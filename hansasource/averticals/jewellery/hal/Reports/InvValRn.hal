external procedure FindAllStocksValueSerialNumber(string,record INVc,val,var val,Date,Integer,Integer,Integer,Integer);
external procedure FindAllStocksValueLIFO(string,record INVc,val,var val,Date,Integer,Integer,Integer,Integer,Integer);
external procedure FindAllStocksValueFIFO(string,record INVc,val,var val,Date,Integer,Integer,Integer,Integer,Integer);
external procedure FindAllStocksValueWA(record INVc,Integer,var val,Date,Integer,Integer,Integer);

//external inner procedure InvListVarieties(record RcVc,record INVc,string,string,string,string,record CostAccBlock,Boolean,var Boolean,
//                                    var Boolean,var string,var val,var val,var val,var val,roundmode,var val,string,vector val);
external inner procedure HTConsigment(Integer, var string);
external inner procedure FindStockValueAtPosition(string,string,string,var record PISVc);
external inner procedure AddSupersessionsInvList(record RcVc,record INVc,string,record CostAccBlock,roundmode,string,var val,var val,var val);
external inner function roundmode GetCostRoundMode(record RoundBlock);
external inner function roundmode DefaultRoundMode();
external inner procedure GetItemCostPrc(record INVc,record CostAccBlock,record ITVc,Integer,var val);
external inner procedure PrintSerialNumbers_InvVal(string,Integer,val,Date,string,Integer); 
external inner function val ConsigmentStockQty(string,string,Date);
external inner function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);
external inner function Integer ArtCodeCostPricePerLocation(string);
external inner function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);
external inner function val GetStockQty(string,string,Date,Boolean);
external inner procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external inner function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external inner function Integer ItemCostPerLocation(record INVc);
external inner function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external inner function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external inner function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external inner function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external inner function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external inner function Boolean FindItemVAR(string,var string,var string,var string,var string);
external inner function val GetStockQty2(string,string,Date,Boolean,Integer);
external inner procedure ExtractObj(string,var Integer,var string);
external inner procedure HTArts(string, string, var string);
external inner procedure HTDepartment(string,var string);
external inner procedure HTArtGroup(string, var string);
external inner procedure HTSupplier(string, var string);
external inner function Integer GetProgramMode();
external inner procedure GetItemGroupDescription(string,var string);
external inner procedure CalcSum(val,val,val,val,var val,Integer);
external inner procedure FindStockValue2(record INVc,string,string,Integer,Date,Integer,Boolean,var val,var val,var val,Integer,Integer,Integer,Integer,Boolean,vector val);
external inner procedure HTCustClass(string,var string);
external inner procedure HTCustClassType(string,var string);
external inner function Boolean SetInSet2(string,string);
external inner procedure ItemClassTypef(string,string,var Boolean);
external inner function Boolean FillItemVarArray(string,string,date,var array string,var array val,var Integer,var string,var string,var string,var string);
external inner procedure CalcCostPrice(val,val,val,Integer,val,var val,var val);

procedure SerialInStock(string item,string ser,string location,var val q)
BEGIN
  record SerBalVc SBr;
  record MainStockBlock MainStockRec;
  
  q = blankval;
  SBr.Item = item;
  SBr.Serial = ser;
  SBr.Location = location;
  if (blank(location)) then begin
    BlockLoad(MainStockRec);
    SBr.Location = MainStockRec.MainStock;
  end;
  if (ReadFirstMain(SBr,3,true)) then begin
    q = SBr.Quant;
  end;
  RETURN;
END;

function val GetSerialNumberPrice(record CostAccBlock CAb,record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,val instock,Integer printf)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueSerialNumber(artcode,INp,instock,restotprice,RepSpec.d1,printf,0,RepSpec.flags[19],RepSpec.flags[12]);
  end else begin
    restotprice = FindCostPriceSerialNumberBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,printf,false,0,RepSpec.flags[12]);
  end;
  GetSerialNumberPrice = restotprice;
  return;
end;

function val GetFIFOPrice(record CostAccBlock CAb,record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,val instock,Integer printf)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueFIFO(artcode,INp,instock,restotprice,RepSpec.d1,printf,0,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
  end else begin
    restotprice = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,printf,false,0,RepSpec.flags[12],RepSpec.flags[20]);
  end;
  GetFIFOPrice = restotprice;
  return;
end;

function val GetLIFOPrice(record CostAccBlock CAb,record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,val instock,Integer printf)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueLIFO(artcode,INp,instock,restotprice,RepSpec.d1,printf,0,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
  end else begin
    restotprice = FindCostPriceLIFOBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,RepSpec.d1,false,printf,false,0,RepSpec.flags[12],RepSpec.flags[20]);
  end;
  GetLIFOPrice = restotprice;
  return;
end;

function val GetWAPrice_Detailed(record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,Integer PerLocation,Integer UseDiscount,val instock)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueFIFO(artcode,INp,instock,restotprice,RepSpec.d1,2,3,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
  end else begin
    restotprice = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,2,false,3,RepSpec.flags[12],RepSpec.flags[20]);
  end;
  GetWAPrice_Detailed = restotprice;
  return;
end;

function val GetBPPrice_Detailed(record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,Integer PerLocation,Integer UseDiscount,val instock)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueFIFO(artcode,INp,instock,restotprice,RepSpec.d1,2,2,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
  end else begin
    restotprice = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,2,false,2,RepSpec.flags[12],RepSpec.flags[20]);
  end;
  GetBPPrice_Detailed = restotprice;
  return;
end;

function val GetCPPrice_Detailed(record RcVc RepSpec,string artcode,record INVc INp,Boolean fManyLocations,Integer PerLocation,Integer UseDiscount,val instock)
begin
  val restotprice;

  if (blank(RepSpec.f2) and fManyLocations) then begin
    FindAllStocksValueFIFO(artcode,INp,instock,restotprice,RepSpec.d1,2,1,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
  end else begin
    restotprice = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,2,false,1,RepSpec.flags[12],RepSpec.flags[20]);
  end;
  GetCPPrice_Detailed = restotprice;
  return;
end;

procedure GetCostPrice(record RcVc RepSpec,record INVc INp,record INVc orgINr,Boolean varf,Boolean fManyLocations,
                       record CostAccBlock CAb,
                       Integer UseDiscount,roundmode roundof,val instock,val instockwithconsig,val orginstock,var val resprice,var val restotprice)
begin
  record WeigAvVc war;
  Integer StockListCostModel;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  val costprc;
  
  GetCostModel(INp,CAb,ITr,primary,queuecostmodel,false);
  
  StockListCostModel = RepSpec.flags[11];
  if (StockListCostModel==0) then begin
    StockListCostModel = primary;
  end;
  if (queuecostmodel==20) then begin
    StockListCostModel = 4;
  end;
  GetItemCostPrc(INp,CAb,ITr,primary,costprc);
  switch (StockListCostModel) begin
    case 1:
      switch (RepSpec.ArtMode) begin
        case 0:    
          if (RepSpec.d1<CurrentDate) and (nonblankdate(RepSpec.d1)) then begin
            resprice = FindCPPriceBackdated(ArtCodeCostPricePerLocation(INp.Code),INp,"",instock,RepSpec.d1,false);                
            restotprice = resprice*instock;
          end else begin          
            CalcCostPrice(instock,INp.InPrice,INp.PriceFactor,UseDiscount,100,resprice,restotprice);
          end;
        case 1:
          restotprice = GetCPPrice_Detailed(RepSpec,INp.Code,INp,fManyLocations,0,UseDiscount,instock);
      end;
    case 2:
      switch (RepSpec.ArtMode) begin
        case 0:    
          CalcCostPrice(instock,INp.UPrice1,INp.PriceFactor,UseDiscount,costprc,resprice,restotprice);
        case 1:
          restotprice = GetBPPrice_Detailed(RepSpec,INp.Code,INp,fManyLocations,WAPerLocation(INp,ITr,CAb),UseDiscount,instock);
      end;
    case 3:
      switch (RepSpec.ArtMode) begin
        case 0:
          if (WAPerLocation(INp,ITr,CAb)!=0) then begin 
            if (nonblank(RepSpec.f2)) then begin
              if (blank(RepSpec.d1) or (RepSpec.d1==CurrentDate)) then begin
                war.ArtCode = INp.Code;
                war.Location = RepSpec.f2;
                if (ReadFirstMain(war,2,true)) then begin
                  CalcCostPrice(instock,war.WeighedAvPrice,INp.PriceFactor,UseDiscount,100,resprice,restotprice);
                end;
              end else begin
                restotprice = FindWAPriceBackdated(1,INp,RepSpec.f2,instock,RepSpec.d1,false,RepSpec.flags[20]);
                CalcCostPrice(instock,restotprice/instock,INp.PriceFactor,UseDiscount,100,resprice,restotprice);
              end;
            end else begin
              FindAllStocksValueWA(orgINr,UseDiscount,restotprice,RepSpec.d1,RepSpec.flags[19],RepSpec.flags[12],RepSpec.flags[20]);
              if (varf) then begin
                resprice = restotprice/orginstock;
                restotprice = instock*resprice;
              end else begin
                resprice = restotprice/instock;
              end;
            end;
          end else begin
            if (blank(RepSpec.d1) or (RepSpec.d1==CurrentDate)) then begin
              CalcCostPrice(instock,INp.WeighedAvPrice,INp.PriceFactor,UseDiscount,100,resprice,restotprice);              
            end else begin
//              restotprice = FindWAPriceBackdated(1,INp,RepSpec.f2,instock,RepSpec.d1,false,RepSpec.flags[20]);
              restotprice = FindCostPriceFIFOBackDated(0,INp,RepSpec.f2,"",instock,0,RepSpec.d1,false,0,false,3,RepSpec.flags[12],RepSpec.flags[20]);
              CalcCostPrice(instock,restotprice/instock,INp.PriceFactor,UseDiscount,100,resprice,restotprice);
            end;
          end;
        case 1:
          restotprice = GetWAPrice_Detailed(RepSpec,INp.Code,INp,fManyLocations,WAPerLocation(INp,ITr,CAb),UseDiscount,instock);
      end;
    case 4:
      switch (RepSpec.ArtMode) begin
        case 0:
          switch (queuecostmodel) begin // What about the others and why checking only CAb?
            case 0: restotprice = GetFIFOPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,0);
            case 1: restotprice = GetLIFOPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,0);
            case 20: 
              restotprice = GetSerialNumberPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,0);
          end;
        case 1:
          switch (queuecostmodel) begin // What about the others and why checking only CAb?
            case 0: restotprice = GetFIFOPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,2);
            case 1: restotprice = GetLIFOPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,2);
            case 20: restotprice = GetSerialNumberPrice(CAb,RepSpec,INp.Code,orgINr,fManyLocations,instock,2);
          end;
      end;

      resprice = restotprice/instockwithconsig;
/*
    case 20:
      switch (RepSpec.ArtMode) begin
        case 0:
          restotprice = GetSerialPrice(CAb,RepSpec,INp,fManyLocations,instock,false);
        case 1:
          restotprice = GetSerialPrice(CAb,RepSpec,INp,fManyLocations,instock,true);
  	    end;
      resprice = restotprice/instock;
*/
  end;            
  resprice = Round(resprice,roundof);
  return;
end;


global
procedure InvListOneItem(record RcVc RepSpec,Integer inpos,record INVc INp,string variety,record CostAccBlock CAb,Boolean printf,
                         var Boolean itemoutp,var Boolean groutp,var string lastgroup,var val sum1p,var val nrp,var val groupqtyp,var val groupsump,roundmode roundof,var val nrq2p,string dblstr,
                         vector val vlocationtotals)
BEGIN
  Integer typ;
  Boolean plhit;
  val upric,zero;
  val instock,t,t2,instock2,consiginstock,instockwithconsig,instockwithconsigsin,instock2sin,totcpsin;
  string 255 tstr;
  record GeneralOptionBlock GOb;
  record INVc orgINr;
  record INVc lINr;
  val orginstock,orginstock2;
  Boolean varf;
  string 60 sz,msk,mskrep;
  string 200 varsubset,itemcode;
  Boolean fManyLocations;
  record MainStockBlock mst;
  record PISVc PISr;

  BlockLoad(mst);
  fManyLocations = false;
  if (CountRecords("LocationVc")>1) then begin
    fManyLocations = true;
  end;
  if (ItemCostPerLocation(INp)==0) then begin
    fManyLocations = false;
  end;
  if (blank(mst.MainStock)) then begin
    fManyLocations = false;
  end;  
  if (FindItemVAR(INp.Code,sz,msk,mskrep,varsubset)) then begin 
    varf = ReadFirstItem(INp.Code,orgINr,false,true);
    if (varf==false) then begin
      RecordCopy(orgINr,INp);
    end;
  end else begin
    RecordCopy(orgINr,INp);
  end;
  
  BlockLoad(GOb);
  if (RepSpec.flags[2]==1) then begin
    if (printf) then begin
    if (lastgroup!=INp.Group) then begin
      if (itemoutp==true) then begin
        if (nonblank(groupsump)) then begin
          Gray_Divider(0,1);
          StartFormat(15);
          OutString(20,0,lastgroup,false);
          GetItemGroupDescription(lastgroup,tstr);
          OutString(100,0,tstr,false);
          OutString(300,0,USetStr(3248),true);
          OutVal(310,0,groupqtyp,M4Qty,true);
          OutVal(480,0,groupsump,M45Val,true);
          EndFormat;
          groupsump = blankval;
          groupqtyp = blankval;
          Gray_Divider(0,1);
        end;
        groutp = false;
      end;  
      lastgroup = INp.Group;
    end;
    end;
  end;
  itemoutp = true;
  upric = INp.UPrice1;
  plhit = true;  

  if (INp.ItemType==1) then begin    
    if (nonblank(variety)) then begin
      if (nonblank(RepSpec.FirstAcc)) then begin
        FindStockValueAtPosition(INp.Code & variety,RepSpec.f2,RepSpec.FirstAcc,PISr);
        instock = PISr.Instock;        
        FindStockValueAtPosition(INp.Code,RepSpec.f2,RepSpec.FirstAcc,PISr);
        orginstock = PISr.Instock;
      end else begin
        instock = GetStockQty(INp.Code & variety,RepSpec.f2,RepSpec.d1,false);
        orginstock = GetStockQty(INp.Code,RepSpec.f2,RepSpec.d1,false);
      end;
      varf = true;
    end else begin
      if (nonblank(RepSpec.FirstAcc)) then begin
        FindStockValueAtPosition(INp.Code,RepSpec.f2,RepSpec.FirstAcc,PISr);
        instock = PISr.Instock;
      end else begin
        instock = GetStockQty(INp.Code,RepSpec.f2,RepSpec.d1,false);
      end;
    end;
    consiginstock = blankval;
    switch (RepSpec.flags[12]) begin
      case 0:  instockwithconsig = instock;
      case 1: 
        consiginstock = ConsigmentStockQty(INp.Code,RepSpec.f2,RepSpec.d1);
        instockwithconsig = instock - consiginstock;
      case 2: 
        consiginstock = ConsigmentStockQty(INp.Code,RepSpec.f2,RepSpec.d1);
        instockwithconsig = consiginstock;
    end;

    if (RepSpec.flags[15]==1) then begin 
      instock2 = GetStockQty2(INp.Code & variety,RepSpec.f2,RepSpec.d1,true,RepSpec.flags[19]);
    end;

    AddSupersessionsInvList(RepSpec,INp,variety,CAb,roundof,dblstr,totcpsin,instockwithconsigsin,instock2sin);
    instockwithconsig = instockwithconsig + instockwithconsigsin;
    instock2 = instock2 + instock2sin;

    
    if (RepSpec.UsedOnly==1) then begin
      if (instockwithconsig==0) then begin
        goto LInvListOneItem;
      end;
    end;
    if (RepSpec.flags[17]!=0) then begin
      if (instock>0) then begin goto LInvListOneItem; end;
    end;
    if (RepSpec.ArtMode==1) begin// Detailed 
      if (printf) then begin
      StartFormat(15);
      OutString(inpos,dblstr,INp.Code & variety,false);
      if (nonblank(variety)) then begin
        ReadFirstItem(INp.Code & variety,lINr,true,false);
        OutString(2,0,lINr.Name,false);
      end else begin
        OutString(2,0,INp.Name,false);
      end;
      OutString(440,0,INp.Unittext,false);
      EndFormat;
      end;
      GetCostPrice(RepSpec,INp,orgINr,varf,fManyLocations,CAb,GOb.UseDiscount,roundof,instock,instockwithconsig,orginstock,t2,t); 
      t = t + totcpsin;
      if (totcpsin>0) then begin
        t2 = t/instockwithconsig;
        t2 = Round(t2,roundof);
      end;
      if (printf) then begin
      Black_Divider(2,1);
      StartFormat(15);
      OutVal(3,0,instockwithconsig,M4UVal,true);
      OutVal(4,0,t/instockwithconsig,M45Val,true);
      if (RepSpec.flags[15]==1) then begin 
        OutVal(350,0,instock2,M4UVal,true);
      end;  
      typ = M45Val;
      if ((RepSpec.flags[16]!=0) or (roundof.decimals==2)) then begin
        t = Round(t,DefaultRoundMode);
        typ = M4Val;
      end;
      OutVal(1,0,t,typ,true);
      EndFormat;
      if (RepSpec.flags[10]!=0) then begin
        PrintSerialNumbers_InvVal(INp.Code,INp.ItemType,instock,RepSpec.d1,RepSpec.f2,RepSpec.flags[12]);
      end;  
      Gray_Divider(0,1);
      end;
      sum1p = sum1p + t;
      nrp = nrp + instockwithconsig;
      groupsump = groupsump +t;
      groupqtyp = groupqtyp + instockwithconsig;
      nrq2p = nrq2p + instock2;      
    end;
    if (RepSpec.ArtMode==0) then begin// Overview     
      GetCostPrice(RepSpec,INp,orgINr,varf,fManyLocations,CAb,GOb.UseDiscount,roundof,instock,instockwithconsig,orginstock,t2,t);
      t = t + totcpsin;
      if (totcpsin>0) then begin
        t2 = t/instockwithconsig;
        t2 = Round(t2,roundof);
      end;
      if (printf) then begin
        if (RepSpec.PocketPC==0) then begin//here
          StartFormat(15);
          OutString(inpos,dblstr,INp.Code & variety,false);
          OutStringID(2,"DblINVc",Left(INp.Name,40),false,INp.Code);
          OutString(5,0,INp.Unittext,false);
          OutImage(230,100,30,INp);
          OutVal(3,0,instockwithconsig,M4UVal,true);
          if (RepSpec.flags[15]==1) then begin
            OutVal(350,0,instock2,M4UVal,true);
          end;
        end else begin
          StartFormat(15);
          OutString(inpos,dblstr,INp.Code & variety,false);
          OutString(2,0,left(INp.Name,15),false);
          OutVal(3,0,instock,M4UVal,true);
        end;
        if (RepSpec.PocketPC == 0) then begin
          OutVal(4,0,t2,M45Val,true);
        end;
        typ = M45Val;
        if ((RepSpec.flags[16]!=0) or (roundof.decimals==2)) then begin
          t = Round(t,DefaultRoundMode);
          typ = M4Val;
        end;
        OutVal(1,0,t,typ,true);
        EndFormat;
      end;
/*      
      if (RepSpec.flags[11]==3) then begin
        StartFormat(15);
        OutString(3,0,USetStr(2350),true);
        OutVal(4,0,t2,M45Val,true);
        typ = M45Val;
        if ((RepSpec.flags[16]!=0) or (roundof.decimals==2)) then begin
          t = Round(t,DefaultRoundMode);
          typ = M4Val;
        end;
        OutVal(1,0,t,typ,true);        
        EndFormat;
        StartFormat(5);
        EndFormat;
      end;
*/      
      sum1p = sum1p + t;
      nrp = nrp + instockwithconsig;
      nrq2p = nrq2p + instock2;
      groupsump = groupsump + t;
      groupqtyp = groupqtyp + instockwithconsig;
      if (printf) then begin
      if (RepSpec.flags[10]!=0) then begin
        PrintSerialNumbers_InvVal(INp.Code,INp.ItemType,instock,RepSpec.d1,RepSpec.f2,RepSpec.flags[12]); 
      end;  
      end;
    end;
    if (RepSpec.ArtMode==2) then begin// Per location          
      if (printf) then begin
      StartFormat(15);
      OutString(inpos,dblstr,INp.Code & variety,false);
      OutString(2,0,INp.Name,false);
      OutString(4,0,INp.Unittext,false);
      EndFormat;
      end;
      FindStockValue2(INp,variety,RepSpec.f2,RepSpec.flags[1],RepSpec.d1,RepSpec.flags[14],fManyLocations,t,instock,instock2,RepSpec.flags[15],RepSpec.flags[11],RepSpec.flags[12],RepSpec.flags[20],true,vlocationtotals);
      
      if (printf) then begin
      Black_Divider(2,1);      
      StartFormat(15);
      OutVal(3,0,instockwithconsig,M4UVal,true);
      if (RepSpec.flags[15]!=0) then begin
        OutVal(350,0,instock2,M4UVal,true);
      end;
      OutVal(4,0,t/instock,M45Val,true);
      typ = M45Val;
      if ((RepSpec.flags[16]!=0) or (roundof.decimals==2)) then begin
        t = Round(t,DefaultRoundMode);
        typ = M4Val;
      end;
      OutVal(1,0,t,typ,true);
      EndFormat;
      end;      
      sum1p = sum1p + t;
      nrp = nrp + instockwithconsig;
      groupsump = groupsump + t;
      groupqtyp = groupqtyp + instockwithconsig;
      nrq2p = nrq2p + instock2;
      if (printf) then begin
      Gray_Divider(0,1);
      if (RepSpec.flags[10]!=0) then begin
        PrintSerialNumbers_InvVal(INp.Code,INp.ItemType,instock,RepSpec.d1,RepSpec.f2,RepSpec.flags[12]);
      end;  
      end;
    end;
    if (RepSpec.ArtMode==3) then begin// Location Totals     
      FindStockValue2(INp,variety,RepSpec.f2,RepSpec.flags[1],RepSpec.d1,1,fManyLocations,t,instock,instock2,RepSpec.flags[15],RepSpec.flags[11],RepSpec.flags[12],RepSpec.flags[20],false,vlocationtotals);
      
      sum1p = sum1p + t;
      nrp = nrp + instockwithconsig;
      groupsump = groupsump + t;
      groupqtyp = groupqtyp + instockwithconsig;
      nrq2p = nrq2p + instock2;
    end;
  end;
LInvListOneItem:;
  RETURN;
END;

procedure InvListVarieties(record RcVc RepSpec,record INVc INr,record CostAccBlock CAb,Boolean printf,var Boolean itemoutp,
  var Boolean groutp,var string lastgroup,var val sum1p,var val nrp,var val groupqtyp,var val groupsump,roundmode roundof,var val nrq2p,string dblstr,
  vector val vlocationtotals)
begin
  Array string 20 items;
  Array val itemqty;
  string 60 sz,msk,mskrep;
  string 200 varsubset,variety;
  Integer i,isrs;
  
  if (FillItemVarArray(INr.Code,RepSpec.f2,RepSpec.d1,items,itemqty,isrs,sz,msk,mskrep,varsubset)) then begin
    for (i = 0; i < isrs; i = i + 1) begin
      variety = Right(items[i],Len(items[i]) - Len(INr.Code));
      InvListOneItem(RepSpec,0,INr,variety,CAb,true,itemoutp,groutp,lastgroup,sum1p,nrp,groupqtyp,groupsump,roundof,nrq2p,dblstr,vlocationtotals);
    end;
  end;
  return;
end;

procedure ShowSupersessionItems(record RcVc RepSpec,record INVc INp,string variety,record CostAccBlock CAb,
                         var Boolean itemout,var Boolean grout,var string lastgroup,var val sum1p,var val nrp,var val groupqty,var val groupsum,roundmode roundof,var val nrq2p,string dblstr,
                         vector val vlocationtotals)
begin
  record SupersessionINVc SINr;
  record INVc INr;
  Boolean found;

  found = true;
  SINr.NewArtCode = INp.Code;
  while (LoopKey("ActNewArtCode",SINr,1,found)) begin
    if (SINr.NewArtCode!=INp.Code) then begin found = false; end;
    if (found) then begin
      INr.Code = SINr.OldArtCode;
      if (ReadFirstMain(INr,1,true)) then begin
        InvListOneItem(RepSpec,12,INr,"",CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
      end;
    end;
  end;
  return;
end;

function Boolean TestSummarisedStock(record INVc INr,Integer sumf)
begin
  Boolean res;
  record AutoProdVc AutoProdr;
  
  res = true;
  if (sumf==1) then begin
    AutoProdr.FromItemCode = INr.Code;
    if (ReadFirstMain(AutoProdr,1,true)) then begin
      if (nonblank(AutoProdr.ToItemCode)) then begin
        res = false;
      end;
    end;
  end else begin
    AutoProdr.Default = 1;
    AutoProdr.ToItemCode = INr.Code;
    if (ReadFirstKey("Default",AutoProdr,2,true)) then begin
      if (nonblank(AutoProdr.FromItemCode)) then begin
        res = false;
      end;
    end;
  end;
  TestSummarisedStock = res;
  return;
end;

procedure ILLoopIS(record RcVc RepSpec,var val sum1p,var val nrp,roundmode roundof,var val nrq2p,vector val vlocationtotals)
BEGIN
  record PIVc PIr;
  record INVc INr;
  record ItemStatusVc ISr;
  string 255 lastgroup;
  Boolean itemout,grout;
  Boolean testf;
  string 255 fromart,toart;
  string 255 frvariety,tovariety;
  string 255 frcc,tocc;
  Boolean TrHs,found,ShowVarieties;
  string 255 lastitem,dblstr;
  val groupsum,groupqty;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;  
  record CostAccBlock CAb;
  string 255 keystr;
  Integer keys;
  record ItemSettingBlock ISb;
  record SupersessionINVc SINr;

  BlockLoad(CAb);
  BlockLoad(ISb);
  itemout = false;
  grout = false;
  fromart = FirstInRange(RepSpec.f1,20);  
  toart = LastInRange(RepSpec.f1,20);
  if (nonblank(fromart)) then begin
    if (ReadFirstItem(fromart,INr,false,false)) then begin
      frvariety = right(fromart,len(fromart)-len(INr.Code));
      fromart = INr.Code;
    end;
  end;
  if (nonblank(toart)) then begin
    if (ReadFirstItem(toart,INr,false,false)) then begin
      tovariety = right(toart,len(toart)-len(INr.Code));
      toart = INr.Code;
    end;
  end;
  
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);  
  Gray_Divider(0,1);
  TrHs = true;
  keys = 1;
  keystr = "Code";
  ISr.Code = fromart;    
  if (nonblank(frvariety)) or (nonblank(tovariety)) then begin
    keys = 1;
    keystr = "CodeVariety";
    ISr.Variety = frvariety;    
  end;
  while (LoopKey(keystr,ISr,keys,TrHs)) begin  
    if (ReadFirstItemInclClosed(ISr.Code,INr,false,false)==false) then begin goto LILLoopISEnd; end;
    if (INr.Code==lastitem) then begin goto LILLoopISEnd; end;
//    ISr.Code = INr.Code; // ??

    lastitem = INr.Code;
    testf = true;
    if (RepSpec.flags[18]==0) then begin
      if (INr.Terminated!=0) then begin
      	testf = false;
      end;
    end;
    if (nonblank(frvariety)) or (nonblank(tovariety)) then begin
      if (ISr.Variety>tovariety) then begin TrHs = false; end;
    end;    
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          if (RepSpec.flags[2]==1) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;  
      end;   
    end;        
    if (TrHs) then begin
      if (nonblank(toart)) then begin 
        if (INr.Code>toart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
      if (nonblank(fromart)) then begin
        if (INr.Code<fromart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;
    if (TrHs==false) then begin testf = false; end;
    if (testf) then begin
      if (nonblank(RepSpec.AccStr)) then begin
        if (INr.Department!=RepSpec.AccStr) then begin
          testf = false;
        end;
      end;    
    end;
    if (testf) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group<frcc) then begin
          testf = false;
        end;
      end;
    end;      
    if (testf) then begin
      if (nonblank(RepSpec.LastAcc)) then begin
        PIr.ItemCode = INr.Code;
        PIr.Location = RepSpec.f2;
        PIr.VECode = RepSpec.LastAcc;
        found = ReadFirstMain(PIr,3,true);
        if (found==false) then begin
          if (nonblank(RepSpec.f2)) then begin
            PIr.ItemCode = INr.Code;
            PIr.Location = "";
            PIr.VECode = RepSpec.LastAcc;
            found = ReadFirstMain(PIr,3,true);
          end;
        end;
        if (found) then begin
          if (PIr.ItemCode!=INr.Code) then begin testf = false; end;
          if (PIr.VECode!=RepSpec.LastAcc) then begin testf = false; end;
          if (PIr.DefaultChoice==0) then begin testf = false; end;
        end else begin
          testf = false;
        end;
      end;
    end;
    if (testf) then begin
      if (nonblank(RepSpec.f4)) then begin
        if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
          testf = false;
        end;
      end;
      if (nonblank(RepSpec.f5)) then begin
        if (testf) then begin
          testf = false;
          ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
        end;
      end;
    end;
    if (RepSpec.flags[19]>0) then begin
      if (TestSummarisedStock(INr,RepSpec.flags[19])==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      if (ISb.UseSupersessionIN!=0) then begin
        switch (RepSpec.flags[21]) begin
          case 0:
            SINr.OldArtCode = INr.Code;
            if (ReadFIrstMain(SINr,1,true)) then begin
              testf = false;
            end;
          case 1:
            SINr.OldArtCode = INr.Code;
            if (ReadFIrstMain(SINr,1,true)) then begin
              testf = false;
            end;
        end;
      end;
    end;
    if (testf) then begin
      dblstr = "";
      ShowVarieties = false;
      if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin
        dblstr = "VarMaskVarDbl";
        if (RepSpec.flags[22]!=0) then begin
          ShowVarieties = true;
          dblstr = "";
        end;
      end;
      if (ShowVarieties) then begin
        InvListVarieties(RepSpec,INr,CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
      end else begin
        if (nonblank(frvariety)) then begin
          InvListOneItem(RepSpec,0,INr,ISr.Variety,CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
        end else begin
          InvListOneItem(RepSpec,0,INr,"",CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
        end;
        if (ISb.UseSupersessionIN!=0) then begin
          switch (RepSpec.flags[21]) begin
            case 1:        
              ShowSupersessionItems(RepSpec,INr,"",CAb,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);    
          end;
        end;
      end;
    end;
LILLoopISEnd:;
  end;
  RETURN;
END;

procedure ILLoopINDICode(record RcVc RepSpec,var val sum1p,var val nrp,roundmode roundof,var val nrq2p,vector val vlocationtotals)
BEGIN
  record PIVc PIr;
  record INVc INr;
  record DIVc DIr;
  Boolean found,TrHs,testf,ShowVarieties;
  string 255 frart,toart;
  string 255 frit,toit;
  string 255 dblstr;
  string 60 sz,msk,mskrep;
  string 200 varsubset;
  string 255 lastgroup;
  Boolean itemout,grout,foundpi;
  val groupsum,groupqty;
  record CostAccBlock CAb;
  record ItemSettingBlock ISb;
  record SupersessionINVc SINr;

  BlockLoad(CAb);
  BlockLoad(ISb);
  frart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frit = FirstInRange(RepSpec.f3,20);
  toit = LastInRange(RepSpec.f3,20);  
  found = true;
  DIr.CType = RepSpec.f5;
  while (LoopKey("CType",DIr,1,found)) begin
    if (DIr.CType!=RepSpec.f5) then begin found = false; end;
    if (found) then begin
      ResetLoop(INr);
      TrHs = true;
      while (LoopKey("DICode:" & DIr.Code,INr,1,TrHs)) begin    
        testf = true;
        if (RepSpec.flags[18]==0) then begin
          if (INr.Terminated!=0) then begin
          	testf = false;
          end;
        end;
        if (TrHs) then begin
          if (nonblank(RepSpec.f3)) then begin
            if (INr.Group<frit) then begin testf = false; end;
            if (INr.Group>toit) then begin testf = false; end;
          end;
        end;        
        if (TrHs) then begin
          if (nonblank(toart)) then begin
            if (INr.Code<frart) then begin testf = false; end;
            if (INr.Code>toart) then begin testf = false; end;
          end;
        end;        
        if (TrHs) then begin
          if (nonblank(RepSpec.AccStr)) then begin
            if (INr.Department!=RepSpec.AccStr) then begin
              testf = false;
            end;
          end;    
        end;
        if (TrHs) then begin
          if (nonblank(RepSpec.LastAcc)) then begin
            PIr.ItemCode = INr.Code;
            PIr.Location = RepSpec.f2;
            PIr.VECode = RepSpec.LastAcc;
            foundpi = ReadFirstMain(PIr,3,true);
            if (foundpi==false) then begin
              if (nonblank(RepSpec.f2)) then begin
                PIr.ItemCode = INr.Code;
                PIr.Location = "";
                PIr.VECode = RepSpec.LastAcc;
                foundpi = ReadFirstMain(PIr,3,true);
              end;
            end;
            if (foundpi) then begin
              if (PIr.ItemCode!=INr.Code) then begin testf = false; end;
              if (PIr.VECode!=RepSpec.LastAcc) then begin testf = false; end;
              if (PIr.DefaultChoice==0) then begin testf = false; end;
            end else begin
              testf = false;
            end;
          end;
        end;
        if (TrHs==false) then begin testf = false; end;
        if (nonblank(RepSpec.f4)) then begin
          if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
            testf = false;
          end;
        end;
        if (testf) then begin
          if (nonblank(RepSpec.f5)) then begin
            if (testf) then begin
              testf = false;
              ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
            end;
          end;
        end;
        if (testf) then begin
          if (ISb.UseSupersessionIN!=0) then begin
            switch (RepSpec.flags[21]) begin
              case 0:
                SINr.OldArtCode = INr.Code;
                if (ReadFIrstMain(SINr,1,true)) then begin
                  testf = false;
                end;
              case 1:
                SINr.OldArtCode = INr.Code;
                if (ReadFIrstMain(SINr,1,true)) then begin
                  testf = false;
                end;
            end;
          end;
        end;
        if (testf) then begin
          dblstr = "";
          ShowVarieties = false;
          if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin
            dblstr = "VarMaskVarDbl";
            if (RepSpec.flags[22]!=0) then begin
              ShowVarieties = true;
              dblstr = "";
            end;
          end;
          if (ShowVarieties) then begin
            InvListVarieties(RepSpec,INr,CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
          end else begin
            InvListOneItem(RepSpec,0,INr,"",CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
            if (ISb.UseSupersessionIN!=0) then begin
              switch (RepSpec.flags[21]) begin
                case 1:        
                  ShowSupersessionItems(RepSpec,INr,"",CAb,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);    
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure ILLoopIN(record RcVc RepSpec,var val sum1p,var val nrp,roundmode roundof,var val nrq2p,vector val vlocationtotals)
BEGIN
  record PIVc PIr;
  record INVc INr;
  record DIVc DIr;
  Integer keys;
  string 255 dblstr;
  string 255 lastgroup;
  string 255 fromart,toart;
  string 255 frcc,tocc;
  string 255 tstr;
  string 255 ckey;
  Boolean itemout,grout,foundpi;
  Boolean TrHs,testf;
  val groupsum,groupqty;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  string 10 clcode;
  string 60 clname;
  boolean TrHs1,testf1,ShowVarieties;
  record CostAccBlock CAb;

  BlockLoad(CAb);
  Gray_Divider(0,1);
  itemout = false;
  grout = false;
  fromart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);  
  if (RepSpec.flags[2]==0) then begin
    INr.Code = fromart;
    ckey = "Code";
    keys = 1;
  end;
  if (RepSpec.flags[2]==1) then begin
    INr.Group = frcc;
    INr.Code = fromart;
    ckey = "Group";
    keys = 2;
  end;
  if (RepSpec.flags[2]==2) then begin
    INr.Name = "";
    INr.Code = "";
    ckey = "Name";
    keys = 1;
  end;
  if (RepSpec.flags[2]==3) then begin
    INr.Code = fromart;
    INr.BarCode = "";
    ckey = "BarCode";
    keys = 2;
  end;
  if (RepSpec.flags[2]==4) then begin
    INr.Code = fromart;
    ckey = "DICode";
    keys = 1;
    ILLoopINDICode(RepSpec,sum1p,nrp,roundof,nrq2p,vlocationtotals);
    goto LILLoopIN;
  end;
  
  Gray_Divider(0,1);
  TrHs = true;
  while (LoopKey(ckey,INr,keys,TrHs)) begin    
    testf = true;
    if (RepSpec.flags[18]==0) then begin
      if (INr.Terminated!=0) then begin
      	testf = false;
      end;
    end;
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          if (RepSpec.flags[2]==1) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs) then begin
      if (nonblank(toart)) then begin
        if (INr.Code>toart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
      if (nonblank(fromart)) then begin
        if (INr.Code<fromart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs==false) then begin testf = false; end;
    if (testf) then begin
      if (nonblank(RepSpec.AccStr)) then begin
        if (INr.Department!=RepSpec.AccStr) then begin
          testf = false;
        end;
      end;    
    end;
    if (testf) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group<frcc) then begin
          testf = false;
        end;
      end;
    end;      
    if (testf) then begin
      if (nonblank(RepSpec.LastAcc)) then begin
        PIr.ItemCode = INr.Code;
        PIr.Location = RepSpec.f2;
        PIr.VECode = RepSpec.LastAcc;
        foundpi = ReadFirstMain(PIr,3,true);
        if (foundpi==false) then begin
          if (nonblank(RepSpec.f2)) then begin
            PIr.ItemCode = INr.Code;
            PIr.Location = "";
            PIr.VECode = RepSpec.LastAcc;
            foundpi = ReadFirstMain(PIr,3,true);
          end;
        end;
        if (foundpi) then begin
          if (PIr.ItemCode!=INr.Code) then begin testf = false; end;
          if (PIr.VECode!=RepSpec.LastAcc) then begin testf = false; end;
          if (PIr.DefaultChoice==0) then begin testf = false; end;
        end else begin
          testf = false;
        end;
      end;
    end;
    if (testf) then begin
      if (nonblank(RepSpec.f4)) then begin
        if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
          testf = false;
        end;
      end;
      if (nonblank(RepSpec.f5)) then begin
        if (testf) then begin
          testf = false;
          ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
        end;
      end;
    end;
    if (RepSpec.flags[19]>0) then begin
      if (TestSummarisedStock(INr,RepSpec.flags[19])==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      dblstr = "";
      ShowVarieties = false;
      if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin
        dblstr = "VarMaskVarDbl";
        if (RepSpec.flags[22]!=0) then begin
          ShowVarieties = true;
          dblstr = "";
        end;
      end;
      if (ShowVarieties) then begin
        InvListVarieties(RepSpec,INr,CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
      end else begin
        InvListOneItem(RepSpec,0,INr,"",CAb,true,itemout,grout,lastgroup,sum1p,nrp,groupqty,groupsum,roundof,nrq2p,dblstr,vlocationtotals);
      end;
    end;
  end;
  if (RepSpec.flags[2]==1) then begin
    Gray_Divider(0,1);
    StartFormat(15);
    OutString(20,0,lastgroup,false);
    GetItemGroupDescription(lastgroup,tstr);
    OutString(100,0,tstr,false);
    OutString(300,0,USetStr(3248),true);
    OutVal(480,0,groupsum,M45Val,true);
    groupsum = 0;
    EndFormat;
    Gray_Divider(0,1);
  end;
LILLoopIN:;
  RETURN;
END;

global
procedure InvValRn(record RcVc RepSpec)
begin
  record RoundBlock RoundRec;
  record CostAccBlock CAb;
  record MainStockBlock mst;
  val nr,nrq2;
  val sum1,sum2;
  Integer vatflag;
  string 255 tstr;
  Integer rw;
  vector val vlocationtotals;
  Boolean found;
  record LocationVc Locr;
  
  BlockLoad(mst);
  BlockLoad(CAb);
  BlockLoad(RoundRec);
  vatflag = 0;
  StartReportJob(USetStr(2322));
  if (RepSpec.PocketPC == 0) then begin
    rw = 1;
    if ((nonblank(RepSpec.f1)) or (blank(RepSpec.AccStr))) then begin
      HTArts(RepSpec.f1,RepSpec.f1,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.AccStr)) then begin
      HTDepartment(RepSpec.AccStr,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.f2)) then begin
      tstr = USetStr(2768);
      tstr = RepSpec.f2;
      Header(rw,tstr,0);
    end;
    HTArtGroup(RepSpec.f3,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.FirstAcc)) then begin
      tstr = USetStr(2779) & " " & RepSpec.FirstAcc;
      Header(rw,tstr,0);
    end;
    HTCustClass(RepSpec.f4,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end; 
    HTCustClassType(RepSpec.f5,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end; 
    if (nonblank(RepSpec.LastAcc)) then begin
      HTSupplier(RepSpec.LastAcc,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if ((GetProgramMode!=typFirstOffice) and
        (GetProgramMode!=typBooks) and
        (GetProgramMode!=typBooksPro) and
        (GetProgramMode!=typBooksProAdv) and
        (GetProgramMode!=typBooksJobCost) and
        (GetProgramMode!=typBooksAcc) and
        (GetProgramMode!=typBooksPOS)) then begin //?? CHECKBOOKSFUNC
      if (RepSpec.flags[1]==0) then begin
        tstr = USetStr(2345); 
      end;  
      if (RepSpec.flags[1]==1) then begin
        tstr = USetStr(2346);      
      end;  
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblankdate(RepSpec.d1)) then begin
      tstr = RepSpec.d1;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    HTConsigment(RepSpec.flags[12],tstr);
    Header(rw,tstr,0);
    switch (RepSpec.flags[11]) begin
      case 0: 
        switch (CAb.PrimaryCostModel) begin
          case 4:
            tstr = USetStr(10554 + CAb.QueuedCostModel);
          otherwise
            tstr = USetStr(10550 + CAb.PrimaryCostModel);
        end;      
      case 1: tstr = USetStr(10550+RepSpec.flags[11]);
      case 2: tstr = USetStr(10550+RepSpec.flags[11]);
      case 3: tstr = USetStr(10550+RepSpec.flags[11]);
      otherwise 
/*wierd      
        switch (CAb.PrimaryCostModel) begin
          case 4:
            tstr = USetStr(10554 + CAb.QueuedCostModel);
          otherwise
            tstr = USetStr(10550 + CAb.PrimaryCostModel);
        end;
*/        
        tstr = USetStr(10554 + CAb.QueuedCostModel);
    end;
    Header(rw,USetStr(10549) & ": " & tstr,1);
    rw = rw + 1;
  end else begin
  end;
  EndHeader;
  if (blank(RepSpec.f5) and (RepSpec.flags[2]==4)) then begin
    StartFormat(15);
    OutString(140,0,USetStr(20098),false);
    EndFormat;  
    goto LInvValRn;
  end;
  switch (RepSpec.ArtMode) begin
    case 0:
      if (RepSpec.PocketPC== 0) then begin
        SetRepCol(2,70);
        SetRepCol(3,360);
        SetRepCol(4,410);
        SetRepCol(5,200);
      end else begin
        SetRepCol(2,100);
        SetRepCol(3,380);
        SetRepCol(4,400);
        SetRepCol(5,240);
      end;
    otherwise
      if (RepSpec.PocketPC== 0) then begin
        SetRepCol(2,70);
        SetRepCol(3,310);
        SetRepCol(4,400);
        SetRepCol(5,240);
      end else begin
        SetRepCol(2,100);
        SetRepCol(3,380);
        SetRepCol(4,400);
        SetRepCol(5,240);
      end;
  end;
  if ((RepSpec.ArtMode==0) or (RepSpec.ArtMode==2)) then begin
    if (RepSpec.PocketPC== 0) then begin
      StartFormat(15);
      OutString(0,0,USetStr(2325),false);
      OutString(2,0,USetStr(2326),false);
      OutString(3,0,USetStr(2330),true);
      if (RepSpec.flags[15]==1) then begin
        OutString(350,0,USetStr(7593),true);
      end;  
      switch (RepSpec.flags[11]) begin
        case 1: OutString(4,0,USetStr(10551),true);
        case 2: OutString(4,0,USetStr(10552),true);
        otherwise OutString(4,0,USetStr(2331),true);
      end;
      OutString(1,0,USetStr(2332),true);
      EndFormat;
    end else begin
      StartFormat(15);
      OutString(0,0,USetStr(2325),false);
      OutString(2,0,USetStr(2326),false);
      OutString(3,0,USetStr(2330),true);
      OutString(1,0,USetStr(2332),true);
      EndFormat;
    end;
  end;  
  if (RepSpec.ArtMode==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(2325),false);
    OutString(2,0,USetStr(2326),false);
    OutString(440,0,USetStr(2327),false);
    EndFormat;
    StartFormat(15);
    OutString(50,0,USetStr(2344),false);
    OutString(3,0,USetStr(2330),true);
    if (RepSpec.flags[15]==1) then begin
      OutString(350,0,USetStr(7593),true);
    end;  
    if (RepSpec.flags[11]==1) then begin
      OutString(4,0,USetStr(2350),true);
    end else begin
      OutString(4,0,USetStr(2331),true);
    end;
    OutString(1,0,USetStr(2332),true);
    EndFormat;
  end;
  if (RepSpec.ArtMode==3) then begin
    StartFormat(15);
    OutString(0,0,USetStr(5010),false);
    OutString(5,0,USetStr(5279),true);
    OutString(340,0,USetStr(5288),true);
    EndFormat;
  end;
  
  if ((RepSpec.flags[2]==0) and (RepSpec.UsedOnly!=0) and (blankdate(RepSpec.d1))) then begin  
    ILLoopIS(RepSpec,sum1,nr,GetCostRoundMode(RoundRec),nrq2,vlocationtotals);
  end else begin  
    ILLoopIN(RepSpec,sum1,nr,GetCostRoundMode(RoundRec),nrq2,vlocationtotals);
  end;
  if (RepSpec.ArtMode==3) then begin
    sum1 = blankval; sum2 = blankval;
    Locr.Code = RepSpec.f2;
    found = true;
    while (LoopMain(Locr,1,found)) begin
      if (nonblank(RepSpec.f2)) then begin
        if (Locr.Code!=RepSpec.f2) then begin found = false; end;
      end;
      if (found) then begin
        if (vlocationtotals[Locr.Code]!=0) then begin
          StartFormat(15);
          OutString(0,0,Locr.Code,false);
          OutVal(5,0,vlocationtotals[Locr.Code],M4UVal,true);
          OutVal(340,0,vlocationtotals[Locr.Code & ":" & "VALUE"],M4Val,true);
          sum1 = sum1 + vlocationtotals[Locr.Code];
          sum2 = sum2 + vlocationtotals[Locr.Code & ":" & "VALUE"];
          EndFormat;
        end;
      end;
    end;
    Gray_Divider(0,1);
    StartFormat(15);
    OutVal(5,0,sum1,M4UVal,true);
    OutVal(340,0,sum2,M4Val,true);
    EndFormat;
  end else begin
    if (RepSpec.ArtMode==0) then begin
      Gray_Divider(0,1);
    end;  
    StartFormat(15);
    OutVal(3,0,nr,M4UVal,true);
    if (RepSpec.flags[15]==1) then begin  
      OutVal(350,0,nrq2,M4UVal,true);
    end;  
    OutVal(1,0,sum1,M45Val,true);
    EndFormat;
  end;
LInvValRn:; 
  EndJob;
  return;
end;
