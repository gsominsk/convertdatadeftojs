external procedure PMsgStack_ModeProgramming(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_ReceiptOpen(record LSerialPortDeviceVc,var array string,integer);
external procedure PMsgStack_ChangeModeEx(record LSerialPortDeviceVc,var array string,integer,string);
external procedure PMsgStack_ReceiptClose(record LSerialPortDeviceVc,var array string,integer,val);
external procedure PMsgStack_AddDiscount(record LSerialPortDeviceVc,var array string,integer,integer,integer,Val);
external procedure PMsgStack_ReceiptAddPayment(record LSerialPortDeviceVc,var array string,integer,val,integer);
external function boolean PMsgSend(record LSerialPortDeviceVc,var array string,var array string);
external function integer PMsgOpen(record LSerialPortDeviceVc);
external function boolean PMsgWrite(record LSerialPortDeviceVc,var array string,var array string);
external function boolean PMsgWriteDeaf(record LSerialPortDeviceVc,var array string);
external function boolean PMsgSendDeaf(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_MoneyWithdraw(record LSerialPortDeviceVc,var array string,val);
external procedure PMsgStack_AddReturnSumQty(record LSerialPortDeviceVc,var array string,val,val,val);
external procedure PMsgClose(integer);
external procedure PMsgStack_PrintLine(record LSerialPortDeviceVc,var array string,String);
external function roundmode SetRoundModeD(Integer);
external procedure PMsgStack_ReceiptCancel(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_Report(record LSerialPortDeviceVc,var array string,integer);
external procedure PMsgStack_Feed(record LSerialPortDeviceVc,var array string,integer);
external procedure PMsgStack_StatusRequest(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_CloseShift(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_GetVatValue(record LSerialPortDeviceVc,var array string,integer);
external procedure PMsgAnswersCollectValues(string,string,array string,var array string);
external function Integer StrArrayCnt(array string);
external procedure PMsgStack_AddSalesSumQty(record LSerialPortDeviceVc,var array string,val,val,val);
external procedure PMsgStack_MoneyDeposit(record LSerialPortDeviceVc,var array string,val);
external procedure PMsgStack_PrintMultiLine(record LSerialPortDeviceVc,var array string,String);
external procedure PMsgStack_GetNextDocumentNumber(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_OpenCashDrawer(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_StatusCode(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_Diagnostics(record LSerialPortDeviceVc,var array string);
external procedure PMsgStack_SetDate(record LSerialPortDeviceVc,var array string,date);
external procedure PMsgStack_SetTime(record LSerialPortDeviceVc,var array string,time);
external procedure PMsgStack_ReportMonthly(record LSerialPortDeviceVc,var array string,integer,date);
external procedure PMsgStack_FiscalReportDateRange(record LSerialPortDeviceVc,var array string,date,date,integer);
external procedure PMsgStack_YearlyReport(record LSerialPortDeviceVc,var array string,integer,date);
external procedure PMsgStack_OpenShift(record LSerialPortDeviceVc,var array string,string);
external procedure PMsgStack_ResetCashierNames(record LSerialPortDeviceVc,var array string);
external procedure GetUserName(string,var string);

global
function boolean PMsg_GetDate(record LSerialPortDeviceVc LSPDr,var date d)
begin
  boolean res;
  array string 255 msgstack,answers;

  // [TODO/] Do so that all Stacking functions return -1 when the function is not present for that printer
  PMsgStack_StatusRequest(LSPDr,msgstack);
  if (PMsgSend(LSPDr,msgstack,answers)) then begin
    d = answers[PMsgVar_Date];
    if (NonBlankDate(d)) then begin
      res = true;
    end;
  end;
  
  PMsg_GetDate = res;
  return;
end;

global
function longint PMsg_GetDecimals(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack,answers;

  PMsgStack_StatusRequest(LSPDr,msgstack);
  PMsgSend(LSPDr,msgstack,answers);
  if(answers[PMsgVar_Decimals]!="") then begin
    PMsg_GetDecimals = StringToInt(answers[PMsgVar_Decimals]);
  end;

  return;
end;


global
procedure PMsg_TerminateReceipt(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;

  PMsgStack_ReceiptCancel(LSPDr,msgstack);
  PMsgWriteDeaf(LSPDr,msgstack)
  return;
end;

global
procedure PMsg_Diagnostics(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;

  PMsgStack_Diagnostics(LSPDr,msgstack);
  PMsgWriteDeaf(LSPDr,msgstack)
  return;
end;

procedure PMsg_OneStatusLine(string name,string value)
begin
  if(nonblank(value)) then begin
    StartFormat(16);
        OutString(0,0,name,false);
        OutString(2,0,value,false);
    EndFormat;
  end;
  return;
end;

global
function boolean PMsg_IsShiftOpen(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack,answers;

  PMsgStack_StatusRequest(LSPDr,msgstack);
  PMsgWrite(LSPDr,msgstack,answers);
  if(StringToInt(answers[PMsgVar_ShiftOpened])!=0) then begin
    PMsg_IsShiftOpen = true;
  end;
  return;
end;

global
procedure PMsg_OpenCashDrawer(record LSerialPortDeviceVc LSPDr,boolean opendrawerf)
begin
  array string 255 msgstack;

  if(opendrawerf) then begin
    PMsgStack_OpenCashDrawer(LSPDr,msgstack);
    PMsgWriteDeaf(LSPDr,msgstack);
  end;

  return;
end;

global
procedure PMsg_MonthlyReport(record LSerialPortDeviceVc LSPDr,date rdate)
begin
  array string 255 msgstack;

  if(PMsg_IsShiftOpen(LSPDr)) then begin
    MessageBox(0,USetstr(30210));
    return;
  end;

  PMsgStack_ReportMonthly(LSPDr,msgstack,1,rdate);
  PMsgWriteDeaf(LSPDr,msgstack);
  return;
end;

global
procedure PMsg_YearlyReport(record LSerialPortDeviceVc LSPDr,date rdate)
begin
  array string 255 msgstack;

  if(PMsg_IsShiftOpen(LSPDr)) then begin
    MessageBox(0,USetstr(30211));
    return;
  end;

  PMsgStack_YearlyReport(LSPDr,msgstack,1,rdate);
  PMsgWriteDeaf(LSPDr,msgstack);
  return;
end;

global
procedure PMsg_PeriodicReport(record RcVc RepSpec,record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;

  if(PMsg_IsShiftOpen(LSPDr)) then begin
    MessageBox(0,USetstr(30212));
    return;
  end;

  PMsgStack_FiscalReportDateRange(LSPDr,msgstack,RepSpec.d1,RepSpec.d2,1);
  PMsgWriteDeaf(LSPDr,msgstack);
  return;
end;


global
function LongInt PMsg_SyncDateAndTime(record LSerialPortDeviceVc LSPDr,date d,time t)
begin
  LongInt res;
  array string 255 msgstack,answers;

  res = 0;
  if(PMsg_IsShiftOpen(LSPDr)) then begin
    res = 22166;
    goto LExit;
  end;

  PMsgStack_ModeProgramming(LSPDr,msgstack);
  PMsgStack_SetDate(LSPDr,msgstack,d);
  PMsgStack_SetTime(LSPDr,msgstack,t);
  PMsgWriteDeaf(LSPDr,msgstack);
  
LExit:;
  PMsg_SyncDateAndTime = res;
  return;
end;

global
procedure PMsg_Status(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack,answers;

  PMsgStack_StatusRequest(LSPDr,msgstack);
  PMsgStack_StatusCode(LSPDr,msgstack);
  PMsgStack_GetNextDocumentNumber(LSPDr,msgstack);
  PMsgWrite(LSPDr,msgstack,answers);

  StartReportJob("Printer status");
  EndHeader;
  setRepCol(2,180);
  setRepCol(3,400);
  StartFormat(16);
  OutString(0,0,"Name",false);
  OutString(2,0,"Value",false);
  OutString(3,0,"Meaning",false);
  EndFormat;
  Gray_Divider(0,1);
  PMsg_OneStatusLine("Printing mode",answers[PMsgVar_PrintingMode]);
  PMsg_OneStatusLine("Status code",answers[PMsgVar_Status]);
  PMsg_OneStatusLine("Printer Date",answers[PMsgVar_Date]);
  PMsg_OneStatusLine("Printer Time",answers[PMsgVar_Time]);
  PMsg_OneStatusLine("Printer SerNr",answers[PMsgVar_SerialNr]);
  PMsg_OneStatusLine("Next receipt nr.",answers[PMsgVar_ReceiptNr]);
  PMsg_OneStatusLine("Next document nr.",answers[PMsgVar_DocumentNr]);
  PMsg_OneStatusLine("Receipt Status",answers[PMsgVar_ReceiptStatus]);
  PMsg_OneStatusLine("Out of paper",answers[PMsgVar_ErrorNoPaper]);
  PMsg_OneStatusLine("Connection error",answers[PMsgVar_ErrorConnection]);
  PMsg_OneStatusLine("Mechanical error",answers[PMsgVar_ErrorMechanical]);
  PMsg_OneStatusLine("Electronical error",answers[PMsgVar_ErrorElectronical]);
  PMsg_OneStatusLine("Printer overheated",answers[PMsgVar_ErrorPrntHeadOverheat]);
  PMsg_OneStatusLine("Printer buffer not used",answers[PMsgVar_PrinterBufferNotUsed]);
  PMsg_OneStatusLine("Printer buffer full",answers[PMsgVar_PrinterBufferFull]);
  PMsg_OneStatusLine("Fiscal mode",answers[PMsgVar_FiscalMode]);
  PMsg_OneStatusLine("Shift open",answers[PMsgVar_ShiftOpened]);
  EndJob;

  return;
end;

function val DownPaymentAmount(record IVVc IVr,Integer ordrow)
begin
  val res;
  row IVVc IVrw;
  Integer i,rwcnt;

  if (ordrow>=0) then begin
    rwcnt =  MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==5) then begin
        if (IVrw.OrdRow==ordrow) then begin
          res = res + IVrw.Sum;
        end;
      end;
    end;
  end;

  DownPaymentAmount = res;
  RETURN;
END;

function Integer GetTSLVATCode(array val aVatRate,record VATCodeBlock VATCodeRec,string VATCode)
begin
  Integer res;
  Integer i,j,rwcnt;
  row VATCodeBlock VATCodeRow;

  res = 0;
  if (nonblank(VATCode)) then begin
    rwcnt = MatRowCnt(VATCodeRec);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(VATCodeRec,i,VATCodeRow);
      if (VATCodeRow.VATCode==VATCode) then begin
        if (blank(VATCodeRow.ExVatpr)) then begin
          goto LGetTSLVATCode;
        end;
        for (j=0;j<5;j=j+1) begin
          if (aVatRate[j]==VATCodeRow.ExVatpr) then begin
            res = j;
            goto LGetTSLVATCode;
          end;
        end;
      end;
    end;
  end;

LGetTSLVATCode:;
  GetTSLVATCode = res;
  RETURN;
END;

global
function boolean PMsg_GetPrinterVAT(record LSerialPortDeviceVc LSPDr,var array string values)
begin
  integer i;
  array string 255 answers,msgstack;
  boolean res;

  PMsgStack_ModeProgramming(LSPDr,msgstack);

  for(i=1;i<=15;i=i+1) begin
    PMsgStack_GetVatValue(LSPDr,msgstack,i);
  end;

  // [TODO/] if GetVatValue function is not found, then no Sending will be done
  res = PMsgSend(LSPDr,msgstack,answers);
  if(res) then begin
    PMsgAnswersCollectValues(PMsgCmdConst_GetVATValue,PMsgVar_Value,answers,values);
  end;

  PMsg_GetPrinterVAT = res;
  return;
end;

procedure CrossRefVAT(array string PrinterVAT,var vector longint CrossRef,var vector val Rates)
begin
  Integer i,j,rwcnt;
  record VATCodeBlock VATCodeRec;
  row VATCodeBlock VATCodeRow;
  integer acnt;

  acnt = StrArrayCnt(PrinterVAT);
  BlockLoad(VATCodeRec);
  rwcnt = MatRowCnt(VATCodeRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATCodeRec,i,VATCodeRow);
    for (j=1;j<=acnt;j=j+1) begin
      if (StringToVal(PrinterVAT[j],M4Val)==VATCodeRow.ExVatpr) then begin
        CrossRef[VATCodeRow.VATCode] = j;
        Rates[VATCodeRow.VATCode] = VATCodeRow.ExVatpr;
      end;
    end;
  end;
  return;
end;

function boolean PMsg_GetCrossrefVAT(record LSerialPortDeviceVc LSPDr,var vector longint CrossRef,var vector val Rates)
begin
  array string 10 values;
  boolean res;

  res = PMsg_GetPrinterVAT(LSPDr,values);
  if(res) then begin
    CrossRefVAT(values,CrossRef,Rates);
  end;

  PMsg_GetCrossrefVAT = res;
  return;
end;

function boolean PMsgStack_PrintInvoiceLines(record LSerialPortDeviceVc LSPDr,var array string msgstack,record IVVc IVr,var Boolean DoPayment,var string errmsg)
begin
  Boolean abort;
  Integer noErr;
  record INVc INr;
  Integer i,rwcnt,VATNo,j,slen;
  row IVVc IVrw;
  string 255 replystr,tstr;
  val downpay,t,t1,discount;
  array Integer aEscSeq;
  Integer aCount;
  record VATCodeBlock VATCodeRec;
  val SumOnReceipt;
  val Difference;
  integer mode;
  vector longint CrossRefVAT;
  vector val VATRates;
  integer decimals;

  // [COMM/] Using this as the Fiscal printer will have more precise number that we have to deal with if we want to close the receipt // using this for calculating the needed rounding
  SumOnReceipt = 0;

  // [COMM/] VAT code cross-reference ([Enterprise] = Printer)
  abort = !PMsg_GetCrossrefVAT(LSPDr,CrossRefVAT,VATRates);

  if(!abort) then begin
    BlockLoad(VATCodeRec);
    rwcnt =  MatRowCnt(IVr);
    for (i=0;i<rwcnt and !abort;i=i+1) begin
      MatRowGet(IVr,i,IVrw);

      switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
          downpay = DownPaymentAmount(IVr,IVrw.OrdRow);
          if (downpay!=0) then begin
            IVrw.Sum = IVrw.Sum + downpay;
            IVrw.Price = IVrw.Sum/IVrw.Quant;
          end;
          // [COMM/] Discount item support
          if(IVrw.Sum<0) then begin
            goto LSkipRow;
          end;
        case kInvoiceRowTypeCorrection: ;
        case kInvoiceRowTypeDownpayment:
          if (IVrw.Sum<0) then begin
            goto LSkipRow;
          end;
          IVrw.Price = IVrw.Sum/IVrw.Quant;
        case kInvoiceRowTypeLoyaltyPointsPayment:
          DoPayment = true;
        case kInvoiceRowTypeGiftVoucherPayment:
          DoPayment = true;
          goto LSkipRow;
        case kInvoiceRowTypeCashPayment:
          DoPayment = true;
          goto LSkipRow;
        case kInvoiceRowTypeCreditCardPayment:
          DoPayment = true;
          goto LSkipRow;
        case kInvoiceRowTypeChequePayment:
          DoPayment = true;
          goto LSkipRow;
        otherwise
          goto LSkipRow;
      end;
      if (blank(IVrw.ArtCode)) then begin
        goto LSkipRow;
      end;

      if(CrossRefVAT[IVrw.VATCode]==-1) then begin
        errmsg = USetStr(22167);
        abort = true;
      end;

      if (IVr.InclVAT==0) then begin
        IVrw.Price = IVrw.Price + Round(IVrw.Price * VATRates[IVrw.VATCode]/100,SetRoundModeD(2));
      end;

      PMsgStack_PrintMultiLine(LSPDr,msgstack,IVrw.Spec);
      if (nonblank(IVrw.SerialNr)) then begin
        PMsgStack_PrintLine(LSPDr,msgstack,IVrw.SerialNr);
      end;

      switch(IVr.InvType) begin
        case kInvoiceTypeNormal:
          PMsgStack_AddSalesSumQty(LSPDr,msgstack,IVrw.Price,IVrw.Quant,CrossRefVAT[IVrw.VATCode]);
        case kInvoiceTypeCredit:
          PMsgStack_AddReturnSumQty(LSPDr,msgstack,IVrw.Price,IVrw.Quant,CrossRefVAT[IVrw.VATCode]);
        case kInvoiceTypeNormalSpecialSales:
          PMsgStack_AddSalesSumQty(LSPDr,msgstack,IVrw.Price,IVrw.Quant,CrossRefVAT[IVrw.VATCode]);
        case kInvoiceTypeCreditSpecialSales:
          PMsgStack_AddReturnSumQty(LSPDr,msgstack,IVrw.Price,IVrw.Quant,CrossRefVAT[IVrw.VATCode]);
      end;

      if (IVrw.vRebate!=blankval) then begin
        PMsgStack_AddDiscount(LSPDr,msgstack,PMsgConst_ScopeOneLine,PMsgConst_DiscountPercentage,PMsgConst_Normal,IVrw.vRebate);
        IVrw.Price =  IVrw.Price * (1 - IVrw.vRebate/100);
      end;

      SumOnReceipt = SumOnReceipt + IVrw.Price * IVrw.Quant;
      LSkipRow:;
    end;

    if(!abort) then begin
      // [COMM/] Correcting rounding differences Printer VS Enterprise (happens with InclVAT == 0 Invoices)
      Difference = Round(SumOnReceipt - IVr.Sum4,SetRoundModeD(2));
      if(Difference!=0.00) then begin
        mode = PMsgConst_Normal;
        if(Difference<0) then begin
          mode = PMsgConst_Premium;
          Difference = Difference * -1;
        end;
        PMsgStack_Feed(LSPDr,msgstack,0);
        PMsgStack_AddDiscount(LSPDr,msgstack,PMsgConst_ScopeWholeReceipt,PMsgConst_DiscountSum,mode,Difference);
      end;
    end;
  end;

  PMsgStack_PrintInvoiceLines = !abort;
  return;
end;

function val PMsgStack_Payment(record LSerialPortDeviceVc LSPDr,var array string msgstack,record IVVc IVr)
begin
  Integer res,noErr;
  string 255 replystr,tstr;
  array Integer aEscSeq;
  Integer aCount,i,rwcnt,PayType,CalcChange;
  row IVVc IVrw;
  val PaidAmount;

  rwcnt =  MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    PayType = -1;
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeCashPayment:
        PayType = PMsgConst_Cash;
      case kInvoiceRowTypeCreditCardPayment:
        PayType = PMsgConst_CreditCard;
      case kInvoiceRowTypeChequePayment:
        PayType = PMsgConst_Cheque;
      case kInvoiceRowTypeGiftVoucherPayment:
        PayType = PMsgConst_GiftVoucher;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        PayType = PMsgConst_Loyalty;
    end;

    if(PayType!=-1) then begin
      PaidAmount = PaidAmount + IVrw.Sum;
      if (PaidAmount>=IVr.Sum4) then begin
        CalcChange = 0;
      end else begin
        CalcChange = 1;
      end;

      PMsgStack_ReceiptAddPayment(LSPDr,msgstack,PayType,IVrw.Sum,CalcChange);
    end;
  end;

  PMsgStack_Payment = PaidAmount;
  return;
end;

global
function boolean PMsg_PrintReceipt(record LSerialPortDeviceVc LSPDr,var record IVVc IVr)
begin
  record IVVc oldIVr;
  Integer noErr,res;
  record CashPrintBlock CPb;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  Integer cmdnr;
  Boolean DoPayment;
  array val aVatRate;
  array string 255 msgstack,answers;
  string 255 msg;
  date PrinterDate;
  array integer CrossRefVAT;
  string 255 errmsg,tstr;
  val PaidAmount;
  boolean printed;

  if (PMsgOpen(LSPDr)) then begin
    if (!PMsg_GetDate(LSPDr,PrinterDate)) then begin
      MessageBox(22165,"");
      goto LClose;
    end;

    if (PrinterDate!=IVr.TransDate) then begin
      errmsg = IVr.TransDate & " " & USetStr(12403) & " " & PrinterDate;
      MessageBox(20852,errmsg);
      goto LClose;
    end;

    PMsgStack_ChangeModeEx(LSPDr,msgstack,PMsgConst_ModeRecord,1);
    PMsgStack_GetNextDocumentNumber(LSPDr,msgstack);
    
    switch(IVr.InvType) begin
      case kInvoiceTypeNormal:
        PMsgStack_ReceiptOpen(LSPDr,msgstack,PMsgConst_ReceiptSales);
      case kInvoiceTypeCredit:
        PMsgStack_ReceiptOpen(LSPDr,msgstack,PMsgConst_ReceiptSalesReturn);
    end;
    
    PMsgStack_PrintLine(LSPDr,msgstack,USetStr(13821) & " " & IVr.SerNr);
    GetUserName(CurrentUser,tstr);
    PMsgStack_PrintLine(LSPDr,msgstack,USetStr(9230) & " " & tstr);
    
    if (!PMsgStack_PrintInvoiceLines(LSPDr,msgstack,IVr,DoPayment,errmsg)) then begin
      MessageBox(0,errmsg);
      goto LClose;
    end;
    
    if (DoPayment) then begin
      PaidAmount = PMsgStack_Payment(LSPDr,msgstack,IVr);
    end;
    
    PMsgStack_ReceiptClose(LSPDr,msgstack,1,0);
    if (PaidAmount==blankval or PaidAmount>=IVr.Sum4) then begin
      PMsgSend(LSPDr,msgstack,answers);
      if (nonblank(answers[PMsgVar_DocumentNr])) then begin
        IVr.OfficialSerNr = answers[PMsgVar_DocumentNr];
      end;
    end else begin
      MessageBox(22168,"");
      goto LClose;
    end;
    
    printed = true;
LClose:;
    PMsgClose(1);
  end else begin
    MessageBox(12383,"");
  end;
  
  PMsg_PrintReceipt = printed;
  return;
end;

global
procedure PMsg_DailyReport(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack,answers;

  PMsgStack_ChangeModeEx(LSPDr,msgstack,PMsgConst_ModeReporting,30);
  PMsgStack_Report(LSPDr,msgstack,PMsgConst_Daily);
  PMsgWrite(LSPDr,msgstack,answers);
  return;
end;

global
procedure PMsg_CloseShift(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;
  Integer noErr,res;

  PMsgStack_ChangeModeEx(LSPDr,msgstack,PMsgConst_ModeReportingPrint,30);
  PMsgStack_CloseShift(LSPDr,msgstack);
  PMsgWriteDeaf(LSPDr,msgstack);

  return;
end;

global
procedure PMsg_ResetCashierNames(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;

  PMsgStack_ResetCashierNames(LSPDr,msgstack);
  PMsgWriteDeaf(LSPDr,msgstack);
  return;
end;

global
procedure PMsg_OpenShift(record LSerialPortDeviceVc LSPDr)
begin
  array string 255 msgstack;
  Integer noErr,res;

  // [TODO/] Check the shift register and fetch us a code :)
  PMsgStack_ChangeModeEx(LSPDr,msgstack,PMsgConst_ModeRecord,30);
  PMsgStack_OpenShift(LSPDr,msgstack,CurrentUser);
  PMsgWriteDeaf(LSPDr,msgstack);

  return;
end;

global
procedure PMsg_CashEvent(record LSerialPortDeviceVc LSPDr,var record CashVc Cashr)
begin
  array string 255 msgstack;
  integer res;
  date PrinterDate;

  res = PMsgOpen(LSPDr);
  if (res) then begin
    if (PMsg_GetDate(LSPDr,PrinterDate)) then begin
      if (PrinterDate==CurrentDate) then begin
        PMsgStack_ChangeModeEx(LSPDr,msgstack,PMsgConst_ModeRecord,1);
        PMsgStack_PrintMultiLine(LSPDr,msgstack,Cashr.Comment);
        PMsgStack_Feed(LSPDr,msgstack,0);
  
        switch (Cashr.Event) begin
          case 0:
            PMsgStack_MoneyWithdraw(LSPDr,msgstack,Cashr.Total);
          case 1:
            PMsgStack_MoneyDeposit(LSPDr,msgstack,Cashr.Total);
        end;
        PMsgStack_OpenCashDrawer(LSPDr,msgstack);
        PMsgSendDeaf(LSPDr,msgstack);
      end else begin
         MessageBox(0,USetStr(12402));
      end;
    end;
    PMsgClose(1);
  end;

  return;
end;
