external procedure PMsg_DefBIT(integer,integer,var array integer);
external procedure PMsg_DefINT(integer,integer,var array integer);
external procedure PMsg_DefBCD(integer,integer,var array integer);
external procedure PMsg_DefDMY(integer,var array integer);
external procedure PMsg_DefHEX(string,var array integer); 
external procedure PMsg_DefSTR(integer,integer,var array integer); 
external procedure PMsg_DefYMD(integer,var array integer); 
external procedure PMsg_DefHMS(integer,var array integer);
external procedure PMsg_DefVAL(integer,integer,var array integer); 
external procedure PMsg_DefSTRPAD(integer,integer,var array integer); 
external procedure PMsg_DefSTRSTRIP(integer,integer,var array integer); 
external procedure PMsg_DefVAL2(integer,integer,var array integer); 
external procedure PMsg_DefVAL3(integer,integer,var array integer);
external procedure PMsgFormat_DefVar(integer,integer,integer,var array integer); 
external function string 255 StrReplace(string,string,string);
external function string 100 HexStrToChrStr(string,boolean); 
external procedure PMsgAddToStackPreset(integer,integer,array string,var array string);
external procedure PMsgFormat_DefStaticInteger(integer,var array integer); 

// [COMM/] FUNCTIONS FOR INTERNAL USAGE
procedure AddToMsgStack(integer PMsgConst,array string params,var array string msgbuffer) 
begin
  PMsgAddToStackPreset(kSerialPortDeviceModelFiscPrinterFPRINT02K,PMsgConst,params,msgbuffer);
  return;
end;

procedure PMsg_DefCashValue(var array integer format) 
begin
  PMsg_DefBIT(PMsgVar_TestMode,1,format);
  PMsg_DefVAL2(PMsgVar_Sum,5,format); 
  return;
end;

procedure PMsg_DefSumQty(var array integer format) 
begin
  PMsg_DefBIT(PMsgVar_TestMode,1,format);
  PMsg_DefBIT(PMsgVar_CashCheckMode,1,format);
  PMsg_DefVAL2(PMsgVar_Price,5,format);
  PMsg_DefVAL3(PMsgVar_Qty,5,format);  
  return;
end;

procedure PMsg_DefPayment(var array integer format) 
begin
  PMsg_DefBIT(PMsgVar_TestMode,1,format);
  PMsg_DefBCD(PMsgVar_PaymentType,1,format);
  PMsg_DefVAL2(PMsgVar_Sum,5,format);      
  return;
end;

procedure PMsg_DefDiscount(var array integer format) 
begin
  PMsg_DefBIT(PMsgVar_TestMode,1,format);
  PMsg_DefBCD(PMsgVar_Scope,1,format);
  PMsg_DefBCD(PMsgVar_Type,1,format);
  PMsg_DefBCD(PMsgVar_Sign,1,format);
  return;
end;

procedure PMsg_DefSettings(integer variable,var array integer format) begin
  PMsg_DefHEX("02 00 01",format);  
  PMsgFormat_DefStaticInteger(variable,format);
  PMsg_DefBCD(PMsgVar_Value,1,format);
  return;
end;

// [COMM] DRIVER DATA FOR FPRINT-02K
function string 255 PMsg_Constant(integer CmdConst,string ParamConst) 
begin
  string 255 res;
  
  res = -1;
  switch(StringToInt(ParamConst)) begin
    // [COMM/] Receipt type
    case PMsgConst_ReceiptSales: res = 1;
    case PMsgConst_ReceiptSalesReturn: res = 2;
    case PMsgConst_ReceiptSalesCancellation: res = 3;
    case PMsgConst_ReceiptPurchase: res = 4;
    case PMsgConst_ReceiptPurchaseReturn: res = 5;
    case PMsgConst_ReceiptPurchaseCancellation: res = 6;
    // [COMM/] Operation Mode
    case PMsgConst_ModeRecord: res = 1;
    case PMsgConst_ModeReporting: res = 2;
    case PMsgConst_ModeReportingPrint: res = 3;
    case PMsgConst_ModeProgramming: res = 4;
    case PMsgConst_ModeAccessToFiscalPrinter: res = 5;
    case PMsgConst_ModeAccessFiscalMem: res = 6;
    // [COMM/] Discount type
    case PMsgConst_DiscountPercentage: res = 0;
    case PMsgConst_DiscountSum: res = 1;
    case PMsgConst_ScopeOneLine: res = 1;
    case PMsgConst_ScopeWholeReceipt: res = 0;
    case PMsgConst_Normal: res = 0;
    case PMsgConst_Premium: res = 1;
    // [COMM/] Reports
    case PMsgConst_Daily: res = 1;
    case PMsgConst_Section: res = 2;
    case PMsgConst_Cashiers: res = 3;
    case PMsgConst_Items: res = 4;
    case PMsgConst_Hourly: res = 5;
    case PMsgConst_Amouts: res = 7;
    case PMsgConst_Monthly: res = 8; 
    // [COMM/] Payments
    case PMsgConst_Cash: res = 1;
    case PMsgConst_Loyalty: res = 2;
    case PMsgConst_GiftVoucher: res = 2;
    case PMsgConst_CreditCard: res = 3;
    case PMsgConst_Cheque: res = 4;
    // [COMM/] Settings table
    case PMsgConst_GeneralSettings: res = 2;
    case PMsgConst_VAT: res = 8;
    // [COMM/] Settings section
    case PMsgConst_General: res = 1;
    // [COMM/] Settings 
    // [TODO/] Those lines should also be just settings:::
    case PMsgConst_TaxMode: res = 11;
    case PMsgConst_LineSpacing: res = 30;
    case PMsgConst_Password: res = 23;
    case PMsgConst_Show: res = 1;
    case PMsgConst_Hide: res = 0;
    case PMsgConst_On: res = 1;
    case PMsgConst_Off: res = 0;
    case PMsgConst_Always: res = 2;
    // [COMM/] // These are actually 8 digits long
    case PMsgConst_PasswordAdmin: res = 30;
    case PMsgConst_PasswordFiscalRep: res = 0;
  end;

  PMsg_Constant = res;
  return;
end;

// [COMM/] Printer-specific driver settings
function string 100 PMsg_Settings(integer PMsgSettingsId) 
begin
  string 255 res;

  switch(PMsgSettingsId) begin
    case PMsgSettings_NumberPackingFormat:
      res = PMsg_BCD;
    case PMsgSettings_MaxLineLength:
      res = 40;
  end;   

  PMsg_Settings = res;
  return;
end;

// [COMM/] Byte command cross-reference for Sematic Printer Messages 
function string 10 PMsg_Commands(integer PMsgCommandId) 
begin
  integer res;
  
  switch(PMsgCommandId) begin
    case PMsgCmdConst_Sound:
      res = 136; // 0x88
    case PMsgCmdConst_Cut:
      res = 117; // 0x75 
    case PMsgCmdConst_PrintLine:
      res = 76; // 0x4C
    case PMsgCmdConst_Beep:
      res = 71; // 0x47
    case PMsgCmdConst_PrintFooter:
      res = 108; // 0x6C
    case PMsgCmdConst_ExitCurrentMode:
      res = 72; // 0x48
    case PMsgCmdConst_DemoPrint:
      res = 130; // 0x82           
    case PMsgCmdConst_Status:
      res = 63; // 0x3F
    case PMsgCmdConst_SetDate:
      res = 100; // 0x64
    case PMsgCmdConst_SetTime:
      res = 75; // 0x4B
    case PMsgCmdConst_OpenReceipt:
      res = 146; // 0x92
    case PMsgCmdConst_CloseReceipt:
      res = 74; // 0x4A
    case PMsgCmdConst_AddSalesSumQty:
      res = 82; // 0x52
    case PMsgCmdConst_AddCancelSumQty:
      res = 65; // 0x41
    case PMsgCmdConst_AddReturnSumQty:
      res = 87; // 0x57
    case PMsgCmdConst_RemSumQty:
      res = 78; // 0x4E
    case PMsgCmdConst_AddReceiptPayment:
      res = 153; // 0x99
    case PMsgCmdConst_RemReceiptPayment:
      res = 155; // 0x9B
    case PMsgCmdConst_MoneyDeposit:
      res = 73; // 0x49
    case PMsgCmdConst_MoneyWithdraw:
      res = 79;  // 0x4F
    case PMsgCmdConst_AddDiscountPercentage:
      res = 67; // 0x43
    case PMsgCmdConst_AddDiscountSum:
      res = 67; // 0x43
    case PMsgCmdConst_CancelDiscount:
      res = 120; // 0x78
    case PMsgCmdConst_PrintText:
      res = 135; // 0x87
    case PMsgCmdConst_GetLastShiftSales:
      res = 88; // 0x58
    case PMsgCmdConst_Report:
      res = 103; // 0x67
    case PMsgCmdConst_Feed:
      res = 135; // 0x87
    case PMsgCmdConst_GetVATValue:
      res = 70; // 0x46
    case PMsgCmdConst_PrinterGet:
      res = 70; // 0x46
    case PMsgCmdConst_GetCashierName:
      res = 70; // 0x46
    case PMsgCmdConst_GetCashierCode:
      res = 70; // 0x46
    case PMsgCmdConst_PrinterSet:
      res = 80; // 0x50
    case PMsgCmdConst_PrintCashierName:
      res = 80; // 0x50
    case PMsgCmdConst_PrintReceiptType:
      res = 80; // 0x50
    case PMsgCmdConst_ReceiptCut:
      res = 80; // 0x50
    case PMsgCmdConst_PrintUnitForSingleItem:
      res = 80; // 0x50
    case PMsgCmdConst_GetNextDocumentNumber:
      res = 145; // 0x91
    case PMsgCmdConst_OpenCashDrawer:
      res = 128; // 0x80 
    case PMsgCmdConst_RequestStatusCode:
      res = 69; // 0x45
    case PMsgCmdConst_FiscalReportDateRange:
      res = 101; // 0x65
    case PMsgCmdConst_OpenShift:
      res = 154; // 0x9A    
    case PMsgCmdConst_CloseShift:
      res = 90; // 0x5A
    case PMsgCmdConst_SetCashierName:
      res = 80; // 0x50
    case PMsgCmdConst_EnterMode:
      res = 86; // 0x56
    case PMsgCmdConst_CancelCurrentReceipt:
      res = 89; // 0x59
    case PMsgCmdConst_Reset:
    case PMsgCmdConst_TotalExtinction:
    case PMsgCmdConst_CashInRegisterDrawer:
    case PMsgCmdConst_PrintImageFromHost:
    case PMsgCmdConst_GetDeviceType:
    case PMsgCmdConst_CompleteDocument:
    case PMsgCmdConst_GetLastErrorCode:
    case PMsgCmdConst_PrintDocumentFooter:
  end;
    
  if(res > 0) then begin
    PMsg_Commands = uchr(res);
  end;
  return;
end;

// [COMM/] Alternative commands for something that the printer does not have originally, but can be constructed by using other commands
procedure PMsg_AlternativeCommands(integer PMsgCommandId,var array string msgbuffer,array string altparams) 
begin
  array string 255 params;
  integer i;
  date d;
  string 30 tstr;
  
  switch(PMsgCommandId) begin
    case PMsgCmdConst_GetCashierData:
      AddToMsgStack(PMsgCmdConst_ModeProgramming,params,msgbuffer);
      for(i=1;i<=29;i=i+1) begin
        params[PMsgVar_Row] = i;
        AddToMsgStack(PMsgCmdConst_GetCashierCode,params,msgbuffer);      
        params[PMsgVar_Row] = i;
        AddToMsgStack(PMsgCmdConst_GetCashierName,params,msgbuffer);      
      end;
    case PMsgCmdConst_ResetCashierNames:
      AddToMsgStack(PMsgCmdConst_ModeProgramming,params,msgbuffer);
      for(i=1;i<=29;i=i+1) begin
        params[PMsgVar_Row] = i;
        params[PMsgVar_Name] = "";
        AddToMsgStack(PMsgCmdConst_SetCashierName,params,msgbuffer);      
      end;
    case PMsgCmdConst_ReportYearly:
      AddToMsgStack(PMsgCmdConst_ModeFiscalReporting,params,msgbuffer);
      d = StringToDate(altparams[PMsgVar_Date]);
      d.day = 1;
      d.month = 1;
      altparams[PMsgVar_FromDate] = d;
      d.day = 31;
      d.month = 12;
      altparams[PMsgVar_ToDate] = d;
      AddToMsgStack(PMsgCmdConst_FiscalReportDateRange,altparams,msgbuffer);          
    case PMsgCmdConst_ReportMonthly:
      AddToMsgStack(PMsgCmdConst_ModeFiscalReporting,params,msgbuffer);
      d = StringToDate(altparams[PMsgVar_Date]);
      d = AddDay(d,-GetDay(d)+1);
      altparams[PMsgVar_FromDate] = d;
      altparams[PMsgVar_ToDate] = AddDay(AddMonth(d,1),-1);
      AddToMsgStack(PMsgCmdConst_FiscalReportDateRange,altparams,msgbuffer);      
    case PMsgCmdConst_Diagnostics:
      AddToMsgStack(PMsgCmdConst_ExitCurrentMode,params,msgbuffer);
      params[PMsgVar_PrintOnReceipt] = 1;
      params[PMsgVar_PrintOnTestStrip] = 0;
      AddToMsgStack(PMsgCmdConst_DemoPrint,params,msgbuffer);
    case PMsgCmdConst_ModeProgramming:
      AddToMsgStack(PMsgCmdConst_ExitCurrentMode,params,msgbuffer);
      params[PMsgVar_Mode] = 4;
      params[PMsgVar_Password] = 30;
      AddToMsgStack(PMsgCmdConst_EnterMode,params,msgbuffer);
    case PMsgCmdConst_ModeFiscalReporting:
      AddToMsgStack(PMsgCmdConst_ExitCurrentMode,params,msgbuffer);
      params[PMsgVar_Mode] = 5;
      params[PMsgVar_Password] = 0;
      AddToMsgStack(PMsgCmdConst_EnterMode,params,msgbuffer);      
  end;
  
  return;
end;

// [COMM/] Custom settings for some functions
function string 30 PMsg_CommandControl(integer CmdId,integer VarId)
begin
  string 30 res;

  switch(VarId) begin
    case PMsgSettings_Delay:
    case PMsgSettings_RetryDelay:
      switch(CmdId) begin
        case PMsgCmdConst_CloseReceipt:
          res = 300;
        case PMsgCmdConst_CloseShift:
          res = 300;
      end;
  end;
  
  PMsg_CommandControl = res;
  return;
end;

// [COMM/] Format definitions for different Sematic Printer Commands 
procedure PMsg_MessageVariables(integer PMsgCmdId,var array integer format) 
begin
  string 255 res;
  
  switch(PMsgCmdId) begin
    case PMsgCmdConst_PrintCashierName:
      PMsg_DefSettings(26,format);
    case PMsgCmdConst_PrintReceiptType:
      PMsg_DefSettings(29,format);
    case PMsgCmdConst_ReceiptCut:
      PMsg_DefSettings(24,format);
    case PMsgCmdConst_PrintUnitForSingleItem:
      PMsg_DefSettings(49,format);
    case PMsgCmdConst_SetCashierName:
      PMsg_DefHEX("03 00",format);
      PMsg_DefINT(PMsgVar_Row,1,format);
      PMsg_DefHEX("02",format);
      PMsg_DefSTRPAD(PMsgVar_Name,56,format);
    case PMsgCmdConst_GetCashierName:
      PMsg_DefHEX("03 00",format);
      PMsg_DefINT(PMsgVar_Row,1,format);
      PMsg_DefHEX("02",format);
    case PMsgCmdConst_GetCashierCode:
      PMsg_DefHEX("03 00",format);
      PMsg_DefINT(PMsgVar_Row,1,format);
      PMsg_DefHEX("01",format);
    case PMsgCmdConst_PrinterSet:
      PMsg_DefINT(PMsgVar_Table,1,format);      
      PMsg_DefINT(PMsgVar_Row,2,format);      
      PMsg_DefINT(PMsgVar_Field,1,format);      
    case PMsgCmdConst_PrinterGet:
      PMsg_DefINT(PMsgVar_Table,1,format);      
      PMsg_DefINT(PMsgVar_Row,2,format);      
      PMsg_DefINT(PMsgVar_Field,1,format);
    case PMsgCmdConst_ReportDateRanges:
      PMsg_DefBIT(PMsgVar_Mode,1,format);      
      PMsg_DefDMY(PMsgVar_FromDate,format);      
      PMsg_DefDMY(PMsgVar_ToDate,format);      
    case PMsgCmdConst_Report:
      PMsg_DefINT(PMsgVar_Type,1,format);
    case PMsgCmdConst_AddDiscountPercentage:
      PMsg_DefDiscount(format);
      PMsg_DefVAL2(PMsgVar_Value,3,format);
    case PMsgCmdConst_AddDiscountSum:
      PMsg_DefDiscount(format);
      PMsg_DefVAL2(PMsgVar_Value,5,format);
    case PMsgCmdConst_AddReceiptPayment:
      PMsg_DefPayment(format);
    case PMsgCmdConst_RemReceiptPayment:
      PMsg_DefPayment(format);
    case PMsgCmdConst_CloseReceipt:
      PMsg_DefPayment(format);
    case PMsgCmdConst_OpenShift:
      PMsg_DefBIT(PMsgVar_TestMode,1,format);
      PMsg_DefSTR(PMsgVar_Text,56,format);
    case PMsgCmdConst_OpenReceipt:
      PMsg_DefBIT(PMsgVar_TestMode,1,format);
      PMsg_DefBCD(PMsgVar_Type,1,format);
    case PMsgCmdConst_AddReturnSumQty:
      PMsg_DefSumQty(format);
    case PMsgCmdConst_AddCancelSumQty:
      PMsg_DefSumQty(format);
    case PMsgCmdConst_AddSalesSumQty:
      PMsg_DefSumQty(format);
      PMsg_DefINT(PMsgVar_Section,1,format);      
    case PMsgCmdConst_RemSumQty:
      PMsg_DefSumQty(format);
      PMsg_DefINT(PMsgVar_Section,1,format);          
    case PMsgCmdConst_EnterMode:
      PMsg_DefBCD(PMsgVar_Mode,1,format);
      PMsg_DefBCD(PMsgVar_Password,4,format);
    case PMsgCmdConst_SetDate:
      PMsg_DefDMY(PMsgVar_Date,format);          
    case PMsgCmdConst_SetTime:
      PMsg_DefHMS(PMsgVar_Time,format);          
    case PMsgCmdConst_Sound:     
      PMsg_DefINT(PMsgVar_Freq,2,format);
      PMsg_DefINT(PMsgVar_Duration,1,format);      
    case PMsgCmdConst_Cut: 
      PMsg_DefINT(PMsgVar_Mode,1,format);
    case PMsgCmdConst_PrintLine:       
      PMsg_DefSTR(PMsgVar_Text,56,format);
    case PMsgCmdConst_FiscalReportDateRange:
      PMsg_DefBIT(PMsgVar_Complete,1,format);
      PMsg_DefDMY(PMsgVar_FromDate,format);
      PMsg_DefDMY(PMsgVar_ToDate,format);
    case PMsgCmdConst_GetNextDocumentNumber:
      PMsg_DefHEX("13",format);
      PMsg_DefINT(PMsgVar_Reserved,2,format);
    case PMsgCmdConst_GetVATValue:
      PMsg_DefHEX("08",format);
      PMsg_DefINT(PMsgVar_Row,2,format); // VAT row
      PMsg_DefHEX("01",format);
    case PMsgCmdConst_Feed:
      PMsg_DefHEX("00 01 00 01",format)
      PMsg_DefBIT(PMsgVar_Amount,4,format); // spacing
      PMsg_DefHEX("00 01 01 00 00 00 00",format); 
    case PMsgCmdConst_PrintText:
      PMsg_DefBIT(PMsgVar_TestMode,8,format);
      PMsg_DefBIT(PMsgVar_Print,8,format);
      PMsg_DefINT(PMsgVar_Reserved,1,format);
      PMsg_DefBIT(PMsgVar_Size,4,format);
      PMsg_DefBIT(PMsgVar_Reserved,4,format);
      PMsg_DefBIT(PMsgVar_Spacing,4,format);
      PMsg_DefBIT(PMsgVar_Reserved,4,format);
      PMsg_DefINT(PMsgVar_Reserved,1,format);
      PMsg_DefINT(PMsgVar_Mode1,1,format);
      PMsg_DefINT(PMsgVar_Mode2,1,format);
      PMsg_DefINT(PMsgVar_Reserved,3,format);
      PMsg_DefSTR(PMsgVar_Text,52,format);
    case PMsgCmdConst_DemoPrint:
      PMsg_DefBIT(PMsgVar_PrintOnReceipt,1,format);                
      PMsg_DefBIT(PMsgVar_PrintOnTestStrip,1,format);                
      PMsg_DefINT(PMsgVar_Reserved,2,format);      
    case PMsgCmdConst_MoneyDeposit: 
      PMsg_DefCashValue(format);
    case PMsgCmdConst_MoneyWithDraw:
      PMsg_DefCashValue(format);
    case PMsgCmdConst_CompleteDocument:
      PMsg_DefBIT(PMsgVar_TestMode,1,format);
    case PMsgCmdConst_SetDecimalPoint:
      PMsg_DefBCD(PMsgVar_Value,1,format);
  end;
  return;
end;

// [COMM/] Data processing routines that the printer uses
procedure PMsg_Routines(integer PMsgRoutineId,var array integer format) 
begin
  switch(PMsgRoutineId) begin
    case PMsgRoutine_Initiate:  
    case PMsgRoutine_Terminate:
    case PMsgRoutine_Send:
      PMsgFormat_DefVar(PMsgAction_Send,PMsgCmdConst_Request,10,format);
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Acknowledge,1,format);
      PMsgFormat_DefVar(PMsgAction_Send,PMsgCmdConst_Message,5,format);
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Acknowledge,1,format);
      PMsgFormat_DefVar(PMsgAction_KillOn,PMsgCmdConst_Const,CC_NAK,format); // if last WaitFor answer is not ACK, but NAK, then die
      PMsgFormat_DefVar(PMsgAction_Send,PMsgCmdConst_Terminate,1,format);
    case PMsgRoutine_Receive:
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Request,5,format);
      PMsgFormat_DefVar(PMsgAction_Send,PMsgCmdConst_Acknowledge,1,format);
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Const,CC_STX,format);
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Message,1,format);
      PMsgFormat_DefVar(PMsgAction_Send,PMsgCmdConst_Acknowledge,1,format);
      PMsgFormat_DefVar(PMsgAction_WaitFor,PMsgCmdConst_Terminate,1,format);
  end;
  return;
end;

// [COMM/] Answer bytes that are returned after certain messages have been sent to the Printer 
function string 255 PMsg_NativeAnswers(integer PMsgCmdId)
begin
  integer res;
  
  switch(PMsgCmdId) begin
    case PMsgCmdConst_Beep: 
      res = CC_EOT;  // This means that no answer is expected
    case PMsgCmdConst_Status: // 0x44
      res = 68; 
    case PMsgCmdConst_CashInRegisterDrawer: // 0x4D
      res = 77;
    case PMsgCmdConst_GetDeviceType:
      res = 10;
    otherwise // 0x55
      res = 85; 
  end;
  
  PMsg_NativeAnswers = chr(res);
  return;
end;

// [COMM/] Format definitions for Sematic Printer Command Answers
procedure PMsg_AnswerVariables(integer PMsgCmdId,var array integer format) 
begin
  switch(PMsgCmdId) begin
    case PMsgCmdConst_GetCashierName:
      PMsg_DefINT(PMsgVar_Error,1,format);
      PMsg_DefSTRSTRIP(PMsgVar_Name,56,format);
    case PMsgCmdConst_GetCashierCode:
      PMsg_DefINT(PMsgVar_Error,1,format);
      PMsg_DefBCD(PMsgVar_Code,4,format);
    case PMsgCmdConst_GetNextDocumentNumber:
      PMsg_DefINT(PMsgVar_Error,1,format);
      PMsg_DefINT(PMsg_Reserved,2,format);
      PMsg_DefBCD(PMsgVar_ReceiptNr,2,format);
      PMsg_DefBCD(PMsgVar_DocumentNr,4,format);
    case PMsgCmdConst_PrinterGet:
      PMsg_DefBCD(PMsgVar_Value,56,format);      
    case PMsgCmdConst_GetVATValue:
      PMsg_DefVAL2(PMsgVar_Value,3,format);
    case PMsgCmdConst_GetLastShiftSales:
      PMsg_DefINT(PMsgVar_Error,1,format);
      PMsg_DefVAL2(PMsgVar_Sum,7,format);
    case PMsgCmdConst_Status:      
      PMsg_DefBCD(PMsgVar_CashierId,1,format);
      PMsg_DefBCD(PMsgVar_RoomId,1,format);
      PMsg_DefYMD(PMsgVar_Date,format);
      PMsg_DefHMS(PMsgVar_Time,format);
      PMsg_DefBIT(PMsgVar_FiscalMode,1,format);
      PMsg_DefBIT(PMsgVar_ShiftOpened,1,format);      
      PMsg_DefBIT(PMsgVar_CashDrawerOpened,1,format);
      PMsg_DefBIT(PMsgVar_HasPaper,1,format);
      PMsg_DefBIT(PMsg_Reserved,1,format);
      PMsg_DefBIT(PMsgVar_SensorCoverState,1,format);
      PMsg_DefBIT(PMsg_Reserved,1,format);
      PMsg_DefBIT(PMsgVar_BatteryVoltage,1,format);
      PMsg_DefBCD(PMsgVar_SerialNr,4,format);
      PMsg_DefINT(PMsgVar_Model,1,format); // page 86 
      PMsg_DefBCD(PMsgVar_FirmwareVersion,2,format);      
      PMsg_DefBCD(PMsgVar_Mode,1,format);  // page 45
      PMsg_DefBCD(PMsgVar_LastClosedReceipt,2,format); 
      PMsg_DefBCD(PMsgVar_LastClosedShift,2,format); 
      PMsg_DefBIT(PMsgVar_ReceiptStatus,2,format); 
      PMsg_DefBIT(PMsgVar_Reserved,2,format); 
      PMsg_DefVAL2(PMsgVar_ReceiptSum,5,format); 
      PMsg_DefBCD(PMsgVar_Decimals,1,format); 
      PMsg_DefBCD(PMsgVar_Port,1,format);
    case PMsgCmdConst_CashInRegisterDrawer:
      PMsg_DefVAL2(PMsgVar_CashInRegisterDrawer,7,format); 
    case PMsgCmdConst_ReadRegister:
      PMsg_DefINT(PMsgVar_Error,1,format);
      PMsgFormat_DefVar(PMsgVar_Error,PMsg_IntEtx,50,format);      
    case PMsgCmdConst_RequestStatusCode:
      PMsg_DefBIT(PMsgVar_PrintingMode,4,format);
      PMsg_DefBIT(PMsgVar_Status,4,format); 
      PMsg_DefBIT(PMsgVar_ErrorNoPaper,1,format); 
      PMsg_DefBIT(PMsgVar_ErrorConnection,1,format); 
      PMsg_DefBIT(PMsgVar_ErrorMechanical,1,format); 
      PMsg_DefBIT(PMsgVar_ErrorElectronical,1,format);
      PMsg_DefBIT(PMsgVar_ErrorPrntHeadOverheat,1,format); 
      PMsg_DefBIT(PMsgVar_PrinterBufferNotUsed,1,format); 
      PMsg_DefBIT(PMsgVar_PrinterBufferFull,1,format); 
    case PMsgCmdConst_RawHex:
      PMsg_DefSTR(PMsgVar_Value,5,format);
    otherwise
      PMsg_DefINT(PMsgVar_Error,1,format);
  end;
  return;
end;

// [COMM/] Byte Cross-reference for Sematic Error Messages 
function string 255 PMsg_CommonError(integer PMsgErrorCode) 
begin
  string 255 res;
  
  switch(PMsgErrorCode) begin
    case 0: 
      res = PMsgErrorType_NoError;
    case 103: 
      res = PMsgErrorType_NoPaper;
  end;
  
  PMsg_CommonError = res;
  return;
end;

// [COMM/] Byte cross-reference for Error Messages
function string 255 PMsg_TranslateMessage(integer CmdId, integer PMsgErrorCode) begin
  string 255 res;
  
  switch(CmdId) begin
    case PMsgCmdConst_RequestStatusCode: // special statuses for a cmd
    otherwise
      switch(PMsgErrorCode) begin 
        // [COMM/] Those are just google translated error messages from Fprint-02K manual. So bare with me :D
        case 0: res = "No errors";
        case 1: res = "Control tape is processed without errors";
        case 8: res = "Wrong price (amount)";
        case 10: res = "Wrong number";
        case 11: res = "Overflow counter cash";
        case 12: res = "Unable to reversal of the last operation";
        case 13: res = "Reversal of the code is not possible (in the receipt showing lower the number of products with the specified code)";
        case 14: res = "Can not repeat the last operation";
        case 15: res = "Re-discount for the operation impossible";
        case 16: res = "Discount / premium to the previous operation is not possible";
        case 17: res = "Invalid product code";
        case 18: res = "Invalid bar code products";
        case 19: res = "Invalid format";
        case 20: res = "Invalid length";
        case 21: res = "CMC is locked when entering dates";
        case 22: res = "I need to confirm the date";
        case 24: res = "No more data for transmission over the CMC";
        case 25: res = "No confirmation or cancellation of the sale";
        case 26: res = "Report with interrupted quenching. The entrance to the regime is impossible.";
        case 27: res = "Disabling the flow control is impossible (not configured necessary types of payment).";
        case 30: res = "Log in locked mode";
        case 31: res = "Check the date and time";
        case 32: res = "Date and time in CMC is less than EKLZ";
        case 33: res = "Can not close archive";
        case 61: res = "Product not found";
        case 62: res = "The weighted bar code with the number <> 1.000";
        case 63: res = "Buffer overflow check";
        case 64: res = "Insufficient quantity of goods";
        case 65: res = "Storniruemoe quantity sold more";
        case 66: res = "Blocked product was not found in the buffer check";
        case 67: res = "This product is not sold in the check cancellation is impossible";
        case 68: res = "Memo Plus(TM) blocked from your PC";
        case 69: res = "Memo Plus Checksum error table settings Memo Plus (TM)";
        case 70: res = "Invalid command of the CMC";
        case 102: res = "The command is not implemented in this mode of printing";
        case 103: res = "No Paper";
        case 104: res = "No connection with the receipt printer";
        case 105: res = "Mechanical printer error";
        case 106: res = "Wrong type of check";
        case 107: res = "No more lines of picture";
        case 108: res = "Invalid register number";
        case 109: res = "Invalid target device";
        case 110: res = "There is no place in an array of images";
        case 111: res = "Wrong number of picture / No picture";
        case 112: res = "Amount Cancellation more than was received by this type of payment";
        case 113: res = "No amount of cash payments exceed the amount of the check";
        case 114: res = "Sum payment is less than the check amount";
        case 115: res = "Accumulation of less than the refund or cancellation";
        case 117: res = "Overflow sum payments";
        case 118: res = "(Reserved)";
        case 122: res = "This model PFC can not execute";
        case 123: res = "Invalid value discount / premium";
        case 124: res = "Operation after rebates / allowances can not be";
        case 125: res = "Wrong Section";
        case 126: res = "Invalid payment type";
        case 127: res = "Overflow in the multiplication";
        case 128: res = "The operation is prohibited in the table settings";
        case 129: res = "Total overflow check";
        case 130: res = "Cancellation receipt open - the operation is not possible";
        case 132: res = "Buffer overflow control tape";
        case 134: res = "Introduced by the customer less the amount of the check amount";
        case 135: res = "Refund receipt open - the operation is not possible";
        case 136: res = "Change has exceeded 24 hours";
        case 137: res = "Open sales points - the operation is not possible";
        case 138: res = "Overflow PT";
        case 140: res = "Wrong password";
        case 141: res = "Buffer control tape is not full";
        case 142: res = "Processing control tape";
        case 143: res = "Zeroing Box Office (re-extinction is impossible)";
        case 145: res = "Invalid table number";
        case 146: res = "Invalid row number";
        case 147: res = "Invalid field number";
        case 148: res = "Invalid date";
        case 149: res = "Wrong time";
        case 150: res = "Amount of the check in the section below the amount Reversal";
        case 151: res = "Counting the amount of deposit is not possible";
        case 152: res = "In CMC there is no money to pay";
        case 154: res = "Check closed - operation is not possible";
        case 155: res = "Chek is open - the operation is not possible";
        case 156: res = "Changing the open operation is not possible";
        case 157: res = "PFC is blocked, waiting for a password to access PT";
        case 158: res = "Serial number is already set";
        case 159: res = "Number of re-registrations can not be more than 4";
        case 160: res = "FP Error";
        case 162: res = "Wrong change";
        case 163: res = "Wrong type of report";
        case 164: res = "Invalid password";
        case 165: res = "Invalid serial number of PFC";
        case 166: res = "Invalid UMP";
        case 167: res = "Invalid TIN";
        case 168: res = "CMC does not fiskalizirovana";
        case 169: res = "Not specified serial number";
        case 170: res = "No Report";
        case 171: res = "Mode is not activated";
        case 172: res = "None specified check in KL";
        case 173: res = "No more entries KL";
        case 174: res = "Incorrect code number or security code CMC";
        case 176: res = "Required to do a total extinction";
        case 177: res = "The command is not permitted imposed codes protect MCF";
        case 178: res = "Can not cancel discounts / surcharges";
        case 179: res = "Unable to close a check for this type of payment (check there operation without the control of cash)";
        case 186: res = "Error communicating with the fiscal module";
        case 190: res = "Necessary to carry out maintenance work";
        case 200: res = "No device that handles the command";
        case 201: res = "No connection to an external device";
        case 202: res = "The error state TRC";
        case 203: res = "More than one registration check";
        case 204: res = "Wrong number TRK";
        case 205: res = "Wrong divider";
        case 207: res = "In the PFC produced 20 activations";
        case 208: res = "Activating this EKLZ as part of the CMC can not be";
        case 209: res = "Overheated print head";
        case 210: res = "Error communicating with EKLZ at interface I2C";
        case 211: res = "Error transmission format EKLZ";
        case 212: res = "Wrong state EKLZ";
        case 213: res = "Fatal error EKLZ";
        case 214: res = "Accident crypto-processor EKLZ";
        case 215: res = "Exhausted time resource EKLZ";
        case 216: res = "EKLZ full";
        case 217: res = "In EKLZ passed invalid date or time";
        case 218: res = "In EKLZ not requested data";
        case 219: res = "EKLZ overflow (total check)";
        case 220: res = "Buffer is full";
        case 221: res = "Can not print a copy of the second fiscal";
        otherwise
          res = "Unkwnown error: " & PMsgErrorCode;
      end;
  end;
  PMsg_TranslateMessage = res;
  return;
end;

// [COMM/] For handling Unicode text
procedure PMsg_PrinterCodePage(var array integer CrossRef) 
begin
  integer unicode,pinter,i
  
  unicode = 1040;
  for(i=128;i<=175;i=i+1) begin
    CrossRef[unicode] = i;
    unicode = unicode + 1;
  end;
  for(i=224;i<=239;i=i+1) begin
    CrossRef[unicode] = i;
    unicode = unicode + 1;
  end;
  
  return;
end;

// [COMM/] Printer message construction routine
function string 255 PMsg_FormatMessage(integer CommandConst,string Message) 
begin
  string 255 res,tstr;
  string 4 password;
  string 10 cmd;
  integer strlen,i,checksum;

  cmd = PMsg_Commands(CommandConst);

  password = "0000";  
  res = chr(CC_STX);
  // [COMM/] Password is put visually to HEX format, meaning that password "1234" will become 0x1234
  res = res & HexStrToChrStr(password,false);
  res = res & cmd;
  res = res & Message;
  // [COMM/] mask all 0x03 and 0x10 with a 0x10 -> similar to \ -> \\ masking 
  res = StrReplace(res,uchr(16),uchr(16)&uchr(16));
  res = StrReplace(res,uchr(3),uchr(16)&uchr(3));
  res = res & chr(CC_ETX);
  strlen = Len(res);
  
  for(i=1;i<strlen;i=i+1) begin
    checksum = BitXor(asc(Mid(res,i,1)),checksum);
  end;
  
  res = res & uchr(checksum);

  PMsg_FormatMessage = res;
  return;
end;

function string 255 PMsg_FormatAnswer(string Message) 
begin
  string 255 res;
  
  res = StrReplace(Message,uchr(16)&uchr(16),uchr(16));
  res = StrReplace(res,uchr(16)&uchr(3),uchr(3));
  PMsg_FormatAnswer = res;
  return;
end;

// [COMM/] Extension handler // This function will be added to PMsgTools.hal // No need to change anything here (only if you want to comment something out that you're not using) :: APE
global
function string 255 PMsgExtension_FPrint02K(integer PMsgExtensionType,integer PMsgExtensionVarId,string KeyWord,var array integer format,var array string msgstack,array string altparams) 
begin
  string 255 res;

  switch(PMsgExtensionType) begin
    case PMsgExtensionType_Settings:  
      res = PMsg_Settings(PMsgExtensionVarId);
    case PMsgExtensionType_Cmd: 
      res = PMsg_Commands(PMsgExtensionVarId);
    case PMsgExtensionType_AlternativeCmd:
      PMsg_AlternativeCommands(PMsgExtensionVarId,msgstack,altparams);
    case PMsgExtensionType_Pack: 
      PMsg_MessageVariables(PMsgExtensionVarId,format);
    case PMsgExtensionType_MFormat: 
      res = PMsg_FormatMessage(PMsgExtensionVarId,KeyWord);    
    case PMsgExtensionType_AFormat:
      res = PMsg_FormatAnswer(KeyWord);
    case PMsgExtensionType_ErrorMsg: 
      res = PMsg_TranslateMessage(PMsgExtensionVarId,StringToInt(KeyWord));
    case PMsgExtensionType_Error: 
      res = PMsg_CommonError(PMsgExtensionVarId);
    case PMsgExtensionType_Answer: 
      res = PMsg_NativeAnswers(PMsgExtensionVarId);
    case PMsgExtensionType_UnPack: 
      PMsg_AnswerVariables(PMsgExtensionVarId,format);
    case PMsgExtensionType_Routines:
      PMsg_Routines(PMsgExtensionVarId,format);      
    case PMsgExtensionType_ProcessVariable:
      res = KeyWord;
    case PMsgExtensionType_Constant:
      res = PMsg_Constant(PMsgExtensionVarId,KeyWord);
    case PMsgExtensionType_CmdCtrl:
      res = PMsg_CommandControl(PMsgExtensionVarId,StringToInt(KeyWord));
    case PMsgExtensionType_InnerCodePage:
      PMsg_PrinterCodePage(format);
    otherwise
      res = "-1";
  end;

  // [COMM/] Convert length from bit>byte
  format[1] = format[1]/8;  
  PMsgExtension_FPrint02K = res;
  return;
end;