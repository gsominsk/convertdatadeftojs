external procedure LogAreaToFile(string,area);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external function roundmode GetVATRoundMode(record RoundBlock);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure GetVATproc(string,Integer,var val);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure SetupVATBase(var record SMVc,var Integer);
external updating procedure PrintFI550Receipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintEPSONINVOICEReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintHASARReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintHASARPL23FPANReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFM3000Receipt(record IVVc,record LSerialPortDeviceVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Integer POSNETAcceptBOS_POSNETY(record IVVc);
external function Integer POSNETAcceptBOS_OPTIMUS(record IVVc);
external procedure POSNETCheckSum(var string);
external function Integer POSNETInString(string,string);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure POSNETGetByte(string,Integer,Integer,var string);
external function LongInt POSNETHexToLong(string);
external function Integer GetPOSNETErrorCode(string);
external function Integer GetPOSNETDate(string,var Integer,var Integer,var Integer);
external procedure GetPOSNETVATCode(Array val,Integer,record VATCodeBlock,string,var string);
external function Integer GetPOSNETVATRates(string,var Array val);
external procedure WinToMaz(string,var string);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function string 255 NumToHex(string);

enum begin
  kCleanCashSHORT_DELAY = 500,
  kCleanCashLONG_DELAY = 4000
end;

function string 255 StripLeadingChars(string replystr,string ch)
begin
  Integer i,l;
  string 255 res,tstr;

  tstr = replystr;
  l = len(tstr);
  for (i=0;i<=l;i=i+1) begin
    if (Mid(tstr,i,1)!=ch) then begin
      goto LStripLeadingChars;
    end;
  end;
LStripLeadingChars:; 
  res = Mid(tstr,i,l);
  StripLeadingChars = res;
  return;
end;

function string 255 ValueFromReply(var string replystr,Integer fromfield)
begin
  string 255 res;
  Integer pos,cnt;
  
  pos = 0;
  cnt = 1;
  replystr = StripLeadingChars(replystr,chr(13));
  ExtractObjWithSeparator("#",replystr,true,pos,res);
  while ((nonblank(res)) and (cnt!=fromfield)) begin
    ExtractObjWithSeparator("#",replystr,true,pos,res);
    cnt = cnt + 1;
  end;
  if (cnt!=fromfield) then begin
    res = "";
  end;
  ValueFromReply = res;
  return;
end;

function string 255 CalculateLRC(string CtrlSeq)
begin
  string 255 res;
  Integer i,resi;
  
  resi = 0;
  for (i=0;i<len(CtrlSeq);i=i+1) begin
    resi = BitXor(resi,asc(Mid(CtrlSeq,i,1)));
  end;
  res = NumToHex(resi);
  res = Right(res,2);
  CalculateLRC = res;
  return;
end;

function Boolean TestLRC(string msg) 
begin
  Boolean res;
  string 255 tstr;
  
  res = true;
  if (nonblank(msg)) then begin
    tstr = CalculateLRC(Left(msg,len(msg)-3));
    if (tstr!=Mid(msg,len(msg)-3,2)) then begin
//LogText(0,"TestLRC tstr " & tstr & " Mid(msg,len(msg)-3,2) " & Mid(msg,len(msg)-3,2) & " msg " & msg);    
      res = false;
    end;
  end;
  TestLRC = res;
  return;
end;

procedure CleanCashReply(var string replystr)
begin
  replystr = replystr & ReadComPort(0,255-len(replystr));
  if (nonblank(replystr)) then begin
    if (Left(replystr,1)!="#") then begin
//LogText(0,"CleanCashReply Adding # to " & " replystr " & replystr);    
      replystr = "#" & replystr;
//work around for simulator error, home real clean cash box not having this issue      
    end;
  end;
  return;
end;

function string 255 BuildIdentityRequest()
begin
  string 20 CtrlSeq,msglenhex,separator;
  Integer msglen,lengthfieldlen,lrclen;
  
  string 255 IDENTIFIER,MSGTYPE,CR;
  
  lengthfieldlen = 3;
  lrclen = 2;
  
  CR = chr(13);
  separator = "#";  
  IDENTIFIER = "#!#";
  MSGTYPE = "IQ";

  
  CtrlSeq = MSGTYPE & separator;  
  msglen = len(IDENTIFIER) + lengthfieldlen + len(separator) + len(CtrlSeq) + lrclen + len(CR);
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,3);
  CtrlSeq = IDENTIFIER & msglenhex & separator & CtrlSeq;
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = CtrlSeq & CR;

  BuildIdentityRequest = CtrlSeq;
  return;
end;

function string 255 BuildStatusInformationRequest()
begin
  string 20 CtrlSeq,msglenhex,separator;
  Integer msglen,lengthfieldlen,lrclen;
  
  string 255 IDENTIFIER,MSGTYPE,CR;
  
  lengthfieldlen = 3;
  lrclen = 2;
  
  CR = chr(13);
  separator = "#";  
  IDENTIFIER = "#!#";
  MSGTYPE = "SIQ";

  
  CtrlSeq = MSGTYPE & separator;  
  msglen = len(IDENTIFIER) + lengthfieldlen + len(separator) + len(CtrlSeq) + lrclen + len(CR);
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,3);
  CtrlSeq = IDENTIFIER & msglenhex & separator & CtrlSeq;
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = CtrlSeq & CR;

  BuildStatusInformationRequest = CtrlSeq;
  return;
end;

function string 255 TimedOutCleanCashReply(LongInt timeout,string expectedreply,var string errorstr)
begin
  string 255 res,replystr;
  LongInt tickcount, starttick;
  Boolean loopf,timeoutf;

  errorstr = "";
  starttick = GetCurTick;
  tickcount = starttick;
//LogText(0,"1.TimedOutCleanCashReply replystr " & replystr);    
  timeoutf = true;
  loopf = true;
  while (loopf) begin
    tickcount = GetCurTick;
    CleanCashReply(replystr);
    if (Right(replystr,1)==chr(13)) then begin
      loopf = false;
      timeoutf = false;
    end;
    if ((tickcount-starttick)>timeout) then begin
      loopf = false;
    end;
  end;

//LogText(0,"2.TimedOutCleanCashReply replystr " & replystr);    
  if (timeoutf==false) then begin
    if (TestLRC(replystr)==false) then begin
      res = "NAK";
      errorstr = USetStr(12384);
      goto LTimedOutCleanCashReply;
    end;
    res = ValueFromReply(replystr,3);
    switch (res) begin
      case "NAK":
        errorstr = ValueFromReply(replystr,4);
    end;  
  end else begin
    res = "NAK";
  end;
LTimedOutCleanCashReply:;  
  TimedOutCleanCashReply = res;
  return;  
end;

function string 255 HanldeCleanCashTimeout(var string errorstr)
begin
  string 255 res;
  string 255 reply;
  Integer iqcnt,siqcnt;
  Integer nakcnt;
  
  if (OutComPort(0,BuildIdentityRequest)==0) then begin
    res = "sendingtocomfailed";
    goto LHanldeCleanCashTimeout;
  end;
  nakcnt = 0;
  iqcnt = 1;
  while (iqcnt<=10) begin
    reply = TimedOutCleanCashReply(kCleanCashSHORT_DELAY,"IR",errorstr);
    switch (reply) begin
      case "NAK":
        nakcnt = nakcnt + 1;
        if (nakcnt==3) then begin
          res = "IQ_noresponsefromcleancash";
          goto LHanldeCleanCashTimeout;
        end;
      case "IR":
        if (OutComPort(0,BuildStatusInformationRequest)==0) then begin
          res = "sendingtocomfailed";
          goto LHanldeCleanCashTimeout;
        end;
        nakcnt = 0;
        siqcnt = 1;
        while (siqcnt<=10) begin
          reply = TimedOutCleanCashReply(kCleanCashSHORT_DELAY,"SIR",errorstr);
          switch (reply) begin
            case "NAK":
              nakcnt = nakcnt + 1;
              if (nakcnt==3) then begin
                res = "SIQ_noresponsefromcleancash";
                goto LHanldeCleanCashTimeout;
              end;
            case "SIR":
              res = "resend";
              goto LHanldeCleanCashTimeout;
          end;
          siqcnt = siqcnt + 1;
        end;
    end;
    iqcnt = iqcnt + 1;
  end;

LHanldeCleanCashTimeout:;  
  HanldeCleanCashTimeout = res;  
  return;
end;

function Integer WaitForCleanCashReply(string CtrlSeq,string expectedreply,LongInt timeout,var string errorstr,var string replystr)
begin
  Integer res;
  Integer noErr;
  LongInt tickcount, starttick;
  Boolean timeoutf,loopf;
  string 255 timeoutreply;
  Integer resendcnt;

//LogText(0,"WaitForCleanCashReply CtrlSeq " & CtrlSeq);    
LWaitForCleanCashReply_Start:;
  res = 12380;
  replystr = "";
  timeoutf = true;
  starttick = GetCurTick;
  tickcount = starttick;
  loopf = true;
  while (loopf) begin
    tickcount = GetCurTick;
    CleanCashReply(replystr);
    if (Right(replystr,1)==chr(13)) then begin
      loopf = false;
      timeoutf = false;
    end;
    if ((tickcount-starttick)>timeout) then begin
      loopf = false;
    end;
  end;
  
//LogText(0,"WaitForCleanCashReply replystr " & replystr);    

//Trace("WaitForCleanCashReply replystr " & replystr," tickcount-starttick " & tickcount-starttick);  
  if (timeoutf==false) then begin
    if (TestLRC(replystr)==false) then begin
      res = 12384;
      goto LWaitForCleanCashReply;
    end;
    switch (ValueFromReply(replystr,3)) begin 
      case "ACK": //#!#00E#ACK#2D#
        res = 0;
        goto LWaitForCleanCashReply;
      case "NAK":
        res = 12381;
        errorstr = ValueFromReply(replystr,4);
        switch (errorstr) begin
          case "003": errorstr = USetStr(12386);
          case "007": errorstr = USetStr(12385);
        end;
        goto LWaitForCleanCashReply;
      otherwise
        if (nonblank(expectedreply)) then begin
          if (ValueFromReply(replystr,3)==expectedreply) then begin
            switch (expectedreply) begin
              case "SIR":
                switch (ValueFromReply(replystr,4)) begin
                  case "0":
                    timeoutf = false;
                    res = 0;
                    goto LWaitForCleanCashReply;
                  case "1":
                    timeoutf = false;
                    res = 0;
                    LogText(12381," " & ValueFromReply(replystr,4) & " " & ValueFromReply(replystr,5));
                    goto LWaitForCleanCashReply;
                  case "2":
                    timeoutf = false;
                    res = 12381;
                    LogText(12381," " & ValueFromReply(replystr,4) & " " & ValueFromReply(replystr,5));
                    goto LWaitForCleanCashReply;
                  case "3":
                    timeoutf = false;
                    res = 12381;
                    LogText(12381," " & ValueFromReply(replystr,4) & " " & ValueFromReply(replystr,5));
                    goto LWaitForCleanCashReply;
                  case "4":
                    timeoutf = false;
                    res = 12381;
                    LogText(12381," " & ValueFromReply(replystr,4) & " " & ValueFromReply(replystr,5));
                    goto LWaitForCleanCashReply;
                  case "5":
                    timeoutf = false;
                    res = 12381;
                    LogText(12381," " & ValueFromReply(replystr,4) & " " & ValueFromReply(replystr,5));
                    goto LWaitForCleanCashReply;
                end;
              otherwise
                timeoutf = false;
                res = 0;
                goto LWaitForCleanCashReply;
            end;
  //Trace("WaitForCleanCashReply replystr " & replystr," ValueFromReply(replystr,3) " & ValueFromReply(replystr,3) & " expectedreply " & expectedreply);  
          end;
        end;
    end;
  end else begin
    timeoutreply = HanldeCleanCashTimeout(errorstr);
    switch (timeoutreply) begin
      case "sendingtocomfailed":
        res = 12380;
      case "IQ_noresponsefromcleancash":
        res = 12381;
        errorstr = USetStr(12380);
      case "SIQ_noresponsefromcleancash":
        res = 12381;
        errorstr = USetStr(12380);
      case "resend":
        if (resendcnt>10) then begin
          res = 1;
          goto LWaitForCleanCashReply;
        end;        
        if (OutComPort(0,CtrlSeq)==0) then begin
          res = 12382;
          goto LWaitForCleanCashReply;
        end;
        resendcnt = resendcnt + 1;
        goto LWaitForCleanCashReply_Start;
    end;
  end;
LWaitForCleanCashReply:;
//Trace("2. WaitForCleanCashReply replystr " & replystr,"");  

  WaitForCleanCashReply = res;
  return;  
end;

function Integer WritetoCleanCash(string CtrlSeq,string expectedreply,LongInt errtimeout,var string errorstr,var string replystr)
begin
  Integer res;
  Integer noErr;

  res = noErr;
//Trace("1. WritetoCleanCash CtrlSeq " & CtrlSeq,"");  
  if (OutComPort(0,CtrlSeq)==0) then begin//failed
    res = 12382;
    goto LWritetoCleanCash;
  end;
//Trace("2. WritetoCleanCash CtrlSeq " & CtrlSeq,"");  
  res = WaitForCleanCashReply(CtrlSeq,expectedreply,errtimeout,errorstr,replystr);
  if (res!=noErr) then begin
    if (nonblank(errorstr)) then begin
      MessageBox(res,errorstr);
    end;
    goto LWritetoCleanCash;
  end;      
LWritetoCleanCash:;
  WritetoCleanCash = res;
  return;
end;

function Integer SendRequesttoCleanCash(string message,string expectedreply,Integer timeout,var string replystr,var string errorstr)
begin
  Integer res,noErr;
  string 255 CtrlSeq,msglenhex,separator;
  string 255 IDENTIFIER,CR;
  Integer msglen,lengthfieldlen,lrclen;
  
//#<IDENTIFIER>#<LENGTH>#<MSGTYPE>#<FIELD 1>#...#<FIELD N>#<LRC><CR>  

  lengthfieldlen = 3;
  lrclen = 2;
  
  CR = chr(13);
  separator = "#";  
  IDENTIFIER = "#!#";
  
  CtrlSeq = message;  
  msglen = len(IDENTIFIER) + lengthfieldlen + len(separator) + len(CtrlSeq) + lrclen + len(CR);
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,3);
  CtrlSeq = IDENTIFIER & msglenhex & separator & CtrlSeq;
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = CtrlSeq & CR;  
  
//  logtext(0,"SEND | " & Trim(CtrlSeq));  
  res = WritetoCleanCash(CtrlSeq,expectedreply,timeout,errorstr,replystr);
//  logtext(0,"READ | " & Trim(replystr));

  SendRequesttoCleanCash = res;
  return;
end;

procedure CloseCleanCash()
begin
  Integer res;

  res = CloseComPort(0);
  return;
end;

function Integer OpenCleanCash(record LSerialPortDeviceVc LSPDr)
begin
  Integer res,noErr;
  string 255 ldevice;
 
  ldevice = LSPDr.Port;
  if (blank(ldevice)) then begin
    ldevice = "COM1";
  end;
  if (SetComPortCodepage(StringSetFromString(89,LSPDr.Codepage))) then begin end;
  res = OpenComPort(0,ldevice,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);
  if (res!=1) then begin
    MessageBox(12383,"");
    res = 12383;
    goto LOpenCleanCash;
  end else begin
    res = noErr;
  end;
/*baudrate = 9600
  parity = 0(no)
  bytesize = 8
  stopbits = 0(1 stopbit)
  
*/  
LOpenCleanCash:;
  OpenCleanCash = res;
  return;
end;

function Integer StartReceiptCleanCash(var string errorstr)
begin
  Integer res;
  string 255 MSGTYPE,separator,req;
  string 255 replystr;
  
  separator = "#";  
  MSGTYPE = "ST";
  req = MSGTYPE & separator;
  res = SendRequesttoCleanCash(req,"",kCleanCashSHORT_DELAY,replystr,errorstr);  
  StartReceiptCleanCash = res;
  return;
end;

global
function Integer CalculateVATTotalsCleanCash(record IVVc IVr,var record SMVc VATr,var val positivetotal,var record SMVc pVATr,var val negativetotal,var record SMVc nVATr)
begin
  Integer res;
  Integer i,rwcnt;
  row iVVc IVrw;
  Integer vatcnt;
  val tax1reb,vatprc;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  record GeneralOptionBlock GOb;
  val norebrowsum,v;
     
  BlockLoad(GOb);     
  positivetotal = blankval;
  negativetotal = blankval;
  SetupVATBase(VATr,vatcnt);
  SetupVATBase(nVATr,vatcnt);
  SetupVATBase(pVATr,vatcnt);
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
      if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) then begin
        IVrw.rowGP = -IVrw.rowGP;
        IVrw.Sum = -IVrw.Sum;
      end;
    end;
    if (IVrw.stp==kInvoiceRowTypeVoid) then begin
      goto LSkipInvoiceRow;
    end;
    if ((IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeInterest) or (IVrw.stp==kInvoiceRowTypeCorrection) or (IVrw.stp==kInvoiceRowTypeRetention)) then begin    
      if (IVrw.Sum>0) then begin
        positivetotal = positivetotal + IVrw.Sum;
        AddVATBase(pVATr,IVrw.VATCode,IVrw.Sum,tax1reb,vatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
/*
        CalcSum(IVrw.Quant,IVrw.Price,IVrw.PriceFactor,0.00,norebrowsum,GOb.UseDiscount);
        if (norebrowsum!=IVrw.Sum) then begin
          v = norebrowsum - IVrw.Sum;
          negativetotal = negativetotal - v;
          AddVATBase(nVATr,IVrw.VATCode,v,tax1reb,vatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
        end;
*/
      end else begin
        negativetotal = negativetotal + IVrw.Sum;
        AddVATBase(nVATr,IVrw.VATCode,IVrw.Sum,tax1reb,vatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
      end;
      AddVATBase(VATr,IVrw.VATCode,IVrw.Sum,tax1reb,vatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
      
      GetVATproc(IVrw.VATCode,0,vatprc);
      for (ai=1;ai<acnt;ai=ai+1) begin
        if (avatrates[ai]==vatprc) then begin
          goto LCalculateVATTotalsCleanCash;
        end;
      end;
      acnt = acnt + 1;
      avatrates[acnt] = vatprc;
LCalculateVATTotalsCleanCash:;
    end;
LSkipInvoiceRow:;    
  end;    
//  CalcVATBaseVAT(pVATr,IVr.InclVAT,IVr.NoTAXonVAT,vatcnt,s3,tax1sum); 
  if (acnt>4) then begin
    res = 12387;
    MessageBox(res,"");
  end;
  if ((nonblank(positivetotal) and positivetotal>0.00) and (nonblank(negativetotal) and negativetotal<0.00)) then begin
    res = 12389;
    MessageBox(res,"");
  end;
  CalculateVATTotalsCleanCash = res;
  return;
end;

function Integer SignatureReuqestCleanCash(var record IVVc IVr,var string errorstr)
begin
  Integer res;
  string 255 req,MSGTYPE,separator;
  string 255 replystr;
   
  separator = "#";  
  MSGTYPE = "SQ";    
  req = MSGTYPE & separator;
  res = SendRequesttoCleanCash(req,"SR",kCleanCashSHORT_DELAY,replystr,errorstr);
  if (blank(IVr.OfficialSerNr)) then begin
    IVr.OfficialSerNr = ValueFromReply(replystr,4);
  end else begin
    if (blank(IVr.OfficialSerNr2)) then begin
      IVr.OfficialSerNr2 = ValueFromReply(replystr,4);
    end;
  end;
  SignatureReuqestCleanCash = res;
  return;
end;

function Integer ReceiptHeaderCleanCash(record IVVc IVr,record SMVc VATr,var val positivetotal,record SMVc pVATr,var val negativetotal,record SMVc nVATr,var string errorstr)
begin
  Integer res,noErr;
  string 20 separator,tstr;
  string 255 MSGTYPE,req;
  record CYBlock CYb;
  row SMVc VATrw;
  Integer i,rwcnt,err;
  val vatprc,vat,t1;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  string 255 replystr;
  record RoundBlock Roundb;
  Array val apvat;
  Array val apvatbase;
  Array val apvatrates;
  val totvat;
  
  
//#<IDENTIFIER>#<LENGTH>#<MSGTYPE>#<FIELD 1>#...#<FIELD N>#<LRC><CR>  

  BlockLoad(CYb);
  BlockLoad(Roundb);
  
  separator = "#";  
  MSGTYPE = "RH";
  
  req = MSGTYPE & separator;  
  req = req & DateToString(IVr.TransDate,"YYYYMMDD") & Left(StripNonDigits(CurrentTime),4) & separator;  
  req = req & IVr.FiscalDeviceSeqNr & separator;  
  req = req & CurMachineName & separator;  
  req = req & CurrentUser & separator;  
  req = req & " " & separator;  
  req = req & StripNonDigits(CYb.OrgNr) & separator;

  totvat = 0.00;
  positivetotal = MulRateToBase1(IVr.CurncyCode,positivetotal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(pVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(pVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVr.CurncyCode,VATrw.DebVal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVr.InclVAT,IVr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (IVr.InclVAT==0) then begin
    positivetotal = positivetotal + totvat;
  end;

  totvat = 0.00;
  negativetotal = MulRateToBase1(IVr.CurncyCode,negativetotal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(nVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(nVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVr.CurncyCode,VATrw.DebVal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVr.InclVAT,IVr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (IVr.InclVAT==0) then begin
    negativetotal = negativetotal + totvat;
  end;
  

  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
    tstr = ValToString(-IVr.BaseSum4,M4Val,"",",",0);
    req = req & tstr & separator;  
    negativetotal = -IVr.BaseSum4;
    tstr = ValToString(-negativetotal,M4Val,"",",",0);
    req = req & tstr & separator;  
  end else begin
    tstr = ValToString(IVr.BaseSum4,M4Val,"",",",0);
    req = req & tstr & separator;  
    if (blank(negativetotal)) then begin
      negativetotal = 0.00;
    end;    
    if (negativetotal<0.00) then begin
      negativetotal = -negativetotal;
    end;
    tstr = ValToString(negativetotal,M4Val,"",",",0);
    req = req & tstr & separator;  
  end;
  
/*  
  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) or (IVr.BaseSum4<0) then begin
    if (IVr.BaseSum4<0) then begin
      tstr = ValToString(-IVr.BaseSum4,M4Val,"",",",0);
    end else begin
      tstr = ValToString(IVr.BaseSum4,M4Val,"",",",0);
    end;
    req = req & "0,00" & separator;  
    req = req & tstr & separator;  
  end else begin
    tstr = ValToString(IVr.BaseSum4,M4Val,"",",",0);
    req = req & tstr & separator;  
    req = req & "0,00" & separator;  
  end;
*/  
  if (blank(IVr.OfficialSerNr)) then begin
    req = req & "normal" & separator;  
  end else begin
    req = req & "kopia" & separator;  
  end;
  acnt = 0;
  rwcnt = MatRowCnt(VATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVr.CurncyCode,VATrw.DebVal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVr.InclVAT,IVr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    for (ai=1;ai<acnt;ai=ai+1) begin
      if (avatrates[ai]==vatprc) then begin
        avatbase[ai] = avatbase[ai] + VATrw.DebVal;
        avat[ai] = avat[ai] + vat;
        goto LVATRateAdded;
      end;
    end;
    acnt = acnt + 1;
    avatrates[acnt] = vatprc;
    avatbase[acnt] = VATrw.DebVal;
    avat[acnt] = vat;
LVATRateAdded:;    
  end;
  for (ai=1;ai<=4;ai=ai+1) begin
    if (ai>acnt) or (blank(avatbase[ai])) then begin
      req = req & " ";
    end else begin
      tstr = ValToString(avatrates[ai],M4Val,"",",",0);
      req = req & tstr;
      req = req & ";";
      tstr = ValToString(avat[ai],M4Val,"",",",0);
      req = req & tstr;
    end;
    req = req & separator;  
  end;
  
  res = SendRequesttoCleanCash(req,"",kCleanCashLONG_DELAY,replystr,errorstr);    

  if (res!=noErr) then begin
    switch (ValueFromReply(replystr,3)) begin
      case "NAK":
        MSGTYPE = "SIQ";    
        req = MSGTYPE & separator;
        err = SendRequesttoCleanCash(req,"SIR",kCleanCashSHORT_DELAY,replystr,errorstr);
        if (err!=noErr) then begin
          errorstr = ValueFromReply(replystr,4) & ", " & ValueFromReply(replystr,5);
          MessageBox(err,errorstr);
        end;
    end;
  end;

LReceiptHeaderCleanCash:;  
  ReceiptHeaderCleanCash = res;
  return;
end;

global
function Integer TestCleanCashIdentity(Boolean opencomf,record LSerialPortDeviceVc LSPDr,string terminalid,var string errorstr)
begin
  Integer err,noErr;
  string 255 req,MSGTYPE,separator;
  string 255 replystr,mfgid;
  
  noErr = 0;
    
  if (opencomf) then begin
    err = OpenCleanCash(LSPDr);
    if (err!=noErr) then begin
      goto LTestCleanCashIdentity;
    end;   
  end;
  separator = "#";  
  MSGTYPE = "IQ";    
  req = MSGTYPE & separator;
  err = SendRequesttoCleanCash(req,"IR",kCleanCashSHORT_DELAY,replystr,errorstr);
  mfgid = ValueFromReply(replystr,4);
  if (err!=noErr) then begin
    goto LTestCleanCashIdentity;
  end;
  MSGTYPE = "SIQ";    
  req = MSGTYPE & separator;
  err = SendRequesttoCleanCash(req,"SIR",kCleanCashSHORT_DELAY,replystr,errorstr);
  if (err!=noErr) then begin
    errorstr = ValueFromReply(replystr,4) & ", " & ValueFromReply(replystr,5);
    goto LTestCleanCashIdentity;
  end;
  if (mfgid!=terminalid) then begin
    err = 22122;
    errorstr = mfgid;
  end;  
LTestCleanCashIdentity:;  
  if (opencomf) then begin
    CloseCleanCash;
  end;
  TestCleanCashIdentity = err;
  return;
end;

function LongInt MAX(LongInt a,LongInt b)
begin
  LongInt res;
  
  if (a>=b) then begin
    res = a;
  end else begin
    res = b;
  end;
  Max = res;
  return;
end;

function LongInt NextFiscalDeviceSeqNrCleanCash(record LocalMachineBlock LMb,LongInt FiscalDeviceSeqNr)
begin
//Client-Server
  LongInt res;
  record IVVc prevIVr;
  record IVCashVc prevIVCr;
  record RestAccVc prevRAr;
  
  RecordClear(prevIVr);
  prevIVr.TerminalID = LMb.TerminalID;
  if (LoopBackKey("TerminalID",prevIVr,1,true)) then begin
//    if (prevIVr.TerminalID==LMb.TerminalID) then begin
//      if (LoopBackKey("TerminalID",prevIVr,1,true)) then begin    
//Trace("2.prevIVr.FiscalDeviceSeqNr " & prevIVr.FiscalDeviceSeqNr," prevIVr.SerNr " & prevIVr.SerNr);
//      end;
//    end;
  end;
  if (prevIVr.TerminalID!=LMb.TerminalID) then begin
    prevIVr.FiscalDeviceSeqNr = -1;
  end;

  RecordClear(prevIVCr);
  prevIVCr.TerminalID = LMb.TerminalID;
  if (LoopBackKey("TerminalID",prevIVCr,1,true)) then begin
//    if (prevIVCr.TerminalID==LMb.TerminalID) then begin
//      if (LoopBackKey("TerminalID",prevIVCr,1,true)) then begin    
//Trace("4,prevIVCr.FiscalDeviceSeqNr " & prevIVCr.FiscalDeviceSeqNr," prevIVCr.SerNr " & prevIVCr.SerNr);
//      end;
//    end;
  end;
  if (prevIVCr.TerminalID!=LMb.TerminalID) then begin
    prevIVCr.FiscalDeviceSeqNr = -1;
  end;

  RecordClear(prevRAr);
  prevRAr.TerminalID = LMb.TerminalID;
  if (LoopBackKey("TerminalID",prevRAr,1,true)) then begin
//    if (prevRAr.TerminalID==LMb.TerminalID) then begin
//      if (LoopBackKey("TerminalID",prevRAr,1,true)) then begin    
//Trace("4,prevRAr.FiscalDeviceSeqNr " & prevRAr.FiscalDeviceSeqNr," prevRAr.SerNr " & prevRAr.SerNr);
//      end;
//    end;
  end;
  if (prevRAr.TerminalID!=LMb.TerminalID) then begin
    prevRAr.FiscalDeviceSeqNr = -1;
  end;

//Trace("prevIVr.FiscalDeviceSeqNr " & prevIVr.FiscalDeviceSeqNr," prevIVr.SerNr " & prevIVr.SerNr);
//Trace("prevIVCr.FiscalDeviceSeqNr " & prevIVCr.FiscalDeviceSeqNr," prevIVCr.SerNr " & prevIVCr.SerNr);

/*
  if (prevIVr.FiscalDeviceSeqNr>prevIVCr.FiscalDeviceSeqNr) then begin
    res = prevIVr.FiscalDeviceSeqNr;
  end else begin
    res = prevIVCr.FiscalDeviceSeqNr;
  end;
*/
  res = Max(prevIVr.FiscalDeviceSeqNr,prevIVCr.FiscalDeviceSeqNr);
  res = Max(res,prevRAr.FiscalDeviceSeqNr);

  res = res + 1;
  if (res<=0) then begin
    res = 1;
  end;  
  NextFiscalDeviceSeqNrCleanCash = res;
  return;
end;

global
updating function integer CommunicateWithCleanCash(var record IVVc IVr,var record IVVc oldIVr,record LocalMachineBlock LMb,record LSerialPortDeviceVc LSPDr,
                                                   record SMVc VATr,record SMVc pVATr,record SMVc nVATr,val positivetotal,val negativetotal,var string errorstr)
begin
  integer err,noErr;
  
  noErr = 0;
  
  err = OpenCleanCash(LSPDr);
  if (err!=noErr) then begin
    errorstr = USetStr(err);
    goto LCommunicateWithCleanCash;
  end;
  err = TestCleanCashIdentity(false,LSPDr,LMb.TerminalID,errorstr);
  if (err!=noErr) then begin
    errorstr = err & ": " & errorstr;
    goto LCommunicateWithCleanCash;
  end;
  err = StartReceiptCleanCash(errorstr);
  if (err!=noErr) then begin
    goto LCommunicateWithCleanCash;
  end;
  RecordCopy(oldIVr,IVr);
  if (IVr.FiscalDeviceSeqNr<=0) then begin
    IVr.FiscalDeviceSeqNr = NextFiscalDeviceSeqNrCleanCash(LMb,IVr.FiscalDeviceSeqNr);
  end;
  err = ReceiptHeaderCleanCash(IVr,VATr,positivetotal,pVATr,negativetotal,nVATr,errorstr);
  if (err!=noErr) then begin
    goto LCommunicateWithCleanCash;
  end;
  err = SignatureReuqestCleanCash(IVr,errorstr);
  if (err!=noErr) then begin
    goto LCommunicateWithCleanCash;
  end;
  
LCommunicateWithCleanCash:;
  CloseCleanCash;
  CommunicateWithCleanCash = err;
  return;
end;

global
updating function Boolean StoreCleanCashReceipt(record LocalMachineBlock LMb,var record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  Boolean res;
  Integer err,noErr;
  record SMVc VATr;
  record SMVc pVATr;
  record SMVc nVATr;
  record IVVc oldIVr;
  val positivetotal,negativetotal;
  string 255 errorstr;
  
//8.4 CCSP v1 Mode A/C sequence chart
  
  noErr = 0;
  
  if ((nonblank(IVr.OfficialSerNr)) and (nonblank(IVr.OfficialSerNr2))) then begin
    MessageBox(12388,"");
    goto LStoreCleanCashReceipt;
  end;
  err = CalculateVATTotalsCleanCash(IVr,VATr,positivetotal,pVATr,negativetotal,nVATr);
  if (err!=noErr) then begin
    goto LStoreCleanCashReceipt;
  end;
  
  err = CommunicateWithCleanCash(IVr,oldIVr,LMb,LSPDr,VATr,pVATr,nVATr,positivetotal,negativetotal,errorstr);
  if (err!=noErr) then begin
    MessageBox(errorstr,"");
    goto LStoreCleanCashReceipt;
  end;
  
  IVr.FiscalFlag = 1;
  if (RecordUpdate(oldIVr,IVr,false)==0) then begin
    res = true;
  end;
  PrintDocument(IVr,"CashInvForm",false);
  ReadFirstMain(IVr,1,true);
  if (IVr.Prntdf!=1) then begin
    RecordCopy(oldIVr,IVr);
    IVr.Prntdf = 1;
    if (RecordUpdate(oldIVr,IVr,false)==0) then begin end;
  end;
LStoreCleanCashReceipt:;
  StoreCleanCashReceipt = res;
  return;
end;

global
function Integer CalculateVATTotalsCleanCash_IVCashVc(record IVCashVc IVCashr,var record SMVc VATr,var val positivetotal,var record SMVc pVATr,var val negativetotal,var record SMVc nVATr)
begin
  Integer res;
  Integer i,rwcnt;
  row IVCashVc IVCashrw;
  Integer vatcnt;
  val tax1reb,vatprc;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  record GeneralOptionBlock GOb;
  val norebrowsum,v;
     
  BlockLoad(GOb);          
  positivetotal = blankval;
  negativetotal = blankval;
  SetupVATBase(VATr,vatcnt);
  SetupVATBase(nVATr,vatcnt);
  SetupVATBase(pVATr,vatcnt);
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    if (IVCashrw.stp==kInvoiceRowTypeVoid) then begin
      goto LSkipInvoiceRow;
    end;
    if ((IVCashrw.stp==kInvoiceRowTypeNormal) or (IVCashrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVCashrw.stp==kInvoiceRowTypeInterest) or (IVCashrw.stp==kInvoiceRowTypeCorrection) or (IVCashrw.stp==kInvoiceRowTypeRetention)) then begin    
      if (IVCashrw.Sum>0) then begin
        positivetotal = positivetotal + IVCashrw.Sum;
        AddVATBase(pVATr,IVCashrw.VATCode,IVCashrw.Sum,tax1reb,vatcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
/*
        CalcSum(IVCashrw.Quant,IVCashrw.Price,IVCashrw.PriceFactor,0.00,norebrowsum,GOb.UseDiscount);
        if (norebrowsum!=IVCashrw.Sum) then begin
          v = norebrowsum - IVCashrw.Sum;
          negativetotal = negativetotal - v;
          AddVATBase(nVATr,IVCashrw.VATCode,v,tax1reb,vatcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
        end;
*/
      end else begin
        negativetotal = negativetotal + IVCashrw.Sum;
        AddVATBase(nVATr,IVCashrw.VATCode,IVCashrw.Sum,tax1reb,vatcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
      end;
      AddVATBase(VATr,IVCashrw.VATCode,IVCashrw.Sum,tax1reb,vatcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
      
      GetVATproc(IVCashrw.VATCode,0,vatprc);
      for (ai=1;ai<acnt;ai=ai+1) begin
        if (avatrates[ai]==vatprc) then begin
          goto LCalculateVATTotalsCleanCash;
        end;
      end;
      acnt = acnt + 1;
      avatrates[acnt] = vatprc;
LCalculateVATTotalsCleanCash:;
    end;
LSkipInvoiceRow:;    
  end;    
//  CalcVATBaseVAT(pVATr,IVCashr.InclVAT,IVCashr.NoTAXonVAT,vatcnt,s3,tax1sum); 
  if (acnt>4) then begin
    res = 12387;
    MessageBox(res,"");
  end;
  if ((nonblank(positivetotal) and positivetotal>0.00) and (nonblank(negativetotal) and negativetotal<0.00)) then begin
    res = 12389;
    MessageBox(res,"");
  end;
  CalculateVATTotalsCleanCash_IVCashVc = res;
  return;
end;

function Integer ReceiptHeaderCleanCash_IVCashVc(record IVCashVc IVCashr,record SMVc VATr,var val positivetotal,record SMVc pVATr,var val negativetotal,record SMVc nVATr,var string errorstr)
begin
  Integer res,noErr;
  string 20 separator,tstr;
  string 255 MSGTYPE,req;
  record CYBlock CYb;
  row SMVc VATrw;
  Integer i,rwcnt,err;
  val vatprc,vat,t1,v;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  string 255 replystr;
  record RoundBlock Roundb;
  Array val apvat;
  Array val apvatbase;
  Array val apvatrates;
  val totvat;
  
  
//#<IDENTIFIER>#<LENGTH>#<MSGTYPE>#<FIELD 1>#...#<FIELD N>#<LRC><CR>  

  BlockLoad(CYb);
  BlockLoad(Roundb);
  
  separator = "#";  
  MSGTYPE = "RH";
  
  req = MSGTYPE & separator;  
  req = req & DateToString(IVCashr.TransDate,"YYYYMMDD") & Left(StripNonDigits(CurrentTime),4) & separator;  
  req = req & IVCashr.FiscalDeviceSeqNr & separator;  
  req = req & CurMachineName & separator;  
  req = req & CurrentUser & separator;  
  req = req & " " & separator;  
  req = req & StripNonDigits(CYb.OrgNr) & separator;

  totvat = 0.00;
  positivetotal = MulRateToBase1(IVCashr.CurncyCode,positivetotal,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(pVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(pVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVCashr.CurncyCode,VATrw.DebVal,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (IVCashr.InclVAT==0) then begin
    positivetotal = positivetotal + totvat;
  end;

  totvat = 0.00;
  negativetotal = MulRateToBase1(IVCashr.CurncyCode,negativetotal,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(nVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(nVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVCashr.CurncyCode,VATrw.DebVal,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (IVCashr.InclVAT==0) then begin
    negativetotal = negativetotal + totvat;
  end;
  


  v = MulRateToBase1(IVCashr.CurncyCode,IVCashr.Sum4,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  tstr = ValToString(v,M4Val,"",",",0);
  req = req & tstr & separator;  
  if (blank(negativetotal)) then begin
    negativetotal = 0.00;
    tstr = ValToString(negativetotal,M4Val,"",",",0);
  end else begin
    tstr = ValToString(-negativetotal,M4Val,"",",",0);
  end;
  req = req & tstr & separator;  
  

  if (blank(IVCashr.OfficialSerNr)) then begin
    req = req & "normal" & separator;  
  end else begin
    req = req & "kopia" & separator;  
  end;
  acnt = 0;
  rwcnt = MatRowCnt(VATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
    VATrw.DebVal = MulRateToBase1(IVCashr.CurncyCode,VATrw.DebVal,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
    vat = Round(vat,GetVATRoundMode(Roundb));
    for (ai=1;ai<acnt;ai=ai+1) begin
      if (avatrates[ai]==vatprc) then begin
        avatbase[ai] = avatbase[ai] + VATrw.DebVal;
        avat[ai] = avat[ai] + vat;
        goto LVATRateAdded;
      end;
    end;
    acnt = acnt + 1;
    avatrates[acnt] = vatprc;
    avatbase[acnt] = VATrw.DebVal;
    avat[acnt] = vat;
LVATRateAdded:;    
  end;
  for (ai=1;ai<=4;ai=ai+1) begin
    if (ai>acnt) or (blank(avatbase[ai])) then begin
      req = req & " ";
    end else begin
      tstr = ValToString(avatrates[ai],M4Val,"",",",0);
      req = req & tstr;
      req = req & ";";
      tstr = ValToString(avat[ai],M4Val,"",",",0);
      req = req & tstr;
    end;
    req = req & separator;  
  end;
  
  res = SendRequesttoCleanCash(req,"",kCleanCashLONG_DELAY,replystr,errorstr);    

  if (res!=noErr) then begin
    switch (ValueFromReply(replystr,3)) begin
      case "NAK":
        MSGTYPE = "SIQ";    
        req = MSGTYPE & separator;
        err = SendRequesttoCleanCash(req,"SIR",kCleanCashSHORT_DELAY,replystr,errorstr);
        if (err!=noErr) then begin
          errorstr = ValueFromReply(replystr,4) & ", " & ValueFromReply(replystr,5);
          MessageBox(err,errorstr);
        end;
    end;
  end;

LReceiptHeaderCleanCash_IVCashVc:;  
  ReceiptHeaderCleanCash_IVCashVc = res;
  return;
end;

function Integer SignatureReuqestCleanCash_IVCashVc(var record IVCashVc IVCashr,var string errorstr)
begin
  Integer res;
  string 255 req,MSGTYPE,separator;
  string 255 replystr;
   
  separator = "#";  
  MSGTYPE = "SQ";    
  req = MSGTYPE & separator;
  res = SendRequesttoCleanCash(req,"SR",kCleanCashSHORT_DELAY,replystr,errorstr);
  if (blank(IVCashr.OfficialSerNr)) then begin
    IVCashr.OfficialSerNr = ValueFromReply(replystr,4);
  end else begin
    if (blank(IVCashr.OfficialSerNr2)) then begin
      IVCashr.OfficialSerNr2 = ValueFromReply(replystr,4);
    end;
  end;
  SignatureReuqestCleanCash_IVCashVc = res;
  return;
end;

global
updating function integer IVCash_CommunicateWithCleanCash(var record IVCashVc IVCashr,var record IVCashVc oldIVCashr,record LocalMachineBlock LMb,record LSerialPortDeviceVc LSPDr,
                                                          record SMVc VATr,record SMVc pVATr,record SMVc nVATr,val positivetotal,val negativetotal,var string errorstr)
begin
  integer err,noErr;
  
  noErr = 0;
  
  err = OpenCleanCash(LSPDr);
  if (err!=noErr) then begin
    errorstr = USetStr(err);
    goto LIVCash_CommunicateWithCleanCash;
  end;
  err = TestCleanCashIdentity(false,LSPDr,LMb.TerminalID,errorstr);
  if (err!=noErr) then begin
    errorstr = err & ": " & errorstr;
    goto LIVCash_CommunicateWithCleanCash;
  end;
  err = StartReceiptCleanCash(errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash;
  end;
  RecordCopy(oldIVCashr,IVCashr);
  if (IVCashr.FiscalDeviceSeqNr<=0) then begin
    IVCashr.FiscalDeviceSeqNr = NextFiscalDeviceSeqNrCleanCash(LMb,IVCashr.FiscalDeviceSeqNr);
  end;
  err = ReceiptHeaderCleanCash_IVCashVc(IVCashr,VATr,positivetotal,pVATr,negativetotal,nVATr,errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash;
  end;
  err = SignatureReuqestCleanCash_IVCashVc(IVCashr,errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash;
  end;
  
LIVCash_CommunicateWithCleanCash:;
  CloseCleanCash;
  IVCash_CommunicateWithCleanCash = err;
  return;
end;

global
updating function integer IVCash_CommunicateWithCleanCash_TypeC(var record IVCashVc IVCashr,var record IVCashVc oldIVCashr,record LocalMachineBlock LMb,record LSerialPortDeviceVc LSPDr,
                                                          record SMVc VATr,record SMVc pVATr,record SMVc nVATr,val positivetotal,val negativetotal,var string errorstr)
begin
  integer err,noErr;
  string 255 host,tstr,nonce,opaque;
  LongInt port,pos;
  Area req,reply;
  string 255 ha1,ha2;
  
  noErr = 0;
  pos = 0;
  GetNextSubstring(LSPDr.Port,pos,":",host);
  GetNextSubstring(LSPDr.Port,pos,":",tstr);
  port = StringToLongInt(tstr);  
  
//  AddTextToArea("Authorization: Digest username=""" & "1" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        password=""" & "1" & """," & chr(13) & chr(10),req);
//  AddTextToArea(chr(13) & chr(10),req);

//  nonce = "f17ac3434ce8464fbf17d4bc818e0318";
//  opaque = "a5b5c2eff60f48629cf8219acb65472e";
  ha1 = LowerCase(md5string("1" & ":" & "" & ":" & "1"));
  ha2 = LowerCase(md5string("" & ":" & "/xccsp"));

  AddTextToArea("Authorization: Digest username=""" & "Kassa" & """," & chr(13) & chr(10),req);
//  AddTextToArea("Authorization: Basic " & base64encode("1" & ":" & "1") & chr(13) & chr(10),req);
  AddTextToArea("        realm=""" & "CleanCash Server" & """," & chr(13) & chr(10),req);
  AddTextToArea("        nonce=""" & nonce & """," & chr(13) & chr(10),req);
//  AddTextToArea("        stale=""" & "false" & """," & chr(13) & chr(10),req);
  AddTextToArea("        uri=""" & "/xccsp" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        cnonce=""" & "" & """," & chr(13) & chr(10),req);
  AddTextToArea("        nc=""" & "00000001" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        opaque=""" & opaque & """," & chr(13) & chr(10),req);
  AddTextToArea("        algorithm=MD5," & chr(13) & chr(10),req);
  AddTextToArea("        qop=auth," & chr(13) & chr(10),req);
  AddTextToArea("        response=""" & LowerCase(md5string(ha1 & ":" & nonce & ":" & ha2)) & """" & chr(13) & chr(10),req);
  AddTextToArea(chr(13) & chr(10),req);

/*
//  AddTextToArea("Authorization: Basic " & base64encode("1" & ":" & "1") & chr(13) & chr(10),req);
//  AddTextToArea(chr(13) & chr(10),req);

  AddTextToArea("<?xml version=""1.0"" encoding=""ISO-8859-1""?>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<request xmlns=""http://www.retailinnovation.se/xccsp"">",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<type>RequestStatus</type>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<data>",req);
  AddTextToArea(chr(13) & chr(10),req);
*/

/*  
  AddTextToArea("<IdentityRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<PosId>POS1</PosId>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<OrgNo>55667756791</OrgNo>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</IdentityRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
*/  
  
/*  
  AddTextToArea("<StatusRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<PosId>kassa2</PosId>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<OrgNo>1234567891</OrgNo>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</StatusRequest>",req);  

  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</data>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</request>",req);
*/

  LogAreaToFile("_IVCash_CommunicateWithCleanCash_TypeC.request.txt",req);
//  if (SendWebRequest(host,port,-1,false,"POST","/xccsp","text/xml","",false,req,reply,10)) then begin
  if (SendRawWebRequest(host,port,false,"POST","/xccsp","text/xml","",false,req,reply,10)) then begin
  end;
  LogAreaToFile("_IVCash_CommunicateWithCleanCash_TypeC.reply.txt",reply);
  
/*  
  err = OpenCleanCash(LSPDr);
  if (err!=noErr) then begin
    errorstr = USetStr(err);
    goto LIVCash_CommunicateWithCleanCash_TypeC;
  end;
  err = TestCleanCashIdentity(false,LSPDr,LMb.TerminalID,errorstr);
  if (err!=noErr) then begin
    errorstr = err & ": " & errorstr;
    goto LIVCash_CommunicateWithCleanCash_TypeC;
  end;
  err = StartReceiptCleanCash(errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash_TypeC;
  end;
  RecordCopy(oldIVCashr,IVCashr);
  if (IVCashr.FiscalDeviceSeqNr<=0) then begin
    IVCashr.FiscalDeviceSeqNr = NextFiscalDeviceSeqNrCleanCash(LMb,IVCashr.FiscalDeviceSeqNr);
  end;
  err = ReceiptHeaderCleanCash_IVCashVc(IVCashr,VATr,positivetotal,pVATr,negativetotal,nVATr,errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash_TypeC;
  end;
  err = SignatureReuqestCleanCash_IVCashVc(IVCashr,errorstr);
  if (err!=noErr) then begin
    goto LIVCash_CommunicateWithCleanCash_TypeC;
  end;
  
LIVCash_CommunicateWithCleanCash_TypeC:;
  CloseCleanCash;
*/  
  IVCash_CommunicateWithCleanCash_TypeC = err;
  return;
end;

global
updating function Boolean StoreCleanCashIVCashReceipt(record LocalMachineBlock LMb,var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  Boolean res;
  Integer err,noErr;
  record SMVc VATr;
  record SMVc pVATr;
  record SMVc nVATr;
  record IVCashVc oldIVCashr;
  val positivetotal,negativetotal;
  string 255 errorstr;

//8.4 CCSP v1 Mode A/C sequence chart

  noErr = 0;
    

  if ((nonblank(IVCashr.OfficialSerNr)) and (nonblank(IVCashr.OfficialSerNr2))) then begin
    MessageBox(12388,"");
    goto LStoreCleanCashIVCashReceipt;
  end;
  err = CalculateVATTotalsCleanCash_IVCashVc(IVCashr,VATr,positivetotal,pVATr,negativetotal,nVATr);
  if (err!=noErr) then begin
    goto LStoreCleanCashIVCashReceipt;
  end;
  
  err = IVCash_CommunicateWithCleanCash(IVCashr,oldIVCashr,LMb,LSPDr,VATr,pVATr,nVATr,positivetotal,negativetotal,errorstr);
  if (err!=noErr) then begin
    MessageBox(errorstr,"");
    goto LStoreCleanCashIVCashReceipt;
  end;
  
  IVCashr.FiscalFlag = 1;
  if (RecordUpdate(oldIVCashr,IVCashr,false)==0) then begin
    res = true;
  end;
  PrintDocument(IVCashr,"InvCashForm",false);
  RecordCopy(oldIVCashr,IVCashr);
  IVCashr.Prntdf = 1;
  if (RecordUpdate(oldIVCashr,IVCashr,false)==0) then begin
  end;
LStoreCleanCashIVCashReceipt:;
  StoreCleanCashIVCashReceipt = res;
  return;
end;

function Integer ReceiptHeaderCleanCash_RestAccVc(record RestAccVc RestAccr,record SMVc VATr,var val positivetotal,record SMVc pVATr,var val negativetotal,record SMVc nVATr,var string errorstr)
begin
  Integer res,noErr;
  string 20 separator,tstr;
  string 255 MSGTYPE,req;
  record CYBlock CYb;
  row SMVc VATrw;
  Integer i,rwcnt,err;
  val vatprc,vat,t1,v;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  string 255 replystr;
  record RoundBlock Roundb;
  Array val apvat;
  Array val apvatbase;
  Array val apvatrates;
  val totvat;
  
  
//#<IDENTIFIER>#<LENGTH>#<MSGTYPE>#<FIELD 1>#...#<FIELD N>#<LRC><CR>  

  BlockLoad(CYb);
  BlockLoad(Roundb);
  
  separator = "#";  
  MSGTYPE = "RH";
  
  req = MSGTYPE & separator;  
  req = req & DateToString(RestAccr.TransDate,"YYYYMMDD") & Left(StripNonDigits(CurrentTime),4) & separator;  
  req = req & RestAccr.FiscalDeviceSeqNr & separator;  
  req = req & CurMachineName & separator;  
  req = req & CurrentUser & separator;  
  req = req & " " & separator;  
  req = req & StripNonDigits(CYb.OrgNr) & separator;

  totvat = 0.00;
//  positivetotal = MulRateToBase1(RestAccr.CurncyCode,positivetotal,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(pVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(pVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
//    VATrw.DebVal = MulRateToBase1(RestAccr.CurncyCode,VATrw.DebVal,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,RestAccr.InclVAT,0);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (RestAccr.InclVAT==0) then begin
    positivetotal = positivetotal + totvat;
  end;

  totvat = 0.00;
//  negativetotal = MulRateToBase1(RestAccr.CurncyCode,negativetotal,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
  acnt = 0;
  rwcnt = MatRowCnt(nVATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(nVATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
//    VATrw.DebVal = MulRateToBase1(RestAccr.CurncyCode,VATrw.DebVal,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,RestAccr.InclVAT,0);
    vat = Round(vat,GetVATRoundMode(Roundb));
    totvat = totvat  + vat;
  end;
  if (RestAccr.InclVAT==0) then begin
    negativetotal = negativetotal + totvat;
  end;
  


//  v = MulRateToBase1(RestAccr.CurncyCode,RestAccr.Sum4,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
  v = RestAccr.Sum4;
  tstr = ValToString(v,M4Val,"",",",0);
  req = req & tstr & separator;  
  if (blank(negativetotal)) then begin
    negativetotal = 0.00;
    tstr = ValToString(negativetotal,M4Val,"",",",0);
  end else begin
    tstr = ValToString(-negativetotal,M4Val,"",",",0);
  end;
  req = req & tstr & separator;  
  

  if (blank(RestAccr.OfficialSerNr)) then begin
    req = req & "normal" & separator;  
  end else begin
    req = req & "kopia" & separator;  
  end;
  acnt = 0;
  rwcnt = MatRowCnt(VATr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATr,i,VATrw);
    GetVATproc(VATrw.VATCode,0,vatprc);
//    VATrw.DebVal = MulRateToBase1(RestAccr.CurncyCode,VATrw.DebVal,RestAccr.FrRate,RestAccr.ToRateB1,RestAccr.ToRateB2,RestAccr.BaseRate1,RestAccr.BaseRate2,DefaultCurRoundOff);
    MulVATIV(VATrw.VATCode,VATrw.DebVal,vat,t1,RestAccr.InclVAT,0);
    vat = Round(vat,GetVATRoundMode(Roundb));
    for (ai=1;ai<acnt;ai=ai+1) begin
      if (avatrates[ai]==vatprc) then begin
        avatbase[ai] = avatbase[ai] + VATrw.DebVal;
        avat[ai] = avat[ai] + vat;
        goto LVATRateAdded;
      end;
    end;
    acnt = acnt + 1;
    avatrates[acnt] = vatprc;
    avatbase[acnt] = VATrw.DebVal;
    avat[acnt] = vat;
LVATRateAdded:;    
  end;
  for (ai=1;ai<=4;ai=ai+1) begin
    if (ai>acnt) or (blank(avatbase[ai])) then begin
      req = req & " ";
    end else begin
      tstr = ValToString(avatrates[ai],M4Val,"",",",0);
      req = req & tstr;
      req = req & ";";
      tstr = ValToString(avat[ai],M4Val,"",",",0);
      req = req & tstr;
    end;
    req = req & separator;  
  end;
  
  res = SendRequesttoCleanCash(req,"",kCleanCashLONG_DELAY,replystr,errorstr);    

  if (res!=noErr) then begin
    switch (ValueFromReply(replystr,3)) begin
      case "NAK":
        MSGTYPE = "SIQ";    
        req = MSGTYPE & separator;
        err = SendRequesttoCleanCash(req,"SIR",kCleanCashSHORT_DELAY,replystr,errorstr);
        if (err!=noErr) then begin
          errorstr = ValueFromReply(replystr,4) & ", " & ValueFromReply(replystr,5);
          MessageBox(err,errorstr);
        end;
    end;
  end;

LReceiptHeaderCleanCash_RestAccVc:;  
  ReceiptHeaderCleanCash_RestAccVc = res;
  return;
end;

function Integer SignatureReuqestCleanCash_RestAccVc(var record RestAccVc RestAccr,var string errorstr)
begin
  Integer res;
  string 255 req,MSGTYPE,separator;
  string 255 replystr;
   
  separator = "#";  
  MSGTYPE = "SQ";    
  req = MSGTYPE & separator;
  res = SendRequesttoCleanCash(req,"SR",kCleanCashSHORT_DELAY,replystr,errorstr);
  if (blank(RestAccr.OfficialSerNr)) then begin
    RestAccr.OfficialSerNr = ValueFromReply(replystr,4);
  end else begin
    if (blank(RestAccr.OfficialSerNr2)) then begin
      RestAccr.OfficialSerNr2 = ValueFromReply(replystr,4);
    end;
  end;
  SignatureReuqestCleanCash_RestAccVc = res;
  return;
end;

global
updating function integer RestAcc_CommunicateWithCleanCash(var record RestAccVc RestAccr,var record RestAccVc oldRestAccr,record LocalMachineBlock LMb,record LSerialPortDeviceVc LSPDr,
                                                          record SMVc VATr,record SMVc pVATr,record SMVc nVATr,val positivetotal,val negativetotal,var string errorstr)
begin
  integer err,noErr;
  
  noErr = 0;
  
  err = OpenCleanCash(LSPDr);
  if (err!=noErr) then begin
    errorstr = USetStr(err);
    goto LRestAcc_CommunicateWithCleanCash;
  end;
  err = TestCleanCashIdentity(false,LSPDr,LMb.TerminalID,errorstr);
  if (err!=noErr) then begin
    errorstr = err & ": " & errorstr;
    goto LRestAcc_CommunicateWithCleanCash;
  end;
  err = StartReceiptCleanCash(errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash;
  end;
  RecordCopy(oldRestAccr,RestAccr);
  if (RestAccr.FiscalDeviceSeqNr<=0) then begin
    RestAccr.FiscalDeviceSeqNr = NextFiscalDeviceSeqNrCleanCash(LMb,RestAccr.FiscalDeviceSeqNr);
  end;
  err = ReceiptHeaderCleanCash_RestAccVc(RestAccr,VATr,positivetotal,pVATr,negativetotal,nVATr,errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash;
  end;
  err = SignatureReuqestCleanCash_RestAccVc(RestAccr,errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash;
  end;
  
LRestAcc_CommunicateWithCleanCash:;
  CloseCleanCash;
  RestAcc_CommunicateWithCleanCash = err;
  return;
end;

global
updating function integer RestAcc_CommunicateWithCleanCash_TypeC(var record RestAccVc RestAccr,var record RestAccVc oldRestAccr,record LocalMachineBlock LMb,record LSerialPortDeviceVc LSPDr,
                                                          record SMVc VATr,record SMVc pVATr,record SMVc nVATr,val positivetotal,val negativetotal,var string errorstr)
begin
  integer err,noErr;
  string 255 host,tstr,nonce,opaque;
  LongInt port,pos;
  Area req,reply;
  string 255 ha1,ha2;
  
  noErr = 0;
  pos = 0;
  GetNextSubstring(LSPDr.Port,pos,":",host);
  GetNextSubstring(LSPDr.Port,pos,":",tstr);
  port = StringToLongInt(tstr);  
  
//  AddTextToArea("Authorization: Digest username=""" & "1" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        password=""" & "1" & """," & chr(13) & chr(10),req);
//  AddTextToArea(chr(13) & chr(10),req);

//  nonce = "f17ac3434ce8464fbf17d4bc818e0318";
//  opaque = "a5b5c2eff60f48629cf8219acb65472e";
  ha1 = LowerCase(md5string("1" & ":" & "" & ":" & "1"));
  ha2 = LowerCase(md5string("" & ":" & "/xccsp"));

  AddTextToArea("Authorization: Digest username=""" & "Kassa" & """," & chr(13) & chr(10),req);
//  AddTextToArea("Authorization: Basic " & base64encode("1" & ":" & "1") & chr(13) & chr(10),req);
  AddTextToArea("        realm=""" & "CleanCash Server" & """," & chr(13) & chr(10),req);
  AddTextToArea("        nonce=""" & nonce & """," & chr(13) & chr(10),req);
//  AddTextToArea("        stale=""" & "false" & """," & chr(13) & chr(10),req);
  AddTextToArea("        uri=""" & "/xccsp" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        cnonce=""" & "" & """," & chr(13) & chr(10),req);
  AddTextToArea("        nc=""" & "00000001" & """," & chr(13) & chr(10),req);
//  AddTextToArea("        opaque=""" & opaque & """," & chr(13) & chr(10),req);
  AddTextToArea("        algorithm=MD5," & chr(13) & chr(10),req);
  AddTextToArea("        qop=auth," & chr(13) & chr(10),req);
  AddTextToArea("        response=""" & LowerCase(md5string(ha1 & ":" & nonce & ":" & ha2)) & """" & chr(13) & chr(10),req);
  AddTextToArea(chr(13) & chr(10),req);

/*
//  AddTextToArea("Authorization: Basic " & base64encode("1" & ":" & "1") & chr(13) & chr(10),req);
//  AddTextToArea(chr(13) & chr(10),req);

  AddTextToArea("<?xml version=""1.0"" encoding=""ISO-8859-1""?>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<request xmlns=""http://www.retailinnovation.se/xccsp"">",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<type>RequestStatus</type>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<data>",req);
  AddTextToArea(chr(13) & chr(10),req);
*/

/*  
  AddTextToArea("<IdentityRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<PosId>POS1</PosId>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<OrgNo>55667756791</OrgNo>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</IdentityRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
*/  
  
/*  
  AddTextToArea("<StatusRequest>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<PosId>kassa2</PosId>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("<OrgNo>1234567891</OrgNo>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</StatusRequest>",req);  

  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</data>",req);
  AddTextToArea(chr(13) & chr(10),req);
  AddTextToArea("</request>",req);
*/

  LogAreaToFile("_RestAcc_CommunicateWithCleanCash_TypeC.request.txt",req);
//  if (SendWebRequest(host,port,-1,false,"POST","/xccsp","text/xml","",false,req,reply,10)) then begin
  if (SendRawWebRequest(host,port,false,"POST","/xccsp","text/xml","",false,req,reply,10)) then begin
  end;
  LogAreaToFile("_RestAcc_CommunicateWithCleanCash_TypeC.reply.txt",reply);
  
/*  
  err = OpenCleanCash(LSPDr);
  if (err!=noErr) then begin
    errorstr = USetStr(err);
    goto LRestAcc_CommunicateWithCleanCash_TypeC;
  end;
  err = TestCleanCashIdentity(false,LSPDr,LMb.TerminalID,errorstr);
  if (err!=noErr) then begin
    errorstr = err & ": " & errorstr;
    goto LRestAcc_CommunicateWithCleanCash_TypeC;
  end;
  err = StartReceiptCleanCash(errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash_TypeC;
  end;
  RecordCopy(oldRestAccr,RestAccr);
  if (RestAccr.FiscalDeviceSeqNr<=0) then begin
    RestAccr.FiscalDeviceSeqNr = NextFiscalDeviceSeqNrCleanCash(LMb,RestAccr.FiscalDeviceSeqNr);
  end;
  err = ReceiptHeaderCleanCash_RestAccVc(RestAccr,VATr,positivetotal,pVATr,negativetotal,nVATr,errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash_TypeC;
  end;
  err = SignatureReuqestCleanCash_RestAccVc(RestAccr,errorstr);
  if (err!=noErr) then begin
    goto LRestAcc_CommunicateWithCleanCash_TypeC;
  end;
  
LRestAcc_CommunicateWithCleanCash_TypeC:;
  CloseCleanCash;
*/  
  RestAcc_CommunicateWithCleanCash_TypeC = err;
  return;
end;

global
function Integer CalculateVATTotalsCleanCash_RestAccVc(record RestAccVc RestAccr,var record SMVc VATr,var val positivetotal,var record SMVc pVATr,var val negativetotal,var record SMVc nVATr)
begin
  Integer res;
  Integer i,rwcnt;
  row RestAccVc RestAccrw;
  Integer vatcnt;
  val tax1reb,vatprc;
  Array val avat;
  Array val avatbase;
  Array val avatrates;
  Integer ai,acnt;
  record GeneralOptionBlock GOb;
  val norebrowsum,v;
     
  BlockLoad(GOb);          
  positivetotal = blankval;
  negativetotal = blankval;
  SetupVATBase(VATr,vatcnt);
  SetupVATBase(nVATr,vatcnt);
  SetupVATBase(pVATr,vatcnt);
  rwcnt = MatRowCnt(RestAccr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccr,i,RestAccrw);
    if (RestAccrw.stp==kInvoiceRowTypeVoid) then begin
      goto LSkipInvoiceRow;
    end;
    if ((RestAccrw.stp==kInvoiceRowTypeNormal) or (RestAccrw.stp==kInvoiceRowTypeStructuredItemComponent) or (RestAccrw.stp==kInvoiceRowTypeInterest) or (RestAccrw.stp==kInvoiceRowTypeCorrection) or (RestAccrw.stp==kInvoiceRowTypeRetention)) then begin    
      if (RestAccrw.Sum>0) then begin
        positivetotal = positivetotal + RestAccrw.Sum;
        AddVATBase(pVATr,RestAccrw.VATCode,RestAccrw.Sum,tax1reb,vatcnt,RestAccr.InclVAT,0);
/*
        CalcSum(IVCashrw.Quant,IVCashrw.Price,IVCashrw.PriceFactor,0.00,norebrowsum,GOb.UseDiscount);
        if (norebrowsum!=IVCashrw.Sum) then begin
          v = norebrowsum - IVCashrw.Sum;
          negativetotal = negativetotal - v;
          AddVATBase(nVATr,IVCashrw.VATCode,v,tax1reb,vatcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
        end;
*/
      end else begin
        negativetotal = negativetotal + RestAccrw.Sum;
        AddVATBase(nVATr,RestAccrw.VATCode,RestAccrw.Sum,tax1reb,vatcnt,RestAccr.InclVAT,0);
      end;
      AddVATBase(VATr,RestAccrw.VATCode,RestAccrw.Sum,tax1reb,vatcnt,RestAccr.InclVAT,0);
      
      GetVATproc(RestAccrw.VATCode,0,vatprc);
      for (ai=1;ai<acnt;ai=ai+1) begin
        if (avatrates[ai]==vatprc) then begin
          goto LCalculateVATTotalsCleanCash;
        end;
      end;
      acnt = acnt + 1;
      avatrates[acnt] = vatprc;
LCalculateVATTotalsCleanCash:;
    end;
LSkipInvoiceRow:;    
  end;    
//  CalcVATBaseVAT(pVATr,RestAccr.InclVAT,0,vatcnt,s3,tax1sum); 
  if (acnt>4) then begin
    res = 12387;
    MessageBox(res,"");
  end;
  if ((nonblank(positivetotal) and positivetotal>0.00) and (nonblank(negativetotal) and negativetotal<0.00)) then begin
    res = 12389;
    MessageBox(res,"");
  end;
  CalculateVATTotalsCleanCash_RestAccVc = res;
  return;
end;

global
updating function Boolean StoreCleanCashRestAccReceipt(record LocalMachineBlock LMb,var record RestAccVc RestAccr,record LSerialPortDeviceVc LSPDr)
begin
  Boolean res;
  Integer err,noErr;
  record SMVc VATr;
  record SMVc pVATr;
  record SMVc nVATr;
  record RestAccVc oldRestAccr;
  val positivetotal,negativetotal;
  string 255 errorstr;

//8.4 CCSP v1 Mode A/C sequence chart

  noErr = 0;
    

  if ((nonblank(RestAccr.OfficialSerNr)) and (nonblank(RestAccr.OfficialSerNr2))) then begin
    MessageBox(12388,"");
    goto LStoreCleanCashRestAccReceipt;
  end;
  err = CalculateVATTotalsCleanCash_RestAccVc(RestAccr,VATr,positivetotal,pVATr,negativetotal,nVATr);
  if (err!=noErr) then begin
    goto LStoreCleanCashRestAccReceipt;
  end;
  
  err = RestAcc_CommunicateWithCleanCash(RestAccr,oldRestAccr,LMb,LSPDr,VATr,pVATr,nVATr,positivetotal,negativetotal,errorstr);
  if (err!=noErr) then begin
    MessageBox(errorstr,"");
    goto LStoreCleanCashRestAccReceipt;
  end;
  
  RestAccr.FiscalFlag = 1;
  if (RecordUpdate(oldRestAccr,RestAccr,false)==0) then begin
    res = true;
  end;
  PrintDocument(RestAccr,"InvCashForm",false);
  RecordCopy(oldRestAccr,RestAccr);
  RestAccr.Prntdf = 1;
  if (RecordUpdate(oldRestAccr,RestAccr,false)==0) then begin
  end;
LStoreCleanCashRestAccReceipt:;
  StoreCleanCashRestAccReceipt = res;
  return;
end;
