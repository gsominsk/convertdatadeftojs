external function val CalculateDiscountPercentage(val,val,val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external function string 255 NumToHex2(string,Integer);

enum begin
  RCHFLEA_DELAY = 10,
  RCHFLEA_LONGDELAY = 30
end;

enum begin
  RCHFLEA_STX = 2,
  RCHFLEA_ETX = 3,
  RCHFLEA_ACK = 6,
  RCHFLEA_NACK = 21,
  RCHFLEA_FNC_FISCAL_CODE = 34,      // ASCII code for '"'
  RCHFLEA_VALUE = 36,                // ASCII code for '$'
  RCHFLEA_FNC_PRCNT_MODIFIER = 37,   // ASCII code for '%'
  RCHFLEA_EXTRA_VALUE = 38,          // ASCII code for '&', up to three extra values are possible.
  RCHFLEA_DESC_BEGIN = 40,           // ASCII code for '('
  RCHFLEA_DESC_END = 41,             // ASCII code for ')'
  RCHFLEA_QUANTITY = 42,             // ASCII code for '*'
  RCHFLEA_SEPARATOR = 47,            // ASCII code for '/'
  RCHFLEA_CMD_DUMP_ENQ = 60,         // ASCII code for '<'
  RCHFLEA_CMD_ST_FISC = 61,          // ACSII code for '='
  RCHFLEA_CMD_LOAD_SET = 62,         // ASCII code for '>'
  RCHFLEA_FNC_KEY_CODE = 67,         // ASCII code for 'C'
  RCHFLEA_FNC_DISPLAY = 68,          // ASCII code for 'D'
  RCHFLEA_FNC_CLEAR = 75,            // ASCII code for 'K'
  RCHFLEA_PROT_ID = 78,              // ASCII code for 'N'
  RCHFLEA_FNC_OPERATOR = 79,         // ASCII code for 'O'
  RCHFLEA_FNC_PLU_SALE = 80,         // ASCII code for 'P'
  RCHFLEA_FNC_SALE_TO_DEP = 82,      // ASCII code for 'R'
  RCHFLEA_FNC_PRINT_SUBTOT = 83,     // ASCII code for 'S'
  RCHFLEA_FNC_PAYMENT = 84,          // ASCII code for 'T'
  RCHFLEA_FNC_VARIATION_IN_USD = 86, // ASCII code for 'V'
  RCHFLEA_FNC_SET = 94,              // ASCII code for '^'
  RCHFLEA_FNC_CANCEL = 97,           // ASCII code for 'a'
  RCHFLEA_FNC_ROLL_PAPER = 102,      // ASCII code for 'f'
  RCHFLEA_FNC_COMPL_CHRGE_OFF = 107, // ASCII code for 'k'
  RCHFLEA_FNC_RETURN_GOOD = 114,     // ASCII code for 'r'
  RCHFLEA_FNC_CHARGE_OFF = 115       // ASCII code for 's'
end;

enum begin
  RCHFLEA_ERROR = 69,                // ASCII code for 'E'
  RCHFLEA_OK = 79                    // ASCII code for 'O'
end;

enum begin
  RCHFLEA_ERRFMLY_GENERIC_ERR = 71,  // ASCII code for 'G'
  RCHFLEA_ERRFMLY_NO_ERR = 78,       // ASCII code for 'N'
  RCHFLEA_ERRFMLY_NO_PAPER = 80,     // ASCII code for 'P'
  RCHFLEA_ERRFMLY_BLOCKING = 83      // ASCII code for 'S'
end;

enum begin
  RCHFLEA_PAYMENT_CASH = 1,
  RCHFLEA_PAYMENT_CHEQUE = 2,
  RCHFLEA_PAYMENT_CREDIT_CARD = 3
end;

function integer CheckCurrency(string curncycode,var string errstr)
begin
  integer res;
  record BaseCurBlock BCb;
  
  res = 0;
  if (curncycode!="USD") then begin
    BlockLoad(BCb);
    if (BCb.BaseCur1!="USD" and BCb.BaseCur2!="USD") then begin
      errstr = USetStr(28351);
      res = 1;
    end;
  end;
  
  CheckCurrency = res;
  return;
end;

function integer FindStrPosition(string tstr,string decsep)
begin
  integer res;
  integer i,slen;
  
  slen = len(tstr);
  for (i=slen;i>=0;i=i-1) begin
    if (Mid(tstr,i,1)==decsep) then begin
      res = i;
      goto LFindStrPosition;
    end;
  end;
  
LFindStrPosition:;
  FindStrPosition = res;
  return;
end;

function integer HexToInt(string instr)
begin
  integer res;
  string 16 hexs;
  integer pos,slen,i,t;
  
  res = 0;
  slen = len(instr);
  hexs = "0123456789ABCDEF";
  for (i=slen;i>0;i=i-1) begin
    pos = FindStrPosition(hexs,Mid(instr,i-1,1));
    res = res + pos*Power(16,(slen-i));
  end;
  
  HexToInt = res;
  return;
end;

procedure StripDisallowedChars(var string str)
begin
  string 255 res;
  integer i,l,ascii;
  
  l = len(str);
  for (i=0;i<l;i=i+1) begin
    ascii = Asc(Mid(str,i,1));
    if (ascii>=32 and ascii<=127) then begin
      res = res & Mid(str,i,1);
    end;
  end;
  
  str = res;
  return;
end;

function string 5 CalcChecksum(string CtrlSeq)
begin
  string 5 res;
  integer checksum,i,l;
  
  l = len(CtrlSeq);
  checksum = Asc(Mid(CtrlSeq,0,1));
  for (i=1;i<l;i=i+1) begin
    checksum = BitXor(checksum,Asc(Mid(CtrlSeq,i,1)));
  end;
  res = NumToHex2(checksum,2);
  
  CalcChecksum = res;
  return;
end;

function integer RCHFleaOpen(record LSerialPortDeviceVc LSPDr,var string errstr)
begin
  integer res;
  
//  LogText(0,"RCHFleaOpen, LSPDr.Port = " & LSPDr.Port & ", LSPDr.BaudRate = " & LSPDr.BaudRate & ", LSPDr.Parity = " & LSPDr.Parity & ", LSPDr.ByteSize = " & LSPDr.ByteSize & ", LSPDr.StopBits = " & LSPDr.StopBits & ", LSPDr.FlowControl = " & LSPDr.FlowControl);
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    res = 0;
  end else begin
    res = 1;
  end;
  
  RCHFleaOpen = res;
  return;
end;

procedure RCHFleaClose()
begin
  CloseComPort(0);
  return;
end;

function string 10 CtrlSeqStart(integer datalen)
begin
  string 10 res,datalength;
  
  datalength = datalen;
  while (len(datalength)<3) begin
    datalength = "0" & datalength;
  end;
  res = Chr(RCHFLEA_STX) & "00" & datalength & Chr(RCHFLEA_PROT_ID);
  
  CtrlSeqStart = res;
  return;
end;

function integer WaitForRCHFleaReply(var string errstr,longint waittickscoef,integer packid)
begin
  integer res,noErr;
  string 255 replystr;
  longint waitticks,curtick,starttick;
  boolean waitf;
  
  noErr = 0;
  res = noErr;
  replystr = "";
  errstr = "";
  waitticks = waittickscoef*1000;
  starttick = GetCurTick;
  waitf = true;
  
  while (waitf) begin
    replystr = replystr & ReadComPort(0,255-len(replystr));
    if (nonblank(replystr)) then begin
      if (Asc(Left(replystr,1))==RCHFLEA_NACK) then begin
        waitf = false;
        res = 1;
      end;
      if (Asc(Right(replystr,1))==RCHFLEA_ETX) then begin
        waitf = false;
      end;
    end;
    curtick = GetCurTick;
    if (curtick-starttick>waitticks) then begin
      errstr = USetStr(28352);
      waitf = false;
      res = 2;
    end;
  end;
  if (res!=noErr) then begin goto LWaitForRCHFleaReply; end;
  if (Asc(Left(replystr,1))!=RCHFLEA_ACK) then begin
    LogText(0,"WaitForRCHFleaReply !ACK");
    res = 1;
    goto LWaitForRCHFleaReply;
  end;
  if (Asc(Mid(replystr,8,1))!=RCHFLEA_OK) then begin
    LogText(0,"WaitForRCHFleaReply !RCHFLEA_OK");
    res = 1;
    switch (Asc(Mid(replystr,9,1))) begin
      case RCHFLEA_ERRFMLY_GENERIC_ERR:
      case RCHFLEA_ERRFMLY_NO_PAPER:
        errstr = USetStr(28353);
      case RCHFLEA_ERRFMLY_BLOCKING:
    end;
    goto LWaitForRCHFleaReply;
  end;
LWaitForRCHFleaReply:;
  if (res==2) then begin
    OutComPort(0,Chr(RCHFLEA_NACK));
  end else begin
    OutComPort(0,Chr(RCHFLEA_ACK));
  end;
  
  LogText(0,"WaitForRCHFleaReply = " & res & ", time = " & curtick-starttick & ", replystr = " & replystr);
  
  WaitForRCHFleaReply = res;
  return;
end;

function integer WriteToRCHFlea(string data,var string errstr,longint delay,var integer packid)
begin
  integer res;
  string 255 CtrlSeq;
  
  CtrlSeq = CtrlSeqStart(len(data)) & data & Chr(packid);
  CtrlSeq = CtrlSeq & CalcChecksum(CtrlSeq) & Chr(RCHFLEA_ETX);
  
  LogText(0,"WriteToRCHFlea, CtrlSeq = " & CtrlSeq);
  
  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForRCHFleaReply(errstr,delay,packid);
    packid = packid + 1;
    if (packid>Asc("Z")) then begin packid = Asc("A"); end;
  end else begin
    res = 1;
  end;
  
  LogText(0,"WriteToRCHFlea = " & res);
  
  WriteToRCHFlea = res;
  return;
end;

/*
function integer RCHFleaDisplayMessage(string message,var string errstr,var integer packid)
begin
  integer res;
  string 255 data;
  
  StripDisallowedChars(message);
  data = Chr(RCHFLEA_CMD_ST_FISC) & Chr(RCHFLEA_FNC_DISPLAY) & Chr(RCHFLEA_SEPARATOR) &
         Chr(RCHFLEA_DESC_BEGIN) & message & Chr(RCHFLEA_DESC_END);
  res = WriteToRCHFlea(data,errstr,RCHFLEA_DELAY,packid);
  
  RCHFleaDisplayMessage = res;
  return;
end;
*/

function integer RCHFleaPrintItemRow(val price,val qty,string desc,val rebate,integer department,var string errstr,var integer packid)
begin
  integer res,noErr;
  string 255 data;
  
  noErr = 0;
  if (department<1 or department>5) then begin
    res = 1;
    goto LRCHFleaPrintItemRow;
  end;
  StripDisallowedChars(desc);
  data = Chr(RCHFLEA_CMD_ST_FISC) & Chr(RCHFLEA_FNC_SALE_TO_DEP) & department & Chr(RCHFLEA_SEPARATOR) &
         Chr(RCHFLEA_VALUE) & ValToString(price,M423Val,"","",1) & Chr(RCHFLEA_SEPARATOR) &
         Chr(RCHFLEA_QUANTITY) & ValToString(qty,M4UVal,"","",1) & Chr(RCHFLEA_SEPARATOR) &
         Chr(RCHFLEA_DESC_BEGIN) & desc & Chr(RCHFLEA_DESC_END);
  res = WriteToRCHFlea(data,errstr,RCHFLEA_DELAY,packid);
  if (res!=noErr) then begin
    goto LRCHFleaPrintItemRow;
  end;
  if (nonblank(rebate)) then begin
    data = Chr(RCHFLEA_CMD_ST_FISC) & Chr(RCHFLEA_FNC_PRCNT_MODIFIER);
    if (rebate<0) then begin
      data = data & "+";
    end;
    data = data & Chr(RCHFLEA_SEPARATOR) & Chr(RCHFLEA_QUANTITY);
    if (rebate<0) then begin
      data = data & ValToString(rebate*-1,M41Val,"",".",0);
    end else begin
      data = data & ValToString(rebate,M41Val,"",".",0);
    end;
    res = WriteToRCHFlea(data,errstr,RCHFLEA_DELAY,packid);
    if (res!=noErr) then begin
      goto LRCHFleaPrintItemRow;
    end;
  end;
  
LRCHFleaPrintItemRow:;
  RCHFleaPrintItemRow = res;
  return;
end;

function integer RCHFleaPayment(val sum,integer paymentmode,var string errstr,var integer packid)
begin
  integer res;
  string 255 data;
  
  if (paymentmode>=1 and paymentmode<=3) then begin
    data = Chr(RCHFLEA_CMD_ST_FISC) & Chr(RCHFLEA_FNC_PAYMENT) & paymentmode & Chr(RCHFLEA_SEPARATOR) &
           Chr(RCHFLEA_VALUE) & ValToString(sum,M4Val,"","",1);
    res = WriteToRCHFlea(data,errstr,RCHFLEA_DELAY,packid);
  end else begin
    res = 1;
  end;
  
  RCHFleaPayment = res;
  return;
end;

function integer RCHFleaVoid(var string errstr,var integer packid)
begin
  integer res;
  string 255 data;
  
  data = Chr(RCHFLEA_CMD_ST_FISC) & Chr(RCHFLEA_FNC_COMPL_CHRGE_OFF);
  res = WriteToRCHFlea(data,errstr,RCHFLEA_DELAY,packid);
  
  RCHFleaVoid = res;
  return;
end;

global
function integer DepartmentFromVATCode(string VATCode)
begin
  Integer res,i,rwcnt;
  record ZimFPVATCodeBlock ZFPVCb;
  row ZimFPVATCodeBlock ZFPVCrw;

  BlockLoad(ZFPVCb);
  rwcnt = MatRowCnt(ZFPVCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ZFPVCb,i,ZFPVCrw);
    if (ZFPVCrw.VATCode==VATCode) then begin
      res = ZFPVCrw.Department;
    end;
  end;
  if (res==0) then begin
    Trace(USetStr(28355) & ": " & VATCode,"");
  end;
LDepartmentFromVATCode:;
  DepartmentFromVATCode = res;
  return;
end;


function integer IVVc_RCHFleaPrintItemRows(record IVVc IVr,var string errstr,var integer packid)
begin
  integer res,noErr,dept;
  row IVVc IVrw;
  string 255 desc,vatcode;
  integer i,rwcnt;
  val price,vatv,t1;
  record BaseCurBlock BCb;
  
  noErr = 0;
  BlockLoad(BCb);
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
        price = IVrw.Price;
        if (IVr.InclVAT==0) then begin
          MulVATIV(IVrw.VATCode,price,vatv,t1,IVr.InclVAT,IVr.NoTAXonVAT);
          price = price + vatv + t1;
        end;
        if (IVrw.CurncyCode!="USD") then begin
          if (BCb.BaseCur1=="USD") then begin
            price = MulRateToBase1(IVrw.CurncyCode,price,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
          end else begin
            if (BCb.BaseCur2=="USD") then begin
              price = MulRateToBase2(IVr.CurncyCode,price,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
            end else begin
              errstr = USetStr(28351);
              res = 1;
              goto LIVVc_RCHFleaPrintItemRows;
            end;
          end;
        end;
        vatcode = IVrw.VATCode;
        if (blank(vatcode)) then begin
          GetItemVATCode(IVrw.ArtCode,IVr.ExportFlag,vatcode,true);
        end;
        if (blank(vatcode)) then begin
          Trace(USetStr(28354) & ": " & IVrw.ArtCode,"");
        end else begin
          dept = DepartmentFromVATCode(vatcode);
        end;
        res = RCHFleaPrintItemRow(price,IVrw.Quant,IVrw.Spec,IVrw.vRebate,dept,errstr,packid);
        if (res!=noErr) then begin
          goto LIVVc_RCHFleaPrintItemRows;
        end;
    end;
  end;
  
LIVVc_RCHFleaPrintItemRows:;
  IVVc_RCHFleaPrintItemRows = res;
  return;
end;

function integer IVVc_CalculatePaymentModeSums(record IVVc IVr,var vector val vpaymodesums,var string errstr)
begin
  integer res;
  row IVVc IVrw;
  Integer i,rwcnt;
  val sum,v;
  record BaseCurBlock BCb;
  
  res = 0;
  BlockLoad(BCb);
  vpaymodesums[RCHFLEA_PAYMENT_CASH] = 0.00;
  vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] = 0.00;
  vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] = 0.00;
  sum = IVr.Sum4;
  if (IVr.CurncyCode!="USD") then begin
    if (BCb.BaseCur1=="USD") then begin
      sum = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    end else begin
      if (BCb.BaseCur2=="USD") then begin
        sum = MulRateToBase2(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
      end else begin
        errstr = USetStr(28351);
        res = 1;
        goto LIVVc_CalculatePaymentModeSums;
      end;
    end;
  end;
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    v = 0.00;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeCreditCardPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeCashPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeChequePayment:
        v = IVrw.Sum;
      otherwise
        goto LIVVc_SkipRow;
    end;
    if (IVrw.CurncyCode!="USD") then begin
      if (BCb.BaseCur1=="USD") then begin
        v = MulRateToBase1(IVrw.CurncyCode,v,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
      end else begin
        if (BCb.BaseCur2=="USD") then begin
          v = MulRateToBase2(IVrw.CurncyCode,v,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        end else begin
          errstr = USetStr(28351);
          res = 1;
          goto LIVVc_CalculatePaymentModeSums;
        end;
      end;
    end;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] = vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] + v;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeChequePayment:
        vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] = vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] + v;
      otherwise
        goto LIVVc_SkipRow;
    end;
LIVVc_SkipRow:;
  end;
  v = sum - vpaymodesums[RCHFLEA_PAYMENT_CASH] - vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] - vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD];
  if (v>0) then begin
    vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
  end;
  
LIVVc_CalculatePaymentModeSums:;
  IVVc_CalculatePaymentModeSums = res;
  return;
end;

function integer IVVc_RCHFleaPayment(record IVVc IVr,var string errstr,var integer packid)
begin
  integer res,noErr;
  string 255 data;
  vector val vpaymodesums;
  
  noErr = 0;
  res = IVVc_CalculatePaymentModeSums(IVr,vpaymodesums,errstr);
  if (res!=noErr) then begin
    goto LIVVc_RCHFleaPayment;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CASH]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CASH],RCHFLEA_PAYMENT_CASH,errstr,packid);
    if (res!=noErr) then begin
      goto LIVVc_RCHFleaPayment;
    end;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CHEQUE]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CHEQUE],RCHFLEA_PAYMENT_CHEQUE,errstr,packid);
    if (res!=noErr) then begin
      goto LIVVc_RCHFleaPayment;
    end;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD],RCHFLEA_PAYMENT_CREDIT_CARD,errstr,packid);
    if (res!=noErr) then begin
      goto LIVVc_RCHFleaPayment;
    end;
  end;
  
LIVVc_RCHFleaPayment:;
  IVVc_RCHFleaPayment = res;
  return;
end;

global
procedure IVVc_PrintRCHFleaReceipt(var record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  integer res,noErr,packid;
  string 255 errstr;
  
  noErr = 0;
  packid = Asc("A");
  
  res = CheckCurrency(IVr.CurncyCode,errstr);
  if (res!=noErr) then begin
    goto LIVVc_PrintRCHFleaReceipt;
  end;
  
  res = RCHFleaOpen(LSPDr,errstr);
  if (res!=noErr) then begin
    goto LIVVc_PrintRCHFleaReceipt;
  end;
  
  res = IVVc_RCHFleaPrintItemRows(IVr,errstr,packid);
  if (res!=noErr) then begin
    goto LIVVc_PrintRCHFleaReceipt;
  end;
  
  res = IVVc_RCHFleaPayment(IVr,errstr,packid);
  if (res!=noErr) then begin
    goto LIVVc_PrintRCHFleaReceipt;
  end;
  
LIVVc_PrintRCHFleaReceipt:;
  if (res!=noErr) then begin
    if (nonblank(errstr)) then begin
      Trace(USetStr(28350) & ": ",errstr);
    end;
    RCHFleaVoid(errstr,packid);
  end;
  RCHFleaClose;
  
  return;
end;

function integer IVCashVc_RCHFleaPrintItemRows(record IVCashVc IVCashr,var string errstr,var integer packid)
begin
  integer res,noErr,dept;
  row IVCashVc IVCashrw;
  string 255 desc,vatcode;
  integer i,rwcnt;
  val price,vatv,t1,vreb;
  record BaseCurBlock BCb;
  
  noErr = 0;
  BlockLoad(BCb);
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LIVCashVc_kInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LIVCashVc_kInvoiceRowTypeNormal:;
        price = IVCashrw.Price;
        if (IVCashr.InclVAT==0) then begin
          MulVATIV(IVCashrw.VATCode,price,vatv,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
          price = price + vatv + t1;
        end;
        if (IVCashrw.CurncyCode!="USD") then begin
          if (BCb.BaseCur1=="USD") then begin
            price = MulRateToBase1(IVCashrw.CurncyCode,price,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
          end else begin
            if (BCb.BaseCur2=="USD") then begin
              price = MulRateToBase2(IVCashrw.CurncyCode,price,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
            end else begin
              errstr = USetStr(28351);
              res = 1;
              goto LIVCashVc_RCHFleaPrintItemRows;
            end;
          end;
        end;
        vatcode = IVCashrw.VATCode;
        if (blank(vatcode)) then begin
          GetItemVATCode(IVCashrw.ArtCode,0,vatcode,true);
        end;
        if (blank(vatcode)) then begin
          Trace(USetStr(28354) & ": " & IVCashrw.ArtCode,"");
        end else begin
          dept = DepartmentFromVATCode(vatcode);
        end;
        vreb = CalculateDiscountPercentage(IVCashrw.Quant,IVCashrw.Price,IVCashrw.Sum);
        res = RCHFleaPrintItemRow(price,IVCashrw.Quant,IVCashrw.Spec,vreb,dept,errstr,packid);
        if (res!=noErr) then begin
          goto LIVCashVc_RCHFleaPrintItemRows;
        end;
    end;
  end;
  
LIVCashVc_RCHFleaPrintItemRows:;
  IVCashVc_RCHFleaPrintItemRows = res;
  return;
end;

function integer IVCashVc_CalculatePaymentModeSums(record IVCashVc IVCashr,var vector val vpaymodesums,var string errstr)
begin
  integer res;
  row IVCashVc IVCashrw;
  integer i,rwcnt;
  record BaseCurBlock BCb;
  val sum,v;
  
  res = 0;
  BlockLoad(BCb);
  vpaymodesums[RCHFLEA_PAYMENT_CASH] = 0.00;
  vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] = 0.00;
  vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] = 0.00;
  sum = IVCashr.Sum4;
  if (IVCashr.CurncyCode!="USD") then begin
    if (BCb.BaseCur1=="USD") then begin
      sum = MulRateToBase1(IVCashr.CurncyCode,sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
    end else begin
      if (BCb.BaseCur2=="USD") then begin
        sum = MulRateToBase2(IVCashr.CurncyCode,sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
      end else begin
        errstr = USetStr(28351);
        res = 1;
        goto LIVCashVc_CalculatePaymentModeSums;
      end;
    end;
  end;
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    v = 0.00;
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeCreditCardPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeCashPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeChequePayment:
        v = IVCashrw.Sum;
      otherwise
        goto LIVCashVc_SkipRow;
    end;
    if (IVCashrw.CurncyCode!="USD") then begin
      if (BCb.BaseCur1=="USD") then begin
        v = MulRateToBase1(IVCashrw.CurncyCode,v,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
      end else begin
        if (BCb.BaseCur2=="USD") then begin
          v = MulRateToBase2(IVCashrw.CurncyCode,v,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        end else begin
          errstr = USetStr(28351);
          res = 1;
          goto LIVCashVc_CalculatePaymentModeSums;
        end;
      end;
    end;
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] = vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD] + v;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
      case kInvoiceRowTypeChequePayment:
        vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] = vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] + v;
      otherwise
        goto LIVCashVc_SkipRow;
    end;
LIVCashVc_SkipRow:;
  end;
  v = sum - vpaymodesums[RCHFLEA_PAYMENT_CASH] - vpaymodesums[RCHFLEA_PAYMENT_CHEQUE] - vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD];
  if (v>0) then begin
    vpaymodesums[RCHFLEA_PAYMENT_CASH] = vpaymodesums[RCHFLEA_PAYMENT_CASH] + v;
  end;

LIVCashVc_CalculatePaymentModeSums:;
  IVCashVc_CalculatePaymentModeSums = res;
  return;
end;

function integer IVCashVc_RCHFleaPayment(record IVCashVc IVCashr,var string errstr,var integer packid)
begin
  integer res,noErr;
  vector val vpaymodesums;
  
  noErr = 0;
  res = IVCashVc_CalculatePaymentModeSums(IVCashr,vpaymodesums,errstr);
  if (res!=noErr) then begin
    goto LIVCashVc_RCHFleaPayment;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CASH]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CASH],RCHFLEA_PAYMENT_CASH,errstr,packid);
    if (res!=noErr) then begin
      goto LIVCashVc_RCHFleaPayment;
    end;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CHEQUE]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CHEQUE],RCHFLEA_PAYMENT_CHEQUE,errstr,packid);
    if (res!=noErr) then begin
      goto LIVCashVc_RCHFleaPayment;
    end;
  end;
  if (vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD]!=0.00) then begin
    res = RCHFleaPayment(vpaymodesums[RCHFLEA_PAYMENT_CREDIT_CARD],RCHFLEA_PAYMENT_CREDIT_CARD,errstr,packid);
    if (res!=noErr) then begin
      goto LIVCashVc_RCHFleaPayment;
    end;
  end;
  
LIVCashVc_RCHFleaPayment:;
  IVCashVc_RCHFleaPayment = res;
  return;
end;

global
procedure IVCashVc_PrintRCHFleaReceipt(var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  integer res,noErr,packid;
  string 255 errstr;
  
  noErr = 0;
  packid = Asc("A");
  
  res = CheckCurrency(IVCashr.CurncyCode,errstr);
  if (res!=noErr) then begin
    goto LIVCashVc_PrintRCHFleaReceipt;
  end;
  
  res = RCHFleaOpen(LSPDr,errstr);
  if (res!=noErr) then begin
    goto LIVCashVc_PrintRCHFleaReceipt;
  end;
  
  res = IVCashVc_RCHFleaPrintItemRows(IVCashr,errstr,packid);
  if (res!=noErr) then begin
    goto LIVCashVc_PrintRCHFleaReceipt;
  end;
  
  res = IVCashVc_RCHFleaPayment(IVCashr,errstr,packid);
  if (res!=noErr) then begin
    goto LIVCashVc_PrintRCHFleaReceipt;
  end;
  
LIVCashVc_PrintRCHFleaReceipt:;
  if (res!=noErr) then begin
    if (nonblank(errstr)) then begin
      Trace(USetStr(28350) & ": ",errstr);
    end;
    RCHFleaVoid(errstr,packid);
  end;
  RCHFleaClose;
  
  return;
end;
