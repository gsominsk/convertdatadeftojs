external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);

global
procedure IVCalculatePaymentModeSums(record IVVc IVr,vector val vpaymodesums)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
//  vpaymodesums[100] = IVr.Sum4;//on account
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeCreditSpecialSales: 
      goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
LkInvoiceTypeCredit:;
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
    otherwise
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
  end;
//  vpaymodesums[100] = vpaymodesums[100] - vpaymodesums[kInvoiceRowTypeCreditCardPayment] - vpaymodesums[kInvoiceRowTypeCashPayment];
  return;
end;

global
procedure RestAccCalculatePaymentModeSums(record RestAccVc RestAccr,vector val vpaymodesums)
begin
  row RestAccVc RestAccrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0;
  vpaymodesums[kInvoiceRowTypeCashPayment] = RestAccr.CashValue;
  rwcnt = MatRowCnt(RestAccr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccr,i,RestAccrw);
    switch (RestAccrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  t = RestAccr.Sum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (t>0) then begin
    vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
  end;
  return;
end;

global
procedure IVCashCalculatePaymentModeSums(record IVCashVc IVCashr,vector val vpaymodesums)
begin
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = IVCashr.RecValue + IVCashr.RecValue2;
  vpaymodesums[kInvoiceRowTypeCashPayment] = IVCashr.CashValue;
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  t = IVCashr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (t>0) then begin
    vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
  end;
  return;
end;
