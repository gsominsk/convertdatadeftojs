forward function Integer DATECS2000_DELAYWrite(string,LongInt,var Integer);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure ExtractObj(string,var Integer,var string);
external procedure GetVATdouble(string,var val,var val,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val ValFromString(string,string,string);
external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external function string 255 NumToHex(string);

//FS, Field Separator = 0x1C

enum begin
  DATECS2000_DELAY = 10,
  DATECS2000_LONGDELAY = 30
end;

enum begin
  DATECS2000_STX = 1,
  DATECS2000_ETX = 3,
  DATECS2000_FS = 4,
  DATECS2000_POSTAMBLE = 5
end;

function Integer FindStrPosition(string tstr,string decsep)
begin
  Integer res;
  Integer i,slen;
  
  slen = len(tstr);
  for (i=slen;i>=0;i=i-1) begin
    if (Mid(tstr,i,1)==decsep) then begin
       res = i;
       goto LFindStrPosition;
    end;
  end;
LFindStrPosition:;  
  FindStrPosition = res;
  return;  
end;

function Integer HexToInt(string instr)
begin
  Integer res;
  string 16 hexs;
  Integer pos,slen,i,t;

  res = 0;
  slen = len(instr);
  hexs = "0123456789ABCDEF";
  for (i=slen;i>0;i=i-1) begin
    pos = FindStrPosition(hexs,Mid(instr,i-1,1));
    res = res + pos*Power(16,(slen-i));
  end; 
  HexToInt = res; 
  return;  
end;

function string 255 CalculateLRC(string CtrlSeq)
begin
  string 255 res,c,tstr;
  Integer i,resi,a;
  
  resi = 0;
  for (i=0;i<len(CtrlSeq);i=i+1) begin
    resi = resi + asc(Mid(CtrlSeq,i,1));
  end;
  tstr = NumToHex(resi);
  for (i=0;i<len(tstr);i=i+1) begin
    c = Mid(tstr,i,1);
    a = HexToInt(c) + 48;    
    res = res & chr(a);
  end;
  CalculateLRC = res;
  return;
end;

procedure CancelFiscalReceipt(var Integer sequence)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,cmd,seqhex;
  
  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x3C"));
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_LONGDELAY,sequence);
  return;
end;

function Integer ReadErrorFromStatus(string status)
begin
  Integer res,noErr;
  Integer i,err,bytetest;
  
  noErr = 0;
  res = noErr;

  bytetest = GetByteFromString(status,0);
  if (TestBit(bytetest,6)!=0) then begin res = 19380; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,5)!=0) then begin res = 19381; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,4)!=0) then begin res = 19382; goto LReadErrorFromStatus; end;
//  if (TestBit(bytetest,3)!=0) then begin res = 19383; goto LReadErrorFromStatus; end;//Display is Disconnected
  if (TestBit(bytetest,2)!=0) then begin res = 12402; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,1)!=0) then begin res = 19384; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,0)!=0) then begin res = 19385; goto LReadErrorFromStatus; end;

  bytetest = GetByteFromString(status,1);
  if (TestBit(bytetest,4)!=0) then begin res = 19386; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,3)!=0) then begin res = 19387; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,2)!=0) then begin res = 19388; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,1)!=0) then begin res = 19389; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,0)!=0) then begin res = 19340; goto LReadErrorFromStatus; end;

  bytetest = GetByteFromString(status,2);
  if (TestBit(bytetest,6)!=0) then begin res = 19381; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,5)!=0) then begin res = 19347; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,4)!=0) then begin res = 19344; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,3)!=0) then begin res = 19347; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,2)!=0) then begin res = 19343; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,1)!=0) then begin res = 19341; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,0)!=0) then begin res = 19342; goto LReadErrorFromStatus; end;

//  bytetest = GetByteFromString(status,3); siwtches

  bytetest = GetByteFromString(status,4);
  if (TestBit(bytetest,5)!=0) then begin res = 19381; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,4)!=0) then begin res = 19348; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,3)!=0) then begin res = 19345; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,2)!=0) then begin res = 19381; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,1)!=0) then begin res = 19346; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,0)!=0) then begin res = 19349; goto LReadErrorFromStatus; end;

  bytetest = GetByteFromString(status,5);
  if (TestBit(bytetest,5)!=0) then begin res = 19349; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,2)!=0) then begin res = 19347; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,1)!=0) then begin res = 19349; goto LReadErrorFromStatus; end;
  if (TestBit(bytetest,0)!=0) then begin res = 19349; goto LReadErrorFromStatus; end;

LReadErrorFromStatus:;  
  res = 0;//temporary
  ReadErrorFromStatus = res;
  return;
end;

procedure ParseReply(string response,var string fpresp,var string status)
begin
  Integer c,l,pos;
  Boolean statusf,testf;
  
  fpresp = "";
  status = "";
  l = BytesInString(response);  
  
  pos = 4;
  testf = true;
  while (testf) begin
    c = GetByteFromString(response,pos); 
    if (c==DATECS2000_FS) then begin
      testf = false;
    end;
    if (testf) then begin
      fpresp = fpresp & chr(c);
    end;
    pos = pos + 1;
  end;

  testf = true;
  while (testf) begin
    c = GetByteFromString(response,pos); 
    if (c==DATECS2000_POSTAMBLE) then begin
      testf = false;
    end;
    if (testf) then begin
      status = status & chr(c);
    end;
    pos = pos + 1;
  end;  
  return;
end;

function Integer WaitForDATECS2000_DELAYReply(LongInt waittickscoef,var string response,var Integer sequence)
begin
  Integer res;
  Integer noErr;
  LongInt waitticks;
  LongInt currenttick, starttick;
  Integer l,responselen;
  Boolean waitf;
  string 255 fpresp,errorcode,c,status;
  Integer pos;

  res = noErr;
  response = "";
  waitticks = waittickscoef*1000;
  starttick = GetCurTick;

  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    response = response & c;

    if (asc(c)==DATECS2000_ETX) then begin
      waitf = false;
    end;    
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
  if (blank(response)) then begin
    res = 1; //no reply
    goto LWaitForDATECS2000_DELAYReply;
  end;

  ParseReply(response,fpresp,status);
  response = fpresp;
  res = ReadErrorFromStatus(status);    
LWaitForDATECS2000_DELAYReply:;  
  if (res!=0) then begin
    LogText(0,"WaitForDATECS2000_DELAYReply fpresp " & fpresp & " res " & res);
    CancelFiscalReceipt(sequence);
  end;  
  WaitForDATECS2000_DELAYReply = res;
  return;
end;

function Integer DATECS2000_DELAYWrite(string CtrlSeq,LongInt delay,var Integer sequence) 
begin
  Integer res;
  string 255 response;
  
  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForDATECS2000_DELAYReply(delay,response,sequence);
  end else begin
    res = 1;
  end;
  DATECS2000_DELAYWrite = res;
  return;
end;

function Integer DATECS2000_DELAYWriteAndGetResponse(string CtrlSeq,LongInt delay,var string response,var Integer sequence) 
begin
  Integer res;

  response = "";
  res = OutComPort(0,CtrlSeq);
  if (res!=0) then begin
    res = WaitForDATECS2000_DELAYReply(delay,response,sequence);
  end else begin
    res = 1;
  end;
  DATECS2000_DELAYWriteAndGetResponse = res;
  return;
end;
  
global
function Integer DATECS2000_DELAYGetFiscalData(string command,var Integer sequence)
begin
  Integer res,msglen;
  string 255 CtrlSeq,msglenhex;  

//<COMMAND>=<0x4F><FS><Õ9Õ><FS>

  msglen = 6;
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x4F"));
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & command;
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));
  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_LONGDELAY,sequence);

  DATECS2000_DELAYGetFiscalData = res;
  return;
end;
 
function Integer DATECS2000_DELAYOpen(record LSerialPortDeviceVc LSPDr)
begin
  Integer res;
  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    res = 0;
  end else begin
    res = 1;
  end;
  DATECS2000_DELAYOpen = res;
  return;
end;

procedure DATECS2000_DELAYClose()
begin
  Integer res;

  res = CloseComPort(0);
  return;
end;

function Integer CheckDATECS2000_DELAYClock(var Integer sequence)
begin
  INteger res,msglen,noErr,pos;
  string 255 CtrlSeq,msglenhex,response,seqhex; 
  Date td; 
  Integer pY,pM,pD;
  
//<COMMAND>=<0x4F><FS><Õ5Õ><FS>

  td = CurrentDate;
  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x3E"));
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWriteAndGetResponse(CtrlSeq,DATECS2000_LONGDELAY,response,sequence);
  
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,USetStr(1742) & " " & USetStr(res));
    end;
    goto LCheckDATECS2000_DELAYClock;
  end;

  pD = StringToInt(Left(response,2));
  pM = StringToInt(Mid(response,3,2));
  pY = StringToInt(Mid(response,6,2))+2000;
    
  if ((td.year==pY) and (td.month==pM) and (td.day==pD)) then begin
     res = noErr;
  end else begin
     MessageBox(0,USetStr(12402));
     MessageBox(0,USetStr(12403) & pY & pM & pD);
     MessageBox(0,USetStr(12404) & GetYear(td) & GetMonth(td) & GetDay(td));
     res = 12402;
  end;
LCheckDATECS2000_DELAYClock:;
  CheckDATECS2000_DELAYClock = res;
  return;
end;

function Integer LoadDATECS2000_DELAYVATRates(var Integer sequence,vector val vatrates)
begin
  INteger res,msglen,noErr,i;
  string 255 CtrlSeq,msglenhex,response,seqhex,vr; 
  LongInt pos;

  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x61"));
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWriteAndGetResponse(CtrlSeq,DATECS2000_DELAY,response,sequence);

  if (res!=noErr) then begin
    res = 12405;
    goto LLoadDATECS2000_DELAYVATRates;
  end;
  
  pos = 0;
  i = 0;
  while (GetNextSubstring(response,pos,",",vr)) begin
    vatrates[i] = ValFromString(vr,".","");
    i = i + 1;
  end;  
LLoadDATECS2000_DELAYVATRates:;
  LoadDATECS2000_DELAYVATRates = res;
  return;
end;

function Integer BeginFiscalReceipt(string localmachinecode,var Integer sequence)
begin
  Integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,seqhex;
  string 255 operator,passwd,datastr;

  operator = 1;
  passwd = "000000";
  datastr = datastr & operator;
  datastr = datastr & ",";
  datastr = datastr & passwd;
  datastr = datastr & ",";
  if (nonblank(localmachinecode)) then begin
    datastr = datastr & localmachinecode;
  end else begin
    datastr = datastr & 12;
  end;
  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + len(datastr) + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x30"));
  CtrlSeq = CtrlSeq & datastr;  
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);
  BeginFiscalReceipt = res;
  return;
end;

procedure CalculatePaymentModeSums(record IVVc IVr,vector val vpaymodesums)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
      LkInvoiceTypeCredit:;
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
    otherwise
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
  end;
  return;
end;

function Integer PrintSubtotals(record IVVc IVr,var Integer sequence)
begin
  Integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,seqhex;
  string 255 datastr;
  
  datastr = "1";
  datastr = datastr & ",";
  datastr = datastr & "0";

  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + len(datastr) + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x33"));
  CtrlSeq = CtrlSeq & datastr;  
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);
  PrintSubtotals = res;
  return;
end;

function Integer EndFiscalReceipt(record IVVc IVr,var Integer sequence)
begin
  Integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,seqhex;
  string 255 datastr;
  vector val vpaymodesums;

  res = PrintSubtotals(IVr,sequence);
  if (res!=0) then begin
    goto LEndFiscalReceipt;
  end;
  
  CalculatePaymentModeSums(IVr,vpaymodesums);
  if (vpaymodesums[kInvoiceRowTypeCashPayment]!=0) then begin
    datastr = "P";
    datastr = datastr & ",";
    if (vpaymodesums[kInvoiceRowTypeCashPayment]>0) then begin
      datastr = datastr & "+";
    end else begin
      datastr = datastr & "-";
    end;
    datastr = datastr & ",";
    datastr = datastr & ValToString(vpaymodesums[kInvoiceRowTypeCashPayment],M4UVal,"",".",0);

    seqhex = NumToHex(sequence);
    seqhex = Right(seqhex,2);
    sequence = sequence + 1;

    msglen = 4 + len(datastr) + 32;//offset of 32
    msglenhex = NumToHex(msglen);
    msglenhex = Right(msglenhex,2);

    CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
    CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
    CtrlSeq = CtrlSeq & chr(HexToInt("0x35"));
    CtrlSeq = CtrlSeq & datastr;  
    CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
    CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
    CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
    res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);
    if (res!=0) then begin
      goto LEndFiscalReceipt;
    end;
  end;
  if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]!=0) then begin
    datastr = "N";
    datastr = datastr & ",";
    if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]>0) then begin
      datastr = datastr & "+";
    end else begin
      datastr = datastr & "-";
    end;
    datastr = datastr & ",";
    datastr = datastr & ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment],M4UVal,"",".",0);

    seqhex = NumToHex(sequence);
    seqhex = Right(seqhex,2);
    sequence = sequence + 1;

    msglen = 4 + len(datastr) + 32;//offset of 32
    msglenhex = NumToHex(msglen);
    msglenhex = Right(msglenhex,2);

    CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
    CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
    CtrlSeq = CtrlSeq & chr(HexToInt("0x35"));
    CtrlSeq = CtrlSeq & datastr;  
    CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
    CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
    CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
    res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);
    if (res!=0) then begin
      goto LEndFiscalReceipt;
    end;
  end;

LEndFiscalReceipt:;  
  EndFiscalReceipt = res;
  return;
end;

function string 255 GetDATECS2000_DELAYVATCode(Integer InclVAT,string vatcode,vector val vatrates)
begin
  string 255 res;
  val vatprc,tax1;

  GetVATdouble(vatcode,vatprc,tax1,0);
  if (vatprc==vatrates[0]) then begin 
    res = "0"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
  if (vatprc==vatrates[1]) then begin 
    res = "1"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
  if (vatprc==vatrates[2]) then begin 
    res = "2"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
  if (vatprc==vatrates[3]) then begin 
    res = "3"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
  if (vatprc==vatrates[4]) then begin 
    res = "4"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
  if (vatprc==vatrates[5]) then begin 
    res = "5"; 
    goto LGetDATECS2000_DELAYVATCode;
  end;
LGetDATECS2000_DELAYVATCode:;
  GetDATECS2000_DELAYVATCode = res;
  return;
end;

function Integer PrintRecItem(record IVVc IVr,row IVVc IVrw,vector val vatrates,string sign,var Integer sequence)
begin
  Integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,seqhex;
  string 255 datastr,rebstr;

  datastr = Left(IVrw.Spec,36);
  if (len(IVrw.Spec)>36) then begin
    datastr = datastr & chr(10);
    datastr = datastr & Mid(IVrw.Spec,36,36);
  end;
  datastr = datastr & chr(9);
  datastr = datastr & GetDATECS2000_DELAYVATCode(IVr.InclVAT,IVrw.VATCode,vatrates);
//  datastr = datastr & ",";
  datastr = datastr & sign;
//  datastr = datastr & ",";
  datastr = datastr & ValToString(IVrw.Price,M4UVal,"",".",0);
  datastr = datastr & "*";
  CtrlSeq = CtrlSeq & ValToString(IVrw.Quant,M4UVal,"",".",0);
  datastr = datastr & "#";
  if (blank(IVrw.UnitCode)) then begin
    datastr = datastr & "PCS";
  end else begin
    datastr = datastr & IVrw.UnitCode;
  end;
  rebstr = ValToString(IVrw.vRebate,M41Val,"",".",0);
  if (nonblank(rebstr)) then begin
    datastr = datastr & ",";
    datastr = datastr & rebstr;
  end;

  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + len(datastr) + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x31"));
  CtrlSeq = CtrlSeq & datastr;  
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);

  PrintRecItem = res;
  return;
end;

function Integer PrintCommentLine(record IVVc IVr,row IVVc IVrw,var Integer sequence)
begin
  Integer res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,seqhex;
  string 255 datastr;
  
  datastr = Left(IVrw.Spec,42);
  
  seqhex = NumToHex(sequence);
  seqhex = Right(seqhex,2);
  sequence = sequence + 1;

  msglen = 4 + len(datastr) + 32;//offset of 32
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);

  CtrlSeq = CtrlSeq & chr(HexToInt(msglenhex));
  CtrlSeq = CtrlSeq & chr(HexToInt(seqhex));
  CtrlSeq = CtrlSeq & chr(HexToInt("0x36"));
  CtrlSeq = CtrlSeq & datastr;  
  CtrlSeq = CtrlSeq & chr(DATECS2000_POSTAMBLE);  
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq); 
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY,sequence);
  PrintCommentLine = res;
  return;
end;

function Integer PrintItemRows(record IVVc IVr,vector val vatrates,var Integer sequence)
begin
  INteger res,noErr;
  row IVVc IVrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal1;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal1:;  
        if (nonblank(IVrw.ArtCode)) then begin
          res = PrintRecItem(IVr,IVrw,vatrates,"+",sequence);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end else begin
          res = PrintCommentLine(IVr,IVrw,sequence);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end;
      case kInvoiceRowTypeVoid:
        res = PrintRecItem(IVr,IVrw,vatrates,"-",sequence);
        if (res!=noErr) then begin
          goto LPrintItemRows;
        end;
    end;
  end;
LPrintItemRows:;  
  PrintItemRows = res;
  return;
end;

global
updating procedure PrintDatecs2000Receipt(var record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  record IVVc oldIVr;
  Integer noErr,res;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  vector val vatrates;
  Integer sequence;
  
  noErr = 0;
  res = DATECS2000_DELAYOpen(LSPDr);

  if (res==noErr) then begin
    noErr = 0;
    BlockLoad(LMb);
    
    sequence = 32;
    res = CheckDATECS2000_DELAYClock(sequence);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = LoadDATECS2000_DELAYVATRates(sequence,vatrates);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = BeginFiscalReceipt(LSPDr.LocalMachineCode,sequence);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = PrintItemRows(IVr,vatrates,sequence);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = EndFiscalReceipt(IVr,sequence);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
/*    
    if (IVr.Prntdf!=0) then begin
      RecordCopy(oldIVr,IVr);
      IVr.Prntdf = 1;
      RecordUpdate(oldIVr,IVr,false);
    end;    
*/    
LPrintDatecs2000Receipt:;
    DATECS2000_DELAYClose;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;
/*

procedure IVCash_CalculatePaymentModeSums(record IVCashVc IVCashr,vector val vpaymodesums)
begin
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  t = IVCashr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (t>0) then begin
    vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
  end;
  return;
end;

function Integer IVCash_EndFiscalReceiptCurr(record IVCashVc IVCashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  vector val vpaymodesums;

  IVCash_CalculatePaymentModeSums(IVCashr,vpaymodesums);

  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCashPayment],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
//credit card payments  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment],M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
//Cash payments in foreign currency  
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "2";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_LONGDELAY,sequence);

  DATECS2000_DELAYGetFiscalData("9",sequence);
  IVCash_EndFiscalReceiptCurr = res;
  return;
end;

function Integer IVCash_DiscountAdditionForItem(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "4";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "1";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(-IVCashrw.vRebate,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    
  
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  IVCash_DiscountAdditionForItem = res;
  return;
end;

function Integer IVCash_PrintRecItem(record IVCashVc IVCashr,row IVCashVc IVCashrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  string 255 unit;
  Area CtrlSeqArea;
  
  unit = IVCashrw.UnitCode;
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  CtrlSeq = CtrlSeq & "3";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & GetDATECS2000_DELAYVATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & unit;
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(DATECS2000_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  if (res==noErr) then begin
    if (IVCashrw.vRebate!=0) then begin
      res = IVCash_DiscountAdditionForItem(IVCashr,IVCashrw);
    end;
  end;
  IVCash_PrintRecItem = res;
  return;
end;

function Integer IVCash_PrintRecReturn(record IVCashVc IVCashr,row IVCashVc IVCashrw,vector val vatrates)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,unit;
  Area CtrlSeqArea;
  
  unit = IVCashrw.UnitCode;
  if (blank(unit)) then begin
    unit = "PCS";
  end;
  CtrlSeq = CtrlSeq & "6";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(-IVCashrw.Quant,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(IVCashrw.Price,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & GetDATECS2000_DELAYVATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & unit;
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(1.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(2.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(0.00,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(DATECS2000_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  IVCash_PrintRecReturn = res;
  return;
end;

function Integer IVCash_PrintCommentLine(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  Area CtrlSeqArea;
  
  CtrlSeq = CtrlSeq & "C";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & chr(HexToInt("0x45"));
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ConvertStringToCodePage("CP1257",IVCashrw.Spec);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  AddStringToArea(CtrlSeq,CtrlSeqArea);
  AddByteToArea(HexToInt(CalculateLRC(CtrlSeq)),CtrlSeqArea);


  CtrlSeq = chr(DATECS2000_STX);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,1,msglen-1);
  CtrlSeq = CtrlSeq & GetStringFromArea(CtrlSeqArea,msglen,1);
  CtrlSeq = CtrlSeq & chr(DATECS2000_ETX);

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  IVCash_PrintCommentLine = res;
  return;
end;

function Integer IVCash_PrintItemRows(record IVCashVc IVCashr,vector val vatrates)
begin
  INteger res,noErr;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal2;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal2:;  
        if (nonblank(IVCashrw.ArtCode)) then begin
          res = IVCash_PrintRecItem(IVCashr,IVCashrw,vatrates);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end else begin
          res = IVCash_PrintCommentLine(IVCashr,IVCashrw);
          if (res!=noErr) then begin
            goto LPrintItemRows;
          end;
        end;
      case kInvoiceRowTypeVoid:
        res = IVCash_PrintRecReturn(IVCashr,IVCashrw,vatrates);
        if (res!=noErr) then begin
          goto LPrintItemRows;
        end;
    end;
  end;
LPrintItemRows:;  
  IVCash_PrintItemRows = res;
  return;
end;

global
updating procedure PrintDATECS2000_DELAYIVCashReceipt(var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  record IVCashVc oldIVCashr;
  Integer noErr,res;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  vector val vatrates;
  
  noErr = 0;
  res = DATECS2000_DELAYOpen(LSPDr);
  if (res==noErr) then begin
    noErr = 0;
    BlockLoad(LMb);
    
//    MCr.Code = LMb.LocalMachineCode;
//    ReadFirstMain(MCr,1,true);

    res = CheckDATECS2000_DELAYClock;
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = LoadDATECS2000_DELAYVATRates(vatrates);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = BeginFiscalReceipt;
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = IVCash_PrintItemRows(IVCashr,vatrates);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    res = IVCash_EndFiscalReceiptCurr(IVCashr);
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    if (IVCashr.Prntdf!=0) then begin
      RecordCopy(oldIVCashr,IVCashr);
      IVCashr.Prntdf = 1;
      RecordUpdate(oldIVCashr,IVCashr,false);
    end;    
LPrintDatecs2000Receipt:;
    DATECS2000_DELAYClose;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

function Integer MoneyOutCurr(record CashVc Cashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "Y";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(Cashr.Total,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    
  
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  MoneyOutCurr = res;
  return;
end;

function Integer MoneyInCurr(record CashVc Cashr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex;
  
  CtrlSeq = CtrlSeq & "I";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & ValToString(Cashr.Total,M4UVal,"",".",0);
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    
  
  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY);  
  MoneyInCurr = res;
  return;
end;

global
procedure PrintDATECS2000_DELAYCashEvent(var record CashVc Cashr,record LSerialPortDeviceVc LSPDr)
begin
  Integer noErr,res;
  
  noErr = 0;
  res = DATECS2000_DELAYOpen(LSPDr);
  if (res==noErr) then begin    
    res = CheckDATECS2000_DELAYClock;
    if (res!=noErr) then begin
      goto LPrintDatecs2000Receipt;
    end;
    switch (Cashr.Event) begin
      case 0:
        MoneyOutCurr(Cashr);
      case 1:
        MoneyInCurr(Cashr);
    end;
LPrintDATECS2000_DELAYCashEvent:;
    DATECS2000_DELAYClose;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

global
procedure DATECS2000_DELAYDailyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = DATECS2000_DELAYOpen(LSPDr);
  if (res!=noErr) then begin
    goto LDATECS2000_DELAYDailyReport;
  end;
  
  CtrlSeq = CtrlSeq & "Z";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY); 
  DATECS2000_DELAYClose;
 LDATECS2000_DELAYDailyReport:;  
  return;
end;

global
procedure DATECS2000_DELAYMonthlyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = DATECS2000_DELAYOpen(LSPDr);
  if (res!=noErr) then begin
    goto LDATECS2000_DELAYMonthlyReport;
  end;
  
  CtrlSeq = CtrlSeq & "X";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY); 
  DATECS2000_DELAYClose;
 LDATECS2000_DELAYMonthlyReport:;  
  return;
end;

global
procedure DATECS2000_DELAYPeriodicReport(record RcVc RepSpec,record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = DATECS2000_DELAYOpen(LSPDr);
  if (res!=noErr) then begin
    goto LDATECS2000_DELAYPeriodicReport;
  end;
  
  CtrlSeq = CtrlSeq & "F";
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & DateToString(RepSpec.d1,"YYYYMMDD");
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);
  CtrlSeq = CtrlSeq & DateToString(RepSpec.d2,"YYYYMMDD");
  CtrlSeq = CtrlSeq & chr(DATECS2000_FS);

  msglen = len(CtrlSeq) + 2;  //msglen and lrc
  msglenhex = NumToHex(msglen);
  msglenhex = Right(msglenhex,2);
  CtrlSeq = chr(HexToInt(msglenhex)) & CtrlSeq;

  CtrlSeq = CtrlSeq & chr(HexToInt(CalculateLRC(CtrlSeq)));  
  CtrlSeq = chr(DATECS2000_STX) & CtrlSeq & chr(DATECS2000_ETX);    

  res = DATECS2000_DELAYWrite(CtrlSeq,DATECS2000_DELAY); 
  DATECS2000_DELAYClose;
 LDATECS2000_DELAYPeriodicReport:;  
  return;
end;
*/

/*
  begin
  Integer i;
  string 255 tstr;
  
  for (i=0;i<len(CtrlSeq);i=i+1) begin
    tstr = NumToHex(asc(Mid(CtrlSeq,i,1)));
    tstr = Right(tstr,2);
    LogText(0,"h.CheckDATECS2000_DELAYClock asc(Mid(CtrlSeq,i,1))= " & tstr);
  end;

  end;
*/
