external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure GetVATproc(string,Integer,var val);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function LongInt POSNETHexToLong(string);
external function string 255 NumToHex(string);

enum begin
  H_STX = 2,  // 0x02
  H_ETX = 3,  // 0x03
  H_ACK = 6,  // 0x06
  H_DC2 = 18, // 0x12
  H_DC4 = 20, // 0x14
  H_NAK = 21, // 0x15
  H_ESC = 27, // 0x1B
  H_FS = 28,  // 0x1C
  H_STATPRN = 161
end;

procedure Add_ASC(var Array Integer aArray,var Integer aCount,Integer AscCode)
begin
  aArray[aCount] = AscCode;
  aCount = aCount + 1;
  return;
end;

procedure Add_CHR(var Array Integer aArray,var Integer aCount,string s)
begin                                                                              
  Integer i,cnt;
  
  cnt = len(s);
  for (i=0;i<cnt;i=i+1) begin
    Add_ASC(aArray,aCount,asc(mid(s,i,1)));
  end;                                                  
  return;                                                                          
end; 

procedure Add_STR(var Array Integer aArray,var Integer aCount,string s)
begin                                                       
  if (NonBlank(s)) then begin
    Add_CHR(aArray,aCount,ConvertStringToCodePage("CP437",s));
  end;
  return;                                                                          
end; 

procedure Add_VAL(var Array Integer aArray,var Integer aCount,val v)
begin
  string 20 tstr;
  
  tstr = ValToString(v,M4Val,"",".",0);
  Add_CHR(aArray,aCount,tstr);
  return;
end;

function string 255 ArrayToStr(Array Integer aArray,Integer aCount)
begin
  string 255 res;
  Integer i;
  
  for (i=0;i<aCount;i=i+1) begin
    res = res & chr(aArray[i]);
  end;
  
  ArrayToStr = res;
  return;
end;

function string 255 AddMessage(string msg1,string msg2)
begin
  string 255 res;
  
  res = msg1;
  if (NonBlank(res)) then begin
    res = res & chr(10);
  end;
  res = res & msg2;
  
  AddMessage = res;
  return;
end;

procedure HASARDisplayErrorMsg(Integer err,string msg)
begin
  if (err!=0 or NonBlank(msg)) then begin
    MessageBox(err,msg);
  end;
  return;
end;

function Integer AddCmdSeq(var Integer cmdnr)
begin
  if (cmdnr<32 or cmdnr>=127) then begin
    cmdnr = 32;
  end else begin
    cmdnr = cmdnr + 1;
  end;
  AddCmdSeq = cmdnr;
  return;
end;

function Integer ReplyInHASARBuffer(var string replystr,Integer l)
begin
  Integer noErr;
  
  replystr = replystr & ReadComPort(0,l-len(replystr));
  ReplyInHASARBuffer = noErr;
  return;
end;

function Integer OutComPortInteger(Integer EscSeq)
begin
  Integer res;
  res = OutComPort(0,chr(EscSeq));
  OutComPortInteger = res;
  return;
end;

function Integer OutComPortArray(array Integer aEscSeq,Integer aCount)
BEGIN
  Integer res;
  Integer noErr,i;
  
  for (i=0;i<aCount;i=i+1) begin
    res = OutComPortInteger(aEscSeq[i]);
  end;
  if (res!=0) then begin
    res = noErr;
  end else begin
    res = 1;
  end;
  OutComPortArray = res;
  RETURN;
END;

procedure ClearComPort()
begin
  string 1 c;
  
  c = ReadComPort(0,1);
  while (c!="") begin
    c = ReadComPort(0,1);
  end;
  
  return;
end;

function Integer WaitHASARTime(var string replystr,Integer replylen)
begin
  Integer res;
  Integer noErr;
  LongInt timeout;
  LongInt tickcount, tick;

  res = 12400;
  replystr = "";
  timeout = 800;
  tick = GetCurTick;
  tickcount = tick;
  while ((tickcount-tick)<timeout) begin
    millisleep(100);
    tickcount = GetCurTick;
    res = ReplyInHASARBuffer(replystr,replylen);
    if (len(replystr)>=replylen) or ((replylen==255) and (len(replystr)>0)) then begin
      res = noErr;
      goto LWaitHASARTime;
    end;
  end;
LWaitHASARTime:;
  WaitHASARTime = res;
  return;
end;

function Integer TestPrinterStatus(string printerstatus)
begin
  Integer res;
  LongInt l;

  l = POSNETHexToLong(Left(printerstatus,4));

  if (BitAnd(l,1)) then begin res = 22100; goto LTestPrinterStatus; end;//printer busy
//  if (BitAnd(l,2)) then begin res = 0; end;//always zero
  if (BitAnd(l,4)) then begin res = 22101; goto LTestPrinterStatus; end;//printer error (serial comunication error)
  if (BitAnd(l,8)) then begin res = 22102; goto LTestPrinterStatus; end;//offline printer
  if (BitAnd(l,16)) then begin res = 22103; goto LTestPrinterStatus; end;//secondary paper error
  if (BitAnd(l,32)) then begin res = 22104; goto LTestPrinterStatus; end;//main paper error
//  if (BitAnd(l,64)) then begin res = 22105; goto LTestPrinterStatus; end;//incomming buffer almost full (printer send back the command to you if 1)
  if (BitAnd(l,64)) then begin res = 0; end;//incomming buffer almost full (printer send back the command to you if 1)
  if (BitAnd(l,128)) then begin res = 0; end;//empty buffer (sucessfull command)  
  if (BitAnd(l,256)) then begin res = 22106; goto LTestPrinterStatus; end;//top of the printer opened
//  if (BitAnd(l,512)) then begin res = 1; end;//always zero
//  if (BitAnd(l,1024)) then begin res = 1; end;//always zero
//  if (BitAnd(l,2048)) then begin res = 1; end;//always zero
//  if (BitAnd(l,4096)) then begin res = 1; end;//always zero
//  if (BitAnd(l,8192)) then begin res = 1; end;//always zero
  if (BitAnd(l,16384)) then begin res = 0; end;//cash box closed or non existent
  if (BitAnd(l,32768)) then begin res = 0; end;//Logic OR for 2 to 5, 8 and 14
LTestPrinterStatus:;
  TestPrinterStatus = res;
  return;
end;

function Integer TestFiscMemoryStatus(string fiscalstatus)
begin
  Integer res;
  LongInt l;

  l = POSNETHexToLong(Left(fiscalstatus,4));

  if (BitAnd(l,1)) then begin res = 22110; goto LTestFiscMemoryStatus; end;//fiscal printer memory error
  if (BitAnd(l,2)) then begin res = 22111; goto LTestFiscMemoryStatus; end;//internal buffer error
//  if (BitAnd(l,4)) then begin res = 0; end;//always 0
  if (BitAnd(l,8)) then begin res = 22112; goto LTestFiscMemoryStatus; end;//Unknown Command
  if (BitAnd(l,16)) then begin res = 22113; goto LTestFiscMemoryStatus; end;//Invalid Data
  if (BitAnd(l,32)) then begin res = 22114; goto LTestFiscMemoryStatus; end;//Invalid Command
  if (BitAnd(l,64)) then begin res = 22115; goto LTestFiscMemoryStatus; end;//total overflow
  if (BitAnd(l,128)) then begin res = 22116; goto LTestFiscMemoryStatus; end;//memory full, blocked or down
  if (BitAnd(l,256)) then begin res = 0; end;//memory almost full
  if (BitAnd(l,512)) then begin res = 0; end;//certified terminal
  if (BitAnd(l,1024)) then begin res = 0; end;//fiscalized terminal
  if (BitAnd(l,2048)) then begin res = 22118; goto LTestFiscMemoryStatus; end;//error in date
//  if (BitAnd(l,4096)) then begin res = 22119; goto LTestFiscMemoryStatus; end;//Document Already Opened
//  if (BitAnd(l,8192)) then begin res = 22120; goto LTestFiscMemoryStatus; end;//nonfiscal document already open
//  if (BitAnd(l,16384)) then begin res = 22121; goto LTestFiscMemoryStatus; end;//H_STATPRN
  if (BitAnd(l,32768)) then begin res = 0; end;//logic OR for 0 to 8 bits
LTestFiscMemoryStatus:;
  TestFiscMemoryStatus = res;
  return;
end;

function Integer TestHASARSuccess(string escseq,var string replystr)
begin
  Integer res,err;
  Integer noErr;
  Integer enqint;
  string 255 printerstatus,fiscalstatus;

  if (Left(escseq,4)==Left(replystr,4)) then begin
    printerstatus = Mid(replystr,5,4);
    res = TestPrinterStatus(printerstatus);
    if (res!=0) then begin
      goto LTestHASARSuccess;
    end;
    fiscalstatus = Mid(replystr,10,4);
    res = TestFiscMemoryStatus(fiscalstatus);
    if (res!=0) then begin
      goto LTestHASARSuccess;
    end;
  end else begin
    res = 12400;
    goto LTestHASARSuccess;
  end;
  res = noErr;
LTestHASARSuccess:;
  TestHASARSuccess = res;
  return;
end;

procedure SeqWithHasanCheckSum(array Integer aEscSeq,var Integer aCount)
begin
  string 255 cchex,escseq2;
  Integer cc,i;
  
  for (i=0;i<aCount;i=i+1) begin
    cc = cc + aEscSeq[i];
  end;
  cchex = NumToHex(cc);
  for(i=0;i<len(cchex);i=i+1)begin
    aEscSeq[aCount] = asc(Mid(cchex,i,1));
    aCount = aCount + 1;
  end;
  return;
end;

function Integer HASARWrite(array Integer aEscSeq,var Integer aCount,Boolean cancelstrf,var Integer cmdnr,var string replystr,Integer replylen)
begin
  string 255 result;
  Integer res,i;
  Integer noErr,err;
  Integer attempts;
  Integer enqint;
  Boolean testf;
  string 255 CtrlSeqcancelstr;
  LongInt starttick;  
  
  MilliSleep(800);
  i = 0;
  SeqWithHasanCheckSum(aEscSeq,aCount);
  res = OutComPortArray(aEscSeq,aCount);
  if (res!=noErr) then begin
    goto LHASARWrite2;
  end;
  res = 12400;
  starttick = GetCurTick;
  testf = true;
  while (testf) begin
    err = WaitHASARTime(replystr,1);
    if (nonblank(replystr)) then begin
      enqint = asc(Left(replystr,1));
      switch (enqint) begin
        case H_DC2: //continue
        case H_DC4: //continue
        case H_NAK: //retransmit
          err = OutComPortInteger(H_ACK);
          SeqWithHasanCheckSum(aEscSeq,aCount);
          err = OutComPortArray(aEscSeq,aCount);
          if (err!=noErr) then begin
            res = err;
            goto LHASARWrite2;
          end;
        case H_STATPRN: 
          err = OutComPortInteger(H_STATPRN);
          err = WaitHASARTime(replystr,replylen);
          testf = false;
        case H_ACK: //continue
        
        otherwise 
          testf = false;
          err = WaitHASARTime(replystr,replylen);
          replystr = chr(enqint) & replystr;
          res = noErr;
      end;
    end;
    if ((GetCurTick-starttick)>15000) then begin
      testf = false;
    end;
  end;
  
LHASARWrite2:;

  if (res==noErr) then begin
    res = TestHASARSuccess(ArrayToStr(aEscSeq,aCount),replystr);
    err = OutComPortInteger(H_ACK);
  end;
  if (res==noErr) then begin
    //err = OutComPortInteger(chr(H_ACK));
  end else begin
    if (cancelstrf) then begin
      aCount = 0;
      Add_ASC(aEscSeq,aCount,H_STX);
      Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
      Add_ASC(aEscSeq,aCount,H_ESC);
      Add_ASC(aEscSeq,aCount,152);
      Add_ASC(aEscSeq,aCount,H_ETX);
      err = HASARWrite(aEscSeq,aCount,false,cmdnr,replystr,20);
    end;
    HASARDisplayErrorMsg(res,"");
  end;
  HASARWrite = res;
  return;
end;

procedure GetHASARDate(string replystr,var Integer year,var Integer month,var Integer day)
BEGIN
  Integer i,l,what;
  string 1 nc;
  string 255 tstrY,tstrM,tstrD;
  Boolean getdatef;
  
  l = len(replystr);
  for (i=15;i<=16;i=i+1) begin
    nc = Mid(replystr,i,1);
    if ((asc(nc)>=asc("0")) and (asc(nc)<=asc("9"))) then begin
      tstrY = tstrY & nc;
    end;
  end;        
  for (i=17;i<=18;i=i+1) begin
    nc = Mid(replystr,i,1);
    if ((asc(nc)>=asc("0")) and (asc(nc)<=asc("9"))) then begin
      tstrM = tstrM & nc;
    end;
  end;
  for (i=19;i<=20;i=i+1) begin
    nc = Mid(replystr,i,1);
    if ((asc(nc)>=asc("0")) and (asc(nc)<=asc("9"))) then begin
      tstrD = tstrD & nc;
    end;
  end;          
  year = 2000 + StringToInt(tstrY);
  month = StringToInt(tstrM);
  day = StringToInt(tstrD);
  return;
end;

function Integer HASAROpen(record LSerialPortDeviceVc LSPDr)
begin
  Integer res;
  
  res = OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);
//  res = OpenComPort(0,device,9600,-1,8,0,kFlowControlDefault);
  HASAROpen = res;
  return;
end;

procedure HASARClose()
begin
  CloseComPort(0);
  return;
end;

function Integer HASARSetDateTime(record LSerialPortDeviceVc LSPDr,record IVVc IVr,var Integer cmdnr)
begin
  Integer res;
  Array Integer aCtrlSeq;
  Integer aCount,noErr;
  string 255 replystr;
  
  Add_ASC(aCtrlSeq,aCount,H_STX);
  Add_ASC(aCtrlSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aCtrlSeq,aCount,H_ESC);
  Add_ASC(aCtrlSeq,aCount,88); // 58H
  Add_ASC(aCtrlSeq,aCount,H_FS);
  Add_CHR(aCtrlSeq,aCount,DateToString(CurrentDate,"YYMMDD"));
  Add_ASC(aCtrlSeq,aCount,H_FS);
  Add_CHR(aCtrlSeq,aCount,"1230"); // HHMM
  Add_ASC(aCtrlSeq,aCount,H_ETX);
  res = HASARWrite(aCtrlSeq,aCount,false,cmdnr,replystr,19);
  
  HASARSetDateTime = res;
  return;
end;

function val DownPaymentAmount(record IVVc IVr,Integer ordrow)
begin
  val res;
  row IVVc IVrw;
  Integer i,rwcnt;

  if (ordrow>=0) then begin
    rwcnt =  MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==5) then begin
        if (IVrw.OrdRow==ordrow) then begin
          res = res + IVrw.Sum;
        end;
      end;
    end;
  end;
  DownPaymentAmount = res;
  RETURN;
END;

function string 255 CUVATRules(record MachineCashVc MCr,string regnr2)
begin
  string 255 res;
  Integer i,rwcnt;
  row MachineCashVc MCrw;
  
  rwcnt = MatRowCnt(MCr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(MCr,i,MCrw);
    if (MCrw.RegDef==regnr2) then begin
      switch (MCrw.CUVATRules) begin
        case 0: res = "";
        case 1: res = "I";
        case 2: res = "E";
        case 3: res = "E";
        case 4: res = "A";
        case 5: res = "C";  
        case 6: res = "M";  
        case 7: res = "M";  
        case 8: res = "S";  
        case 9: res = "S";  
        case 10: res = "S";  
        case 11: res = "T";  
        otherwise res = "I";         
      end;
    end;
  end;  
  CUVATRules = res;
  return;
end;
 
function Integer CheckHASARClock(record IVVc IVr,var Integer cmdnr)
begin
  Integer res;
  Date td;
  Integer pY,pM,pD;
  Array Integer aCtrlSeq;
  Integer aCount,noErr;
  string 255 replystr,msg;
  
//  HASARSetDateTime(LSPDr,IVr,cmdnr);
  td = CurrentDate;
  Add_ASC(aCtrlSeq,aCount,H_STX);
  Add_ASC(aCtrlSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aCtrlSeq,aCount,H_ESC);
  Add_ASC(aCtrlSeq,aCount,89); // 59H
  Add_ASC(aCtrlSeq,aCount,H_ETX);
  res = HASARWrite(aCtrlSeq,aCount,false,cmdnr,replystr,33);
  GetHASARDate(replystr,pY,pM,pD);
  if ((GetYear(td)==pY) and (GetMonth(td)==pM) and (GetDay(td)==pD)) then begin
    res = noErr;
  end else begin
    msg = AddMessage(msg,USetStr(12402));
//    msg = AddMessage(msg,USetStr(12403) & pY & "/" & pM & "/" & pD);
//    msg = AddMessage(msg,USetStr(12404) & DateToString(td,"YY/MM/DD"));
//     res = SendHASARString(chr(56));
    res = 1;
  end;
  td.year = pY;
  td.month = pM;
  td.day = pD;
  if (td==IVr.TransDate) then begin
    res = noErr;
  end else begin
    msg = AddMessage(msg,USetStr(20852) & " " & IVr.TransDate & " " & USetStr(12403) & " " & td);
    res = 1;
  end;
LCheckHASARClock:;
  HASARDisplayErrorMsg(0,msg);
  CheckHASARClock = res;
  RETURN;
END;

function Integer HASARSetCustomerData(record MachineCashVc MCr,record IVVc IVr,var Integer cmdnr,var Boolean AddPerceptions)
begin
  Integer res,noErr;
  string 255 replystr,tstr;
  record CUVc CUr;
  Array Integer aCtrlSeq;
  Integer aCount;

  CUr.Code = IVr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
  end;
  Add_ASC(aCtrlSeq,aCount,H_STX);
  Add_ASC(aCtrlSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aCtrlSeq,aCount,H_ESC);
  Add_ASC(aCtrlSeq,aCount,98); // 62H
  Add_ASC(aCtrlSeq,aCount,H_FS);
  Add_STR(aCtrlSeq,aCount,Left(IVr.Addr0,50));
  Add_ASC(aCtrlSeq,aCount,H_FS);
  Add_CHR(aCtrlSeq,aCount,StripNonDigits(IVr.VATNr));
  Add_ASC(aCtrlSeq,aCount,H_FS);
  tstr = CUVATRules(MCr,CUr.RegNr2);
  Add_CHR(aCtrlSeq,aCount,tstr);
  AddPerceptions = (tstr=="M" or tstr=="I");
  Add_ASC(aCtrlSeq,aCount,H_FS);
  switch (CUr.DocType) begin
    case "80": Add_CHR(aCtrlSeq,aCount,"C");
    case "86": Add_CHR(aCtrlSeq,aCount,"L");
    case "87": Add_CHR(aCtrlSeq,aCount,"4");
    case "89": Add_CHR(aCtrlSeq,aCount,"0");
    case "90": Add_CHR(aCtrlSeq,aCount,"1");
    case "94": Add_CHR(aCtrlSeq,aCount,"3");
    case "96": Add_CHR(aCtrlSeq,aCount,"2");
    otherwise
      switch (CUr.CustType) begin
        case 1:
          Add_CHR(aCtrlSeq,aCount,"L");
        otherwise
          Add_CHR(aCtrlSeq,aCount,"C");
      end;
  end;
  Add_ASC(aCtrlSeq,aCount,H_FS);
  Add_STR(aCtrlSeq,aCount,Left(IVr.Addr1,50));
  Add_ASC(aCtrlSeq,aCount,H_ETX);
  res = HASARWrite(aCtrlSeq,aCount,false,cmdnr,replystr,19);
LHASARSetCustomerData:;
  HASARSetCustomerData = res;
  return;
end;

function Integer HASARSetEmbarkNumber(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,noErr,rwcnt,i;
  string 255 replystr,tstr,cnnr;
  record CUVc CUr;
  record IVVc IV2r;
  row IVVc IVrw;
  array Integer aEscSeq;
  Integer aCount;

  if(IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales)then begin
    cnnr = ".";
    cnnr = 1000;
    rwcnt = MatRowCnt(IVr);
    for(i=0;i<rwcnt;i=i+1)begin
      MatRowGet(IVr,i,IVrw);
      if(IVrw.stp == 3)then begin
        IV2r.SerNr = IVrw.OrdRow;
        if(ReadFirstMain(IV2r,1,true))then begin
        end;
        cnnr = IV2r.OfficialSerNr & cnnr;
      end;
    end;
    Add_ASC(aEscSeq,aCount,H_STX);
    Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
    Add_ASC(aEscSeq,aCount,H_ESC);
    Add_ASC(aEscSeq,aCount,147); // 93H
    Add_ASC(aEscSeq,aCount,H_FS);
    Add_CHR(aEscSeq,aCount,"1");
    Add_ASC(aEscSeq,aCount,H_FS);
    Add_CHR(aEscSeq,aCount,cnnr);
    Add_ASC(aEscSeq,aCount,H_ETX);
    res = HASARWrite(aEscSeq,aCount,false,cmdnr,replystr,19);
  end else begin
    res = 0;
  end;
  
LHASARSetEmbarkNumber:;
  HASARSetEmbarkNumber = res;
  return;
end;

function Integer HASAROpenFiscalReceipt(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,noErr;
  string 255 replystr;
  array Integer aEscSeq;
  Integer aCount;
  string 1 c,InvKind,DocType;
  Integer i,cnt;
  
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
    Add_ASC(aEscSeq,aCount,128); // 80H
  end else begin
    Add_ASC(aEscSeq,aCount,64); // 40H
  end;
  Add_ASC(aEscSeq,aCount,H_FS);
  cnt = Len(IVr.OfficialSerNr);
  for (i=0;i<cnt;i=i+1) begin
    c = Mid(IVr.OfficialSerNr,i,1);
    if (c=="-") then begin
      i = cnt;
    end else begin
      InvKind = c;
    end;
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeNormalSpecialSales: goto LkInvoiceTypeNormal;
    case kInvoiceTypeNormal: // Normal
      LkInvoiceTypeNormal:;
      switch (InvKind) begin
        case "A": DocType = "A";
        case "B": DocType = "B";
        case "C": DocType = "B";
      end;
    case kInvoiceTypeCash: // Cash
      switch (InvKind) begin
        case "A": DocType = "A";
        case "B": DocType = "B";
        case "C": DocType = "B";
      end;
    case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit: // Credit Note
      LkInvoiceTypeCredit:;
      switch (InvKind) begin
        case "A": DocType = "R";
        case "B": DocType = "S";
        case "C": DocType = "S";
      end;
    case kInvoiceTypeInterest: // Manual Interest Invoice
      switch (InvKind) begin
        case "A": DocType = "D";
        case "B": DocType = "E";
        case "C": DocType = "E";
      end;
  end;
  Add_ASC(aEscSeq,aCount,asc(DocType));
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,asc("T"));
  Add_ASC(aEscSeq,aCount,H_ETX);

  res = HASARWrite(aEscSeq,aCount,false,cmdnr,replystr,28);
LHASAROpenFiscalReceipt:;  
  HASAROpenFiscalReceipt = res;
  return;
end;

function Integer HASARPrintLastItemDiscount(record IVVc IVr,row IVVc IVrw,var Integer cmdnr)
begin
  Integer res,noErr;
  string 255 replystr,tstr;
  Array Integer aEscSeq;
  Integer aCount;
  val Discount,t;
  
  Discount = IVrw.Quant * IVrw.Price * IVrw.vRebate / 100;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,85); // 55H
  Add_ASC(aEscSeq,aCount,H_FS);
  t = IVrw.vRebate;
  if (t<0) then begin
    t = -t;
  end;
  tstr = ValToString(t,M41Val,"",".",0) & " %";
  Add_STR(aEscSeq,aCount,Left(tstr,50));
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_VAL(aEscSeq,aCount,Discount);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_CHR(aEscSeq,aCount,"m");
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_CHR(aEscSeq,aCount,"0");
  Add_ASC(aEscSeq,aCount,H_FS);
  if (IVr.InclVAT==0) then begin
    tstr = "X";
  end else begin
    tstr = "T";
  end;
  Add_CHR(aEscSeq,aCount,tstr);
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,19);
  
LHASARPrintLastItemDiscount:;
  HASARPrintLastItemDiscount = res;
  return;
end;

function Integer HASARPrintInvoiceLines(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,noErr,res2;
  record CashPrintBlock CPb;
  record LocalMachineBlock LMb;
  record INVc INr;
  Integer i,rwcnt;
  row IVVc IVrw;
  string 255 tstr;
  string 255 replystr;
  val downpay,t;
  array Integer aEscSeq;
  Integer aCount,SpecLinesCount;

//PrintLineItem    
  BlockLoad(LMb);
  BlockLoad(CPb);
  rwcnt =  MatRowCnt(IVr);
  // Ignore all lines with empty ArtCode in the bottom of the matrix
  // Because 41H must always be followed by 42H
  if (rwcnt>0) then begin
    MatRowGet(IVr,rwcnt-1,IVrw);
    while (rwcnt>0 and Blank(IVrw.ArtCode)) begin
      rwcnt = rwcnt - 1;
      if (rwcnt>0) then begin
        MatRowGet(IVr,rwcnt-1,IVrw);
      end;
    end;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
        downpay = DownPaymentAmount(IVr,IVrw.OrdRow);
        if (downpay!=0) then begin
          IVrw.Sum = IVrw.Sum + downpay;
          IVrw.Price = IVrw.Sum/IVrw.Quant;
        end;
      case 11: ;
      case 5: 
        if (IVrw.Sum<0) then begin 
          goto LSKIPROW;
        end;
        IVrw.Price = IVrw.Sum/IVrw.Quant;
      otherwise 
        goto LSKIPROW;
    end;
    if (Blank(IVrw.ArtCode) and SpecLinesCount>=4) then begin
      goto LSKIPROW;
    end;
    if (NonBlank(IVrw.ArtCode)) then begin
      aCount = 0;
      Add_ASC(aEscSeq,aCount,H_STX);
      Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
      Add_ASC(aEscSeq,aCount,H_ESC);
      Add_ASC(aEscSeq,aCount,66); //42H
      Add_ASC(aEscSeq,aCount,H_FS);
      tstr = IVrw.ArtCode & " " & IVrw.Spec;
      Add_STR(aEscSeq,aCount,Left(tstr,50));
      Add_ASC(aEscSeq,aCount,H_FS);
      t = IVrw.Quant;
      if (IVrw.Price<0)then begin
        t = -t;
      end;
      Add_VAL(aEscSeq,aCount,t);
      Add_ASC(aEscSeq,aCount,H_FS);
      t = IVrw.Price;
      if ((IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and IVrw.stp!=11) then begin
        t = -t;
      end;
      Add_VAL(aEscSeq,aCount,t);
      Add_ASC(aEscSeq,aCount,H_FS);
      GetVATproc(IVrw.VATCode,IVr.InclVAT,t);
      if (t==blankval) then begin
        GetVATproc(IVrw.VATCode,0,t);
      end;
      if (t==blankval) then begin
        t = 0;
      end;
      Add_VAL(aEscSeq,aCount,t);
      Add_ASC(aEscSeq,aCount,H_FS);
      tstr = "";
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (IVrw.stp==11) then begin
          if (IVrw.Sum<0) then begin tstr = "m"; end;      
        end else begin
          if (IVrw.Sum>0) then begin tstr = "m"; end;      
        end;
      end else begin
        if (IVrw.Sum<0) then begin tstr = "m"; end;
      end;
      if (blank(tstr)) then begin tstr = "M"; end;    
      Add_CHR(aEscSeq,aCount,tstr);
      Add_ASC(aEscSeq,aCount,H_FS);
      Add_ASC(aEscSeq,aCount,asc("0"));
      Add_ASC(aEscSeq,aCount,H_FS);
      if (LMb.UseDisplay!=0) then begin
        Add_ASC(aEscSeq,aCount,asc("1"));
      end else begin
        Add_ASC(aEscSeq,aCount,asc("0"));
      end;
      Add_ASC(aEscSeq,aCount,H_FS);
      // T: total price, another character: Base price
      // if row includes VAT then T, if it doesnt then X
      if (IVr.InclVAT==0) then begin
        tstr = "X";
      end else begin
        tstr = "T";
      end;
      Add_CHR(aEscSeq,aCount,tstr);
      Add_ASC(aEscSeq,aCount,H_ETX);
      res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,19);
    end else begin
      aCount = 0;
      Add_ASC(aEscSeq,aCount,H_STX);
      Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
      Add_ASC(aEscSeq,aCount,H_ESC);
      Add_ASC(aEscSeq,aCount,65); //41H
      Add_ASC(aEscSeq,aCount,H_FS);
      Add_STR(aEscSeq,aCount,Left(IVrw.Spec,50));
      Add_ASC(aEscSeq,aCount,H_FS);
      Add_CHR(aEscSeq,aCount,"0");
      Add_ASC(aEscSeq,aCount,H_ETX);
      res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,19);
      SpecLinesCount = SpecLinesCount + 1;
    end;
    if (IVrw.vRebate!=BlankVal) then begin
      HASARPrintLastItemDiscount(IVr,IVrw,cmdnr);
    end;
LSKIPROW:;    
  end;
LHASARPrintInvoiceLines:;  
  HASARPrintInvoiceLines = res;
  return;
end;

function Integer HASARTotalTenderCancel(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,noErr,res2;
  string 255 tstr;
  string 255 replystr;
  record LocalMachineBlock LMb;
  array Integer aEscSeq;
  Integer aCount;

  BlockLoad(LMb);
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,68);
  Add_ASC(aEscSeq,aCount,H_FS);
  M4PadString("",50," ",false,tstr);
  Add_CHR(aEscSeq,aCount,tstr);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_VAL(aEscSeq,aCount,IVr.Sum4);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,asc("C"));
  Add_ASC(aEscSeq,aCount,H_FS);
  if (LMb.UseDisplay!=0) then begin
    Add_ASC(aEscSeq,aCount,1);
  end else begin
    Add_ASC(aEscSeq,aCount,0);
  end;
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,33);
LHASARTotalTenderCancel:;  
  HASARTotalTenderCancel = res;
  return;
end;

function Integer HasarPerceptions(record IVVc IVr,var Integer cmdnr,Boolean AddPerceptions,string TaxType)
begin
  Integer res,noErr;
  string 255 replystr,tstr;
  Array Integer aEscSeq;
  Integer aCount;
  val TaxSum,t;
  string 255 TaxDescr,TaxSide;
  
  if (!AddPerceptions) then begin
    goto LHasarPerceptions;
  end;
  switch (TaxType) begin
    case "I": 
      TaxSum = IVr.TAX1Sum;
      TaxDescr = "VAT Perception";
      TaxSide = "**.**"; // TODO: this needs to be assigned to used VAT %
    case "O": 
      TaxSum = IVr.TAX2Sum;
      TaxDescr = "Gross Income Perception";
      TaxSide = "**.**";
  end;
  if (TaxSum==BlankVal) then begin
    goto LHasarPerceptions;
  end;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,96); // 60H
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_CHR(aEscSeq,aCount,TaxSide);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_CHR(aEscSeq,aCount,TaxDescr);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_VAL(aEscSeq,aCount,TaxSum);
  Add_ASC(aEscSeq,aCount,H_ETX);
  
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,19);
LHasarPerceptions:;  
  HasarPerceptions = res;
  return;
end;

function Integer HASARTotalTender(record IVVc IVr,var Integer cmdnr,Boolean AddPerceptions)
begin
  Integer res,noErr,res2;
  string 255 tstr;
  string 255 replystr;
  record LocalMachineBlock LMb;
  array Integer aEscSeq;
  Integer aCount;
  val t;

  BlockLoad(LMb);
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
    Add_ASC(aEscSeq,aCount,129); // 81H
    Add_ASC(aEscSeq,aCount,asc("0"));
  end else begin
    Add_ASC(aEscSeq,aCount,68); // 44H
    Add_ASC(aEscSeq,aCount,H_FS);
    M4PadString("",50," ",false,tstr);
    Add_CHR(aEscSeq,aCount,tstr);
    Add_ASC(aEscSeq,aCount,H_FS);
    if (AddPerceptions) then begin
      t = IVr.Sum4;
    end else begin
      t = IVr.Sum4 - IVr.TAX1Sum - IVr.TAX2Sum;
    end;
    Add_VAL(aEscSeq,aCount,t);
    Add_ASC(aEscSeq,aCount,H_FS);
    Add_ASC(aEscSeq,aCount,asc("T"));
    Add_ASC(aEscSeq,aCount,H_FS);
    if (LMb.UseDisplay!=0) then begin
      Add_ASC(aEscSeq,aCount,asc("1"));
    end else begin
      Add_ASC(aEscSeq,aCount,asc("0"));
    end;
  end;
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,33);
LHASARTotalTender:;  
  HASARTotalTender = res;
  return;
end;

function Integer HASARCloseFiscalReceipt(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,noErr;
  string 255 replystr;
  Array Integer aEscSeq;
  Integer aCount;
  
  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
    goto LHASARCloseFiscalReceipt;
  end;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,69); // 45H
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,asc("0"));
  Add_ASC(aEscSeq,aCount,H_ETX);
  
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,55);
LHASARCloseFiscalReceipt:;  
  HASARCloseFiscalReceipt = res;
  return;
end;

global
updating procedure PrintHASARReceipt(record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  record IVVc lIVr;
  record IVVc oldIVr;
  Integer noErr,res;
  Array val FPVATRates;
  record CashPrintBlock CPb;
  string 255 lastinvcnt;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  Integer cmdnr;
  Boolean AddPerceptions;
    
  res = HASAROpen(LSPDr);
  if (res!=1) then begin
    goto LPrintHASARReceipt;
  end;
  if (blank(LSPDr.Port)) then begin
    LSPDr.Port = "COM1";
  end;  
  cmdnr = 33;
  BlockLoad(LMb);
  MCr.Code = LMb.LocalMachineCode;
  ReadFirstMain(MCr,1,true);
  if (CheckHASARClock(IVr,cmdnr)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HASARSetCustomerData(MCr,IVr,cmdnr,AddPerceptions)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HASARSetEmbarkNumber(IVr,cmdnr)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HASAROpenFiscalReceipt(IVr,cmdnr)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HASARPrintInvoiceLines(IVr,cmdnr)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HasarPerceptions(IVr,cmdnr,AddPerceptions,"I")!=noErr) then begin goto LPrintHASARReceipt; end;
  if (HasarPerceptions(IVr,cmdnr,AddPerceptions,"O")!=noErr) then begin goto LPrintHASARReceipt; end;
  if (HASARTotalTender(IVr,cmdnr,AddPerceptions)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  if (HASARCloseFiscalReceipt(IVr,cmdnr)!=noErr) then begin
    goto LPrintHASARReceipt;
  end;
  lIVr.SerNr = IVr.SerNr;
  if (ReadFirstMain(lIVr,1,true)) then begin
    RecordCopy(oldIVr,lIVr);
    lIVr.Prntdf = 1;
    if (RecordUpdate(oldIVr,lIVr,false)==0) then begin
    end;
  end;
LPrintHASARReceipt:;
  HasarClose;
  return;
end;

global
procedure HasarDailyReport(record LSerialPortDeviceVc LSPDr)
begin
  Integer cmdnr,res;
  string 255 replystr;
  array Integer aEscSeq;
  Integer aCount;
  
  res = HASAROpen(LSPDr);
  if (res!=1) then begin
    goto LHasarDailyReport;
  end;
  cmdnr = 31;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,57);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,asc("X"));
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,255);
LHasarDailyReport:;  
  HASARClose;
  return;
end;

global
procedure HasarMonthlyReport(record LSerialPortDeviceVc LSPDr)
begin
  Integer cmdnr,res;
  string 255 replystr;
  array Integer aEscSeq;
  Integer aCount;
  
  res = HASAROpen(LSPDr);
  if (res!=1) then begin
    goto LHasarDailyReport;
  end;
  cmdnr = 32;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,57);
  Add_ASC(aEscSeq,aCount,H_FS);
  Add_ASC(aEscSeq,aCount,asc("Z"));
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,255);
LHasarDailyReport:;  
  HASARClose;
  return;
end;

global
procedure HASARReset(record LSerialPortDeviceVc LSPDr)
begin
  Integer res,cmdnr;
  string 255 replystr;
  array Integer aEscSeq;
  Integer aCount;
  
  res = HASAROpen(LSPDr);
  if (res!=1) then begin
    goto LHASARReset;
  end;
  cmdnr = 0;
  Add_ASC(aEscSeq,aCount,H_STX);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,H_ESC);
  Add_ASC(aEscSeq,aCount,152); // 98H
  Add_ASC(aEscSeq,aCount,H_ETX);
  res = HASARWrite(aEscSeq,aCount,true,cmdnr,replystr,20);
  HASARClose;
  
LHASARReset:;  
  return;
end;
