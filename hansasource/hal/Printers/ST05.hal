external function roundmode SetRoundModeD(Integer);
external procedure ST05CancelReceipt();
external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure ExtractObj(string,var Integer,var string);
external procedure GetVATdouble(string,var val,var val,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val ValFromString(string,string,string);
external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external function string 255 NumToHex(string);

//FS, Field Separator = 0x1C

enum begin
  ST05_DELAY = 10,
  ST05_LONGDELAY = 30
end;

enum begin
  ST05_SOC = 10, //0x0A
  ST05_ECM = 13, //0x0D
  ST05_SCM = 35, //0x23
  ST05_ACK = 81  //0x51
end;

procedure PopulateCRCTable(Array Integer aCRC)
begin
  acrc[0] = 0; acrc[1] = 94; acrc[2] = 188; acrc[3] = 226;  acrc[4] = 97;  
  acrc[5] = 63; acrc[6] = 221; acrc[7] = 131; acrc[8] = 194; acrc[9] = 156; 
  acrc[10] = 126; acrc[11] = 32; acrc[12] = 163; acrc[13] = 233; acrc[14] = 31; 
  acrc[15] = 65; acrc[16] = 157; acrc[17] = 195; acrc[18] = 33; acrc[19] = 127;
  acrc[20] = 252; acrc[21] = 162;  acrc[22] = 64;  acrc[23] = 30; acrc[24] = 95;  
  acrc[25] = 1; acrc[26] = 227; acrc[27] = 189;  acrc[28] = 62;  acrc[29] = 96;
  acrc[30] = 130; acrc[31] = 220; acrc[32] = 35; acrc[33] = 125; acrc[34] = 159;
  acrc[35] = 193; acrc[36] = 66;  acrc[37] = 28; acrc[38] = 254; acrc[39] = 160;
  acrc[40] = 225; acrc[41] = 191;  acrc[42] = 93; acrc[43] = 3; acrc[44] = 128;
  acrc[45] = 222;  acrc[46] = 60; acrc[47] = 98; acrc[48] = 190; acrc[49] = 224;  
  acrc[50] = 2; acrc[51] = 92; acrc[52] = 223; acrc[53] = 129; acrc[54] = 99; 
  acrc[55] = 61; acrc[56] = 124; acrc[57] = 34; acrc[58] = 192; acrc[59] = 158; 
  acrc[60] = 29;  acrc[61] = 67; acrc[62] = 161; acrc[63] = 255; acrc[64] = 70; 
  acrc[65] = 24; acrc[66] = 250; acrc[67] = 164;  acrc[68] = 39; acrc[69] = 121;
  acrc[70] = 155; acrc[71] = 197; acrc[72] = 132; acrc[73] = 218; acrc[74] = 56;
  acrc[75] = 102; acrc[76] = 229; acrc[77] = 187;  acrc[78] = 89; acrc[79] = 7;
  acrc[80] = 219; acrc[81] = 133; acrc[82] = 103; acrc[83] = 57; acrc[84] = 186;
  acrc[85] = 228; acrc[86] = 6; acrc[87] = 88; acrc[88] = 25; acrc[89] = 71;  
  acrc[90] = 165; acrc[91] = 251; acrc[92] = 120; acrc[93] = 38; acrc[94] = 196;
  acrc[95] = 154; acrc[96] = 101; acrc[97] = 59; acrc[98] = 217; acrc[99] = 135;  
  acrc[100] = 4;  acrc[101] = 90; acrc[102] = 184; acrc[103] = 230; acrc[104] = 167;
  acrc[105] = 249;  acrc[106] = 27; acrc[107] = 69; acrc[108] = 198; acrc[109] = 152;
  acrc[110] = 122; acrc[111] = 36; acrc[112] = 248; acrc[113] = 166; acrc[114] = 68; 
  acrc[115] = 26; acrc[116] = 153; acrc[117] = 199;  acrc[118] = 37; acrc[119] = 123; 
  acrc[120] = 58; acrc[121] = 100; acrc[122] = 134; acrc[123] = 216; acrc[124] = 91;  
  acrc[125] = 5; acrc[126] = 231; acrc[127] = 185; acrc[128] = 140; acrc[129] = 210; 
  acrc[130] = 48; acrc[131] = 110; acrc[132] = 237; acrc[133] = 179; acrc[134] = 81; 
  acrc[135] = 15; acrc[136] = 78; acrc[137] = 16; acrc[138] = 242; acrc[139] = 172; 
  acrc[140] = 47; acrc[141] = 113; acrc[142] = 147; acrc[143] = 205; acrc[144] = 17; 
  acrc[145] = 79; acrc[146] = 173; acrc[147] = 243; acrc[148] = 112; acrc[149] = 46;
  acrc[150] = 204; acrc[151] = 146; acrc[152] = 211; acrc[153] = 141; acrc[154] = 111; 
  acrc[155] = 49; acrc[156] = 178; acrc[157] = 236; acrc[158] = 14; acrc[159] = 80;  
  acrc[160] = 175; acrc[161] = 241; acrc[162] = 19; acrc[163] = 77; acrc[164] = 206;
  acrc[165] = 144; acrc[166] = 114; acrc[167] = 44; acrc[168] = 109;  acrc[169] = 51; 
  acrc[170] = 209; acrc[171] = 143; acrc[172] = 12; acrc[173] = 82; acrc[174] = 176;
  acrc[175] = 238; acrc[176] = 50; acrc[177] = 108; acrc[178] = 142; acrc[179] = 208; 
  acrc[180] = 83;  acrc[181] = 13; acrc[182] = 239; acrc[183] = 177; acrc[184] = 240;
  acrc[185] = 174; acrc[186] = 76; acrc[187] = 18; acrc[188] = 145; acrc[189] = 207; 
  acrc[190] = 45; acrc[191] = 115; acrc[192] = 202; acrc[193] = 148;acrc[194] = 118; 
  acrc[195] = 40; acrc[196] = 171; acrc[197] = 245; acrc[198] = 23; acrc[199] = 73;  
  acrc[200] = 8; acrc[201] = 86; acrc[202] = 180; acrc[203] = 234; acrc[204] = 105; 
  acrc[205] = 55; acrc[206] = 213; acrc[207] = 139; acrc[208] = 87; acrc[209] = 9;
  acrc[210] = 235; acrc[211] = 181; acrc[212] = 54; acrc[213] = 104; acrc[214] = 138;
  acrc[215] = 212; acrc[216] = 149; acrc[217] = 203; acrc[218] = 41; acrc[219] = 119;
  acrc[220] = 244; acrc[221] = 170; acrc[222] = 72; acrc[223] = 22; acrc[224] = 233;
  acrc[225] = 183;  acrc[226] = 85; acrc[227] = 11; acrc[228] = 136; acrc[229] = 214; 
  acrc[230] = 52; acrc[231] = 106; acrc[232] = 43; acrc[233] = 117; acrc[234] = 151;
  acrc[235] = 201; acrc[236] = 74; acrc[237] = 20;acrc[238] = 246; acrc[239] = 168;
  acrc[240] = 116; acrc[241] = 42; acrc[242] = 200; acrc[243] = 150; acrc[244] = 21; 
  acrc[245] = 75; acrc[246] = 169; acrc[247] = 247; acrc[248] = 182; acrc[249] = 232; 
  acrc[250] = 10; acrc[251] = 84; acrc[252] = 215; acrc[253] = 137; acrc[254] = 107; 
  acrc[255] = 53;
  
  return;
end;

function string 255 CalculateControlSum(string CtrlSeq)
begin
  string 255 res;
  Array Integer CRC;
  Integer i,l,a;
  Integer bcrc,v;
 
  PopulateCRCTable(CRC);
  l = len(CtrlSeq);
  for (i=0;i<l;i=i+1) begin
    a = GetByteFromString(Mid(CtrlSeq,i,1),0);
    bcrc = BitXor(bcrc,a);
//    bcrc = BitXor(bCrc,asc(Mid(CtrlSeq,i,1)));
    bcrc = CRC[bcrc];
  end;

  v = bcrc/power(2,4);  // val = bcrc >> 4 ;

  if (v<=9) then begin
    res = chr(v + 48);  // pDest[ 0 ] = val + 0x30 ;
  end;
  if (v>=10) and (v<=15) then begin
    res = chr(v + 65 - 10);  // pDest[ 0 ] = val + 'A' - 0x0A ;
  end;

  v = BitAnd(bcrc,15); //
  if (v<=9) then begin
    res = res & chr(v + 48);  // pDest[ 1 ] = val + 0x30 ;
  end;
  if (v>=10) and (v<=15) then begin
    res = res & chr(v + 65 - 10); //  pDest[ 1 ] = val + 'A' - 0x0A ;
  end;
  CalculateControlSum = res;
  return;
end;

function Integer FindStrPosition(string tstr,string decsep)
begin
  Integer res;
  Integer i,slen;
  
  slen = len(tstr);
  for (i=slen;i>=0;i=i-1) begin
    if (Mid(tstr,i,1)==decsep) then begin
       res = i;
       goto LFindStrPosition;
    end;
  end;
LFindStrPosition:;  
  FindStrPosition = res;
  return;  
end;

function Integer HexToInt(string instr)
begin
  Integer res;
  string 16 hexs;
  Integer pos,slen,i,t;

  res = 0;
  slen = len(instr);
  hexs = "0123456789ABCDEF";
  for (i=slen;i>0;i=i-1) begin
    pos = FindStrPosition(hexs,Mid(instr,i-1,1));
    res = res + pos*Power(16,(slen-i));
  end; 
  HexToInt = res; 
  return;  
end;

function val BCD62ToVal(string src)
begin
  val res;
  string 255 tstr,c,lsrc;
  Integer i,v,t;

//00000002100C
//00 00 00 01 80 0C
  for (i=0;i<len(src);i=i+2) begin
    v = HexToInt(Mid(src,i,2));
    lsrc = lsrc & chr(v);
  end;
  for (i=0;i<6;i=i+1) begin
    t = BitAnd(asc(Mid(lsrc,i,1)),240);
    v = t/power(2,4);
    c  = chr(v + 48);
    tstr = tstr & c;

    t = BitAnd(asc(Mid(lsrc,i,1)),15);
    v = t;
    c  = chr(v + 48);
    tstr = tstr & c;
  end;

  tstr = src;
  res = ValFromString(tstr,"","");
  res = res / 100.00; //precision
    
  if (BitAnd(asc(Mid(lsrc,5,1)),15)==13) then begin //==0x0d
    res = -res;
  end;
  BCD62ToVal = res;
  return;
end;
/*
function string 255 ValToBCD62(val src)
begin
  string 255 res,tstr,c;
  val lsrc;
  Integer i,v,t;
   
  lsrc = src;
  if (lsrc<0) then begin lsrc = -lsrc; end;
  lsrc = lsrc*100.00; //precision
   
  tstr = ValToString(lsrc,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
//  tstr = tstr & "0";

//00000002100
//00000002100

  for (i=0;i<6;i=i+1) begin
    t = asc(Mid(tstr,i*2,1)) - 48;
    t = BitAnd(t,15);
    v = t*power(2,4);
   
    t = asc(Mid(tstr,i*2+1,1)) - 48;
    t = BitAnd(t,15);
    v = v + t;
    res = res & v;
  end;

  res = res & "C";
Trace("0.src " & src , " res " & res);
  tstr = "";
  for (i=0;i<len(res);i=i+2) begin
    tstr = tstr & NumToHex(Mid(res,i,2));
  end;

//00000002100C

//Trace("2.src " & src & " tstr " & tstr,"");

   ValToBCD62 = res;
   return;
end;
*/

function string 255 DecodeResponse(string response)
begin
  string 255 res;
  Integer i,l,v;
  
//  23 30303034 30303030 30303032 31303043 4242 0D
//=
//      0004    0000     0002     100C     BB
  l = len(response);
  for (i=0;i<l;i=i+2) begin
    v = HexToInt(Mid(response,i,2));
    res = res & uchr(v);
  end;
  DecodeResponse = res;
  return;
end;

function Integer WaitForST05Reply(LongInt waittickscoef,Boolean acknowledgeonlyf,var string response)
begin
  Integer res;
  Integer noErr;
  LongInt waitticks;
  LongInt currenttick, starttick;
  Integer l,responselen;
  Boolean waitf;
  string 255 c,errorcode,status;
  Integer pos,i;
  string 255 tstr,tstr2;

  res = noErr;
  response = "";
  waitticks = waittickscoef*1000;
//  waitticks = 1*1000;
  starttick = GetCurTick;

  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    response = response & c;
    if (len(response)>=250) then begin
      waitf = false;
    end;

    if (acknowledgeonlyf) then begin
      if (asc(c)==ST05_ACK) then begin
        waitf = false;
      end;    
    end else begin
      if (asc(c)==ST05_ECM) then begin
        waitf = false;
      end;    
    end;
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
LWaitForST05Reply:;
//LogText(0,"WaitForST05Reply response " & response);
  if (acknowledgeonlyf) then begin
    if (asc(response)==ST05_ACK) then begin
      res = 0;
    end else begin
      res = -1;
//      ST05CancelReceipt;
    end;
  end else begin
    response = Mid(response,1,len(response)-4);
    errorcode = Left(response,2);
    status = Mid(response,2,2);
    response = Mid(response,4,len(response)-4);
    if (errorcode!="00") then begin
      res = asc(errorcode) - 48;
    end;
    if (res!=noErr) then begin
      LogText(0,"WaitForST05Reply errorcode " & errorcode & " res " & res & " status " & status);
//      ST05CancelReceipt;
    end;  
    if (res==noErr) then begin
      if (blank(errorcode)) then begin
        LogText(0,"WaitForST05Reply blank errorcode ");
        res = -2;
      end;
    end;
  end;
  WaitForST05Reply = res;
  return;
end;

function string 255 ConvertToST05Command(string CtrlSeq)
begin
  string 255 res;
  Integer i,l;
  
//Sending command: #130130
//Sent 8 of 8: 3133303133 

/*
  l = len(CtrlSeq);
  for (i=0;i<l;i=i+1) begin
    res = res & Right(NumToHex(asc(Mid(CtrlSeq,i,1))),2);
  end;
*/
  res = CtrlSeq;
  ConvertToST05Command = res;
  return;
end;

function Integer ST05Write(string aCtrlSeq,LongInt delay) 
begin
  Integer res,noErr;
  string 255 response;
  string 255 CtrlSeq;
  Boolean sent;
 
  CtrlSeq = aCtrlSeq & CalculateControlSum(aCtrlSeq);  
  CtrlSeq = chr(ST05_SCM) & CtrlSeq & chr(ST05_ECM);
  res = -3;
  sent = OutComPort(0,chr(ST05_SOC));
  if (sent) then begin
    res = WaitForST05Reply(delay,true,response);
  end;
  if (res!=noErr) then begin
    goto LST05Write;
  end;
  res = -4;
  sent = OutComPort(0,CtrlSeq);
  if (sent) then begin
    res = WaitForST05Reply(delay,false,response);
  end;
LST05Write:;  
  ST05Write = res;
  return;
end;

function Integer EndNonFiscalReceipt()
begin
  INteger res,noErr;
  string 255 CtrlSeq;

  CtrlSeq = "0F";
  CtrlSeq = CtrlSeq & "00";  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  EndNonFiscalReceipt = res;
  return;
end;

global
procedure ST05CancelReceipt()
begin
  Integer res,noErr;
  string 255 CtrlSeq;
  Boolean sent;

  CtrlSeq = "04";
  CtrlSeq = CtrlSeq & CalculateControlSum(CtrlSeq);  
  CtrlSeq = chr(ST05_SCM) & ConvertToST05Command(CtrlSeq) & chr(ST05_ECM);
  sent = OutComPort(0,CtrlSeq);
  return;
end;

function Integer ST05WriteAndGetResponse(string aCtrlSeq,LongInt delay,var string response) 
begin
  Integer res,noErr;
  string 255 CtrlSeq;
  Boolean sent;

  response = ""; 
  CtrlSeq = aCtrlSeq & CalculateControlSum(aCtrlSeq);  
  CtrlSeq = chr(ST05_SCM) & CtrlSeq & chr(ST05_ECM);
  res = -5;
  sent = OutComPort(0,chr(ST05_SOC));
  if (sent) then begin
    res = WaitForST05Reply(delay,true,response);
  end;
  if (res!=noErr) then begin
    goto LST05WriteAndGetResponse;
  end;
  
  res = -6;
  sent = OutComPort(0,CtrlSeq);
  if (sent) then begin
    res = WaitForST05Reply(delay,false,response);
  end;
LST05WriteAndGetResponse:;  
  ST05WriteAndGetResponse = res;
  return;
end;

function Integer ST05WriteAndGetReceipt(string aCtrlSeq,LongInt delay,var Area aresponse) 
begin
  Integer res,noErr;
  Boolean sent;
  string 255 CtrlSeq,response;

  CtrlSeq = aCtrlSeq & CalculateControlSum(aCtrlSeq);  
  CtrlSeq = chr(ST05_SCM) & CtrlSeq & chr(ST05_ECM);

  sent = OutComPort(0,chr(ST05_SOC));
  if (sent) then begin
    res = WaitForST05Reply(delay,true,response);
  end;
  if (res!=noErr) then begin
    goto LST05WriteAndGetReceipt;
  end;
  sent = OutComPort(0,CtrlSeq);
  if (sent) then begin
    res = WaitForST05Reply(delay,false,response);
  end;
LST05WriteAndGetReceipt:;  
  ST05WriteAndGetReceipt = res;
  return;
end;

procedure OpenCashDrawer()
begin
  INteger res,noErr;
  string 255 CtrlSeq;

  CtrlSeq = "0D";  
  res = ST05Write(CtrlSeq,ST05_DELAY);
  return;
end;

function Integer CheckST05Clock()
begin
  INteger res,noErr;
  string 255 CtrlSeq,response,fpresp; 
  Date td; 
  Integer pY,pM,pD;
  

  td = CurrentDate;
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & "09";  
  
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
      
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,"error " & USetStr(res));
    end;
    goto LCheckST05Clock;
  end;

  fpresp = DecodeResponse(response);
  
  pY = StringToInt(Left(fpresp,4));
  pM = StringToInt(Mid(fpresp,4,2));
  pD = StringToInt(Mid(fpresp,6,2));

  if ((td.year==pY) and (td.month==pM) and (td.day==pD)) then begin
     res = noErr;
  end else begin
     MessageBox(0,USetStr(12402));
     MessageBox(0,USetStr(12403) & pY & pM & pD);
     MessageBox(0,USetStr(12404) & GetYear(td) & GetMonth(td) & GetDay(td));
     res = 12402;
  end;

LCheckST05Clock:;
  CheckST05Clock = res;
  return;
end;

function Integer LoadST05VATRate(string vatrate,var val vr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,response; 

  vr = blankval;
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & vatrate;  
  
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);


  if (res!=noErr) then begin
    res = 12405;
    goto LLoadST05VATRate;
  end;
  vr = BCD62ToVal(response);
LLoadST05VATRate:;
  LoadST05VATRate = res;
  return;
end;

function Integer LoadST05VATRates(vector val vatrates)
begin
  Integer res;
  val vr;
  
  res = LoadST05VATRate("01",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadST05VATRates;
  end;
  vatrates[0] = vr;
  res = LoadST05VATRate("03",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadST05VATRates;
  end;
  vatrates[1] = vr;
  res = LoadST05VATRate("05",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadST05VATRates;
  end;
  vatrates[2] = vr;
  res = LoadST05VATRate("07",vr);
  if (res!=0) then begin
    MessageBox(0,USetStr(res));
    goto LLoadST05VATRates;
  end;
  vatrates[3] = vr;
LLoadST05VATRates:;
  LoadST05VATRates = res;
  return;
end;

function string 255 ConvertST05String(string instr)
begin
  string 255 res,tstr;
  Integer i,l,a;
  
  l = len(instr);
  for (i=0;i<l;i=i+1) begin
    a = GetByteFromString(Mid(instr,i,1),0);
    tstr = Right(NumToHex(a),2);
    res = res & tstr;
  end;
  ConvertST05String = res;
  return;
end;

function Integer BeginFiscalReceipt()
begin
  INteger res,noErr;
  string 255 CtrlSeq; 
  
  CtrlSeq = "01";
  CtrlSeq = CtrlSeq & "00";
  res = ST05Write(CtrlSeq,ST05_DELAY);
     
LBeginFiscalReceipt:;
  BeginFiscalReceipt = res;
  return;
end;

function Integer FiscalReturnText()
begin
  INteger res,noErr;
  string 255 CtrlSeq; 
  
  CtrlSeq = "0C";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(22136)));
  CtrlSeq = CtrlSeq & "00";
  res = ST05Write(CtrlSeq,ST05_DELAY);
     
LFiscalReturnText:;
  FiscalReturnText = res;
  return;
end;

function string 255 GetST05VATCode(Integer InclVAT,string vatcode,vector val vatrates)
begin
  string 255 res;
  val vatprc,tax1;

  GetVATdouble(vatcode,vatprc,tax1,0);
  if (vatprc==vatrates[0]) then begin 
    res = "00"; 
    goto LGetST05VATCode;
  end;
  if (vatprc==vatrates[1]) then begin 
    res = "01"; 
    goto LGetST05VATCode;
  end;
  if (vatprc==vatrates[2]) then begin 
    res = "02"; 
    goto LGetST05VATCode;
  end;
  if (vatprc==vatrates[3]) then begin 
    res = "03"; 
    goto LGetST05VATCode;
  end;
LGetST05VATCode:;
  GetST05VATCode = res;
  return;
end;

function Integer DiscountAdditionForItem(record IVVc IVr,row IVVc IVrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  val t;

  CtrlSeq = "05";
  t = Round(IVrw.Quant*IVrw.Price - IVrw.Sum,SetRoundModeD(2));
  tstr = ValToString(t*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVrw.Price>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "03";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(1870)));
  CtrlSeq = CtrlSeq & "00";
  res = ST05Write(CtrlSeq,ST05_DELAY);  

  DiscountAdditionForItem = res;
  return;
end;

function Integer PrintRecItem(record IVVc IVr,row IVVc IVrw,vector val vatrates)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "02";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVrw.Spec));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(IVrw.Quant*1000,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVrw.Quant>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  tstr = ValToString(IVrw.Price*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVrw.Price>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
//  CtrlSeq = CtrlSeq & "00";
  CtrlSeq = CtrlSeq & GetST05VATCode(IVr.InclVAT,IVrw.VATCode,vatrates);

  res = ST05Write(CtrlSeq,ST05_DELAY);  
  if (res==noErr) then begin
    if (IVrw.vRebate!=0) then begin
      res = DiscountAdditionForItem(IVr,IVrw);
    end;
  end;
  PrintRecItem = res;
  return;
end;

function Integer PrintRecReturn(record IVVc IVr,row IVVc IVrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "0E";
//  tstr = ValToString(-IVrw.Quant,M4UVal,"","",0) & "x" & ValToString(IVrw.Price,M4UVal,"","",0);
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVrw.Spec));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(-IVrw.Sum*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (-IVrw.Quant>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "41";
  res = ST05Write(CtrlSeq,ST05_LONGDELAY);
  PrintRecReturn = res;
  return;
end;

function Integer PrintCommentLine(record IVVc IVr,row IVVc IVrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "0C";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVrw.Spec));
  CtrlSeq = CtrlSeq & "00";  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  PrintCommentLine = res;
  return;
end;

function Integer PrintItemRowsReturn(record IVVc IVr)
begin
  INteger res,noErr;
  row IVVc IVrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal1;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal1:;
        if (IVrw.ovst==0) then begin
          if (nonblank(IVrw.ArtCode)) then begin
            if (IVrw.Quant<0) then begin
              res = PrintRecReturn(IVr,IVrw);
            end;
            if (res!=noErr) then begin
              goto LPrintItemRowsReturn;
            end;
          end else begin
            res = PrintCommentLine(IVr,IVrw);
            if (res!=noErr) then begin
              goto LPrintItemRowsReturn;
            end;
          end;
        end;
    end;
  end;
LPrintItemRowsReturn:;  
  PrintItemRowsReturn = res;
  return;
end;

function Integer PrintItemRows(record IVVc IVr,vector val vatrates)
begin
  INteger res,noErr;
  row IVVc IVrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal2;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal2:;
        if (IVrw.ovst==0) then begin
          if (nonblank(IVrw.ArtCode)) then begin
            res = PrintRecItem(IVr,IVrw,vatrates);
            if (res!=noErr) then begin
              goto LPrintItemRows;
            end;
          end else begin
            res = PrintCommentLine(IVr,IVrw);
            if (res!=noErr) then begin
              goto LPrintItemRows;
            end;
          end;
        end;
      case kInvoiceRowTypeVoid:
//        res = PrintRecReturn(IVr,IVrw,vatrates);
//        if (res!=noErr) then begin
//          goto LPrintItemRows;
//        end;
    end;
  end;
LPrintItemRows:;  
  PrintItemRows = res;
  return;
end;

procedure CalculatePaymentModeSums(record IVVc IVr,vector val vpaymodesums)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
      LkInvoiceTypeCredit:;
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
    otherwise
      t = IVr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
      if (t>0) then begin
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
      end;
  end;
  return;
end;

function Integer EndFiscalReceiptReturn(record IVVc IVr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  vector val vpaymodesums;
  val v;

  CalculatePaymentModeSums(IVr,vpaymodesums);
  v = vpaymodesums[kInvoiceRowTypeCashPayment] + vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (v<0) then begin
    v = -v;
  end;
  CtrlSeq = "0E";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(22137)));

  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(v*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (v>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "47";
  res = ST05Write(CtrlSeq,ST05_LONGDELAY);
  EndFiscalReceiptReturn = res;
  return;
end;

function Integer EndFiscalReceipt(record IVVc IVr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  vector val vpaymodesums;

  CalculatePaymentModeSums(IVr,vpaymodesums);

  if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]==0.00) then begin
    CtrlSeq = "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20800)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCashPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCashPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & "00";
  end else begin

    CtrlSeq = "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20800)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCashPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCashPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;

    CtrlSeq =  CtrlSeq & "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20801)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & "00";
    
  end;

  res = ST05Write(CtrlSeq,ST05_LONGDELAY);

  EndFiscalReceipt = res;
  return;
end;

function Integer ST05Open(record LSerialPortDeviceVc LSPDr)
begin
  Integer res;
  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)) then begin
    SetComPortCodepage("CP1257");
    res = 0;
  end else begin
    res = 1;
  end;

  ST05Open = res;
  return;
end;

procedure ST05Close()
begin
  Integer res;

  res = CloseComPort(0);
  return;
end;

function Integer ValidateIVReceipt(record IVVc IVr,vector val vatrates)
begin
  Integer res;
  Integer i,rwcnt;
  row IVVc IVrw;
  string 255 tstr;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    tstr = GetST05VATCode(IVr.InclVAT,IVrw.VATCode,vatrates);
    if (blank(tstr)) then begin
      res = 1951;
      goto LValidateIVReceipt;
    end;
  end;
LValidateIVReceipt:;  
  ValidateIVReceipt = res;  
  return;
end;

function Boolean IV_TestReturn(record IVVc IVr)
begin
  Boolean res;
  row IVVc IVrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal3;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal3:;
        if (IVrw.ovst==0) then begin
          if (nonblank(IVrw.ArtCode)) then begin
            if (IVrw.Quant<0) then begin
              res = true;
              goto LIV_TestReturn;
            end;
          end;
        end;
    end;
  end;
LIV_TestReturn:;  
  IV_TestReturn = res;
  return;
end;

global
updating procedure PrintST05Receipt(var record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  record IVVc lIVr;
  record IVVc oldIVr;
  Integer noErr,res;
  vector val vatrates;
  val v;
  area a;
  string 255 response;
  Boolean sent;

  noErr = 0;


//goto LPrintST05Receipt;
/*
  res = ST05Open(LSPDr);
      ST05CancelReceipt;

  sent = OutComPort(0,chr(ST05_SOC));
  if (sent) then begin
    res = WaitForST05Reply(ST05_DELAY,true,response);
  end;
TRace("response " & response,"");
  if (res!=noErr) then begin
    goto LPrintST05Receipt;
  end;

    ST05Close;
goto LPrintST05Receipt;
*/

  res = ST05Open(LSPDr);
  if (res==noErr) then begin
    if (IV_TestReturn(IVr)) then begin
      res = FiscalReturnText;
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = PrintItemRowsReturn(IVr);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = FiscalReturnText;
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = EndFiscalReceiptReturn(IVr);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = EndNonFiscalReceipt;
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
    end else begin      
      noErr = 0;
      res = CheckST05Clock;
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = LoadST05VATRates(vatrates);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = ValidateIVReceipt(IVr,vatrates);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = BeginFiscalReceipt;
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = PrintItemRows(IVr,vatrates);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
      res = EndFiscalReceipt(IVr);
      if (res!=noErr) then begin
        goto LPrintST05Receipt;
      end;
  //    OpenCashDrawer;
      lIVr.SerNr = IVr.SerNr;
      if (ReadFirstMain(lIVr,1,true)) then begin
        if (lIVr.Prntdf==0) then begin
          RecordCopy(oldIVr,lIVr);
          lIVr.Prntdf = 1;
          RecordUpdate(oldIVr,lIVr,false);
        end;
      end;
    end;
LPrintST05Receipt:;
    ST05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

function Integer IVCash_DiscountAdditionForItem(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  val t;

  CtrlSeq = "05";
  t = Round(IVCashrw.Quant*IVCashrw.Price - IVCashrw.Sum,SetRoundModeD(2));
  tstr = ValToString(t*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVCashrw.Price>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "03";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(1870)));
  CtrlSeq = CtrlSeq & "00";
  res = ST05Write(CtrlSeq,ST05_DELAY);  

  IVCash_DiscountAdditionForItem = res;
  return;
end;

function Integer IVCash_PrintRecItem(record IVCashVc IVCashr,row IVCashVc IVCashrw,vector val vatrates)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "02";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVCashrw.Spec));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(IVCashrw.Quant*1000,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVCashrw.Quant>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  tstr = ValToString(IVCashrw.Price*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (IVCashrw.Price>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & GetST05VATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
//  CtrlSeq = CtrlSeq & "00";
  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  if (res==noErr) then begin
    if (nonblank(IVCashrw.vRebate)) then begin
      res = IVCash_DiscountAdditionForItem(IVCashr,IVCashrw);
    end;
  end;
  IVCash_PrintRecItem = res;
  return;
end;

function Integer IVCash_PrintRecReturn(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "0E";
//  tstr = ValToString(-IVCashrw.Quant,M4UVal,"","",0) & "x" & ValToString(IVCashrw.Price,M4UVal,"","",0);
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVCashrw.Spec));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(-IVCashrw.Sum*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (-IVCashrw.Quant>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "41";
  res = ST05Write(CtrlSeq,ST05_LONGDELAY);
  IVCash_PrintRecReturn = res;
  return;
end;

function Integer IVCash_PrintCommentLine(record IVCashVc IVCashr,row IVCashVc IVCashrw)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "0C";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",IVCashrw.Spec));
  CtrlSeq = CtrlSeq & "00";  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  IVCash_PrintCommentLine = res;
  return;
end;

function Integer IVCash_PrintItemRows(record IVCashVc IVCashr,vector val vatrates)
begin
  INteger res,noErr;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal4;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal4:;
        if (IVCashrw.ovst==0) then begin
          if (nonblank(IVCashrw.ArtCode)) then begin
            if (IVCashrw.Quant<0) then begin
              res = IVCash_PrintRecItem(IVCashr,IVCashrw,vatrates);
            end else begin
              res = IVCash_PrintRecItem(IVCashr,IVCashrw,vatrates);
            end;
            if (res!=noErr) then begin
              goto LIVCash_PrintItemRows;
            end;
          end else begin
            res = IVCash_PrintCommentLine(IVCashr,IVCashrw);
            if (res!=noErr) then begin
              goto LIVCash_PrintItemRows;
            end;
          end;
        end;
      case kInvoiceRowTypeVoid:
//        res = IVCash_PrintRecReturn(IVCashr,IVCashrw);
//        if (res!=noErr) then begin
//          goto LIVCash_PrintItemRows;
//        end;
    end;
  end;
LIVCash_PrintItemRows:;  
  IVCash_PrintItemRows = res;
  return;
end;

function Integer IVCash_PrintItemRowsReturn(record IVCashVc IVCashr)
begin
  INteger res,noErr;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal5;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal5:;
        if (IVCashrw.ovst==0) then begin
          if (nonblank(IVCashrw.ArtCode)) then begin
            if (IVCashrw.Quant<0) then begin
              res = IVCash_PrintRecReturn(IVCashr,IVCashrw);
            end;
            if (res!=noErr) then begin
              goto LIVCash_PrintItemRowsReturn;
            end;
          end else begin
            res = IVCash_PrintCommentLine(IVCashr,IVCashrw);
            if (res!=noErr) then begin
              goto LIVCash_PrintItemRowsReturn;
            end;
          end;
        end;
    end;
  end;
LIVCash_PrintItemRowsReturn:;  
  IVCash_PrintItemRowsReturn = res;
  return;
end;

procedure IVCash_CalculatePaymentModeSums(record IVCashVc IVCashr,vector val vpaymodesums)
begin
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  val t;
  
  vpaymodesums[kInvoiceRowTypeCreditCardPayment] = 0.00;
  vpaymodesums[kInvoiceRowTypeCashPayment] = 0.00;
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
//      case kInvoiceRowTypeGiftVoucherPayment:
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[kInvoiceRowTypeCreditCardPayment] = vpaymodesums[kInvoiceRowTypeCreditCardPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeLoyaltyPointsPayment:
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
//      case kInvoiceRowTypeChequePayment:
    end;
  end;
  t = IVCashr.BaseSum4 - vpaymodesums[kInvoiceRowTypeCashPayment] - vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (t>0) then begin
    vpaymodesums[kInvoiceRowTypeCashPayment] = vpaymodesums[kInvoiceRowTypeCashPayment] + t;  
  end;
  return;
end;

function Integer IVCash_EndFiscalReceiptReturn(record IVCashVc IVCashr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  vector val vpaymodesums;
  val v;

  IVCash_CalculatePaymentModeSums(IVCashr,vpaymodesums);
  v = vpaymodesums[kInvoiceRowTypeCashPayment] + vpaymodesums[kInvoiceRowTypeCreditCardPayment];
  if (v<0) then begin
    v = -v;
  end;
  CtrlSeq = "0E";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(22137)));

  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(v*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (v>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "47";
  res = ST05Write(CtrlSeq,ST05_LONGDELAY);
  IVCash_EndFiscalReceiptReturn = res;
  return;
end;

function Integer IVCash_EndFiscalReceipt(record IVCashVc IVCashr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  vector val vpaymodesums;

  IVCash_CalculatePaymentModeSums(IVCashr,vpaymodesums);
  if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]==0.00) then begin
    CtrlSeq = "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20800)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCashPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCashPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & "00";
  end else begin
    CtrlSeq = "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20800)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCashPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCashPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;

    CtrlSeq =  CtrlSeq & "03";
    CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",USetStr(20801)));
    CtrlSeq = CtrlSeq & "00";
    tstr = ValToString(vpaymodesums[kInvoiceRowTypeCreditCardPayment]*100,M4UVal,"","",0);
    M4PadString(tstr,11,"0",true,tstr);
    if (vpaymodesums[kInvoiceRowTypeCreditCardPayment]>0) then begin
      tstr = tstr & "C";
    end else begin
      tstr = tstr & "D";
    end;
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & "00";
  end;

  res = ST05Write(CtrlSeq,ST05_LONGDELAY);
  IVCash_EndFiscalReceipt = res;
  return;
end;

function Integer ValidateIVCashReceipt(record IVCashVc IVCashr,vector val vatrates)
begin
  Integer res;
  Integer i,rwcnt;
  row IVCashVc IVCashrw;
  string 255 tstr;
  
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    tstr = GetST05VATCode(IVCashr.InclVAT,IVCashrw.VATCode,vatrates);
    if (blank(tstr)) then begin
      res = 1951;
      goto LValidateIVCashReceipt;
    end;
  end;
LValidateIVCashReceipt:;  
  ValidateIVCashReceipt = res;  
  return;
end;

function Boolean IVCash_TestReturn(record IVCashVc IVCashr)
begin
  Boolean res;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal6;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal6:;
        if (IVCashrw.ovst==0) then begin
          if (nonblank(IVCashrw.ArtCode)) then begin
            if (IVCashrw.Quant<0) then begin
              res = true;
              goto LIVCash_TestReturn;
            end;
          end;
        end;
    end;
  end;
LIVCash_TestReturn:;  
  IVCash_TestReturn = res;
  return;
end;

global
updating procedure PrintST05IVCashReceipt(var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  record IVCashVc oldIVCashr;
  Integer noErr,res;
  vector val vatrates;
  val v;
  area a;
  string 255 response;
  Boolean sent;
  

  noErr = 0;
//goto LPrintST05Receipt;
/*
  res = ST05Open(LSPDr);
      ST05CancelReceipt;

  sent = OutComPort(0,chr(ST05_SOC));
  if (sent) then begin
    res = WaitForST05Reply(ST05_DELAY,true,response);
  end;
TRace("response " & response,"");
  if (res!=noErr) then begin
    goto LPrintST05Receipt;
  end;

    ST05Close;
goto LPrintST05Receipt;
*/

  res = ST05Open(LSPDr);
  if (res==noErr) then begin
    noErr = 0;
    res = CheckST05Clock;
    if (res!=noErr) then begin
      goto LPrintST05IVCashReceipt;
    end;
    res = LoadST05VATRates(vatrates);
    if (res!=noErr) then begin
      goto LPrintST05IVCashReceipt;
    end;
    res = ValidateIVCashReceipt(IVCashr,vatrates);
    if (res!=noErr) then begin
      goto LPrintST05IVCashReceipt;
    end;
    
    if (IVCash_TestReturn(IVCashr)) then begin
      res = FiscalReturnText;
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = IVCash_PrintItemRowsReturn(IVCashr);
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = FiscalReturnText;
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = IVCash_EndFiscalReceiptReturn(IVCashr);
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = EndNonFiscalReceipt;
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
    end else begin      
      res = BeginFiscalReceipt;
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = IVCash_PrintItemRows(IVCashr,vatrates);
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
      res = IVCash_EndFiscalReceipt(IVCashr);
      if (res!=noErr) then begin
        goto LPrintST05IVCashReceipt;
      end;
  //    OpenCashDrawer;
      if (IVCashr.Prntdf!=0) then begin
        RecordCopy(oldIVCashr,IVCashr);
        IVCashr.Prntdf = 1;
        RecordUpdate(oldIVCashr,IVCashr,false);
      end;
    end;
LPrintST05IVCashReceipt:;
    ST05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

function Integer MoneyOutCurr(record CashVc Cashr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
   
  CtrlSeq = "0E";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",Cashr.Comment));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(Cashr.Total*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (Cashr.Total>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "50";
  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  MoneyOutCurr = res;
  return;
end;

function Integer MoneyInCurr(record CashVc Cashr)
begin
  INteger res,noErr;
  string 255 CtrlSeq,tstr;
  
  CtrlSeq = "0E";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",Cashr.Comment));
  CtrlSeq = CtrlSeq & "00";
  tstr = ValToString(Cashr.Total*100,M4UVal,"","",0);
  M4PadString(tstr,11,"0",true,tstr);
  if (Cashr.Total>0) then begin
    tstr = tstr & "C";
  end else begin
    tstr = tstr & "D";
  end;
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "52";
  
  res = ST05Write(CtrlSeq,ST05_DELAY);  
  MoneyInCurr = res;
  return;
end;

global
procedure PrintST05CashEvent(var record CashVc Cashr,record LSerialPortDeviceVc LSPDr)
begin
  INteger res,noErr,err;
  string 255 CtrlSeq;
  
  noErr = 0;
  res = ST05Open(LSPDr);
  if (res==noErr) then begin
    noErr = 0;
    
    res = CheckST05Clock;
    if (res!=noErr) then begin
      goto LPrintST05CashEvent;
    end;
    switch (Cashr.Event) begin
      case 0:
        err = MoneyOutCurr(Cashr);
        if (res!=noErr) then begin
          goto LPrintST05CashEvent;
        end;
        EndNonFiscalReceipt;
      case 1:
        err = MoneyInCurr(Cashr);
        if (res!=noErr) then begin
          goto LPrintST05CashEvent;
        end;
        EndNonFiscalReceipt;
    end;
LPrintST05CashEvent:;
    ST05Close;
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  return;
end;

global
procedure SetPOSWindowDisplay_ST05(record LSerialPortDeviceVc LSPDr,string dispstr,string disp2str)
begin
  Integer res,noErr;
  string 255 CtrlSeq; 
  string 255 tstr;
  
  res = ST05Open(LSPDr);
  if (res!=noErr) then begin
    goto LSetPOSWindowDisplay_ST05;
  end;

  CtrlSeq = "0D";
  M4PadString(Left(dispstr,20),20," ",true,tstr);
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",tstr));
  M4PadString(Left(disp2str,20),20," ",true,tstr);
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",tstr));
  CtrlSeq = CtrlSeq & "00";

  res = ST05Write(CtrlSeq,ST05_DELAY); 
  ST05Close;
LSetPOSWindowDisplay_ST05:;  
  return;
end;

function Integer GetCopyOfReceipt(string fr,string to,var area aresponse)
begin
  Integer res,msglen,i;
  string 255 CtrlSeq,msglenhex;  

  SetAreaZeroSize(aresponse);

/*
  CtrlSeq = "2E";  
  CtrlSeq = CtrlSeq & "4E";  
  res = ST05WriteAndGetReceipt(CtrlSeq,ST05_LONGDELAY,aresponse);
Trace("response " & response,""); 
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;

  CtrlSeq = "2E";  
  CtrlSeq = CtrlSeq & "45";  
  res = ST05Write(CtrlSeq,ST05_DELAY); 
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
*/  
  GetCopyOfReceipt = res;
  return;
end;

function Integer ReadEJournal(record LSerialPortDeviceVc LSPDr)
begin
  Integer res,noErr;
  string 255 CtrlSeq,response,tstr,filename,filename2; 
  Integer l,nrofreceipts;
  record LocalMachineBlock LMb;
  Area aresponse;

  BlockLoad(LMb);
  if (blank(LMb.FiscalPrinterEJournalPath)) then begin
    goto LST05ReadEJournalOut;
  end;

  res = ST05Open(LSPDr);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
/*

#1895.


#130DF7.
#130DF7.
#131A0C.
#133165.

*/  
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & "0D";    
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & "0D";    
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & "1A";    
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  CtrlSeq = "13";
  CtrlSeq = CtrlSeq & "31";    
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;

  CtrlSeq = "30";  
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_LONGDELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  CtrlSeq = "33";  
  CtrlSeq = CtrlSeq & "01";  
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_LONGDELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  nrofreceipts = BCD62ToVal(response)*100;

/*
#30C6.
#330137.
*/
  
  filename = LMb.FiscalPrinterEJournalPath & "/" & DateToString(CurrentDate,"YYYYMMDD") & ".txt";
  CreateFile(filename);
  CloseFile;      
  if (nonblank(LMb.FiscalPrinterEJournalPath2)) then begin
    filename2 = LMb.FiscalPrinterEJournalPath2 & "/" & DateToString(CurrentDate,"YYYYMMDD") & ".txt";
    CreateFile(filename2);
    CloseFile;      
  end;

  for (l=1;l<=nrofreceipts;l=l+1) begin
    SetAreaZeroSize(aresponse);    
    res = GetCopyOfReceipt(l,l,aresponse);
    OutAreaToFile(aresponse,filename,1);
    if (nonblank(filename2)) then begin
      OutAreaToFile(aresponse,filename2,1);
    end;
  end;
  
  CtrlSeq = "27";
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  CtrlSeq = "1E";
  res = ST05WriteAndGetResponse(CtrlSeq,ST05_DELAY,response);
  if (res!=noErr) then begin
    goto LST05ReadEJournal;
  end;
  
/*
#2E4E24.
#2E45DC.
#2781.
#1E90.
*/
  
LST05ReadEJournal:;  
  ST05Close;
LST05ReadEJournalOut:;  
  ReadEJournal = res;
  return;
end;

global
procedure ST05DailyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,noErr;
  string 255 CtrlSeq; 

/*
  res = ReadEJournal(LSPDr);
  if (res!=noErr) then begin
    goto LST05DailyReport;
  end;
*/
  
  res = ST05Open(LSPDr);
  if (res!=noErr) then begin
    goto LST05DailyReport;
  end;

  CtrlSeq = "07";  
  res = ST05Write(CtrlSeq,ST05_DELAY); 
  ST05Close;
  

 LST05DailyReport:;  
  return;
end;

global
procedure ST05MonthlyReport(record LSerialPortDeviceVc LSPDr)
begin
  INteger res,noErr;
  string 255 CtrlSeq; 

  res = ST05Open(LSPDr);
  if (res!=noErr) then begin
    goto LST05MonthlyReport;
  end;
  
  CtrlSeq = "10";

  res = ST05Write(CtrlSeq,ST05_DELAY); 
  ST05Close;
 LST05MonthlyReport:;  
  return;
end;

global
procedure ST05PeriodicReport(record RcVc RepSpec,record LSerialPortDeviceVc LSPDr)
begin
  INteger res,msglen,noErr;
  string 255 CtrlSeq,msglenhex,response; 

  res = ST05Open(LSPDr);
  if (res!=noErr) then begin
    goto LST05PeriodicReport;
  end;
  
  CtrlSeq = "0B";
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",DateToString(RepSpec.d1,"YYYYMMDD"))); 
  CtrlSeq = CtrlSeq & "00";  
  CtrlSeq = CtrlSeq & ConvertST05String(ConvertStringToCodePage("CP1257",DateToString(RepSpec.d2,"YYYYMMDD"))); 
  CtrlSeq = CtrlSeq & "00";  
  
  res = ST05Write(CtrlSeq,ST05_DELAY); 
  ST05Close;
 LST05PeriodicReport:;  
  return;
end;
