external function val CalculateDiscountPercentage(val,val,val);
external procedure GetVATdouble(string,var val,var val,Integer);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure GetVATproc(string,Integer,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function LongInt POSNETHexToLong(string);
external function val FindVAT(string,val,Integer,Integer);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external function val GetStockQty(string,string,Date,Boolean);
external function string 255 NumToHex2(string,Integer);

enum begin
  EPSON_STX                 = 170, // 0xAA
  EPSON_STX2                = 85,  // 0x55
  EPSON_ADDR                = 0,
  EPSON_CHECK_DATE_AND_TIME = 62,  // 0x3E
  EPSON_OPEN_RECEIPT        = 45,  // 0x2D
  EPSON_PRINT_LINE          = 46,  // 0x2E
  EPSON_CLOSE_RECEIPT       = 47,  // 0x2F
  EPSON_SET_PLU             = 32,  // 0x20
  EPSON_READ_PLU            = 34,  // 0x22
  EPSON_CHANGE_PLU_PRICE    = 40,  // 0x28
  EPSON_GET_TAX_GROUPS      = 25,  // 0x19
  EPSON_VOID_RECEIPT        = 59,  // 0x3B
  EPSON_CHECK_STATUS        = 112, // 0x70
  EPSON_BUSY                = 113  // 0x71
end;

enum begin
  EPSON_PAYMENT_CASH = 9,
  EPSON_PAYMENT_CHEQUE = 10,
  EPSON_PAYMENT_CREDIT_CARD = 11
end;

function Integer HexToInt(string ch)
begin
  Integer res;
  
  switch (Left(ch,1)) begin
    case "0": res = 0;
    case "1": res = 1;
    case "2": res = 2;
    case "3": res = 3;
    case "4": res = 4;
    case "5": res = 5;
    case "6": res = 6;
    case "7": res = 7;
    case "8": res = 8;
    case "9": res = 9;
    case "A": res = 10;
    case "B": res = 11;
    case "C": res = 12;
    case "D": res = 13;
    case "E": res = 14;
    case "F": res = 15;
  end;
  
  HexToInt = res;
end;

function LongInt HexToLongInt(string s,Integer length)
begin
  LongInt res,multiplier;
  Integer i,l;
  
  res = 0;
  l = Len(s);
  if (length<l) then begin l = length; end;
  multiplier = 1;
  for (i=l-1;i>=0;i=i-1) begin
    res = res + HexToInt(Mid(s,i,1)) * multiplier;
    multiplier = multiplier * 16;
  end;
  
  HexToLongInt = res;
  return;
end;

function string 255 StringToHex(string s)
begin
  string 255 res;
  Integer i,cnt;
  
  cnt = Len(s);
  for (i=0;i<cnt;i=i+1) begin
    res = res & Asc(Mid(s,i,1)) & " ";
  end;
  
  StringToHex = res;
  return;
end;

procedure Add_ASC(var Array Integer aArray,var Integer aCount,Integer AscCode)
begin
  aArray[aCount] = AscCode;
  aCount = aCount + 1;
  return;
end;

procedure Add_CHR(var Array Integer aArray,var Integer aCount,string s)
begin
  Integer i,cnt;
  
  cnt = len(s);
  for (i=0;i<cnt;i=i+1) begin
    Add_ASC(aArray,aCount,Asc(Mid(s,i,1)));
  end;
  return;
end;

procedure Add_LONGINT(var Array Integer aArray,var Integer aCount,LongInt l,Integer bytes)
begin
  string 255 tstr;
  Integer i;
  
  tstr = NumToHex2(l,bytes*2);
  for (i=0;i<bytes;i=i+1) begin
    aArray[aCount] = HexToLongInt(Mid(tstr,i*2,2),2);
    aCount = aCount + 1;
  end;
  return;
end;

procedure Add_STR(var Array Integer aArray,var Integer aCount,string s,Integer length)
begin
  string 255 tstr;
  
  tstr = s;
  while (length>Len(tstr)) begin
    tstr = tstr & " ";
  end;
  if (length>Len(tstr)) then begin
    tstr = Left(tstr,length);
  end;
  Add_CHR(aArray,aCount,ConvertStringToCodePage("CP437",tstr));
  return;
end; 

procedure Add_VAL(var Array Integer aArray,var Integer aCount,val v,Integer decimals,Integer bytes)
begin
  Integer i;
  LongInt l;
  val t;
  
  t = v;
  for (i=0;i<decimals;i=i+1) begin
    t = t * 10;
  end;
  l = t;
  Add_LONGINT(aArray,aCount,l,bytes);
  return;
end;

function boolean Add_ArtCode(var Array Integer aArray,var Integer aCount,string artcode)
begin
  boolean res;
  Integer i;
  string 255 tstr;
  LongInt l;
  
  res = true;
  l = StringToLongInt(artcode);
  if (l>99999 or l<0) then begin
    res = false;
    goto LAdd_ArtCode;
  end;
  Add_LONGINT(aArray,aCount,l,4);
  
LAdd_ArtCode:;
  Add_ArtCode = res;
  return;
end;

function string 255 ArrayToStr(Array Integer aArray,Integer aCount)
begin
  string 255 res;
  Integer i;
  
  for (i=0;i<aCount;i=i+1) begin
    res = res & Chr(aArray[i]);
  end;
  
  ArrayToStr = res;
  return;
end;

procedure EpsonDisplayErrorMsg(Integer err,string msg)
begin
  MessageBox(err,msg);
  return;
end;

function Integer AddCmdSeq(var Integer cmdnr)
begin
  if (cmdnr<0 or cmdnr>=255) then begin
    cmdnr = 0;
  end else begin
    cmdnr = cmdnr + 1;
  end;
  AddCmdSeq = cmdnr;
  return;
end;

/*
function Integer ReplyInEpsonBuffer(var array Integer aReply,var Integer aReplyCount,Integer l)
begin
  Integer NoErr,i;
  
  for (i=0;i<l;i=i+1) begin
    aReply[aReplyCount] = GetByteFromString(ReadComPort(0,1),0);
    aReplyCount = aReplyCount + 1;
  end;
  ReplyInEpsonBuffer = NoErr;
  return;
end;
*/

function Integer OutComPortInteger(Integer EscSeq)
begin
  Integer res;
  
  res = OutComPort(0,Chr(EscSeq));
  OutComPortInteger = res;
  return;
end;

procedure ClearComPort()
begin
  string 1 c;
  
  c = ReadComPort(0,1);
  while (c!="") begin
    c = ReadComPort(0,1);
  end;
  
  return;
end;

/*
function Integer OutComPortArray(array Integer aEscSeq,Integer aCount)
BEGIN
  Integer res;
  Integer NoErr,i;
  
  ClearComPort;
  for (i=0;i<aCount;i=i+1) begin
    res = OutComPortInteger(aEscSeq[i]);
  end;
  if (res!=0) then begin
    res = NoErr;
  end else begin
    res = 1;
  end;
  OutComPortArray = res;
  RETURN;
END;
*/

function Integer OutComPortArray(array Integer aEscSeq,Integer aCount)
BEGIN
  Integer res;
  Integer NoErr,i;
  string 255 s;
  
  ClearComPort;
  for (i=0;i<aCount;i=i+1) begin
    s = s & chr(aEscSeq[i]);
  end;

  res = OutComPort(0,s);
  
  if (res!=0) then begin
    res = NoErr;
  end else begin
    res = 1;
  end;
  OutComPortArray = res;
  RETURN;
END;

function Integer WaitEpsonTime(var array Integer aReply,var Integer aReplyCount,Integer replylen)
begin
  Integer res;
  Integer NoErr;
  LongInt timeout;
  LongInt tickcount, starttick,currenttick;
  Boolean waitf;

  res = 12400;
  timeout = 800;
  starttick = GetCurTick;
  tickcount = starttick;
  if (replylen!=69) then begin
    aReplyCount = 0;
  end;
  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;
    
    aReply[aReplyCount] = GetByteFromString(ReadComPort(0,1),0);
    aReplyCount = aReplyCount + 1;

    if (aReplyCount>=replylen) or ((replylen==255) and (aReplyCount>0) or ((aReply[aReplyCount-1]==EPSON_CHECK_STATUS) and (replylen!=69)) ) then begin
      res = NoErr;
      waitf = false;
    end;
    
    if ((currenttick-starttick)>timeout) then begin
      waitf = false;
    end;
  end;
LWaitEpsonTime:;
  WaitEpsonTime = res;
  return;
end;

procedure SeqWithEpsonCheckSum(var array Integer aEscSeq,var Integer aCount)
begin
  Integer res,cc,i;
  
  for (i=2;i<aCount;i=i+1) begin
    cc = cc + aEscSeq[i];
  end;
  res = 256 - Mod(cc,256);
  if (res==256) then begin res = 0; end;
  Add_ASC(aEscSeq,aCount,res);
  return;
end;

procedure LogEpsonEscSeq(array Integer aEscSeq, Integer aCount)
begin
  string 255 tstr;
  Integer i;
  
  for (i=0;i<aCount;i=i+1) begin
    tstr = tstr & NumToHex2(aEscSeq[i],2) & " ";
  end;
  LogText(0,"LogEpsonEscSeq: " & tstr);
end;

procedure LogEpsonReply(array Integer aReply, Integer aReplyCount)
begin
  string 255 tstr;
  Integer i;
  
  for (i=0;i<aReplyCount;i=i+1) begin
    tstr = tstr & NumToHex2(aReply[i],2) & " ";
  end;
  LogText(0,"LogEpsonReply: " & tstr);
end;

procedure LogEpsonReplystr(string replystr)
begin
  string 255 tstr;
  Integer i,l;
  
  l = Len(replystr);
  for (i=0;i<l;i=i+1) begin
    tstr = tstr & NumToHex2(GetByteFromString(Mid(replystr,i,1),0),2) & " ";
  end;
  LogText(0,"LogEpsonReplystr: " & tstr);
end;

function Integer EpsonCheckStatus(var Integer cmdnr)
begin
  Integer res,NoErr,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_CHECK_STATUS);
  Add_ASC(aEscSeq,aCount,length);
  
  SeqWithEpsonCheckSum(aEscSeq,aCount);
//  LogEpsonEscSeq(aEscSeq,aCount);
  res = OutComPortArray(aEscSeq,aCount);
  if (res!=NoErr) then begin
    goto LEpsonCheckStatus;
  end;
  ReadComPort(0,1);
  
  res = WaitEpsonTime(aReply,aReplyCount,9);
LEpsonCheckStatus:;
  if (res==NoErr) then begin
//    ClearComPort;
//    LogEpsonReply(aReply,aReplyCount);
    res = aReply[4];
  end else begin
    res = 12400;
  end;
  
  EpsonCheckStatus = res;
  return;
end;

function Integer EpsonRetry(var array Integer aEscSeq,var Integer aCount,var Integer cmdnr,var array Integer aReply,var Integer aReplyCount,Integer replylen,Integer retrycnt,Boolean clearcomportf)
begin
  Integer res;
  Integer NoErr;
  Integer count;
  
  MilliSleep(200);
  count = 3;
  Add_ASC(aEscSeq,count,AddCmdSeq(cmdnr));
  aCount = aCount - 1;
  SeqWithEpsonCheckSum(aEscSeq,aCount);
//  LogEpsonEscSeq(aEscSeq,aCount);
  res = OutComPortArray(aEscSeq,aCount);
  if (res!=NoErr) then begin
    goto LEpsonRetry;
  end;
  ReadComPort(0,1);
  
  res = WaitEpsonTime(aReply,aReplyCount,replylen);
LEpsonRetry:;
  if (res==NoErr) then begin
    if (clearcomportf) then begin
      ClearComPort;
    end;
  end else begin
    EpsonDisplayErrorMsg(res,"");
  end;
//  LogEpsonReply(aReply,aReplyCount);
  
  if (aReply[4]==EPSON_BUSY) then begin
    if (retrycnt<3) then begin
      res = EpsonRetry(aEscSeq,aCount,cmdnr,aReply,aReplyCount,replylen,retrycnt+1,clearcomportf);
    end else begin
      res = 12400;
    end;
  end;
  
  EpsonRetry = res;
  return;
end;

function Integer EpsonWrite(var array Integer aEscSeq,var Integer aCount,var Integer cmdnr,var array Integer aReply,var Integer aReplyCount,Integer replylen,Boolean clearcomportf)
begin
  Integer res;
  Integer NoErr;
  
  res = EpsonCheckStatus(cmdnr);
  while (res!=112) begin // 112 = printer ready
    if (res!=EPSON_BUSY) then begin
      res = 12400;
      goto LEpsonWrite;
    end;
//    MilliSleep(20);
    res = EpsonCheckStatus(cmdnr);
  end;
  SeqWithEpsonCheckSum(aEscSeq,aCount);
//  LogEpsonEscSeq(aEscSeq,aCount);
  res = OutComPortArray(aEscSeq,aCount);
  if (res!=NoErr) then begin
    goto LEpsonWrite;
  end;
  ReadComPort(0,1);
  
  res = WaitEpsonTime(aReply,aReplyCount,replylen);
LEpsonWrite:;
  if (res==NoErr) then begin
    if (clearcomportf) then begin 
//      ClearComPort;//done in other place
    end;
  end else begin
    EpsonDisplayErrorMsg(res,"");
  end;
//  LogEpsonReply(aReply,aReplyCount);
  
  if (aReply[4]==EPSON_BUSY) then begin
    res = EpsonRetry(aEscSeq,aCount,cmdnr,aReply,aReplyCount,replylen,0,clearcomportf);
  end;
  
  EpsonWrite = res;
  return;
end;

procedure GetEpsonDate(array Integer aReply,var Integer year,var Integer month,var Integer day)
begin
  year = 2000 + StringToInt(NumToHex2(aReply[10],2));
  month = StringToInt(NumToHex2(aReply[9],2));
  day = StringToInt(NumToHex2(aReply[8],2));
  return;
end;

function val DownPaymentAmount(record IVVc IVr,Integer ordrow)
begin
  val res;
  row IVVc IVrw;
  Integer i,rwcnt;

  if (ordrow>=0) then begin
    rwcnt =  MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==5) then begin
        if (IVrw.OrdRow==ordrow) then begin
          res = res + IVrw.Sum;
        end;
      end;
    end;
  end;
  DownPaymentAmount = res;
  RETURN;
END;

function Integer EpsonOpen(record LSerialPortDeviceVc LSPDr)
begin
  Integer res;
  
  res = OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);
  EpsonOpen = res;
  return;
end;

procedure EpsonClose()
begin
  Integer res;

  res = CloseComPort(0);
  return;
end;

function Integer EpsonGetVATGroupNew(string vatcode,array val aVATGroups)
begin
  val vatprc,tax1;
  Integer res,i;

  res = -1;
  GetVATdouble(vatcode,vatprc,tax1,0);
  for (i=0;i<4;i=i+1) begin
    if (vatprc==aVATGroups[i]) then begin
      res = i + 1;
      goto LEpsonGetVATGroupNew;
    end;
  end;
LEpsonGetVATGroupNew:;  
  EpsonGetVATGroupNew = res;
  return;
end;

function Integer EpsonGetVATGroup(string vatcode,var Integer cmdnr)
begin
  Integer res,NoErr,i,rwcnt,length;
  record VATCodeBlock VATCodeb;
  row VATCodeBlock VATCoderw;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  boolean foundf;
  array val aVATGroups;
  
  res = -1;
  
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_GET_TAX_GROUPS);
  Add_ASC(aEscSeq,aCount,length);
  if (EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,19,true)!=NoErr) then begin
    goto LEpsonGetVATGroup;
  end;
  
  for (i=0;i<4;i=i+1) begin
    aVATGroups[i] = (aReply[6+i*2] * 256 + aReply[7+i*2]) / 100;
  end;
  
  BlockLoad(VATCodeb);
  rwcnt = MatRowCnt(VATCodeb);
  foundf = false;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATCodeb,i,VATCoderw);
    if (VATCoderw.VATCode==vatcode) then begin
      foundf = true;
      i = rwcnt;
    end;
  end;
  if (foundf==false) then begin
    goto LEpsonGetVATGroup;
  end;
  for (i=0;i<4;i=i+1) begin
    if (VATCoderw.ExVatpr==aVATGroups[i]) then begin
      res = i + 1;
      i = 4;
    end;
  end;
  
LEpsonGetVATGroup:;
  EpsonGetVATGroup = res;
  return;
end;

function Integer EpsonReadVATGroups(var Integer cmdnr,var array val aVATGroups)
begin
  Integer res,NoErr,i,rwcnt,length;
  record VATCodeBlock VATCodeb;
  row VATCodeBlock VATCoderw;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  boolean foundf;
  
  res = NoErr;
  
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_GET_TAX_GROUPS);
  Add_ASC(aEscSeq,aCount,length);
  if (EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,19,true)!=NoErr) then begin
    res = 1;
    goto LEpsonReadVATGroups;
  end;
  
  for (i=0;i<4;i=i+1) begin
    aVATGroups[i] = (aReply[6+i*2] * 256 + aReply[7+i*2]) / 100;
  end;   
LEpsonReadVATGroups:;
  EpsonReadVATGroups = res;
  return;
end;

function Integer EpsonCheckClock(date transdate,var Integer cmdnr)
begin
  Integer res,length;
  Date td;
  Integer pY,pM,pD;
  Integer NoErr;
  string 255 msg;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  td = CurrentDate;
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_CHECK_DATE_AND_TIME);
  Add_ASC(aEscSeq,aCount,length);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,15,true);
  GetEpsonDate(areply,pY,pM,pD);
  if ((GetYear(td)==pY) and (GetMonth(td)==pM) and (GetDay(td)==pD)) then begin
    res = NoErr;
  end else begin
    msg = USetStr(12402);
    msg = msg & chr(10) & USetStr(12403) & pY & pM & pD;
    msg = msg & chr(10) & USetStr(12404) & GetYear(td) & GetMonth(td) & GetDay(td);
    res = 1;
  end;
  td.year = pY;
  td.month = pM;
  td.day = pD;
  if (td==transdate) then begin
    res = NoErr;
  end else begin
    msg = msg & chr(10) & USetStr(20852) & " " & transdate & " " & USetStr(12403) & " " & td;
    res = 1;
  end;
LEpsonCheckClock:;
  if (NonBlank(msg)) then begin
    EpsonDisplayErrorMsg(0,msg);
  end;
  EpsonCheckClock = res;
  return;
end;

function Integer EpsonOpenFiscalReceipt(string cucode,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  string 255 tstr;
  record CUVc CUr;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  CUr.Code = cucode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_OPEN_RECEIPT);
  Add_ASC(aEscSeq,aCount,length);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,9,true);
  
  EpsonOpenFiscalReceipt = res;
  return;
end;

function Integer EpsonChangePluPrice(string artcode,val price,boolean setinstock,val instock,var Integer cmdnr)
begin
  Integer res,NoErr,length,i;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 13;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_CHANGE_PLU_PRICE);
  Add_ASC(aEscSeq,aCount,length);
  if (Add_ArtCode(aEscSeq,aCount,artcode)==false) then begin
    res = 2;
    goto LEpsonChangePluPrice;
  end;
  Add_VAL(aEscSeq,aCount,price,2,4);
  if (setinstock) then begin
    Add_ASC(aEscSeq,aCount,2);
  end else begin
    Add_ASC(aEscSeq,aCount,0);
  end;
  Add_VAL(aEscSeq,aCount,instock,3,4);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,9,true);
  
LEpsonChangePluPrice:;
  EpsonChangePluPrice = res;
  return;
end;

function Integer EpsonReadPlu(string artcode,var string artname,var val price,var val instock,var Integer vatgroup,var Integer cmdnr)
begin
  Integer res,NoErr,i,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  string 255 tstr;
  
  length = 4;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_READ_PLU);
  Add_ASC(aEscSeq,aCount,length);
  if (Add_ArtCode(aEscSeq,aCount,artcode)==false) then begin
    res = 2;
    goto LEpsonReadPlu;
  end;
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,9,false);
  if (res!=NoErr) then begin
    goto LEpsonReadPlu;
  end;
  if (aReply[5]==2 and aReply[6]==0 and aReply[7]==0) then begin
    res = 3;
    goto LEpsonReadPlu;
  end;
  if (aReplyCount<69) then begin
    res = WaitEpsonTime(aReply,aReplyCount,69);
    if (res!=NoErr) then begin
      goto LEpsonReadPlu;
    end;
  end;
  
  tstr = NumToHex2(aReply[19],2) & NumToHex2(aReply[20],2) & NumToHex2(aReply[21],2) & NumToHex2(aReply[22],2);
  price = HexToLongInt(tstr,8);

  
/* 
  price = aReply[22];
  for(i=1;i<4;i=i+1) begin
    price = price + aReply[22-i] * i * 16;
  end;
*/  
  price = price / 100;

  vatgroup = aReply[23];
  artname = "";
  for(i=24;i<64;i=i+1) begin
    artname = artname & Chr(aReply[i]);
  end;
/*  
  instock = aReply[67];
  for(i=1;i<4;i=i+1) begin
    instock = instock + aReply[67-i] * i * 16;
  end;
*/  
  tstr = NumToHex2(aReply[64],2) & NumToHex2(aReply[65],2) & NumToHex2(aReply[66],2) & NumToHex2(aReply[67],2);
  instock = HexToLongInt(tstr,8);
  instock = instock / 1000;
  
LEpsonReadPlu:;
//  ClearComPort;
  EpsonReadPlu = res;
  return;
end;

function Integer EpsonSetPlu(string artcode,string artname,val price,val instock,Integer vatgroup,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 53;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_SET_PLU);
  Add_ASC(aEscSeq,aCount,length);
  if (Add_ArtCode(aEscSeq,aCount,artcode)==false) then begin
    res = 2;
    goto LEpsonSetPlu;
  end;
  Add_VAL(aEscSeq,aCount,price,2,4);
  Add_ASC(aEscSeq,aCount,vatgroup);
  Add_STR(aEscSeq,aCount,artname,40);
  Add_VAL(aEscSeq,aCount,instock,3,4);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,13,true);
  
LEpsonSetPlu:;
  EpsonSetPlu = res;
  return;
end;

function Integer EpsonPrintInvoiceLineDiscount(val discount,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 5;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_PRINT_LINE);
  Add_ASC(aEscSeq,aCount,length);
  if (discount<0) then begin
    Add_ASC(aEscSeq,aCount,5);
    Add_VAL(aEscSeq,aCount,discount*-1,2,4);
  end else begin
    Add_ASC(aEscSeq,aCount,6);
    Add_VAL(aEscSeq,aCount,discount,2,4);
  end;
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,11,true);
  
  EpsonPrintInvoiceLineDiscount = res;
  return;
end;

function Integer EpsonPrintInvoiceLines(record IVVc IVr,array val aVATGroups,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  record INVc INr;
  Integer i,rwcnt;
  row IVVc IVrw;
  string 255 tstr;
  val downpay,t,t1;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  string 255 artname;
  val price,price2,instock,instock2;
  Integer vatgroup,vatgroup2;

//  if (IVr.InclVAT!=0) then begin          // This needs a better way to prevent. Zimbabwe requires invoice including of VAT to be printed.
//    res = 2;
//    goto LEpsonPrintInvoiceLines;
//  end;
  rwcnt =  MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (blank(IVrw.ArtCode)) then begin
      goto LSKIPROW;
    end;
    INr.Code = IVrw.ArtCode;
    if (ReadFirstMain(INr,1,true)==false) then begin
      goto LSKIPROW;
    end;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
      otherwise 
        goto LSKIPROW;
    end;
    MulVATIV(INr.VATCode,INr.UPrice1,t,t1,IVr.InclVAT,IVr.NoTAXonVAT);
    if (IVr.InclVAT!=0) then begin 
      price = INr.UPrice1;
    end else begin
      price = INr.UPrice1 + t + t1;
    end; 
    instock = GetStockQty(INr.Code,IVr.Location,CurrentDate,false);
    if (INr.VATCode!=IVrw.VATCode) then begin
      res = 2;
      goto LEpsonPrintInvoiceLines;
    end;
//    vatgroup = EpsonGetVATGroup(INr.VATCode,cmdnr);
    vatgroup = EpsonGetVATGroupNew(INr.VATCode,aVATGroups);
    if (vatgroup==-1) then begin
      res = 2;
      goto LEpsonPrintInvoiceLines;
    end;
    aCount = 0;
    res = EpsonReadPlu(INr.Code,artname,price2,instock2,vatgroup2,cmdnr);
    switch (res) begin
      case 0:
        tstr = INr.Name;
        while(Len(tstr)<40) begin
          tstr = tstr & " ";
        end;
        if (Len(tstr)>40) then begin
          tstr = Left(tstr,40);
        end;
        if (artname!=tstr or vatgroup!=vatgroup2) then begin
          res = EpsonSetPlu(INr.Code,INr.Name,price,instock,vatgroup,cmdnr);
          if (res!=NoErr) then begin
            goto LEpsonPrintInvoiceLines;
          end;
        end else begin
//          if (price!=price2 or instock!=instock2) then begin
          if (price!=price2) then begin
            res = EpsonChangePluPrice(INr.Code,price,instock!=instock2,instock,cmdnr);
            if (res!=NoErr) then begin
              goto LEpsonPrintInvoiceLines;
            end;
          end;
        end;
      case 2: goto LEpsonPrintInvoiceLines; // ArtCode is too long
      case 3:
        res = EpsonSetPlu(INr.Code,INr.Name,price,instock,vatgroup,cmdnr);
        if (res!=NoErr) then begin
          goto LEpsonPrintInvoiceLines;
        end;
    end;
    MulVATIV(IVrw.VATCode,IVrw.Price,t,t1,IVr.InclVAT,IVr.NoTAXonVAT);
    if (IVr.InclVAT!=0) then begin 
      price2 = Price; 
    end else begin
      price2 = Price + t + t1; 
    end;    
    if (price==price2) then begin
      length = 9;
    end else begin
      length = 15;
    end;
    Add_ASC(aEscSeq,aCount,EPSON_STX);
    Add_ASC(aEscSeq,aCount,EPSON_STX2);
    Add_ASC(aEscSeq,aCount,EPSON_ADDR);
    Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
    Add_ASC(aEscSeq,aCount,EPSON_PRINT_LINE);
    Add_ASC(aEscSeq,aCount,length);
    Add_ASC(aEscSeq,aCount,2);
    if (Add_ArtCode(aEscSeq,aCount,INr.Code)==false) then begin
      res = 2;
      goto LEpsonPrintInvoiceLines;
    end;
    Add_VAL(aEscSeq,aCount,IVrw.Quant,3,4);
    if (IVrw.Price!=INr.UPrice1) then begin
      Add_ASC(aEscSeq,aCount,0);
      Add_ASC(aEscSeq,aCount,0);
      Add_VAL(aEscSeq,aCount,price2,2,4);
    end;
    res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,11,true);
    if (res!=NoErr) then begin
      goto LEpsonPrintInvoiceLines;
    end;
    if (IVrw.vRebate!=0) then begin
      res = EpsonPrintInvoiceLineDiscount(IVrw.vRebate,cmdnr);
      if (res!=NoErr) then begin
        goto LEpsonPrintInvoiceLines;
      end;
    end;
LSKIPROW:;
  end;
LEpsonPrintInvoiceLines:;
  EpsonPrintInvoiceLines = res;
  return;
end;

function Integer EpsonTotalCancel(var Integer cmdnr)
begin
  Integer res,NoErr,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_VOID_RECEIPT);
  Add_ASC(aEscSeq,aCount,length);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,11,true);
  
  EpsonTotalCancel = res;
  return;
end;

function integer IVVc_CalculatePaymentModeSums(record IVVc IVr,var vector val vpaymodesums)
begin
  integer res;
  row IVVc IVrw;
  Integer i,rwcnt;
  val sum,v;
  record BaseCurBlock BCb;
  
  res = 0;
  BlockLoad(BCb);
  vpaymodesums[EPSON_PAYMENT_CASH] = 0.00;
  vpaymodesums[EPSON_PAYMENT_CHEQUE] = 0.00;
  vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] = 0.00;
  sum = IVr.Sum4;
/*
  if (IVr.CurncyCode!="USD") then begin
    if (BCb.BaseCur1=="USD") then begin
      sum = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    end else begin
      if (BCb.BaseCur2=="USD") then begin
        sum = MulRateToBase2(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
      end else begin
        errstr = USetStr(28351);
        res = 1;
        goto LIVVc_CalculatePaymentModeSums;
      end;
    end;
  end;
*/
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    v = 0.00;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeCreditCardPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeCashPayment:
        v = IVrw.Sum;
      case kInvoiceRowTypeChequePayment:
        v = IVrw.Sum;
      otherwise
        goto LIVVc_SkipRow;
    end;
/*
    if (IVrw.CurncyCode!="USD") then begin
      if (BCb.BaseCur1=="USD") then begin
        v = MulRateToBase1(IVrw.CurncyCode,v,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
      end else begin
        if (BCb.BaseCur2=="USD") then begin
          v = MulRateToBase2(IVrw.CurncyCode,v,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        end else begin
          errstr = USetStr(28351);
          res = 1;
          goto LIVVc_CalculatePaymentModeSums;
        end;
      end;
    end;
*/
    switch (IVrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] = vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] + v;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeChequePayment:
        vpaymodesums[EPSON_PAYMENT_CHEQUE] = vpaymodesums[EPSON_PAYMENT_CHEQUE] + v;
      otherwise
        goto LIVVc_SkipRow;
    end;
LIVVc_SkipRow:;
  end;
  v = sum - vpaymodesums[EPSON_PAYMENT_CASH] - vpaymodesums[EPSON_PAYMENT_CHEQUE] - vpaymodesums[EPSON_PAYMENT_CREDIT_CARD];
  if (v>0) then begin
    vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
  end;
  
LIVVc_CalculatePaymentModeSums:;
  IVVc_CalculatePaymentModeSums = res;
  return;
end;

function integer EpsonPrintPaymentLine(Integer paymentmode,val sum,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 6;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_PRINT_LINE);
  Add_ASC(aEscSeq,aCount,length);
  Add_ASC(aEscSeq,aCount,paymentmode);
  Add_ASC(aEscSeq,aCount,0);
  Add_VAL(aEscSeq,aCount,sum,2,4);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,11,true);
  
  EpsonPrintPaymentLine = res;
  return;
end;

function Integer EpsonTotalTender(record IVVc IVr,var Integer cmdnr)
begin
  Integer res,NoErr;
  vector val vpaymodesums;
  
  IVVc_CalculatePaymentModeSums(IVr,vpaymodesums);
  
  if (vpaymodesums[EPSON_PAYMENT_CASH]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CASH,vpaymodesums[EPSON_PAYMENT_CASH],cmdnr);
    if (res!=NoErr) then begin
      goto LEpsonTotalTender;
    end;
  end;
  
  if (vpaymodesums[EPSON_PAYMENT_CHEQUE]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CHEQUE,vpaymodesums[EPSON_PAYMENT_CHEQUE],cmdnr);
    if (res!=NoErr) then begin
      goto LEpsonTotalTender;
    end;
  end;
  
  if (vpaymodesums[EPSON_PAYMENT_CREDIT_CARD]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CREDIT_CARD,vpaymodesums[EPSON_PAYMENT_CREDIT_CARD],cmdnr);
    if (res!=NoErr) then begin
      goto LEpsonTotalTender;
    end;
  end;
  
LEpsonTotalTender:;
  EpsonTotalTender = res;
  return;
end;

function Integer EpsonCloseFiscalReceipt(var Integer cmdnr)
begin
  Integer res,NoErr,length;
  string 255 tstr;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  
  length = 0;
  Add_ASC(aEscSeq,aCount,EPSON_STX);
  Add_ASC(aEscSeq,aCount,EPSON_STX2);
  Add_ASC(aEscSeq,aCount,EPSON_ADDR);
  Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
  Add_ASC(aEscSeq,aCount,EPSON_CLOSE_RECEIPT);
  Add_ASC(aEscSeq,aCount,length);
  res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,9,true);
  
  EpsonCloseFiscalReceipt = res;
  return;
end;

global
updating procedure PrintEpsonTMTReceipt(var record IVVc aIVr,record LSerialPortDeviceVc LSPDr)
begin
  record IVVc IVr;
  record IVVc oldIVr;
  Integer NoErr,res;
  Integer cmdnr;
  array val aVATGroups;
    
  if (blank(LSPDr.Port)) then begin
    LSPDr.Port = "COM1";
  end;  
  NoErr = 1;
  res = EpsonOpen(LSPDr);
  if (res==NoErr) then begin
    NoErr = 0;
    cmdnr = 0;
    res = EpsonCheckClock(IVr.TransDate,cmdnr);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    res = EpsonReadVATGroups(cmdnr,aVATGroups);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    res = EpsonOpenFiscalReceipt(IVr.CustCode,cmdnr);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    res = EpsonPrintInvoiceLines(IVr,aVATGroups,cmdnr);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    res = EpsonTotalTender(IVr,cmdnr);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    res = EpsonCloseFiscalReceipt(cmdnr);
    if (res!=NoErr) then begin goto LPrintEpsonReceipt; end;
    IVr.SerNr = aIVr.SerNr;
    if (ReadFirstMain(IVr,1,true)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.Prntdf = 1;
      RecordUpdate(oldIVr,IVr,false);
    end;
LPrintEpsonReceipt:;
    if (res!=NoErr) then begin
      EpsonTotalCancel(cmdnr);
    end;
    EpsonClose;
  end;
  return;
end;

function Integer IVCashVc_EpsonPrintInvoiceLines(record IVCashVc IVCashr,array val aVATGroups,var Integer cmdnr)
begin
  Integer res,NoErr,length;
  record INVc INr;
  Integer i,rwcnt;
  row IVCashVc IVCashrw;
  string 255 tstr;
  val downpay,t,t1;
  array Integer aEscSeq;
  Integer aCount;
  array Integer aReply;
  Integer aReplyCount;
  string 255 artname;
  val price,price2,instock,instock2;
  Integer vatgroup,vatgroup2;

//  if (IVCashr.InclVAT!=0) then begin            // This needs a better way to prevent. Zimbabwe requires invoice including of VAT to be printed.
//    res = 2;
//    goto LIVCashVc_EpsonPrintInvoiceLines;
//  end;
  rwcnt =  MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    if (blank(IVCashrw.ArtCode)) then begin
      goto LSKIPROW;
    end;
    INr.Code = IVCashrw.ArtCode;
    if (ReadFirstMain(INr,1,true)==false) then begin
      goto LSKIPROW;
    end;
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
      otherwise 
        goto LSKIPROW;
    end;
    MulVATIV(INr.VATCode,INr.UPrice1,t,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
    if (IVCashr.InclVAT!=0) then begin 
      price = INr.UPrice1;
    end else begin
      price = INr.UPrice1 + t + t1;
    end; 
    instock = GetStockQty(INr.Code,IVCashr.Location,CurrentDate,false);
    if (INr.VATCode!=IVCashrw.VATCode) then begin
      res = 2;
      goto LIVCashVc_EpsonPrintInvoiceLines;
    end;
//    vatgroup = EpsonGetVATGroup(INr.VATCode,cmdnr);
    vatgroup = EpsonGetVATGroupNew(INr.VATCode,aVATGroups);
    if (vatgroup==-1) then begin
      res = 2;
      goto LIVCashVc_EpsonPrintInvoiceLines;
    end;
    aCount = 0;
    res = EpsonReadPlu(INr.Code,artname,price2,instock2,vatgroup2,cmdnr);
    switch (res) begin
      case 0:
        tstr = INr.Name;
        while(Len(tstr)<40) begin
          tstr = tstr & " ";
        end;
        if (Len(tstr)>40) then begin
          tstr = Left(tstr,40);
        end;
        if (artname!=tstr or vatgroup!=vatgroup2) then begin
          res = EpsonSetPlu(INr.Code,INr.Name,price,instock,vatgroup,cmdnr);
          if (res!=NoErr) then begin
            goto LIVCashVc_EpsonPrintInvoiceLines;
          end;
        end else begin
//          if (price!=price2 or instock!=instock2) then begin
          if (price!=price2) then begin
            res = EpsonChangePluPrice(INr.Code,price,instock!=instock2,instock,cmdnr);
            if (res!=NoErr) then begin
              goto LIVCashVc_EpsonPrintInvoiceLines;
            end;
          end;
        end;
      case 2: goto LIVCashVc_EpsonPrintInvoiceLines; // ArtCode is too long
      case 3:
        res = EpsonSetPlu(INr.Code,INr.Name,price,instock,vatgroup,cmdnr);
        if (res!=NoErr) then begin
          goto LIVCashVc_EpsonPrintInvoiceLines;
        end;
    end;
    MulVATIV(IVCashrw.VATCode,IVCashrw.Price,t,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
    if (IVCashr.InclVAT!=0) then begin 
      price2 = Price; 
    end else begin
      price2 = IVCashrw.Price + t + t1; 
    end;      
    if (price==price2) then begin
      length = 9;
    end else begin
      length = 15;
    end;
    Add_ASC(aEscSeq,aCount,EPSON_STX);
    Add_ASC(aEscSeq,aCount,EPSON_STX2);
    Add_ASC(aEscSeq,aCount,EPSON_ADDR);
    Add_ASC(aEscSeq,aCount,AddCmdSeq(cmdnr));
    Add_ASC(aEscSeq,aCount,EPSON_PRINT_LINE);
    Add_ASC(aEscSeq,aCount,length);
    Add_ASC(aEscSeq,aCount,2);
    if (Add_ArtCode(aEscSeq,aCount,INr.Code)==false) then begin
      res = 2;
      goto LIVCashVc_EpsonPrintInvoiceLines;
    end;
    Add_VAL(aEscSeq,aCount,IVCashrw.Quant,3,4);
    if (IVCashrw.Price!=INr.UPrice1) then begin
      Add_ASC(aEscSeq,aCount,0);
      Add_ASC(aEscSeq,aCount,0);
      Add_VAL(aEscSeq,aCount,price2,2,4);
    end;
    res = EpsonWrite(aEscSeq,aCount,cmdnr,aReply,aReplyCount,11,true);
    if (res!=NoErr) then begin
      goto LIVCashVc_EpsonPrintInvoiceLines;
    end;

    if (nonblank(IVCashrw.vRebate)) then begin
      res = EpsonPrintInvoiceLineDiscount(CalculateDiscountPercentage(IVCashrw.Quant,IVCashrw.Price,IVCashrw.Sum),cmdnr);
      if (res!=NoErr) then begin
        goto LIVCashVc_EpsonPrintInvoiceLines;
      end;
    end;
LSKIPROW:;
  end;
LIVCashVc_EpsonPrintInvoiceLines:;
  IVCashVc_EpsonPrintInvoiceLines = res;
  return;
end;

function integer IVCashVc_CalculatePaymentModeSums(record IVCashVc IVCashr,var vector val vpaymodesums)
begin
  integer res;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  val sum,v;
  record BaseCurBlock BCb;
  
  res = 0;
  BlockLoad(BCb);
  vpaymodesums[EPSON_PAYMENT_CASH] = 0.00;
  vpaymodesums[EPSON_PAYMENT_CHEQUE] = 0.00;
  vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] = 0.00;
  sum = IVCashr.Sum4;
/*
  if (IVCashr.CurncyCode!="USD") then begin
    if (BCb.BaseCur1=="USD") then begin
      sum = MulRateToBase1(IVCashr.CurncyCode,sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
    end else begin
      if (BCb.BaseCur2=="USD") then begin
        sum = MulRateToBase2(IVCashr.CurncyCode,sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCahsr.BaseRate2,DefaultCurRoundOff);
      end else begin
        errstr = USetStr(28351);
        res = 1;
        goto LIVCashVc_CalculatePaymentModeSums;
      end;
    end;
  end;
*/
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    v = 0.00;
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeCreditCardPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeCashPayment:
        v = IVCashrw.Sum;
      case kInvoiceRowTypeChequePayment:
        v = IVCashrw.Sum;
      otherwise
        goto LIVCashVc_SkipRow;
    end;
/*
    if (IVCashrw.CurncyCode!="USD") then begin
      if (BCb.BaseCur1=="USD") then begin
        v = MulRateToBase1(IVCashrw.CurncyCode,v,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
      end else begin
        if (BCb.BaseCur2=="USD") then begin
          v = MulRateToBase2(IVCashrw.CurncyCode,v,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        end else begin
          errstr = USetStr(28351);
          res = 1;
          goto LIVCashVc_CalculatePaymentModeSums;
        end;
      end;
    end;
*/
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeGiftVoucherPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCreditCardPayment:
        vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] = vpaymodesums[EPSON_PAYMENT_CREDIT_CARD] + v;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeCashPayment:
        vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
      case kInvoiceRowTypeChequePayment:
        vpaymodesums[EPSON_PAYMENT_CHEQUE] = vpaymodesums[EPSON_PAYMENT_CHEQUE] + v;
      otherwise
        goto LIVCashVc_SkipRow;
    end;
LIVCashVc_SkipRow:;
  end;
  v = sum - vpaymodesums[EPSON_PAYMENT_CASH] - vpaymodesums[EPSON_PAYMENT_CHEQUE] - vpaymodesums[EPSON_PAYMENT_CREDIT_CARD];
  if (v>0) then begin
    vpaymodesums[EPSON_PAYMENT_CASH] = vpaymodesums[EPSON_PAYMENT_CASH] + v;
  end;
  
LIVCashVc_CalculatePaymentModeSums:;
  IVCashVc_CalculatePaymentModeSums = res;
  return;
end;

function Integer IVCashVc_EpsonTotalTender(record IVCashVc IVCashr,var Integer cmdnr)
begin
  Integer res,NoErr;
  vector val vpaymodesums;
  
  IVCashVc_CalculatePaymentModeSums(IVCashr,vpaymodesums);
  
  if (vpaymodesums[EPSON_PAYMENT_CASH]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CASH,vpaymodesums[EPSON_PAYMENT_CASH],cmdnr);
    if (res!=NoErr) then begin
      goto LIVCashVc_EpsonTotalTender;
    end;
  end;
  
  if (vpaymodesums[EPSON_PAYMENT_CHEQUE]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CHEQUE,vpaymodesums[EPSON_PAYMENT_CHEQUE],cmdnr);
    if (res!=NoErr) then begin
      goto LIVCashVc_EpsonTotalTender;
    end;
  end;
  
  if (vpaymodesums[EPSON_PAYMENT_CREDIT_CARD]!=0) then begin
    res = EpsonPrintPaymentLine(EPSON_PAYMENT_CREDIT_CARD,vpaymodesums[EPSON_PAYMENT_CREDIT_CARD],cmdnr);
    if (res!=NoErr) then begin
      goto LIVCashVc_EpsonTotalTender;
    end;
  end;
  
LIVCashVc_EpsonTotalTender:;
  IVCashVc_EpsonTotalTender = res;
  return;
end;

global
updating procedure IVCashVc_PrintEpsonTMTReceipt(var record IVCashVc IVCashr,record LSerialPortDeviceVc LSPDr)
begin
  record IVCashVc oldIVCashr;
  Integer NoErr,res;
  Integer cmdnr;
  array val aVATGroups;
    
  if (blank(LSPDr.Port)) then begin
    LSPDr.Port = "COM1";
  end;  
  NoErr = 1;
  res = EpsonOpen(LSPDr);
  if (res==NoErr) then begin
    NoErr = 0;
    cmdnr = 0;
    res = EpsonCheckClock(IVCashr.TransDate,cmdnr);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    res = EpsonReadVATGroups(cmdnr,aVATGroups);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    res = EpsonOpenFiscalReceipt(IVCashr.CustCode,cmdnr);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    res = IVCashVc_EpsonPrintInvoiceLines(IVCashr,aVATGroups,cmdnr);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    res = IVCashVc_EpsonTotalTender(IVCashr,cmdnr);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    res = EpsonCloseFiscalReceipt(cmdnr);
    if (res!=NoErr) then begin goto LIVCashVc_PrintEpsonReceipt; end;
    RecordCopy(oldIVCashr,IVCashr);
    IVCashr.Prntdf = 1;
    RecordUpdate(oldIVCashr,IVCashr,false);
LIVCashVc_PrintEpsonReceipt:;
    if (res!=NoErr) then begin
      EpsonTotalCancel(cmdnr);
    end;
    EpsonClose;
  end;
  return;
end;
