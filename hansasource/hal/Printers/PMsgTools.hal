external procedure M4PadString(string,Integer,string,Boolean,var string);
external function Integer StrArrayCnt(array string);
external procedure StrArrayEmpty(var array string);
external procedure AddToStrArray(string,var array string);
external procedure AddToIntArray(Integer,var array integer);
external procedure StripSpace(var string,string);
external function LongInt UnPackNumber(string,integer,integer);
external function integer DecimalFromByteByBit(var integer,integer);
external function string 255 ChrStrToHexStr(string,boolean);
external function string 100 HexStrToChrStr(string,boolean);
external function string 255 ChrStrToDecStr(string,boolean);
external function string 50 PackNumber(LongInt);
external function string 50 IntToBCD(LongInt,boolean);
external function string 255 PMsgExtension(record LSerialPortDeviceVc,integer,integer,string);
external function string 255 PMsgExtensionEx(record LSerialPortDeviceVc,integer,integer,string,var array integer,var array string);
external function string 255 PMsgExtensionEx2(record LSerialPortDeviceVc,integer,integer,string,var array integer,var array string,array string);
external function string 50 TimeToString(time,string,boolean);

global
procedure PMsgFormat_DefVar(integer VarId,integer Type,integer Length,var array integer pformat)
begin

  if(Type==PMsg_Bit) then begin
    pformat[1] = pformat[1] + Length;
  end else begin
    if(pformat[pformat[0]-1]==PMsg_Bit) then begin
      pformat[1] = pformat[1] + Mod(pformat[1],8);
    end;
    pformat[1] = pformat[1] + (Length*8);
  end;

  AddToIntArray(VarId,pformat);
  AddToIntArray(Type,pformat);
  AddToIntArray(Length,pformat);

  return;
end;

global
procedure PMsg_DefBIT(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_Bit,Length,pformat);
  return;
end;

global
procedure PMsg_DefINT(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_Int,Length,pformat);
  return;
end;

global
procedure PMsg_DefBCD(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_BCD,Length,pformat);
  return;
end;

global
procedure PMsg_DefDMY(integer VarId,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_DateDMY,3,pformat);
  return;
end;

global
procedure PMsg_DefYMD(integer VarId,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_DateYMD,3,pformat);
  return;
end;

global
procedure PMsg_DefHMS(integer VarId,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_TimeHMS,3,pformat);
  return;
end;

global
procedure PMsg_DefSTR(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_Str,Length,pformat);
  return;
end;

global
procedure PMsg_DefSTRPAD(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_StrPad,Length,pformat);
  return;
end;

global
procedure PMsg_DefSTRSTRIP(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_StrStrip,Length,pformat);
  return;
end;

global
procedure PMsg_DefVAL(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_Val,Length,pformat);
  return;
end;

global
procedure PMsg_DefVAL2(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_ValD2,Length,pformat);
  return;
end;

global
procedure PMsg_DefVAL3(integer VarId,integer Length,var array integer pformat)
begin
  PMsgFormat_DefVar(VarId,PMsg_ValD3,Length,pformat);
  return;
end;


global
procedure PMsgFormat_DefStaticText(string text,var array integer format)
begin
  integer slen,i;

  slen = Len(text);
  for(i=0;i<slen;i=i+1) begin
    PMsgFormat_DefVar(PMsgVar_Reserved,PMsg_Filler,asc(Mid(text,i,1)),format);
  end;
  return;
end;

global
procedure PMsgFormat_DefStaticHex(string hex,var array integer format)
begin
  string 100 tstr;

  tstr = HexStrToChrStr(hex,false);
  PMsgFormat_DefStaticText(tstr,format);
  return;
end;

global
procedure PMsg_DefHEX(string hex,var array integer format)
begin
  PMsgFormat_DefStaticHex(hex,format);
  return;
end;


global
procedure PMsgFormat_DefStaticInteger(integer num,var array integer format)
begin
  PMsgFormat_DefStaticText(chr(num),format);
  return;
end;


global
function string 255 PMsgSettings(record LSerialPortDeviceVc LSPDr,integer PMsgSettingsId)
begin
  string 255 res;

  res = PMsgExtension(LSPDr,PMsgExtensionType_Settings,PMsgSettingsId,"");

  PMsgSettings = res;
  return;
end;

global
function integer PMsgExtension_Int(record LSerialPortDeviceVc LSPDr,integer ExtensionConst,integer CmdConst,string ParamConst)
begin
  integer res;
  string 50 value;

  res = -1;
  value = PMsgExtension(LSPDr,ExtensionConst,CmdConst,ParamConst);
  if(nonblank(value)) then begin
    res = StringToInt(value);
  end;

  PMsgExtension_Int = res;
  return;
end;

global
function integer PMsgConst(record LSerialPortDeviceVc LSPDr,integer CmdConst,string ParamConst)
begin
  integer res;

  res = PMsgExtension_Int(LSPDr,PMsgExtensionType_Constant,CmdConst,ParamConst);

  PMsgConst = res;
  return;
end;

global
function integer PMsgCmdCtrl(record LSerialPortDeviceVc LSPDr,integer CmdConst,string ParamConst)
begin
  integer res;

  res = PMsgExtension_Int(LSPDr,PMsgExtensionType_CmdCtrl,CmdConst,ParamConst);
  PMsgCmdCtrl = res;
  return;
end;

global
function integer PMsgSettings_Int(record LSerialPortDeviceVc LSPDr,integer PMsgSettingsId)
begin
  PMsgSettings_Int = StringToInt(PMsgSettings(LSPDr,PMsgSettingsId));
  return;
end;

global
function string 255 PMsgTextToPrinterCodePage(record LSerialPortDeviceVc LSPDr,string Text)
begin
  array integer codepage;
  array string 255 dummy;
  integer slen,i,ascii;
  string 255 res;
  string 1 c;

  PMsgExtensionEx(LSPDr,PMsgExtensionType_InnerCodePage,0,"",codepage,dummy);
  slen = Len(Text);
  for(i=0;i<slen;i=i+1) begin
    c = Mid(Text,i,1);
    ascii = asc(c);
    if(ascii>256) then begin
      c = uchr(codepage[ascii]);
    end;
    res = res & c;
  end;

  PMsgTextToPrinterCodePage = res;
  return;
end;

function boolean PmsgArrayLoop(var integer i,array integer iarray,var integer var1,var integer var2, var integer var3)
begin
  boolean abort;

  if(i<2) then begin
    i = 2;
  end else begin
    i = i + 3;
  end;

  if(i>iarray[0]) then begin
    abort = true;
  end else begin
    var1 = iarray[i];
    var2 = iarray[i+1];
    var3 = iarray[i+2];
  end;

  PmsgArrayLoop = !abort;
  return;
end;

global
function string 255 PMsgNumber(record LSerialPortDeviceVc LSPDr,string astring,integer start,integer l)
begin
  string 255 res;

  switch(PMsgSettings_Int(LSPDr,PMsgSettings_NumberPackingFormat)) begin
    case PMsg_BCD:
      res = ChrStrToHexStr(Mid(astring,start,l),false);
    case PMsg_Int:
      res = UnPackNumber(astring,start,l);
  end;

  PMsgNumber = res;
  return;
end;

// [COMM/] Support for getting answers from stacked functions (if we query for more than one thing)
function integer PmsgAnswerCount(array string answers)
begin

  PmsgAnswerCount = StringToInt(answers[0])/3;

  return;
end;

global
procedure PMsgAnswersAddFunction(integer CmdConst,var array string answers)
begin
  integer ai,api,cmdindex;

  ai = StringToInt(answers[0]); // answer index
  api = StringToInt(answers[1]); // last answer start index

  cmdindex = 500+ai;
  answers[cmdindex] = CmdConst; // command
  answers[cmdindex+1] = api; // asnw. var start index
  answers[cmdindex+2] = 0; // answ. var count
  answers[0] = ai + 3;

  return;
end;

global
procedure PMsgAnswersAddValue(integer Variable,string Value,var array string answers)
begin
  integer api,ai,cmdindex;

  ai = StringToInt(answers[0]);
  api = StringToInt(answers[1]);
  // [COMM/] Last command answer variables number upped
  cmdindex = 500+ai-3;
  answers[cmdindex+2] = StringToInt(answers[cmdindex+2]) + 1;
  // [COMM/] Add the variable
  answers[600+api] = Variable;
  answers[600+api+1] = Value;

  answers[1] = api + 2;
  return;
end;

global
procedure PMsgAnswersCollectValues(string CmdId,string VarId,array string answers,var array string values)
begin
  integer cnt,i,index,j,iend,acnt;

  StrArrayEmpty(values);
  acnt = StringToInt(answers[0]);
  if(acnt>0) then begin
    cnt = 500 + acnt;
    for(i=500;i<cnt;i=i+3) begin
      if(answers[i]==CmdId) then begin
        index = 600+StringtoInt(answers[i+1]);
        iend = index+StringToInt(answers[i+2])*2;
        for(j=index;j<=iend;j=j+2) begin
          if(answers[j]==VarId) then begin
            AddToStrArray(answers[j+1],values);
            j=iend;
          end;
        end;
      end;
    end;
  end;
  return;
end;

// [COMM/] Answer string to parameters... :: EscapeVar implemented >> will quit the function when that Var is unpacked
global
function Boolean PMsgParamsUnpackEx(record LSerialPortDeviceVc LSPDr,Integer PMsgCmdId,string answer,array string params,integer EscapeVar)
begin
  array integer format;
  integer chunklen,i,varid,vtype,vtypenext,bvalue,bts,alen;
  longint tmpvalue;
  Boolean failed;
  string 255 astring,tstr;
  integer divide;
  date d;
  time t;
  array string 1 dummy;

  astring = answer;
  PMsgExtensionEx(LSPDr,PMsgExtensionType_UnPack,PMsgCmdId,"",format,dummy);

  // [COMM/] Fail, if answer is shorter than expected
  // [TODO/] Exceptions should be the answers that have ETX variables for last VAR
  alen = Len(answer);
  if(format[1] > alen and EscapeVar == -1 and vtype != PMsg_Str) then begin
    failed = true;
    tstr = PMsgExtension(LSPDr,PMsgExtensionType_TrasnalteCmd,PMsgCmdId,"");
    LogText(0,"PMsgParamsUnpackEx: Msg_"&tstr&" Answer shorter ("& alen &") than expected ("&format[1]&"). Aborting.");
    MessageBox(0,"Communication error: Msg_"&tstr&" (answer too short)");
  end;

  // [COMM/] Support for getting answers from stacked functions
  PMsgAnswersAddFunction(PMsgCmdId,params);

  while(PmsgArrayLoop(i,format,varid,vtype,chunklen) and !failed) begin
    vtypenext = format[i+4]; // (i+3)+1
    tstr = "";
    divide = 0;
    switch(vtype) begin
      case PMsg_StrStrip:
        StripSpace(tstr,astring);
        astring = tstr;
        vtype = PMsg_Str;
      case PMsg_ValD2:
        vtype = PMsg_Val;
        divide = 100;
      case PMsg_ValD3:
        vtype = PMsg_Val;
        divide = 1000;
    end;

    switch(vtype) begin
      case PMsg_BCD:
        params[varid] = PMsgNumber(LSPDr,astring,0,chunklen);
      case PMsg_Int:
        params[varid] = UnPackNumber(astring,0,chunklen);
      case PMsg_IntEtx:
        for(chunklen=chunklen;StringToInt(Mid(astring,chunklen,1))!=CC_ETX and chunklen>=0;chunklen=chunklen-1) begin end;
        params[varid] = PMsgNumber(LSPDr,astring,0,chunklen);
      case PMsg_DateDMY:
        d.day = StringToInt(PMsgNumber(LSPDr,astring,0,1));
        d.month = StringToInt(PMsgNumber(LSPDr,astring,1,1));
        d.year = StringToInt(PMsgNumber(LSPDr,astring,2,1));
        params[varid] = d;
      case PMsg_DateYMD:
        d.day = StringToInt(PMsgNumber(LSPDr,astring,2,1));
        d.month = StringToInt(PMsgNumber(LSPDr,astring,1,1));
        d.year = StringToInt(PMsgNumber(LSPDr,astring,0,1));
        params[varid] = d;
      case PMsg_TimeHMS:
        t.hour = StringToInt(PMsgNumber(LSPDr,astring,0,1));
        t.minute = StringToInt(PMsgNumber(LSPDr,astring,1,1));
        t.second = StringToInt(PMsgNumber(LSPDr,astring,2,1));
        params[varid] = t;
      case PMsg_TimeSMH:
        t.hour = StringToInt(PMsgNumber(LSPDr,astring,2,1));
        t.minute = StringToInt(PMsgNumber(LSPDr,astring,1,1));
        t.second = StringToInt(PMsgNumber(LSPDr,astring,0,1));
        params[varid] = t;
      case PMsg_Str:
        params[varid] = Left(astring,chunklen);
      case PMsg_StrEtx:
        for(chunklen=chunklen;StringToInt(Mid(astring,chunklen,1))!=CC_ETX and chunklen>=0;chunklen=chunklen-1) begin end;
        params[varid] = Left(astring,chunklen);
      case PMsg_Val:
        params[varid] = StringToVal(PMsgNumber(LSPDr,astring,0,chunklen),M4Val)/divide;
      case PMsg_Bit:
        if(bts==0) then begin
          bvalue = UnPackNumber(astring,0,1);
        end;
        params[varid] = DecimalFromByteByBit(bvalue,chunklen);
        bvalue = bvalue;
        bts = bts + chunklen;
        chunklen = 1; // remove only one byte
    end;
    // [COMM/] remove part of the string
    if(vtypenext!=PMsg_Bit or vtype!=PMsg_Bit or bts>=8) then begin
      astring = Mid(astring,chunklen,256);
      bts = 0;
    end;
    // [COMM/] Support for getting answers from stacked functions
    PMsgAnswersAddValue(varid,params[varid],params);
    // [COMM/] Escape the unpacking when we hit EscapeVar
    if(EscapeVar != -1 and varid == EscapeVar) then begin wQuit; end;
  end;

  PMsgParamsUnpackEx = !failed;
  return;
end;

global
function Boolean PMsgParamsUnpack(record LSerialPortDeviceVc LSPDr,Integer PMsgCmdId,string answer,array string params)
begin
  PMsgParamsUnpack = PMsgParamsUnpackEx(LSPDr,PMsgCmdId,answer,params,-1);
  return;
end;

global
function string 255 PmsgUnpackAndGetVar(record LSerialPortDeviceVc LSPDr,Integer PMsgCmdId,string answer,integer EscapeVar)
begin
  array string 255 params;

  PMsgParamsUnpackEx(LSPDr,PMsgCmdId,answer,params,EscapeVar);
  PmsgUnpackAndGetVar = params[EscapeVar];

  return;
end;

// [COMM/] Will return the parameters that have been formated according to printer type
global
function string 255 PMsgParamsPack(record LSerialPortDeviceVc LSPDr,Integer PMsgCmdId,array string cmdvars)
begin
  string 255 res;
  integer chunklen,strlen,i,j,vtype,vtypenext,bnum;
  val tmp;
  string 255 tstr;
  string 100 bitmap;
  array integer format;
  integer varid,bpos;
  date d;
  time t;
  integer multiply;
  array string 1 dummy;

  PMsgExtensionEx(LSPDr,PMsgExtensionType_Pack,PMsgCmdId,"",format,dummy);

  while(PmsgArrayLoop(i,format,varid,vtype,chunklen)) begin
    cmdvars[varid] = PMsgExtension(LSPDr,PMsgExtensionType_ProcessVariable,vtype,cmdvars[varid]);
    vtypenext = format[i+4]; // (i+3)+1
    // prepare some variables
    multiply = 0;
    switch(vtype) begin
      case PMsg_StrPad:
        M4PadString(cmdvars[varid],chunklen,chr(32),false,tstr);
        cmdvars[varid] = tstr;
        vtype = PMsg_Str;
      case PMsg_ValD2:
        vtype = PMsg_Val;
        multiply = 100;
      case PMsg_ValD3:
        vtype = PMsg_Val;
        multiply = 1000;
    end;

    // pack variables
    switch(vtype) begin
      case PMsg_BCD:
        cmdvars[varid] = IntToBCD(cmdvars[varid],false);
        M4PadString(cmdvars[varid],chunklen,uchr(0),true,tstr);
        res = res & tstr;
      case PMsg_Int:
        cmdvars[varid] = PackNumber(StringToLongInt(cmdvars[varid]));
        M4PadString(cmdvars[varid],chunklen,uchr(0),true,tstr);
        res = res & tstr;
      case PMsg_Str:
        cmdvars[varid] = PMsgTextToPrinterCodePage(LSPDr,cmdvars[varid]);
        res = res & Left(cmdvars[varid],chunklen);
      case PMsg_DateYMD:
        tstr = HexStrToChrStr(DateToString(cmdvars[varid],"YYMMDD"),false);
        res = res & tstr;
      case PMsg_DateDMY:
        tstr = HexStrToChrStr(DateToString(cmdvars[varid],"DDMMYY"),false);
        res = res & tstr;
      case PMsg_TimeSMH:
        res = res & TimeToString(cmdvars[varid],"SMH",false);
      case PMsg_TimeHMS:
        res = res & TimeToString(cmdvars[varid],"HMS",false);
      case PMsg_Val:
        tmp = StringToVal(cmdvars[varid],M45Val)*multiply;
        cmdvars[varid] = IntToBCD(tmp,false);
        M4PadString(cmdvars[varid],chunklen,uchr(0),true,tstr);
        res = res & tstr;
      case PMsg_Filler:
        // [COMM/] Adds a predefined constant to the message
        res = res & uchr(chunklen);
      case PMsg_Hex:
        // [COMM/] user for raw sending
        res = HexStrToChrStr(cmdvars[varid],false);
      case PMsg_Bit:
        bnum = bnum + (StringToInt(cmdvars[varid]) * Power(2,bpos));
        bpos = bpos + chunklen;
        if((vtypenext != PMsg_Bit) or bpos >= 8) then begin
          res = res & chr(bnum);
          bnum = 0;
          bpos = 0;
        end;
      case PMsg_Reserved:
        // [COMM/] Fill reserved area with blank
        M4PadString("",chunklen,chr(0),false,tstr);
        res = res & tstr;
    end;
  end;

  PMsgParamsPack = res;
  return;
end;

global
function string 255 PMsg(record LSerialPortDeviceVc LSPDr,integer CommandConst,array string params)
begin
  string 255 FormatedParams,res;

  FormatedParams = PMsgParamsPack(LSPDr,CommandConst,params);
  res = PMsgExtension(LSPDr,PMsgExtensionType_MFormat,CommandConst,FormatedParams);

  PMsg = res;
  return;
end;

function boolean PMsgCommandAvailable(record LSerialPortDeviceVc LSPDr,integer PMsgConst)
begin
  boolean res;

  // [COMM/] Skip, if this device does not support given command // only exception: RawHex (has only parameter value)
  if(asc(PMsgExtension(LSPDr,PMsgExtensionType_Cmd,PMsgConst,""))!=0 or PMsgConst==PMsgCmdConst_RawHex) then begin
    res = true;
  end;

  PMsgCommandAvailable = res;
  return;
end;

global
procedure PMsgAddToStack(record LSerialPortDeviceVc LSPDr,integer PMsgConst,array string params,var array string msgbuffer)
begin
  string 255 tstr;
  integer cmdctrl;
  integer slen,i,j;
  string 255 msg,tmp;
  string 1 c;
  integer ascii;
  array integer dummy;
  array string 255 vals;
  integer valpos,ccnt,pcnt;

  // [COMM/] If the function needs a delay before sending - then delay cmd will be added to the msgbuffer
  cmdctrl = PMsgCmdCtrl(LSPDr,PMsgConst,PMsgSettings_Delay);
  if (cmdctrl>0) then begin
    AddToStrArray(PMsgCmdConst_CmdDelay,msgbuffer);
    AddToStrArray(cmdctrl,msgbuffer);
  end;

  // [COMM/] Will wait a bit longer for an answer to the sent function
  cmdctrl = PMsgCmdCtrl(LSPDr,PMsgConst,PMsgSettings_RetryDelay);
  if(cmdctrl>0) then begin
    AddToStrArray(PMsgCmdConst_RetryDelay,msgbuffer);
    AddToStrArray(cmdctrl,msgbuffer);
  end;
  // [COMM/] Skip, if this device does not support given command // only exception: RawHex (has only parameter value)
  if (PMsgCommandAvailable(LSPDr,PMsgConst)) then begin
    // [COMM/] Format message
    tstr = PMsg(LSPDr,PMsgConst,params);
    // [TMP_FIX/] Fix the message :: THIS CODE SHOULD BE REMOVED :: only used because of the non-bit-safeness of the whole string-business in HAL
    slen = len(tstr);
    for(i=0;i<slen;i=i+1) begin
      ascii = asc(Mid(tstr,i,1));
      msg = msg & chr(ascii);
    end;
    tstr = msg;
    // [COMM/] Add to stack: Semantic command constant :: SematicCommand parameter added so that we could "simulate" a command that we do not have really :)
    AddToStrArray(PMsgConst,msgbuffer);
    // [COMM/] Add to stack: Message
    AddToStrArray(tstr,msgbuffer);
  end else begin
    // [COMM/] Check for alternatives -> If we have one then stack the alternative commands :: also pass params from the CMD to alternative command
    PMsgExtensionEx2(LSPDr,PMsgExtensionType_AlternativeCmd,PMsgConst,"",dummy,msgbuffer,params);
  end;
  return;
end;

global
procedure PMsgAddToStackPreset(integer PrinterModel,integer PMsgConst,array string params,var array string msgbuffer)
begin
  record LSerialPortDeviceVc LSPDr;

  LSPDr.Printer = PrinterModel;
  PMsgAddToStack(LSPDr,PMsgConst,params,msgbuffer);
  return;
end;

global
procedure PMsgAddToStackNP(record LSerialPortDeviceVc LSPDr,integer PMsgConst,var array string msgbuffer)
begin
  array string 255 params;

  PMsgAddToStack(LSPDr,PMsgConst,params,msgbuffer);
  return;
end;

function string 255 PCmdRead(record LSerialPortDeviceVc LSPDr,integer Length)
begin
  string 255 res;
  string 1 c;
  integer cnt,ascii;
  Boolean abort;

  while(!abort and cnt<256) begin
    c = ReadComPort(0,1);
    if(asc(c)>256) then begin wQuit; end;
    // [COMM/] Mid function can't read some characters // try this for example: stopalert(asc(Mid(uchr(134),0,1))); // converting flawed chars to uchr
    ascii = asc(c);
    if(ascii>0 and len(c)==0) then begin c = uchr(ascii); end;
    res = res & c;
    cnt = cnt + 1;
    if(Length > 0) then begin
      if(cnt >= Length) then begin abort = true; end;
    end else begin
      if(c=="") then begin abort = true; end;
    end;
  end;

//  LogText(0," READ: " & ChrStrToHexStr(res,true) & " ("&Length&") {" & ChrStrToDecStr(res,true) & "}"); // debug
  PCmdRead = res;
  return;
end;

global
function string 255 PCmdSendRawEx(record LSerialPortDeviceVc LSPDr,string Data)
begin
  string 255 tstr;

//  LogText(0,"WRITE: " & ChrStrToHexStr(Data,true) & " {" & ChrStrToDecStr(Data,true) & "}");  // debug
  OutComPort(0,Data);

  return;
end;

global
function string 255 PCmdSendRawEx_Cmd(record LSerialPortDeviceVc LSPDr,integer PCmdCommandConst)
begin
  string 255 res;
  string 100 cmd;

  // [TODO/] Querying for this on every time a routine is called is folly. This should be done before sending.
  cmd = PMsgExtension(LSPDr,PMsgExtensionType_Cmd,PCmdCommandConst,"");
  res = PCmdSendRawEx(LSPDr,cmd);

  PCmdSendRawEx_Cmd = res;
  return;
end;

global
procedure PMsgRoutineSend(record LSerialPortDeviceVc LSPDr,integer MsgType,string Message)
begin
  switch(MsgType) begin
    case PMsgCmdConst_Message:
      PCmdSendRawEx(LSPDr,Message);
    otherwise
      PCmdSendRawEx_Cmd(LSPDr,MsgType);
  end;
  return;
end;

global
function boolean PMsgCommunicationRoutine(record LSerialPortDeviceVc LSPDr,integer RoutineType,integer CommandConst,var string Message,integer DelayBetweenRetries)
begin
  array integer seq,aformat;
  integer vcount,i,j,slen;
  string 1 byte;
  integer abyte;
  integer msg;
  string 255 dump,res;
  boolean failed;
  integer rcount;
  integer lastsend;
  integer MsgType,DoThis,RepCnt,MsgConst;
  string 1 from;
  integer rlast;
  array string 255 dummy;

  PMsgExtensionEx(LSPDr,PMsgExtensionType_Routines,RoutineType,"",seq,dummy);
  abyte = asc(PMsgExtension(LSPDr,PMsgExtensionType_Answer,CommandConst,""));
  if (seq[0]>0) then begin
    while(PmsgArrayLoop(i,seq,DoThis,MsgType,MsgConst) and !failed) begin
      switch(DoThis) begin
        case PMsgAction_Send:
          rlast = MsgConst;
          if(abyte == CC_EOT) then begin failed = true; end;
          PMsgRoutineSend(LSPDr,MsgType,Message);
        case PMsgAction_WaitFor:
          // [COMM/] Read one byte and determine how to continue based on that
          msg = asc(PCmdRead(LSPDr,1));

          switch(MsgType) begin
            case PMsgCmdConst_Const:
              if(msg != MsgConst) then begin
                LogText(0,"PMsgCommunicationRoutine: Was expecting for 0x" & MsgConst & ", but got 0x" & res);
                failed = true;
              end;
            case PMsgCmdConst_Message:
              // [COMM/] chr(10) means that there is no answer needed to continue
              if(abyte == 10 or msg == abyte) then begin
                Message = PCmdRead(LSPDr,0);
              end;
            otherwise
              if(abyte!= CC_EOT or i!=2) then begin
                if(msg != asc(PMsgExtension(LSPDr,PMsgExtensionType_Cmd,MsgType,""))) then begin
                  // [COMM/] Check the next handler, if it's KillOn, then die
                  if(seq[i+3]==PMsgAction_KillOn and msg == seq[i+5]) then begin
                    failed = true;
                    wQuit;
                  end else begin
                    // [COMM/] Resend last command
                    if(seq[i-2]==PMsgAction_Send and rlast>rcount) then begin
                      rcount = rcount + 1;
                      i=i-6;
                    end else begin
                      // [COMM/] Wait some more
                      if(seq[i+2]>rcount) then begin
                        MilliSleep(DelayBetweenRetries);
                        rcount = rcount + 1;
                        i=i-3;
                      end else begin
                        return;
                      end;
                    end;
                  end;
                end else begin
                  rcount = 0;
                end;
              end else begin
                return;
              end;
          end; // switch
      end;
    end;
  end;
  PMsgCommunicationRoutine = !failed;
  return;
end;

// [COMM/] Support for processing answers from stacked functions
global function boolean PMsgProcessAnswers(record LSerialPortDeviceVc LSPDr,array string RawAnswers,var array string ProcessedAnswers)
begin
  integer i,acnt,cconst;
  string 255 res;
  boolean failed;

  acnt = StrArrayCnt(RawAnswers);
  for(i=1;i<=acnt and !failed;i=i+2) begin
    cconst = StringToInt(RawAnswers[i]);
    // [COMM/] Format the answer (remove anything that is more communication related :: masking for example)
    res = PMsgExtension(LSPDr,PMsgExtensionType_AFormat,cconst,RawAnswers[i+1]);
    // [COMM/] Process one answer
    failed = !PMsgParamsUnpack(LSPDr,cconst,res,ProcessedAnswers);
  end;

  PMsgProcessAnswers = !failed;
  return;
end;

global
procedure PMsgErrorMsg(record LSerialPortDeviceVc LSPDr,integer PMsgCmdId,integer ErrCode)
begin
  string 255 tstr,errmsg;

  errmsg = PMsgExtension(LSPDr,PMsgExtensionType_ErrorMsg,PMsgCmdId,ErrCode);
  tstr = PMsgExtension(LSPDr,PMsgExtensionType_TrasnalteCmd,PMsgCmdId,"");
  MessageBox(0,"PMsg_"&tstr&":"&chr(13) & "(" &ErrCode& ") " & errmsg);

  return;
end;

global
function boolean PMsgSend(record LSerialPortDeviceVc LSPDr,var array string MessageStack,var array string answers)
begin
  integer acnt,cconst,retrydelay,i,errcode,noerr;
  string 255 res,errmsg,msg,tstr;
  array string 255 RawAnswers;
  boolean error;

  acnt = StrArrayCnt(MessageStack);

  noerr = StringToInt(PMsgExtension_Int(LSPDr,PMsgExtensionType_Error,PMsgErrorType_NoError,""));
  if(acnt>0) then begin
    PMsgCommunicationRoutine(LSPDr,PMsgRoutine_Initiate,0,res,0);
    for(i=1;i<=acnt and !error;i=i+2) begin
      cconst = StringToInt(MessageStack[i]);
      msg = MessageStack[i+1];
      switch(cconst) begin
        case PMsgCmdConst_CmdDelay:
          MilliSleep(StringToInt(msg));
        case PMsgCmdConst_RetryDelay:
          retrydelay = StringToInt(msg);
        otherwise
          //tstr = PMsgExtension(LSPDr,PMsgExtensionType_TrasnalteCmd,cconst,""); // debug
          //LogText(0,"----------------" & tstr & "----------------"); // debug
          if(PMsgCommunicationRoutine(LSPDr,PMsgRoutine_Send,cconst,msg,0)) then begin
            PMsgCommunicationRoutine(LSPDr,PMsgRoutine_Receive,cconst,res,retrydelay);
            // [COMM/] Quickly unpack part of the message and check the error code
            errcode = StringToInt(PmsgUnpackAndGetVar(LSPDr,cconst,res,PMsgVar_Error));
            if(errcode != noerr) then begin
              // [COMM/] Get printer specific error message, show it to the user and exit the loop
              PMsgErrorMsg(LSPDr,cconst,errcode);
              // [COMM/] Dump the message // answer to log
              LogText(0,"Err/w: " & ChrStrToHexStr(msg,true));
              LogText(0,"Err/r: " & ChrStrToHexStr(res,true));
              error = true;
            end;
            // [COMM/] Support for stacked functions
            AddToStrArray(cconst,RawAnswers);
            AddToStrArray(res,RawAnswers);
          end;
          retrydelay = 0;
      end;
    end;
    if(!error) then begin
      PMsgCommunicationRoutine(LSPDr,PMsgRoutine_Terminate,0,res,0);
      StrArrayEmpty(MessageStack);
      error = !PMsgProcessAnswers(LSPDr,RawAnswers,answers);
    end;
  end;

  PMsgSend = !error;
  return;
end;

global
function boolean PMsgSendDeaf(record LSerialPortDeviceVc LSPDr,var array string MessageStack)
begin
  array string 255 answers;

  PMsgSendDeaf = PMsgSend(LSPDr,MessageStack,answers);
  return;
end;

global
function integer PMsgOpen(record LSerialPortDeviceVc LSPDr)
begin
  integer res;

  res = OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);

  if (res) then begin
//    LogText(0,"OPEN"); // debug
  end;

  PMsgOpen = res;
  return;
end;

global
procedure PMsgClose(integer status)
begin

  if(status != 0) then begin
    CloseComPort(0);
//    LogText(0,"CLOSE"); // debug
  end;

  return;
end;

global
function boolean PMsgWrite(record LSerialPortDeviceVc LSPDr,var array string msgstack,var array string answers)
begin

  if(PMsgOpen(LSPDr)!=0) then begin
    PMsgWrite = PMsgSend(LSPDr,msgstack,answers);
    PMsgClose(1);
  end;

  return;
end;

global
function boolean PMsgWriteDeaf(record LSerialPortDeviceVc LSPDr,var array string msgstack)
begin
  array string 255 answers;

  PMsgWriteDeaf = PMsgWrite(LSPDr,msgstack,answers);

  return;
end;
