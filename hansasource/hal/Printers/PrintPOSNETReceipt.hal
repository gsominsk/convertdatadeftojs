remote function Integer OpenDrawer_POSNETProtocol_TCP(record LSerialPortDeviceVc);
remote updating procedure PrintPOSNETReceiptRestAcc_withPOSNETProtocol_TCP(var record RestAccVc,record LSerialPortDeviceVc);
remote updating procedure PrintPOSNETReceipt_withPOSNETProtocol_TCP(var record IVVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashRestAccReceiptClient(record LocalMachineBlock,var record RestAccVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashRestAccReceipt(record LocalMachineBlock,var record RestAccVc,record LSerialPortDeviceVc);
external updating procedure RestAccVc_PrintTSLReceipt(var record RestAccVc,record LSerialPortDeviceVc,Boolean);
external updating procedure PrintPOSNETReceiptRestAcc_withPOSNETProtocol(var record RestAccVc,record LSerialPortDeviceVc);
external function Integer OpenDrawer_POSNETProtocol(record LSerialPortDeviceVc,Boolean);
external updating procedure PrintPOSNETReceipt_withPOSNETProtocol(var record IVVc,record LSerialPortDeviceVc);
external function Integer POSNETAcceptBOS_WithPaymentModes(record IVVc);
external updating procedure PrintDatecs2000Receipt(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintST05Receipt(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFB05Receipt(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFB15Receipt_IVVc(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFB15Receiptdll_IVVc(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFM32Receiptdll_IVVc(var record IVVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashIVCashReceipt(record LocalMachineBlock,var record IVCashVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashIVCashReceiptClient(record LocalMachineBlock,var record IVCashVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashReceipt(record LocalMachineBlock,var record IVVc,record LSerialPortDeviceVc);
external updating function Boolean StoreCleanCashReceiptClient(record LocalMachineBlock,var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFI550Receipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintEPSONINVOICEReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintEpsonTMUReceipt(record IVVc,record LSerialPortDeviceVc);
external procedure IVVc_PrintTSLReceipt(record IVVc,record LSerialPortDeviceVc,Integer,Boolean,Boolean,Integer);
external updating procedure PrintHASARReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintHASARPL23FPANReceipt(record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintFM3000Receipt(record IVVc,record LSerialPortDeviceVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Integer POSNETAcceptBOS_POSNETY(record IVVc);
external function Integer POSNETAcceptBOS_OPTIMUS(record IVVc);
external procedure POSNETCheckSum(var string);
external function Integer POSNETInString(string,string);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure POSNETGetByte(string,Integer,Integer,var string);
external function LongInt POSNETHexToLong(string);
external function Integer GetPOSNETErrorCode(string);
external function Integer GetPOSNETDate(string,var Integer,var Integer,var Integer);
external procedure GetPOSNETVATCode(Array val,Integer,record VATCodeBlock,string,var string);
external function Integer GetPOSNETVATRates(string,var Array val);
external procedure WinToMaz(string,var string);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function boolean PMsg_PrintReceipt(record LSerialPortDeviceVc,var record IVVc);
external procedure IVVc_PrintRCHFleaReceipt(var record IVVc,record LSerialPortDeviceVc);
external updating procedure PrintEpsonTMTReceipt(var record IVVc,record LSerialPortDeviceVc);
external procedure IVVc_PrintBematechMP2100Receipt(var record IVVc,record LSerialPortDeviceVc);
external procedure RestAccVc_PrintBematechMP2100Receipt(var record RestAccVc,record LSerialPortDeviceVc);

procedure StripOneZero(var string res)
BEGIN
  Integer i,l,j;
  string 255 tstr;
  
  tstr = res;
  res = "";
  l = len(tstr);
  j = l;
  for (i=l; i>=1; i=i-1) begin
    if (CharacterMatch(tstr,"0",i)) then begin
      j = i-1;
      goto LBreakStripOneZero;
    end;
  end;
LBreakStripOneZero:;  
  res = Left(tstr,j);
  RETURN;
END;

procedure AddPOSNETStrings(record CashPrintBlock CPb,record IVVc IVr,Boolean headerf,var string CtrlSeq)
BEGIN
  Integer i;
  string 255 tstr,extstr;
  string 255 thestr0,thestr1,thestr2;
  string 1 CR;

  CR = chr(13);
  if (headerf) then begin
    thestr0 = CPb.Head0;
    thestr1 = CPb.Head1;
    thestr2 = CPb.Head2;
  end else begin
    thestr0 = CPb.Foot0;
    thestr1 = CPb.Foot1;
//    thestr2 = CPb.Foot2;
  end;
  if (nonblank(thestr0)) then begin
    extstr = thestr0;
    i = POSNETInString(extstr,"[2]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.Addr0 & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[1]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.SerNr & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[3]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.CustCode & Right(extstr,len(extstr)-i-3);
    end;
    extstr = Left(extstr,40);
    WinToMaz(extstr,tstr);
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & CR;
  end;
  if (nonblank(thestr1)) then begin  
    extstr = thestr1;
    i = POSNETInString(extstr,"[2]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.Addr0 & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[1]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.SerNr & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[3]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.CustCode & Right(extstr,len(extstr)-i-3);
    end;
    extstr = Left(extstr,40);
    WinToMaz(extstr,tstr);
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & CR;
  end;
  if (nonblank(thestr2)) then begin
    extstr = thestr2;
    i = POSNETInString(extstr,"[2]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.Addr0 & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[1]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.SerNr & Right(extstr,len(extstr)-i-3);
    end;
    i = POSNETInString(extstr,"[3]");
    if (i>=0) then begin
      extstr = Left(extstr,i) & IVr.CustCode & Right(extstr,len(extstr)-i-3);
    end;
    extstr = Left(extstr,40);
    WinToMaz(extstr,tstr);
    CtrlSeq = CtrlSeq & tstr;
    CtrlSeq = CtrlSeq & CR;
  end;
  RETURN;
END;

function Integer  ReplyInPOSNETBuffer(var string replystr)
BEGIN
  Integer noErr;
  
  replystr = replystr & ReadComPort(0,255-len(replystr));
  ReplyInPOSNETBuffer = noErr;
  RETURN;
END;

function Integer WaitPOSNETTime(LongInt par,Integer option,var string replystr)
BEGIN
  Integer res;
  Integer noErr;
  LongInt lpar;
  LongInt tickcount, tick;
  Integer l;
  string 3 ESCs;

  res = 12400;
  ESCs = chr(27);
  replystr = "";
  lpar = par*1000;
  tick = GetCurTick;
  tickcount = tick;
  while ((tickcount-tick)<lpar) begin
    tickcount = GetCurTick;
    switch (option) begin
      case 80:      
        res = ReplyInPOSNETBuffer(replystr);
        if (len(replystr)>0) then begin//TestBit(asc(Left(replystr,1)),2)==1
          res = noErr;
          goto LWaitPOSNETTime;
        end;
      case 27:
        res = ReplyInPOSNETBuffer(replystr);
        l = len(replystr);
        if ((Mid(replystr,l-2,1)==ESCs) and (l>3)) then begin
          res = noErr;
          goto LWaitPOSNETTime;
        end;
    end;
  end;
LWaitPOSNETTime:;
  WaitPOSNETTime = res;
  RETURN;  
END;

function Integer SendPOSNETString(string s)
BEGIN
  Integer res;
  Integer noErr;

  if (OutComPort(0,s)!=0) then begin
    res = noErr;
  end else begin
    res = 1;
  end;
  SendPOSNETString = res;
  RETURN;
END;

function Integer TestPOSNETSuccess(string replystr)
BEGIN
  Integer res,err;
  Integer noErr;
  string 20    tstr;
  string 1 enqs;
  Integer enqint;
  string 10 getReplystr;
  LongInt DELAY;
  Integer SEQ_ESC;
  
  DELAY = 10;
  SEQ_ESC = 27;
  getReplystr  = chr(27) & "P" & "#" & "s" & chr(27) & "\\";
  enqs = Mid(replystr,len(replystr)-1,1);
  if (len(enqs)==0) then begin
    res = 12401;
    goto LTestPOSNETSuccess;
  end;
  enqint = asc(enqs);
  if (BitAnd(enqint,4)!=4) then begin
    res = SendPOSNETString(getReplystr);
    if (res!=noErr) then begin
      goto LTestPOSNETSuccess;
    end;
    res = WaitPOSNETTime(DELAY,SEQ_ESC,replystr);

    if (res==noErr) then begin
//      goto LTestPOSNETSuccess;
    end;
    err = GetPOSNETErrorCode(replystr);
    if (err!=noErr) then begin
      if (err>40) then begin 
        res = 12441; 
      end else begin
        res = err + 12400; 
      end;       
      if (res<12399) or (res>12406) then begin
        res = err;
      end;
      goto LTestPOSNETSuccess;
    end;
  end;
  res = noErr;
  MilliSleep(100);
LTestPOSNETSuccess:;
  TestPOSNETSuccess = res;
  RETURN;
END;

function Integer WritePOSNET(string str,LongInt errtimeout,Boolean testsuccf,var string replystr)
BEGIN
  Integer res;
  Integer noErr;
  string 3 ENQs;
  Integer ONE_ERROR_BYTE;
  Integer SEQ_ESC;
  
  ONE_ERROR_BYTE = 80;
  SEQ_ESC = 27;
  ENQs = chr(5);
  res = SendPOSNETString(str);
  if (res!=noErr) then begin
    goto LWritePOSNET;
  end;
  if (Mid(str,len(str)-1,1)==ENQs) then begin
    res = WaitPOSNETTime(errtimeout, ONE_ERROR_BYTE,replystr);
    if (res!=noErr) then begin
      goto LWritePOSNET;
    end;    
  end else begin
    res = WaitPOSNETTime(errtimeout, SEQ_ESC,replystr);
    if (res!=noErr) then begin
      goto LWritePOSNET;
    end;    
  end;
LWritePOSNET:;
  if (testsuccf) then begin
    res = TestPOSNETSuccess(replystr);
  end else begin
    res = noErr;
  end;
  WritePOSNET = res;
  RETURN;
END;

global
procedure AddPOSNETInteger(Integer w,Boolean addsemicolonf,var string CtrlSeq)
BEGIN
  string 20 tstr;

  tstr = w;
  if (addsemicolonf) then begin
  tstr = tstr & ";";
  end;
  CtrlSeq = CtrlSeq & tstr;
  RETURN;
END;

procedure POSNETValToStr(record SysFormatBlock SysFormatRec,val a,Integer minprec,Integer maxprec, var string resstr)
BEGIN
  Integer i,typ;
  
  switch (maxprec) begin
    case 5: typ = M45Val;
    case 3: typ = M4UVal;
    otherwise typ = M4Val;
  end;  
  resstr = ValToString(a,typ,"",".",0);
  RETURN;
END;

global
procedure AddPOSNETVal(record SysFormatBlock SysFormatRec,val a,Integer prec,Boolean addslashf,var string CtrlSeq)
BEGIN
  string 20 tstr;

  POSNETValToStr(SysFormatRec,a,prec,prec,tstr);
  if (addslashf) then begin
    tstr = tstr & "/";
  end;
  CtrlSeq = CtrlSeq & tstr;
  RETURN;
END;

function Integer CheckPOSNETClock()
BEGIN
  Integer res;
  Date td;
  Integer pY,pM,pD;
  string 255 CtrlSeq;
  string 3 DCS,LBSENDCK,ST;
  LongInt DELAY,LONG_DELAY;
  Integer noErr;
  string 255 replystr;
  
  DELAY = 10;
  LONG_DELAY = 45;
  td = CurrentDate;
  LBSENDCK = "#" & "c";
  DCS = chr(27) & "P";
  ST  = chr(27) & chr(92);
  CtrlSeq = DCS;
  AddPOSNETInteger(1,false,CtrlSeq);
  CtrlSeq = CtrlSeq & LBSENDCK;
  CtrlSeq = CtrlSeq & ST;
  res = WritePOSNET(CtrlSeq,DELAY,true,replystr);
  if (res!=noErr) then begin
    if (res>=12400) then begin
      MessageBox(0,USetStr(res));
    end else begin
      MessageBox(0,"error " & USetStr(res));
    end;
    goto LCheckPOSNETClock;
  end;
  res = GetPOSNETDate(replystr,pY,pM,pD);
  if ((GetYear(td)==pY) and (GetMonth(td)==pM) and (GetDay(td)==pD)) then begin
     res = noErr;
  end else begin
     MessageBox(0,USetStr(12402));
     MessageBox(0,USetStr(12403) & pY & pM & pD);
     MessageBox(0,USetStr(12404) & GetYear(td) & GetMonth(td) & GetDay(td));
     res = SendPOSNETString(chr(56));
     res = 1;
  end;
LCheckPOSNETClock:;
  CheckPOSNETClock = res;
  RETURN;
END;

function Integer LoadPOSNETVATRates(Array val prates,Integer FiscalPrinter)
BEGIN
  Integer res,noErr;
  string 10 getReplystr;
  LongInt DELAY;
  string 2 ST;
  Integer i,l,slash,vatdef;
  string 255 replystr;

  DELAY = 10;
  ST  = chr(27) & chr(92);
  if (FiscalPrinter!=kSerialPortDeviceModelFiscPrinterPOSNETThermal5V) then begin
    getReplystr  = chr(27) & "P" & "#" & "s" & ST;
  end else begin
    getReplystr  = chr(27) & "P" & "23" & "#" & "s" & ST;
  end;
  res = WritePOSNET(getReplystr,DELAY,false,replystr);
  if (blank(replystr)) then begin
    goto L66LoadPOSNETVATRates;
  end;
  if (res!=noErr) then begin
  goto LLoadPOSNETVATRates;
  end;
  res = GetPOSNETVATRates(replystr,prates);
  l = len(replystr);
  for(i=0;i<=l;i=i+1) begin
    if (Mid(replystr,i,1)=="/") then begin
      slash = slash + 1;
    end;
  end;
  vatdef = (slash/2) - 2;
  if (vatdef<0) then begin goto L66LoadPOSNETVATRates; end;
/*

  for (i=0;i<vatdef;i++)
   DoubleToBcd((double)VAT[i], &FPVATRates[i]);

  for (i=vatdef;i<5;i++)
   SetM4ValBlank(&FPVATRates[i]);
*/  
  res = noErr;
  goto LLoadPOSNETVATRates;
L66LoadPOSNETVATRates:;
  res = 12405;
  MessageBox(0,USetStr(res));
LLoadPOSNETVATRates:;
  LoadPOSNETVATRates = res;
  RETURN;
END;

global
function Integer CheckPOSNETWrite(LongInt t,string CtrlSeq)
BEGIN
  Integer res,noErr;
  string 255 replystr;
  string 20 cancelstr;
  
  cancelstr = chr(24) & chr(27) & "P" & "0" & "$" & "e" & "8" & "e" & chr(27) & "\\";  
  res = WritePOSNET(CtrlSeq,t,true,replystr);
  if (res!=noErr) then begin
    res = SendPOSNETString(cancelstr);
    res = 1;
  goto LCheckPOSNETWrite;
  end;
LCheckPOSNETWrite:;  
  CheckPOSNETWrite = res;
  RETURN
END;

function Integer POSNETTransBegin(record IVVc IVr)
BEGIN
  Integer res;
  Integer i,rwcnt,addlines;
  LongInt DELAY;
  record CashPrintBlock CPb;
  string 3 DCS,LBTRSHDR,ST;
  string 255 CtrlSeq;
  Integer linenrs;
  row IVVc IVrw;

  DELAY = 10;
  LBTRSHDR = "$" & "h";
  DCS = chr(27) & "P";
  BlockLoad(CPb);

  rwcnt = MatRowCnt(IVr);
  linenrs = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (blank(IVrw.ArtCode)) then begin
      goto LSKIPROW2;
    end;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeNormal: ;
      case kInvoiceRowTypeStructuredItemComponent: ;
      case kInvoiceRowTypeVoid: ;
      case 11: ;
      case 5: 
        if (IVrw.Sum<0) then begin 
          goto LSKIPROW2;
        end;
      otherwise 
        goto LSKIPROW2;
    end;
    linenrs = linenrs + 1;
LSKIPROW2:;
  end;
  rwcnt = linenrs;

  if (nonblank(CPb.Head0)) then begin
    addlines = addlines + 1;
  end;
  if (nonblank(CPb.Head1)) then begin
    addlines = addlines + 1;
  end;
  if (nonblank(CPb.Head2)) then begin
    addlines = addlines + 1;
  end;
  addlines = 0;
  CtrlSeq = DCS;
  AddPOSNETInteger(rwcnt,true,CtrlSeq);
  AddPOSNETInteger(addlines,false,CtrlSeq);
  CtrlSeq = CtrlSeq & LBTRSHDR;
//  AddPOSNETStrings(CPb,IVr,true,CtrlSeq);
  POSNETCheckSum(CtrlSeq);
//StopAlert("Begin " & CtrlSeq);
  res = CheckPOSNETWrite(DELAY,CtrlSeq);
  if (windowsMode) then begin
  end else begin
    MilliSleep(600);
  end;
  POSNETTransBegin = res;
  RETURN;
END;

function Integer DataBaseRep(string article, string VATCode)
BEGIN
  string 255 CtrlSeq,tstr;
  string 3 DCS,ST,LBDBREP;
  string 1 CR;
  string 20 cancelstr;
  LongInt LONG_DELAY;
  Integer res;
  
  LONG_DELAY = 45;
  CR = chr(13);  
  DCS = chr(27) & "P";
  ST  = chr(27) & chr(92);
  LBDBREP = "#" & "b";

  CtrlSeq = DCS;
  AddPOSNETInteger(0,false,CtrlSeq);
  CtrlSeq = CtrlSeq & LBDBREP;
  POSNETCheckSum(CtrlSeq);
  tstr = Left(CtrlSeq,len(CtrlSeq)-1);//throw ENQ

  CtrlSeq = DCS;
  AddPOSNETInteger(1,false,CtrlSeq);
  CtrlSeq = CtrlSeq & LBDBREP;
  CtrlSeq = CtrlSeq & article;
  CtrlSeq = CtrlSeq & CR;
  CtrlSeq = CtrlSeq & VATCode;
  CtrlSeq = CtrlSeq & "/";
  POSNETCheckSum(CtrlSeq);
  tstr = tstr & Left(CtrlSeq,len(CtrlSeq)-1);//throw ENQ
  CtrlSeq = DCS;
  AddPOSNETInteger(2,false,CtrlSeq);
  CtrlSeq = CtrlSeq & LBDBREP;
  POSNETCheckSum(CtrlSeq);
  tstr = tstr & CtrlSeq;
  res = CheckPOSNETWrite(LONG_DELAY,tstr);
  DataBaseRep = res;
  RETURN;
END;

function val DownPaymentAmount(record IVVc IVr,Integer ordrow)
begin
  val res;
  row IVVc IVrw;
  Integer i,rwcnt;

  if (ordrow>=0) then begin
    rwcnt =  MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==5) then begin
        if (IVrw.OrdRow==ordrow) then begin
          res = res + IVrw.Sum;
        end;
      end;
    end;
  end;
  DownPaymentAmount = res;
  RETURN;
END;

function Integer POSNETPrintBOSLines(record IVVc IVr,Array val prates,Integer FiscalPrinter)
BEGIN
  Integer res,noErr,res2;
  record SysFormatBlock SysFormatRec;
  record CashPrintBlock CPb;
  record VATCodeBlock VATCodeRec;
  record INVc INr;
  Integer i,j,linenr,rwcnt,slen;
  row IVVc IVrw;
  string 255 tstr,spec,tspec,CtrlSeq;
  string 20 qtystr, pricestr;
  Boolean onelinef;
  string 3 DCS,ST,LBTRSLN;
  string 1 CR;
  string 20 cancelstr;
  LongInt DELAY;
  string 10 FPVATCode;
  string 255 replystr;
  val downpay,qty;
  
  DELAY = 10;
  CR = chr(13);  
  LBTRSLN = "$" & "l";
  DCS = chr(27) & "P";
  ST  = chr(27) & chr(92);
  cancelstr = chr(24) & chr(27) & "P" & "0" & "$" & "e" & "8" & "e" & chr(27) & "\\";  
  BlockLoad(SysFormatRec);
  BlockLoad(CPb);
  BlockLoad(VATCodeRec);
  rwcnt =  MatRowCnt(IVr);
  linenr = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (blank(IVrw.ArtCode)) then begin
      goto LSKIPROW;
    end;
    qty = IVrw.Quant;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
        downpay = DownPaymentAmount(IVr,IVrw.OrdRow);
        if (downpay!=0) then begin
          IVrw.Sum = IVrw.Sum + downpay;
          IVrw.Price = IVrw.Sum/IVrw.Quant;
        end else begin
          if (IVrw.PriceFactor!=0) then begin
            qty = qty/IVrw.PriceFactor;
          end;
        end;
      case 11: ;
        if (IVrw.PriceFactor!=0) then begin
          qty = qty/IVrw.PriceFactor;
        end;
      case 5: 
        if (IVrw.Sum<0) then begin 
          goto LSKIPROW;
        end;
        IVrw.Price = IVrw.Sum/IVrw.Quant;
      otherwise 
        if (IVrw.PriceFactor!=0) then begin
          qty = qty/IVrw.PriceFactor;
        end;
        goto LSKIPROW;
    end;
    onelinef = false;
    linenr = linenr + 1;
    spec = "";
    if (ReadFirstItem(IVrw.ArtCode,INr,true,true)) then begin    
      tspec = INr.AlternativeCode;
    end;
    if (blank(tspec)) then begin
      tspec = IVrw.ArtCode;
    end;
    WinToMaz(tspec,spec);
    POSNETValToStr(SysFormatRec,qty,2,3,qtystr);
    POSNETValToStr(SysFormatRec,IVrw.Price,2,2,pricestr);

//"one line" format
    /*
    if (CPb.MinCashLen==1) then begin
    if ((len(spec)<=12) and (len(pricestr)+len(qtystr))<=14) then begin
    if (IVrw.Price<100000) then begin
      onelinef = true;
    end;
      end;
    end;
    if (onelinef) then begin
      M4PadString(spec,12," ",false,tstr);
      spec = tstr;
      M4PadString(qtystr,15-(len(pricestr)+len(qtystr))," ",true,tstr);
      qtystr = tstr;
    end else begin
      M4PadString(spec,40," ",false,tstr);
      spec = tstr;      
      pricestr = pricestr;
      M4PadString(qtystr,15-len(qtystr)," ",true,tstr);
      qtystr = tstr;
    end;
    */
    if (len(spec)<=(40-(len(pricestr)+len(qtystr)+6))) then begin
      M4PadString(spec,len(spec)," ",false,tstr);
    end else begin
      M4PadString(spec,40," ",false,tstr);
    end;
    
//    M4PadString(spec,12," ",false,tstr);
    spec = tstr;
    
    CtrlSeq = DCS;
    if (IVrw.vRebate!=0) and (FiscalPrinter==kSerialPortDeviceModelFiscPrinterPOSNETThermal5V) begin
      IVrw.Sum = IVrw.Quant*Ivrw.Price; 
      AddPOSNETInteger(linenr,true,CtrlSeq);
      AddPOSNETInteger(2,false,CtrlSeq);
      CtrlSeq = CtrlSeq & LBTRSLN;
      CtrlSeq = CtrlSeq & spec;
      CtrlSeq = CtrlSeq & CR;
      CtrlSeq = CtrlSeq & qtystr;
      CtrlSeq = CtrlSeq & CR;
      GetPOSNETVATCode(prates,FiscalPrinter,VATCodeRec,IVrw.VATCode,FPVATCode);
      CtrlSeq = CtrlSeq & FPVATCode;
      CtrlSeq = CtrlSeq & "/";
      CtrlSeq = CtrlSeq & pricestr;
      CtrlSeq = CtrlSeq & "/";
      AddPOSNETVal(SysFormatRec,IVrw.Sum,2,true,CtrlSeq);
      AddPOSNETVal(SysFormatRec,IVrw.vRebate,2,true,CtrlSeq);
    end else begin
      AddPOSNETInteger(linenr,false,CtrlSeq);
      CtrlSeq = CtrlSeq & LBTRSLN;
      CtrlSeq = CtrlSeq & spec;
      CtrlSeq = CtrlSeq & CR;
      CtrlSeq = CtrlSeq & qtystr;
      CtrlSeq = CtrlSeq & CR;
      GetPOSNETVATCode(prates,FiscalPrinter,VATCodeRec,IVrw.VATCode,FPVATCode);
      CtrlSeq = CtrlSeq & FPVATCode;
      CtrlSeq = CtrlSeq & "/";
      CtrlSeq = CtrlSeq & pricestr;
      CtrlSeq = CtrlSeq & "/";
      AddPOSNETVal(SysFormatRec,IVrw.Sum,2,true,CtrlSeq);
    end;
    POSNETCheckSum(CtrlSeq);
    CtrlSeq = ConvertStringToCodePage("MAZOVIA",CtrlSeq);
    res = WritePOSNET(CtrlSeq,DELAY,true,replystr);
    if (res!=noErr) then begin
      res2 = SendPOSNETString(cancelstr);
      if (res2==18) or (res==18) then begin
        MessageBox(0,USetStr(12406));
        res = DataBaseRep(spec, FPVATCode);
        res = 1;
        goto LPOSNETPrintBOSLines;
      end;
      MessageBox(0,"error " & USetStr(res));
    end;
    MilliSleep(200);
LSKIPROW:;    
  end;
LPOSNETPrintBOSLines:;  
  POSNETPrintBOSLines = res;
  RETURN;  
END;

function Integer POSNETAcceptBOS_POSNET(record IVVc IVr)
BEGIN
  Integer res;
  Integer footlines;
  record CashPrintBlock CPb;
  record SysFormatBlock SysFormatRec;
  string 255 CtrlSeq,tstr,t2;
  string 3 DCS,ST,LBTREXIT;
  string 1 CR;
  LongInt LONG_DELAY;
  
  LONG_DELAY = 45;
  CR = chr(13);  
  LBTREXIT = "$" & "e";
  DCS = chr(27) & "P";
  ST  = chr(27) & chr(92);

  BlockLoad(SysFormatRec);
  BlockLoad(CPb);
  if (nonblank(CPb.Foot0)) then begin
//    footlines = footlines + 1;
  end;
  if (nonblank(CPb.Foot1)) then begin
//    footlines = footlines + 1;
  end;
  if (nonblank(CPb.Foot2)) then begin
//    footlines = footlines + 1;
  end;
  footlines = 0;
  CtrlSeq = DCS;
  AddPOSNETInteger(1,true,CtrlSeq);
  AddPOSNETInteger(0,false,CtrlSeq);//discoutn = 0
  CtrlSeq = CtrlSeq & LBTREXIT;
  t2 = "00A"; // & CurrentUser;
  if (len(t2)<3) then begin
    t2 = t2 & " ";
  end;
  WinToMaz(t2,tstr);
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & CR;
//  AddPOSNETStrings(CPb,IVr,false,CtrlSeq);//xx
  CtrlSeq = CtrlSeq & "0/";//napisy gotowka i reszta nie beda drukowane
  AddPOSNETVal(SysFormatRec,IVr.Sum4,2,true,CtrlSeq);
  POSNETCheckSum(CtrlSeq);
//StopAlert("Acceptposnet " & CtrlSeq);
  res = CheckPOSNETWrite(LONG_DELAY,CtrlSeq);
//ESC P 1 ; Pr $e <kod> CR WPLATA / TOTAL / <check> ESC \
  POSNETAcceptBOS_POSNET = res;
  RETURN;
END;

function Integer POSNETAcceptBOS(record IVVc IVr,Integer FiscalPrinter)
BEGIN
  Integer res;

  switch (FiscalPrinter) begin
    case kSerialPortDeviceModelFiscPrinterPOSNET1: res = POSNETAcceptBOS_POSNET(IVr);
    case kSerialPortDeviceModelFiscPrinterPOSNET2: res = POSNETAcceptBOS_POSNETY(IVr);
    case kSerialPortDeviceModelFiscPrinterOPTIMUS: res = POSNETAcceptBOS_OPTIMUS(IVr);
//    case kSerialPortDeviceModelFiscPrinterPOSNETThermal5V: res = POSNETAcceptBOS_POSNET(IVr);
    case kSerialPortDeviceModelFiscPrinterPOSNETThermal5V: res = POSNETAcceptBOS_WithPaymentModes(IVr);
  end;
  POSNETAcceptBOS = res;
  RETURN;
END;

procedure ClosePOSNET()
BEGIN
  Integer res;

  res = CloseComPort(0);
  RETURN;
END;

global
procedure POSNETOpenDrawer(record LSerialPortDeviceVc LSPDr,Boolean opencomf)
begin
  Integer res,noErr;
  LongInt DELAY,LONG_DELAY;
  string 20 CtrlSeq;
  string 2 DCS;
  string 255 replystr,ldevice;

//ESC  P  Ps  $d  <string>  ESC  \ 
  ldevice = LSPDr.Port;
  if (blank(ldevice)) then begin
    ldevice = "COM1";
  end;
  DELAY = 10;
  LONG_DELAY = 45;
  switch (LSPDr.Printer) begin
    case kSerialPortDeviceModelFiscPrinterPOSNET1:
      goto LkSerialPortDeviceModelFiscPrinterPOSNETThermal5V;
    case kSerialPortDeviceModelFiscPrinterPOSNET2:
      goto LkSerialPortDeviceModelFiscPrinterPOSNETThermal5V;
    case kSerialPortDeviceModelFiscPrinterOPTIMUS:
      goto LkSerialPortDeviceModelFiscPrinterPOSNETThermal5V;
    case kSerialPortDeviceModelFiscPrinterPOSNETThermal5V:
LkSerialPortDeviceModelFiscPrinterPOSNETThermal5V:;
      if (opencomf) then begin
        res = OpenComPort(0,ldevice,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);
        if (res==0) then begin
          goto LPOSNETOpenDrawer;
        end;
      end;
      DCS = chr(27) & "P";
      CtrlSeq = DCS;
      AddPOSNETInteger(1,false,CtrlSeq);
      CtrlSeq = CtrlSeq & "$d" & chr(27) & "\\";  
      res = WritePOSNET(CtrlSeq,DELAY,true,replystr);
      if (opencomf) then begin
        ClosePOSNET
      end;
    case kSerialPortDeviceModelFiscPrinterPOSNET:
      OpenDrawer_POSNETProtocol(LSPDr,opencomf);
    case kSerialPortDeviceModelFiscPrinterPOSNETTCPIP:
      OpenDrawer_POSNETProtocol_TCP(LSPDr);
    case kSerialPortDeviceModelFiscPrinterPOSNETwVATNr:
      OpenDrawer_POSNETProtocol(LSPDr,opencomf);
  end;
LPOSNETOpenDrawer:;
  return;
end;

function Integer OpenPOSNET(record LSerialPortDeviceVc LSPDr)
BEGIN
  Integer res,noErr;
  LongInt DELAY,LONG_DELAY;
  string 20 CtrlSeq;
  string 2 DCS,LBSERM;
  string 255 replystr;
  string 255 ldevice;
  
  ldevice = LSPDr.Port;
  if (blank(ldevice)) then begin
    ldevice = "COM1";
  end;
  DELAY = 10;
  LONG_DELAY = 45;
  DCS = chr(27) & "P";
  LBSERM = "#" & "e";
  CtrlSeq  = chr(27) & "P" & "#" & "s" & chr(27) & "\\";  
  res = OpenComPort(0,ldevice,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl);
//  res = OpenComPort(0,ldevice,9600,-1,8,0,kFlowControlDefault);
  if (res==1) then begin
    res = noErr;
  end else begin
    goto LOpenPOSNET;
  end;
  res = WritePOSNET(CtrlSeq,LONG_DELAY,true,replystr);
  if (res==noErr) then begin
    CtrlSeq = DCS;
    AddPOSNETInteger(2,false,CtrlSeq);
    CtrlSeq = CtrlSeq & LBSERM;
    AddPOSNETInteger(8,false,CtrlSeq);
    CtrlSeq = CtrlSeq & "B";
    CtrlSeq = CtrlSeq & chr(27) & "\\";
    res = WritePOSNET(CtrlSeq,DELAY,true,replystr);
  end;
/*  
obsluga bledow najpier 2 , powyzej, potem 1 nie dziala
  if (res==noErr) then begin
    CtrlSeq = DCS;
    AddPOSNETInteger(1,false,CtrlSeq);
    CtrlSeq = CtrlSeq & LBSERM;
    POSNETCheckSum(CtrlSeq);
    res = CheckPOSNETWrite(DELAY,CtrlSeq);//error handling 
  end;
*/  
/*baudrate = 9600
  patiry = 0(no)
  bytesize = 8
  stopbits = 0(1 stopbit)
*/  
LOpenPOSNET:;
  OpenPOSNET = res;
  RETURN;
END;

updating procedure PrintPOSNETReceipt(var record IVVc IVr,record LSerialPortDeviceVc LSPDr)
begin
  record IVVc lIVr;
  record IVVc oldIVr;
  string 2 ST;
  string 255 replystr,tstr;
  Integer noErr;
  Array val prates;

  noErr = 0;
  if (OpenPOSNET(LSPDr)==noErr) then begin
    if ((CheckPOSNETClock==noErr) and 
        (LoadPOSNETVATRates(prates,LSPDr.Printer)==noErr)) then begin
      if (POSNETTransBegin(IVr)==noErr) then begin
        if (POSNETPrintBOSLines(IVr,prates,LSPDr.Printer)==noErr) then begin
          if (POSNETAcceptBOS(IVr,LSPDr.Printer)==noErr) then begin//akceptujparagon
//            POSNETOpenDrawer(LSPDr.Printer);
            lIVr.SerNr = IVr.SerNr;
            if (ReadFirstMain(lIVr,1,true)) then begin
              RecordCopy(oldIVr,lIVr);
              lIVr.Prntdf = 1;
              if (RecordUpdate(oldIVr,lIVr,false)==0) then begin
              end;
            end;
          end;
        end;     
      end;     
    end;
    ClosePOSNET;
  end;
      
  return;
end;

procedure CopySerialPortDevice(record SerialPortDeviceVc SPDr,var record LSerialPortDeviceVc LSPDr)
begin
  LSPDr.Code = SPDr.Code;
  LSPDr.DeviceType = SPDr.DeviceType;
  LSPDr.LocalMachineCode = SPDr.LocalMachineCode;
  LSPDr.Printer = SPDr.Printer;
  LSPDr.Port = SPDr.Port;
  LSPDr.BaudRate = SPDr.BaudRate;
  LSPDr.ByteSize = SPDr.ByteSize;
  LSPDr.Parity = SPDr.Parity;
  LSPDr.StopBits = SPDr.StopBits;
  LSPDr.Codepage = SPDr.Codepage;
  LSPDr.FlowControl = SPDr.FlowControl;
  LSPDr.EscSeqBefore = SPDr.EscSeqBefore;
  LSPDr.EscSeqAfter = SPDr.EscSeqAfter;
  LSPDr.FailureCode = SPDr.FailureCode;
  return;
end;

global
updating procedure StoreLocalSerialPortDevice(record LSerialPortDeviceVc LSPDr)
begin
  RecordStore(LSPDr,true);
  return;
end;

global
function Boolean FindLocalSerialPortDevice(Integer type,LongInt printer,string machinecode,var record LSerialPortDeviceVc LSPDr)
begin
  Boolean res;
  record SerialPortDeviceVc SPDr;
  string 255 index;
  Integer segs;
  
  if (machinecode=="") then begin
    goto LFindLocalSerialPortDevice;
  end;
  
  index = "DeviceType";
  segs = 2;
  LSPDr.DeviceType = type;
  LSPDr.LocalMachineCode = machinecode;
  if (printer>0) then begin
    index = "Printer";
    segs = 3;
    LSPDr.Printer = printer;
  end;
  if (ReadFirstKey(index,LSPDr,segs,true)) then begin
    res = true;
  end else begin
    SPDr.DeviceType = type;
    SPDr.LocalMachineCode = machinecode;
    SPDr.Printer = printer;
    if (ReadFirstKey(index,SPDr,segs,true)) then begin
      CopySerialPortDevice(SPDr,LSPDr);
      queued.StoreLocalSerialPortDevice(LSPDr);
      res = true;
    end;
  end;

LFindLocalSerialPortDevice:;
  FindLocalSerialPortDevice = res;
  return;
end;

global
updating procedure IVVc_PrintToFiscalPrinter(var record IVVc IVr,Boolean forceprintf)
BEGIN
  record CashPrintBlock CPb;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  record LSerialPortDeviceVc LSPDr;
    
  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalPrinter,-1,LMb.LocalMachineCode,LSPDr)==false) then begin  
//old way  
    BlockLoad(CPb);  
    MCr.Code = LMb.LocalMachineCode;
    if (ReadFirstMain(MCr,1,true)) then begin
      LSPDr.Printer = MCr.FiscalPrinter;
      LSPDr.Port = MCr.CommPort;
    end;
    if (LSPDr.Printer==0) then begin
      LSPDr.Printer = CPb.FiscalPrinter;
      if (blank(LSPDr.Port)) then begin
        LSPDr.Port = CPb.CommPort;
      end;
    end;
    switch (LSPDr.Printer) begin
      case 11:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 12:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 13:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 14:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 15:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 1; LSPDr.FlowControl = kFlowControlDefault;
      case 16:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 17:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 40:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
    end;
  end;
  if (blank(LSPDr.Port)) then begin
    LSPDr.Port = LMb.DefPrinter;
  end;

  if ((IVr.FiscalFlag!=0) and (IVr.OKFlag!=0) and ((IVr.Prntdf==0) or forceprintf)) then begin
    switch (LSPDr.Printer) begin
      case kSerialPortDeviceModelFiscPrinterPOSNET:
        PrintPOSNETReceipt_withPOSNETProtocol(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNETTCPIP:
        PrintPOSNETReceipt_withPOSNETProtocol_TCP(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNETwVATNr:
        PrintPOSNETReceipt_withPOSNETProtocol(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNET1:
        PrintPOSNETReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNET2:
        PrintPOSNETReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterOPTIMUS:
        PrintPOSNETReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNETThermal5V:
        PrintPOSNETReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFP3000:
        PrintFM3000Receipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterHASAR:
        PrintHASARReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterHASARPL23F:
        PrintHASARPL23FPANReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterEPSON:
        PrintEPSONINVOICEReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFI550:
        PrintFI550Receipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterEPSONTMU220:
        PrintEpsonTMUReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterTSLFP05:
        IVVc_PrintTSLReceipt(IVr,LSPDr,0,true,false,0);
      case kSerialPortDeviceModelFiscPrinterFB05:
        PrintFB05Receipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFB15:
        PrintFB15Receipt_IVVc(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFB15DLL:
        PrintFB15Receiptdll_IVVc(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFM32DLL:
        PrintFM32Receiptdll_IVVc(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterST05:
        PrintST05Receipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterFPRINT02K:
        PMsg_PrintReceipt(LSPDr,IVr);
        RecordStore(IVr,true);
      case kSerialPortDeviceModelFiscPrinterRCHFlea:
        IVVc_PrintRCHFleaReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterEPSONTMT81F:
        PrintEpsonTMTReceipt(IVr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterBematechMP2100:
        IVVc_PrintBematechMP2100Receipt(IVr,LSPDr);
    end;
  end;
  return;
end;

global
updating procedure PrintPOSNETReceiptDsm()
BEGIN
  Integer wn;
  record IVVc IVr;

  wn = CurWindow;
  DeselectWindow(wn,false);
  GetWindowRecord(wn,IVr);
  IVVc_PrintToFiscalPrinter(IVr,false);
  PutWindowRecord(wn,IVr);
  RETURN;
END;

global
updating function Boolean IVVc_PrintToFiscalControlUnit(var record IVVc IVr)
begin
  Boolean res;
  record LocalMachineBlock LMb;
  record LSerialPortDeviceVc LSPDr;
    
  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalControlUnit,-1,LMb.LocalMachineCode,LSPDr)) then begin  
    switch (LSPDr.Printer) begin
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeA:
        if ((IVr.OKFlag!=0) and ((blank(IVr.OfficialSerNr)) or (blank(IVr.OfficialSerNr2)))) then begin
          res = StoreCleanCashReceipt(LMb,IVr,LSPDr);
        end else begin
          if ((nonblank(IVr.OfficialSerNr)) and (nonblank(IVr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeC:
        if ((IVr.OKFlag!=0) and ((blank(IVr.OfficialSerNr)) or (blank(IVr.OfficialSerNr2)))) then begin
          res = StoreCleanCashReceiptClient(LMb,IVr,LSPDr);
        end else begin
          if ((nonblank(IVr.OfficialSerNr)) and (nonblank(IVr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
    end;
  end;
  IVVc_PrintToFiscalControlUnit = res;
  return;
end;

global
updating function Boolean IVCashVc_PrintToFiscalControlUnit(var record IVCashVc IVCashr)
begin
  Boolean res;
  record LocalMachineBlock LMb;
  record LSerialPortDeviceVc LSPDr;
    
  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalControlUnit,-1,LMb.LocalMachineCode,LSPDr)) then begin  
    switch (LSPDr.Printer) begin
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeA:
        if ((IVCashr.OKFlag!=0) and ((blank(IVCashr.OfficialSerNr)) or (blank(IVCashr.OfficialSerNr2)))) then begin
          if (IVCashr.Invalid==0) then begin
            res = StoreCleanCashIVCashReceipt(LMb,IVCashr,LSPDr);
          end;
        end else begin
          if ((nonblank(IVCashr.OfficialSerNr)) and (nonblank(IVCashr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeC:
        if ((IVCashr.OKFlag!=0) and ((blank(IVCashr.OfficialSerNr)) or (blank(IVCashr.OfficialSerNr2)))) then begin
          if (IVCashr.Invalid==0) then begin
            res = StoreCleanCashIVCashReceiptClient(LMb,IVCashr,LSPDr);
          end;
        end else begin
          if ((nonblank(IVCashr.OfficialSerNr)) and (nonblank(IVCashr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
    end;
  end;
  IVCashVc_PrintToFiscalControlUnit = res;
  return;
end;

global
updating function Boolean RestAccVc_PrintToFiscalControlUnit(var record RestAccVc RestAccr)
begin
  Boolean res;
  record LocalMachineBlock LMb;
  record LSerialPortDeviceVc LSPDr;
    
  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalControlUnit,-1,LMb.LocalMachineCode,LSPDr)) then begin  
    switch (LSPDr.Printer) begin
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeA:
        if ((RestAccr.Closed!=0) and ((blank(RestAccr.OfficialSerNr)) or (blank(RestAccr.OfficialSerNr2)))) then begin
          if (RestAccr.Invalid==0) then begin
            res = StoreCleanCashRestAccReceipt(LMb,RestAccr,LSPDr);
          end;
        end else begin
          if ((nonblank(RestAccr.OfficialSerNr)) and (nonblank(RestAccr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
      case kSerialPortDeviceModelFiscPrinterCLEANCASHTypeC:
        if ((RestAccr.Closed!=0) and ((blank(RestAccr.OfficialSerNr)) or (blank(RestAccr.OfficialSerNr2)))) then begin
          if (RestAccr.Invalid==0) then begin
            res = StoreCleanCashRestAccReceiptClient(LMb,RestAccr,LSPDr);
          end;
        end else begin
          if ((nonblank(RestAccr.OfficialSerNr)) and (nonblank(RestAccr.OfficialSerNr2))) then begin
            MessageBox(12388,"");
          end;
        end;
    end;
  end;
  RestAccVc_PrintToFiscalControlUnit = res;
  return;
end;


global
updating procedure RestAccVc_PrintToFiscalPrinter(var record RestAccVc RestAccr,Boolean forceprintf)
BEGIN
  record CashPrintBlock CPb;
  record LocalMachineBlock LMb;
  record MachineCashVc MCr;
  record LSerialPortDeviceVc LSPDr;
    
  BlockLoad(LMb);  
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassFiscalPrinter,-1,LMb.LocalMachineCode,LSPDr)==false) then begin  
//old way  
    BlockLoad(CPb);  
    MCr.Code = LMb.LocalMachineCode;
    if (ReadFirstMain(MCr,1,true)) then begin
      LSPDr.Printer = MCr.FiscalPrinter;
      LSPDr.Port = MCr.CommPort;
    end;
    if (LSPDr.Printer==0) then begin
      LSPDr.Printer = CPb.FiscalPrinter;
      if (blank(LSPDr.Port)) then begin
        LSPDr.Port = CPb.CommPort;
      end;
    end;
    switch (LSPDr.Printer) begin
      case 11:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 12:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 13:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 14:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 15:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 1; LSPDr.FlowControl = kFlowControlDefault;
      case 16:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 17:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
      case 40:
        LSPDr.BaudRate = 9600; LSPDr.Parity = -1; LSPDr.ByteSize = 8; LSPDr.StopBits = 0; LSPDr.FlowControl = kFlowControlDefault;
    end;
  end;
  if (blank(LSPDr.Port)) then begin
    LSPDr.Port = LMb.DefPrinter;
  end;
  if ((RestAccr.FiscalFlag!=0) and (RestAccr.Closed!=0) and ((RestAccr.Prntdf==0) or forceprintf)) then begin
    switch (LSPDr.Printer) begin
      case kSerialPortDeviceModelFiscPrinterPOSNET:
        PrintPOSNETReceiptRestAcc_withPOSNETProtocol(RestAccr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNETTCPIP:
        PrintPOSNETReceiptRestAcc_withPOSNETProtocol_TCP(RestAccr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterPOSNETwVATNr:
        PrintPOSNETReceiptRestAcc_withPOSNETProtocol(RestAccr,LSPDr);
      case kSerialPortDeviceModelFiscPrinterTSLFP05:
        RestAccVc_PrintTSLReceipt(RestAccr,LSPDr,false);
      case kSerialPortDeviceModelFiscPrinterBematechMP2100:
        RestAccVc_PrintBematechMP2100Receipt(RestAccr,LSPDr);
    end;
  end;
  return;
end;
