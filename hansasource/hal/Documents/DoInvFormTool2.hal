external function Date DateFromString(string,string);
external procedure FindSourcePU(LongInt,var record ItemHistVc);
external function roundmode GetVATRoundModeRB();
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode GetTotalRoundMode(record RoundBlock);
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external function roundmode DefaultRoundMode();
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Date FindTaxAuthIDToDate(record IVVc);
external function string 255 FindTaxAuthIDControlCode(string,record IVVc);
external function string 255 FindTaxAuthID(string,record IVVc);
external procedure StripSpace(var string,string);
external procedure GetFieldArgument(record DocVc,Integer,var string);
external procedure PrintValueInclZero(string,val,Integer,record LangNrVc,record SysFormatBlock,Boolean);
external procedure GetVATproc(string,Integer,var val);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure GetCountryName(string,string,var string);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure PrintValue(string,val,Integer,record LangNrVc,record SysFormatBlock,Boolean);
external procedure InvVat(Integer,Integer,Integer,Integer,string,val,var val,var val,var val,var val,var val);
external procedure FinnishBankVal(var string,val);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external procedure FinnishBankDate(var string,Date);

function Integer SetWinBCSpecChar(Integer pos,Array Integer bc128_Key)
BEGIN
  switch (pos) begin
    case 0:   bc128_Key[pos] = 206; //"Œ";
    case 95:  bc128_Key[pos] = 207; //"œ";
    case 96:  bc128_Key[pos] = 199; //"«";
    case 97:  bc128_Key[pos] = 252; //"¸";
    case 98:  bc128_Key[pos] = 233; //"È";
    case 99:  bc128_Key[pos] = 226; //"‚";
    case 100: bc128_Key[pos] = 228; //"‰";
    case 101: bc128_Key[pos] = 224; //"‡";
    case 102: bc128_Key[pos] = 225; //"·";
    case 103: bc128_Key[pos] = 231; //"Á";
    case 104: bc128_Key[pos] = 234; //"Í";
    case 105: bc128_Key[pos] = 235; //"Î";
  end;
  SetWinBCSpecChar = pos;
  RETURN;
END;

function Integer SetMacBCSpecChar(Integer pos,Array Integer bc128_Key)
BEGIN
  switch (pos) begin
    case 0:   bc128_Key[pos] = 148; //"î";
    case 95:  bc128_Key[pos] = 149; //"ï";
    case 96:  bc128_Key[pos] = 130; //"Ç";
    case 97:  bc128_Key[pos] = 159; //"ü";
    case 98:  bc128_Key[pos] = 142; //"é";
    case 99:  bc128_Key[pos] = 137; //"â";
    case 100: bc128_Key[pos] = 138; //"ä";
    case 101: bc128_Key[pos] = 136; //"à";
    case 102: bc128_Key[pos] = 135; //"á";
    case 103: bc128_Key[pos] = 141; //"ç";
    case 104: bc128_Key[pos] = 144; //"ê";
    case 105: bc128_Key[pos] = 145; //"ë";
  end;
  SetMacBCSpecChar = pos;
  RETURN;
END;

function Integer SetBCSpecChar(Integer pos,Array Integer bc128_Key)
BEGIN
  Integer res;
  
/* what about unix ##??## */
  if (windowsMode==1) then begin
    res = SetWinBCSpecChar(pos,bc128_Key);
  end else begin
    res = SetWinBCSpecChar(pos,bc128_Key);
//    res = SetMacBCSpecChar(pos,bc128_Key);
  end;
  SetBCSpecChar = pos;
  RETURN;
END;

global
procedure FillBC128(Array Integer bc128_Key,Array Integer bc128_C)
BEGIN
  bc128_Key[0] = 148; bc128_C[0] = 0; // "î";
  bc128_Key[1] = 33;  bc128_C[1] = 1; // "!";
  bc128_Key[2] = 34; bc128_C[2] = 2; // """"; 
  bc128_Key[3] = 35; bc128_C[3] = 3; // "#"; 
  bc128_Key[4] = 36; bc128_C[4] = 4; // "$"; 
  bc128_Key[5] = 37; bc128_C[5] = 5; // "%"; 
  bc128_Key[6] = 38; bc128_C[6] = 6; // "&"; 
  bc128_Key[7] = 39; bc128_C[7] = 7; // "'"; 
  bc128_Key[8] = 40; bc128_C[8] = 8; // "("; 
  bc128_Key[9] = 41; bc128_C[9] = 9; // ")"; 
  bc128_Key[10] = 42; bc128_C[10] = 10; // "*"; 
  bc128_Key[11] = 43; bc128_C[11] = 11; // "+"; 
  bc128_Key[12] = 44; bc128_C[12] = 12; // ","; 
  bc128_Key[13] = 45; bc128_C[13] = 13; // "-"; 
  bc128_Key[14] = 46; bc128_C[14] = 14; // "."; 
  bc128_Key[15] = 47; bc128_C[15] = 15; // "/"; 
  bc128_Key[16] = Asc("0"); bc128_C[16] = 16;
  bc128_Key[17] = Asc("1"); bc128_C[17] = 17;
  bc128_Key[18] = Asc("2"); bc128_C[18] = 18;
  bc128_Key[19] = Asc("3"); bc128_C[19] = 19;
  bc128_Key[20] = Asc("4"); bc128_C[20] = 20;
  bc128_Key[21] = Asc("5"); bc128_C[21] = 21;
  bc128_Key[22] = Asc("6"); bc128_C[22] = 22;
  bc128_Key[23] = Asc("7"); bc128_C[23] = 23;
  bc128_Key[24] = Asc("8"); bc128_C[24] = 24;
  bc128_Key[25] = Asc("9"); bc128_C[25] = 25;
  bc128_Key[26] = Asc(":"); bc128_C[26] = 26;
  bc128_Key[27] = Asc(";"); bc128_C[27] = 27;
  bc128_Key[28] = Asc("<"); bc128_C[28] = 28;
  bc128_Key[29] = Asc("="); bc128_C[29] = 29;
  bc128_Key[30] = Asc(">"); bc128_C[30] = 30;
  bc128_Key[31] = Asc("?"); bc128_C[31] = 31;
  bc128_Key[32] = Asc("@"); bc128_C[32] = 32;
  bc128_Key[33] = Asc("A"); bc128_C[33] = 33;
  bc128_Key[34] = Asc("B"); bc128_C[34] = 34;
  bc128_Key[35] = Asc("C"); bc128_C[35] = 35;
  bc128_Key[36] = Asc("D"); bc128_C[36] = 36;
  bc128_Key[37] = Asc("E"); bc128_C[37] = 37;
  bc128_Key[38] = Asc("F"); bc128_C[38] = 38;
  bc128_Key[39] = Asc("G"); bc128_C[39] = 39;
  bc128_Key[40] = Asc("H"); bc128_C[40] = 40;
  bc128_Key[41] = Asc("I"); bc128_C[41] = 41;
  bc128_Key[42] = Asc("J"); bc128_C[42] = 42;
  bc128_Key[43] = Asc("K"); bc128_C[43] = 43;
  bc128_Key[44] = Asc("L"); bc128_C[44] = 44;
  bc128_Key[45] = Asc("M"); bc128_C[45] = 45;
  bc128_Key[46] = Asc("N"); bc128_C[46] = 46;
  bc128_Key[47] = Asc("O"); bc128_C[47] = 47;
  bc128_Key[48] = Asc("P"); bc128_C[48] = 48;
  bc128_Key[49] = Asc("Q"); bc128_C[49] = 49;
  bc128_Key[50] = Asc("R"); bc128_C[50] = 50;
  bc128_Key[51] = Asc("S"); bc128_C[51] = 51;
  bc128_Key[52] = Asc("T"); bc128_C[52] = 52;
  bc128_Key[53] = Asc("U"); bc128_C[53] = 53;
  bc128_Key[54] = Asc("V"); bc128_C[54] = 54;
  bc128_Key[55] = Asc("W"); bc128_C[55] = 55;
  bc128_Key[56] = Asc("X"); bc128_C[56] = 56;
  bc128_Key[57] = Asc("Y"); bc128_C[57] = 57;
  bc128_Key[58] = Asc("Z"); bc128_C[58] = 58;
  bc128_Key[59] = 91; bc128_C[59] = 59; // "[";
  bc128_Key[60] = 92; bc128_C[60] = 60; // "\\"; 
  bc128_Key[61] = 93; bc128_C[61] = 61; // "]";
  bc128_Key[62] = 94; bc128_C[62] = 62; // "^";
  bc128_Key[63] = 95; bc128_C[63] = 63; // "_";
  bc128_Key[64] = 96; bc128_C[64] = 64; // "`";
  bc128_Key[65] = Asc("a"); bc128_C[65] = 65;
  bc128_Key[66] = Asc("b"); bc128_C[66] = 66;
  bc128_Key[67] = Asc("c"); bc128_C[67] = 67;
  bc128_Key[68] = Asc("d"); bc128_C[68] = 68;
  bc128_Key[69] = Asc("e"); bc128_C[69] = 69;
  bc128_Key[70] = Asc("f"); bc128_C[70] = 70;
  bc128_Key[71] = Asc("g"); bc128_C[71] = 71;
  bc128_Key[72] = Asc("h"); bc128_C[72] = 72;
  bc128_Key[73] = Asc("i"); bc128_C[73] = 73;
  bc128_Key[74] = Asc("j"); bc128_C[74] = 74;
  bc128_Key[75] = Asc("k"); bc128_C[75] = 75;
  bc128_Key[76] = Asc("l"); bc128_C[76] = 76;
  bc128_Key[77] = Asc("m"); bc128_C[77] = 77;
  bc128_Key[78] = Asc("n"); bc128_C[78] = 78;
  bc128_Key[79] = Asc("o"); bc128_C[79] = 79;
  bc128_Key[80] = Asc("p"); bc128_C[80] = 80;
  bc128_Key[81] = Asc("q"); bc128_C[81] = 81;
  bc128_Key[82] = Asc("r"); bc128_C[82] = 82;
  bc128_Key[83] = Asc("s"); bc128_C[83] = 83;
  bc128_Key[84] = Asc("t"); bc128_C[84] = 84;
  bc128_Key[85] = Asc("u"); bc128_C[85] = 85;
  bc128_Key[86] = Asc("v"); bc128_C[86] = 86;
  bc128_Key[87] = Asc("w"); bc128_C[87] = 87;
  bc128_Key[88] = Asc("x"); bc128_C[88] = 88;
  bc128_Key[89] = Asc("y"); bc128_C[89] = 89;
  bc128_Key[90] = Asc("z"); bc128_C[90] = 90;
  bc128_Key[91] = 123; bc128_C[91] = 91; // "{";
  bc128_Key[92] = 124; bc128_C[92] = 92; // "|";
  bc128_Key[93] = 125; bc128_C[93] = 93; // "}";
  bc128_Key[94] = 126; bc128_C[94] = 94; // "~";
  
  bc128_C[95]   = SetBCSpecChar(95,bc128_Key);
  bc128_C[96]   = SetBCSpecChar(96,bc128_Key);
  bc128_C[97]   = SetBCSpecChar(97,bc128_Key);
  bc128_C[98]   = SetBCSpecChar(98,bc128_Key);
  bc128_C[99]   = SetBCSpecChar(99,bc128_Key);
  bc128_C[100]  = SetBCSpecChar(100,bc128_Key);
  bc128_C[101]  = SetBCSpecChar(101,bc128_Key);
  bc128_C[102]  = SetBCSpecChar(102,bc128_Key);
  bc128_C[103]  = SetBCSpecChar(103,bc128_Key);
  bc128_C[104]  = SetBCSpecChar(104,bc128_Key);
  bc128_C[105]  = SetBCSpecChar(105,bc128_Key);
  bc128_C[0]    = SetBCSpecChar(0,bc128_Key);
  RETURN;
END;

procedure strppadright(var string outStrng,string inStrng,string padchar,Integer destlen)
BEGIN
  Integer i,j,m;
  
  j = len(inStrng);
  outStrng = "";
  
  if (j>destlen) then begin
    for (i=0;i<j;i=i+1) begin
      outStrng = outStrng & Mid(inStrng,i,1);  
    end;
  end else begin
    m = destlen - j;  
    outStrng = outStrng & inStrng;
    for (i=0;i<m;i=i+1) begin
      outStrng = outStrng & padchar;  
    end;
  end;
  RETURN;
END;

procedure strppadleft(var string outStrng,string inStrng,string padchar,Integer destlen)
BEGIN
  Integer i,j,m;
  
  j = len(inStrng);
  outStrng = "";
  if (j>destlen) then begin
    for (i=0;i<j;i=i+1) begin
      outStrng = outStrng & Mid(inStrng,i,1);  
    end;
  end else begin
    m = destlen - j;  
    for (i=0;i<m;i=i+1) begin
      outStrng = outStrng & padchar;  
    end;
    outStrng = outStrng & inStrng;
  end;
  RETURN;
END;

function Integer FinnishIdentifyBank(string bacc)
BEGIN
  Integer res;
  string 255 t2;
  
  res = 1;//KOP
  t2 = StripNonDigits(bacc);

  if (len(t2)>=2) then begin
    res = asc(Mid(t2,0,1)) - asc("0");    /* this converts the char to bank number */
    if (res==7) then begin//STSPPOY
      res = res*10;
      res = res + asc(Mid(t2,1,1)) - asc("0");
    end;
    if (res==3) then begin//HOP
      res = res*10;
      res = res + asc(Mid(t2,1,1)) - asc("0");
    end;
  end;  
  FinnishIdentifyBank = res;
  RETURN;
END;

global
procedure FinnishBankacc(var string toAcct,string fromAcct)
BEGIN
  Integer theBank;
  string 255 tempAcct,t2,t3;
  Integer t,i;
  Integer OfficeLen;
  Integer SP,OP,PPOY,ACCTLEN;

  SP = 4;
  OP = 5;
  ACCTLEN = 14;
  PPOY = 70;
  tempAcct = StripNonDigits(fromAcct);
  toAcct = "";;
  theBank = FinnishIdentifyBank(tempAcct);  
  switch (theBank) begin
    case 4://SP
      OfficeLen = 7;
    case 5://OP
      OfficeLen = 7;
    case 70: //SP
      OfficeLen = 7;
    otherwise
      OfficeLen = 6;
  end;
  t = len(tempAcct);
  if (t>OfficeLen) then begin t = OfficeLen; end;
  for (i=0;i<t;i=i+1) begin
    toAcct = toAcct & Mid(tempAcct,i,1);
  end;     
  t = len(tempAcct);
  t2 = "";
  for (i=OfficeLen;i<=t;i=i+1) begin
    t2 = t2 & Mid(tempAcct,i,1);
  end;  
  t3 = toAcct;
  strppadright(toAcct,t3,"0",OfficeLen); 
  strppadleft(tempAcct,t2,"0",14 - OfficeLen);// ACCTLEN - OfficeLen
  toAcct = toAcct & tempAcct;
  RETURN;
END;

global
procedure FinRefChecksum1(var string ref)
BEGIN
  Integer i;
  Integer sm,s1;
  
  s1 = 0;
  for (i=(len(ref)-1);i>=0;i=i-1) begin
    switch (Mod(((len(ref)-1)-i),3)) begin
      case 0: sm = 7;
      case 1: sm = 3;
      otherwise sm = 1;
    end;
    s1 = s1 + sm*(asc(Mid(ref,i,1))-48);
  end;
  sm =  Mod(10 - Mod(s1,10),10);
  ref = ref & uchr(sm+48);
  RETURN;
END;

function Integer BC128Key(Integer v,Array Integer bc128_Key,Array Integer bc128_C)
BEGIN
  Integer i;
  Integer res;
  
  res = asc(" ");
  for (i=0;i<106;i=i+1) begin
    if (bc128_C[i]==v) then begin
      res = bc128_Key[i];
      goto LBC128Key;
    end;
  end;
LBC128Key:;  
  BC128Key = res;
  RETURN;
END;

global
procedure ConvertToBC128(var string tstr,var string bc,Array Integer tstri,var integer tstrlen,Array Integer bc128_Key,Array Integer bc128_C)
BEGIN
  Integer i,pos;
  string 255 t;
  Integer v,v2;
  
  tstrlen = 0;
  pos = 1;
  if (BitAnd(len(tstr),1)==1) then begin  
    tstr = tstr & "0";
  end;
  for (i=0;i<len(tstr);i=i+2) begin
    t = Mid(tstr,i,1);
    t = t & Mid(tstr,i+1,1);
    v = StringToInt(t);
    v2 = BC128Key(v,bc128_Key,bc128_C);
    tstri[tstrlen] = v2;
    bc = bc & chr(v2);
    tstrlen = tstrlen + 1;
  end;
  RETURN;
END;

function Integer BC128Val(Integer c,Array Integer bc128_Key,Array Integer bc128_C)
BEGIN
  Integer i;
  Integer res;
  
  for (i=0;i<106;i=i+1) begin
    if (bc128_Key[i]==c) then begin
      res = bc128_C[i];
      goto LBC128Val;
    end;
  end;
LBC128Val:;  
  BC128Val = res;
  RETURN;
END;

global
procedure FinRefChecksum2(var string ref,Array Integer tstri,Integer tstrlen,Array Integer bc128_Key,Array Integer bc128_C)
BEGIN
  Integer i,v;
  Integer sum;
  
  sum = 105;
  for (i=0;i<tstrlen;i=i+1) begin
    v = BC128Val(tstri[i],bc128_Key,bc128_C);
    v = v * (i+1);
    sum = sum + v;
  end;
  sum = Mod(sum,103);
  ref = ref & uchr(BC128Key(sum,bc128_Key,bc128_C));
  RETURN;
END;

procedure AddWinBC128Flags(var string tstr)
BEGIN
  string 255 t2;
  
  t2 = chr(235) & tstr & chr(232) & chr(214); // "Î"; // & "Ë÷";
  tstr = t2;
  RETURN;
END;

procedure AddMacBC128Flags(var string tstr)
BEGIN
  string 255 t2;
  
  t2 = chr(145) & tstr & chr(143) & chr(133); // "ë"; // & "èÖ";
  tstr = t2;
  RETURN;
END;

global
procedure AddBC128Flags(var string tstr)
BEGIN
/* what about unix ##??## */
  if (windowsMode==1) then begin
    AddWinBC128Flags(tstr);
  end else begin
    AddMacBC128Flags(tstr);
  end;
  RETURN;
END;

global
procedure PrintFINREFBC128(record DocVc Docr,string CurncyCode,val Sum, string CalcFinRef,Date PayDate)
BEGIN
  record CYBlock CompYear;
  Array Integer bc128_Key;
  Array Integer bc128_C;
  Array Integer tstri;
  Integer tstrlen;
  string 255 tstr,t2,t3,res;
  val t,tm;
  row DocVc Docrw;
  Integer i,rwcnt;
  record StyleVc Styler;
  Integer BarcodeType;

  rwcnt = MatRowCnt(Docr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Docr,i,Docrw);
    if (Docrw.fieldSetNr==F_FINREFBC128) then begin
      res = Docrw.unitText;
      Styler.Code = Docrw.unitStyle;
      ReadFirstMain(Styler,1,true);
      BarcodeType = Styler.BarcodeType;
      i = rwcnt;
    end;
  end;

  BlockLoad(CompYear);
  FillBC128(bc128_Key,bc128_C);
  if (CurncyCode=="EUR") then begin
    tstr = "4";
  end else begin
    tstr = "1";
  end;
  FinnishBankacc(t2,CompYear.Bank1);
  tstr = tstr & t2;
  tm = 999999.99;
  if (Sum>tm) then begin
    t = 0;
  end else begin
    t = Sum;
  end;
  FinnishBankVal(t2,t);
  M4PadString(t2,8,"0",true,t3);  
  tstr = tstr & t3;
  tstr = tstr & "000";//reserved
  t2 = CalcFinRef;
  StripSpace(t3,t2);
  M4PadString(t3,20,"0",true,t2);
  tstr = tstr & t2;
  FinnishBankDate(t2,PayDate);
  tstr = tstr & t2;
  FinRefChecksum1(tstr);

  switch (BarcodeType) begin
    case kBarcodeCode39:
      res = tstr;
    case kBarcodeCode128:
      res = tstr;
    otherwise
      ConvertToBC128(tstr,res,tstri,tstrlen,bc128_Key,bc128_C);
      FinRefChecksum2(res,tstri,tstrlen,bc128_Key,bc128_C);
      AddBC128Flags(res);
  end;
  OutFormField("F_FINREFBC128",res);
  RETURN;  
END;     

global
procedure PrintFINREF(record IVVc IVr,record DocVc Docr)
BEGIN
  PrintFINREFBC128(Docr,IVr.CurncyCode,IVr.Sum4,IVr.CalcFinRef,IVr.PayDate);
/*
  string 255 tstr,t2,t3,res;
  val t,tm;
  record CYBlock CompYear;
  Array Integer bc128_Key;
  Array Integer bc128_C;
  Array Integer tstri;
  Integer tstrlen;
  
  BlockLoad(CompYear);
  FillBC128(bc128_Key,bc128_C);

//  if (IVr.CurncyCode=="EUR") then begin
    tstr = "4";
//  end else begin
//    tstr = "1";
//  end;
  FinnishBankacc(t2,CompYear.Bank1);
  tstr = tstr & t2;
  tm = 999999.99;
  if (IVr.Sum4>tm) then begin
    t = 0;
  end else begin
    t = IVr.Sum4;
  end;
  FinnishBankVal(t2,t);
  M4PadString(t2,8,"0",true,t3);  
  tstr = tstr & t3;
  tstr = tstr & "000";//reserved
  t2 = IVr.CalcFinRef;
  StripSpace(t3,t2);
  M4PadString(t3,20,"0",true,t2);
  tstr = tstr & t2;
  FinnishBankDate(t2,IVr.PayDate);
  tstr = tstr & t2;
  FinRefChecksum1(tstr);
  ConvertToBC128(tstr,res,tstri,tstrlen,bc128_Key,bc128_C);
  FinRefChecksum2(res,tstri,tstrlen,bc128_Key,bc128_C);
  AddBC128Flags(res);
  OutFormField("F_FINREFBC128",res);
*/
  RETURN;
END;    

global
procedure PrintPurchVal(record IVVc IVr,record LangNrVc LangNrr,record SysFormatBlock SysFormatRec)
BEGIN
  row IVVc IVrw;
  Integer i,rwcnt;
  val tot;
  val t,t1,v;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;
  record AccBlock ARAccRec;
  Boolean negamountf;
  
  BlockLoad(ARAccRec);
  negamountf = (ARAccRec.PrintNegAmountsCredNote!=0 and (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales));
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVr.InclVAT==0) then begin
      MulVATIV(IVrw.VATCode,IVrw.Price,t,t1,0,0);
      t = t + IVrw.Price;
    end else begin
      t = IVrw.Price*IVrw.vRebate;
      t = t/100;
      v = IVrw.Price - t;
      InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
      t = v - vatval;      
    end;
    tot = tot + t;
  end;
  PrintValue("F_PURCHVAL",tot,M4Val,LangNrr,SysFormatRec,negamountf);
  RETURN;        
END;

global
procedure GetCustomsDeclarationNumber(string filename,LongInt transnr,LongInt rownr,string artcode,string serialnr,Integer ac,var string res)
BEGIN
  record ItemHistVc IHr;
  record ItemHistVc PUsourceIHr;
  record PUVc PUr;
  row PUVc PUrw;
  Integer i,rwcnt;
  Boolean found;
  
  res = "";
  if (nonblank(filename)) and (transnr>0) and (rownr>=0) then begin
    IHr.FileName = filename;
    IHr.TransNr = transnr;
    IHr.Row = rownr;
    found = ReadFirstKey("FNTransNr",IHr,3,true);
    if (found) then begin
       FindSourcePU(IHr.SerNr,PUsourceIHr);
       PUr.SerNr = PUsourceIHr.TransNr;
       found = ReadFirstMain(PUr,1,true);
    end;
  end;
  if (found==false) then begin
    IHr.ArtCode = artcode;
    IHr.SerialNr = serialnr;
    IHr.FileName = "PUVc";
    if (ReadFirstKey("ArtCodeSerialNr",IHr,3,true)) then begin
      PUr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PUr,1,true)) then begin
      end;  
    end;
  end;
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if ((PUrw.ArtCode==artcode) and (PUrw.SerialNr==serialnr)) then begin
      switch (ac) begin
        case 0:
          res = PUrw.CustomsNr;
        case 1:
          GetCountryName(PUrw.CountryOfOrg,PUr.LangCode,res);
        case 2:
          res = PUrw.CountryOfOrg;
        case 3:
          res = DateToString(PUrw.CustomsDate,"DD/MM/YYYY");
      end;    
    end;
  end;      
  RETURN;
END;

global
procedure RebPay2(record IVVc ivrp,record RoundBlock RoundRec,Integer base,Boolean what,var string res)
BEGIN
  val tv,t100;
  record AccBlock atr;
  
  res = "";
  BlockLoad(atr);
  if (ivrp.pdvrebt2!=0) then begin
    t100 = 100;
    if (atr.DiscCashVAT!=0) then begin
      tv = 100 - ivrp.pdvrebt2;
      tv = tv*ivrp.Sum1;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      if (HasLocalization("GBR")) then begin
        tv = tv + ivrp.Sum3;
      end;
      if (what) then begin
        tv = ivrp.Sum1 - tv;
      end;
    end else begin
      tv = t100 - ivrp.pdvrebt2;
      tv = tv*ivrp.Sum4;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      if (what) then begin
        tv = ivrp.Sum4 - tv;
      end;
    end;
    switch (base) begin
      case 0: 
      case 1: tv = MulRateToBase1(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
      case 2: tv = MulRateToBase2(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
    end;
    res = tv;
  end;
  RETURN;
END;

procedure AddToDownPayArray(LongInt ivnr,Array LongInt anr,Array Date atd,var Integer acnt)
BEGIN
  record IVVc dpIVr;
  Integer i;
  
  for (i=0;i<acnt;i=i+1) begin
    if (anr[i]==ivnr) then begin
      goto LAddToDownPayArray;
    end;
  end;
  dpIVr.SerNr = ivnr;  
  if (ReadFirstMain(dpIVr,1,true)) then begin end;
  anr[acnt] = ivnr;
  atd[acnt] = dpIVr.TransDate;
  acnt = acnt + 1;
LAddToDownPayArray:;  
  RETURN;
END;

global
procedure AddVATBaseToArrays(string vatcode,val t,val tax1reb,Integer InclVAT,Integer NoTAXonVAT,Integer vatcodef,
                             Array string avatcode,Array val avatrate,Array val avatbase,Array val avatv,
                             Array val atax1,Array val atax1reb,var Integer acnt)
BEGIN
  row SMVc SMrw;
  Integer i;
  record RoundBlock RoundRec;
  val vatv,tax1;
  Boolean testf;
  
  BlockLoad(RoundRec);
  for (i=0; i<acnt; i=i+1) begin
    testf = false;
    if (vatcodef==1) then begin
      if (avatcode[i]==vatcode) then begin testf = true; end;
    end else begin
      GetVATproc(vatcode,InclVAT,vatv);
      if (avatrate[i]==vatv) then begin testf = true; end;
    end;
    if (testf) then begin
      avatbase[i] = avatbase[i] + t;
      if (RoundRec.VATCalcWay!=0) then begin
        MulVATIV(vatcode,t,vatv,tax1,InclVAT,NoTAXonVAT);
        vatv = Round(vatv,GetVATRoundModeRB);        
        avatv[i] = avatv[i] + vatv;
        tax1 = Round(tax1,DefaultRoundMode);
        atax1[i] = atax1[i] + tax1;
      end;
      atax1reb[i] = tax1reb;
      goto LAddVATBaseToArrays;
    end;
  end;   
  avatcode[acnt] = vatcode;
  avatbase[acnt] = t;   
  MulVATIV(vatcode,t,vatv,tax1,InclVAT,NoTAXonVAT);
  vatv = Round(vatv,GetVATRoundModeRB);        
  if (RoundRec.VATCalcWay!=0) then begin
    avatv[acnt] = vatv;
  end;
  atax1[acnt] = tax1;
  atax1reb[acnt] = tax1reb;
  GetVATproc(vatcode,InclVAT,vatv);
  avatrate[acnt] = vatv;
  acnt = acnt + 1;
LAddVATBaseToArrays:;
  RETURN;
END;

global
procedure PrintDownPaymentData(record IVVc IVr,record DocVc Docr,record RoundBlock RoundRec,record LangNrVc LangNrr,record SysFormatBlock SysFormatRec,Boolean negamountf)
BEGIN
  Integer i,rwcnt;
  row IVVc IVrw;
  Array LongInt anr;
  Array Date atd;
  Integer acnt;
  Array string 2 avatcode;
  Array val avatrate,avatbase,avatval,atax1,atax1reb;
  Integer avatcnt;
  Integer valtyp;
  string 255 tstr;
  val vattot,vatbase,vatval,t1;
  val t;
  
  if (IVr.InvType!=kInvoiceTypeDownpayment) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==5) then begin
        AddToDownPayArray(StringToLongint(IVrw.ArtCode),anr,atd,acnt);
        
        AddVATBaseToArrays(IVrw.VATCode,IVrw.Sum,IVrw.TAX1Reb,IVr.InclVAT,IVr.NoTAXonVAT,0,
                           avatcode,avatrate,avatbase,avatval,atax1,atax1reb,avatcnt);
      end;
    end;
    for (i=0;i<acnt;i=i+1) begin
      OUTFORMFIELD("F_DOWNPAYNR",anr[i]);
      OUTFORMFIELD("F_DOWNPAYDATE",atd[i]);
    end;

    for (i=0;i<avatcnt;i=i+1) begin
      MulVATIV(avatcode[i],avatbase[i],vatval,t1,IVr.InclVAT,IVr.NoTAXonVAT);    

      if (IVr.InclVAT>0) then begin
        vatbase = avatbase[i] - vatval;
        vattot = avatbase[i];
      end else begin
        vatbase = avatbase[i];
        vattot = avatbase[i] + vatval;
      end;

      if (IVr.InclVAT>0) then begin
        vatbase = avatbase[i];
        vattot = avatbase[i] + vatval;
      end else begin
        vatbase = avatbase[i];
        vattot = avatbase[i] + vatval;
      end;
      if (FIELDINFORM("F_DOWNPAYVATPRC")) then begin
        OUTFORMFIELD("F_DOWNPAYVATPRC",avatrate[i]);
      end;
      if (FIELDINFORM("F_DOWNPAYVATBASE")) then begin
        valtyp = M4Val;
        GetFieldArgument(Docr,F_DOWNPAYVATBASE,tstr);
        if (tstr=="-") then begin
          valtyp = M4NegVal;
        end;
        PrintValueInclZero("F_DOWNPAYVATBASE",vatbase,valtyp,LangNrr,SysFormatRec,negamountf);
      end;    
      if (FIELDINFORM("F_DOWNPAYVATVAL")) then begin
        valtyp = M4Val;
        GetFieldArgument(Docr,F_DOWNPAYVATVAL,tstr);
        if (tstr=="-") then begin
          valtyp = M4NegVal;
        end;
        PrintValueInclZero("F_DOWNPAYVATVAL",vatval,valtyp,LangNrr,SysFormatRec,negamountf);
      end;
      if (FIELDINFORM("F_DOWNPAYVATTOT")) then begin
        valtyp = M4Val;
        GetFieldArgument(Docr,F_DOWNPAYVATTOT,tstr);
        if (tstr=="-") then begin
          valtyp = M4NegVal;
        end;
        PrintValueInclZero("F_DOWNPAYVATTOT",vattot,valtyp,LangNrr,SysFormatRec,negamountf);
      end;

      if (nonblank(vatbase)) then begin
        if (FIELDINFORM("F_DOWNPAYBASE1VATBASE")) then begin
          t = MulRateToBase1(IVr.CurncyCode,vatbase,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE1VATBASE,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValueInclZero("F_DOWNPAYBASE1VATBASE",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;
        if (FIELDINFORM("F_DOWNPAYBASE2VATBASE")) then begin
          t = MulRateToBase2(IVr.CurncyCode,vatbase,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE2VATBASE,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValueInclZero("F_DOWNPAYBASE2VATBASE",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;
      end;
      if (nonblank(vattot)) then begin
        if (FIELDINFORM("F_DOWNPAYBASE1VATTOT")) then begin
          t = MulRateToBase1(IVr.CurncyCode,vattot,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE1VATTOT,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValueInclZero("F_DOWNPAYBASE1VATTOT",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;
        if (FIELDINFORM("F_DOWNPAYBASE2VATTOT")) then begin
          t = MulRateToBase2(IVr.CurncyCode,vattot,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE2VATTOT,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValueInclZero("F_DOWNPAYBASE2VATTOT",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;    
      end;
      if (vatval!=0) then begin
        if (FIELDINFORM("F_DOWNPAYBASE1VATVAL")) then begin
          t = MulRateToBase1(IVr.CurncyCode,vatval,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE1VATVAL,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValue("F_DOWNPAYBASE1VATVAL",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;
        if (FIELDINFORM("F_DOWNPAYBASE2VATVAL")) then begin
          t = MulRateToBase2(IVr.CurncyCode,vatval,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,GetVATRoundMode(RoundRec));
          valtyp = M4Val;
          GetFieldArgument(Docr,F_DOWNPAYBASE2VATVAL,tstr);
          if (tstr=="-") then begin
            valtyp = M4NegVal;
          end;
          PrintValue("F_DOWNPAYBASE2VATVAL",Round(t,GetVATRoundMode(RoundRec)),valtyp,LangNrr,SysFormatRec,negamountf);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
procedure FindShpPackages(LongInt orderno,LongInt ordrow,string itemcode,record LangNrVc LangNrr,record SysFormatBlock SysFormatRec,var string res)
BEGIN
  record SHVc SHr;
  row SHVc SHrw;
  Integer i,rwcnt;
  Boolean TrHs;
  val totpck;
  
  SHr.OrderNr = orderno;
  TrHs = true;
  while (LoopKey("OrderKey",SHr,1,TrHs)) begin
    if (SHr.OrderNr!=orderno) then begin TrHs = false; end;
    if (TrHs) then begin
      if (nonblank(itemcode)) then begin
        rwcnt = MatRowCnt(SHr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SHr,i,SHrw);
          if (SHrw.ArtCode==itemcode) and (SHrw.OrdRow==ordrow) then begin
            totpck = totpck + SHrw.RowPackages;
          end;
        end;
      end else begin
        totpck = totpck + SHr.Packages;
      end;
    end;  
  end;
  res = ValToString(totpck,M4UVal,SysFormatRec.thousSep,SysFormatRec.decimalPt,LangNrr.CutDecimals);
  RETURN;
END;

procedure AddRowToTrans(record TRVc tmpTRr,row TRVc TRrw)
BEGIN
  row TRVc tmpTRrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(tmpTRr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(tmpTRr,i,tmpTRrw);
    if (tmpTRrw.AccNumber==TRrw.AccNumber) then begin
      tmpTRrw.DebVal = tmpTRrw.DebVal + TRrw.DebVal;
      tmpTRrw.CredVal = tmpTRrw.CredVal + TRrw.CredVal;
      tmpTRrw.DebVal2 = tmpTRrw.DebVal2 + TRrw.DebVal2;
      tmpTRrw.CredVal2 = tmpTRrw.CredVal2 + TRrw.CredVal2;
      tmpTRrw.CurDebVal = tmpTRrw.CurDebVal + TRrw.CurDebVal;
      tmpTRrw.CurCredVal = tmpTRrw.CurCredVal + TRrw.CurCredVal;
      MatRowPut(tmpTRr,i,tmpTRrw);
      goto LAddRowToTrans;
    end;
  end;
  MatRowPut(tmpTRr,rwcnt,TRrw);
LAddRowToTrans:;  
  RETURN;
END;

global
procedure PrintTransactionOnDocument(Integer IntYc,LongInt sernr)
BEGIN
  record TRVc tmpTRr;
  record TRVc TRr;
  row TRVc TRrw;
  Integer i,rwcnt;
  
  TRr.IntYc = IntYc;
  TRr.Number = sernr;
  if (ReadFirstMain(TRr,2,true)) then begin
    rwcnt = MatRowCnt(TRr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      AddRowToTrans(tmpTRr,TRrw);
    end;
  end;
  rwcnt = MatRowCnt(tmpTRr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(tmpTRr,i,TRrw);
    OUTFORMFIELD("F_TRACCOUNT",TRrw.AccNumber);
    OUTFORMFIELD("F_TRDEBVAL",TRrw.DebVal);
    OUTFORMFIELD("F_TRCREDVAL",TRrw.CredVal);
  end;
  
  RETURN;
END;

global
procedure PrintFreightInfo(string freightcode)
begin
  record FreightCompanyVc FCr;
  
  FCr.Code = FreightCode;
  if (ReadFirstMain(FCr,1,true)) then begin
    OUTFORMFIELD("F_FREIGHTCOMPCODE",FCr.Code);
    OUTFORMFIELD("F_FREIGHTCOMP",FCr.Company); 
    OUTFORMFIELD("F_FREIGHTCOMPREGNO",FCr.CompanyRegNr);
    OUTFORMFIELD("F_TRUCKINFO",FCr.TruckInfo); 
    OUTFORMFIELD("F_DRIVER",FCr.Driver); 
    OUTFORMFIELD("F_CMRTEXT",FCr.CMRText);
  end;
  RETURN;
END;

global
procedure PrintTAXAuthID(string fieldname,string defTaxAuthID,LongInt SerNr,Date TransDate)
begin  
  record IVVc IVr;
  
  IVr.SerNr = SerNr;
  if (ReadFirstMain(IVr,1,true)) then begin
  end;
  OUTFORMFIELD(fieldname,FindTaxAuthID(defTaxAuthID,IVr));
  return;
end;

global
procedure PrintTAXAuthIDControlCode(string fieldname,record IVVc IVr)
begin  
  OUTFORMFIELD(fieldname,FindTaxAuthIDControlCode(IVr.TaxAuthIDCC,IVr));
  return;
end;

global
procedure PrintTAXAuthIDToDate(string fieldname,record IVVc IVr)
begin  
  OutFormField(fieldname,FindTaxAuthIDToDate(IVr));
  return;
end;

global
function Integer CountInvoiceRows(record IVVc IVr)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Integer cnt;
  Boolean hiddenrowf,testf;
  record FormBlock Formb;
  
  rwcnt = MatRowCnt(IVr);
  if (CountRecords("RPCUTaxVc")>0) then begin
    if (HasLocalization("ARG")) then begin
      BlockLoad(Formb);
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      testf = true;
      if (IVrw.stp==kInvoiceRowTypeHidden) then begin
        testf = false;
      end;
      if (HasLocalization("ARG")) then begin
        switch (Formb.PerceptionTax) begin
          case kDonotPrintPerceptionTaxRow:
            if (IVrw.stp==kInvoiceRowTypePerceptionTax) then begin
              testf = false;
            end;
        end;
      end;
      if (testf) then begin
        cnt = cnt + 1;
      end;
    end;
    rwcnt = cnt;
  end else begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==kInvoiceRowTypeHidden) then begin
        rwcnt = i;
        goto LCountInvoiceRows;
      end;
    end;
  end;
LCountInvoiceRows:;
  CountInvoiceRows = rwcnt;
  return;
end;

global
procedure PrintDeliveriesNos(LongInt InvoiceNr,LongInt OrderNr,var string res)
BEGIN
  record SHVc SHr;
  Boolean TrHs;
  string 255 tstr;
  
  res = "";
  TrHs = true;    
  SHr.InvoiceNr = InvoiceNr;
  while (LoopKey("InvoiceNr",SHr,1,TrHs)) begin
    if (SHr.InvoiceNr!=InvoiceNr) then begin TrHs = false; end;
    if (TrHs) then begin      
      if (nonblank(tstr)) then begin
        tstr = tstr & ",";
      end;
      tstr = tstr & SHr.SerNr;
    end;
  end;
  if (blank(tstr)) then begin
    ResetLoop(SHr);
    TrHs = true;    
    SHr.OrderNr = OrderNr;
    while (LoopKey("OrderKey",SHr,1,TrHs)) begin
      if (SHr.OrderNr!=OrderNr) then begin TrHs = false; end;
      if (TrHs) then begin      
        if (nonblank(tstr)) then begin
          tstr = tstr & ",";
        end;
        tstr = tstr & SHr.SerNr;
      end;
    end;     
  end;     
  res = tstr;
  RETURN;
END;

global
procedure RebPay_IV(record IVVc ivrp,record RoundBlock RoundRec,Integer base,Boolean what,var val res)
BEGIN
  val tv,t100;
  record AccBlock atr;
  
  res = blankval;
  BlockLoad(atr);
  if (ivrp.pdvrebt!=0) then begin
    t100 = 100;
    if (atr.DiscCashVAT!=0) then begin
      tv = 100 - ivrp.pdvrebt;
      tv = tv*ivrp.Sum1;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      if (what) then begin
        tv = ivrp.Sum1 - tv;
      end else begin
        tv = tv + ivrp.Sum3;
      end;
    end else begin
      tv = t100 - ivrp.pdvrebt;
      tv = tv*ivrp.Sum4;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      if (what) then begin
        tv = ivrp.Sum4 - tv;
      end;
    end;
    switch (base) begin
      case 0: 
      case 1: tv = MulRateToBase1(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
      case 2: tv = MulRateToBase2(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
    end;
    res = tv;
  end;
  RETURN;
END;

global
procedure RebPayHalf_IV(record IVVc ivrp,record RoundBlock RoundRec,Integer base,var string res)
BEGIN
  val tv,t100;
  record AccBlock atr;

  res = "";
  BlockLoad(atr);
  if (ivrp.pdvrebt!=0) then begin
    t100 = 100;
    if (atr.DiscCashVAT!=0) then begin
      tv = t100 - ivrp.pdvrebt;
      tv = tv*ivrp.Sum1;
      tv = tv/2;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      tv = ivrp.Sum4 - tv;
    end else begin
      tv = t100 - ivrp.pdvrebt;
      tv = tv*ivrp.Sum4;
      tv = tv/100;
      tv = ivrp.Sum4 - tv;
      tv = tv/2;
      tv = ivrp.Sum4 - tv;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
    end;
    switch (base) begin
      case 0: 
      case 1: tv = MulRateToBase1(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
      case 2: tv = MulRateToBase2(ivrp.CurncyCode,tv,ivrp.FrRate,ivrp.ToRateB1,ivrp.ToRateB2,ivrp.BaseRate1,ivrp.BaseRate2,DefaultCurRoundOff);
    end;
    res = tv;
  end;
  RETURN;
END;

global
function Integer ITType(string artcode)
BEGIN
  record INVc INr;
  record ITVc ITr;
  
  INr.Code = artcode;
  if (ReadFirstItem(artcode,INr,true,true)) then begin end;
  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin end;
  ITType = ITr.Type;
  RETURN;
END;

global
procedure CashDiscVAT(val thesum,val rebprc,record RoundBlock RoundRec,var val res)
BEGIN
  val tv,t100;

  res = BlankVal;
  if (rebprc!=0) then begin
    t100 = 100;
    tv = t100 - rebprc;
    tv = tv*thesum;
    tv = tv/100;
    tv = Round(tv,GetTotalRoundMode(RoundRec));
    res = thesum - tv;
  end;
  RETURN;
END;

global
procedure GetVATText(string vatc,var string VATtext)
begin
  record VATCodeBlock vcb;
  row VATCodeBlock vcbrow;
  integer rwcnt,i;

  BlockLoad(vcb);
  rwcnt = MatRowCnt(vcb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(vcb,i,vcbrow);
    if (vcbrow.VATCode == vatc) then begin
      VATtext  =  vcbrow.Comment;
    end;
  end;
  return;
end;

global
procedure PrintNotDeliveredQty(LongInt OrderNr,string ArtCode,integer OrderRowNr,record LangNrVc LangNrr,record SysFormatBlock SysFormatRec)
begin
  record ORVc ORr;
  row ORVc ORrw;

  if (FIELDINFORM("F_LEVANTAL") or FIELDINFORM("F_ORDQTY") or FIELDINFORM("F_REMAININGQTY")) then begin
    ORr.SerNr = OrderNr;
    if (ReadFirstMain(ORr,1,true)) then begin
      if (OrderRowNr<MatRowCnt(ORr) and OrderRowNr>=0) then begin
        MatRowGet(ORr,OrderRowNr,ORrw);
        if (ORrw.ArtCode==ArtCode) then begin
          PrintValueInclZero("F_REMAININGQTY",ORrw.Quant-ORrw.Shipd1,M4UVal,LangNrr,SysFormatRec,false);
          PrintValueInclZero("F_LEVANTAL",ORrw.Shipd1,M4UVal,LangNrr,SysFormatRec,false);
          PrintValueInclZero("F_ORDQTY",ORrw.Quant,M4UVal,LangNrr,SysFormatRec,false);
        end;
      end;
    end;
  end;
  return;
end;

global
procedure PrintBankData(string bankcode)
begin
  record BankVc Bankr;
  
  Bankr.Code = bankcode;
  if (ReadFirstMain(Bankr,1,true)) then begin
    OUTFORMFIELD("F_ACCOUNTOPERATOR2",Bankr.Code);
    OUTFORMFIELD("F_BANKACC2",Bankr.Nr2);
    OUTFORMFIELD("F_BANKNAME2",Bankr.Name);
    OUTFORMFIELD("F_BANKSWIFT2",Bankr.SWIFT);
    OUTFORMFIELD("F_BANKCORRPACC2",Bankr.CorrspAcc);
  end;
  return; 
end;

global
procedure PrintOrgCustBankData(string orgcust)
begin
  record CUVc CUr;
  record BankVc Bankr;
  
  if (nonblank(orgcust)) then begin
    CUr.Code = orgcust;
    if (ReadFirstMain(CUr,1,true)) then begin
      Bankr.Code = CUr.AccOperator;
      if (ReadFirstMain(Bankr,1,true)) then begin
        OUTFORMFIELD("F_ACCOUNTOPERATORNAMEORGCUST",Bankr.Code);
        OUTFORMFIELD("F_BANKNAMEORGCUST",Bankr.Name);
        OUTFORMFIELD("F_BANKSWIFTORGCUST",Bankr.SWIFT);
        OUTFORMFIELD("F_BANKCORRPACCORGCUST",Bankr.CorrspAcc);
      end;
      if (nonblank(CUr.BankAccount)) then begin
        OUTFORMFIELD("F_BANKACCORGCUST",CUr.BankAccount);
      end else begin
        OUTFORMFIELD("F_BANKACCORGCUST",Bankr.Nr2);
      end;
    end;
  end;
  return; 
end;

global
procedure PrintInvoiceToBankData(string cubankacc,record BankVc CUBankr,string invoiceto)
begin
  record CUVc CUr;
  record BankVc Bankr;
  
  if (nonblank(invoiceto)) then begin
    CUr.Code = invoiceto;
    if (ReadFirstMain(CUr,1,true)) then begin
      Bankr.Code = CUr.AccOperator;
      if (ReadFirstMain(Bankr,1,true)) then begin
        OUTFORMFIELD("F_ACCOUNTOPERATORINVOICETO",Bankr.Code);
        OUTFORMFIELD("F_ACCOUNTOPERATORNAMEINVOICETO",Bankr.Name);
        OUTFORMFIELD("F_BANKNAMEINVOICETO",Bankr.Name);
        OUTFORMFIELD("F_BANKSWIFTINVOICETO",Bankr.SWIFT);
        OUTFORMFIELD("F_BANKCORRPACCINVOICETO",Bankr.CorrspAcc);
      end;
      if (nonblank(CUr.BankAccount)) then begin
        OUTFORMFIELD("F_BANKACCINVOICETO",CUr.BankAccount);
      end else begin
        OUTFORMFIELD("F_BANKACCINVOICETO",Bankr.Nr2);
      end;
    end;
  end else begin
    OUTFORMFIELD("F_ACCOUNTOPERATORINVOICETO",CUBankr.Code);
    OUTFORMFIELD("F_ACCOUNTOPERATORNAMEINVOICETO",CUBankr.Name);
    OUTFORMFIELD("F_BANKCORRPACCINVOICETO",CUBankr.CorrspAcc);
    OUTFORMFIELD("F_BANKSWIFTINVOICETO",CUBankr.SWIFT);
    if (nonblank(cubankacc)) then begin
      OUTFORMFIELD("F_BANKACCINVOICETO",cubankacc);
    end else begin
      OUTFORMFIELD("F_BANKACCINVOICETO",CUBankr.Nr2);
    end;
  end;
  return; 
end;

global
function string 255 SerialNrBC128(string tstr)
begin
  string 255 res;
  Array Integer bc128_Key;
  Array Integer bc128_C;
  Array Integer tstri;
  Integer tstrlen;  

  res = tstr;
  FinRefChecksum1(tstr);
  ConvertToBC128(res,res,tstri,tstrlen,bc128_Key,bc128_C);
  FinRefChecksum2(res,tstri,tstrlen,bc128_Key,bc128_C);
  AddBC128Flags(res);
  SerialNrBC128 = res;
  return; 
end;
