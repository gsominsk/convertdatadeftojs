external function Boolean IsDigit(string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure ExtractObj(string,var Integer,var string);

procedure GetINBarCode(string item,var string res)
BEGIN
  record INVc INr;
  record BarcodeVc Barcoder;

  res = item;
  Barcoder.Itemcode = item;
  if (ReadFirstKey("Itemcode",Barcoder,1,true)) then begin
    res = Barcoder.Barcode;
  end else begin
    if (GetFirstItem(item,INr)) then begin
      if (nonblank(INr.BarCode)) then begin
        res = INr.BarCode;
      end else begin
        res = INr.Code;
      end;
    end;
  end;
  RETURN;
END;

function
Integer cval(string t,Integer pos)
BEGIN
  Integer res;
  
  res =  asc(Mid(t,pos-1,1)) - asc("0");
  cval = res;
  RETURN;
END;

procedure InitTbl(var Array Integer tbl,Integer i0,Integer i1,Integer i2,Integer i3,Integer i4)
BEGIN
  tbl[0] = i0;
  tbl[1] = i1;
  tbl[2] = i2;
  tbl[3] = i3;
  tbl[4] = i4;
  RETURN;
END;

procedure GetCharFromTable(Array Integer tbl0,Array Integer tbl1,Array Integer tbl2,Array Integer tbl3,
                           Array Integer tbl4,Array Integer tbl5,Array Integer tbl6,Array Integer tbl7,
                           Array Integer tbl8,Array Integer tbl9,Integer tblnr,Integer chnr,var Integer char)
BEGIN
  char = 0;
  if (tblnr==0) then begin
    char = tbl0[chnr];
  end;
  if (tblnr==1) then begin
    char = tbl1[chnr];
  end;
  if (tblnr==2) then begin
    char = tbl2[chnr];
  end;
  if (tblnr==3) then begin
    char = tbl3[chnr];
  end;
  if (tblnr==4) then begin
    char = tbl4[chnr];
  end;
  if (tblnr==5) then begin
    char = tbl5[chnr];
  end;
  if (tblnr==6) then begin
    char = tbl6[chnr];
  end;
  if (tblnr==7) then begin
    char = tbl7[chnr];
  end;
  if (tblnr==8) then begin
    char = tbl8[chnr];
  end;
  if (tblnr==9) then begin
    char = tbl9[chnr];
  end;
  RETURN;
END;

// this function is now converting to EAN13
procedure ConvertToEAN13(string t,var string res)
BEGIN
  Array Integer tbl0;
  Array Integer tbl1;
  Array Integer tbl2;
  Array Integer tbl3;
  Array Integer tbl4;
  Array Integer tbl5;
  Array Integer tbl6;
  Array Integer tbl7;
  Array Integer tbl8;
  Array Integer tbl9;
  string 1 ch;
  Integer char;
  Integer tblnr;
  Integer i;
  
  InitTbl(tbl0,0,0,0,0,0);
  InitTbl(tbl1,0,1,0,1,1);
  InitTbl(tbl2,0,1,1,0,1);
  InitTbl(tbl3,0,1,1,1,0);
  InitTbl(tbl4,1,0,0,1,1);
  InitTbl(tbl5,1,1,0,0,1);
  InitTbl(tbl6,1,1,1,0,0);
  InitTbl(tbl7,1,0,1,0,1);
  InitTbl(tbl8,1,0,1,1,0);
  InitTbl(tbl9,1,1,0,1,0);
  
  tblnr = asc(Mid(t,0,1)) - asc("0");

  res = "." & chr(asc(Mid(t,1,1)));

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,0,char);
  ch = chr(asc(Mid(t,3-1,1)) + 16*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,1,char);
  ch = chr(asc(Mid(t,4-1,1)) + 16*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,2,char);
  ch = chr(asc(Mid(t,5-1,1)) + 16*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,3,char);
  ch = chr(asc(Mid(t,6-1,1)) + 16*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,4,char);
  ch = chr(asc(Mid(t,7-1,1)) + 16*char);
  res = res & ch;

  res = res & chr(45);

  ch = chr(asc(Mid(t,8-1,1)) - asc("0") + 97);
  res = res & ch;
  ch = chr(asc(Mid(t,9-1,1)) - asc("0") + 97);
  res = res & ch;
  ch = chr(asc(Mid(t,10-1,1)) - asc("0") + 97);
  res = res & ch;
  ch = chr(asc(Mid(t,11-1,1)) - asc("0") + 97);
  res = res & ch;
  ch = chr(asc(Mid(t,12-1,1)) - asc("0") + 97);
  res = res & ch;
  ch = chr(asc(Mid(t,13-1,1)) - asc("0") + 97);
  res = res & ch;
  res = res & ".";
  RETURN;
END;

// According to a PDF file on the net, THIS is the correct code....
// We need to sit down and make correct stuff and save that code Together with the font....
/*
procedure ConvertToEAN13(string t,var string res)
BEGIN
  Array Integer tbl0;
  Array Integer tbl1;
  Array Integer tbl2;
  Array Integer tbl3;
  Array Integer tbl4;
  Array Integer tbl5;
  Array Integer tbl6;
  Array Integer tbl7;
  Array Integer tbl8;
  Array Integer tbl9;
  string 1 ch;
  Integer char;
  Integer tblnr;
  Integer i;
  
  InitTbl(tbl0,0,0,0,0,0);
  InitTbl(tbl1,0,1,0,1,1);
  InitTbl(tbl2,0,1,1,0,1);
  InitTbl(tbl3,0,1,1,1,0);
  InitTbl(tbl4,1,0,0,1,1);
  InitTbl(tbl5,1,1,0,0,1);
  InitTbl(tbl6,1,1,1,0,0);
  InitTbl(tbl7,1,0,1,0,1);
  InitTbl(tbl8,1,0,1,1,0);
  InitTbl(tbl9,1,1,0,1,0);
  
  tblnr = asc(Mid(t,0,1)) - asc("0");

  res = chr(asc("Q")+tblnr);
  res = res & chr(40) & chr(asc(Mid(t,1,1)));

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,0,char);
  ch = chr(asc(Mid(t,3-1,1)) + 16*char + 33);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,1,char);
  ch = chr(asc(Mid(t,4-1,1)) + (16 + 33)*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,2,char);
  ch = chr(asc(Mid(t,5-1,1)) + (16 + 33)*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,3,char);
  ch = chr(asc(Mid(t,6-1,1)) + (16 + 33)*char);
  res = res & ch;

  GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblnr,4,char);
  ch = chr(asc(Mid(t,7-1,1)) + (16 + 33)*char);
  res = res & ch;

  res = res & chr(45);

  ch = chr(asc(Mid(t,8-1,1)) - asc("0") + 65);
  res = res & ch;
  ch = chr(asc(Mid(t,9-1,1)) - asc("0") + 65);
  res = res & ch;
  ch = chr(asc(Mid(t,10-1,1)) - asc("0") + 65);
  res = res & ch;
  ch = chr(asc(Mid(t,11-1,1)) - asc("0") + 65);
  res = res & ch;
  ch = chr(asc(Mid(t,12-1,1)) - asc("0") + 65);
  res = res & ch;
  ch = chr(asc(Mid(t,13-1,1)) - asc("0") + 65);
  res = res & ch;
  res = res & chr(40); // & ">";
  RETURN;
END;
*/

function string 255 GetEncodedLefthandstring(Array string encodelefthandoddparity,Array string encodelefthandevenparity,Integer charnr,Integer parity)
BEGIN
  string 255 res;

  switch (parity) begin
    case 0: res = encodelefthandoddparity[charnr];
    case 1: res = encodelefthandevenparity[charnr];
  end;
  GetEncodedLefthandstring = res;
  RETURN;
END;

function string 255 GetEncodedRighthandstring(Array string encoderighthand,Integer charnr)
BEGIN
  string 255 res;

  res = encoderighthand[charnr];
  GetEncodedRighthandstring = res;
  RETURN;
END;

procedure InitEncodelefthand(Array string encodelefthandoddparity,Array string encodelefthandevenparity)
BEGIN
  encodelefthandoddparity[0] = "0001101";//A
  encodelefthandoddparity[1] = "0011001";
  encodelefthandoddparity[2] = "0010011";
  encodelefthandoddparity[3] = "0111101";
  encodelefthandoddparity[4] = "0100011";
  encodelefthandoddparity[5] = "0110001";
  encodelefthandoddparity[6] = "0101111";
  encodelefthandoddparity[7] = "0111011";
  encodelefthandoddparity[8] = "0110111";
  encodelefthandoddparity[9] = "0001011";

  encodelefthandevenparity[0] = "0100111";//B
  encodelefthandevenparity[1] = "0110011";
  encodelefthandevenparity[2] = "0011011";
  encodelefthandevenparity[3] = "0100001";
  encodelefthandevenparity[4] = "0011101";
  encodelefthandevenparity[5] = "0111001";
  encodelefthandevenparity[6] = "0000101";
  encodelefthandevenparity[7] = "0010001";
  encodelefthandevenparity[8] = "0001001";
  encodelefthandevenparity[9] = "0010111";
  RETURN;
END;

procedure InitEncoderighthand(Array string encoderighthand)
BEGIN
  encoderighthand[0] = "1110010";
  encoderighthand[1] = "1100110";
  encoderighthand[2] = "1101100";
  encoderighthand[3] = "1000010";
  encoderighthand[4] = "1011100";
  encoderighthand[5] = "1001110";
  encoderighthand[6] = "1010000";
  encoderighthand[7] = "1000100";
  encoderighthand[8] = "1001000";
  encoderighthand[9] = "1110100";
  RETURN;
END;

//the above ConvertToEAN is worng, have a look in, http://www.barcodeisland.com/ean13.phtml
procedure ConvertToEAN_2(string t,var string res)
BEGIN
  Array Integer tbl0;
  Array Integer tbl1;
  Array Integer tbl2;
  Array Integer tbl3;
  Array Integer tbl4;
  Array Integer tbl5;
  Array Integer tbl6;
  Array Integer tbl7;
  Array Integer tbl8;
  Array Integer tbl9;
  string 255 t2;
  string 14 tmp;
  string 1 first;
  string 1 second;
  string 5 lefthand;
  string 5 righthand;
  string 1 cntrldigit;
  string 1 ch;
  Integer char,i;
  Integer tblparitynr;
  Array string 7 encoderighthand;
  Array string 7 encodelefthandoddparity;
  Array string 7 encodelefthandevenparity;
  
  res = "";
  InitTbl(tbl0,0,0,0,0,0);//A,A,A,A,A
  InitTbl(tbl1,0,1,0,1,1);//A,B,A,B,B
  InitTbl(tbl2,0,1,1,0,1);//A,B,B,A,B
  InitTbl(tbl3,0,1,1,1,0);//A,B,B,B,A
  InitTbl(tbl4,1,0,0,1,1);//B,A,A,B,B
  InitTbl(tbl5,1,1,0,0,1);//B,B,A,A,B
  InitTbl(tbl6,1,1,1,0,0);//B,B,B,A,A
  InitTbl(tbl7,1,0,1,0,1);//B,A,B,A,B
  InitTbl(tbl8,1,0,1,1,0);//B,A,B,B,A
  InitTbl(tbl9,1,1,0,1,0);//B,B,A,B,A
  InitEncoderighthand(encoderighthand);
  InitEncodelefthand(encodelefthandoddparity,encodelefthandevenparity);
  
//  tmp = "7501031311309";
//  tmp = "4011462209029";//testcode
  tmp = t;
  first = Left(tmp,1);
  second = Mid(tmp,2-1,1);
  lefthand = Mid(tmp,3-1,5);
  righthand = Mid(tmp,8-1,5);
  cntrldigit = Right(tmp,1);  
//StopAlert("1=" & first & " 2=" & second & " left=" & lefthand & " right=" & righthand & " cntrl=" & cntrldigit);  
 
  res = first & "101";  
  res = "101";  

  tblparitynr = StringToInt(first);
  ch = Mid(second,i,1);
  t2 = GetEncodedLefthandstring(encodelefthandoddparity,encodelefthandevenparity,StringToInt(ch),0);
  res = res & t2;
  
  for (i=0;i<5;i=i+1) begin
    ch = Mid(lefthand,i,1);
    GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblparitynr,i,char);
    t2 = GetEncodedLefthandstring(encodelefthandoddparity,encodelefthandevenparity,StringToInt(ch),char);
    res = res & t2;
  end;
  res = res & "01010";
  for (i=0;i<5;i=i+1) begin
    ch = Mid(righthand,i,1);
    GetCharFromTable(tbl0,tbl1,tbl2,tbl3,tbl4,tbl5,tbl6,tbl7,tbl8,tbl9,tblparitynr,i,char);
    t2 = GetEncodedRighthandstring(encoderighthand,StringToInt(ch));
    res = res & t2;
  end;
  ch = cntrldigit;
  t2 = GetEncodedRighthandstring(encoderighthand,StringToInt(ch));
  res = res & t2;
  
  res = res & "101";
//  res = Right(tmp,len(tmp));
//MessageBox(0,"res " & res);  
  RETURN;
END;

global
procedure BCEAN(string item,var string res)
BEGIN
  LongInt sm,a,b;
  string 255 tstr;
  
  tstr = item;
  if (len(tstr)<13) then begin
     M4PadString(tstr,12,"0",true,res);
     a = cval(res,1) + cval(res,3) + cval(res,5) + cval(res,7) + cval(res,9) + cval(res,11);
     b = 3*(cval(res,2) + cval(res,4) + cval(res,6) + cval(res,8) + cval(res,10) + cval(res,12));
     sm = 4000 - a- b;
     sm = Mod(sm,10);
     res = res & chr(sm + asc("0"));
  end else begin
    res = tstr;
  end;  
  ConvertToEAN_2(res,tstr);
  res = tstr;
  RETURN;
END;

procedure EAN13(string item,var string res)
BEGIN
  LongInt sm,a,b;
  string 255 tstr;
  
  tstr = item;
  if (len(tstr)<13) then begin
    M4PadString(tstr,12,"0",true,res);  
    a = cval(res,1) + cval(res,3) + cval(res,5) + cval(res,7) + cval(res,9) + cval(res,11);
    b = 3 * (cval(res,2) + cval(res,4) + cval(res,6) + cval(res,8) + cval(res,10) + cval(res,12));
    sm = 4000 - a - b;
    sm = Mod(sm,10);
    res = res & chr(sm + asc("0"));
  end else begin
    res = tstr;
  end;  
  ConvertToEAN13(res,tstr);
  res = tstr;
  RETURN;
END;

function LongInt StringToEAN13(string s, var string encs) 
begin
  Integer i,ascBufIn;
  string 1 x;
  LongInt checksum;
  Boolean tableA;
  LongInt res;
  array Integer BufIn;
  array Integer BufOut;

  encs = "";
  for (i = 0; i < 12; i = i + 1) begin
    BufIn[i] = Asc(Mid(s,i,1));
  end;  
  //Check for 12 characters
  for (i = 0; i < 12; i = i + 1) begin
    if (BufIn[i] < 48 or BufIn[i] > 57) then begin
      res = 1;
      goto StringToEAN13End;
    end;  
  end;

  //Calculation of the checksum
  checksum = 0;
  for (i = 11; i >= 0; i = i - 2) begin
    checksum = checksum + BufIn[i] - 48;
  end;  
  checksum = checksum * 3;
  for (i = 10; i >= 0; i = i - 2) begin
    checksum = checksum + BufIn[i] - 48;
  end;  
  checksum = Mod((10 - Mod(checksum,10)),10);

  //The first digit is taken just as it is, the second one comes from table A
  BufOut[0] = BufIn[0];
  BufOut[1] = BufIn[1] + 17;
  ascBufIn = BufIn[0];
  for (i = 2; i <= 6; i = i + 1) begin
    tableA = false;
    switch (i) begin
    case 2:  if (ascBufIn > 47 and ascBufIn < 52) then begin tableA = true; end;
    case 3:  if (ascBufIn == 48 or ascBufIn == 52 or ascBufIn == 55 or ascBufIn == 56) then begin tableA = true; end;
    case 4:  if (ascBufIn == 48 or ascBufIn == 49 or ascBufIn == 52 or ascBufIn == 53 or ascBufIn == 57) then begin tableA = true; end;
    case 5:  if (ascBufIn == 48 or ascBufIn == 50 or ascBufIn == 53 or ascBufIn == 54 or ascBufIn == 55) then begin tableA = true; end;
    case 6:
      if (ascBufIn == 48 or ascBufIn == 51 or ascBufIn == 54 or ascBufIn == 56 or ascBufIn == 57) then begin tableA = true; end;
    end;
    if (tableA) then begin
      BufOut[i] = BufIn[i] + 17;
    end else begin
      BufOut[i] = BufIn[i] + 27;
    end;
  end;
  BufOut[7] = Asc("*"); // Add middle separator
  for (i = 7; i <= 11; i = i + 1) begin
    BufOut[i + 1] = BufIn[i] + 49;
  end;  
  BufOut[13] = checksum + 97;
  BufOut[14] = Asc("+"); // Add end mark

  for (i = 0; i < 15; i = i + 1) begin
    encs = encs & Chr(BufOut[i]);
  end;
  res = 0;
StringToEAN13End:;
  StringToEAN13 = res;
  return;
end;

global
procedure ItemBCEAN13(string item,var string res)
BEGIN
  string 255 tstr;

  GetINBarCode(item,tstr);
  StringToEAN13(tstr,res);
//  EAN13(tstr,res);
  if (blank(item)) then begin
    res = "";
  end;  
  RETURN;
END;

global
procedure ItemBCEAN(string item,var string res)
begin
  string 255 tstr;

  GetINBarCode(item,tstr);
  BCEAN(tstr,res);
  if (blank(item)) then begin
    res = "";
  end;
  return;
end;

global
procedure BC39(string item,var string res)
BEGIN
  string 255 tstr;
  
  if (nonblank(item)) then begin
    res = "*";
    tstr = item;
    res = res & tstr;
    res = res & "*";
  end else begin
    res = "";
  end;
  RETURN;
END;

global
procedure ItemBC39(string item,var string res)
BEGIN
  string 255 tstr;

  GetINBarCode(item,tstr);
  BC39(tstr,res);
  RETURN;
END;

global
procedure GetCreditCardType(string creditcard,var string res)
BEGIN
  record CreditCardVc CCr;
  record CredCardTypeVc CCTr;

  res = "";
  CCr.CreditCardNr = creditcard;
  if (ReadFirstMain(CCr,1,true)) then begin
    CCTr.Code = CCr.CredCardType;
    if (ReadFirstMain(CCTr,1,true)) then begin
      res = USetStr(8560+CCTr.CardType);
    end;
  end;
  RETURN;
END;

global
procedure GetObjectText(string obj,var string res)
BEGIN
  record ObjVc OBr;
  Integer pos;
  string 255 ostr;
  
  res = "";
  pos = 0;
  ExtractObj(obj,pos,ostr);
  while (nonblank(ostr)) begin
    OBr.Code = ostr;
    if (ReadFirstMain(OBr,1,true)) then begin
      if ((len(res)+len(OBr.Comment))<=250) then begin
        if (nonblank(res)) then begin
          res = res & ", ";
        end;  
        res = res & OBr.Comment;
      end;
    end;
    ExtractObj(obj,pos,ostr);
  end;
  RETURN;
END;

global
procedure GetLocationName(string code,var string res)
BEGIN
  record LocationVc Locr;
 
  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Name;
  end else begin
    res = code;
  end;  
  RETURN;
END;

global
procedure GetLocationContact(string code,var string res)
BEGIN
 record LocationVc Locr;
 
  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Contact;
  end;  
  RETURN;
END;

global
procedure GetLocationPhone(string code,var string res)
BEGIN
 record LocationVc Locr;
 
  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Phone;
  end;  
  RETURN;
END;

global
procedure GetLocationFax(string code,var string res)
BEGIN
 record LocationVc Locr;
 
  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Fax;
  end;  
  RETURN;
END;

global
procedure GetLocationEmail(string code,var string res)
BEGIN
  record LocationVc Locr;
 
  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Email;
  end;  
  RETURN;
END;

global
procedure GetLocationAddress(string code,Integer rn,var string res)
BEGIN
  record LocationVc Locr;

  res = "";
  Locr.Code = code;
  if (ReadFirstMain(Locr,1,true)) then begin
    switch (rn) begin
      case 1: res = Locr.Addr0;
      case 2: res = Locr.Addr1;
      case 3: res = Locr.Addr2;
      case 4: res = Locr.Addr3;
      case 5: res = Locr.Addr4;
    end;
  end;  
  RETURN;
END;

global
function Boolean GetPurchaseItem(string artcode,string location,var record PIVc PIp)
BEGIN
  Boolean res;
  Integer keynum;
  
  PIp.ItemCode = artcode;
  PIp.DefaultChoice = 1;
  keynum = 2;
  if (nonblank(location)) then begin 
    keynum = 3;
    PIp.Location = location;
  end;
  if (ReadFirstKey("DefaultChoice",PIp,keynum,true)) then begin
    res = true;
  end;
  if (res==false) then begin
    if (nonblank(location)) then begin
      res = GetPurchaseItem(artcode,"",PIp);
    end;
  end;
  GetPurchaseItem = res;
  RETURN;
END;

global
procedure GetOriginCoutry(string ItemCode,string location,var string orgcountry)
BEGIN
  record PIVc PIr;
  
  orgcountry = "";
  if (GetPurchaseItem(ItemCode,location,PIr)) then begin
    orgcountry = PIr.OrgCountry;
  end;
  RETURN;
END;

global
procedure RussianPaymentNr(LongInt sernr,var string res)
BEGIN
  string 255 tstr;
  LongInt russernr;
  
  tstr = sernr;
  res = Right(tstr,len(tstr)-3);
  russernr = FirstInRange(res,10);
  res = russernr;
  RETURN;
END;

global
procedure GetOrdClassText(string a,var string res)
BEGIN
  record OrderClassVc OCr;
  
  res = "";
  OCr.Code = a;
  if (ReadFirstMain(OCr,1,true)) then begin
    res = OCr.Comment;
  end;
  RETURN;
END;

global
procedure GetPOrdClassText(string a,var string res)
begin
  record POrderClassVc POrderClassr;
  
  res = "";
  POrderClassr.Code = a;
  if (ReadFirstMain(POrderClassr,1,true)) then begin
    res = POrderClassr.Comment;
  end;
  return;
end;

global
procedure GetRecipeCode(string a,var string res)
BEGIN
  record INVc INr;
  record RecVc Recr;
     
  res = "";
  INr.Code = a;
  if (ReadFirstMain(INr,1,true)) then begin
    if ((INr.ItemType==2) and (INr.ExplodeRec!=0)) then begin
      Recr.Code = INr.Recepy;
      if (ReadFirstMain(Recr,1,true)) then begin
        res = Recr.Code;
      end;
    end;
  end;    
  RETURN;
END;

global
procedure GetRecipeName(string a,var string res)
BEGIN
  record INVc INr;
  record RecVc Recr;
     
  res = "";
  INr.Code = a;
  if (ReadFirstMain(INr,1,true)) then begin
    if ((INr.ItemType==2) and (INr.ExplodeRec!=0)) then begin
      Recr.Code = INr.Recepy;
      if (ReadFirstMain(Recr,1,true)) then begin
        res = Recr.Comment;
      end;
    end;
  end;    
  RETURN;
END;

global
procedure GetWarrantyLength(string artcode,var string res)
BEGIN
  record INVc INr;
    
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
     res = INr.WarrantyLength;
  end;
  RETURN;
END;

global
procedure GetItemDepartment(string artcode,var string res)
BEGIN
  record INVc INr;
    
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
     res = INr.Department;
  end;
  RETURN;
END;

global
procedure GetItemDepartment2(string artcode,var string res)
BEGIN
  record INVc INr;
  record DepVc Depr;
    
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
    Depr.Code = INr.Department;
    if (ReadFirstMain(Depr,1,true)) then begin
      res = Depr.Description;
    end; 
  end;
  RETURN;
END;

global
procedure GetAC2Accounts(Integer model,Integer account,string at2cat,string at2class,var string resacc)
BEGIN
  record AT2Vc AT2Catr;
  record AC2Block AC2Rec;
  row AC2Block AC2rw;
  string 20 tstr;
  Integer i,acrwcnt;
   
  tstr = at2class;
  if (blank(tstr)) then begin
    AT2Catr.Code = at2cat;
    if (ReadFirstMain(AT2Catr,1,true)) then begin
      tstr = AT2Catr.AT2Class;
    end;  
  end;
  BlockLoad(AC2Rec); 
  acrwcnt = MatRowCnt(AC2Rec); 
  for (i=0;i<acrwcnt;i=i+1) begin
    MatRowGet(AC2Rec,i,AC2rw);
    if (AC2rw.Code==tstr) then begin
      switch (model) begin
        case 0: 
          switch (account) begin
            case 0: resacc = AC2rw.Asset1Acc;
            case 1: resacc = AC2rw.Depr1Acc;
            case 2: resacc = AC2rw.Cost1Acc;
          end;
        case 1: 
          switch (account) begin
            case 0: resacc = AC2rw.Asset2Acc;
            case 1: resacc = AC2rw.Depr2Acc;
            case 2: resacc = AC2rw.Cost2Acc;
          end;
      end;  
      goto LGetAC2Accounts;
    end;
  end;
LGetAC2Accounts:;  
  RETURN;
END;

global
procedure GetDprModDescription(string modcode,var string res)
BEGIN
  record DprModVc DprModr;
  
  res = "";
  DprModr.Code = modcode;
  if (ReadFirstMain(DprModr,1,true)) then begin
    res = DprModr.Description;
  end;
  RETURN;
END;

global
procedure GetInventoryNrWrofNumber(string InventoryNr,var LongInt res)
BEGIN
  record InvrsVc Inrsr;
  
  res = -1;
  Inrsr.FileName = "AT2WrofVc";
  Inrsr.InventoryNr = InventoryNr;
  if (ReadFirstKey("FileName",Inrsr,2,true)) then begin
    res = Inrsr.TransNr;
  end;
  RETURN;
END;

global
procedure GetInventoryNrWrofComment(string InventoryNr,var string res)
BEGIN
  record InvrsVc Inrsr;
  record AT2WrofVc Wrofr;
  
  res = "";
  Inrsr.FileName = "AT2WrofVc";
  Inrsr.InventoryNr = InventoryNr;
  if (ReadFirstKey("FileName",Inrsr,2,true)) then begin
    Wrofr.SerNr = Inrsr.TransNr;
    if (ReadFirstMain(Wrofr,1,true)) then begin    
      res = Wrofr.Comment;
    end;  
  end;
  RETURN;
END;

global
procedure GetAssetCurDepartment(string InventoryNr,var string res) 
BEGIN
  record InvBalVc InvBalr;

  res = "";
  InvBalr.InventoryNr = InventoryNr;
  if (ReadLastMain(InvBalr,1,true)) then begin
    res = InvBalr.CurDepartment;
  end;
  RETURN;
END;

global
procedure GetPriceRangeText(string pricerange,var string res)
BEGIN
  record PriceRangeBlock PriceRangeRec;
  row PriceRangeBlock prrw;
  Integer i,rwcnt;
  
  res = "";
  BlockLoad(PriceRangeRec);
  rwcnt = MatRowCnt(PriceRangeRec);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(PriceRangeRec,i,prrw);
    if (pricerange==prrw.Code) then begin
      res = prrw.Comment;
      goto LGetPriceRangeText;
    end;
  end;
LGetPriceRangeText:;
  RETURN;
END;

global
procedure GetCalcChargeCode(LongInt sernr,Integer rownr,var string res) 
BEGIN
  record CalcChargeVc CalcCharger;
  row CalcChargeVc CalcChargerw;

  res = "";
  CalcCharger.SerNr = sernr;
  if (ReadFirstMain(CalcCharger,1,true)) then begin
    MatRowGet(CalcCharger,rownr,CalcChargerw);
    res = CalcChargerw.Code;
  end;
  RETURN;
END;

global
procedure GetCalcChargeComment(LongInt sernr,Integer rownr,var string res) 
BEGIN
  record CalcChargeVc CalcCharger;
  row CalcChargeVc CalcChargerw;

  res = "";
  CalcCharger.SerNr = sernr;
  if (ReadFirstMain(CalcCharger,1,true)) then begin
    MatRowGet(CalcCharger,rownr,CalcChargerw);
    res = CalcChargerw.Comment;
  end;
  RETURN;
END;

global
procedure GetCalcChargeCalcVal(LongInt sernr,Integer rownr,var string res) 
BEGIN
  record CalcChargeVc CalcCharger;
  row CalcChargeVc CalcChargerw;

  res = "";
  CalcCharger.SerNr = sernr;
  if (ReadFirstMain(CalcCharger,1,true)) then begin
    MatRowGet(CalcCharger,rownr,CalcChargerw);
    res = CalcChargerw.CalcVal;
  end;
  RETURN;
END;

global
procedure SelectUnitText(string langcode,string unit,var string res)
BEGIN
  record UnitVc UNr;
  row UnitVc UNrw;
  Integer rwcnt,i;
 
  res = ""; 
  UNr.Code = unit;
  if (ReadFirstMain(UNr,1,true)) then begin
    if (blank(langcode)) then begin
      res = UNr.Comment;
      if (blank(res)) then begin
        res = unit;
      end;  
    end else begin
      rwcnt = MatRowCnt(UNr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(UNr,i,UNrw);
        if (UNrw.LangCode==langcode) then begin
          res = UNrw.Text;
          goto LSelectUnitText;
        end;
      end;
      res = UNr.Comment;
      if (blank(res)) then begin
        res = unit;
      end;
    end;
  end else begin
    res = unit;
  end;
LSelectUnitText:;  
  RETURN;
END;

global
procedure GetItemGroup(string artcode,var string res)
BEGIN
  record INVc INr;

  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
    res = INr.Group;
  end;
  RETURN;
END;

global
procedure GetItemCommodityCode(string artcode,var string res)
BEGIN
  record INVc INr;
  
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
    res = INr.EUCodex;
  end;  
  RETURN;
END;

global
procedure GetAlternativeItemCode(string artcode,var string res)
BEGIN
  record INVc INr;
  
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
    res = INr.AlternativeCode;
  end;  
  RETURN;
END;

global
function string 255 GetVarietyComment(string fullcode,string incode)
begin
  string 255 res;
  record INVc INr;
  
  if (ReadFirstItem(fullcode,INr,true,false)) then begin
    res = INr.Name;
    if (ReadFirstMain(INr,1,true)) then begin
      res = Right(res,Len(res)-Len(INr.Name)-2);
    end;
  end else begin
    res = Right(fullcode,Len(fullcode)-Len(incode));
  end;
  GetVarietyComment = res;
  return;
end;

global
function string 255 BC128(string barcode)
begin
  string 255 res;
  string 255 tstr,ns,tstr2,startc;
  Integer i,bcl,n,weight,cc,l;
  val tot,ccv;
  
//this works only for digits in barcode  
  tstr = barcode;
  bcl = len(barcode);
  for (i=0;i<bcl;i=i+1) begin
    if (IsDigit(Mid(barcode,i,1))==false) then begin
      res = USetStr(20861);
      goto LBC128;
    end;
  end;
  if (bcl<4) then begin
    startc = uchr(204);
//B encoding
    l = len(tstr);
    weight = 1;
    i = 0;  
    while (i<l) begin
      ns = Mid(tstr,i,1);
      n = asc(ns)-32;  
      
      tot = tot + n*weight;
      weight = weight + 1;
      i = i + 1;
      res = res & ns;      
    end;
    tot = tot + 104;
  end else begin
//C encoding
    startc = uchr(205);
    if (Mod(bcl,2)!=0) then begin
      tstr = Left(tstr,len(tstr)-1);
    end;
    l = len(tstr);
    weight = 1;
    i = 0;  
    while (i<l) begin
      ns = Mid(tstr,i,2);
      n = StringToInt(ns);  
      tot = tot + n*weight;
      weight = weight + 1;
      i = i + 2;
      switch (n) begin
        case 0:
          res = res & uchr(194);
        otherwise
          res = res & uchr(n+32);
      end;
    end;
    if (Mod(bcl,2)!=0) then begin
      res = res & uchr(200);
      tot = tot + 100*weight; //200 is 100 in BC128 C set
      weight = weight + 1;
      res = res & Right(barcode,1);
      tot = tot + (asc(Right(barcode,1))-32)*weight;
      weight = weight + 1;
    end;  
    tot = tot + 105;
  end; 
  ccv = Mod(tot,103);
  cc = ccv;
  switch (cc) begin
    case 0: cc = 194;//space
    otherwise 
      if (cc>94) then begin
        cc = cc + 100;
      end else begin
        cc = cc + 32;
      end;
  end; 
  res = startc & res & uchr(cc) & uchr(206);
LBC128:;  
  BC128 = res;
  return;
end;
