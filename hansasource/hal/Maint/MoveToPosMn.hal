external procedure CheckFlush(var Integer,Integer);

updating procedure SaveStockMov(var record StockMovVc StockMovr,var Integer flushcnt)
BEGIN
  if (MatRowCnt(StockMovr)>0) then begin
    StockMovr.TransDate = CurrentDate;
    StockMovr.SerNr = NextSerNr("StockMovVc",StockMovr.TransDate,-1,false,"");
    StockMovr.ToForkLiftQue = 1;          
    if (StockMovr.SerNr>=0) then begin
      if (RecordStore(StockMovr,false)) then begin end;
    end;
    CheckFlush(flushcnt,10);
    RecordNew(StockMovr);    
  end;
  RETURN;
END;

updating procedure AddToStockMov(record PUVc PUr,row PUVc PUrw,var record StockMovVc StockMovr,var Integer flushcnt)
BEGIN
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  row StockMovVc newStockMovrw;
  record PosVc Posr;
  record PISVc PISr;
  Boolean TrHs,posfoundf,testf;
  string 20 freepos;
  record INVc INr;

  if ((PUr.Location!=StockMovr.FrLocation) and (nonblank(StockMovr.FrLocation))) then begin
    SaveStockMov(StockMovr,flushcnt);
  end;
  StockMovr.FrLocation = PUr.Location;
  StockMovr.ToLocation = PUr.Location;
  ClearRow(StockMovr,newStockMovrw,1);
  rwcnt = MatRowCnt(StockMovr);
  TrHs = true;
  Posr.Status = 0;
//  Posr.PickOrder = 999999;
  while (LoopKey("Status",Posr,2,TrHs)) begin
    if (Posr.Status!=0) then begin TrHs = false; end;
    testf = true;
    if (Posr.Closed!=0) then begin testf = false; end;        
    if (TrHs and testf) then begin
      PISr.Position = Posr.Code;
      if (ReadFirstKey("Position",PISr,1,true)==false) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(StockMovr,i,StockMovrw);      
          if (StockMovrw.ToPosCode==Posr.Code) then begin
            goto LPOSITIONUSED;
          end;
        end;
        freepos = Posr.Code;
        posfoundf = true;
        TrHs = false;
LPOSITIONUSED:;  
      end;
    end;
  end;
  if (posfoundf) then begin
    newStockMovrw.ArtCode = PUrw.ArtCode;
    newStockMovrw.Quant = PUrw.Quant;
    newStockMovrw.Spec = PUrw.Spec;
    newStockMovrw.SerialNr = PUrw.SerialNr;
    newStockMovrw.OldPrice = PUrw.CostPrice;
    newStockMovrw.ExtraSCost = blankval;
    newStockMovrw.NewPrice = PUrw.CostPrice;
    newStockMovrw.BasePrice = PUrw.UPrice;
    newStockMovrw.Coefficient = PUrw.Coefficient;
    newStockMovrw.UnitXval = PUrw.UnitXval;
    newStockMovrw.UnitYval = PUrw.UnitYval;
    newStockMovrw.UnitZval = PUrw.UnitZval;
    newStockMovrw.FrPosCode = PUrw.PosCode;
    newStockMovrw.ToPosCode = freepos;
    MatRowPut(StockMovr,rwcnt,newStockMovrw);
  end;
  RETURN;
END;

global
updating procedure MoveToPosMn(record RcVc RepSpec)
BEGIN
  LongInt frpu,topu;
  string 20 keystr;
  record StockMovVc StockMovr;
  record PUVc PUr;
  row PUVc PUrw;
  Integer sorting;
  Boolean TrHs,testf;
  Integer i,rwcnt;
  Integer flushcnt;
  
  if (blank(RepSpec.FirstAcc)) then begin
    MessageBox(0,"Specify Position");
    goto LMoveToPosMn; 
  end;
  RecordNew(StockMovr);
  frpu = FirstInRange(RepSpec.f1,10);
  topu = FirstInRange(RepSpec.f1,10);
  if (nonblank(RepSpec.f1)) then begin
    keystr = "SerNr";
    PUr.SerNr = frpu;
    sorting = 1;
  end else begin
    keystr = "TransDate";
    PUr.TransDate = RepSpec.sStartDate;
    sorting = 2;
  end;
  TrHs = true;
  while (LoopKey(keystr,PUr,1,TrHs)) begin
    switch (sorting) begin
      case 1:
        if (PUr.SerNr>topu) then begin TrHs = false; end;
      case 2:
        if (PUr.TransDate>RepSpec.sEndDate) then begin TrHs = false; end;
    end;
    if (TrHs) then begin
      testf = true;
      switch (sorting) begin
        case 1:
          if (PUr.TransDate>RepSpec.sEndDate) then begin testf = false; end;
        case 2:
          if (PUr.SerNr>topu) then begin testf = false; end;
      end;
      if (testf) then begin
        rwcnt = MatRowCnt(PUr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(PUr,i,PUrw);
          if (PUrw.PosCode==RepSpec.FirstAcc) then begin
            AddToStockMov(PUr,PUrw,StockMovr,flushcnt);
          end;
        end;
      end;
    end;
  end;
  SaveStockMov(StockMovr,flushcnt);
LMoveToPosMn:;  
  RETURN;
END;