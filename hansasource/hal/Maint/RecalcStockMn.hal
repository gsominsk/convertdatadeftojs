external procedure IVSumup(var record IVVc,Boolean);
external procedure WSSumup(record WSVc);
external procedure ProdOperationSumup(var record ProdOperationVc);
external procedure ProdSumup(var record ProdVc);
external procedure INTransferSumUp(record INTransferVc);
external procedure RetPUSumUp(var record RetPUVc);
external procedure RetSumUp(var record RetVc);
external procedure SRSumUp(var record SRVc);
external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external procedure FindBatchBestBeforeDate(string,string,var Date);
external procedure SHSumUp(var record SHVc);
external procedure FindPUStockAcc(string,record CostAccBlock,string,string,string,record INVc,Integer,var string,var string,Boolean);
external procedure PUSumUp(var record PUVc);
external updating procedure UnOKItemTransfer(record RetPUVc,record RetPUVc,Boolean);
external updating procedure UnOKSupplierReturn(record RetPUVc,record RetPUVc,Boolean);
external updating procedure UnOKCustomerReturn(record RetVc,record RetVc,Boolean);
external updating procedure UnOKStockRevaluation(record SRVc,record SRVc,Boolean);
external updating procedure UnOKDelivery(record SHVc,record SHVc,Boolean);
external updating procedure UnOKInvoice(record IVVc,record IVVc,Boolean);
external updating procedure UnOKStockDepreciation(record SDVc,record SDVc,Boolean);
external updating procedure UnOKGoodsReceipt(record PUVc,record PUVc,Boolean);
external updating procedure UnOKProduction(record ProdVc,record ProdVc,Boolean);
external updating procedure UnOKProductionOperation(record ProdOperationVc,record ProdOperationVc,Boolean);
external updating procedure UnOKWorkSheet(record WSVc,record WSVc,Boolean);
external updating procedure UnOKStockMovement(record StockMovVc,record StockMovVc,Boolean);

external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function string 255 FindINObjects(string,string);
external procedure SDSumUp(var record SDVc);
external procedure UpdateSDFIFO(record SDVc);
external updating procedure RebuildReservations();
external updating function LongInt FillTempStockWithItemHist(Integer,Boolean,Date,Boolean);
external updating procedure EmptyTempStock(Boolean);
external updating procedure UpdateRecalcStockNeeded(Integer);

updating procedure RecalcStockPU(LongInt nr,Integer action)
begin
  record PUVc PUr;
  record PUVc oPUr;
  row PUVc PUrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  string 255 stockacc,purchacc;
  record CostAccBlock CAb;
  record CUVc VEr;
    
  PUr.SerNr = nr;
  if (ReadFirstMain(PUr,1,true)) then begin
    BlockLoad(CAb);    
    RecordCopy(oPUr,PUr);
    switch (action) begin
      case 0:
        PUr.OKFlag = 0;
        UnOKGoodsReceipt(PUr,oPUr,false);    
        updfailed = RecordUpdate(oPUr,PUr,false)!=0;
      case 1:
        VEr.Code = PUr.VECode;
        if (ReadFirstMain(VEr,1,true)) then begin
        end;
        PUr.Objects = VEr.VEObjects;
        rwcnt = MatRowCnt(PUr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(PUr,i,PUrw);
          ReadFirstItem(PUrw.ArtCode,INr,true,true);
          if (blank(PUrw.Location)) then begin
            FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUr.Location,INr,PUrw.StockType,stockacc,purchacc,true);
          end else begin
            FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUrw.Location,INr,PUrw.StockType,stockacc,purchacc,true);
          end;
          PUrw.CostAcc = stockacc;
          PUrw.CredAcc = purchacc;
          PUrw.InPrice = INr.InPrice;
          PUrw.Objects = FindINObjects(INr.Objects,INr.Group);
          MatRowPut(PUr,i,PUrw);
        end;
        PUSumUp(PUr);
        updfailed = RecordUpdate(oPUr,PUr,false)!=0;
        
        if (updfailed==false) then begin
          RecordCopy(oPUr,PUr);
          PUr.OKFlag = 1;
          updfailed = RecordUpdate(oPUr,PUr,true)!=0;
        end;
        if (updfailed) then begin
        end;    
    end;

  end;  
  return;
end;

updating procedure RecalcStockProd(LongInt nr,Integer status,Integer action)
begin
  record ProdVc Prodr;
  record ProdVc oProdr;
  row ProdVc Prodrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
    
  Prodr.SerNr = nr;
  if (ReadFirstMain(Prodr,1,true)) then begin
    RecordCopy(oProdr,Prodr);
    switch (action) begin
      case 0:
        Prodr.PRStatusFlag = 0;
        UnOKProduction(Prodr,oProdr,false);
        updfailed = RecordUpdate(oProdr,Prodr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(Prodr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Prodr,i,Prodrw);
          ReadFirstItem(Prodrw.Item,INr,true,true);
          Prodrw.Objects = FindINObjects(INr.Objects,INr.Group);
          MatRowPut(Prodr,i,Prodrw);
        end;
        ProdSumUp(Prodr);
        updfailed = RecordUpdate(oProdr,Prodr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oProdr,Prodr);
          Prodr.PRStatusFlag = status;
          updfailed = RecordUpdate(oProdr,Prodr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockProdOperation(LongInt nr,Integer status,Integer action)
begin
  record ProdOperationVc ProdOr;
  record ProdOperationVc oProdOr;
  row ProdOperationVc ProdOrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
    
  ProdOr.SerNr = nr;
  if (ReadFirstMain(ProdOr,1,true)) then begin
    RecordCopy(oProdOr,ProdOr);
    switch (action) begin
      case 0:
        ProdOr.PRStatusFlag = 0;
        UnOKProductionOperation(ProdOr,oProdOr,false);
        updfailed = RecordUpdate(oProdOr,ProdOr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(ProdOr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(ProdOr,i,ProdOrw);
          ReadFirstItem(ProdOrw.Item,INr,true,true);
          ProdOrw.Objects = FindINObjects(INr.Objects,INr.Group);
          MatRowPut(ProdOr,i,ProdOrw);
        end;
        ProdOperationSumup(ProdOr);
        updfailed = RecordUpdate(oProdOr,ProdOr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oProdOr,ProdOr);
          ProdOr.PRStatusFlag = status;
          updfailed = RecordUpdate(oProdOr,ProdOr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockSD(LongInt nr,Integer action)
begin
  record SDVc SDr;
  record SDVc oSDr;
  row SDVc SDrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  
  SDr.SerNr = nr;
  if (ReadFirstMain(SDr,1,true)) then begin
    RecordCopy(oSDr,SDr);
    switch (action) begin
      case 0:
        SDr.OKFlag = 0;
        UnOKStockDepreciation(SDr,oSDr,false);
        updfailed = RecordUpdate(oSDr,SDr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(SDr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SDr,i,SDrw);
          ReadFirstItem(SDrw.ArtCode,INr,true,true);
          SDrw.Objects = FindINObjects(INr.Objects,INr.Group);
          SDrw.BasePrice = INr.UPrice1;
          MatRowPut(SDr,i,SDrw);
        end;
        SDSumUp(SDr);
        updfailed = RecordUpdate(oSDr,SDr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oSDr,SDr);
          SDr.OKFlag = 1;
          updfailed = RecordUpdate(oSDr,SDr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockWS(LongInt nr,Integer action)
begin
  record WSVc WSr;
  record WSVc oWSr;
  row WSVc WSrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed,testf;
  string 255 costacc,tstr;
  record AccBlock ARb;
  record CostAccBlock CAb;
  
  WSr.SerNr = nr;
  if (ReadFirstMain(WSr,1,true)) then begin
    BlockLoad(ARb);
    BlockLoad(CAb);
    RecordCopy(oWSr,WSr);
    switch (action) begin
      case 0:
        if (WSr.UpdStockFlag!=0) then begin
          WSr.OKFlag = 0;
          UnOKWorkSheet(WSr,oWSr,false);
          updfailed = RecordUpdate(oWSr,WSr,false)!=0;
        end;
      case 1:
        testf = true;
        if (WSr.UpdStockFlag==0) then begin
          testf = false;
        end;
        if (testf) then begin
          rwcnt = MatRowCnt(WSr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(WSr,i,WSrw);
            ReadFirstItem(WSrw.ArtCode,INr,true,true);
            WSrw.Objects = FindINObjects(INr.Objects,INr.Group);
            WSrw.BasePrice = INr.UPrice1;
            if (GetCOSAcc("",WSr.CustCode,WSr.Location,ARb,INr,CAb.ItemGroupAccounts,false,0,costacc,tstr)==false) then begin
            end;
            WSrw.CostAcc = costacc;
            MatRowPut(WSr,i,WSrw);
          end;
          WSSumUp(WSr);
          updfailed = RecordUpdate(oWSr,WSr,false)!=0;
          if (updfailed==false) then begin
            RecordCopy(oWSr,WSr);
            WSr.OKFlag = 1;
            updfailed = RecordUpdate(oWSr,WSr,true)!=0;
          end;
          if (updfailed) then begin
          end;
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockRet(LongInt nr,Integer action)
begin
  record RetVc Retr;
  record RetVc oRetr;
  row RetVc Retrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  
  Retr.SerNr = nr;
  if (ReadFirstMain(Retr,1,true)) then begin
    RecordCopy(oRetr,Retr);
    switch (action) begin
      case 0:
        Retr.OKFlag = 0;
        UnOKCustomerReturn(Retr,oRetr,false);    
        updfailed = RecordUpdate(oRetr,Retr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(Retr);
  /*    
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Retr,i,Retrw);
          ReadFirstItem(Retrw.ArtCode,INr,true,true);
          Retrw.Objects = FindINObjects(INr.Objects,INr.Group);
          Retrw.BasePrice = INr.UPrice1;
          MatRowPut(Retr,i,Retrw);
        end;
  */    
        RetSumUp(Retr);
        updfailed = RecordUpdate(oRetr,Retr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oRetr,Retr);
          Retr.OKFlag = 1;
          updfailed = RecordUpdate(oRetr,Retr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockINTransfer(LongInt nr,Integer action)
begin
  record INTransferVc INTr;
  record INTransferVc oINTr;
  row INTransferVc INTrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  
  INTr.SerNr = nr;
  if (ReadFirstMain(INTr,1,true)) then begin
    RecordCopy(oINTr,INTr);
    switch (action) begin
      case 0:
        INTr.OKFlag = 0;
        UnOKItemTransfer(INTr,oINTr,false);
        updfailed = RecordUpdate(oINTr,INTr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(INTr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(INTr,i,INTrw);
          ReadFirstItem(INTrw.ArtCode,INr,true,true);
          INTrw.Objects = FindINObjects(INr.Objects,INr.Group);
//              INTrw.FIFO = PUrw.CostPrice;
          MatRowPut(INTr,i,INTrw);
        end;
        INTransferSumUp(INTr);
        updfailed = RecordUpdate(oINTr,INTr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oINTr,INTr);
          INTr.OKFlag = 1;
          updfailed = RecordUpdate(oINTr,INTr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockRetPU(LongInt nr,Integer action)
begin
  record RetPUVc RetPUr;
  record RetPUVc oRetPUr;
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  record PUVc PUr;
  row PUVc PUrw;
  
  RetPUr.SerNr = nr;
  if (ReadFirstMain(RetPUr,1,true)) then begin
    RecordCopy(oRetPUr,RetPUr);
    switch (action) begin
      case 0:
        RetPUr.OKFlag = 0;
        UnOKSupplierReturn(RetPUr,oRetPUr,false);
        updfailed = RecordUpdate(oRetPUr,RetPUr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(RetPUr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(RetPUr,i,RetPUrw);
          PUr.SerNr = RetPUrw.PUNr;
          if (PUr.SerNr<=0) then begin          
            PUr.SerNr = RetPUr.PUNr;
          end;
          if (ReadFirstMain(PUr,1,true)) then begin
            if (RetPUrw.PURow<MatRowCnt(PUr)) then begin
              MatRowGet(PUr,RetPUrw.PURow,PUrw);
              RetPUrw.SerialNr = PUrw.SerialNr;
              RetPUrw.PUCostPrice = PUrw.Sum/PUrw.Quant;
            end;
          end;
/*          
          ReadFirstItem(RetPUrw.ArtCode,INr,true,true);
          RetPUrw.Objects = PUrw.Objects;
          RetPUrw.CostAcc = PUrw.CostAcc;
          RetPUrw.CredAcc = PUrw.CredAcc;
          if (nonblank(ARb.RetPUAcc)) then begin
            if (ARb.UsePUAccInRetPU==0) or (blank(RetPUrw.CredAcc))  then begin
              RetPUrw.CredAcc = ARb.RetPUAcc;
            end;
          end;
*/          
          MatRowPut(RetPUr,i,RetPUrw);
        end;
        RetPUSumUp(RetPUr);
        updfailed = RecordUpdate(oRetPUr,RetPUr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oRetPUr,RetPUr);
          RetPUr.OKFlag = 1;
          updfailed = RecordUpdate(oRetPUr,RetPUr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockSR(LongInt nr,Integer action)
begin
  record SRVc SRr;
  record SRVc oSRr;
  row SRVc SRrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  record LocationVc Locr;
  
  SRr.SerNr = nr;
  if (ReadFirstMain(SRr,1,true)) then begin
    RecordCopy(oSRr,SRr);
    switch (action) begin
      case 0:
        SRr.OKFlag = 0;
        UnOKStockRevaluation(SRr,oSRr,false);
        updfailed = RecordUpdate(oSRr,SRr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(SRr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SRr,i,SRrw);
          ReadFirstItem(SRrw.ArtCode,INr,true,true);
          SRrw.Objects = FindINObjects(INr.Objects,INr.Group);
          Locr.Code = SRrw.Location;
          if (ReadFirstMain(Locr,1,true)) then begin
            SRrw.Objects = Locr.Objects;
          end;
          MatRowPut(SRr,i,SRrw);
        end;
        SRSumUp(SRr);
        updfailed = RecordUpdate(oSRr,SRr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oSRr,SRr);
          SRr.OKFlag = 1;
          updfailed = RecordUpdate(oSRr,SRr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockSH(LongInt nr,Integer action)
begin
  record SHVc SHr;
  record SHVc oSHr;
  row SHVc SHrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  Date dat;
  string 255 costacc,tstr,location;
  record AccBlock ARb;
  record CostAccBlock CAb;
  
  SHr.SerNr = nr;
  if (ReadFirstMain(SHr,1,true)) then begin
    BlockLoad(ARb);
    BlockLoad(CAb);
    RecordCopy(oSHr,SHr);
    switch (action) begin
      case 0:
        SHr.OKFlag = 0;
        UnOKDelivery(SHr,oSHr,false);
        updfailed = RecordUpdate(oSHr,SHr,false)!=0;
      case 1:
        rwcnt = MatRowCnt(SHr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SHr,i,SHrw);
          ReadFirstItem(SHrw.ArtCode,INr,true,true);
          FindBatchBestBeforeDate(SHrw.ArtCode,SHrw.SerialNr,dat);
          SHrw.BestBefore = dat;
          location = SHrw.Location;
          if (blank(location)) then begin
            location = SHr.Location;
          end;
          if (CAb.NoNLCostOnShip==2) then begin
            costacc = ARb.COSAccrualAcc;
          end else begin
            if (GetCOSAcc(SHrw.CostAcc,SHr.CustCode,location,ARb,INr,CAb.ItemGroupAccounts,false,0,costacc,tstr)==true) then begin
            end;
          end;
          SHrw.CostAcc = costacc;
          MatRowPut(SHr,i,SHrw);
        end;
        SHSumUp(SHr);
        updfailed = RecordUpdate(oSHr,SHr,false)!=0;
        if (updfailed==false) then begin
          RecordCopy(oSHr,SHr);
          SHr.OKFlag = 1;
          updfailed = RecordUpdate(oSHr,SHr,true)!=0;
        end;
        if (updfailed) then begin
        end;
    end;
  end;  
  return;
end;

updating procedure RecalcStockStockMov(LongInt nr,Integer action)
begin
  record StockMovVc SMr;
  record StockMovVc oSMr;
  row StockMovVc SMrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed;
  Date dat;
  string 255 costacc,tstr;
  record AccBlock ARb;
  record CostAccBlock CAb;
  
  SMr.SerNr = nr;
  if (ReadFirstMain(SMr,1,true)) then begin
    BlockLoad(ARb);
    BlockLoad(CAb);
    RecordCopy(oSMr,SMr);
    switch (action) begin
      case 0:
        SMr.OKFlag = 0;
        UnOKStockMovement(SMr,oSMr,false);
        updfailed = RecordUpdate(oSMr,SMr,false)!=0;
        if (updfailed==false) then begin
          if (SMr.SentOKFlag!=0) then begin
            RecordCopy(oSMr,SMr);
            SMr.SentOKFlag = 0;
            UnOKStockMovement(oSMr,SMr,false);
            updfailed = RecordUpdate(oSMr,SMr,false)!=0;
          end;
        end;
      case 1:              
        RecordCopy(oSMr,SMr);
        rwcnt = MatRowCnt(SMr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SMr,i,SMrw);
          ReadFirstItem(SMrw.ArtCode,INr,true,true);
          MatRowPut(SMr,i,SMrw);
        end;
        updfailed = RecordUpdate(oSMr,SMr,false)!=0;
        if (nonblank(SMr.ThrouLocation)) then begin
          RecordCopy(oSMr,SMr);
          SMr.SentOKFlag = 1;
          updfailed = RecordUpdate(oSMr,SMr,true)!=0;
        end;
        if (updfailed==false) then begin
          RecordCopy(oSMr,SMr);
          SMr.OKFlag = 1;
          updfailed = RecordUpdate(oSMr,SMr,true)!=0;
        end;
        if (updfailed) then begin
        end;    
    end;
  end;  
  return;
end;

procedure UpdateInvoiceFIFO(record IVVc IVr)
begin
  if (IVr.OrderNr>0) then begin
    
  end;
  return;
end;

updating procedure RecalcStockIV(LongInt nr,Integer action)
begin
  record IVVc IVr;
  record IVVc oIVr;
  row IVVc IVrw;
  Integer i,rwcnt;
  record INVc INr;
  Boolean updfailed,testf;
  Date dat;
  string 255 costacc,tstr;
  record AccBlock ARb;
  record CostAccBlock CAb;
  
  IVr.SerNr = nr;
  if (ReadFirstMain(IVr,1,true)) then begin  
    BlockLoad(ARb);    
    BlockLoad(CAb);
    RecordCopy(oIVr,IVr);
    switch (action) begin
      case 0:
        if (IVr.UpdStockFlag!=0) then begin
          IVr.OKFlag = 0;
          UnOKInvoice(IVr,oIVr,false);
          updfailed = RecordUpdate(oIVr,IVr,false)!=0;
        end;
      case 1:
        testf = true;
        if (IVr.UpdStockFlag==0) then begin
          testf = false;
        end;
        if (testf) then begin
        
          rwcnt = MatRowCnt(IVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IVr,i,IVrw);
            ReadFirstItem(IVrw.ArtCode,INr,true,true);
            MatRowPut(IVr,i,IVrw);
          end;
          IVSumup(IVr,true);
          updfailed = RecordUpdate(oIVr,IVr,false)!=0;
          if (updfailed==false) then begin
            RecordCopy(oIVr,IVr);
  //          UpdateInvoiceFIFO(IVr);
            IVr.OKFlag = 1;
            updfailed = RecordUpdate(oIVr,IVr,true)!=0;
          end;
          if (updfailed) then begin
          end;
        end;
    end;
  end;  
  return;
end;

updating procedure EmptyItemHist(Date startd)
begin
  record ItemHistVc IHr;
  string 255 index;
  Boolean found;
  
  index = "SerNr";
  if (nonblankdate(startd)) then begin
    index = "TransDate";
    IHr.TransDate = startd;
  end;
  found = true;
  while (LoopKey(index,IHr,1,found)) begin
    if (nonblankdate(startd)) then begin
      if (IHr.TransDate<startd) then begin found = false; end;
    end;
    if (found) then begin
      RecordDelete(IHr);
      StepBack(IHr);
    end;
  end;
  return;
end;

global
updating procedure RecalcStockMn(record RcVc RepSpec)
begin
  transaction string 255 gRuniningMaint;
  LongInt missed;
  record MainStockBlock MSb;
  record TempStockVc TSr;
  LongInt r,totr;
  LongInt nexttick;
  LongInt nowtick;
  Integer segments;
  Date ignoredate;
  string 255 index;
  Boolean testf;
  
  if (blankdate(RepSpec.d1)) then begin
    goto LRecalcStockMn;
  end;
  gRuniningMaint = "RecalcStockMn";
  BlockLoad(MSb);
  SetDatabaseToUnsafeMode;
  EmptyTempStock(false);
  MaintTrace("Adding to Temp Stock");
  missed = FillTempStockWithItemHist(MSb.Chronology,true,RepSpec.d1,false);

  MaintTrace("Emptying Item History");
  EmptyItemHist(RepSpec.d1);

  r = CountRecords("TempStockVc");
  totr = r;
  MaintTrace("Rebuilding Item History: " & r & " left of " & totr);
  nexttick = GetCurTick() + 10000;

  ResetLoop(TSr);
  switch (MSb.Chronology) begin
    case 1:
      index = "LocationLocOKNr";
    otherwise
      index = "LocOKNr";
  end;
  segments = 1;
  while (LoopKey(index,TSr,segments,true)) begin
    testf = true;
    if (nonblankdate(ignoredate)) then begin
      if (TSr.TransDate<=ignoredate) then begin
        if (TSr.FileName!="RegArchiveDetailVc") then begin
          testf = false;
        end;
      end;
    end;
    if (testf) then begin
      switch (TSr.FileName) begin
        case "IVVc":         RecalcStockIV(TSr.TransNr,0);
//        case "InvalidatedIVVc":         RecalcStockIV(TSr.TransNr);
        case "SHVc":         RecalcStockSH(TSr.TransNr,0);
        case "PUVc":         RecalcStockPU(TSr.TransNr,0);
        case "StockMovVc":   RecalcStockStockMov(TSr.TransNr,0);
        case "StockMov4Vc":  RecalcStockStockMov(TSr.TransNr,0);
        case "SDVc":         RecalcStockSD(TSr.TransNr,0);
        case "SRVc":         RecalcStockSR(TSr.TransNr,0);
        case "RetVc":        RecalcStockRet(TSr.TransNr,0);
        case "RetPUVc":      RecalcStockRetPU(TSr.TransNr,0);
        case "INTransferVc": RecalcStockINTransfer(TSr.TransNr,0);
        case "ProdVc":       RecalcStockProd(TSr.TransNr,0,0);
        case "ProdOperationVc": RecalcStockProdOperation(TSr.TransNr,0,0);
        case "WSVc":         RecalcStockWS(TSr.TransNr,0);
/*        
        case "RegArchiveDetailVc": ItemHistRegArchive(TSr.TransNr,MSb);
*/      
      end;
    end;

    r = r - 1;
    
    nowtick = GetCurTick();
    
    if (nowtick>nexttick) then begin
      MaintTrace("Building Item History: " & r & " left of " & totr);
      nexttick = nowtick + 10000;
    end;
    
  end;
  
  ResetLoop(TSr);
  RecordClear(TSr);
  while (LoopKey(index,TSr,segments,true)) begin
    testf = true;
    if (nonblankdate(ignoredate)) then begin
      if (TSr.TransDate<=ignoredate) then begin
        if (TSr.FileName!="RegArchiveDetailVc") then begin
          testf = false;
        end;
      end;
    end;
    if (TSr.OKStatus==0) then begin
      testf = false;
    end;
    if (testf) then begin
      switch (TSr.FileName) begin
        case "IVVc":         RecalcStockIV(TSr.TransNr,1);
//        case "InvalidatedIVVc":         RecalcStockIV(TSr.TransNr);
        case "SHVc":         RecalcStockSH(TSr.TransNr,1);
        case "PUVc":         RecalcStockPU(TSr.TransNr,1);
        case "StockMovVc":   RecalcStockStockMov(TSr.TransNr,1);
        case "StockMov4Vc":  RecalcStockStockMov(TSr.TransNr,1);
        case "SDVc":         RecalcStockSD(TSr.TransNr,1);
        case "SRVc":         RecalcStockSR(TSr.TransNr,1);
        case "RetVc":        RecalcStockRet(TSr.TransNr,1);
        case "RetPUVc":      RecalcStockRetPU(TSr.TransNr,1);
        case "INTransferVc": RecalcStockINTransfer(TSr.TransNr,1);
        case "ProdVc":       RecalcStockProd(TSr.TransNr,TSr.OKStatus,1);
        case "ProdOperationVc": RecalcStockProdOperation(TSr.TransNr,TSr.OKStatus,1);
        case "WSVc":         RecalcStockWS(TSr.TransNr,1);
/*        
        case "RegArchiveDetailVc": ItemHistRegArchive(TSr.TransNr,MSb);
*/      
      end;
    end;

    RecordDelete(TSr);
    StepBack(TSr);
 
    r = r - 1;
    
    nowtick = GetCurTick();
    
    if (nowtick>nexttick) then begin
      MaintTrace("Building Item History: " & r & " left of " & totr);
      nexttick = nowtick + 10000;
    end;
    
  end;
    
  RebuildReservations;
  
//  EmptyTempStock(false);
  UpdateRecalcStockNeeded(0);
  SetDatabaseToSafeMode;

  if (missed>0) then begin
    MessageBox(0,"Records skipped = " & missed);
  end;
LRecalcStockMn:;
  gRuniningMaint = "";
  return;
end;