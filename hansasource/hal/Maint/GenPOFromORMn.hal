external procedure POVc_PasteQuant(var record POVc,Integer);
external function Boolean POVc_PasteArtCode(var record POVc,Integer,Boolean);
external function Boolean PODchrsum(record POVc,Integer);
external function string 255 FillupTaxMatrix(Integer,string,string,string,string,string,var record TaxMatrixVc);
external function Boolean GetItemPurchasePriceDiscount(string,string,Date,string,string,val,string,string,string,string,Integer,Boolean,val,val,val,val,val,
         var record INVc,var record PIVc,var Boolean,var val,var string,var val,var string,var string,var Boolean,var string);
external function roundmode SetRoundModeD(Integer);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external function Boolean CheckVARSubsets(record VARVc,string,string);
external function Integer FindYVars(string,string,string);
external procedure ExtractObj(string,var Integer,var string);
external function string 255 FindINObjects(string,string);
external procedure GetINPurchaseControlAcc(record INVc,var string,string,string,Integer);
external function Boolean FindPItem(string,string,var record PIVc,string,Integer);
external function Boolean FindPOQantity2(record INVc,record ItemStatusVc,Boolean,string,record PIVc,var val,var val,var val,val,Boolean,Boolean,Boolean,Boolean);
external function Integer ValidatePORecord(var record POVc,record POVc,LongInt,LongInt,Boolean,var string);
external procedure CheckFlush(var Integer,Integer);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstPurchaseItem2(string,string,string,var record PIVc);
external function Boolean CorrectItemVAR(string,var string,var string,Boolean);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external procedure DivPIFactor(val,val,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function Boolean PasteVEInPO(var record POVc,Boolean);
external procedure SetPOFlags(record POVc,Boolean);
external procedure POSumup(var record POVc);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external procedure RoundRowSum(string,string,string,var val);

function Boolean DoFindPItem(string itemcode,string location,var record PIVc PIr,string veselect,Integer matchve,Integer flags1)
begin
  Boolean res;
  
  if (flags1==0) then begin
    res = FindPItem(itemcode,location,PIr,veselect,matchve);
  end else begin
    res = false;
    if (matchve==0 or blank(veselect)) then begin
      goto LDoFindPItem;
    end;
    
    PIr.DefaultChoice = 1;
    PIr.ItemCode = itemcode;
    PIr.Location = location;
    PIr.VECode = veselect;
    res = ReadFirstKey("DefaultChoice",PIr,4,true);
    
    if (res==false) then begin
      PIr.DefaultChoice = 0;
      PIr.ItemCode = itemcode;
      PIr.Location = location;
      PIr.VECode = veselect;
      res = ReadFirstKey("DefaultChoice",PIr,4,true);
    end;
    
    if (res==false and nonblank(location)) then begin
      PIr.DefaultChoice = 1;
      PIr.ItemCode = itemcode;
      PIr.Location = "";
      PIr.VECode = veselect;
      res = ReadFirstKey("DefaultChoice",PIr,4,true);
      
      if (res==false) then begin
        PIr.DefaultChoice = 0;
        PIr.ItemCode = itemcode;
        PIr.Location = "";
        PIr.VECode = veselect;
        res = ReadFirstKey("DefaultChoice",PIr,4,true);
      end;
    end;
  end;
  
LDoFindPItem:;
  DoFindPItem = res;
end;

global
procedure AddPORow(record POVc POp,record INVc INp,LongInt ordrow,string itemcode,Integer ordertype,record PIVc PIp,val ordqtyp,string objects)
BEGIN
  Integer i,rwcnt,j;
  row POVc POrw;
  row PIVc PIrw;
  string 60 sz,msk,mskrep;
  string 200 varsubset;
  string 255 tstr,descstr,vatcode,purchacc,taxtemplatecode;
  val price,reb,t;
  record TaxMatrixVc TMr;
  record INVc INr;
  record PIVc PIr;
  Boolean pifound;
  Boolean nomoreremotecalls;
  
//GetItemPurchasePriceDiscount
  
  rwcnt = MatRowCnt(POp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (POrw.ArtCode==PIp.ItemCode and (POrw.OrdRow==ordrow or ordrow<0)) then begin
      if ((nonblank(POrw.VEArtCode)) or (nonblank(PIp.VEItemCode))) then begin
        if (POrw.VEArtCode==PIp.VEItemCode) then begin
          goto LAddPORow;
        end;
      end else begin // If both VEArtCodes are blank, they should be considered as same item as well.
        goto LAddPORow;
      end;
    end;
  end;
  ClearRow(POp,POrw,1);
  i = rwcnt;
  POrw.stp = 1;
  POrw.ovst = 0;
  POrw.OrderType = ordertype;
  POrw.VEArtCode = PIp.VEItemCode;
  POrw.ArtCode = itemcode; // I think it Should it be like this
  if (blank(POrw.ArtCode)) then begin
    POrw.ArtCode = PIp.ItemCode;
  end;
  POrw.Quant = blankval;
  if (FindItemVAR(INp.Code,sz,msk,mskrep,varsubset)) then begin
    tstr = INp.Name;
  end else begin
    if (nonblank(PIp.Comment)) then begin 
      tstr = PIp.Comment;
    end else begin 
      tstr = INp.Name;
    end;
  end;
  POrw.Spec = tstr;
  POrw.UnitCode = INp.Unittext;
  POrw.VEUnit = PIp.VEUnit;
  tstr = "";
  GetINPurchaseControlAcc(INp,tstr,POp.VECode,POp.Location,POrw.StockType);
  POrw.CostAcc = tstr;
  if (PIp.PurPrice!=0) then begin 
    t = PIp.PurPrice;
    if (nonblank(PIp.CurncyCode)) then begin
      CurValToOtherCur(CurrentDate,PIp.CurncyCode,PIp.PurPrice,POp.CurncyCode,t,DefaultCurRoundOff);
    end;
  end else begin
    t = INp.InPrice;
  end;
  POrw.Price = t;
  POrw.Sum = blankval;
  POrw.vRebate = blankval;
  if (nonblank(objects)) then begin
    POrw.Objects = objects;
  end else begin
    POrw.Objects = FindINObjects(INp.Objects,INp.Group);
  end;
  POrw.Shipd2 = blankval;
  POrw.Shipd1 = blankval;
  POrw.PIFactor = PIp.PIFactor;
  POrw.VEUnit =  PIp.VEUnit;
  POrw.VATCode = POp.VEVATCode;
  POrw.TaxTemplateCode = POp.VETaxTemplateCode;
  if (blank(POrw.VATCode)) then begin
    vatcode = "";
    GetItemVATCode(POrw.ArtCode,POp.ExportFlag,vatcode,false);
    POrw.VATCode = vatcode;
  end;
LAddPORow:;
  POrw.Quant = POrw.Quant + ordqtyp;
  if (POrw.Quant<PIp.MinPOQty) then begin POrw.Quant = PIp.MinPOQty; end;
  DivPIFactor(POrw.Quant,POrw.PIFactor,t);
  POrw.VEQuant = t;
  CalcSum(POrw.VEQuant,POrw.Price,0,POrw.vRebate,t,0);
  RoundRowSum(POp.CurncyCode,POp.PayDeal,"POVc",t);
  POrw.Sum = t;
  POrw.OrdRow = ordrow;  
  INr.Code = INp.Code;
  if  (GetItemPurchasePriceDiscount(POp.VECode,POp.Location,POp.TransDate,POp.CurncyCode,INr.Code,POrw.Quant,
                                    POp.LangCode,"","",POp.RebCode,POp.ExportFlag,true,
                                   POp.FrRate,POp.ToRateB1,POp.ToRateB2,POp.BaseRate1,POp.BaseRate2,
                                   INr,PIr,pifound,price,descstr,reb,vatcode,purchacc,nomoreremotecalls,taxtemplatecode)) then begin
    POrw.TaxTemplateCode = FillupTaxMatrix(1,POp.BranchID,POp.VECode,"","",taxtemplatecode,TMr);
    PackRowFieldMatrix(POrw,"TaxMatrix",TMr);  
  end;  
  MatRowPut(POp,i,POrw);
  PODchrsum(POp,i);
  i = i + 1;
  rwcnt = MatRowCnt(PIp);
  for (j=0;j<rwcnt;j=j+1) begin
    MatRowGet(PIp,j,PIrw);
    ClearRow(POp,POrw,1);
    POrw.Spec = PIrw.Text;
    MatRowPut(POp,i,POrw);
    i = i + 1;
  end;
  RETURN;
END;

procedure AddPORow2(record POVc POp,record INVc INp,Integer ordrow,string itemcode,Integer ordertype,Boolean inf,record PIVc PIp,Boolean pif,val ordqtyp,string comment,string objects)
BEGIN
  Integer rwcnt;
  row POVc POrw;
  string 255 tstr,descstr,vatcode,purchacc,taxtemplatecode;
  val price,reb,t;
  record TaxMatrixVc TMr;
  record INVc INr;
  record PIVc PIr;
  Boolean pifound;
  Boolean nomoreremotecalls;
  
  rwcnt = MatRowCnt(POp);
  ClearRow(POp,POrw,1);
  POrw.stp = 1;
  POrw.ovst = 0;
  POrw.WSNr = -1;
  POrw.OrderType = ordertype;
  if (pif) then begin
    POrw.VEArtCode = PIp.VEItemCode;
//    POrw.ArtCode = PIp.ItemCode;
    POrw.ArtCode = itemcode;
    POrw.Spec = comment;
    POrw.Price = PIp.PurPrice;
    POrw.VATCode = POp.VEVATCode;
  end else begin
    POrw.VEArtCode = "";
    POrw.ArtCode = "";
    if (blank(comment)) then begin
      POrw.Spec = " ";
    end else begin
      POrw.Spec = comment;
    end;
    POrw.Price = blankval;
  end;
  POrw.Quant = blankval;
  POrw.Sum = blankval;
  POrw.vRebate = blankval;
  if (inf) then begin
    if (blank(POrw.VATCode)) then begin
      GetItemVATCode(POrw.ArtCode,POp.ExportFlag,tstr,false);
      POrw.VATCode = tstr;
    end;
  end;
  POrw.Objects = objects;
  POrw.Shipd2 = blankval;
  POrw.Shipd1 = blankval;
  POrw.PIFactor = blankval;
  POrw.VEQuant = blankval;    
  if (nonblank(ordqtyp)) then begin
    POrw.Quant = POrw.Quant + ordqtyp;
    POrw.PIFactor = PIp.PIFactor;
    DivPIFactor(POrw.Quant,POrw.PIFactor,t);
    POrw.VEQuant = t;
    CalcSum(POrw.VEQuant,POrw.Price,0,POrw.vRebate,t,0);
    RoundRowSum(POp.CurncyCode,POp.PayDeal,"POVc",t);
    POrw.Sum = t;
  end;
  POrw.OrdRow = ordrow;
  INr.Code = INp.Code;
  if  (GetItemPurchasePriceDiscount(POp.VECode,POp.Location,POp.TransDate,POp.CurncyCode,PIr.ItemCode,POrw.Quant,
                                    POp.LangCode,"","",POp.RebCode,POp.ExportFlag,true,
                                   POp.FrRate,POp.ToRateB1,POp.ToRateB2,POp.BaseRate1,POp.BaseRate2,
                                   INr,PIr,pifound,price,descstr,reb,vatcode,purchacc,nomoreremotecalls,taxtemplatecode)) then begin
    POrw.TaxTemplateCode = FillupTaxMatrix(1,POp.BranchID,POp.VECode,"","",taxtemplatecode,TMr);
    PackRowFieldMatrix(POrw,"TaxMatrix",TMr);  
  end;
  MatRowPut(POp,rwcnt,POrw);
  PODchrsum(POp,rwcnt);
  RETURN;
END;

procedure NewPO(record POVc POp,string vecode)
BEGIN
  RecordNew(POp);
  POp.SerNr = NextSerNr("POVc",POp.TransDate,-1,false,"");
  POp.VECode = vecode;
  if (PasteVEInPO(POp,false)) then begin end;
  RETURN;
END;

function Boolean SearchPOforVEandIN(string vecode,string itemcode,record POVc POp,LongInt startponr,string location,Integer requestedtype)
BEGIN
  Boolean found,testf,res;
  Integer rwcnt;
  
  POp.VECode = vecode;
  POp.OKFlag = 0;
  POp.SerNr = startponr;
  res = false;
  found = true;
  while (LoopKey("VECode",POp,3,found)) begin
    if (found) then begin
      if (POp.VECode!=vecode) then begin found = false; end;
    end;
    if (POp.OKFlag!=0) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (POp.Closed!=0) then begin testf = false; end;
      if (POp.SerNr<startponr) then begin testf = false; end;
      if (nonblank(location)) then begin
        if (location!=POp.Location) then begin testf = false; end;
      end;
      rwcnt = MatRowCnt(POp);
      if (rwcnt>=199) then begin testf = false; end;
      if (requestedtype>=0) then begin
        if (POp.OrderType!=requestedtype) then begin testf = false; end;
      end;
      if (testf) then begin
        res = true;
        goto LSearchPOforVEandIN;
      end;
    end;
  end;
LSearchPOforVEandIN:;
  SearchPOforVEandIN = res;
  RETURN;
END;

function Integer SearchPOforVEandIN2(string vecode,string itemcode,record ORVc ORr,record POVc POp,val ordqtyp,Integer requestedtype)
BEGIN
  Boolean found,testf;
  Integer res;
  Integer i,rwcnt;
  row POVc POrw;
  
  POp.VECode = vecode;
  POp.OKFlag = 0;
  found = true;
  while (LoopKey("VECode",POp,2,found)) begin
    if (found) then begin
      if (POp.VECode!=vecode) then begin found = false; end;
    end;
    if (POp.OKFlag!=0) then begin found = false; end;
    if (found) then begin
      testf = true;
      rwcnt = MatRowCnt(POp);
      if (rwcnt>=199) then begin testf = false; end;
      if (POp.OrdNr!=ORr.SerNr) then begin testf = false; end;
      if (POp.Closed!=0) then begin testf = false; end;
      if (POp.PUFlag!=0) then begin testf = false; end;
      if (requestedtype>=0) then begin
        if (POp.OrderType!=requestedtype) then begin testf = false; end;
      end;
      if (testf) then begin
        switch (POp.OrderType) begin
          case kOrderTypeDropShip:
            res = 2;
          otherwise
            res = 1;
        end;        
        goto LSearchPOforVEandIN2;
      end;
    end;
  end;
LSearchPOforVEandIN2:;  
  SearchPOforVEandIN2 = res;
  RETURN;
END;

procedure PasteLocationInPO(record POVc POp)
BEGIN
  record LocationVc Locr;
  
  RecordNew(Locr);
  Locr.Code = POp.Location;
  if (ReadFirstMain(Locr,1,true)) then begin
    POp.ShipAddr0 = Locr.Name;
    POp.ShipAddr1 = Locr.Addr0;
    POp.ShipAddr2 = Locr.Addr1;
    POp.ShipAddr3 = Locr.Addr2;
    POp.DelAddr3 = Locr.Addr3;    
    POp.DelAddr4 = Locr.Addr4;    
  end;  
  RETURN;
END;

updating procedure DoPO2(Integer flags1,Integer flags2,Integer flags5,record INVc INp,record PIVc PIp,val ordqtyp,record ORVc ORp,row ORVc orrw,Integer ordrow,var Boolean addrf,Integer requestedtype)
begin
  record MainStockBlock MainStockRec;
  record POVc oldPOr;
  record POVc POr;
  val t;
  Integer found;
  string 255 location,tstr;
  transaction Boolean gPOVcRecordCheck_Maintf;
  
  gPOVcRecordCheck_Maintf = true;
  found = SearchPOforVEandIN2(PIp.VECode,PIp.ItemCode,ORp,POr,ordqtyp,requestedtype);
//  if (found==2) then begin goto LDoPO2; end;//when more than 2 items in SO we skiped 2nd item , why ? 
  RecordCopy(oldPOr,POr);
  POr.WONr = -1;
  if (found==0) then begin  
    NewPO(POr,PIp.VECode);
    POr.OrdNr = ORp.SerNr;//carefull, back to back
//    POr.OrderType = ORp.OrderType;
    POr.OrderType = requestedtype;
    addrf = true;
    POr.Location = ORp.Location;
    PasteLocationInPO(POr);
  end;
  if ((flags2!=0) and (addrf)) then begin
    if (blank(ORp.ShipAddr0)) then begin
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.Addr0,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.Addr1,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.Addr2,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.Addr3,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.InvAddr3,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.InvAddr4,"");
    end else begin
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.ShipAddr0,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.ShipAddr1,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.ShipAddr2,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.ShipAddr3,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.DelAddr3,"");
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,false,PIp,false,blankval,ORp.DelAddr4,"");
    end;
    addrf = false;
  end;
  if (blank(PIp.PurPrice)) then begin// if no purchase price we use cost price from order 
    PIp.PurPrice = orrw.BasePrice;
  end;
  if (flags1==1) then begin
    AddPORow2(POr,INp,ordrow,orrw.ArtCode,orrw.OrderType,true,PIp,true,ordqtyp,orrw.Spec,orrw.Objects);
  end else begin
    AddPORow(POr,INp,ordrow,orrw.ArtCode,orrw.OrderType,PIp,ordqtyp,orrw.Objects);
  end;
  if (flags5==1) then begin
    POr.Comment = ORp.Comment;
  end;
  if (ORp.OrderType==kOrderTypeDropShip ) then begin
    if (nonblank(ORp.ShipAddr1) or nonblank(ORp.ShipAddr0)) then begin
      POr.ShipAddr0 = ORp.ShipAddr0;
      POr.ShipAddr1 = ORp.ShipAddr1;
      POr.ShipAddr2 = ORp.ShipAddr2;
      POr.ShipAddr3 = ORp.ShipAddr3;
    end else begin 
      POr.ShipAddr0 = ORp.Addr1;
      POr.ShipAddr1 = ORp.Addr2; 
      POr.ShipAddr2 = ORp.Addr3;
      POr.ShipAddr3 = ORp.InvAddr3;
      POr.DelAddr3 = ORp.InvAddr4;
    end;
  end;
  POSumup(POr);
  SetPOFlags(POr,false);
  if (POr.SerNr!=-1) then begin  
    location = POr.Location;
    if (blank(location)) then begin
      BlockLoad(MainStockRec);
      location = MainStockRec.MainStock;
    end;
    if (found==0) then begin
      if (ValidatePORecord(POr,oldPOr,1,0,false,tstr)==0) then begin
        if (RecordStore(POr,false)) then begin
          CreateRecordLink(ORp,CurrentCompany,POr,CurrentCompany);  
          CreateRecordLink(POr,CurrentCompany,ORp,CurrentCompany);  
        end;
      end;
    end else begin
      if (RecordUpdate(oldPOr,POr,true)==0) then begin     
      end;
    end;
    t = blankval;
  end;
LDoPO2:;  
  RETURN;
END;

function Boolean POCreatedforVE(string VECode,Array string apoforve,Integer acnt)
BEGIN
  Boolean res;
  Integer i;
  
  for (i=0;i<acnt;i=i+1) begin
    if (apoforve[i]==VECode) then begin
      res = true;
    end;
  end;
  POCreatedforVE = res;
  RETURN;
END;

updating procedure DoPO(Integer flags1,record INVc INp,record PIVc PIp,val ordqtyp,row ORVc orrw,Boolean orrwf,Boolean newpof,Boolean flushf,var Integer flushcnt,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
BEGIN
  record MainStockBlock MainStockRec;
  record POVc oldPOr;
  record POVc POr;
  val t;
  Boolean found,updateinf;
  string 60 objects;
  string 255 location,tstr;
  
  if (orrwf) then begin
    objects = orrw.Objects;
  end else begin
    objects = "";
  end;
  found = SearchPOforVEandIN(PIp.VECode,PIp.ItemCode,POr,startponr,PIp.Location,requestedtype);
  if (found==false) or ((newpof) and (POCreatedforVE(PIp.VECode,apoforve,acnt)==false)) then begin 
    NewPO(POr,PIp.VECode);
    found = false;
    apoforve[acnt] = PIp.VECode;
    acnt = acnt + 1;
    POr.Location = PIp.Location;
  end;
  RecordCopy(oldPOr,POr);
  if (orrwf) then begin
    if (PIp.PurPrice==0) then begin
      PIp.PurPrice = orrw.BasePrice;
    end;
    if (flags1==1) then begin
      AddPORow2(POr,INp,-1,orrw.ArtCode,orrw.OrderType,true,PIp,true,ordqtyp,orrw.Spec,objects);
    end else begin
      AddPORow(POr,INp,-1,orrw.ArtCode,orrw.OrderType,PIp,ordqtyp,objects);
    end;
  end else begin
    AddPORow(POr,INp,-1,orrw.ArtCode,orrw.OrderType,PIp,ordqtyp,objects);
  end;  
  POSumup(POr);
  SetPOFlags(POr,false);
  if (POr.SerNr!=-1) then begin    
    location = POr.Location;
    if (blank(location)) then begin
      BlockLoad(MainStockRec);
      location = MainStockRec.MainStock;
    end;
    if (found==false) then begin
      if (ValidatePORecord(POr,oldPOr,1,0,false,tstr)==0) then begin
        if (RecordStore(POr,false)) then begin 
          updateinf = true;
          if (newpof) then begin
          if (startponr<=0) then begin
            startponr = POr.SerNr;
          end;
          end;
        end;
      end;
    end else begin
      if (RecordUpdate(oldPOr,POr,true)==0) then begin 
        updateinf = true;
      end;
    end;    
    if (updateinf) then begin
      if (flushf) then begin
        CheckFlush(flushcnt,10);
      end;
      t = blankval;
    end;
  end;
  RETURN;
END;

/* I guess this was trying to fix Varieties problem of PO. */
/* This was done much more complicated than it has to be :-) */
/*
function Boolean ReadFirstPIItem(string incode,record PIVc PIp,Boolean addname,Boolean forcepropervar)
BEGIN
  Boolean res;
  string 60 theitemcode;
  string 255 comment;
  
  if (nonblank(incode)) then begin
    if (CorrectItemVAR(incode,theitemcode,comment,forcepropervar)) then begin
      res = GetFirstPurchaseItem2(theitemcode,"",PIp);
      if (addname) then begin
        if (incode!=theitemcode) then begin
          if (((len(PIp.Comment)) + (len(comment)))<100) then begin
            PIp.Comment = PIp.Comment & comment;
          end;
        end;
      end;
    end;
  end;
  ReadFirstPIItem = res;
  RETURN;
END;
*/

// itemcode is the full item code 10101.RED.45
function Boolean FindPI2(string itemcode,string location,record INVc INp,record PIVc PIp)
BEGIN
  Boolean res;
  record POSettingBlock POSetRec;
  
  res = GetFirstPurchaseItem2(itemcode,location,"",PIp);
  if (res==false) then begin
    res = GetFirstPurchaseItem2(INp.Code,location,"",PIp);
  end;
//  res = ReadFirstPIItem(itemcode,PIp,false,true);
  if (res==false) then begin
    BlockLoad(POSetRec);
    if (nonblank(POSetRec.DefaultSupplier)) then begin
      RecordNew(PIp);
      PIp.ItemCode = itemcode;
      PIp.VEItemCode = itemcode;
      PIp.VECode = POSetRec.DefaultSupplier;
      res = true;
    end;
  end;
  FindPI2 = res;
  RETURN;
END;

procedure GetPriceFromItem(record RcVc RepSpec,record PIVc PIp)
BEGIN
  record INVc INr;
  val cost;
  val frrate,to1,to2,br1,br2;
  
  if (RepSpec.flags[4]==0) then begin
    if (PIp.PurPrice!=0) then begin
      goto LGetPriceFromItem;
    end;
  end;
  if (RepSpec.flags[4]==2) then begin
    if (PIp.PurPrice!=0) then begin goto LGetPriceFromItem; end;
  end;
  INr.Code = PIp.ItemCode;
  if (ReadFirstItem(PIp.ItemCode,INr,true,true)) then begin
    cost = INr.InPrice;
    if (nonblank(PIp.CurncyCode)) then begin
      GetFullCurncyRate(PIp.CurncyCode,CurrentDate,frrate,to1,to2,br1,br2);
      cost = DivRateToBase1(PIp.CurncyCode,cost,frrate,to1,to2,br1,br2,DefaultCurRoundOff);
    end;
    PIp.PurPrice = cost;
  end;
LGetPriceFromItem:;  
  RETURN;
END;

function Boolean FindPOQty2(string artcode,string location,record INVc INp,record ItemStatusVc ISp,record PIVc PIp,val oq,var val t1p,var val t2p,Boolean inclnonstock)
BEGIN
//try to make same as FindPOQantity
  record POSettingBlock POb;
  Boolean res;
  val t,t2;
  
  t1p = blankval;
  t2p = blankval;
  BlockLoad(POb);
  FindStockValue(artcode,"",ISp);
  if (INp.ItemType==1) then begin
    t = ISp.Instock - ISp.OrddOut;
    t1p = t + ISp.POUnOKQty;
    t1p = t1p - ISp.ProdOrd;
  end else begin
    t = -ISp.POUnOKQty;
  end;
  t2p = blankval;
  if (t1p<INp.MinLevel) then begin
    t2p = INp.MinLevel - t1p;
  end;
  
  if (inclnonstock==false) then begin
    if (INp.ItemType==1) then begin 
      res = FindPI2(artcode,location,INp,PIp); 
    end;
  end else begin
    res = FindPI2(artcode,location,INp,PIp); 
  end;
  if (res) then begin
    if (t2p>0) then begin
      if (PIp.NormPOQty!=0) then begin
        if (PIp.NormPOQty>t2p) then begin t2p = PIp.NormPOQty; end;
        if (t2p<oq) then begin
          t2p = oq;
        end;
        if (POb.UseNormOrdMult!=0) then begin
          t = t2p/PIp.NormPOQty;
          t = t + 49999.00/100000.00;
          t = Round(t,SetRoundModeD(0));
          t2p = t*PIp.NormPOQty;
        end;
      end;
      if (PIp.MinPOQty!=0) then begin
        if (PIp.MinPOQty>t2p) then begin t2p = blankval; end;
      end;
    end else begin
      t2p = oq;
    end;
  end else begin
    t2p = oq;
  end;
  FindPOQty2 = res;
  RETURN;
END;

updating procedure DoPOGroup(Integer flags1,Integer flags2,record INVc INp,record PIVc PIp,val ordqtyp,record ORVc ORp,string spec,val orpr,Boolean flushf,var Integer flushcnt,var LongInt startponr)
BEGIN
  record POVc oldPOr;
  record POVc POr;
  val t;
  Boolean found;
  Integer i,line,rwcnt;
  row POVc POrw;
  string 255 tstr,t2;
  
  tstr = USetStr(1816) & " " & ORp.SerNr;
  found = SearchPOforVEandIN(PIp.VECode,PIp.ItemCode,POr,startponr,"",-1);
  RecordCopy(oldPOr,POr);
  if (found==false) then begin
    NewPO(POr,PIp.VECode);
  end;
  rwcnt = MatRowCnt(POr);
  line = -1;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POr,i,POrw);
    if (POrw.Spec==tstr) then begin
      line = i;
      i = rwcnt;
    end;
  end;
  if (line==-1) then begin
    if (rwcnt>0) then begin
      AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,"","");
    end;
    AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,tstr,"");
    if (HasLocalization("NOR")) then begin
      AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.Comment,"");
    end;
    if (flags2==1) then begin
      if (blank(ORp.ShipAddr0)) then begin
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.Addr0,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.Addr1,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.Addr2,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.Addr3,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.InvAddr3,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.InvAddr4,"");
      end else begin
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.ShipAddr0,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.ShipAddr1,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.ShipAddr2,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.ShipAddr3,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.DelAddr3,"");
        AddPORow2(POr,INp,-1,INp.Code,0,false,PIp,false,blankval,ORp.DelAddr4,"");
      end;
    end;
  end;
  if (blank(PIp.PurPrice)) then begin//it was like that in 3.6.... 
    PIp.PurPrice = orpr;
  end;
  if (flags1==1) then begin
    AddPORow2(POr,INp,-1,INp.Code,0,true,PIp,true,ordqtyp,spec,"");
  end else begin
    AddPORow2(POr,INp,-1,INp.Code,0,true,PIp,true,ordqtyp,"","");
  end;
  POSumup(POr);
  SetPOFlags(POr,false);
  if (POr.SerNr!=-1) then begin
    if (found==false) then begin
      if (ValidatePORecord(POr,oldPOr,1,0,false,tstr)==0) then begin
        if (RecordStore(POr,false)) then begin
        end;
      end;
    end else begin
      if (RecordUpdate(oldPOr,POr,true)==0) then begin     
      end;
    end;
    if (flushf) then begin
      CheckFlush(flushcnt,10);
    end;
    t = blankval;
  end;
  RETURN;
END;

global
updating function Integer GenPOFromORMn1(record RcVc RepSpec,Boolean flushf,var string errstr)
begin
  Integer res;
  LongInt orfr,orto;
  record INVc INr;
  record ItemStatusVc ISr;
  record ORVc ORr;
  row ORVc ORrw;
  record PIVc PIr;
  Boolean found,TrHs;
  Integer rwcnt,i;
  val t1,t2;
  Boolean testf,addrf,pifound;
  val defic;
  Integer flushcnt;
  Array string 20 apoforve;
  Integer acnt,ordertype;
  LongInt startponr;
  string 255 location;
  record POVc POr;
  Integer requestedtype;
  transaction string 255 gRuniningMaint;

  gRuniningMaint = "GenPOFromORMn1";
  orfr = FirstInRange(RepSpec.f1,10);
  orto = LastInRange(RepSpec.f1,10);
  
  requestedtype = kOrderTypeDropShip;
  while (requestedtype>=kOrderTypeNormal) begin
  RecordClear(ORr);
  ResetLoop(ORr);
  ORr.SerNr = orfr;
  TrHs = true;
  while (LoopMain(ORr,1,TrHs)) begin
    testf = true;
    if (TrHs) then begin
      if (orto!=-1) then begin
        if  (ORr.SerNr>orto) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      if (DateInRange(ORr.OrdDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin
        testf = false;
      end;
    end;
    if (TrHs) then begin
      if (nonblank(RepSpec.f2)) then begin
        if (RepSpec.f2!=ORr.OrderClass) then begin
          testf = false;
        end;
      end;
    end;
    if (TrHs==false) then begin testf = false; end;
    if (ORr.Closed!=0) then begin testf = false; end;
/*    
prder type per row
    switch (RepSpec.ArtMode) begin
      case 0:
        switch (ORr.OrderType) begin
          case kOrderTypeDropShip:
            POr.OrdNr = ORr.SerNr;
            testf = not ReadFirstKey("OrdNr",POr,1,true);
        end;
    end;
*/    
    if (testf) then begin
      addrf = true;
      rwcnt = MatRowCnt(ORr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(ORr,i,ORrw);
        found = ReadFirstItem(ORrw.ArtCode,INr,true,false);
        if (ORrw.Quant==ORrw.Shipd2) then begin found = false; end;
        if (INr.Terminated!=0) then begin found = false; end;
        ordertype = ORrw.OrderType;
        if (ordertype==kOrderTypeDefault) then begin
          ordertype = ORr.OrderType;
        end;
        if (ordertype!=requestedtype) then begin found = false; end;
        if (found) then begin
          location = ORrw.Location;
          if (blank(location)) then begin location = ORr.Location; end;
          switch (RepSpec.ArtMode) begin
            case 0:
              ISr.Code = ORrw.ArtCode;
              FindStockValue(ORrw.ArtCode,"",ISr);
              pifound = FindPOQty2(ORrw.ArtCode,location,INr,ISr,PIr,0,t1,defic,RepSpec.flags[6]!=0);
              if (pifound==false) then begin
                res = 20863;
                errstr = ORrw.ArtCode;
              end;
              if (RepSpec.flags[3]!=0) then begin
                t2 = defic;
              end else begin
                t2 = ORrw.Quant;
                if (PIr.MinPOQty!=0) then begin
                  if (t2<PIr.MinPOQty) then begin
                    t2 = PIr.MinPOQty;
                  end;
                end else begin
                  if (t2<PIr.NormPOQty) then begin
                    t2 = PIr.NormPOQty;
                  end;
                end;
              end;
              if (RepSpec.flags[4]!=0) then begin
                GetPriceFromItem(RepSpec,PIr);
              end;
              if (t2>0) then begin
                if (pifound) then begin
                  DoPO2(RepSpec.flags[1],RepSpec.flags[2],RepSpec.flags[5],INr,PIr,t2,ORr,ORrw,i,addrf,requestedtype);
                end;
              end;
            case 1:
              ISr.Code = ORrw.ArtCode;
              FindStockValue(ORrw.ArtCode,"",ISr);
              pifound = FindPOQty2(ORrw.ArtCode,location,INr,ISr,PIr,ORrw.Quant,t1,t2,RepSpec.flags[6]!=0);
              if (RepSpec.flags[3]!=0) then begin
                t2 = defic;
              end else begin
                t2 = ORrw.Quant;
                if (PIr.MinPOQty!=0) then begin
                  if (t2<PIr.MinPOQty) then begin
                    t2 = PIr.MinPOQty;
                  end;
                end;
              end;
              if (RepSpec.flags[4]!=0) then begin
                GetPriceFromItem(RepSpec,PIr);
              end;
              if (t2>0) then begin
                if (pifound) then begin
                  DoPO(RepSpec.flags[1],INr,PIr,t2,ORrw,true,false,flushf,flushcnt,apoforve,acnt,startponr,requestedtype);
                end;
              end;
            case 2:
              ISr.Code = ORrw.ArtCode;
              FindStockValue(ORrw.ArtCode,"",ISr);
              pifound = FindPOQty2(ORrw.ArtCode,location,INr,ISr,PIr,ORrw.Quant,t1,t2,RepSpec.flags[6]!=0);
              if (RepSpec.flags[3]!=0) then begin
                t2 = defic;
              end else begin
                t2 = ORrw.Quant;
                if (PIr.MinPOQty!=0) then begin
                  if (t2<PIr.MinPOQty) then begin
                    t2 = PIr.MinPOQty;
                  end;
                end;
              end;
              if (RepSpec.flags[4]!=0) then begin
                GetPriceFromItem(RepSpec,PIr);
              end;
              if (t2>0) then begin
                if (pifound) then begin
                  DoPOGroup(RepSpec.flags[1],RepSpec.flags[2],INr,PIr,t2,ORr,ORrw.Spec,ORrw.BasePrice,flushf,flushcnt,startponr);
                end;
              end;
          end;
        end;
      end;
    end;
    UserTrace(ORr.SerNr,M4Long);            
  end;
  requestedtype = requestedtype - 1;
  
  end;
  gRuniningMaint = "";
  GenPOFromORMn1 = res;
  RETURN;
end;

global
updating function Integer GenPOFromORMn2(record RcVc RepSpec,var string errstr)
BEGIN
  Integer res;
  
  errstr = "";
  res = GenPOFromORMn1(RepSpec,false,errstr);
  GenPOFromORMn2 = res;
  RETURN;
END;

global
updating procedure GenPOFromORMn(record RcVc RepSpec)
BEGIN
  string 255 errstr;
  
  GenPOFromORMn1(RepSpec,true,errstr);
  RETURN;
END;

updating procedure AddToPO(record RcVc RepSpec,string itemcode,record INVc INr,string itsz,string mask,string mskrep,string subsets,Integer matchve,
                       row ORVc orrw,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
begin
  record ItemStatusVc ISr;
  record PIVc PIr;
  Boolean TrHs,testf,pifound,firstf;
  val t1,t2,minlevel;
  Integer flushcnt;
  
  pifound = DoFindPItem(INr.Code,"",PIr,RepSpec.LastAcc,matchve,RepSpec.flags[1]);
  if (pifound==false) then begin
    pifound = DoFindPItem(itemcode,"",PIr,RepSpec.LastAcc,matchve,RepSpec.flags[1]);
  end;
  if (pifound) then begin
    pifound = FindPOQantity2(INr,ISr,true,RepSpec.FirstAcc,PIr,t1,t2,minlevel,0,true,true,true,RepSpec.flags[7]);
  end;   
  if (t2>0 or RepSpec.flags[2]!=0) then begin
    if (pifound) then begin
      DoPO(RepSpec.flags[1],INr,PIr,t2,orrw,false,RepSpec.flags[2]!=0,false,flushcnt,apoforve,acnt,startponr,requestedtype);
    end;
  end;         
  return;
end;
        
updating procedure POForOneVariety(string group,string itsz,record RcVc RepSpec,record INVc INr,string itsz,string mask,string mskrep,string subsets,Integer matchve,
                       row ORVc orrw,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
begin
  record VARVc VARr;
  Boolean found,testf;
  Integer insz;
  string 255 artcode,itemcode;

  itemcode = INr.Code;
  if (itsz!=".") then begin
    insz = StringToInt(itsz);
  end;
  found = true;
  VARr.VARGCode = group;
  while (LoopKey("VARGCode",VARr,1,found)) begin
    if (VARr.VARGCode!=group) then begin
      found = false;
    end;
    if (found) then begin
      if (itsz!=".") then begin
        artcode = itemcode & VARr.Code;
      end else begin
        artcode = itemcode & itsz & VARr.Code;
      end;      
      INr.Code = artcode;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr,subsets,mask)==false) then begin
          testf = false;
        end;
      end;
      
      if (testf) then begin
        AddToPO(RepSpec,itemcode,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
      end;
    end;
  end;
  return;
end;

updating procedure POForTwoVarieties(string group1,string group2,record RcVc RepSpec,record INVc INr,string itsz,string mask,string mskrep,string subsets,Integer matchve,
                       row ORVc orrw,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
begin
  record VARVc VARr1;
  Boolean found1,testf;
  record VARVc VARr2;
  Boolean found2;
  Integer insz;
  string 255 artcode,artcode1,itemcode,itsz1,itsz2;
  record VARGVc VARGr;

  itemcode = INr.Code;
  found1 = true;
  VARr1.VARGCode = group1;
  while (LoopKey("VARGCode",VARr1,1,found1)) begin
    if (VARr1.VARGCode!=group1) then begin
      found1 = false;
    end;
    if (found1) then begin
      VARGr.Code = VARr1.VARGCode;
      ReadFIrstMain(VARGr,1,true);
      itsz1 = VARGr.VarSize;
      if (itsz1!=".") then begin
        insz = StringToInt(itsz1);
      end;
      if (itsz1!=".") then begin
        artcode = itemcode & VARr1.Code;
      end else begin
        artcode = itemcode & itsz1 & VARr1.Code;
      end;      
      artcode1 = artcode;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr1,subsets,mask)==false) then begin
          testf = false;
        end;
      end;
      
      if (testf) then begin
        ResetLoop(VARr2);
        found2 = true;
        VARr2.VARGCode = group2;
        while (LoopKey("VARGCode",VARr2,1,found2)) begin
          if (VARr2.VARGCode!=group2) then begin
            found2 = false;
          end;
          if (found2) then begin  
            artcode = artcode1;
            VARGr.Code = VARr2.VARGCode;
            ReadFIrstMain(VARGr,1,true);
            itsz2 = VARGr.VarSize;
            if (itsz2!=".") then begin
              itsz2 = StringToInt(itsz2);
            end;
            if (itsz2!=".") then begin
              artcode = artcode & VARr2.Code;
            end else begin
              artcode = artcode & itsz2 & VARr2.Code;
            end;      
            INr.Code = artcode;
            testf = true;
            if (nonblank(subsets)) then begin
              if (CheckVARSubsets(VARr2,subsets,mask)==false) then begin
                testf = false;
              end;
            end;
            if (testf) then begin
              AddToPO(RepSpec,itemcode,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

updating procedure POForThreeVarieties(string group1,string group2,string group3,record RcVc RepSpec,record INVc INr,string itsz,string mask,string mskrep,string subsets,Integer matchve,
                                       row ORVc orrw,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
begin
  record VARVc VARr1;
  Boolean found1;
  record VARVc VARr2;
  Boolean found2;
  record VARVc VARr3;
  Boolean found3,testf;
  record VARGVc VARGr;
  Integer insz1,insz2,insz3;
  string 255 artcode,artcode1,artcode2,itemcode,itemname,itsz1,itsz2,itsz3;

  itemcode = INr.Code;
  found1 = true;
  VARr1.VARGCode = group1;
  while (LoopKey("VARGCode",VARr1,1,found1)) begin
    if (VARr1.VARGCode!=group1) then begin
      found1 = false;
    end;
    if (found1) then begin
      VARGr.Code = VARr1.VARGCode;
      ReadFIrstMain(VARGr,1,true);
      itsz1 = VARGr.VarSize;
      if (itsz1!=".") then begin
        insz1 = StringToInt(itsz1);
      end;
      if (itsz1!=".") then begin
        artcode = itemcode & VARr1.Code;
      end else begin
        artcode = itemcode & itsz1 & VARr1.Code;
      end;      
      artcode1 = artcode;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr1,subsets,mask)==false) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        ResetLoop(VARr2);
        found2 = true;
        VARr2.VARGCode = group2;
        while (LoopKey("VARGCode",VARr2,1,found2)) begin
          if (VARr2.VARGCode!=group2) then begin
            found2 = false;
          end;
          if (found2) then begin  
            artcode = artcode1;
            VARGr.Code = VARr2.VARGCode;
            ReadFIrstMain(VARGr,1,true);
            itsz2 = VARGr.VarSize;
            if (itsz2!=".") then begin
              insz2 = StringToInt(itsz2);
            end;
            if (itsz2!=".") then begin
              artcode = artcode & VARr2.Code;
            end else begin
              artcode = artcode & itsz2 & VARr2.Code;
            end;      
            artcode2 = artcode;

            testf = true;
            if (nonblank(subsets)) then begin
              if (CheckVARSubsets(VARr2,subsets,mask)==false) then begin
                testf = false;
              end;
            end;
            if (testf) then begin
              ResetLoop(VARr3);
              found3 = true;
              VARr3.VARGCode = group3;
              while (LoopKey("VARGCode",VARr3,1,found3)) begin
                if (VARr3.VARGCode!=group3) then begin
                  found3 = false;
                end;
                if (found3) then begin
                  artcode = artcode2;
                  VARGr.Code = VARr3.VARGCode;
                  ReadFIrstMain(VARGr,1,true);
                  itsz2 = VARGr.VarSize;
                  if (itsz2!=".") then begin
                    insz2 = StringToInt(itsz2);
                  end;
                  if (itsz2!=".") then begin
                    artcode = artcode & VARr3.Code;
                  end else begin
                    artcode = artcode & itsz2 & VARr3.Code;
                  end;      
                  INr.Code = artcode;
                  testf = true;
                  if (nonblank(subsets)) then begin
                    if (CheckVARSubsets(VARr3,subsets,mask)==false) then begin
                      testf = false;
                    end;
                  end;
                  if (testf) then begin
                    AddToPO(RepSpec,itemcode,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

updating procedure POPerVariety(record RcVc RepSpec,record INVc INr,string itsz,string mask,string mskrep,string subsets,Integer matchve,
                       row ORVc orrw,Array string apoforve,var Integer acnt,var LongInt startponr,Integer requestedtype)
begin
  Integer nrofy,pos,i,cnt;
  Array string 20 ac;
  string 255 xpos,ypos,zpos,tstr;

  cnt = 0;
  pos = 0;
  for (i=0;i<20;i=i+1) begin
    ExtractObj(mask,pos,tstr);
    if (nonblank(tstr)) then begin
      ac[i] = tstr;
      cnt = cnt + 1;
    end else begin
      i = 20;
    end;
  end;
  if (cnt>0) then begin xpos = ac[0]; end;
  if (cnt>1) then begin ypos = ac[1]; end;
  if (cnt>2) then begin zpos = ac[2]; end;

  nrofy = FindYVars(ypos,subsets,mask);
  switch (cnt) begin
    case 1: POForOneVariety(xpos,itsz,RepSpec,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
    case 2: POForTwoVarieties(xpos,ypos,RepSpec,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
    case 3: POForThreeVarieties(xpos,ypos,zpos,RepSpec,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,requestedtype);
  end;
  return;
end;

global
updating procedure POCreate2(record RcVc RepSpec,Boolean flushf)
BEGIN
  record INVc INr;
  record ItemStatusVc ISr;
  record PIVc PIr;
  Boolean TrHs,testf,pifound,firstf;
  val t1,t2;
  val sum1;
  Integer vatflag;
  string 20 fromart,toart;
  string 20 frcc,tocc;
  string 30 keystr;
  Integer keys,matchve;
  row ORVc orrw;
  Integer flushcnt;
  Array string 20 apoforve;
  Integer acnt;
  val minlevel;
  LongInt startponr;
  string 255 itsz,mask,subsets,mskrep,xpos,ypos,zpos,tstr;
  Boolean varf;

  firstf = true;
  fromart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);
  vatflag = 0;
  
  if (blank(RepSpec.LastAcc) and RepSpec.flags[1]==1) then begin 
    MessageBox(1205,"");
    goto LPOCreate2;
  end;
  
  if (blank(RepSpec.f3)) then begin
    INr.Code = fromart;
    keystr = "Code";
    keys = 1;
  end else begin
    INr.Group = frcc;
    INr.Code = fromart;
    keystr = "Group";
    keys = 2;
  end;
  TrHs = true;
  while (LoopKey(keystr,INr,keys,TrHs)) begin
    testf = false;    
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      if (nonblank(toart)) then begin
        if (INr.Code>toart) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      if (nonblank(RepSpec.AccStr)) then begin
        if (INr.Department!=RepSpec.AccStr) then begin
          testf = false;
        end;
        if (INr.ItemType!=1) then begin testf = false; end;
      end;
      if (INr.Terminated!=0) then begin testf = false; end;
    end;
    if (testf) then begin
      matchve = 0;
      if (nonblank(RepSpec.LastAcc)) then begin
        matchve = 1;
      end;
      //pifound = FindPOQty(RepSpec.LastAcc,INr,ISr,"",PIr,t1,t2,matchve); 
      if (RepSpec.flags[3]==0) then begin
        pifound = DoFindPItem(INr.Code,RepSpec.FirstAcc,PIr,RepSpec.LastAcc,matchve,RepSpec.flags[1]);
        if (pifound) then begin
          pifound = FindPOQantity2(INr,ISr,false,RepSpec.FirstAcc,PIr,t1,t2,minlevel,0,false,true,true,RepSpec.flags[7]);
        end;   
//        if (t2>0 or RepSpec.flags[2]!=0) then begin  //why creating New PO should ignore deficiency ?
        if (t2>0) then begin
          if (pifound) then begin
            DoPO(RepSpec.flags[1],INr,PIr,t2,orrw,false,RepSpec.flags[2]!=0,flushf,flushcnt,apoforve,acnt,startponr,-1);
          end;
        end;         
      end else begin
        varf = FindItemVAR(INr.Code,itsz,mask,mskrep,subsets);
        if (varf) then begin
          POPerVariety(RepSpec,INr,itsz,mask,mskrep,subsets,matchve,orrw,apoforve,acnt,startponr,-1);
        end else begin      
          pifound = DoFindPItem(INr.Code,RepSpec.FirstAcc,PIr,RepSpec.LastAcc,matchve,RepSpec.flags[1]);
          if (pifound) then begin
            pifound = FindPOQantity2(INr,ISr,false,RepSpec.FirstAcc,PIr,t1,t2,minlevel,0,false,true,true,RepSpec.flags[7]);
          end;   
//          if (t2>0 or RepSpec.flags[2]!=0) then begin  //why creating New PO should ignore deficiency ?
          if (t2>0) then begin
            if (pifound) then begin
              DoPO(RepSpec.flags[1],INr,PIr,t2,orrw,false,RepSpec.flags[2]!=0,flushf,flushcnt,apoforve,acnt,startponr,-1);
            end;
          end;         
        end;
      end;
    end;
  end;
LPOCreate2:;  
  RETURN;
END;

global
updating procedure POCreate(record RcVc RepSpec)
BEGIN
  transaction Boolean gMaintenance;
  
  gMaintenance = true;
  POCreate2(RepSpec,false);
  gMaintenance = false;
  RETURN;
END;

global
updating procedure POCreateMn(record RcVc RepSpec)
BEGIN
  POCreate2(RepSpec,true);
  RETURN;
END;