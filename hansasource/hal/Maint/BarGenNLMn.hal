external function roundmode GetRowSumRoundModeRB();
external function roundmode GetTotalRoundMode(record RoundBlock);
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode DefaultRoundMode();
external procedure AddEuroCurncyTrRow(record TRVc,string,string,string,string,val,Boolean,Boolean,var val,string,val,val,val,val,val,val,val,LongInt,Boolean,string);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Integer TRVc_AddRoundOffRow(var record TRVc,val,val,string,Boolean,Boolean,Boolean,val,var val);
external procedure CheckFlush(var Integer,Integer);
external function Integer GetIntYc(Date);
external function Integer GetIntYc(Date);
external function val FindVAT(string,val,Integer,Integer);
external function Boolean GetAccName(string,var string,Integer);
external procedure AddEuroTrRow(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string);
external procedure TRSumup(var record TRVc,var val);
external procedure GetPayModeAccNumber(string,var string);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);

procedure GetItemAccount(String i,var String ret)
begin
  Record INVc Item;
  Record ITVc ItemGroup;
  Record AccBlock AccSettings;
  
  BlockLoad(AccSettings);
  Item.Code = i;
  if ReadFirstMain(Item,1,true) then begin
     if nonblank(Item.SalesAcc) then begin
       ret          = Item.SalesAcc;
     end else begin  
       ItemGroup.Code = Item.Group;
       if ReadFirstMain(ItemGroup,1,true) then begin
         if nonblank(ItemGroup.SalesAcc) then begin
           ret = ItemGroup.SalesAcc;
         end else begin
           ret = AccSettings.DomSalesAcc;  
         end;
       end else begin
         ret = AccSettings.DomSalesAcc;  
       end;
     end;
  end;
  return;
end;

procedure SumupTRVATCode(record TRVc TRr,string vatcode,var val resv,var string firstrev)
BEGIN
  Integer i,rwcnt;
  row TRVc TRrw;
  
  resv = 0;
  firstrev = "";
  rwcnt = MatRowCnt(TRr);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(TRr,i,TRrw);
    if (TRrw.VATCode==vatcode) then begin
      resv = resv + TRrw.DebVal;
      resv = resv - TRrw.CredVal;
      if (blank(firstrev)) then begin
        firstrev = TRrw.AccNumber;
      end;  
    end;
  end;
  RETURN;
END;

procedure SetupVATBaseIR2(record IRVc VATr)
BEGIN
  record VATCodeBlock VATRec;
  row VATCodeBlock vatrw;
  row IRVc IRrw;
  Integer i,rwcnt;
  
  RecordNew(VATr);
  BlockLoad(VATRec);  
  rwcnt = MatRowCnt(VATRec);  
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATRec,i,vatrw);
    ClearRow(VATr,IRrw,1);
    MatRowPut(VATr,i,IRrw);
  end;
  RETURN;
END;

procedure AddVATBaseIR2(record IRVc VATr,string vatcode,val vatbase,Integer InclVAT)
BEGIN
  record VATCodeBlock VATRec;
  row VATCodeBlock vatrw;
  row IRVc IRrw;
  Integer i,rwcnt;
  val blankv;
  val t,t1;
  record RoundBlock RoundRec;
  
  BlockLoad(RoundRec);    
  BlockLoad(VATRec);  
  rwcnt = MatRowCnt(VATRec);  
  if (rwcnt==0) then begin goto L39; end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATRec,i,vatrw);
    if (vatrw.VATCode==vatcode) then begin
      if (vatbase<>blankv) then begin
        if (MatRowCnt(VATr)>=i) then begin
          MatRowGet(VATr,i,IRrw);
          IRrw.limit = IRrw.limit + vatbase;
          if (RoundRec.VATCalcWay!=0) then begin
            MulVATIV(vatcode,vatbase,t,t1,InclVAT,0); //RestAccr.InclVAT
            t = Round(t,GetRowSumRoundModeRB);
            IRrw.rate = IRrw.rate + t;
          end;          
          MatRowPut(VATr,i,IRrw);
        end;  
      end;  
      goto L39;
    end;
  end;
  if (vatbase<>blankv) then begin
    MatRowGet(VATr,0,IRrw);
    IRrw.limit = IRrw.limit + vatbase;
    MatRowPut(VATr,0,IRrw);
  end;  
L39:;  
  RETURN;
END;

procedure AddVATRestAccTransRows(record TRVc TRr,record RestAccVc RestAccr,record IRVc VATr,record AccBlock ARAccRec,var val TotSum,record RoundBlock RoundRec,val base1,val base2)
BEGIN
  record VATCodeBlock VATRec;
  row VATCodeBlock vatrw;
  row IRVc IRrw;
  Integer i,rwcnt;
  string 10 vatcode,vatacc,firstVAT,blanks;
  string 255 ftxt;
  val vatbasev,vatv,trvatbasev;
  val bvatbasev,bvatv,btrvatbasev;
  val t,t1;
  roundmode rndtotal;
  
  BlockLoad(VATRec); 
  rwcnt = MatRowCnt(VATRec); 
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATRec,i,vatrw);
    if (nonblank(vatrw.VATCode)) then begin
      SumupTRVATCode(TRr,vatrw.VATCode,trvatbasev,vatacc);
      MatRowGet(VATr,i,IRrw);
      vatbasev = IRrw.limit;      
//      vatv = FindVAT(vatrw.VATCode,vatbasev,RestAccr.InclVAT,0);
      MulVATIV(vatrw.VATCode,vatbasev,vatv,t1,1,0); //RestAccr.InclVAT
      rndtotal = GetTotalRoundMode(RoundRec);
      vatv = Round(vatv,GetVATRoundMode(RoundRec));
      bvatbasev = vatbasev;
      bvatv = vatv;
      if (1<>0) then begin //RestAccr.InclVAT
        bvatbasev = bvatbasev - bvatv;
      end;
      if (bvatv<>0) then begin
        if (blank(firstVAT)) then begin
          if (nonblank(vatrw.SalesVATAcc)) then begin
            firstVAT = vatrw.SalesVATAcc;
          end;    
        end;
        if (GetAccName(vatrw.SalesVATAcc,ftxt,60)==false) then begin goto L29; end;
        AddEuroTrRow(TRr,vatrw.SalesVATAcc,blanks,vatrw.VATCode,ftxt,bvatv,base1,base2,true,false,TotSum,false,"","","");
      end;
    end;  
  end;      
L29:;
  RETURN;
END;
  
function Integer RestAccVc_CASHRow(record TRVc TRr,record RestAccVc RestAccp,row RestAccVc RestAccrw,var val TotSum)
begin
  Integer errstrno;
  string 255 tstr,lcuobj,taccnumber;
  row PMBlock PMrw;
  val rs,ors;
  Boolean accf;

  errstrno = 1085; // Transaction could not be generated
  if (GetAccName(PMrw.AccNr,tstr,60)==false) then begin
    errstrno = 2191;
    goto LRestAccVc_CASHRow;
  end;
  rs = MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
  AddEuroTrRow(TRr,PMrw.AccNr,"","",tstr,rs,RestAccrw.BaseRate1,RestAccrw.BaseRate2,false,false,TotSum,false,"","","");

//  AddEuroCurncyTrRow(gTRp,PMrw.AccNr,"","",tstr,rs,false,dc1,TotSum,
//                     RestAccrw.CurncyCode,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,
//                     RestAccrw.BaseRate2,RestAccrw.Sum,blankval,-1,false,"");
    
  errstrno = 0;
LRestAccVc_CASHRow:;
  RestAccVc_CASHRow = errstrno;
  return;
end;
  
procedure AddSalesRestAccTransRows(record TRVc TRr,record IRVc VATr,record RestAccVc RestAccr,record AccBlock ARAccRec,string cuobj,Integer rownr,var val TotSum,record RoundBlock RoundRec,val base1,val base2)
BEGIN
  row RestAccVc RestAccrw;
  string 255 blanks,ftxt;
  string 10 salesacc;
  val rs,nilv,salesv,vatv,t1;
  roundmode rndtotal;
  string 60 locobj;
  
  nilv = -1;
  MatRowGet(RestAccr,rownr,RestAccrw);
  if (RestAccrw.ovst!=0) then begin
    goto L19;
  end;
  switch (RestAccrw.stp) begin
    case 1:
      GetItemAccount(RestAccrw.ArtCode,salesacc);
      if (GetAccName(salesacc,ftxt,60)==false) then begin goto L19; end;
      salesv = RestAccrw.Quant*RestAccrw.Price;
      AddVATBaseIR2(VATr,RestAccrw.VATCode,salesv,1);//RestAccr.InclVAT
      if (1<>0) then begin //RestAccr.InclVAT
        MulVATIV(RestAccrw.VATCode,salesv,vatv,t1,1,0); //RestAccr.InclVAT
        rndtotal = GetTotalRoundMode(RoundRec);
        vatv = Round(vatv,GetVATRoundMode(RoundRec));
    //    vatv = FindVAT(RestAccrw.VATCode,salesv,RestAccr.InclVAT,0);
        salesv = salesv - vatv;
      end;
      locobj = "";
      AddEuroTrRow(TRr,salesacc,locobj,RestAccrw.VATCode,ftxt,salesv,base1,base2,true,false,TotSum,false,"","","");
    case kInvoiceRowTypeVoid:
      GetItemAccount(RestAccrw.ArtCode,salesacc);
      if (GetAccName(salesacc,ftxt,60)==false) then begin goto L19; end;
      salesv = RestAccrw.Quant*RestAccrw.Price;

      salesv = -salesv;
      AddVATBaseIR2(VATr,RestAccrw.VATCode,salesv,1);//RestAccr.InclVAT
      if (1<>0) then begin //RestAccr.InclVAT
        MulVATIV(RestAccrw.VATCode,salesv,vatv,t1,1,0); //RestAccr.InclVAT
        rndtotal = GetTotalRoundMode(RoundRec);
        vatv = Round(vatv,GetVATRoundMode(RoundRec));
    //    vatv = FindVAT(RestAccrw.VATCode,salesv,RestAccr.InclVAT,0);
        salesv = salesv - vatv;
      end;
      locobj = "";
      AddEuroTrRow(TRr,salesacc,locobj,RestAccrw.VATCode,ftxt,salesv,base1,base2,true,false,TotSum,false,"","","");
    case kInvoiceRowTypeGiftVoucherPayment:
//IVVc_GiftCertificateReceive(gTRp,ARAccRec,IVp,IVrw,cuobj,baserate1,baserate2,dc1,dc2,TotSum);    
    case kInvoiceRowTypeLoyaltyPointsPayment:
      RestAccVc_CASHRow(TRr,RestAccr,RestAccrw,TotSum);    
    case kInvoiceRowTypeCashPayment:
      RestAccVc_CASHRow(TRr,RestAccr,RestAccrw,TotSum);    
    case kInvoiceRowTypeChequePayment:
      RestAccVc_CASHRow(TRr,RestAccr,RestAccrw,TotSum);    
    case kInvoiceRowTypeCreditCardPayment:
      RestAccVc_CASHRow(TRr,RestAccr,RestAccrw,TotSum);    
  end;
L19:;  
  RETURN;          
END;

updating function Integer AddCashRecords(record RcVc RepSpec,record TRVc TRp,val base1,val base2)
begin
  record CashVc Cashr;
  row CashVc Cashrw;
  Integer i,rwcnt;
  string 255 accnumber,tstr;
  Boolean TrHs,testf,dc1,dc2;
  Integer res;
  val nilv;
  val TotSum;
  Integer flushcnt;
  
  res = 0;
  TrHs = true;
  Cashr.TransDate = RepSpec.sStartDate;
  while (LoopKey("TransDate",Cashr,1,TrHs)) begin  
    if (Cashr.TransDate>RepSpec.sEndDate) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      testf = true;
      if (testf) then begin
        if ((Cashr.Event==0) or (Cashr.Event==2)) then begin 
          dc1 = false; 
          dc2 = true;
        end else begin
          dc1 = true; 
          dc2 = false;
        end;
        rwcnt = MatRowCnt(Cashr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Cashr,i,Cashrw);
          GetPayModeAccNumber(Cashrw.PMCode,accnumber);
          if (GetAccName(accnumber,tstr,60)==false) then begin 
            res = -1;
            goto LAddCashRecords; 
          end;
          AddEuroTrRow(TRp,accnumber,"","",tstr,Cashrw.Amount,base1,base2,false,dc1,TotSum,false,"","","");
        end;
        if (GetAccName(Cashr.CredAcc,tstr,60)==false) then begin 
          res = -1;
          goto LAddCashRecords; 
        end;
        AddEuroTrRow(TRp,Cashr.CredAcc,"","",tstr,Cashr.Total,base1,base2,false,dc2,TotSum,false,"","","");
      end;
    end;     
  end;
  if (MatRowCnt(TRp)>0) then begin
    TRSumup(TRp,nilv);
    TRp.Comment = USetStr(2272) & " " & RepSpec.sStartDate; 
    TRp.Comment = TRp.Comment & ":" & RepSpec.sEndDate;
    TRp.IntYc = GetIntYc(TRp.TransDate);
    TRp.Number = NextSerNr("TRVc",TRp.TransDate,-1,false,"");            
    if (RecordInsert(TRp,false)) then begin end;
    CheckFlush(flushcnt,10);
  end;
LAddCashRecords:;
  AddCashRecords = res;
  return;
end;

global
updating procedure BarGenNLMn(record RcVc RepSpec)
BEGIN
  record RestAccVc RestAccr;
  record UserVc Userr;
  record CashierBalVc CashierBalr;
  record AccBlock ARAccRec;
  record CostAccBlock CostAccRec;
  record TRGenBlock TRGenRec;  
  record RoundBlock RoundRec;
  record BaseERVc BERr;
  record IRVc VATr;
  record TRVc TRr,TRprer; 
  Integer i,rwcnt;
  Boolean TrHs,testf;
  string 255 cuobj,aracc,ftxt,blanks;
  string 10 useracc;
  val rs,TotSum,nilv;
  val base1,base2;
  Integer flushcnt;
  
  nilv = -1;
  BlockLoad(ARAccRec);
  BlockLoad(CostAccRec);
  BlockLoad(TRGenRec);
  BlockLoad(RoundRec);
  base1 = BlankVal;
  base2 = BlankVal;
  BERr.Date = TRr.TransDate;
  if (ReadLastMain(BERr,1,false)) then begin
    base1 = BERr.Rate1;
    base2 = BERr.Rate2;
  end;
  Userr.Code = CurrentUser;
  if (ReadFirstMain(Userr,1,true)) then begin
    useracc = Userr.PersAcc;
  end;  
  RecordNew(TRr);
  if (nonblankdate(RepSpec.d1)) then begin
    TRr.TransDate = RepSpec.d1;
    TRr.RegDate = RepSpec.d1;
  end else begin
    TRr.TransDate = CurrentDate;
    TRr.RegDate = CurrentDate;
  end;
  i = AddCashRecords(RepSpec,TRr,base1,base2);//creates its own Transaction
  if (i!=0) then begin goto L99; end;
  RecordNew(TRr);
  if (nonblankdate(RepSpec.d1)) then begin
    TRr.TransDate = RepSpec.d1;
    TRr.RegDate = RepSpec.d1;
  end else begin
    TRr.TransDate = CurrentDate;
    TRr.RegDate = CurrentDate;
  end;
L22:;
  TrHs = true;
  RestAccr.NLFlag = 0;
  RestAccr.TransDate = RepSpec.sStartDate;
  ResetLoop(RestAccr);
  while (LoopKey("NLFlag",RestAccr,2,TrHs)) begin
    if (RestAccr.NLFlag<>0) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
      if (DateInRange(RestAccr.TransDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin testf = false; end;
      if (nonblank(RepSpec.AccStr)) then begin
        if (RestAccr.Cashier<>RepSpec.AccStr) then begin testf = false; end;
      end; 
      if (RestAccr.Closed==0) then begin testf = false; end;   
      if (testf) then begin
        RecordNew(VATr);        
        cuobj = "";
        if ((RestAccr.CashValue-RestAccr.RetValue)!=0) then begin
          GetPayModeAccNumber(RestAccr.PayDeal,aracc);
          if (blank(aracc)) then begin aracc = ARAccRec.CashAcc; end;
          if (GetAccName(aracc,ftxt,60)==false) then begin goto L99; end;
          AddEuroTrRow(TRr,aracc,cuobj,blanks,ftxt,RestAccr.CashValue-RestAccr.RetValue,base1,base2,true,true,TotSum,false,"","","");
        end;
        if (RestAccr.Paid!=0) then begin
          GetPayModeAccNumber(RestAccr.PayDeal2,aracc);
          if (blank(aracc)) then begin aracc = ARAccRec.CashAcc; end;
          if (GetAccName(aracc,ftxt,60)==false) then begin goto L99; end;
          AddEuroTrRow(TRr,aracc,cuobj,blanks,ftxt,RestAccr.Paid,base1,base2,true,true,TotSum,false,"","","");
        end;
        if (RestAccr.Paid2!=0) then begin
          GetPayModeAccNumber(RestAccr.PayDeal3,aracc);
          if (blank(aracc)) then begin aracc = ARAccRec.CashAcc; end;
          if (GetAccName(aracc,ftxt,60)==false) then begin goto L99; end;
          AddEuroTrRow(TRr,aracc,cuobj,blanks,ftxt,RestAccr.Paid2,base1,base2,true,true,TotSum,false,"","","");
        end;
        if (RestAccr.Paid3!=0) then begin
          GetPayModeAccNumber(RestAccr.PayDeal4,aracc);
          if (blank(aracc)) then begin aracc = ARAccRec.CashAcc; end;
          if (GetAccName(aracc,ftxt,60)==false) then begin goto L99; end;
          AddEuroTrRow(TRr,aracc,cuobj,blanks,ftxt,RestAccr.Paid3,base1,base2,true,true,TotSum,false,"","","");
        end;
        SetupVATBaseIR2(VATr);        
        rwcnt = MatRowCnt(RestAccr);
        for (i=0;i<rwcnt;i=i+1) begin 
          AddSalesRestAccTransRows(TRr,VATr,RestAccr,ARAccRec,cuobj,i,TotSum,RoundRec,base1,base2);
        end;
        AddVATRestAccTransRows(TRr,RestAccr,VATr,ARAccRec,TotSum,RoundRec,base1,base2);
        if (TRVc_AddRoundOffRow(TRr,base1,base2,"",false,false,false,rs,TotSum)!=0) then begin 
          goto L99;
        end;                
        TotSum = 0;
        MaintTrace(RestAccr.SerNr);        
        RestAccr.NLFlag = 1;
        if (RecordStore(RestAccr,true)) then begin
          StepBack(RestAccr); 
          CheckFlush(flushcnt,10);
//          goto L22;
        end;
      end;         
    end;  
  end; 
  if (MatRowCnt(TRr)>0) then begin
/*  
CashierBalances should not do it, 
It will be done by Cash out Event
    if (nonblank(useracc)) then begin
      CashierBalr.UserCode = CurrentUser;
      CashierBalr.TransDate = RepSpec.sStartDate;
      if (ReadFirstMain(CashierBalr,2,true)) then begin
        rs = CashierBalr.EndBal-(CashierBalr.StartBal+RepSpec.vals0);
        if (GetAccName(useracc,ftxt,60)==false) then begin goto L99; end;
        AddEuroTrRow(TRr,useracc,Userr.PersObjx,blanks,ftxt,rs,base1,base2,true,true,TotSum,false,"","","");
        if (GetAccName(ARAccRec.CashBackAcc,ftxt,60)==false) then begin goto L99; end;
        AddEuroTrRow(TRr,ARAccRec.CashBackAcc,Userr.PersObjx,blanks,ftxt,rs,base1,base2,true,false,TotSum,false,"","","");
      end;        
    end;
*/    
    TRr.IntYc = 229;
    TRprer.IntYc = 229;
    if (ReadLastMain(TRprer,1,true)) then begin    
    end;
    TRr.Number = TRprer.Number + 1;
    if (TRr.Number==0) then begin TRr.Number = TRr.Number + 1; end;
    TRSumup(TRr,nilv);
    TRr.Comment = RepSpec.f2 & " " & RepSpec.sStartDate; 
    TRr.Comment = TRr.Comment & ":" & RepSpec.sEndDate;
    if (RecordInsert(TRr,false)) then begin end;
  end;             
L99:;  
  RETURN;
END;

