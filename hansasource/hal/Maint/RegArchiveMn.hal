external procedure TRExtYc(record TRVc,var string);
external updating procedure DoAddItemHistoryToArchive(string,string,string,string,Date,string,val,val,string,val,val,val,val,val,val,val,val);
external updating procedure DoSubItemHistoryFromArchive(string,string,string,string,Date,string,val,val,string,val,val,val,val,val,val,val,val);
external updating procedure AddTrans(record TRVc,Boolean,Boolean,Boolean);
external updating function LongInt TRVcRecordRemove(var record TRVc,record TRVc,LongInt,LongInt);

global
updating procedure PurgeIPTRrsStats(record PurgeTRVc PurgeTRr)
begin
  record IPrsVc mainr;
  
  mainr.CustCode = PurgeTRr.CompCode;
  mainr.TransDate = PurgeTRr.TransDate;
  mainr.CustDate = PurgeTRr.TransDate;
  mainr.TransNr = PurgeTRr.Number;
  mainr.IntYc = PurgeTRr.IntYc;
  mainr.TransType = kIPrsTransTypePurgeNLTransaction;
  mainr.AccNr = PurgeTRr.AccNumber;
  mainr.IVNr = PurgeTRr.SerNr;
  mainr.TransRow = PurgeTRr.TransRow;
  if (RecordStore(mainr,false)) then begin end;
  return;
end;

global
updating procedure PurgeOPTRrsStats(record PurgeTRVc PurgeTRr)
begin
  record OPrsVc mainr;
  
  mainr.VECode = PurgeTRr.CompCode;
  mainr.TransDate = PurgeTRr.TransDate;
  mainr.TransDate = PurgeTRr.TransDate;
  mainr.TransNr = PurgeTRr.Number;
  mainr.IntYc = PurgeTRr.IntYc;
  mainr.TransType = kOPrsTransTypePurgeNLTransaction;
  mainr.AccNr = PurgeTRr.AccNumber;
  mainr.VINr = PurgeTRr.SerNr;
  mainr.TransRow = PurgeTRr.TransRow;
  if (RecordStore(mainr,false)) then begin end;
  return;
end;

updating procedure CreatePurgeTR(record TRVc TRr)
begin
  record PurgeTRVc PurgeTRr;
  Boolean res;
  row TRVc TRrw;
  Integer i,rwcnt;

  res = false;
  if (TRr.IntYc<IVYc) then begin
    rwcnt = MatRowCnt(TRr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      if (TRrw.Typ==kTransactionRowTypeCustomer) or (TRrw.Typ==kTransactionRowTypeSupplier) then begin
        RecordNew(PurgeTRr);
        PurgeTRr.Number = TRr.Number;
        PurgeTRr.IntYc = TRr.IntYc;
        PurgeTRr.TransRow = i;
        PurgeTRr.AccNumber = TRrw.AccNumber;
        PurgeTRr.Typ = TRrw.Typ;
        PurgeTRr.SerNr = TRrw.SerNr;
        PurgeTRr.TransDate = TRr.TransDate;
        PurgeTRr.CompCode = TRrw.CompCode;
        PurgeTRr.DueDate = TRrw.DueDate;
        PurgeTRr.Objects = TRrw.Objects;
        PurgeTRr.DebVal = TRrw.DebVal;
        PurgeTRr.CredVal = TRrw.CredVal;
        PurgeTRr.Curncy = TRrw.Curncy;
        PurgeTRr.CurDebVal = TRrw.CurDebVal;
        PurgeTRr.CurCredVal = TRrw.CurCredVal;  
        PurgeTRr.DebVal2 = TRrw.DebVal2;
        PurgeTRr.CredVal2 = TRrw.CredVal2;
        PurgeTRr.FrRate = TRrw.FrRate;
        PurgeTRr.ToRateB1 = TRrw.ToRateB1;
        PurgeTRr.ToRateB2 = TRrw.ToRateB2;
        PurgeTRr.BaseRate1 = TRrw.BaseRate1;
        PurgeTRr.BaseRate2 = TRrw.BaseRate2;
        if (RecordStore(PurgeTRr,false)) then begin
          if (TRrw.Typ==kTransactionRowTypeCustomer) then begin
            PurgeIPTRrsStats(PurgeTRr);
          end;
          if (TRrw.Typ==kTransactionRowTypeSupplier) then begin
            PurgeOPTRrsStats(PurgeTRr);
          end;
        end;
      end;
    end;
  end;
  return;
end;

function Boolean TRUpdatingSubSystems(record TRVc TRr)
begin
  Boolean res;
  row TRVc TRrw;
  Integer i,rwcnt;

  res = false;
  if (TRr.IntYc<IVYc) then begin
    rwcnt = MatRowCnt(TRr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      if (TRrw.Typ==kTransactionRowTypeCustomer) or (TRrw.Typ==kTransactionRowTypeSupplier) then begin
        res = true;
        goto LTRUpdatingSubSystems;
      end;
    end;
  end;
LTRUpdatingSubSystems:;  
  TRUpdatingSubSystems = res;
  return;
end;

updating procedure TRVcArchive(Date startdat,Boolean deletef)
begin
  record TRVc TRr;
  record TRVc copyTRr;
  Boolean foundf,testf;
  string 255 tstr;
  LongInt cnt;
  
  cnt = 0;
  LogText(0,"Purging Transactions Data");
  foundf = true;
  while (LoopKey("TransDate",TRr,1,foundf)) begin
    if (TRr.TransDate>startdat) then begin
      foundf = false;
    end;
    if (foundf) then begin
      testf = true;
      if (testf) then begin
        if (TRUpdatingSubSystems(TRr)) then begin
          CreatePurgeTR(TRr);
        end;
        if (deletef) then begin
          if (TRVcRecordRemove(TRr,TRr,0,0)<=0) then begin
          end;
          RecordDelete(TRr);
          StepBack(TRr);
        end else begin
          RecordCopy(copyTRr,TRr);
          copyTRr.TransDate = startdat;
          AddTrans(copyTRr,true,false,false);
        end;
        if (Mod(cnt,1000)==0) then begin
          TRExtYc(TRr,tstr);
          LogText(0,"Purging Transaction " & tstr & " Transaction Date " & DateToString(TRr.TransDate,"DD/MM/YYYY"));
        end;
        cnt = cnt + 1;
      end;
    end;
  end;
  return;
end;

updating procedure AddItemHist(record ItemHistVc ItemHistr,Date startdate)
begin
  record RegArchiveDetailVc RegArchiveDetailr;
  record RegArchiveDetailVc prevRegArchiveDetailr;
  Boolean testf;
  
  testf = true;
  if (ItemHistr.Invalid!=0) then begin testf = false; end;
  if (ItemHistr.StockAffectf==0) then begin testf = false; end;
  if (testf) then begin
    if (ItemHistr.Qty>0) then begin
      DoAddItemHistoryToArchive("ItemHistVc",ItemHistr.ArtCode,ItemHistr.Location,ItemHistr.Variety,startdate,ItemHistr.Position,ItemHistr.Qty,ItemHistr.Qty2,
                              ItemHistr.SerialNr,ItemHistr.TotCostPrice,ItemHistr.RemCostPrice,ItemHistr.WATotCost,ItemHistr.WATotCostPerLoc,ItemHistr.CPTotCost,ItemHistr.CPTotCostPerLoc,
                              ItemHistr.BPTotCost,ItemHistr.BPTotCostPerLoc);
    end else begin
      DoSubItemHistoryFromArchive("ItemHistVc",ItemHistr.ArtCode,ItemHistr.Location,ItemHistr.Variety,startdate,ItemHistr.Position,ItemHistr.Qty,ItemHistr.Qty2,
                              ItemHistr.SerialNr,ItemHistr.TotCostPrice,ItemHistr.RemCostPrice,ItemHistr.WATotCost,ItemHistr.WATotCostPerLoc,ItemHistr.CPTotCost,ItemHistr.CPTotCostPerLoc,
                              ItemHistr.BPTotCost,ItemHistr.BPTotCostPerLoc);
    end;
  end;
  return;
end;

updating procedure ItemHistVcArchive(Date startdat,Boolean deletef)
begin
  record INVc INr;
  record ItemHistVc ItemHistr;
  Boolean foundf;
  LongInt cnt;
  val pct,viewsize,curpos;
  
  cnt = 0;
  LogText(0,"Purging Item History Data (using MainKey)");
  viewsize = CountRecords("INVc");
  INr.Code = "";
  while (LoopMain(INr,1,true)) begin
    ResetLoop(ItemHistr);
    foundf = true;
    ItemHistr.ArtCode = INr.Code;
    curpos = GetLoopPosition(INr);
//    while (LoopKey("ArtCode",ItemHistr,1,foundf)) begin
    while (LoopKey("ArtCodeFD",ItemHistr,1,foundf)) begin
//  while (LoopMain(ItemHistr,1,foundf)) begin
      if (ItemHistr.ArtCode!=INr.Code) then begin
        foundf = false;
      end;
//      if (ItemHistr.TransDate>startdat) then begin
      if (nonblankdate(ItemHistr.FIFODate) and ItemHistr.FIFODate>startdat) then begin
        foundf = false;
      end;
      if (foundf) then begin
        if (deletef) then begin
          RecordDelete(ItemHistr);
          StepBack(ItemHistr);
        end else begin
          AddItemHist(ItemHistr,startdat);
        end;
        if (Mod(cnt,1000)==0) then begin
          pct = (curpos / viewsize) * 100;
          LogText(0,"Purging Item History " & ItemHistr.SerNr & " Item " & INr.Code & "(" & pct & "% Done) FIFODate " & DateToString(ItemHistr.FIFODate,"YYYY-MM-DD"));
          //LogText(0,"Purging Item History " & ItemHistr.SerNr & " Transaction Date " & DateToString(ItemHistr.TransDate,"YYYY-MM-DD") & " FIFODate " & DateToString(ItemHistr.FIFODate,"YYYY-MM-DD"));
        end;
        cnt = cnt + 1;
      end;
    end;
  end;
  return;
end;


/*
procedure SearchForSource(LongInt sourcenr,var val qty,var val cost,Date startdat,var Boolean allmarkedaspurged,Boolean inclfirst)
begin
  record ItemHistVc SourceItemHistr;
  record ItemHistVc LoopItemHistr;
  Boolean foundf,testf,firstf;
  
  qty = 0;
  cost = 0;
  SourceItemHistr.SerNr = sourcenr;
  if (ReadFirstMain(SourceItemHistr,1,true)) then begin
    if (inclfirst) then begin
      qty = qty + SourceItemHistr.Qty;
      if (SourceItemHistr.Qty<0) then begin
        cost = cost - SourceItemHistr.TotCostPrice;
      end else begin
        cost = cost + SourceItemHistr.TotCostPrice;
      end;
      if (SourceItemHistr.WillBePurged==0) then begin
        allmarkedaspurged = false;
      end;
    end;
    LoopItemHistr.Source = SourceItemHistr.SerNr;
    firstf = true;
    foundf = true;
    while (LoopKey("Source",LoopItemHistr,1,foundf)) begin
      if (LoopItemHistr.Source!=SourceItemHistr.SerNr) then begin
        foundf = false;
      end;
      testf = foundf;
      if (LoopItemHistr.FIFODate>startdat) then begin
        testf = false;
      end;
      if (testf) then begin
        qty = qty + LoopItemHistr.Qty;
        if (LoopItemHistr.Qty<0) then begin
          cost = cost - LoopItemHistr.TotCostPrice;
        end else begin
          cost = cost + LoopItemHistr.TotCostPrice;
        end;
        if (LoopItemHistr.WillBePurged==0) then begin
          allmarkedaspurged = false;
        end;
        firstf = false;
      end;
    end;
    if (inclfirst==false and firstf==false) then begin
      qty = qty + SourceItemHistr.Qty;
      if (SourceItemHistr.Qty<0) then begin
        cost = cost - SourceItemHistr.TotCostPrice;
      end else begin
        cost = cost + SourceItemHistr.TotCostPrice;
      end;
    end;
  end;
  return;
end;

function Boolean CanItemHistBeArchived(record ItemHistVc ItemHistr,Date startdat,Boolean testfordelete)
begin
  val qty,cost;
  Boolean res;
  Boolean allmarkedaspurged;
  
  allmarkedaspurged = true;
  SearchForSource(ItemHistr.SerNr,qty,cost,startdat,allmarkedaspurged,false);   // Searching if this is the source
  if (qty==0 and cost==0) then begin
    SearchForSource(ItemHistr.Source,qty,cost,startdat,allmarkedaspurged,true); // Searching if this is using a source
  end;
  if (testfordelete==false) then begin
    if (qty==0 and cost==0) then begin
      res = true;
    end else begin
      res = false;
    end;
  end else begin
    res = allmarkedaspurged;
  end;
  CanItemHistBeArchived = res;
  return;
end;

updating procedure DeleteThisRecordsItemHist(string filename,LongInt sernr)
begin
  record ItemHistVc ItemHistr;
  record ItemHistVc oldItemHistr;
  Boolean foundf,testf;
  
  foundf = true;
  ItemHistr.FileName = filename;
  ItemHistr.TransNr = sernr;
  while (LoopKey("FNTransNr",ItemHistr,2,foundf)) begin
    if ((ItemHistr.FileName!=filename) or (ItemHistr.TransNr!=sernr)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      DoAddItemHistoryToArchive("ItemHistVc",ItemHistr.ArtCode,ItemHistr.Location,ItemHistr.Variety,ItemHistr.FIFODate,ItemHistr.Position,ItemHistr.SerNr,ItemHistr.RemQty,ItemHistr.Qty,ItemHistr.Qty2,ItemHistr.Source,
                              ItemHistr.SerialNr,ItemHistr.TotCostPrice,ItemHistr.RemCostPrice,ItemHistr.WATotCost,ItemHistr.WATotCostPerLoc,ItemHistr.CPTotCost,ItemHistr.CPTotCostPerLoc,
                              ItemHistr.BPTotCost,ItemHistr.BPTotCostPerLoc,ItemHistr.SerNrPerLoc);
      RecordDelete(ItemHistr);
      StepBack(ItemHistr);
    end;
  end;
  return;
end;

updating function Boolean SDBeArchived(record SDVc SDr,Date startdat,Boolean updatef)
begin
  record ItemHistVc ItemHistr;
  record ItemHistVc oldItemHistr;
  row SDVc SDrw;
  Integer rwcnt,i;
  Boolean res,foundf,testf;
  
  res = false;
  rwcnt = MatRowCnt(SDr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SDr,i,SDrw);
    ResetLoop(ItemHistr);
    foundf = true;
    ItemHistr.FileName = "SDVc";
    ItemHistr.TransNr = SDr.SerNr;
    ItemHistr.Row = i;
    while (LoopKey("FNTransNr",ItemHistr,3,foundf)) begin
      if ((ItemHistr.FileName!="SDVc") or (ItemHistr.TransNr!=SDr.SerNr) or (ItemHistr.Row!=i)) then begin
        foundf = false;
      end;
      testf = foundf;
      if (ItemHistr.ArtCode!=SDrw.ArtCode) then begin
        testf = false;
      end;
      if (ItemHistr.FIFODate>startdat) then begin
        testf = false;
      end;
      if (testf) then begin
        if (updatef) then begin
          RecordCopy(oldItemHistr,ItemHistr);
          ItemHistr.WillBePurged = 1;
          if (RecordUpdate(oldItemHistr,ItemHistr,false)==0) then begin
          end;
        end else begin
          res = CanItemHistBeArchived(ItemHistr,startdat,false);
          if (res==false) then begin
            foundf = false;
            i = rwcnt;
          end;
        end;
      end;
    end;
  end;
  SDBeArchived = res;
  return;
end;

updating function Boolean CanSDBeArchived(record SDVc SDr,Date startdat)
begin
  Boolean res;
  
  res = SDBeArchived(SDr,startdat,false);
  CanSDBeArchived = res;
  return;
end;

updating procedure SDMarkItemHistAsPurged(record SDVc SDr,Date startdat)
begin
  Boolean res;
  
  res = SDBeArchived(SDr,startdat,true);
  return;
end;

updating function Boolean SDDeletePurgeMarked(record SDVc SDr,Date startdat)
begin
  record ItemHistVc ItemHistr;
  record ItemHistVc oldItemHistr;
  row SDVc SDrw;
  Integer rwcnt,i;
  Boolean res,foundf,testf;
  
  res = false;
  rwcnt = MatRowCnt(SDr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SDr,i,SDrw);
    ResetLoop(ItemHistr);
    foundf = true;
    ItemHistr.FileName = "SDVc";
    ItemHistr.TransNr = SDr.SerNr;
    ItemHistr.Row = i;
    while (LoopKey("FNTransNr",ItemHistr,3,foundf)) begin
      if ((ItemHistr.FileName!="SDVc") or (ItemHistr.TransNr!=SDr.SerNr) or (ItemHistr.Row!=i)) then begin
        foundf = false;
      end;
      testf = foundf;
      if (ItemHistr.ArtCode!=SDrw.ArtCode) then begin
        testf = false;
      end;
      if (ItemHistr.FIFODate>startdat) then begin
        testf = false;
      end;
      if (testf) then begin
        res = CanItemHistBeArchived(ItemHistr,startdat,false); // true
        if (res==false) then begin
          foundf = false;
          i = rwcnt;
        end;
      end;
    end;
  end;
  if (res) then begin
    DeleteThisRecordsItemHist("SDVc",SDr.SerNr);
  end;
  SDDeletePurgeMarked = res;
  return;
end;

updating procedure SDVcArchive(Date startdat,Boolean deletef)
begin
  record SDVc SDr;
  record SDVc copySDr;
  Boolean foundf,testf;
  
  foundf = true;
  while (LoopKey("TransDate",SDr,1,foundf)) begin
    if (SDr.TransDate>startdat) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      if (CanSDBeArchived(SDr,startdat)==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      if (deletef) then begin
        if (SDDeletePurgeMarked(SDr,startdat)) then begin
          RecordDelete(SDr);
          StepBack(SDr);
        end;
      end else begin
        SDMarkItemHistAsPurged(SDr,startdat);
      end;
    end;
  end;
  return;
end;
*/
global
updating procedure RegArchiveMn(record RcVc RepSpec)
begin
  record RegArchiveVc RegArchiver;
  row RegArchiveVc RegArchiverw;
  record RegArchiveDetailVc RADr;
  record RegArchiveDetailVc oldRADr;
  Integer i,rwcnt;
  Boolean foundf;
  
  SetDatabaseToUnsafeMode;
  RegArchiver.Code = RepSpec.f1;
  if (ReadFirstMain(RegArchiver,1,true)) then begin
    rwcnt = MatRowCnt(RegArchiver);
    if (RepSpec.flags[1]!=0) then begin
      RADr.OKFlag = 0;
      foundf = true;
      while (LoopKey("OKFlag",RADr,1,foundf)) begin
        if (RADr.OKFlag==0) then begin
          RecordDelete(RADr);
          StepBack(RADr);
        end else begin
          foundf = false;
        end;
      end;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RegArchiver,i,RegArchiverw);
        switch (RegArchiverw.FileName) begin
          case "TRVc": TRVcArchive(RegArchiverw.TransDate,false);
          case "ItemHistVc": ItemHistVcArchive(RegArchiverw.TransDate,false);
//          case "SDVc": SDVcArchive(RegArchiverw.TransDate,false);
        end;
      end;
    end;
    if (RepSpec.flags[2]!=0) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RegArchiver,i,RegArchiverw);
        switch (RegArchiverw.FileName) begin
          case "TRVc": TRVcArchive(RegArchiverw.TransDate,true);
          case "ItemHistVc": ItemHistVcArchive(RegArchiverw.TransDate,true);
//          case "SDVc": SDVcArchive(RegArchiverw.TransDate,true);
        end;
      end;
      RADr.SerNr = -1;
      ResetLoop(RADr);
      foundf = true;
      while (LoopMain(RADr,1,foundf)) begin
        RecordCopy(oldRADr,RADr);
        RADr.OKFlag = 1;
        if (RecordUpdate(oldRADr,RADr,true)==0) then begin
        end;
      end;
    end;
  end;
  SetDatabaseToSafeMode;
  return;
end;