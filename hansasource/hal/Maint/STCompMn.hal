external procedure BackDatStock(string,string,string,var val,Date,Integer);
external function Boolean TestArtCodeMatch(string,string);
external procedure FindStockValueAtPosition(string,string,string,var record PISVc);
external function string 255 FindINObjects(string,string);
external procedure FindPUStockAcc(string,record CostAccBlock,string,string,string,record INVc,Integer,var string,var string,Boolean);
external function val FindSerialNrQty(string,string,string);
external procedure CheckFlush(var Integer,Integer);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val GetStockQty(string,string,Date,Boolean);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure SDSumUp(var record SDVc);
external function Boolean GetFirstPurchaseItem2(string,string,string,var record PIVc);
external procedure CalculatePURowSum(val,val,string,var val,val,
                                     val,val,val,val,val,
                                     string,var val,Boolean,string,
                                     val,val,val,val,val);

external procedure PUSumUp(var record PUVc);
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                          val,val,val,val,val,
                          val,val,val,val,val,val,
                          string,var val,val,var val,string,Integer);
external function Boolean SetInSet2(string,string);
external procedure ItemClassTypef(string,string,var Boolean);

global
function val STCompFindSerialNrQty(string artcode,string variety,string serialnr,string location,string position,var string resserialnr)
begin
  val instock,q;
  Boolean foundih,testf;
  record ItemHistVc IHr;
  
  resserialnr = "";
  if (blank(position)) then begin
    instock = FindSerialNrQty(artcode & variety,serialnr,location);
  end else begin
    foundih = true;
    IHr.Position = position;
    IHr.ArtCode = artcode;
    while (LoopKey("Position",IHr,2,foundih)) begin
      if (IHr.Position!=position) then begin foundih = false; end;
      if (IHr.ArtCode!=artcode) then begin foundih = false; end;
      if (foundih) then begin
        testf = true;
        if (nonblank(serialnr)) then begin
          if (IHr.SerialNr!=serialnr) then begin testf = false; end;
        end;
        if (nonblank(variety)) then begin
          if (IHr.Variety!=variety) then begin testf = false; end;
        end;
        if (testf) then begin
          instock = instock + IHr.RemQty;
          resserialnr = IHr.SerialNr;
        end;
      end;
    end;
  end;
  STCompFindSerialNrQty = instock;
  return;
end;

function string 20 GetUsageVarianceAcc(string itgroup,string defCostAcc)
BEGIN
  string 20 res;
  record ITVc ITr;
  record CostAccBlock CostAccRec;

  BlockLoad(CostAccRec);
  if (CostAccRec.ItemGroupAccounts!=0) then begin
    ITr.Code = itgroup;
    if (ReadFirstMain(ITr,1,true)) then begin
      res = ITr.UsageVarianceAcc;
    end;  
  end;
  if (blank(res)) then begin
    res = defCostAcc;
  end;
  GetUsageVarianceAcc = res;
  RETURN;
END;

function string 60 GetLocationObject(string location)
BEGIN
  string 20 res;
  record LocationVc Locr;

  Locr.Code = location;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Objects;
  end;
  GetLocationObject = res;
  RETURN;
END;

procedure RemoveFromLastSTForItem(string item,string position,var record StockTakeVc resStockTaker)
begin
  Integer resi,resrwcnt;
  row StockTakeVc resStockTakerw;

  resrwcnt = MatRowCnt(resStockTaker);
  for (resi=0;resi<resrwcnt;resi=resi+1) begin
    MatRowGet(resStockTaker,resi,resStockTakerw);
    if (item==resStockTakerw.ArtCode) and (position==resStockTakerw.Position) then begin
      MatRowDelete(resStockTaker,resi);
      goto LRemoveFromLastSTForItem;
    end;
  end;
LRemoveFromLastSTForItem:;  
  return;
end;
    
/*       
procedure CombineStockTake(string item,record StockTakeVc StockTaker,var record StockTakeVc resStockTaker)
begin
  Integer i,rwcnt;
  Integer resi,resrwcnt;
  row StockTakeVc StockTakerw;
  row StockTakeVc resStockTakerw;
  string 255 variety;
  
  rwcnt = MatRowCnt(StockTaker);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockTaker,i,StockTakerw);
    variety = right(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(item));
    if (item==Left(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(variety))) then begin 
      resrwcnt = MatRowCnt(resStockTaker);
      if (resrwcnt==0) then begin
        CopyRow(StockTaker,StockTakerw,resStockTakerw);
LogText(0,"1.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resrwcnt " & resrwcnt);
        MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
      end else begin
        for (resi=0;resi<resrwcnt;resi=resi+1) begin
          MatRowGet(resStockTaker,resi,resStockTakerw);
          if (StockTakerw.ArtCode==resStockTakerw.ArtCode) and (StockTakerw.SerialNr==resStockTakerw.SerialNr) and (StockTakerw.Position==resStockTakerw.Position) then begin
            resStockTakerw.Qty = resStockTakerw.Qty + StockTakerw.Qty;
            resStockTakerw.InStock = resStockTakerw.InStock + StockTakerw.InStock;
LogText(0,"2.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resi " & resi);
            MatRowPut(resStockTaker,resi,resStockTakerw);
          end else begin
            CopyRow(StockTaker,StockTakerw,resStockTakerw);
            MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
            resi = resrwcnt;
LogText(0,"3.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resi " & resi);
          end;
        end;
      end;
    end;
  end;
  return;
end;
*/

procedure CombineStockTake(string item,record StockTakeVc StockTaker,var record StockTakeVc resStockTaker)
begin
  Integer i,rwcnt;
  Integer resi,resrwcnt;
  row StockTakeVc StockTakerw;
  row StockTakeVc resStockTakerw;
  string 255 variety;
  Boolean found;
  
  rwcnt = MatRowCnt(StockTaker);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockTaker,i,StockTakerw);
    variety = right(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(item));
//    if (item==Left(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(variety))) then begin incorrect when items are 50000 and 50000A on same stocktaking record
    if (TestArtCodeMatch(StockTakerw.ArtCode,item)) then begin
      resrwcnt = MatRowCnt(resStockTaker);
      if (resrwcnt==0) then begin
        CopyRow(StockTaker,StockTakerw,resStockTakerw);
        MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
      end else begin
        found = false;
        for (resi=0;resi<resrwcnt;resi=resi+1) begin
          MatRowGet(resStockTaker,resi,resStockTakerw);
          if (StockTakerw.ArtCode==resStockTakerw.ArtCode) and (StockTakerw.SerialNr==resStockTakerw.SerialNr) and (StockTakerw.Position==resStockTakerw.Position) then begin
            resStockTakerw.Qty = resStockTakerw.Qty + StockTakerw.Qty;
            resStockTakerw.InStock = resStockTakerw.InStock + StockTakerw.InStock;
            MatRowPut(resStockTaker,resi,resStockTakerw);
            found = true;
            resi = resrwcnt;            
          end;
        end;
        if (found==false) then begin
          CopyRow(StockTaker,StockTakerw,resStockTakerw);
          MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
        end;                
      end;
    end;
  end;
  return;
end;
          
global
procedure FindLastSTForItem(record RcVc RepSpec,string item,Date fromdate,var record StockTakeVc resStockTaker)
begin
  record ItemHistVc IHr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  record MainStockBlock MSb;
  Boolean TrHs,testf;
  Integer rwcnt,i,keys;
  val t;
  Integer slen;
  string 40 ckey; 
  Date td;
  vector Boolean stocktakef;

  BlockLoad(MSb);
  ckey = "ArtCode";
  keys = 2;
  IHr.ArtCode = item;
  IHr.TransDate = CurrentDate;
  TrHs = true;
  while (LoopBackKey(ckey,IHr,keys,TrHs)) begin
    if (IHr.ArtCode<>item) then begin TrHs = false; end;
    if (IHr.TransDate<fromdate) then begin
      TrHs = false;
    end;            
    if (TrHs) then begin
      if (IHr.FileName=="StockTakeVc") then begin
        StockTaker.SerNr = IHr.TransNr;
        if (ReadFirstMain(StockTaker,1,true)) then begin
          rwcnt = MatRowCnt(StockTaker);
          if ((IHr.Row<rwcnt) and (IHr.Row>-1)) then begin
            MatRowGet(StockTaker,IHr.Row,StockTakerw);
            testf = true;
            if (TestArtCodeMatch(StockTakerw.ArtCode,item)==false) then begin
              testf = false;
            end;            
            if (nonblank(RepSpec.AccStr)) then begin
              if (nonblank(StockTakerw.Location)) then begin
                if (StockTakerw.Location<>RepSpec.AccStr) then begin testf = false; end;
              end else begin
                if (nonblank(StockTaker.Location)) then begin
                  if (StockTaker.Location<>RepSpec.AccStr) then begin testf = false; end;
                end else begin
                  if (MSb.MainStock<>RepSpec.AccStr) then begin testf = false; end;
                end;
              end;
            end;  
            if (IHr.Invalid!=0) then begin testf = false; end;
            if (stocktakef[StockTaker.SerNr]==true) then begin testf = false; end;
            stocktakef[StockTaker.SerNr] = true;
            if (testf) then begin
              CombineStockTake(item,StockTaker,resStockTaker);
            end;
          end;
        end;
      end;
    end;   
  end;  
LFindLastSTForItem:;
  RETURN;
END;
                          
procedure FindLastST(record RcVc RepSpec,string item,Integer SerNrf,Date fromdate,var Date lastdatep,var val unitsp,var val instock,var array val counteda,var array string batcha,var array string posa,var Integer arrcnt,
                     string variety,var record StockTakeVc resStockTaker)
BEGIN
  record ItemHistVc IHr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  record MainStockBlock MSb;
  Boolean TrHs,testf;
  Integer rwcnt,i,keys;
  val t;
  Integer slen;
  string 40 ckey; 
  Date td;

  instock = blankval;
  lastdatep = td;
  BlockLoad(MSb);
  td = AddYear(td,-GetYear(td));
  if (nonblank(variety)) then begin
    ckey = "ArtCodeVariety";
    keys = 3;
    IHr.Variety = variety;
  end else begin
    ckey = "ArtCode";
    keys = 2;
  end;
    IHr.ArtCode = item;
    IHr.TransDate = CurrentDate;
    TrHs = true;
    while (LoopBackKey(ckey,IHr,keys,TrHs)) begin
      if (IHr.ArtCode<>item) then begin TrHs = false; end;
      if (nonblank(variety)) then begin
        if (IHr.Variety!=variety) then begin TrHs = false; end;
      end;
      if (IHr.TransDate<fromdate) then begin
        TrHs = false;
      end;            
      if (TrHs) then begin
        if (IHr.FileName=="StockTakeVc") then begin
          StockTaker.SerNr = IHr.TransNr;
          if (ReadFirstMain(StockTaker,1,true)) then begin
            rwcnt = MatRowCnt(StockTaker);
            if ((IHr.Row<rwcnt) and (IHr.Row>-1)) then begin
              MatRowGet(StockTaker,IHr.Row,StockTakerw);
              testf = true;
              if (nonblank(variety)) then begin
                if ((item & variety)!=StockTakerw.ArtCode) then begin testf = false; end;
              end else begin
                if (item!=StockTakerw.ArtCode) then begin testf = false; end;
              end;
              if (nonblank(RepSpec.AccStr)) then begin
                if (nonblank(StockTakerw.Location)) then begin
                  if (StockTakerw.Location<>RepSpec.AccStr) then begin testf = false; end;
                end else begin
                  if (nonblank(StockTaker.Location)) then begin
                    if (StockTaker.Location<>RepSpec.AccStr) then begin testf = false; end;
                  end else begin
                    if (MSb.MainStock<>RepSpec.AccStr) then begin testf = false; end;
                  end;
                end;
              end;  
              if (nonblank(RepSpec.LastAcc)) then begin
                if (StockTakerw.Position!=RepSpec.LastAcc) then begin testf = false; end;
              end;
              if (IHr.Invalid!=0) then begin testf = false; end;

              if (testf) then begin
                if (StockTaker.TransDate<>td) then begin
                  t = 0;
                  t = StockTakerw.Qty + t;
                end else begin
                  t = StockTakerw.Qty + t;
                end;
                if (SerNrf==0) then begin
                  if (blank(instock)) then begin
                    instock = StockTakerw.InStock;
                  end;
                end else begin
                  instock = instock + StockTakerw.InStock;
                end;
                if (nonblank(StockTakerw.SerialNr)) then begin
                  batcha[arrcnt] = StockTakerw.SerialNr;
                  counteda[arrcnt] = StockTakerw.Qty;
                  posa[arrcnt] = StockTakerw.Position;
                  arrcnt = arrcnt + 1;
                end;
                td = StockTaker.TransDate;
                lastdatep = StockTaker.TransDate;
                RecordCopy(resStockTaker,StockTaker);
              end;
            end;
          end;
        end;
      end;   
    end;  
LFindLastST:;
  unitsp = t;
/*  
  if (blankdate(lastdatep)) then begin
    TrHs = true;
    StockTaker.TransDate = fromdate;
    while (LoopBackKey("TransDate",StockTaker,1,TrHs)) begin
      if (StockTaker.TransDate<fromdate) then begin
        TrHs = false;
      end;        
      if (TrHs) then begin
        lastdatep = StockTaker.TransDate;
        RecordCopy(resStockTaker,StockTaker);
        TrHs = false;
      end;    
    end;
  end;
*/  
  RETURN;
END;

function Boolean SDPasteArtCode(var record SDVc SDr,record INVc INr,string sernr,Integer rwcnt,Integer loctype,string position)
BEGIN
  Boolean res;
  row SDVc SDrw;
  record INVc locINr;
  
  if (true) then begin
    ClearRow(SDr,SDrw,1);
    SDrw.ArtCode = INr.Code;
    if (ReadFirstItem(SDrw.ArtCode,locINr,true,true)==false) then begin
      goto LSDPasteArtCode;
    end;
    if ((INr.ItemType==2) and (nonblank(INr.Recepy))) then begin
      SDrw.Recepy = INr.Recepy;
    end else begin
      SDrw.Recepy = "";
    end;  
    SDrw.Coefficient = INr.UnitCoefficient;
    SDrw.ArtCode = INr.Code;
    SDrw.Spec = INr.Name;
    SDrw.BasePrice = INr.UPrice1;
    SDrw.Objects = FindINObjects(INr.Objects,INr.Group);
    SDrw.SerialNr = sernr;
    SDrw.PosCode = position;
    if (loctype==1) then begin
      SDrw.CostAcc = GetUsageVarianceAcc(INr.Group,"");
    end;
    MatRowPut(SDr,rwcnt,SDrw);
    res = true;
  end;
LSDPasteArtCode:;  
  SDPasteArtCode = res;
  RETURN;            
END;

procedure SDPasteQty(var record SDVc SDr,record INVc INr,Integer rwcnt,val diff)
BEGIN
  row SDVc SDrw;
  
  MatRowGet(SDr,rwcnt,SDrw);
  SDrw.Qty = -diff;
  if ((INr.ExplodeRec!=0) and (nonblank(SDrw.Recepy))) then begin
//  ExplodeRecepy(SDVc,&INr,&SDrw.Qty,SDp,SDrw.Recepy,row);
    MatRowGet(SDr,rwcnt,SDrw);
    SDrw.Recepy = "";
  end;              
  MatRowPut(SDr,rwcnt,SDrw);
  RETURN;            
END;

updating           
procedure AddtoSD(record RcVc RepSpec,var record SDVc SDr,record INVc INr,string sernr,val diff,var Integer flushcnt,record AccBlock ARAccRec,Integer loctype,
                  var Boolean dbupdatedf)
BEGIN
  Integer rwcnt;
  record SDVc oldSDr;
  
  rwcnt = MatRowCnt(SDr);
  if (rwcnt>=200) then begin
    SDr.TransDate = RepSpec.RegDate;
    SDr.SerNr = NextSerNr("SDVc",SDr.TransDate,-1,false,"");  
    SDr.Location = RepSpec.AccStr;
    SDSumUp(SDr);
    if (blankdate(SDr.TransDate)) then begin SDr.TransDate = CurrentDate; end;
    SDr.CostAcc = ARAccRec.StockLossAcc;
    if (blank(SDr.CostAcc)) then begin
      SDr.CostAcc = ARAccRec.StockGainAcc;
    end;
    SDr.Objects = GetLocationObject(SDr.Location);
    SDr.Comment = RepSpec.f6;
    if (RecordStore(SDr,false)) then begin
    end;
    if (RepSpec.flags[5]!=0) then begin
      RecordCopy(oldSDr,SDr);
      SDr.OKFlag = 1;
      if (RecordUpdate(oldSDr,SDr,true)==0) then begin 
        dbupdatedf = true;
      end;
    end;
    CheckFlush(flushcnt,10);
    RecordNew(SDr);
    rwcnt = 0;
  end;
  if (SDPasteArtCode(SDr,INr,sernr,rwcnt,loctype,RepSpec.LastAcc)) then begin
    SDPasteQty(SDr,INr,rwcnt,diff);
  end;
  RETURN;
END;

function Boolean PUPasteArtCode(record RcVc RepSpec,var record PUVc PUr,record INVc INr,string sernr,Integer rwcnt,record AccBlock ARAccRec,Integer loctype,string position)
BEGIN
  record CostAccBlock CostAccRec;
  record ITVc ITr;
  record PIVc PIr;
  row PUVc PUrw;
  val p;
  string 20 stockacc,purchacc;
  Boolean res;
  record INVc locINr;
  
  BlockLoad(CostAccRec);
  ClearRow(PUr,PUrw,1);
  if (INr.ItemType==1) then begin
    PUrw.ArtCode = INr.Code;
    if (ReadFirstItem(PUrw.ArtCode,locINr,true,true)==false) then begin
      goto LPUPasteArtCode;
    end;
/*
    if (GetFirstPurchaseItem2(PUrw.ArtCode,PUr.Location,PUr.VECode,PIr)) then begin
      PUrw.UPrice = PIr.PurPrice;
      p = PIr.PurPrice;
      if (PIr.PIFactor!=0) then begin
        p = p/PIr.PIFactor;
      end;
      PUrw.PIFactor = PIr.PIFactor;
    end else begin
      PUrw.Spec = INr.Name;
      PUrw.UPrice = INr.InPrice;
      p = INr.InPrice;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
      p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
      PUrw.PIFactor = INr.PriceFactor;
    end;        
*/    
    PUrw.Spec = INr.Name;
    PUrw.UPrice = INr.InPrice;
    p = INr.InPrice;
    if (INr.PriceFactor!=0) then begin
      p = p/INr.PriceFactor;
    end;
    p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
    PUrw.PIFactor = INr.PriceFactor;

    PUrw.Coefficient = INr.UnitCoefficient;
    PUrw.Spec = INr.Name;
    PUrw.Objects = FindINObjects(INr.Objects,INr.Group);
    PUrw.UPrice = p;
    PUrw.BasePrice = INr.UPrice1;
    PUrw.Extra = INr.ExtraCost;    
    PUrw.SerialNr = sernr;
    if (blank(PUrw.Location)) then begin
      FindPUStockAcc(PUr.VECode,CostAccRec,PUrw.CostAcc,PUrw.CredAcc,RepSpec.AccStr,INr,PUrw.StockType,stockacc,purchacc,false);
    end else begin
      FindPUStockAcc(PUr.VECode,CostAccRec,PUrw.CostAcc,PUrw.CredAcc,PUrw.Location,INr,PUrw.StockType,stockacc,purchacc,false);
    end;
    PUrw.CostAcc = stockacc;
    PUrw.CredAcc = purchacc;
    PUrw.CredAcc = ARAccRec.StockGainAcc;//kaido says
    PUrw.UnitCode = INr.Unittext;
    PUrw.ToPosCode = position;
    if (loctype==1) then begin
      PUrw.CredAcc = GetUsageVarianceAcc(INr.Group,PUrw.CredAcc);
    end;
    MatRowPut(PUr,rwcnt,PUrw);
    res = true;
  end;
LPUPasteArtCode:;
  PUPasteArtCode = res;
  RETURN;
END;

procedure PUPasteQty(var record PUVc PUr,record INVc INr,Integer rwcnt,val diff)
BEGIN
  row PUVc PUrw;
  val p,c;
  
  MatRowGet(PUr,rwcnt,PUrw);
  PUrw.Quant = diff;
  PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUr.InclVAT,PUr.NoTAXonVAT,PUrw.Extra,PUr.CurncyCode,
                  PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                  PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                  PUrw.CustomsCost,p,PUrw.Quant,c,PUrw.VATCode,PUr.ExportFlag);

  PUrw.CostPrice = p;                                        
  PUrw.Sum = c;                                        
  CalculatePURowSum(PUrw.Quant,PUrw.UPrice,PUrw.Extra,c,PUrw.ShipCost,
                    PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,false,PUr.CurncyCode,
                    PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2);
                                     
  PUrw.Sum = p;
  MatRowPut(PUr,rwcnt,PUrw);
  RETURN;            
END;

updating
procedure AddtoPU(record RcVc RepSpec,var record PUVc PUr,record INVc INr,string sernr,val diff,var Integer flushcnt,record AccBlock ARAccb,Integer loctype,
                  var Boolean dbupdatedf)
BEGIN
  Integer rwcnt;
  record PUVc oldPUr;
  
  rwcnt = MatRowCnt(PUr);
  if (rwcnt>=200) then begin
    PUr.TransDate = RepSpec.RegDate;
    PUr.SerNr = NextSerNr("PUVc",PUr.TransDate,-1,false,"");  
    PUr.Location = RepSpec.AccStr;
    PUSumUp(PUr);
    if (blankdate(PUr.TransDate)) then begin PUr.TransDate = CurrentDate; end;
    PUr.Objects = GetLocationObject(PUr.Location);
    PUr.Comment = RepSpec.f6;
    if (RecordStore(PUr,false)) then begin
    end;
    if (RepSpec.flags[5]!=0) then begin
      RecordCopy(oldPUr,PUr);
      PUr.OKFlag = 1;
      if (RecordUpdate(oldPUr,PUr,true)==0) then begin 
        dbupdatedf = true;
      end;
    end;
    CheckFlush(flushcnt,10);
    RecordNew(PUr);
    rwcnt = 0;
  end;
  if (PUPasteArtCode(RepSpec,PUr,INr,sernr,rwcnt,ARAccb,loctype,RepSpec.LastAcc)) then begin
    PUPasteQty(PUr,INr,rwcnt,diff);
  end;
  RETURN;
END;

updating function Boolean AddSTForThisItem(record RcVc RepSpec,record INVc INr,string variety,var record SDVc SDr,var record PUVc PUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype,
                                           var Boolean dbupdatedf)
begin
  val instock,units,diff;
  array val counteda;
  array string 20 batcha;
  array string 255 posa;
  Integer i,arrcnt;
  Date dat1,laststdate;
  Boolean res,found,testf;
  vector Boolean vtreatedf;  
  record INVc IN2r;
  record SerBalVc SerBalr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  Integer si,srwcnt;  
  record PISVc PISr;
  string 255 serialnr;

  res = true;
  arrcnt = 0;
  FindLastST(RepSpec,INr.Code,INr.SerNrf,RepSpec.RegDate,laststdate,units,instock,counteda,batcha,posa,arrcnt,variety,StockTaker);

  dat1 = laststdate;
  RecordCopy(IN2r,INr);
  IN2r.Code = INr.Code & variety;
  if (RepSpec.flags[3]==3) then begin
    if (blankdate(dat1)) then begin
      res = false;
      goto LAddSTForThisItem;
    end;
  end;
  if (nonblankdate(RepSpec.RegDate)) then begin
    if (RepSpec.RegDate<>dat1) then begin dat1 = RepSpec.RegDate; end;
  end;
  if (blankdate(dat1)) then begin dat1 = CurrentDate; end;
  if (blank(instock)) or (INr.SerNrf!=0) then begin
    if (nonblank(RepSpec.LastAcc)) then begin
      if (blank(RepSpec.AccStr)) then begin
        FindStockValueAtPosition(INr.Code & variety,";;;",RepSpec.LastAcc,PISr);
      end else begin
        FindStockValueAtPosition(INr.Code & variety,RepSpec.AccStr,RepSpec.LastAcc,PISr);
      end;
      instock = PISr.Instock;
      BackDatStock(INr.Code & variety,RepSpec.AccStr,RepSpec.LastAcc,instock,dat1,0);
    end else begin
      instock = GetStockQty(IN2r.Code,RepSpec.AccStr,dat1,false);
    end;
  end;
    
//  if ((blankdate(dat1)) or (units==0)) then begin
  if (blankdate(laststdate)) then begin
    switch (RepSpec.flags[3]) begin    
      case 0:
        units = 0;
        diff = units - instock;
      case 2:
        diff = 0;
      otherwise
        diff = units - instock;
    end;
  end else begin
    diff = units - instock;
  end;
//LogText(0,"1.AddSTForThisItem INr.Code=" & INr.Code & " variety=" & variety & " instock=" & instock & " units=" & units  & " diff=" & diff);

//Trace("","1.AddSTForThisItem INr.Code=" & INr.Code & " variety=" & variety & " instock=" & instock & " units=" & units  & " diff=" & diff & " RepSpec.LastAcc " & RepSpec.LastAcc);
  switch (IN2r.SerNrf) begin
    case 0:
      if (diff<0) then begin
        AddtoSD(RepSpec,SDr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf);
      end;     
      if (diff>0) then begin
        AddtoPU(RepSpec,PUr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf);
      end;
    case 1:
      if (RepSpec.flags[4]!=0) then begin
        switch (RepSpec.flags[3]) begin
          case 2:
            goto LCASE0;
          case 3:
            goto LCASE0;
          case 0:
LCASE0:;          
            for (i=0;i<arrcnt;i=i+1) begin
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              SerBalr.Serial = batcha[i];
              if (ReadFirstKey("Serial",SerBalr,3,true)) then begin
                if (counteda[i]==0) then begin
                  if (SerBalr.Quant!=0) then begin
                    AddtoSD(RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf);
                    diff = diff + 1;
                  end;
                end else begin
//?                
                end;
              end else begin
                AddtoPU(RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff - 1;
              end;
            end;
            if (RepSpec.flags[3]!=2) then begin
            dbupdatedf = true;
            while (dbupdatedf) begin
              dbupdatedf = false;
              ResetLoop(SerBalr);
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              found = true;
              while (LoopMain(SerBalr,2,found)) begin
                if  (SerBalr.Item!=IN2r.Code) then begin 
                  found = false;
                end;
                if (SerBalr.Location!=RepSpec.AccStr) then begin 
                  found = false;
                end; 
                if (diff>=0) then begin
                  found = false;
                end;
                if (found) then begin
                  testf = true;
                  if (SerBalr.Quant==0) then begin
                    testf = false;
                  end;
                  if (vtreatedf[SerBalr.Item & "??" & SerBalr.Serial]==true) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    for (i=0;i<arrcnt;i=i+1) begin                
                      if (SerBalr.Serial==batcha[i]) then begin
                        i = arrcnt;
                        testf = false;
                      end;
                    end;
                  end;             
                  if (testf) then begin
                    vtreatedf[SerBalr.Item & "??" & SerBalr.Serial] = true;
                    AddtoSD(RepSpec,SDr,IN2r,SerBalr.Serial,-1,flushcnt,ARAccb,loctype,dbupdatedf);
                    if (dbupdatedf) then begin
                      found = false;
                    end;
                    diff = diff + 1;
                  end;
                end;
              end;
            end;
            end;
          case 1:
            for (i=0;i<arrcnt;i=i+1) begin
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              SerBalr.Serial = batcha[i];
              if (ReadFirstKey("Serial",SerBalr,3,true)) then begin
                if (counteda[i]==0) then begin
                  if (SerBalr.Quant!=0) then begin
                    AddtoSD(RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf);
                    diff = diff + 1;
                  end;
                end else begin
//?                
                end;
              end else begin
                AddtoPU(RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff - 1;
              end;
            end;
        end;     
/*            
        if (diff<0) then begin
          ResetLoop(SerBalr);
          SerBalr.Item = IN2r.Code;
          SerBalr.Location = RepSpec.AccStr;
          found = true;
          while (LoopMain(SerBalr,2,found)) begin
            if  (SerBalr.Item!=IN2r.Code) then begin 
              found = false;
            end;
            if (SerBalr.Location!=RepSpec.AccStr) then begin 
              found = false;
            end; 
            if (diff>=0) then begin
              found = false;
            end;
            if (found) then begin
              testf = true;
              if (SerBalr.Quant==0) then begin
                testf = false;
              end;
              if (testf) then begin
                for (i=0;i<arrcnt;i=i+1) begin                
                  if (SerBalr.Serial==batcha[i]) then begin
                    i = arrcnt;
                    testf = false;
                  end;
                end;
              end;             
              if (testf) then begin
                AddtoSD(RepSpec,SDr,IN2r,SerBalr.Serial,-1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff + 1;
              end;
            end;
          end;
        end else begin
          for (i=0;i<arrcnt;i=i+1) begin
            SerBalr.Item = IN2r.Code;
            SerBalr.Location = RepSpec.AccStr;
            SerBalr.Serial = batcha[i];
            if (ReadFirstKey("Serial",SerBalr,3,true)==false) then begin
              AddtoPU(RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf);
              diff = diff - 1;
            end else begin
              if (counteda[i]==0) then begin
                AddtoSD(RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff + 1;
              end;
            end;
          end;
        end;    
*/          
      end else begin
        while (diff<>0) begin
          if (diff<0) then begin
            AddtoSD(RepSpec,SDr,IN2r,"",-1,flushcnt,ARAccb,loctype,dbupdatedf);
            diff = diff + 1;
          end;     
          if (diff>0) then begin
            AddtoPU(RepSpec,PUr,IN2r,"",1,flushcnt,ARAccb,loctype,dbupdatedf);
            diff = diff - 1;
          end;
        end;
      end;
    case 2:
      if (RepSpec.flags[4]!=0) then begin
        if (arrcnt>0) then begin
          for (i=0;i<arrcnt;i=i+1) begin
            instock = STCompFindSerialNrQty(INr.Code,variety,batcha[i],RepSpec.AccStr,posa[i],serialnr);
            diff = counteda[i] - instock;
            if (diff<0) then begin
              AddtoSD(RepSpec,SDr,IN2r,batcha[i],diff,flushcnt,ARAccb,loctype,dbupdatedf);
            end;     
            if (diff>0) then begin
              AddtoPU(RepSpec,PUr,IN2r,batcha[i],diff,flushcnt,ARAccb,loctype,dbupdatedf);
            end;
          end;
        end;

        if (RepSpec.flags[4]!=0) then begin
          ResetLoop(SerBalr);
          SerBalr.Item = IN2r.Code;
          SerBalr.Location = RepSpec.AccStr;
          found = true;
          while (LoopMain(SerBalr,2,found)) begin
            if (SerBalr.Item!=IN2r.Code) then begin found = false; end;
            if (SerBalr.Location!=RepSpec.AccStr) then begin found = false; end; 
            if (found) then begin
              testf = true;
              for (i=0;i<arrcnt;i=i+1) begin
                if (SerBalr.Serial==batcha[i]) then begin 
                  testf = false; 
                  i = arrcnt;
                end;
              end;
              if (testf) then begin
                instock = STCompFindSerialNrQty(INr.Code,variety,SerBalr.Serial,RepSpec.AccStr,RepSpec.LastAcc,serialnr);
                diff = -instock;
                if (diff<0) then begin
                  AddtoSD(RepSpec,SDr,IN2r,SerBalr.Serial,diff,flushcnt,ARAccb,loctype,dbupdatedf);
                end;     
                if (diff>0) then begin
                  AddtoPU(RepSpec,PUr,IN2r,SerBalr.Serial,diff,flushcnt,ARAccb,loctype,dbupdatedf);
                end;
              end;
            end;
          end;                
        end else begin
          if (arrcnt==0) then begin
            instock = STCompFindSerialNrQty(INr.Code,variety,"",RepSpec.AccStr,RepSpec.LastAcc,serialnr);
            if (diff<0) then begin
              AddtoSD(RepSpec,SDr,IN2r,serialnr,diff,flushcnt,ARAccb,loctype,dbupdatedf);
            end;     
            if (diff>0) then begin
              AddtoPU(RepSpec,PUr,IN2r,serialnr,diff,flushcnt,ARAccb,loctype,dbupdatedf);
            end;
          end;
        end;
      end else begin
        if (diff<0) then begin
          AddtoSD(RepSpec,SDr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf);
        end;     
        if (diff>0) then begin
          AddtoPU(RepSpec,PUr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf);
        end;
      end;
  end;
LAddSTForThisItem:;
  AddSTForThisItem = res;
  return;
end;

updating procedure STCompOneItem(record RcVc RepSpec,record INVc INr,var record SDVc SDr,var record PUVc PUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype)
BEGIN
  record INVc IN2r;
  string 60 sz,msk,mskrep;
  Boolean varf;
  Boolean TrHs,testf;
  record ItemStatusVc ISr;
  string 200 varsubset;
  Integer keys;
  Boolean dbupdatedf;
  vector Boolean vtreatedf;
  record StockTakeVc combStockTaker;
  row StockTakeVc combStockTakerw;
  Integer combi,combrwcnt;
  string 255 variety,incode,location;
  
  if (INr.ItemType==1) then begin
    if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin varf = true; end;
    if (varf) then begin
      FindLastSTForItem(RepSpec,INr.Code,RepSpec.RegDate,combStockTaker);
      
      dbupdatedf = true;
      while (dbupdatedf) begin
        dbupdatedf = false;

        TrHs = true;
        ResetLoop(ISr);
        ISr.Code = INr.Code;
        keys = 1;
        if (nonblank(RepSpec.AccStr)) then begin
          ISr.Location = RepSpec.AccStr;
          keys = 2;
        end;
        while (LoopMain(ISr,keys,TrHs)) begin    
          if (ISr.Code!=INr.Code) then begin TrHs = false; end;
          if (nonblank(RepSpec.AccStr)) then begin
            if (ISr.Location!=RepSpec.AccStr) then begin
              TrHs = false;
            end;
          end;
          testf = true;
          if (nonblank(RepSpec.AccStr)) then begin
            if (ISr.Location==";;;") then begin
              testf = false;
            end;
          end else begin
            if (ISr.Location!=";;;") then begin
              testf = false;
            end;
          end;
          if (TrHs==false) then begin testf = false; end;
          if (vtreatedf[ISr.Location & "??" & ISr.Variety]==true) then begin
            testf = false;
          end;
          if (testf) then begin
            vtreatedf[ISr.Location & "??" & ISr.Variety] = true;
            if (ReadFirstItem(ISr.Code & ISr.Variety,IN2r,true,true)) then begin
              if (AddSTForThisItem(RepSpec,IN2r,ISr.Variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
                TrHs = false;
              end else begin
                if (dbupdatedf) then begin
                  TrHs = false;
                end;
              end;
            end;
          end;
        end;  
      end;
      
      if (nonblank(RepSpec.AccStr)) then begin
        location = RepSpec.AccStr;
      end else begin
        location = ";;;";
      end;
      combrwcnt = MatRowCnt(combStockTaker);
      for (combi = 0; combi<combrwcnt; combi = combi + 1) begin
        MatRowGet(combStockTaker,combi,combStockTakerw);
        
        testf = true;
        variety = right(combStockTakerw.ArtCode,len(combStockTakerw.ArtCode)-len(INr.Code));
        incode = left(combStockTakerw.ArtCode,len(INr.Code));
        
        if ((incode!=INr.Code) or (left(variety,1)!=".")) then begin testf = false; end;
        if (testf) then begin
        
          if (vtreatedf[location & "??" & variety]==false) then begin
            vtreatedf[location & "??" & variety] = true;
            
            if (ReadFirstItem(INr.Code & variety,IN2r,true,true)) then begin
              AddSTForThisItem(RepSpec,IN2r,variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf);
            end;
          end;
        end;
      end;
    end else begin
      if (AddSTForThisItem(RepSpec,INr,"",SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
        TrHs = false;
      end;
    end;
  end;
  return;
end;

updating procedure STCompOneItem_PerPosition(record RcVc orgRepSpec,record INVc INr,var record SDVc SDr,var record PUVc PUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype)
begin
  record PISVc PISr;      
  Boolean found;
  record RcVc RepSpec;
  record INVc IN2r;
  Integer combi,combrwcnt;
  record StockTakeVc combStockTaker;
  row StockTakeVc combStockTakerw;
  Integer segs;
  Boolean dbupdatedf,testf;
  vector Boolean vtreatedf;
  string 255 variety,incode;
  
  FindLastSTForItem(orgRepSpec,INr.Code,orgRepSpec.RegDate,combStockTaker);

  dbupdatedf = true;
  while (dbupdatedf) begin
    dbupdatedf = false;

    ResetLoop(PISr);
    found = true;
    PISr.Location = orgRepSpec.AccStr;
    PISr.ArtCode = INr.Code;
    segs = 2;
    if (nonblank(orgRepSpec.LastAcc)) then begin
      PISr.Position = orgRepSpec.LastAcc;
      segs = 3;
    end;
    while (LoopKey("Location",PISr,segs,found)) begin
      if (PISr.Location!=orgRepSpec.AccStr) then begin found = false; end;
      if (PISr.ArtCode!=INr.Code) then begin found = false; end;
      if (nonblank(orgRepSpec.LastAcc)) then begin
        if (PISr.Position!=orgRepSpec.LastAcc) then begin found = false; end;
      end;
      if (found) then begin
        testf = true;
        if (vtreatedf[PISr.Variety & "??" & PISr.Position]==true) then begin
          testf = false;
        end;
        if (testf) then begin
          RecordCopy(RepSpec,orgRepSpec);
          RepSpec.LastAcc = PISr.Position;    
          if (AddSTForThisItem(RepSpec,INr,PISr.Variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
            found = false;
          end;
          vtreatedf[PISr.Variety & "??" & PISr.Position] = true;
          RemoveFromLastSTForItem(PISr.ArtCode & PISr.Variety,PISr.Position,combStockTaker);
          if (dbupdatedf) then begin
            found = false;
          end;
        end;
      end;
    end;
  end;
  combrwcnt = MatRowCnt(combStockTaker);
  for (combi=0;combi<combrwcnt;combi=combi+1) begin
    MatRowGet(combStockTaker,combi,combStockTakerw);
    testf = true;
    
    variety = right(combStockTakerw.ArtCode,len(combStockTakerw.ArtCode)-len(INr.Code));
    incode = left(combStockTakerw.ArtCode,len(INr.Code));
    if (incode!=INr.Code) then begin testf = false; end;
    if (nonblank(variety)) then begin
      if (left(variety,1)!=".") then begin testf = false; end;
    end;
    if (testf) then begin
      RecordCopy(RepSpec,orgRepSpec);
      RepSpec.LastAcc = combStockTakerw.Position;     
      
      if (ReadFirstItem(INr.Code & variety,IN2r,true,true)) then begin
        if (AddSTForThisItem(RepSpec,IN2r,variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
          combi = combrwcnt; //??
        end;
      end;
    end;
  end;


  return;
end;

updating procedure STLoopIN(record RcVc RepSpec)
BEGIN
  string 255 ckey;
  Integer keys;
  Boolean testf;
  record INVc INr;
  string 255 fromart,toart;
  string 255 frcc,tocc;
  Boolean TrHs;
  record SDVc SDr;
  record PUVc PUr;
  Integer flushcnt;
  record AccBlock ARAccb;
  record PUVc oldPUr;
  record SDVc oldSDr;
  record LocationVc Locr;

  Locr.Code = RepSpec.AccStr;
  if (ReadFirstMain(Locr,1,true)) then begin end;
  BlockLoad(ARAccb);
  RecordNew(SDr);
  RecordNew(PUr);
  fromart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);
  INr.Code = fromart;
  ckey = "Code";
  keys = 1;  
  TrHs = true;
  while (LoopKey(ckey,INr,keys,TrHs)) begin
    testf = true;
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          if (RepSpec.flags[2]==1) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs) then begin
      if (nonblank(toart)) then begin
        if (INr.Code>toart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group<frcc) then begin
          testf = false;
        end;
      end;
    end;      
    if (nonblank(RepSpec.f4)) then begin
      if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
        testf = false;
      end;
    end;
    if (nonblank(RepSpec.f5)) then begin
      if (testf==true) then begin
        testf = false;
        ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
      end;
    end;  
    if (TrHs==false) then begin testf = false; end;
    if (testf) then begin
      if (nonblank(RepSpec.AccStr)) then begin
        if (Locr.RequirePos!=0) then begin
          STCompOneItem_PerPosition(RepSpec,INr,SDr,PUr,flushcnt,ARAccb,Locr.Type);
        end else begin
          STCompOneItem(RepSpec,INr,SDr,PUr,flushcnt,ARAccb,Locr.Type);
        end;
      end else begin
        STCompOneItem(RepSpec,INr,SDr,PUr,flushcnt,ARAccb,Locr.Type);
      end;
    end;
    MaintTrace(INr.Code);
  end;
  if (MatRowCnt(SDr)>0) then begin
    SDr.TransDate = RepSpec.RegDate;
    SDr.SerNr = NextSerNr("SDVc",SDr.TransDate,-1,false,"");  
    SDr.Location = RepSpec.AccStr;
    SDr.Comment = RepSpec.f6;
    SDSumUp(SDr);
    if (blankdate(SDr.TransDate)) then begin SDr.TransDate = CurrentDate; end;
    SDr.CostAcc = ARAccb.StockLossAcc;
    if (blank(SDr.CostAcc)) then begin
      SDr.CostAcc = ARAccb.StockGainAcc;
    end;
    SDr.Objects = GetLocationObject(SDr.Location);
    if (SDr.SerNr>0) then begin
      if (RecordStore(SDr,false)) then begin
      end;  
      if (RepSpec.flags[5]!=0) then begin
        RecordCopy(oldSDr,SDr);
        SDr.OKFlag = 1;
        if (RecordUpdate(oldSDr,SDr,true)==0) then begin 
        end;
      end;
    end;
  end;
  if (MatRowCnt(PUr)>0) then begin
    PUr.TransDate = RepSpec.RegDate;
    PUr.SerNr = NextSerNr("PUVc",PUr.TransDate,-1,false,"");  
    PUr.Location = RepSpec.AccStr;
    PUr.Comment = RepSpec.f6;
    PUSumUp(PUr);
    if (blankdate(PUr.TransDate)) then begin PUr.TransDate = CurrentDate; end;
    PUr.Objects = GetLocationObject(PUr.Location);
    if (PUr.SerNr>0) then begin
      if (RecordStore(PUr,false)) then begin
      end;  
      if (RepSpec.flags[5]!=0) then begin
        RecordCopy(oldPUr,PUr);
        PUr.OKFlag = 1;
        if (RecordUpdate(oldPUr,PUr,true)==0) then begin 
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating procedure STCompMn(record RcVc RepSpec)
BEGIN
  if (CountRecords("LocationVc")>1) then begin
    if (blank(RepSpec.AccStr)) then begin
      MessageBox(1058," " & USetStr(5010));
      goto LSTCompMn;
    end;
  end;
  if (blankdate(RepSpec.RegDate)) then begin RepSpec.RegDate = CurrentDate; end;
  STLoopIN(RepSpec);  
LSTCompMn:;
  RETURN;
END;
