external procedure CheckFlush(var Integer,Integer);

updating procedure ForkLiftQueRestart()
BEGIN
  Boolean TrHs;
  record ForkLiftQueVc ForkLiftQuer;
  record ForkLiftQueVc oldForkLiftQuer;
  Integer cnt;
  
  TrHs = true;
  ForkLiftQuer.Status = 1;
  while (LoopKey("Status",ForkLiftQuer,1,TrHs)) begin
    if (ForkLiftQuer.Status>2) then begin TrHs = false; end;
    if (ForkLiftQuer.Status==0) then begin TrHs = false; end;
    if (TrHs) then begin
      RecordCopy(oldForkLiftQuer,ForkLiftQuer);
      ForkLiftQuer.Attempts = 0;
      ForkLiftQuer.Status = 0;
      ForkLiftQuer.ForkLiftSystemID = "";
      ForkLiftQuer.ForkLift = "";
      if (RecordUpdate(oldForkLiftQuer,ForkLiftQuer,false)==0) then begin end;
      CheckFlush(cnt,20);
//      ForkLiftQuer.NextInPickMode
    end;
  end;
  RETURN;
END;

global
updating procedure NT7000ColdRestartMn(record RcVc RepSpec)
BEGIN
  record NT7000PickModeBlock NT7000PickModeRec;
  record NT7000NumbersVc NTNr;
  record NT7000NumbersVc oldNTNr;
  
  BlockLoad(NT7000PickModeRec);
  NT7000PickModeRec.ActiveSHNr = -1;
  NT7000PickModeRec.ActiveForkLiftQueNr = -1;
  NT7000PickModeRec.PalletCnt = 0;
  BlockStore(NT7000PickModeRec);

  NTNr.Location = RepSpec.f1;
  ReadFirstMain(NTNr,1,true);
  RecordCopy(oldNTNr,NTNr);
  NTNr.OrdSentToNT7000 = 0;
  RecordUpdate(oldNTNr,NTNr,true);
  
  ForkLiftQueRestart;
  RETURN;
END;