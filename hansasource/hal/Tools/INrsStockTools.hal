external function roundmode SetRoundModeD(Integer);
forward function Boolean ShouldInvoiceRowUpdateStock(record IVVc,row IVVc);
external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer FIFOPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer GetFIFOPerSerialNr(record INVc,record ITVc,record CostAccBlock);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external updating procedure InvalidateItemHistVc(string,LongInt,Integer);
external procedure RoundRowSum(string,string,string,var val);
external updating procedure StoreItemHistory_In_CreditInvoice(Integer,record CostAccBlock,record MainStockBlock,record IVVc,row IVVc,Integer,record INVc,record TempStockVc,Boolean);
external function val CreditedInvoiceRowFIFORowVal(record INVc,string,Integer,LongInt,string,LongInt,string,val,Integer,val);
external function val CalculateQty2(val,val);
external updating procedure RetPUStoreItemHistory_Out(record MainStockBlock,record CostAccBlock,record RetPUVc,row RetPUVc,Integer,Integer,record TempStockVc,Boolean);
external updating procedure UpdateBatchBestBefore(string,string,string,Date,Date,val,val,val,Integer,Integer,Boolean,
                                                  string,string,string,string,string,string,string,string,
                                                  string,string,string,string,string,string,string,string, string,string);
external updating procedure RetStoreItemHistory_In(record INVc,record MainStockBlock,record CostAccBlock,record RetVc,row RetVc,Integer,Integer,record TempStockVc,Boolean);
external updating procedure StockMovStoreItemHistory_In(record MainStockBlock,string,string,string,string,string,Date,val,val,val,LongInt,Integer,Integer,string,record TempStockVc,Boolean);
external updating procedure StoreItemHistory_In(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,string,record TempStockVc,Boolean);
external updating procedure StoreItemHistory_Out(record MainStockBlock,string,string,string,string,Date,val,val,val,LongInt,Integer,Integer,string,record TempStockVc,Boolean);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external updating procedure LockRecipe(string);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external updating procedure UpdateSerStock(string,string,string,val,val);
external updating procedure UpdateInternalSerStock(string,string,string,val,val);

updating procedure IVUpdateStructureItemHist(record IVVc IVp,integer i,string location,string item,val aqty,record TempStockVc TSr,Boolean usetmpstkf)
begin 
  record INVc INr;
  record ITVc ITr; 
  row IVVc IVrw;
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  Integer RetFIFOQue;
  Integer primary,queuecostmodel;
  val p;
  Integer updstock;
  string 255 serialnr;
  val qty;

  qty = Round(aqty,SetRoundModeD(3));
  BlockLoad(MSb);
  BlockLoad(CAb);
  MatRowGet(IVp,i,IVrw);
  if (ReadFirstItem(item,INr,true,false)) then begin end;
    updstock = 0;
    if (ShouldInvoiceRowUpdateStock(IVp,IVrw)) then begin
      updstock = 1;
    end;
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
      if (IVp.CredInv>0) and (IVrw.CreditedRow>=0) then begin
        RetFIFOQue = CAb.RetFIFOQue;
      end else begin
        RetFIFOQue = 0;
    end;
    switch (RetFIFOQue) begin
      case 0:                              
        p = CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,item,qty,IVrw.stp,0);
        if (p==0) then begin
          if (IVp.CredInv<=0) then begin
            p = INr.InPrice*qty;
          end;
        end;

        serialnr = FirstInRange(IVrw.SerialNr,60);
        StoreItemHistory_In(MSb,item,serialnr,location,"IVVc",IVp.TransDate,IVp.TransDate,qty,0,p,IVp.SerNr,i,updstock,IVrw.PosCode,"",TSr,usetmpstkf);
      case 1: 
//              StoreItemHistory_In_CreditInvoice_InQueComp(MSb,IVp,IVrw,i);
    end;
  end else begin
    if (IVp.Invalid!=0) then begin
      switch (CAb.RetFIFOQue) begin
        case 0: 
          InvalidateItemHistVc("IVVc",IVp.SerNr,i);
          serialnr = FirstInRange(IVrw.SerialNr,60);
          StoreItemHistory_In(MSb,item,serialnr,location,"IVVc",IVp.TransDate,IVp.TransDate,qty,0,CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,item,qty,IVrw.stp,0),IVp.SerNr,i,updstock,IVrw.PosCode,"",TSr,usetmpstkf);
        end;
    end else begin
      serialnr = FirstInRange(IVrw.SerialNr,60);
      StoreItemHistory_Out(MSb,item,serialnr,location,"IVVc",IVp.TransDate,qty,0,IVrw.FIFORowVal,IVp.SerNr,i,updstock,IVrw.PosCode,TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure PurUpdateItemHist2(record PUVc PUp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  row PUVc PUrw;
  Integer rwcnt,i;
  string 255 location;
  string 255 thelocation;
  val sum;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty;
  record INVc INr;
 
  if (PUp.Invalid!=0) then begin
    goto LPurUpdateItemHist;
  end;
  BlockLoad(MSb);
  BlockLoad(SNrb);
  location = PUp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    if (blank(PUrw.Location)) then begin
      thelocation = location;
    end else begin
      thelocation = PUrw.Location;
    end;
    if (PUrw.ovst==0) then begin    
      ReadFirstItem(PUrw.ArtCode,INr,true,false);
      if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
        sum = PUrw.Sum;
        if (PUp.InclVAT!=0) then begin
          sum = PUrw.Quant*PUrw.CostPrice;
        end;
        sum = sum/PUrw.Quant;
        qty = blankval;
        serialnr = FirstInRange(PUrw.SerialNr,60);
        while (nonblank(serialnr)) begin
          StoreItemHistory_In(MSb,PUrw.ArtCode,serialnr,thelocation,"PUVc",PUp.TransDate,PUp.TransDate,1.00,PUrw.Coefficient,sum,PUp.SerNr,i,1,PUrw.ToPosCode,PUp.VECode,TSr,usetmpstkf);
          qty = qty + 1;
          serialnr = NextSerialNumber(PUrw.ArtCode,serialnr,SNrb);
          if (qty>=PUrw.Quant) then begin serialnr = ""; end;
        end;
      end else begin          
        sum = PUrw.Sum;
        if (PUp.InclVAT!=0) then begin
          sum = PUrw.Quant*PUrw.CostPrice;
          RoundRowSum(PUp.CurncyCode,"","PUVc",sum);
        end;
        if (blank(PUrw.PosCode)) then begin
          StoreItemHistory_In(MSb,PUrw.ArtCode,PUrw.SerialNr,thelocation,"PUVc",PUp.TransDate,PUp.TransDate,PUrw.Quant,PUrw.Coefficient,sum,PUp.SerNr,i,1,PUrw.ToPosCode,PUp.VECode,TSr,usetmpstkf);
        end else begin
          StoreItemHistory_In(MSb,PUrw.ArtCode,PUrw.SerialNr,thelocation,"PUVc",PUp.TransDate,PUp.TransDate,PUrw.Quant,PUrw.Coefficient,sum,PUp.SerNr,i,1,PUrw.PosCode,PUp.VECode,TSr,usetmpstkf);
        end;
      end;
    end;
  end;
LPurUpdateItemHist:;  
  return;
end;

global
updating procedure PurUpdateItemHist(record PUVc PUp)
begin
  record TempStockVc TSr;
  
  PurUpdateItemHist2(PUp,TSr,false);
  return;
end;

global
updating procedure SDUpdateItemHist2(record SDVc SDp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record SHVc RecSHr;
  row SDVc SDrw;
  row SHVc SH2rw;
  Integer rwcnt,i,j;
  Integer shrwcnt;
  string 10 location,thelocation;
  Boolean isstruct;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty,sum;
  record INVc INr;
  
  BlockLoad(MSb);
  BlockLoad(SNrb);
  location = SDp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(SDp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SDp,i,SDrw);
    thelocation = SDrw.Location;
    if (blank(thelocation)) then begin
      thelocation = location;
    end;
    isstruct = ExpandStructItem(SDrw.ArtCode,SDrw.Recepy,SDrw.Qty,RecSHr);
    if (isstruct==false) then begin
      ReadFirstItem(SDrw.ArtCode,INr,true,false);
      if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
        sum = SDrw.FIFORowVal/SDrw.Qty;
        qty = blankval;
        serialnr = FirstInRange(SDrw.SerialNr,60);
        while (nonblank(serialnr)) begin
          StoreItemHistory_Out(MSb,SDrw.ArtCode,serialnr,thelocation,"SDVc",SDp.TransDate,1.00,SDrw.Coefficient,sum,SDp.SerNr,i,1,SDrw.PosCode,TSr,usetmpstkf);
          qty = qty + 1;
          serialnr = NextSerialNumber(SDrw.ArtCode,serialnr,SNrb);
          if (qty>=SDrw.Qty) then begin serialnr = ""; end;
        end;
      end else begin          
        StoreItemHistory_Out(MSb,SDrw.ArtCode,SDrw.SerialNr,thelocation,"SDVc",SDp.TransDate,SDrw.Qty,SDrw.Coefficient,SDrw.FIFORowVal,SDp.SerNr,i,1,SDrw.PosCode,TSr,usetmpstkf);
      end;
    end else begin 
      if (nonblank(SDrw.Recepy)) then begin
        LockRecipe(SDrw.Recepy);
      end;    
      shrwcnt = MatRowCnt(RecSHr);
      for (j=0;j<shrwcnt;j=j+1) begin
        MatRowGet(RecSHr,j,SH2rw);
        SH2rw.Ship = Round(SH2rw.Ship,SetRoundModeD(3));
        StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",thelocation,"SDVc",SDp.TransDate,SH2rw.Ship,SH2rw.Coefficient,SDrw.FIFORowVal,SDp.SerNr,i,1,SDrw.PosCode,TSr,usetmpstkf);
      end;
    end;
  end;
  return;
end;

global
updating procedure SDUpdateItemHist(record SDVc SDp)
begin
  record TempStockVc TSr;
  
  SDUpdateItemHist2(SDp,TSr,false);
  return;
end;

global
updating procedure SRUpdateItemHist2(record SRVc SRp,Boolean inf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  row SRVc SRrw;
  Integer rwcnt,i;
  string 10 location,thelocation;
  
  BlockLoad(MSb);
  location = SRp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(SRp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SRp,i,SRrw);
    thelocation = SRrw.Location;
    if (blank(thelocation)) then begin
      thelocation = location;
    end;
    if (inf==false) then begin
      StoreItemHistory_Out(MSb,SRrw.ArtCode,SRrw.SerialNr,thelocation,"SRVc",SRp.TransDate,SRrw.Qty,SRrw.Coefficient,SRrw.FIFORowVal,SRp.SerNr,i,1,SRrw.PosCode,TSr,usetmpstkf);
    end else begin
      StoreItemHistory_In(MSb,SRrw.ArtCode,SRrw.SerialNr,thelocation,"SRVc",SRp.TransDate,SRp.TransDate,SRrw.Qty,SRrw.Coefficient,SRrw.NewFIFORowVal,SRp.SerNr,i,1,SRrw.PosCode,"",TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure SRUpdateItemHist(record SRVc SRp,Boolean inf)
begin
  record TempStockVc TSr;
  
  SRUpdateItemHist2(SRp,inf,TSr,false);
  return;
end;

global
updating procedure SHUpdateItemHist2(record SHVc SHp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record SHVc RecSHr;
  row SHVc SHrw;
  row SHVc SH2rw;
  Integer rwcnt,i,j;
  Integer shrwcnt;
  string 10 location,thelocation;
  Boolean isstruct;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty,sum;
  record INVc INr;
  
  BlockLoad(MSb);
  BlockLoad(SNrb);
  location = SHp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(SHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHp,i,SHrw);
    thelocation = SHrw.Location;
    if (blank(thelocation)) then begin
      thelocation = location;
    end;
    isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
    if (isstruct==false) then begin
      ReadFirstItem(SHrw.ArtCode,INr,true,false);
      if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
        sum = SHrw.FIFORowVal/SHrw.Ship;
        qty = blankval;
        serialnr = FirstInRange(SHrw.SerialNr,60);
        while (nonblank(serialnr)) begin
          StoreItemHistory_Out(MSb,SHrw.ArtCode,serialnr,thelocation,"SHVc",SHp.ShipDate,1.00,SHrw.Coefficient,sum,SHp.SerNr,i,1,SHrw.PosCode,TSr,usetmpstkf);
          qty = qty + 1;
          serialnr = NextSerialNumber(SHrw.ArtCode,serialnr,SNrb);
          if (qty>=SHrw.Ship) then begin serialnr = ""; end;
        end;
      end else begin          
        StoreItemHistory_Out(MSb,SHrw.ArtCode,SHrw.SerialNr,thelocation,"SHVc",SHp.ShipDate,SHrw.Ship,SHrw.Coefficient,SHrw.FIFORowVal,SHp.SerNr,i,1,SHrw.PosCode,TSr,usetmpstkf);
      end;
    end else begin 
      if (nonblank(SHrw.Recepy)) then begin
        LockRecipe(SHrw.Recepy);
      end;    
      shrwcnt = MatRowCnt(RecSHr);
      for (j=0;j<shrwcnt;j=j+1) begin
        MatRowGet(RecSHr,j,SH2rw);
        SH2rw.Ship = Round(SH2rw.Ship,SetRoundModeD(3));
        StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",thelocation,"SHVc",SHp.ShipDate,SH2rw.Ship,SH2rw.Coefficient,SHrw.FIFORowVal,SHp.SerNr,i,1,SHrw.PosCode,TSr,usetmpstkf);
      end;
    end;
  end;
  return;
end;

global
updating procedure SHUpdateItemHist(record SHVc SHp)
begin
  record TempStockVc TSr;
  
  SHUpdateItemHist2(SHp,TSr,false);
  return;
end;

global
updating procedure OffHireUpdateIntINrs2(record OffHireVc OffHirep,Boolean importf,Boolean rebuildf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record IntINrsVc IntINrsr;
  row OffHireVc OffHirerw;
  Integer rwcnt,i;
  string 10 location,loc2;
  val t,costp;
  record INVc INr;
  
  BlockLoad(MSb);
  location = OffHirep.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(OffHirep);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OffHirep,i,OffHirerw);
    if (nonblank(OffHirerw.Location)) then begin
      loc2 = OffHirerw.Location;
    end else begin
      loc2 = location;
    end;
    if (rebuildf==false) then begin
      IntINrsr.ItemCode = OffHirerw.ArtCode;
      IntINrsr.Variety = "";
      if (ReadFirstItem(OffHirerw.ArtCode,INr,false,false)) then begin
        if (OffHirerw.ArtCode!=INr.Code) then begin
          IntINrsr.Variety = right(OffHirerw.ArtCode,len(OffHirerw.ArtCode)-len(INr.Code));
          IntINrsr.ItemCode = INr.Code;
        end;
      end;
      IntINrsr.Location = loc2;
      IntINrsr.FileName = "OffHireVc";
      IntINrsr.Row = i;
      IntINrsr.TransNr = OffHirep.SerNr;
      IntINrsr.TransDate = OffHirep.TransDate;
      IntINrsr.StockAffectf = 1;
      if ((OffHirerw.Status==1) or (OffHirerw.Status==2) or (OffHirerw.Status==3) or (OffHirerw.Status==6)) then begin
        IntINrsr.Qty = 0;
        IntINrsr.FIFO = 0;
      end else begin
        IntINrsr.Qty = OffHirerw.Quant;
        IntINrsr.FIFO = 1;
      end;
      t = IntINrsr.Qty;
      if (RecordStore(IntINrsr,false)) then begin end;
      costp = blankval;
      t = OffHirerw.Quant;
      UpdateInternalSerStock(OffHirerw.ArtCode,loc2,OffHirerw.SerialNr,t,costp);
    end;
    if (importf==false) then begin
      StoreItemHistory_In(MSb,OffHirerw.ArtCode,OffHirerw.SerialNr,loc2,"OffHireVc",OffHirep.TransDate,OffHirep.TransDate,OffHirerw.Quant,1,OffHirerw.Quant*costp,OffHirep.SerNr,i,0,"","",TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure OffHireUpdateIntINrs(record OffHireVc OffHirep,Boolean importf,Boolean rebuildf)
begin
  record TempStockVc TSr;
  
  OffHireUpdateIntINrs2(OffHirep,importf,rebuildf,TSr,false);
  return;
end;

global
updating procedure INTransferUpdateItemHist2(record INTransferVc INTransferp,Boolean realstock,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record IntINrsVc IntINrsr;
  record INVc INr;
  row INTransferVc INTransferrw;
  Integer rwcnt,i;
  string 10 location,loc2;
  
  BlockLoad(MSb);
  location = INTransferp.Location;
  if (realstock) then begin
    location = INTransferp.FrLocation;
  end;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(INTransferp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(INTransferp,i,INTransferrw);
    if (realstock==false) then begin
      if (nonblank(INTransferrw.Location)) then begin
        loc2 = INTransferrw.Location;
      end else begin
        loc2 = location;
      end;
    end else begin
      loc2 = location;
    end;
    if (realstock) then begin
      StoreItemHistory_Out(MSb,INTransferrw.ArtCode,INTransferrw.SerialNr,loc2,"INTransferVc",INTransferp.TransDate,INTransferrw.Quant,INTransferrw.Coefficient,INTransferrw.FIFORowVal,INTransferp.SerNr,i,1,INTransferrw.PosCode,TSr,usetmpstkf);
    end else begin
      IntINrsr.ItemCode = INTransferrw.ArtCode;
      IntINrsr.Variety = "";
      if (ReadFirstItem(INTransferrw.ArtCode,INr,false,false)) then begin
        if (INTransferrw.ArtCode!=INr.Code) then begin
          IntINrsr.Variety = right(INTransferrw.ArtCode,len(INTransferrw.ArtCode)-len(INr.Code));
          IntINrsr.ItemCode = INr.Code;
        end;
      end;
      IntINrsr.Location = loc2;
      IntINrsr.FileName = "INTransferVc";
      IntINrsr.TransNr = INTransferp.SerNr;
      IntINrsr.TransDate = INTransferp.TransDate;
      IntINrsr.StockAffectf = 1;
      IntINrsr.Qty = INTransferrw.Quant;
      IntINrsr.Row = i;
      IntINrsr.FIFO = 1;
      if (RecordStore(IntINrsr,false)) then begin end;
    end;
  end;
  return;
end;

global
updating procedure INTransferUpdateItemHist(record INTransferVc INTransferp,Boolean realstock)
begin
  record TempStockVc TSr;
  
  INTransferUpdateItemHist2(INTransferp,realstock,TSr,false)
  return;
end;

global
updating procedure INTransferUpdateSerialNr2(record INTransferVc INTransferp,Boolean realstock,Boolean importf,Boolean negf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record IntINrsVc IntINrsr;
  record INVc INr;
  row INTransferVc INTransferrw;
  Integer rwcnt,i;
  string 10 location,loc2;
  Boolean save;
  val t,costp;
  
  BlockLoad(MSb);
  location = INTransferp.Location;
  if (realstock) then begin
    location = INTransferp.FrLocation;
  end;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(INTransferp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(INTransferp,i,INTransferrw);
    if (realstock==false) then begin
      if (nonblank(INTransferrw.Location)) then begin
        loc2 = INTransferrw.Location;
      end else begin
        loc2 = location;
      end;
    end else begin
      loc2 = location;
    end;
    costp = blankval;
    if (realstock) then begin
      t = -INTransferrw.Quant;
      if (negf) then begin 
        t = -t; 
      end;
      UpdateSerStock(INTransferrw.ArtCode,loc2,INTransferrw.SerialNr,t,costp);
    end else begin
      t = INTransferrw.Quant;
      if (negf) then begin 
        t = -t; 
      end;
      UpdateInternalSerStock(INTransferrw.ArtCode,loc2,INTransferrw.SerialNr,t,costp);
      if (importf==false) then begin
        if (negf==false) then begin 
          StoreItemHistory_In(MSb,INTransferrw.ArtCode,INTransferrw.SerialNr,loc2,"INTransferVc",INTransferp.TransDate,INTransferp.TransDate,INTransferrw.Quant,1,t*costp,INTransferp.SerNr,i,0,"","",TSr,usetmpstkf);
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure INTransferUpdateSerialNr(record INTransferVc INTransferp,Boolean realstock,Boolean importf,Boolean negf)
begin
  record TempStockVc TSr;
  
  INTransferUpdateSerialNr2(INTransferp,realstock,importf,negf,TSr,false);
  return;
end;

global
updating procedure DispatchUpdateIntINrs2(record DispatchVc Dispatchp,Boolean importf,Boolean rebuildf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record IntINrsVc IntINrsr;
  row DispatchVc Dispatchrw;
  Integer rwcnt,i;
  string 10 location,loc2;
  Boolean save;
  val t,costp;
  record INVc INr;
  
  BlockLoad(MSb);
  location = Dispatchp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(Dispatchp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Dispatchp,i,Dispatchrw);
    IntINrsr.ItemCode = Dispatchrw.ArtCode;
    IntINrsr.Variety = "";
    if (ReadFirstItem(Dispatchrw.ArtCode,INr,false,false)) then begin
      if (Dispatchrw.ArtCode!=INr.Code) then begin
        IntINrsr.Variety = right(Dispatchrw.ArtCode,len(Dispatchrw.ArtCode)-len(INr.Code));
        IntINrsr.ItemCode = INr.Code;
      end;
    end;
    IntINrsr.Location = location;
    IntINrsr.FileName = "DispatchVc";
    IntINrsr.FIFO = 0;
    IntINrsr.Row = i;
    IntINrsr.TransNr = Dispatchp.SerNr;
    IntINrsr.TransDate = Dispatchp.TransDate;
    if (rebuildf==false) then begin
      save = true;
      IntINrsr.StockAffectf = 1;
      IntINrsr.Qty =  -Dispatchrw.Quant;
      if (save) then begin
        if (RecordStore(IntINrsr,false)) then begin end;
      end;
      costp = blankval;
      t = -Dispatchrw.Quant;
      UpdateInternalSerStock(Dispatchrw.ArtCode,location,Dispatchrw.SerialNr,t,costp);
    end;
    if (importf==false) then begin
      StoreItemHistory_In(MSb,Dispatchrw.ArtCode,Dispatchrw.SerialNr,location,"DispatchVc",Dispatchp.TransDate,Dispatchp.TransDate,Dispatchrw.Quant,1,t*costp,Dispatchp.SerNr,i,0,"","",TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure DispatchUpdateIntINrs(record DispatchVc Dispatchp,Boolean importf,Boolean rebuildf)
begin
  record TempStockVc TSr;
  
  DispatchUpdateIntINrs2(Dispatchp,importf,rebuildf,TSr,false);
  return;
end;

global
updating procedure RetUpdateItemHist2(record RetVc Retp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record INVc INr;
  row RetVc Retrw;
  Integer i,rwcnt;
  string 255 location;
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  
  BlockLoad(CAb);
  BlockLoad(MSb);
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    location = Retrw.Location;
    if (blank(location)) then begin
      location = Retp.Location;
    end;
    if (blank(location)) then begin
      location = MSb.MainStock;
    end;
    if (ReadFirstItem(Retrw.ArtCode,INr,false,false)) then begin
    end;
    if (INr.ItemType==1) or (INr.ItemType==2) then begin
      RetStoreItemHistory_In(INr,MSb,CAb,Retp,Retrw,i,Retp.UpdStockFlag,TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure RetUpdateItemHist(record RetVc Retp)
begin
  record TempStockVc TSr;
  
  RetUpdateItemHist2(Retp,TSr,false);
  return;
end;

global
updating procedure StockMovUpdateItemHistory_Out2(record StockMovVc StockMovp,string frlocation,record MainStockBlock MSb,record SerNrTrackBlock SNrb,
                                                 row StockMovVc StockMovrw,Boolean sentquantf,Integer currow,record INVc INr,record TempStockVc TSr,Boolean usetmpstkf)
begin
  string 20 frpos;
  val smquant,costp;
  Date smdate;
  string 255 serialnr;
  val qty,sum;

  if (sentquantf) then begin
    smquant = StockMovrw.SentQuant;
    smdate = StockMovp.SentTransDate;
    sum = StockMovrw.SentFIFORowVal;
  end else begin
    smquant = StockMovrw.Quant;
    smdate = StockMovp.TransDate;
    sum = StockMovrw.FIFORowVal;
  end;
  if (smquant!=0) then begin
    frpos = StockMovp.FrPos;
    if (blank(frpos)) then begin
      frpos = StockMovrw.FrPosCode;
    end;  
    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
      if (sentquantf) then begin
        sum = sum/smquant;
      end else begin
        sum = sum/smquant;
      end;
      qty = blankval;
      serialnr = FirstInRange(StockMovrw.SerialNr,60);
      while (nonblank(serialnr)) begin
        StoreItemHistory_Out(MSb,StockMovrw.ArtCode,serialnr,frlocation,"StockMovVc",smdate,1.00,StockMovrw.Coefficient,sum,StockMovp.SerNr,currow,1,frpos,TSr,usetmpstkf);
        qty = qty + 1;
        serialnr = NextSerialNumber(StockMovrw.ArtCode,serialnr,SNrb);
        if (qty>=smquant) then begin serialnr = ""; end;
      end;
    end else begin          
      StoreItemHistory_Out(MSb,StockMovrw.ArtCode,StockMovrw.SerialNr,frlocation,"StockMovVc",smdate,smquant,StockMovrw.Coefficient,sum,StockMovp.SerNr,currow,1,frpos,TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure StockMovUpdateItemHistory_Out(record StockMovVc StockMovp,string frlocation,record MainStockBlock MSb,record SerNrTrackBlock SNrb,
                                                 row StockMovVc StockMovrw,Boolean sentquantf,Integer currow,record INVc INr)
begin
  record TempStockVc TSr;

  StockMovUpdateItemHistory_Out2(StockMovp,frlocation,MSb,SNrb,StockMovrw,sentquantf,currow,INr,TSr,false);
  return;
end;

global
updating procedure StockMovUpdateItemHist_In2(record StockMovVc StockMovp,string frlocation,string tolocation,record MainStockBlock MSb,record SerNrTrackBlock SNrb,
                                        row StockMovVc StockMovrw,Boolean sentquantf,Integer currow,record INVc INr,record TempStockVc TSr,Boolean usetmpstkf)
begin
  val smquant,smnewprice;
  Date smdate;
  string 20 topos;  
  string 255 serialnr;
  val qty,sum;

  if (sentquantf) then begin
    smquant = StockMovrw.SentQuant;
    smdate = StockMovp.SentTransDate;
    smnewprice = StockMovrw.SentNewPrice;
  end else begin
    smquant = StockMovrw.Quant;
    smdate = StockMovp.TransDate;
    smnewprice = StockMovrw.NewPrice;
  end;
  if (smquant!=0) then begin
    topos = StockMovp.ToPos;
    if (blank(topos)) then begin
      topos = StockMovrw.ToPosCode;
    end;  
    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
      qty = blankval;
      serialnr = FirstInRange(StockMovrw.SerialNr,60);
      while (nonblank(serialnr)) begin
        StockMovStoreItemHistory_In(MSb,StockMovrw.ArtCode,serialnr,frlocation,tolocation,"StockMovVc",smdate,1.00,StockMovrw.Coefficient,smnewprice,StockMovp.SerNr,currow,1,topos,TSr,usetmpstkf);
        qty = qty + 1;
        serialnr = NextSerialNumber(StockMovrw.ArtCode,serialnr,SNrb);
        if (qty>=smquant) then begin serialnr = ""; end;
      end;
    end else begin          
      StockMovStoreItemHistory_In(MSb,StockMovrw.ArtCode,StockMovrw.SerialNr,frlocation,tolocation,"StockMovVc",smdate,smquant,StockMovrw.Coefficient,smnewprice,StockMovp.SerNr,currow,1,topos,TSr,usetmpstkf);
    end;
  end;
LStockMovUpdateItemHist_In:;
  return;
end;

global
updating procedure StockMovUpdateItemHist_In(record StockMovVc StockMovp,string frlocation,string tolocation,record MainStockBlock MSb,record SerNrTrackBlock SNrb,
                                        row StockMovVc StockMovrw,Boolean sentquantf,Integer currow,record INVc INr)
begin
  record TempStockVc TSr;
  
  StockMovUpdateItemHist_In2(StockMovp,frlocation,tolocation,MSb,SNrb,StockMovrw,sentquantf,currow,INr,TSr,false);
  return;
end;

global
updating procedure StockMovUpdateItemHist2(record StockMovVc StockMovp,record StockMovVc prevStockMovp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  row StockMovVc StockMovrw;
  Integer rwcnt,i;
  record MainStockBlock MSb;
  string 20 frlocation,tolocation,fromlocation;
  Boolean fromf,fromsendf,fromthrouf,tof,tothrouf;
  record SerNrTrackBlock SNrb;
  record INVc INr;

  BlockLoad(SNrb);
  frlocation = StockMovp.FrLocation;
  if (blank(frlocation)) then begin
    frlocation = MSb.MainStock;
  end;
  tolocation = StockMovp.ToLocation;
  if (blank(tolocation)) then begin
    tolocation = MSb.MainStock;
  end;

  if (StockMovp.SentOKFlag==0) then begin
    if (StockMovp.OKFlag!=0) then begin
      fromf = true;
      tof = true;
      if (RecordValid(prevStockMovp)) then begin
        if (prevStockMovp.OKFlag!=0) then begin
          fromf = false;
          tof = false;
        end;
      end;
    end;
  end else begin
    fromsendf = true;
    tothrouf = true;
    if (RecordValid(prevStockMovp)) then begin
      if (prevStockMovp.SentOKFlag!=0) then begin
        fromsendf = false;
        tothrouf = false;
      end;
    end;
    if (StockMovp.OKFlag!=0) then begin
      fromthrouf = true;
      tof = true;
      if (RecordValid(prevStockMovp)) then begin
        if (prevStockMovp.OKFlag!=0) then begin
          fromthrouf = false;
          tof = false;
        end;
      end;
    end;
  end;

//StopAlert("fromf " & fromf  & " tof " & tof & " fromsendf " & fromsendf & " tothrouf " & tothrouf & " fromthrouf " & fromthrouf);
  if (fromf==false) and (fromsendf==false) and (tof==false) and (tothrouf==false) and (fromthrouf==false) then begin
    goto LStockMovUpdateItemHist;
  end;
  fromlocation = frlocation;
  if (nonblank(StockMovp.ThrouLocation)) then begin
    fromlocation = StockMovp.ThrouLocation;
  end;
  BlockLoad(MSb);
  rwcnt = MatRowCnt(StockMovp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockMovp,i,StockMovrw);
    ReadFirstItem(StockMovrw.ArtCode,INr,true,false);
    if (fromsendf) then begin
      if (StockMovrw.SentQuant!=0) then begin
        if (usetmpstkf) then begin
          StockMovUpdateItemHistory_Out2(StockMovp,frlocation,MSb,SNrb,StockMovrw,true,i,INr,TSr,usetmpstkf);
        end else begin
          StockMovUpdateItemHistory_Out(StockMovp,frlocation,MSb,SNrb,StockMovrw,true,i,INr);
        end;
      end;
    end else begin
      if (fromf) then begin
        if (StockMovrw.Quant!=0) then begin
          if (usetmpstkf) then begin
            StockMovUpdateItemHistory_Out2(StockMovp,frlocation,MSb,SNrb,StockMovrw,false,i,INr,TSr,usetmpstkf);
          end else begin
            StockMovUpdateItemHistory_Out(StockMovp,frlocation,MSb,SNrb,StockMovrw,false,i,INr);
          end;
        end;
      end;
    end;
    if (tothrouf) then begin
      if (StockMovrw.SentQuant!=0) then begin
        if (usetmpstkf) then begin
          StockMovUpdateItemHist_In2(StockMovp,frlocation,StockMovp.ThrouLocation,MSb,SNrb,StockMovrw,true,i,INr,TSr,usetmpstkf);
        end else begin
          StockMovUpdateItemHist_In(StockMovp,frlocation,StockMovp.ThrouLocation,MSb,SNrb,StockMovrw,true,i,INr);
        end;
      end;
    end;
    if (fromthrouf) then begin
      if (StockMovrw.Quant!=0) then begin
        if (usetmpstkf) then begin
          StockMovUpdateItemHistory_Out2(StockMovp,StockMovp.ThrouLocation,MSb,SNrb,StockMovrw,false,i,INr,TSr,usetmpstkf);
        end else begin
          StockMovUpdateItemHistory_Out(StockMovp,StockMovp.ThrouLocation,MSb,SNrb,StockMovrw,false,i,INr);
        end;
      end;
    end;
    if (tof) then begin
      if (StockMovrw.Quant!=0) then begin
        if (usetmpstkf) then begin
          StockMovUpdateItemHist_In2(StockMovp,fromlocation,tolocation,MSb,SNrb,StockMovrw,false,i,INr,TSr,usetmpstkf);
        end else begin
          StockMovUpdateItemHist_In(StockMovp,fromlocation,tolocation,MSb,SNrb,StockMovrw,false,i,INr);
        end;
      end;
    end;
  end;
LStockMovUpdateItemHist:;
  return;
end;

global
updating procedure StockMovUpdateItemHist(record StockMovVc StockMovp,record StockMovVc prevStockMovp)
begin
  record TempStockVc TSr;
  
  StockMovUpdateItemHist2(StockMovp,prevStockMovp,TSr,false);
  return;
end;

updating procedure StockTakeRowUpdateItemHist(record StockTakeVc StockTakep,string loc2,row StockTakeVc StockTakerw,Integer i,val qty,string serialnr,record INVc INr,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record CostAccBlock CAb;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  row TempStockVc TSrw;

  BlockLoad(CAb);
  RecordNew(IHr);
  IHr.ArtCode = StockTakerw.ArtCode;
  IHr.Variety = "";
  if (ReadFirstItem(StockTakerw.ArtCode,INr,false,false)) then begin
    if (StockTakerw.ArtCode!=INr.Code) then begin
      IHr.Variety = right(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(INr.Code));
      IHr.ArtCode = INr.Code;
    end;
  end;
  IHr.Location = loc2;
  if (StockTakep.SetStockValue==0) then begin
    IHr.FileName = "StockTakeVc";
    IHr.StockAffectf = 0;
  end else begin
    IHr.FileName = "AAAStockTakeVc";
    IHr.StockAffectf = 1;
  end;
  IHr.TransNr = StockTakep.SerNr;
  IHr.TransDate = StockTakep.TransDate;
  IHr.FIFODate = StockTakep.TransDate;
  IHr.Qty = qty;
  IHr.Qty2 = CalculateQty2(IHr.Qty,StockTakerw.Coefficient);
  IHr.Row = i;
  IHr.RemQty = blankval;
  IHr.Source = -1;
  IHr.TotCostPrice = blankval;
  IHr.RemCostPrice = blankval;
  IHr.SerialNr = serialnr;

  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin
  end;
  if (usetmpstkf) then begin
    FindTempStockRow(IHr.Row,IHr.ArtCode,false,TSr,TSrw);
    IHr.PrimaryCostModel = TSrw.PrimaryCostModel;
    IHr.QueuedCostModel = TSrw.QueuedCostModel;
    IHr.ItemType = TSrw.ItemType;
    IHr.FIFOPerSerialNr = TSrw.FIFOPerSerialNr;
    IHr.FIFOPerLocation = TSrw.FIFOPerLocation;
    IHr.NoNLCostOnShip = TSrw.NoNLCostOnShip;
    IHr.WAPerLocation = TSrw.WAPerLocation;
    IHr.WABase2 = TSrw.WABase2;
    IHr.UpdWeightAvFromRet = TSrw.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = TSrw.UpdWeightAvFromRetPU;
  end else begin
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    IHr.PrimaryCostModel = primary;
    IHr.QueuedCostModel = queuecostmodel;
    IHr.ItemType = INr.ItemType;
    IHr.FIFOPerSerialNr = GetFIFOPerSerialNr(INr,ITr,CAb);
    IHr.FIFOPerLocation = FIFOPerLocation(INr,ITr,CAb);
    IHr.NoNLCostOnShip = CAb.NoNLCostOnShip;
    IHr.WAPerLocation = WAPerLocation(INr,ITr,CAb);
    IHr.WABase2 = CAb.WABase2;
    IHr.UpdWeightAvFromRet = CAb.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = CAb.UpdWeightAvFromRetPU;
  end;
  IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");    
  if (RecordStore(IHr,true)) then begin end;;
  return;
end;

global
updating procedure StockTakeUpdateItemHist2(record StockTakeVc StockTakep,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record INVc INr;
  row StockTakeVc StockTakerw;
  Integer rwcnt,i,j;
  Boolean save;
  string 255 location;
  string 255 loc2;
  record SHVc SHr;
  val t;
  record MainStockBlock MSb;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty;
  
  BlockLoad(SNrb);
  BlockLoad(MSb);
  location = StockTakep.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(StockTakep);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockTakep,i,StockTakerw);
    loc2 = StockTakerw.Location;
    if (blank(loc2)) then begin
      loc2 = location;
    end;
    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
      qty = blankval;
      serialnr = FirstInRange(StockTakerw.SerialNr,60);
      while (nonblank(serialnr)) begin
        StockTakeRowUpdateItemHist(StockTakep,loc2,StockTakerw,i,1.00,serialnr,INr,TSr,usetmpstkf);
        qty = qty + 1;
        serialnr = NextSerialNumber(StockTakerw.ArtCode,serialnr,SNrb);
        if (qty>=StockTakerw.Qty) then begin serialnr = ""; end;
      end;
    end else begin          
      StockTakeRowUpdateItemHist(StockTakep,loc2,StockTakerw,i,StockTakerw.Qty,StockTakerw.SerialNr,INr,TSr,usetmpstkf);
    end;
  end;
  return;
end;

global
updating procedure StockTakeUpdateItemHist(record StockTakeVc StockTakep)
begin
  record TempStockVc TSr;
  
  StockTakeUpdateItemHist2(StockTakep,TSr,false);
  return;
end;

global
updating procedure StockTakeRemoveItemHist(record StockTakeVc StockTakep)
begin
  record ItemHistVc IHr;
  Boolean foundf;
  
  foundf = true;
  IHr.FileName = "StockTakeVc";
  IHr.TransNr = StockTakep.SerNr;
  while (LoopKey("FNTransNr",IHr,2,foundf)) begin
    if (IHr.FileName!="StockTakeVc") then begin
      foundf = false;
    end;
    if (IHr.TransNr!=StockTakep.SerNr) then begin
      foundf = false;
    end;
    if (foundf) then begin
      RecordRemove(IHr);
      StepBack(IHr);
    end;
  end;
  return;
end;

global
updating procedure WSUpdateItemHistory2(record WSVc WSp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  row WSVc WSrw;
  row SHVc SH2rw;
  Integer rwcnt,i,j;
  Integer shrwcnt;
  string 255 thelocation;
  Boolean isstruct;
  record SHVc RecSHr;
  record MainStockBlock MSb;
  record INVc INr;
  
  if (WSp.UpdStockFlag==0) then begin
    goto LWSUpdateItemHistory;
  end;
  BlockLoad(MSb);
  thelocation = WSp.Location;
  if (blank(thelocation)) then begin
    thelocation = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (ReadFirstItem(WSrw.ArtCode,INr,false,false)) then begin
      if (INr.ItemType==0 or INr.ItemType==3) then begin goto L22WSUpdateItemHistory; end;
    end;
    isstruct = false;
    if (WSrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
      isstruct = ExpandStructItem(WSrw.ArtCode,WSrw.Recepy,WSrw.Quant,RecSHr);
    end;
    if (isstruct==false) then begin
      StoreItemHistory_Out(MSb,WSrw.ArtCode,WSrw.SerialNr,thelocation,"WSVc",WSp.TransDate,WSrw.Quant,WSrw.Coefficient,WSrw.FIFORowVal,WSp.SerNr,i,1,WSrw.PosCode,TSr,usetmpstkf);
    end else begin 
      if (nonblank(WSrw.Recepy)) then begin
        LockRecipe(WSrw.Recepy);
      end;    
      shrwcnt = MatRowCnt(RecSHr);
      for (j=0;j<shrwcnt;j=j+1) begin
        MatRowGet(RecSHr,j,SH2rw);
        StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",thelocation,"WSVc",WSp.TransDate,SH2rw.Ship,SH2rw.Coefficient,WSrw.FIFORowVal,WSp.SerNr,i,1,WSrw.PosCode,TSr,usetmpstkf);
      end;
    end;
L22WSUpdateItemHistory:;
  end;
LWSUpdateItemHistory:;  
  return;
end;

global
updating procedure WSUpdateItemHistory(record WSVc WSp)
begin
  record TempStockVc TSr;

  WSUpdateItemHistory2(WSp,TSr,false);
  return;
end;

global
updating procedure ProdUpdateItemHistory2(record ProdVc Prodp,record ProdVc Prod2p,record TempStockVc TSr,Boolean usetmpstkf)
begin
  row ProdVc Prodrw;
  string 255 location;
  record MainStockBlock MSb;
  Integer rwcnt,i;
  record SHVc SHr;
  Boolean intostockf,outofstockf;
  val q;

  if (nonblank(Prodp.Routing)) then begin
    goto LProdUpdateItemHistory;
  end;
  switch (Prodp.PRStatusFlag) begin
    case kPRStatusFinished:
      outofstockf = true;
      intostockf = true;
    case kPRStatusFinishedandDiscarded:
      outofstockf = true;
      intostockf = false;
  end;
/*
  if (Prodp.PRStatusFlag==2) then begin
    outofstockf = true;
  end;
  if (RecordValid(Prod2p)) then begin
    switch (Prod2p.PRStatusFlag) begin
      case 0:
        if (Prodp.PRStatusFlag==3) or (Prodp.PRStatusFlag==5) then begin
          outofstockf = true;
          intostockf = true;
        end;
      case 2:
        if (Prodp.PRStatusFlag==3) or (Prodp.PRStatusFlag==5) then begin
          intostockf = true;
        end;
    end;
  end else begin
    if (Prodp.PRStatusFlag==3) or (Prodp.PRStatusFlag==5) then begin
      outofstockf = true;
      intostockf = true;
    end;
  end;
*/
  BlockLoad(MSb);
  location = Prodp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;  
  rwcnt = MatRowCnt(Prodp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    if (outofstockf) then begin      
      switch (Prodp.RowsHoldActualQty) begin
        case 1: q = Prodrw.InQty;
        otherwise q = Prodp.Qty*Prodrw.InQty;
      end;      
      if (q!=0) then begin
        if (q>0) then begin
          UpdateBatchBestBefore(Prodrw.Item,Prodrw.Comment,Prodrw.SerialNr,Prodp.ProdDate,Prodrw.BestBefore,Prodrw.UnitXval,Prodrw.UnitYval,Prodrw.UnitZval,0,0,true,Prodrw.SuppSerialNr,Prodrw.MajStoneDet,Prodrw.Colour,Prodrw.Clarity,Prodrw.Cert,Prodrw.MinStoneDet,Prodrw.Metal,Prodrw.RowWeight,Prodrw.Size,Prodrw.Length,Prodrw.WatchBrand,Prodrw.StyleName,Prodrw.WatchMetal,Prodrw.Movement,Prodrw.BrcStr,Prodrw.Gender,Prodrw.Other,Prodrw.Other2);
          StoreItemHistory_Out(MSb,Prodrw.Item,Prodrw.SerialNr,location,"ProdVc",Prodp.ProdDate,q,Prodrw.Coefficient,q*Prodrw.ItemCost,Prodp.SerNr,i,1,Prodrw.PosCode,TSr,usetmpstkf); // StartDate??
        end else begin
          StoreItemHistory_In(MSb,Prodrw.Item,Prodrw.SerialNr,location,"ProdVc",Prodp.ProdDate,Prodp.ProdDate,-q,Prodrw.Coefficient,q*Prodrw.ItemCost,Prodp.SerNr,i,1,Prodrw.PosCode,"",TSr,usetmpstkf);
        end;
      end;
    end;
    if (intostockf) then begin      
      switch (Prodp.RowsHoldActualQty) begin
        case 1: q = Prodrw.OutQty;
        otherwise q = Prodp.Qty*Prodrw.OutQty;
      end;  
      if (q!=0) then begin
        if (q>0) then begin
          if ((nonblankdate(Prodrw.BestBefore)) or (Prodrw.UnitXval==0) or (nonblank(Prodrw.SuppSerialNr)) or (nonblank(Prodrw.MajStoneDet)) or (nonblank(Prodrw.Colour)) or (nonblank(Prodrw.Clarity)) or (nonblank(Prodrw.Cert)) or (nonblank(Prodrw.MinStoneDet)) or (nonblank(Prodrw.Metal)) or (nonblank(Prodrw.RowWeight)) or (nonblank(Prodrw.Size)) or (nonblank(Prodrw.Length)) or (nonblank(Prodrw.WatchBrand)) or (nonblank(Prodrw.StyleName)) or (nonblank(Prodrw.WatchMetal)) or (nonblank(Prodrw.Movement)) or (nonblank(Prodrw.BrcStr)) or (nonblank(Prodrw.Gender)) or (nonblank(Prodrw.Other)) or (nonblank(Prodrw.Other2))) then begin
            UpdateBatchBestBefore(Prodrw.Item,Prodrw.Comment,Prodrw.SerialNr,Prodp.ProdDate,Prodrw.BestBefore,Prodrw.UnitXval,Prodrw.UnitYval,Prodrw.UnitZval,0,0,false,Prodrw.SuppSerialNr,Prodrw.MajStoneDet,Prodrw.Colour,Prodrw.Clarity,Prodrw.Cert,Prodrw.MinStoneDet,Prodrw.Metal,Prodrw.RowWeight,Prodrw.Size,Prodrw.Length,Prodrw.WatchBrand,Prodrw.StyleName,Prodrw.WatchMetal,Prodrw.Movement,Prodrw.BrcStr,Prodrw.Gender,Prodrw.Other,Prodrw.Other2);
          end;
          StoreItemHistory_In(MSb,Prodrw.Item,Prodrw.SerialNr,location,"ProdVc",Prodp.ProdDate,Prodp.ProdDate,q,Prodrw.Coefficient,q*Prodrw.ItemCost,Prodp.SerNr,i,1,Prodrw.PosCode,"",TSr,usetmpstkf);
        end else begin
          StoreItemHistory_Out(MSb,Prodrw.Item,Prodrw.SerialNr,location,"ProdVc",Prodp.ProdDate,-q,Prodrw.Coefficient,q*Prodrw.ItemCost,Prodp.SerNr,i,1,Prodrw.PosCode,TSr,usetmpstkf); // StartDate??
        end;
      end;
    end;
  end;
LProdUpdateItemHistory:;  
  return;
end;

global
updating procedure ProdUpdateItemHistory(record ProdVc Prodp,record ProdVc Prod2p)
begin
  record TempStockVc TSr;

  ProdUpdateItemHistory2(Prodp,Prod2p,TSr,false);
  return;
end;


global
updating procedure ProdOperationUpdateItemHistory2(record ProdOperationVc ProdOpr,record TempStockVc TSr,Boolean usetmpstkf)
begin
  row ProdOperationVc ProdOprw;
  string 255 location;
  record MainStockBlock MSb;
  Integer rwcnt,i;
  Boolean intostockf,outofstockf;
  val q;
  val UnitXval,UnitYval,UnitZval;
  record INVc INr;

  switch (ProdOpr.PRStatusFlag) begin
    case 3:
      outofstockf = true;
      intostockf = true;
    case 5:
      outofstockf = true;
      intostockf = false;
  end;
  BlockLoad(MSb);
  location = ProdOpr.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;  
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin end;
    if (INr.ItemType==1) then begin
      if (outofstockf) then begin
        if (nonblank(ProdOprw.SerialNr)) then begin
          if (ProdOprw.InQty==0) then begin
            if ((nonblankdate(ProdOprw.BestBefore)) or (UnitXval!=0)) then begin
              UpdateBatchBestBefore(ProdOprw.Item,ProdOprw.Comment,ProdOprw.SerialNr,ProdOpr.ProdDate,ProdOprw.BestBefore,UnitXval,UnitYval,UnitZval,0,0,false,"","","","","","","","","","","","","","","","","","");
            end;
          end;
        end;
      end;
      if (outofstockf) then begin      
        switch (ProdOpr.RowsHoldActualQty) begin
          case 1: q = ProdOprw.InQty;
          otherwise q = ProdOpr.Qty*ProdOprw.InQty;
        end;      
        if (q!=0) then begin
          if (q>0) then begin
            StoreItemHistory_Out(MSb,ProdOprw.Item,ProdOprw.SerialNr,location,"ProdOperationVc",ProdOpr.ProdDate,q,ProdOprw.Coefficient,q*ProdOprw.ItemCost,ProdOpr.SerNr,i,1,ProdOprw.PosCode,TSr,usetmpstkf); // StartDate??
          end else begin
            StoreItemHistory_In(MSb,ProdOprw.Item,ProdOprw.SerialNr,location,"ProdOperationVc",ProdOpr.ProdDate,ProdOpr.ProdDate,-q,ProdOprw.Coefficient,q*ProdOprw.ItemCost,ProdOpr.SerNr,i,1,ProdOprw.PosCode,"",TSr,usetmpstkf);
          end;
        end;
      end;
      if (intostockf) then begin     
        switch (ProdOpr.RowsHoldActualQty) begin
          case 1: q = ProdOprw.OutQty;
          otherwise q = ProdOpr.Qty*ProdOprw.OutQty;
        end;      
        if (q!=0) then begin
          if (q>0) then begin
            StoreItemHistory_In(MSb,ProdOprw.Item,ProdOprw.SerialNr,location,"ProdOperationVc",ProdOpr.ProdDate,ProdOpr.ProdDate,q,ProdOprw.Coefficient,q*ProdOprw.ItemCost,ProdOpr.SerNr,i,1,ProdOprw.PosCode,"",TSr,usetmpstkf);
          end else begin
            StoreItemHistory_Out(MSb,ProdOprw.Item,ProdOprw.SerialNr,location,"ProdOperationVc",ProdOpr.ProdDate,-q,ProdOprw.Coefficient,q*ProdOprw.ItemCost,ProdOpr.SerNr,i,1,ProdOprw.PosCode,TSr,usetmpstkf); // StartDate??
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure ProdOperationUpdateItemHistory(record ProdOperationVc ProdOpr)
begin
  record TempStockVc TSr;
   
  ProdOperationUpdateItemHistory2(ProdOpr,TSr,false);
  return;  
end;

global
updating procedure RetPUUpdateItemHist2(record RetPUVc RetPUp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row RetPUVc RetPUrw;
  Integer rwcnt,i;
  string 10 location;
  
  BlockLoad(MSb);
  BlockLoad(CAb);
  rwcnt = MatRowCnt(RetPUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    location = RetPUrw.Location;
    if (blank(location)) then begin
      location = RetPUp.Location;
    end;
    if (blank(location)) then begin
      location = MSb.MainStock;
    end;
    RetPUStoreItemHistory_Out(MSb,CAb,RetPUp,RetPUrw,i,1,TSr,usetmpstkf);    
  end;
  return;
end;

global
updating procedure RetPUUpdateItemHist(record RetPUVc RetPUp)
begin
  record TempStockVc TSr;

  RetPUUpdateItemHist2(RetPUp,TSr,false);
  return;
end;


// This function should be much easier if someone hadn't started using the OrdRow field for rows from Other registers...
// So... Beginning is easy, if update stock flag is set, rows Not update stock flag is NOT set (phew)
// End is weirder. If OrdRow is blank or Invoice comes from a Quotation, it should update stock
// It should care about OrderNr in the header, but then we get problems because of old data.
global
function Boolean ShouldInvoiceRowUpdateStock(record IVVc IVp,row IVVc IVrw)
begin
  Boolean res;
  
  if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
    res = (IVp.UpdStockFlag!=0) and ((IVrw.NotUpdStockFlag==0) and (IVrw.ovst==0)) and ((IVrw.OrdRow==-1) or (IVp.QTNr!=-1));
  end else begin
    res = (IVp.UpdStockFlag!=0) and (IVrw.NotUpdStockFlag==0) and (IVrw.ovst==0);
  end;
  ShouldInvoiceRowUpdateStock = res;
  return;
end;

global
updating procedure IVUpdateItemHist2(record IVVc IVp,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  Boolean isstruct;
  record SHVc recSHr;
  Integer i,rwcnt;
  Integer j,shrwcnt;
  Integer RetFIFOQue;
  row IVVc IVrw;
  row SHVc SH2rw;
  string 255 location;
  record INVc INr;
  val p;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  Date td;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val serqty;

//  if (XSUpdateINrs(IVp)) then begin  //INRS , is it needed at all ?
//    goto LIVUpdateItemHist;
//  end;

  BlockLoad(MSb);
  BlockLoad(CAb);
  BlockLoad(SNrb);
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
//    if (IVrw.NotUpdStockFlag==0) then begin
    if (true) then begin//we need item hist Vc , not upd stock
    location = IVrw.Location;
    if (blank(location)) then begin
      location = IVp.Location;
    end;
    if (blank(location)) then begin
      location = MSb.MainStock;
    end;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        //goto LkInvoiceRowTypeNormal; //nk otherwise we loop recSHr x times, where x - number of items in recepy
        IVUpdateStructureItemHist(IVp,i,location,IVrw.ArtCode,IVrw.Quant,TSr,usetmpstkf);
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
        if (ShouldInvoiceRowUpdateStock(IVp,IVrw)) then begin
          RecordNew(recSHr);
          isstruct = ExpandStructItem(IVrw.ArtCode,IVrw.Recepy,IVrw.Quant,recSHr);
          if (isstruct==false) then begin        
            if (ReadFirstItem(IVrw.ArtCode,INr,true,false)) then begin end;
            GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
            if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
              RetFIFOQue = 0;
              if (IVp.CredInv>0) and (IVrw.CreditedRow>=0) then begin
                RetFIFOQue = CAb.RetFIFOQue;
              end;
              switch (RetFIFOQue) begin
                case 0: 
                  p = IVrw.FIFO;
                  if (p==0) then begin
                    if (IVp.CredInv<=0) then begin
                      p = IVrw.BasePrice;
                      if (p==0) then begin
                        p = INr.InPrice;
                      end;
                    end;
                  end;
                  if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
                    serqty = blankval;
                    serialnr = FirstInRange(IVrw.SerialNr,60);
                    while (nonblank(serialnr)) begin
                      StoreItemHistory_In(MSb,IVrw.ArtCode,serialnr,location,"IVVc",IVp.TransDate,IVp.TransDate,1.00,IVrw.Coefficient,1.00*p,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                      serqty = serqty + 1;
                      serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                      if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
                    end;
                  end else begin
                    StoreItemHistory_In(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.Quant*p,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                  end;
                case 1: 
                  StoreItemHistory_In_CreditInvoice(primary,CAb,MSb,IVp,IVrw,i,INr,TSr,usetmpstkf);
              end;
            end else begin
              if (IVp.Invalid!=0) then begin
                switch (CAb.RetFIFOQue) begin
                  case 0: 
                    InvalidateItemHistVc("IVVc",IVp.SerNr,i);
/*                    
                    td = IVp.InvalidDate;
                    if (blankdate(td)) then begin
                      td = IVp.TransDate;
                    end;
*/                    
                    td = IVp.TransDate;
                    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
                      serqty = blankval;
                      serialnr = FirstInRange(IVrw.SerialNr,60);
                      while (nonblank(serialnr)) begin
                        StoreItemHistory_In(MSb,IVrw.ArtCode,serialnr,location,"IVVc",td,td,1.00,IVrw.Coefficient,1.00*IVrw.FIFO,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                        serqty = serqty + 1;
                        serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                        if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
                      end;
                    end else begin
                      StoreItemHistory_In(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",td,td,IVrw.Quant,IVrw.Coefficient,IVrw.Quant*IVrw.FIFO,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                    end;
                end;
              end else begin               
                if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
                  serqty = blankval;
                  serialnr = FirstInRange(IVrw.SerialNr,60);
                  while (nonblank(serialnr)) begin
                    StoreItemHistory_Out(MSb,IVrw.ArtCode,serialnr,location,"IVVc",IVp.TransDate,1.00,IVrw.Coefficient,IVrw.FIFORowVal/IVrw.Quant,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                    serqty = serqty + 1;
                    serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                    if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
                  end;
                end else begin
                  StoreItemHistory_Out(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.FIFORowVal,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                end;
              end;
            end;
          end else begin
            if (nonblank(IVrw.Recepy)) then begin
              LockRecipe(IVrw.Recepy);
            end;    
            shrwcnt = MatRowCnt(recSHr);
            for (j=0;j<shrwcnt;j=j+1) begin
              MatRowGet(recSHr,j,SH2rw);
              IVUpdateStructureItemHist(IVp,i,location,SH2rw.ArtCode,SH2rw.Ship,TSr,usetmpstkf);

              /*
              if (ReadFirstItem(SH2rw.ArtCode,INr,true,false)) then begin end;
              GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
              if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
                if (IVp.CredInv>0) and (IVrw.CreditedRow>=0) then begin
                  RetFIFOQue = CAb.RetFIFOQue;
                end else begin
                  RetFIFOQue = 0;
                end;
                switch (RetFIFOQue) begin
                  case 0:                              
                    p = CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,SH2rw.ArtCode,SH2rw.Ship,IVrw.stp,0);
                    if (p==0) then begin
                      if (IVp.CredInv<=0) then begin
                        p = INr.InPrice*SH2rw.Ship;
                      end;
                    end;
                    StoreItemHistory_In(MSb,SH2rw.ArtCode,"",location,"IVVc",IVp.TransDate,IVp.TransDate,SH2rw.Ship,SH2rw.Coefficient,p,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                  case 1: 
//                  StoreItemHistory_In_CreditInvoice_InQueComp(MSb,IVp,IVrw,i);
                end;
              end else begin
                if (IVp.Invalid!=0) then begin
                  switch (CAb.RetFIFOQue) begin
                    case 0: 
                      InvalidateItemHistVc("IVVc",IVp.SerNr,i);
                      StoreItemHistory_In(MSb,SH2rw.ArtCode,"",location,"IVVc",IVp.TransDate,IVp.TransDate,SH2rw.Ship,SH2rw.Coefficient,CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,SH2rw.ArtCode,SH2rw.Ship,IVrw.stp,0),IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                  end;
                end else begin
                  StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",location,"IVVc",IVp.TransDate,SH2rw.Ship,SH2rw.Coefficient,IVrw.FIFORowVal,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                end;
              end;
              */
            end;
          end;
        end else begin
          if (IVrw.ovst==0) then begin
          if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
            if (IVp.UpdStockFlag==0) then begin
              StoreItemHistory_In(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.Quant*IVrw.FIFO,IVp.SerNr,i,0,IVrw.PosCode,"",TSr,usetmpstkf);
            end else begin
              StoreItemHistory_In(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.Quant*IVrw.FIFO,IVp.SerNr,i,0,IVrw.PosCode,"",TSr,usetmpstkf);
            end;
          end else begin
            StoreItemHistory_Out(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.FIFORowVal,IVp.SerNr,i,0,IVrw.PosCode,TSr,usetmpstkf);
          end;
          end;
        end;
      case kInvoiceRowTypeCorrection:
        if (ShouldInvoiceRowUpdateStock(IVp,IVrw)) then begin
          RecordNew(recSHr);
          if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
            isstruct = ExpandStructItem(IVrw.ArtCode,IVrw.Recepy,IVrw.Quant,recSHr);
            if (isstruct==false) then begin        
              if (IVp.Invalid!=0) then begin
                switch (CAb.RetFIFOQue) begin
                  case 0: 
                    InvalidateItemHistVc("IVVc",IVp.SerNr,i);
                    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
                      serqty = blankval;
                      serialnr = FirstInRange(IVrw.SerialNr,60);
                      while (nonblank(serialnr)) begin
                        StoreItemHistory_In(MSb,IVrw.ArtCode,serialnr,location,"IVVc",IVp.TransDate,IVp.TransDate,1.00,IVrw.Coefficient,1.00*IVrw.FIFO,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                        serqty = serqty + 1;
                        serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                        if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
                      end;
                    end else begin
                      StoreItemHistory_In(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.Quant*IVrw.FIFO,IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                    end;
                end;
              end else begin
                if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
                  serqty = blankval;
                  serialnr = FirstInRange(IVrw.SerialNr,60);
                  while (nonblank(serialnr)) begin
                    StoreItemHistory_Out(MSb,IVrw.ArtCode,serialnr,location,"IVVc",IVp.TransDate,1.00,IVrw.Coefficient,IVrw.FIFORowVal/IVrw.Quant,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                    serqty = serqty + 1;
                    serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                    if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
                  end;
                end else begin
                  StoreItemHistory_Out(MSb,IVrw.ArtCode,IVrw.SerialNr,location,"IVVc",IVp.TransDate,IVrw.Quant,IVrw.Coefficient,IVrw.FIFORowVal,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                end;
              end;
            end else begin
              if (nonblank(IVrw.Recepy)) then begin
                LockRecipe(IVrw.Recepy);
              end;    
              shrwcnt = MatRowCnt(recSHr);
              for (j=0;j<shrwcnt;j=j+1) begin
                MatRowGet(recSHr,j,SH2rw);
                if (IVp.Invalid!=0) then begin
                  switch (CAb.RetFIFOQue) begin
                    case 0: 
                      InvalidateItemHistVc("IVVc",IVp.SerNr,i);
                      StoreItemHistory_In(MSb,SH2rw.ArtCode,"",location,"IVVc",IVp.TransDate,IVp.TransDate,SH2rw.Ship,SH2rw.Coefficient,CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,SH2rw.ArtCode,SH2rw.Ship,IVrw.stp,0),IVp.SerNr,i,1,IVrw.PosCode,"",TSr,usetmpstkf);
                  end;
                end else begin
                  StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",location,"IVVc",IVp.TransDate,SH2rw.Ship,SH2rw.Coefficient,IVrw.FIFORowVal,IVp.SerNr,i,1,IVrw.PosCode,TSr,usetmpstkf);
                end;
              end;
            end;
          end;
        end;
    end;
    end;
  end;
 LIVUpdateItemHist:; 
  return;
end;

global
updating procedure IVUpdateItemHist(record IVVc IVp)
begin
  record TempStockVc TSr;
  
  IVUpdateItemHist2(IVp,TSr,false);
  return;
end;

global
updating procedure IVCashUpdateItemHist2(record IVCashVc IVCashp,Integer stockaffectf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record SHVc recSHr;
  row IVCashVc IVCashrw;
  row SHVc SH2rw;
  Integer rwcnt,i,j;
  Integer shrwcnt;
  string 10 location;
  Boolean isstruct;
  
  BlockLoad(MSb);
  location = IVCashp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(IVCashp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashp,i,IVCashrw);
    isstruct = false;
    if (IVCashrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
      isstruct = ExpandStructItem(IVCashrw.ArtCode,IVCashrw.Recepy,IVCashrw.Quant,recSHr);
    end;
    if (isstruct==false) then begin
      if (stockaffectf==0) then begin
        if (nonblank(IVCashrw.SerialNr)) then begin
          StoreItemHistory_Out(MSb,IVCashrw.ArtCode,IVCashrw.SerialNr,location,"IVCashVc",IVCashp.TransDate,IVCashrw.Quant,IVCashrw.Coefficient,IVCashrw.FIFORowVal,IVCashp.SerNr,i,stockaffectf,IVCashrw.PosCode,TSr,usetmpstkf);
        end;
      end else begin
        StoreItemHistory_Out(MSb,IVCashrw.ArtCode,IVCashrw.SerialNr,location,"IVCashVc",IVCashp.TransDate,IVCashrw.Quant,IVCashrw.Coefficient,IVCashrw.FIFORowVal,IVCashp.SerNr,i,stockaffectf,IVCashrw.PosCode,TSr,usetmpstkf);
      end;
    end else begin 
      if (nonblank(IVCashrw.Recepy)) then begin
        LockRecipe(IVCashrw.Recepy);
      end;    
      shrwcnt = MatRowCnt(recSHr);
      for (j=0;j<shrwcnt;j=j+1) begin
        MatRowGet(recSHr,j,SH2rw);
        StoreItemHistory_Out(MSb,SH2rw.ArtCode,"",location,"IVCashVc",IVCashp.TransDate,SH2rw.Ship,SH2rw.Coefficient,IVCashrw.FIFORowVal,IVCashp.SerNr,i,stockaffectf,IVCashrw.PosCode,TSr,usetmpstkf);
      end;
    end;
  end;
  return;
end;

global
updating procedure IVCashUpdateItemHist(record IVCashVc IVCashp,Integer stockaffectf)
begin
  record TempStockVc TSr;

  IVCashUpdateItemHist2(IVCashp,stockaffectf,TSr,false);
  return;
end;
