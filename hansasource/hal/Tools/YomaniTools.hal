external procedure IVDClass_RefreshStringList(Integer,record IVVc);
external updating procedure IVDClassTouchScreenFinishButton();
external updating procedure IVCashDClassTouchScreenFinishButton();
external procedure IVCashDClass_RefreshStringList(Integer,record IVCashVc);
remote procedure IVCashSumup(var record IVCashVc,Boolean);
remote updating procedure StoreCredCardSlip_YomaniBanksys(string,val,string,string,string,string,string,string,LongInt,string,Integer,var record NotepadVc,var record NotepadVc);
external procedure LogAreaToFile(string,area);
external function string 50 TimeToString(time,string,boolean); 
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function Boolean FindLocalSerialPortDevice(Integer,LongInt,string,var record LSerialPortDeviceVc);


function Integer YomaniBanksys_ReadACK(Integer timeout,Integer cmdtype)
begin
  Integer res;
  Boolean waitf;
  LongInt currenttick,starttick,waitticks;
  string 255 response,c;
  
  res = 1;
  starttick = GetCurTick;
  waitticks = timeout*1000;//10 seconds
  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    response = response & c;
    switch (cmdtype) begin
      case CC_ENQ:     
        if (asc(c)==CC_ACK) then begin
          waitf = false;
          res = 0;
        end;    
    end;
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
  YomaniBanksys_ReadACK = res;
  return;
end;

function Integer YomaniBanksys_CalculateLRC(string CtrlSeq)
begin
  Integer i,res;
  
  res = 0;
  for (i=1;i<=len(CtrlSeq);i=i+1) begin
    res = BitXor(res,asc(Mid(CtrlSeq,i,1)));
  end;
  YomaniBanksys_CalculateLRC = res;
  return;
end;

function Integer YomaniBanksys_SendCommand(string CtrlSeq)
begin
  Integer res,noErr;
  
  res = noErr;
  if (OutComPort(0,CtrlSeq)==0) then begin
    res = 1;
  end;  
  YomaniBanksys_SendCommand = res;
  return;
end;

function Integer YomaniBanksys_IsTerminalActive()
begin
  Integer res,noErr;
  string 255 CtrlSeq; 
  Integer nrofmsgs;

  nrofmsgs = 1;
  while (nrofmsgs<=3) begin
    CtrlSeq = uchr(CC_ENQ);
    res = YomaniBanksys_SendCommand(CtrlSeq);
    if (res!=noErr) then begin
      goto LYomaniBanksys_IsTerminalActive;
    end;
    res = YomaniBanksys_ReadACK(10,CC_ENQ);
    if (res==noErr) then begin
      goto LYomaniBanksys_IsTerminalActive;
    end;
    nrofmsgs = nrofmsgs + 1;
  end;
LYomaniBanksys_IsTerminalActive:;  
  YomaniBanksys_IsTerminalActive = res;
  return;
end;

function Integer YomaniBanksys_TransactionRequestEx2(val v,string msg,string transactionid,string timestamp,var string SentCtrlSeq)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr; 

  CtrlSeq = uchr(CC_STX);
  CtrlSeq = CtrlSeq & "Y";
  switch (msg) begin
    case "Purchase":
      CtrlSeq = CtrlSeq & "0";
    case "Reversal":
      CtrlSeq = CtrlSeq & "2";
    case "Refund":
      CtrlSeq = CtrlSeq & "3";
  end;
  M4PadString(ValToString(v*100,M4UVal,"","",1),12,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  M4PadString(ValToString(0,M4UVal,"","",1),12,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  M4PadString(transactionid,5,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & "0";
  M4PadString(uchr(CC_FS),7,"0",false,tstr);
  CtrlSeq = CtrlSeq & tstr;
  if (blank(timestamp)) then begin
    tstr = DateToString(CurrentDate,"YYMMDD") & TimeToString(CurrentTime,"HHMMSS",false);
  end else begin
    tstr = timestamp;
  end;
  CtrlSeq = CtrlSeq & tstr;
  M4PadString("0",9,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & "0";
  CtrlSeq = CtrlSeq & "0";
  M4PadString("0",2,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & "978";  //EUR
  M4PadString("0",10,"0",true,tstr);
  CtrlSeq = CtrlSeq & tstr;
  CtrlSeq = CtrlSeq & uchr(CC_ETX);
  CtrlSeq = CtrlSeq & uchr(YomaniBanksys_CalculateLRC(CtrlSeq));  

  res = YomaniBanksys_SendCommand(CtrlSeq);
  if (res!=noErr) then begin
    goto LYomaniBanksys_TransactionRequestEx2;
  end;
  res = YomaniBanksys_ReadACK(10,CC_ENQ);
  if (res!=noErr) then begin
    goto LYomaniBanksys_TransactionRequestEx2;
  end;  
  SentCtrlSeq = CtrlSeq;
LYomaniBanksys_TransactionRequestEx2:;  
  YomaniBanksys_TransactionRequestEx2 = res;
  return;
end;

function Integer YomaniBanksys_ReadReply(var Area atransresult)
begin
  Integer res,noErr;
  string 255 CtrlSeq,tstr; 
  Boolean waitf,nextpartf;
  LongInt currenttick,starttick,waitticks;
  string 255 c;

  res = 1;
  starttick = GetCurTick;
  waitticks = 30*1000;//10 seconds
  waitf = true;
  while (waitf) begin
    currenttick = GetCurTick;

    c = ReadComPort(0,1);
    switch (asc(c)) begin
      case CC_STX:
      case CC_ETX:
        c = ReadComPort(0,1);//LRC
        if (nextpartf==false) then begin
          waitf = false;
          res = 0;
        end else begin
          YomaniBanksys_SendCommand(uchr(CC_ACK));
          MilliSleep(1000);
        end;
        nextpartf = false;
      case CC_RS:
        AddTextToArea(c,atransresult);
//last msg      
      case CC_ETB:
        nextpartf = true;
      case CC_FS:
      otherwise
        AddTextToArea(c,atransresult);
    end;
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
  YomaniBanksys_ReadReply = res;
  return;
end;

function Boolean YomaniBanksys_TransactionStatus(Integer ProcessingWn,Area aterminalreply,var string results)
begin
  Boolean waitf;
  string 255 c,result;
  string 255 tstr,tstr2;
  record RcVc RepSpec;

  results = "";
  waitf = true;
  c = GetStringFromArea(aterminalreply,1,1);
  switch (c) begin  //Phase
    case "0": tstr = USetStr(27370);
    case "1": tstr = USetStr(27371);
    case "2": tstr = USetStr(27372);
    case "3": tstr = USetStr(27373);
    case "4": tstr = USetStr(27374);
    case "5": tstr = USetStr(27375);
    case "6": tstr = USetStr(27376);
    case "7": tstr = USetStr(27377);
    case "8": tstr = USetStr(27378);
    case "A": tstr = USetStr(27379);
    case "B": tstr = USetStr(27380);
    case "C": tstr = USetStr(27381);
    case "Q": tstr = USetStr(27382);
    case "R": tstr = USetStr(27383);
  end;
  result = GetStringFromArea(aterminalreply,2,4);
  switch (result) begin  //Result
    case "0000": tstr2 = result & "  " & USetStr(27390);
    case "0005": tstr2 = result & "  " & USetStr(27391);
    case "0015": tstr2 = result & "  " & USetStr(27392);
    case "0018": tstr2 = result & "  " & USetStr(27393);
    case "0019": tstr2 = result & "  " & USetStr(27394);
    case "0019": tstr2 = result & "  " & USetStr(27394);
    case "1003":
      tstr2 = result;
      waitf = false;
    case "1004":
      tstr2 = result;
      waitf = false;
    case "1005":
      tstr2 = result;
      waitf = false;
    case "1006":
      tstr2 = result;
      waitf = false;
    case "1007":
      tstr2 = result;
      waitf = false;
    case "1008":
      tstr2 = result & "  " & USetStr(27395);
      waitf = false;
    case "1009":
      tstr2 = result & "  " & USetStr(27396);
      waitf = false;
    case "1012":
      tstr2 = result & "  " & USetStr(27397);
      waitf = false;
    case "2003":
      tstr2 = result & "  " & USetStr(27410);
      results = StringToInt(result);
      waitf = false;
    case "2004":
      tstr2 = result & "  " & USetStr(27411);
      waitf = false;
      results = StringToInt(result);
    case "2005":
      tstr2 = result & "  " & USetStr(27412);
      waitf = false;
      results = StringToInt(result);
    case "2006":
      tstr2 = result & "  " & USetStr(27413);
      waitf = false;
      results = StringToInt(result);
    otherwise 
      if (Left(result,1)=="9") then begin
        tstr2 = result;
        waitf = false;
        results = StringToInt(result);
      end else begin
        tstr2 = result;
      end;
  end;
  GetWindowRecord(ProcessingWn,RepSpec);
  PutWindowString(ProcessingWn,"Status",tstr);        
  PutWindowString(ProcessingWn,"Result",tstr2);        
  PutWindowString(ProcessingWn,"ExtraInfo",GetStringFromArea(aterminalreply,6,20)); 
  PutWindowRecord(ProcessingWn,RepSpec);
  HandleEvents;
  YomaniBanksys_TransactionStatus = waitf;
  return;
end;

global
updating function Integer YomaniBanksys_WaitForTransactionResult(Integer ProcessingWn,string paymode,string label,string transtype,string orgtransactionid,string orgtimestamp,string codepage,var string results)
begin
  Integer res,noErr,i,rownr;
  string 255 CtrlSeq,tstr; 
  Boolean waitf;
  LongInt currenttick,starttick,waitticks;
  string 255 c;
  Area aterminalreply,aterminalreply2;
  Area atransslip;
  Boolean resultreceivedf,CC_RSfound;
  record NotepadVc Noter;
  record NotepadVc merchantNoter;
  string 255 TransactionID,TransactionCertificate,CardType,timestamp,SettlementID;
  val amount;
  record IVVc IVr;
  row IVVc IVrw;
  record IVCashVc IVCashr;
  row IVCashVc IVCashrw;
  Integer mwn;
  string 255 FileName;
  LongInt TransNr;

  results = "";
  res = 1;
  mwn = MotherWindow(ProcessingWn);
  FileName = GetWindowFileName(mwn);
  waitticks = 100.00*1000.00;//100 seconds
  starttick = GetCurTick;
  waitf = true;
  while (waitf) begin
    SetAreaZeroSize(atransslip);
    SetAreaZeroSize(aterminalreply);
    SetAreaZeroSize(aterminalreply2);
    currenttick = GetCurTick;

    res = YomaniBanksys_ReadReply(aterminalreply);
    if (res!=noErr) then begin
      goto LYomaniBanksys_WaitForTransactionResult;
    end;    
    c = GetStringFromArea(aterminalreply,0,1);
    switch (c) begin
      case "2": //Status
        waitf = YomaniBanksys_TransactionStatus(ProcessingWn,aterminalreply,results);
        res = YomaniBanksys_SendCommand(uchr(CC_ACK));
      case "5": //Result
        GetAreaFromArea(aterminalreply,143,GetAreaLength(aterminalreply)-143,atransslip);  
        resultreceivedf = true;
        waitf = false;
        res = YomaniBanksys_SendCommand(uchr(CC_ACK));
//  LogAreaToFile("_aterminalreply.txt",aterminalreply);
//  LogAreaToFile("_atransslip.txt",atransslip);
    end;
    if ((currenttick-starttick)>waitticks) then begin
      waitf = false;
    end;
  end;
  if (resultreceivedf) then begin    
    CardType = GetStringFromArea(aterminalreply,3,1);
    SettlementID = GetStringFromArea(aterminalreply,5,2);
    TransactionCertificate = GetStringFromArea(aterminalreply,58,16);
    TransactionID = GetStringFromArea(aterminalreply,88,5);
    timestamp = GetStringFromArea(aterminalreply,105,12);
    amount = StringToVal(GetStringFromArea(aterminalreply,117,12),M40Val)/100;
    switch (transtype) begin
      case "Refund": amount = -amount;
      case "Reversal": amount = -amount;
    end;
    i = 0;
    while (i<=GetAreaLength(atransslip)) begin
      c = GetStringFromArea(atransslip,i,1);
      switch (asc(c)) begin
        case CC_RS:
          CC_RSfound = true;
        otherwise
          if (c==chr(10)) then begin
            if (CC_RSfound) then begin
              AddToText(chr(13) & chr(10),merchantNoter);
            end else begin
              AddToText(chr(13) & chr(10),Noter);
            end;
          end else begin
            if (CC_RSfound) then begin
              AddToText(ConvertStringFromCodePage(codepage,c),merchantNoter);
            end else begin
              AddToText(ConvertStringFromCodePage(codepage,c),Noter);
            end;
          end;
      end;
      i = i + 1;
    end;
    if (mwn>0) then begin
      CloseWindow(ProcessingWn);
      SelectWindow(mwn);
      DeselectWindow(mwn,true);
      switch (FileName) begin
        case "IVVc":
          GetWindowRecord(mwn,IVr);
          ClearRow(IVr,IVrw,kInvoiceRowTypeCreditCardPayment);  
          IVrw.Sum = amount;
          IVrw.AuthorizationCode = TransactionCertificate;
          IVrw.PayMode = paymode;
          IVCashrw.Spec = label;
          IVrw.CCTimestamp = timestamp;
          IVrw.CCTransID = TransactionID;
          rownr = MatRowCnt(IVr);
          MatRowPut(IVr,rownr,IVrw);
          PutWindowRecord(mwn,IVr);
          IVDClass_RefreshStringList(mwn,IVr);
          if (WindowDoOK(mwn,0)) then begin
          end;
          TransNr = IVr.SerNr;
        case "IVCashVc":
          GetWindowRecord(mwn,IVCashr);
          IVCashr.RecValue = blankval;
          IVCashr.RecValue2 = blankval;
          ClearRow(IVCashr,IVCashrw,kInvoiceRowTypeCreditCardPayment);  
          IVCashrw.Sum = amount;
          IVCashrw.AuthorizationCode = TransactionCertificate;
          IVCashrw.PayMode = paymode;
          IVCashrw.Spec = label;
          IVCashrw.CCTimestamp = timestamp;
          IVCashrw.CCTransID = TransactionID;
          rownr = MatRowCnt(IVCashr);
          MatRowPut(IVCashr,rownr,IVCashrw);
          IVCashSumup(IVCashr,true);
          PutWindowRecord(mwn,IVCashr);
          IVCashDClass_RefreshStringList(mwn,IVCashr);
          if (WindowDoOK(mwn,0)) then begin
          end;
          TransNr = IVCashr.SerNr;
      end;
      switch (transtype) begin
        case "Reversal":
          StoreCredCardSlip_YomaniBanksys(CardType,amount,TransactionID,TransactionCertificate,timestamp,SettlementID,orgtransactionid,orgtimestamp,TransNr,FileName,5,merchantNoter,Noter);
        otherwise
          StoreCredCardSlip_YomaniBanksys(CardType,amount,TransactionID,TransactionCertificate,timestamp,SettlementID,"","",TransNr,FileName,0,merchantNoter,Noter);
      end;
      switch (FileName) begin
        case "IVVc":
          if (IVr.RetValue>=0) then begin
            IVDClassTouchScreenFinishButton;
          end;
        case "IVCashVc":
          if (IVCashr.RetValue>=0) then begin
            IVCashDClassTouchScreenFinishButton;
          end;
      end;
    end;
  end else begin
    if (Left(results,1)=="9") then begin
      CloseWindow(ProcessingWn);
      SelectWindow(mwn);
    end;
  end;
LYomaniBanksys_WaitForTransactionResult:;  
  YomaniBanksys_WaitForTransactionResult = res;
  return;
end;

procedure YomaniAdditionalInformationRequired(string SentCtrlSeq,Integer ProcessingWn)
begin
  record RcVc RepSpec;
  Integer mwn,nwn;
  string 255 tstr,tstr2,tstr3;
  
  GetWindowRecord(ProcessingWn,RepSpec);  
  tstr = GetWindowString(ProcessingWn,"Status");
  tstr2 = GetWindowString(ProcessingWn,"Result");
  tstr3 = GetWindowString(ProcessingWn,"ExtraInfo");
  mwn = MotherWindow(ProcessingWn);
  CloseWindow(ProcessingWn);
  RepSpec.f12 = SentCtrlSeq;
  nwn = OpenWindow("CCPayYomaniAddInfoOClass",0,mwn,"","",RepSpec);
  DeselectWindow(nwn,false);
  PutWindowString(ProcessingWn,"Status",tstr);        
  PutWindowString(ProcessingWn,"Result",tstr2);        
  PutWindowString(ProcessingWn,"ExtraInfo",tstr3); 
  PutWindowRecord(ProcessingWn,RepSpec);
  return;
end;

updating function Integer YomaniBanksys_ProcessTransaction(string msg,val v,string paymode,string label,string transactionid,string timestamp,Integer ProcessingWn,string codepage,
                          var string SentCtrlSeq,var string results)
begin
  Integer res,noErr;
  
  res = YomaniBanksys_IsTerminalActive;
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransaction;
  end;
  res = YomaniBanksys_TransactionRequestEx2(v,msg,"","",SentCtrlSeq);
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransaction;
  end;
  res = YomaniBanksys_WaitForTransactionResult(ProcessingWn,paymode,label,msg,transactionid,timestamp,codepage,results);
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransaction;
  end;    
LYomaniBanksys_ProcessTransaction:;  
  YomaniBanksys_ProcessTransaction = res;
  return;
end;

global
updating procedure YomaniBanksys_Purchase(val v,string paymode,string label,Integer ProcessingWn)
begin
  record LocalMachineBlock LMb;  
  record LSerialPortDeviceVc LSPDr;
  Integer res,noErr;
  string 255 SentCtrlSeq,results,codepage;
  Boolean additionalinfof;

  BlockLoad(LMb);
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassCreditCardTerminal,kSerialPortDeviceModelCreditCardTerminalYomaniBanksys,LMb.LocalMachineCode,LSPDr)==false) then begin  
    goto LYomaniBanksys_PurchaseOut;
  end;  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)==0) then begin
    goto LYomaniBanksys_PurchaseOut;
  end;
  codepage = StringSetFromString(89,LSPDr.Codepage);
  SetComPortCodepage(codepage);
  res = YomaniBanksys_ProcessTransaction("Purchase",v,paymode,label,"","",ProcessingWn,codepage,SentCtrlSeq,results);
LYomaniBanksys_Purchase:;  
  res = CloseComPort(0);  
LYomaniBanksys_PurchaseOut:;  
  switch (results) begin
    case "2003": additionalinfof = true;
    case "2004": additionalinfof = true;
    case "2005": additionalinfof = true;
    case "2006": additionalinfof = true;
  end;
  if (additionalinfof) then begin
    YomaniAdditionalInformationRequired(SentCtrlSeq,ProcessingWn);
  end;
  return;
end;

global
updating procedure YomaniBanksys_Refund(val v,string paymode,string label,Integer ProcessingWn)
begin
  record LocalMachineBlock LMb;  
  record LSerialPortDeviceVc LSPDr;
  Integer wn,res,noErr;
  string 255 SentCtrlSeq,results,codepage;

  BlockLoad(LMb);
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassCreditCardTerminal,kSerialPortDeviceModelCreditCardTerminalYomaniBanksys,LMb.LocalMachineCode,LSPDr)==false) then begin  
    goto LYomaniBanksys_RefundOut;
  end;  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)==0) then begin
    goto LYomaniBanksys_RefundOut;
  end;
  codepage = StringSetFromString(89,LSPDr.Codepage);
  SetComPortCodepage(codepage);
  res = YomaniBanksys_ProcessTransaction("Refund",v,paymode,label,"","",ProcessingWn,codepage,SentCtrlSeq,results);
LYomaniBanksys_Refund:;  
  res = CloseComPort(0);  
LYomaniBanksys_RefundOut:;  
  return;
end;

global
updating procedure YomaniBanksys_Reversal(val v,string paymode,string label,string transactionid,string timestamp,Integer ProcessingWn)
begin
  record LocalMachineBlock LMb;  
  record LSerialPortDeviceVc LSPDr;
  Integer wn,res,noErr;
  string 255 SentCtrlSeq,results,codepage;

  BlockLoad(LMb);
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassCreditCardTerminal,kSerialPortDeviceModelCreditCardTerminalYomaniBanksys,LMb.LocalMachineCode,LSPDr)==false) then begin  
    goto LYomaniBanksys_ReversalOut;
  end;  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)==0) then begin
    goto LYomaniBanksys_ReversalOut;
  end;
  codepage = StringSetFromString(89,LSPDr.Codepage);
  SetComPortCodepage(codepage);
  res = YomaniBanksys_ProcessTransaction("Reversal",v,paymode,label,transactionid,timestamp,ProcessingWn,codepage,SentCtrlSeq,results);
LYomaniBanksys_Reversal:;  
  res = CloseComPort(0);  
LYomaniBanksys_ReversalOut:;  
  return;
end;

global
procedure YomaniBanksys_TransactionAbort()
begin
  string 255 CtrlSeq;
  Integer res;
  
  CtrlSeq = uchr(CC_STX);
  CtrlSeq = CtrlSeq & "72";
  CtrlSeq = CtrlSeq & uchr(CC_ETX);
  CtrlSeq = CtrlSeq & uchr(YomaniBanksys_CalculateLRC(CtrlSeq));  
  res = YomaniBanksys_SendCommand(CtrlSeq);
  Sleep(1);
//  YomaniBanksys_SendCommand(uchr(CC_ACK));
  return;
end;

global
procedure YomaniBanksys_AbortTransaction()
begin
  record LocalMachineBlock LMb;  
  record LSerialPortDeviceVc LSPDr;
  Integer res,noErr;

  BlockLoad(LMb);
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassCreditCardTerminal,kSerialPortDeviceModelCreditCardTerminalYomaniBanksys,LMb.LocalMachineCode,LSPDr)==false) then begin  
    goto LYomaniBanksys_TransactionAbortOut;
  end;  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)==0) then begin
    goto LYomaniBanksys_TransactionAbortOut;
  end;
  SetComPortCodepage(StringSetFromString(89,LSPDr.Codepage));
  YomaniBanksys_TransactionAbort;
  res = CloseComPort(0);  
LYomaniBanksys_TransactionAbortOut:;  
  return;
end;

updating function Integer YomaniBanksys_ProcessTransactionWithCtrlSequence(Integer ProcessingWn,string SentCtrlSeq,string paymode,string label,string transtype,string transactionid,string timestamp,string codepage)
begin
  Integer res,noErr;
  string 255 results;  
  Integer nrofmsgs;
  Boolean additionalinfof;

  res = YomaniBanksys_SendCommand(SentCtrlSeq);
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransactionWithCtrlSequenceOut;
  end;
  res = YomaniBanksys_ReadACK(60,CC_ENQ);
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransactionWithCtrlSequenceOut;
  end;
  res = YomaniBanksys_WaitForTransactionResult(ProcessingWn,paymode,label,transtype,transactionid,timestamp,codepage,results);
  if (res!=noErr) then begin
    goto LYomaniBanksys_ProcessTransactionWithCtrlSequenceOut;
  end;        
  switch (results) begin
    case "2003": additionalinfof = true;
    case "2004": additionalinfof = true;
    case "2005": additionalinfof = true;
    case "2006": additionalinfof = true;
  end;
  if (additionalinfof) then begin
    YomaniAdditionalInformationRequired(SentCtrlSeq,ProcessingWn);
  end;
LYomaniBanksys_ProcessTransactionWithCtrlSequenceOut:;  
  YomaniBanksys_ProcessTransactionWithCtrlSequence = res;
  return;
end;

global
updating procedure YomaniBanksys_ContinueTransaction(Integer ProcessingWn,record RcVc RepSpec)
begin
  record LocalMachineBlock LMb;  
  record LSerialPortDeviceVc LSPDr;
  Integer res,noErr;
  string 255 codepage;

  Sleep(1);
  BlockLoad(LMb);
  if (FindLocalSerialPortDevice(kSerialPortDeviceClassCreditCardTerminal,kSerialPortDeviceModelCreditCardTerminalYomaniBanksys,LMb.LocalMachineCode,LSPDr)==false) then begin  
    goto LYomaniBanksys_ContinueTransaction;
  end;  
  if (OpenComPort(0,LSPDr.Port,LSPDr.BaudRate,LSPDr.Parity,LSPDr.ByteSize,LSPDr.StopBits,LSPDr.FlowControl)==0) then begin
    goto LYomaniBanksys_ContinueTransaction;
  end;
  codepage = StringSetFromString(89,LSPDr.Codepage);
  SetComPortCodepage(codepage);
  res = YomaniBanksys_ProcessTransactionWithCtrlSequence(ProcessingWn,RepSpec.f12,RepSpec.AccStr,RepSpec.f5,RepSpec.f11,RepSpec.f1,RepSpec.f2,codepage);
  res = CloseComPort(0);  
LYomaniBanksys_ContinueTransaction:;  
  return;
end;
