external updating procedure StoreeShipTaxAuthReply(string,LongInt,string,string);
external function Boolean BulkSerialNos_CalculateQuantityAndSerialNr(record SerNrTrackBlock,Boolean,string,var string,var val);
external function roundmode GetCostRoundMode(record RoundBlock);
external function string 255 FindPositionWithSerialNr(string,string,string,string);
external function Boolean SerialNrForOneItem(string,var record SerBalVc);
external function string 255 FindINObjects(string,string);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstItem(var string,var record INVc);
external function Integer GetPO(LongInt,var record POVc,string,Boolean);
external function roundmode SetRoundModeD(Integer);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external procedure RetPUSumUp(var record RetPUVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function val CalculateSerialNrQuantity(string,string,string,Boolean,val,val,val,val);
external function Integer CheckSerialStatus(string,string,var string);
external procedure SerialNrDimensions(string,string,var val,var val,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function string 20 FindCustRoute(string,string,string);

/*
function val AlreadyReturned(LongInt sernr,Integer rownr)
begin
  Boolean found;
  record RetPUVc RetPUr;
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  val res;

  found = true;
  RetPUr.PUNr = sernr;
  while (LoopKey("PUNr",RetPUr,1,found)) begin
    if (RetPUr.PUNr!=sernr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(RetPUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        if (RetPUrw.PURow==rownr) then begin
          res = res + RetPUrw.Quant;
        end;
      end;
    end;
  end;  

  AlreadyReturned = res;
  return;
end;

*/

function val AlreadyReturnedFromCustomer(LongInt sernr,LongInt shnr,LongInt shrow)
begin
  Boolean found;
  record ItemHistVc IHr;
  val res;
  record RetVc Retr;
  row RetVc Retrw;
  Integer i,rwcnt;

  found = true;
  IHr.Source = sernr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sernr) then begin found = false; end;
    if (found) then begin
       res = res + IHr.Qty;
//StopAlert("1.IHr.SerNr " & IHr.SerNr & " res " & res);
    end;
  end;  

  found = true;
  Retr.SHNr = shnr;
  while (LoopKey("SHNr",Retr,1,found)) begin
    if (Retr.SHNr!=shnr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(Retr);
      for (i=0;i<rwcnt;i=i+1) begin 
        MatRowGet(Retr,i,Retrw);
        if (Retrw.SHRow==shrow) then begin
          res = res + Retrw.Quant;
        end;
      end;
    end;
  end;  

  AlreadyReturnedFromCustomer = res;
  return;
end;

function val MovedBack(LongInt sernr)
begin
  Boolean found;
  record ItemHistVc IHr;
  val res;
  string 255 location;

  IHr.SerNr = sernr;
  if (ReadFirstMain(IHr,1,true)) then begin
    location = IHr.Location;
  end;

  found = true;
  IHr.Source = sernr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sernr) then begin found = false; end;
    if (found) then begin
//StopAlert("IHr.Qty " & IHr.Qty);
       if (IHr.Location==location) and (IHr.FileName=="StockMovVc") then begin
         res = res - IHr.Qty;
       end;
    end;
  end;  
  MovedBack = res;
  return;
end;

function LongInt MovementSource(record ItemHistVc outIHr)
begin
  record ItemHistVc inIHr;
  Boolean found,testf;
  
  inIHr.FileName = outIHr.FileName;
  inIHr.TransNr = outIHr.TransNr;
  inIHr.Row = outIHr.Row;
  found = true;
  while (LoopKey("FNTransNr",inIHr,3,found)) begin
    if (inIHr.FileName!=outIHr.FileName) then begin found = false; end;
    if (inIHr.TransNr!=outIHr.TransNr) then begin found = false; end;
    if (inIHr.Row!=outIHr.Row) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (inIHr.Qty!=-outIHr.Qty) then begin testf = false; end;
      if (testf) then begin 
        found = false;       
      end;
    end;
  end;
  MovementSource = inIHr.SerNr;
  return;
end;

global
function val AlreadyReturned_RetPUVc(LongInt sernr)
begin
  Boolean found;
  record ItemHistVc IHr;
  val res;

  found = true;
  IHr.Source = sernr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sernr) then begin found = false; end;
    if (found) then begin
       res = res - IHr.Qty;
//StopAlert("res " & res & " IHr.FileName " & IHr.FileName);
       switch (IHr.FileName) begin
         case "SHVc": res = res - AlreadyReturnedFromCustomer(IHr.SerNr,IHr.TransNr,IHr.Row);
         case "StockMovVc": res = res - MovedBack(MovementSource(IHr));
       end;
    end;
  end;  
  AlreadyReturned_RetPUVc = res;
  return;
end;

global
function LongInt PastePUInRetPU(record PUVc PUp,var record RetPUVc RetPUp)
BEGIN
  LongInt res;
  row PUVc PUrw;
  row RetPUVc RetPUrw;
  Integer i,rwcnt,retrw;
  record MainStockBlock MSb;
  record RetGoodsBlock RGb;  
  record CostAccBlock CAb;  
  record AccBlock ARb;  
  Boolean testf;
  record INVc INr;
  record CUVc VEr;
  record ItemHistVc IHr;
  record ItemStatusVc ISr;
  val q;
  
  res = 1756; //1733;
  BlockLoad(MSb);    
  BlockLoad(RGb);
  BlockLoad(CAb);
  BlockLoad(ARb);
  RetPUp.PUNr = PUp.SerNr;
  RetPUp.PONr = PUp.PONr;  
  RetPUp.Type = RGb.ReduceDefault;
  RetPUp.UpdStockFlag = 1;  
  RetPUp.Comment = PUp.Comment;
  RetPUp.VECode = PUp.VECode;
  RetPUp.VEName = PUp.VEName;
  RetPUp.Location = PUp.Location;
  RetPUp.OKFlag = 0;
  RetPUp.InclVAT = 0;
  RetPUp.SumCostPrice = blankval;
  RetPUp.SumQuant = blankval;
  RetPUp.Objects = PUp.Objects;

  RetPUp.CurncyCode = PUp.CurncyCode;
  RetPUp.FrRate = PUp.FrRate;
  RetPUp.ToRateB1 = PUp.ToRateB1;
  RetPUp.ToRateB2 = PUp.ToRateB2;
  RetPUp.BaseRate1 = PUp.BaseRate1;
  RetPUp.BaseRate2 = PUp.BaseRate2;

  RetPUp.ExtraCost = PUp.ExtraCost;
//  RetPUp.ShipCost = PUp.ShipCost;
//  RetPUp.CustomsCost = PUp.CustomsCost;
  RetPUp.Cost1 = PUp.Cost1;
  RetPUp.Cost2 = PUp.Cost2;
  RetPUp.Cost3 = PUp.Cost3;
  RetPUp.Cost4 = PUp.Cost4;
  RetPUp.Cost5 = PUp.Cost5;

  RetPUp.Cost1Round = PUp.Cost1Round;
  RetPUp.Cost2Round = PUp.Cost2Round;
  RetPUp.Cost3Round = PUp.Cost3Round;
  RetPUp.Cost4Round = PUp.Cost4Round;
  RetPUp.Cost5Round = PUp.Cost5Round;
  RetPUp.ExtraCostsCalculation = PUp.ExtraCostsCalculation;

  VEr.Code = PUp.VECode;
  if (ReadFirstMain(VEr,1,true)) then begin end;
  RetPUp.DelAddr0 = VEr.DelAddr0;
  RetPUp.DelAddr1 = VEr.DelAddr1;
  RetPUp.DelAddr2 = VEr.DelAddr2;
  RetPUp.DelAddr3 = VEr.DelAddr3;
  RetPUp.DelAddr4 = VEr.DelAddr4;
  RetPUp.Sorting = FindCustRoute(RetPUp.VECode,RetPUp.Location,RetPUp.DelAddrCode);
  rwcnt = MatRowCnt(PUp);
  retrw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    testf = true;
    if (blank(PUrw.ArtCode)) then begin
      testf = false;
    end;
    if (PUrw.Quant!=0) then begin testf = true; end;
    if (PUrw.Sum==0) then begin testf = true; end;
    if (testf) then begin
      testf = ReadFirstItem(PUrw.ArtCode,INr,true,true);
      q = PUrw.Quant;
      if (INr.ItemType!=1) then begin
        if (CAb.CostAccForNonStocked==0) then begin
          goto LPastePUInRetPU;
        end;
      end else begin
        FindStockValue(PUrw.ArtCode,RetPUp.Location,ISr);
        if (q>ISr.Instock) then begin
          q = ISr.Instock;
        end;
/*        
        if (CAb.RetPUCostPriceNotFromPU!=0) then begin
          IHr.FileName = "PUVc";
          IHr.TransNr = PUp.SerNr;
          IHr.Row = i;
          if (ReadFirstKey("FNTransNr",IHr,3,true)==false) then begin testf = false; end;
          q = PUrw.Quant - AlreadyReturned_RetPUVc(IHr.SerNr);          
        end;
        if (q<=0) then begin 
          testf = false; 
        end;
*/        
      end;
      
      if (testf) then begin
        ClearRow(RetPUp,RetPUrw,1);
        RetPUrw.PUNr = PUp.SerNr;
        RetPUrw.PURow = i;
        RetPUrw.Location = PUrw.Location;
        RetPUrw.PONr = PUrw.PONr;
        RetPUrw.OrdRow = PUrw.OrdRow;
        RetPUrw.ArtCode = PUrw.ArtCode;
        RetPUrw.Quant = q;
        RetPUrw.Spec = PUrw.Spec;
        RetPUrw.VEItemCode = PUrw.VEItemCode;
/*        
        if (CAb.RetPUCostPriceNotFromPU!=0) then begin
          RetPUrw.FIFO = PUrw.CostPrice;
          RetPUrw.FIFORowVal = Round(RetPUrw.Quant*RetPUrw.FIFO,SetRoundModeD(5));
        end;
*/        
        RetPUrw.Objects = PUrw.Objects;
        RetPUrw.CostAcc = PUrw.CostAcc;
        RetPUrw.CredAcc = PUrw.CredAcc;
        if (nonblank(ARb.RetPUAcc)) then begin
          if (ARb.UsePUAccInRetPU==0) or (blank(RetPUrw.CredAcc))  then begin
            RetPUrw.CredAcc = ARb.RetPUAcc;
          end;
        end;
        RetPUrw.PosCode = PUrw.PosCode;
        RetPUrw.Coefficient = INr.UnitCoefficient;
        RetPUrw.UnitXval = INr.Width;
        RetPUrw.UnitYval = INr.Height;
        RetPUrw.UnitZval = INr.Depth;
        RetPUrw.VATCode = "";
        RetPUrw.SerialNr = PUrw.SerialNr;
        RetPUrw.PUCostPrice = PUrw.Sum/PUrw.Quant;
//        RetPUrw.ShipCost = PUrw.ShipCost;
//        RetPUrw.CustomsCost = PUrw.CustomsCost;
        RetPUrw.RowCost1 = PUrw.RowCost1;
        RetPUrw.RowCost2 = PUrw.RowCost2;
        RetPUrw.RowCost3 = PUrw.RowCost3;
        RetPUrw.RowCost4 = PUrw.RowCost4;
        RetPUrw.RowCost5 = PUrw.RowCost5;
        MatRowPut(RetPUp,retrw,RetPUrw);
        retrw = retrw + 1;
        res = 0;        
      end;
LPastePUInRetPU:;      
    end;
  end;
  RetPUSumUp(RetPUp);
  PastePUInRetPU = res;
  RETURN;
END;

function Integer AddPURowToRetPU(record RetPUVc RetPUp,Integer purownr,LongInt PUNr,row POVc POrw,row PUVc PUrw,record CostAccBlock CAb,record AccBlock ARb)
BEGIN
  Integer retrw;
  row RetPUVc RetPUrw;
  record INVc INr;
  
  retrw = MatRowCnt(RetPUp);
  ClearRow(RetPUp,RetPUrw,1);
  if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin end;
  if (INr.ItemType!=1) then begin 
    if (CAb.CostAccForNonStocked==0) then begin
      goto LSKIPROW; 
    end;
  end;
  RetPUrw.PONr = PUrw.PONr;
  RetPUrw.OrdRow = PUrw.OrdRow;
  RetPUrw.PURow = purownr;
  RetPUrw.PUNr = PUNr;
  RetPUrw.ArtCode = PUrw.ArtCode;
  RetPUrw.Quant = PUrw.Quant;
  RetPUrw.Spec = PUrw.Spec;
  RetPUrw.VEItemCode = POrw.VEArtCode;
/*  
  if (CAb.RetPUCostPriceNotFromPU==0) then begin
    RetPUrw.FIFORowVal = blankval;
    RetPUrw.FIFO = blankval;
  end else begin
    RetPUrw.FIFO = PUrw.CostPrice;
    RetPUrw.FIFORowVal = PUrw.Quant*PUrw.CostPrice;
  end;
*/  
  RetPUrw.Objects = PUrw.Objects;
  RetPUrw.PUCostPrice = PUrw.Sum/PUrw.Quant;
/*  
  RetPUrw.RowCost1 = PUrw.RowCost1;
  RetPUrw.RowCost2 = PUrw.RowCost2;
  RetPUrw.RowCost3 = PUrw.RowCost3;
  RetPUrw.RowCost4 = PUrw.RowCost4;
  RetPUrw.RowCost5 = PUrw.RowCost5;
  RetPUrw.ShipCost = PUrw.ShipCost;
  RetPUrw.CustomsCost = PUrw.CustomsCost;
  RetPUrw.CostAcc = "";
  RetPUrw.CredAcc = "";
  if (nonblank(ARb.RetPUAcc)) then begin
	  RetPUrw.CredAcc = ARb.RetPUAcc;
  end;
*/
  RetPUrw.CostAcc = PUrw.CostAcc;
  RetPUrw.CredAcc = PUrw.CredAcc;
  if (nonblank(ARb.RetPUAcc)) then begin
    if (ARb.UsePUAccInRetPU==0) or (blank(RetPUrw.CredAcc))  then begin
      RetPUrw.CredAcc = ARb.RetPUAcc;
    end;
  end;
  RetPUrw.PosCode = "";
  RetPUrw.Coefficient = INr.UnitCoefficient;
  RetPUrw.UnitXval = INr.Width;
  RetPUrw.UnitYval = INr.Height;
  RetPUrw.UnitZval = INr.Depth;
  RetPUrw.VATCode = "";
  RetPUrw.SerialNr = "";
  MatRowPut(RetPUp,retrw,RetPUrw);
  retrw = retrw + 1;
LSKIPROW:;  
  AddPURowToRetPU = retrw;
  RETURN;
END;

function Integer PastePOInRetPU(var record RetPUVc RetPUp,var record POVc POr,LongInt ordnr)
BEGIN
  Integer res;
  row POVc POrw;
  row RetPUVc RetPUrw;
  Integer i,rwcnt,retrw;
  record MainStockBlock MSb;
  record RetGoodsBlock RGb;  
  Boolean testf;
  Integer pui,purwcnt;
  record PUVc PUr;
  row PUVc PUrw;
  val rem;
  Boolean found,loopf,found2;
  string 255 keystr;
  record CostAccBlock CAb;
  record AccBlock ARb;  
  record CUVc VEr;
  
  res = 20088;
  BlockLoad(MSb);    
  BlockLoad(RGb);
  BlockLoad(CAb);
  BlockLoad(ARb);
  POr.SerNr = ordnr;
  if (ReadFirstMain(POr,1,true)) then begin
  end;
  RetPUp.PONr = POr.SerNr;
  RetPUp.Type = RGb.ReduceDefault;
  RetPUp.UpdStockFlag = 1;  
  RetPUp.Comment = POr.Comment;
  RetPUp.VECode = POr.VECode;
  RetPUp.VEName = POr.Addr0;
  RetPUp.Location = POr.Location;
  RetPUp.OKFlag = 0;
  RetPUp.InclVAT = 0;
  RetPUp.SumCostPrice = blankval;
  RetPUp.SumQuant = blankval;
  RetPUp.PUNr = -1;
  RetPUp.Objects = POr.Objects;
  VEr.Code = POr.VECode;
  if (ReadFirstMain(VEr,1,true)) then begin end;
  RetPUp.DelAddr0 = VEr.DelAddr0;
  RetPUp.DelAddr1 = VEr.DelAddr1;
  RetPUp.DelAddr2 = VEr.DelAddr2;
  RetPUp.DelAddr3 = VEr.DelAddr3;
  RetPUp.DelAddr4 = VEr.DelAddr4;
  RetPUp.Sorting = FindCustRoute(RetPUp.VECode,RetPUp.Location,RetPUp.DelAddrCode);
  rwcnt = MatRowCnt(POr);
  retrw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POr,i,POrw);
    testf = true;
    if (blank(POrw.ArtCode)) then begin
      testf = false;
    end;
    if (POrw.Shipd2!=0) then begin testf = true; end;
    if (POrw.Sum==0) then begin testf = true; end;
    if (testf) then begin
      ResetLoop(PUr);
      rem = POrw.Shipd2;
      loopf = true;
      while (loopf) begin
        found = true;
        PUr.PONr = POr.SerNr;
        while (LoopKey("PONr",PUr,1,found)) begin
          if (PUr.PONr!=POr.SerNr) then begin found = false; end;
          if (found) then begin
            purwcnt = MatRowCnt(PUr);
            for (pui=0;pui<purwcnt;pui=pui+1) begin
              MatRowGet(PUr,pui,PUrw);
              if (PUrw.OrdRow==i) then begin
                retrw = AddPURowToRetPU(RetPUp,pui,PUr.SerNr,POrw,PUrw,CAb,ARb);
                res = 0;
                rem = rem - PUrw.Quant;
                if (rem<=0) then begin 
                  found = false; 
                  found2 = false;
                end else begin
                  found2 = true;
                end;
              end;
            end;
          end;
        end;
        if (found2==false) then begin loopf = false; end;
      end;  
      if (rem>0) then begin loopf = true; end;
      found2 = false;
      while (loopf) begin
        found = true;
        ResetLoop(PUr);      
        keystr = "RowPONr:" & POr.SerNr;
        while (LoopKey(keystr,PUr,1,found)) begin
          if (found) then begin
            purwcnt = MatRowCnt(PUr);
            for (pui=0;pui<purwcnt;pui=pui+1) begin
              MatRowGet(PUr,pui,PUrw);
              if (PUrw.OrdRow==i) and (PUrw.PONr==POr.SerNr) then begin
                retrw = AddPURowToRetPU(RetPUp,pui,PUr.SerNr,POrw,PUrw,CAb,ARb);
                res = 0;
                rem = rem - PUrw.Quant;
                if (rem<=0) then begin 
                  found = false; 
                  found2 = false;
                end else begin
                  found2 = true;
                end;
              end;
            end;
          end;
        end;
        if (found2==false) then begin loopf = false; end;
      end;            
LSKIPROW:;      
    end;
  end;
  PastePOInRetPU = res;
  RETURN;
END;

global
updating function Integer RecordAction_raPastePOInRetPU(var record RetPUVc RetPUp,LongInt ordnr)
BEGIN
  Integer res;
  record CostAccBlock CAb;
  record POVc POr;
  
  res = 20088;
  BlockLoad(CAb);
  RecordNew(RetPUp);
/*  
  if (CAb.RetPUCostPriceNotFromPU!=0) then begin
    res = 20559;
    goto LRecordAction_raPastePOInRetPU;
  end;
*/  
  RetPUp.SerNr = -1;
  if (RetPUp.SerNr==-1) then begin
    RetPUp.SerNr = NextSerNr("RetPUVc",RetPUp.TransDate,-1,false,"");
    if (RetPUp.SerNr==-1) then begin
      res = 1557;
      goto LRecordAction_raPastePOInRetPU;
    end;
  end;
  res = PastePOInRetPU(RetPUp,POr,ordnr);
  if ((MatRowCnt(RetPUp)>0) and (RetPUp.SerNr!=-1)) then begin
    RetPUSumUp(RetPUp);
    if (RecordInsert(RetPUp,false)) then begin
      CreateRecordLink(RetPUp,CurrentCompany,POr,CurrentCompany);
      CreateRecordLink(POr,CurrentCompany,RetPUp,CurrentCompany);
      res = 0;
    end;
  end;
LRecordAction_raPastePOInRetPU:;
  RecordAction_raPastePOInRetPU = res;
  RETURN;
END;

global
function Boolean RetPUVc_PasteArtCode(var record RetPUVc RetPUp,Integer rownr,Boolean changedf,Boolean warnf)
begin
  Boolean res;
  record INVc INr;
  row RetPUVc RetPUrw;
  string 60 sz,msk,mskrep;
  string 200 varsubset;
  Boolean itemfound;

  if (changedf) then begin
    MatRowGet(RetPUp,rownr,RetPUrw);  
    res = true;
    itemfound = GetFirstItem(RetPUrw.ArtCode,INr);
    if (itemfound==false) then begin
      itemfound = ReadFirstItem(RetPUrw.ArtCode,INr,true,true);
      if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin
        INr.Code = RetPUrw.ArtCode;
      end;
    end;
    if (itemfound) then begin
      RetPUrw.Coefficient = INr.UnitCoefficient;
      RetPUrw.ArtCode = INr.Code;
      RetPUrw.Spec = INr.Name;
//      RetPUrw.BasePrice = INr.UPrice1;
      RetPUrw.Objects = FindINObjects(INr.Objects,INr.Group);
      RetPUrw.UnitXval = INr.Width;
      RetPUrw.UnitYval = INr.Height;
      RetPUrw.UnitZval = INr.Depth;
      MatRowPut(RetPUp,rownr,RetPUrw);
      if (warnf) then begin
        if (INr.ItemType!=1) then begin
          MessageBox(1301,"");
        end;      
      end;
    end;
  end;
  RetPUVc_PasteArtCode = res;
  return;
end;

global
procedure RetPUVc_PasteTransDate(var record RetPUVc RetPUp)
BEGIN
/*
  val fr,to1,to2,br1,br2;

  GetFullCurncyRate(RetPUp.CurncyCode,RetPUp.TransDate,fr,to1,to2,br1,br2);
  RetPUp.FrRate = fr;
  RetPUp.ToRateB1 = to1; 
  RetPUp.ToRateB2 = to2;
  RetPUp.BaseRate1 = br1;
  RetPUp.BaseRate2 = br2;    
*/  
  RETURN;
END;

global
function Integer RetPUVc_PastePONr(var record RetPUVc RetPUp,Integer rownr)
begin
  row RetPUVc RetPUrw;
  record POVc POr;
  Integer retval;
  
  if (rownr<0) then begin
    retval = GetPO(RetPUp.PONr,POr,RetPUp.VECode,true);
    if (retval==0) then begin
      retval = PastePOInRetPU(RetPUp,POr,RetPUp.PONr);
    end;
  end else begin
    MatRowGet(RetPUp,rownr,RetPUrw);
    if (RetPUrw.PONr>0) then begin
      retval = GetPO(RetPUrw.PONr,POr,RetPUp.VECode,true);
    end;
  end;
  switch (retval) begin
    case 1: retval = 1281;
    case 2: retval = 1215;
    case 3: retval = 1138;
    case 4: retval = 1026;
    case 5: retval = 1459;  
  end;
  RetPUVc_PastePONr = retval;
  return;
end;

function Boolean CheckIfOnePOOnRetPU(record RetPUVc RetPUp,LongInt POSerNr)
begin
  Integer i,rwcnt;
  row RetPUVc RetPUrw;
  Boolean res;
  
  res = true;
  rwcnt = MatRowCnt(RetPUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (RetPUrw.PONr!=POSerNr) then begin
      res = false;
      goto LCheckIfOnePOOnRetPU;
    end;
  end;
LCheckIfOnePOOnRetPU:;  
  CheckIfOnePOOnRetPU = res;
  return;
end;

function Boolean CopyPOrwToRetPUrw(record POVc POp,row POVc POrw,LongInt OrdRow,var record RetPUVc RetPUp,string VECode,var row RetPUVc RetPUrw)
begin
  Boolean res;
  val rem,p,t,pv,sv,v1,v2,totqty;
  record INVc INr;
  record CostAccBlock CAb;  
  record AccBlock ARb;  

  BlockLoad(CAb);
  BlockLoad(ARb);
  rem = POrw.Shipd1;
  if (rem>0) then begin
    if (ReadFirstItem(POrw.ArtCode,INr,true,true)) then begin end;
    if (INr.ItemType!=1) then begin 
      if (CAb.CostAccForNonStocked==0) then begin
        goto LCopyPOrwToRetPUrwSKIPROW; 
      end;
    end;
    if (blank(RetPUp.VECode)) then begin
      RetPUp.VECode = POp.VECode;
      RetPUp.Comment = POp.Comment;
      RetPUp.CurncyCode = POp.CurncyCode;
      RetPUp.FrRate = POp.FrRate;
      RetPUp.ToRateB1 = POp.ToRateB1;
      RetPUp.ToRateB2 = POp.ToRateB2;
      RetPUp.BaseRate1 = POp.BaseRate1;
      RetPUp.BaseRate2 = POp.BaseRate2;
      if (((POp.BaseRate1!=0) and (POp.BaseRate2!=0)) or
         ((POp.ToRateB1!=0) or (POp.ToRateB2!=0))) then begin
        RetPUp.FrRate = POp.FrRate;
        RetPUp.ToRateB1 = POp.ToRateB1;
        RetPUp.ToRateB2 = POp.ToRateB2;
        RetPUp.BaseRate1 = POp.BaseRate1;
        RetPUp.BaseRate2 = POp.BaseRate2;
      end;    
    end;
    if (CheckIfOnePOOnRetPU(RetPUp,POp.SerNr)) then begin
      RetPUp.PONr = POp.SerNr;
    end else begin
      RetPUp.PONr = -1;
    end;
    RetPUrw.PONr = POp.SerNr;
    RetPUrw.OrdRow = OrdRow;
    RetPUrw.ArtCode = POrw.ArtCode;
    RetPUrw.Quant = POrw.Quant;
    RetPUrw.Spec = POrw.Spec;
    RetPUrw.VEItemCode = POrw.VEArtCode;
    RetPUrw.FIFORowVal = blankval;
    RetPUrw.FIFO = blankval;
    RetPUrw.Objects = POrw.Objects;
//    RetPUrw.RowCost1 = POrw.RowCost1;
//    RetPUrw.RowCost2 = POrw.RowCost2;
//    RetPUrw.RowCost3 = POrw.RowCost3;
//    RetPUrw.RowCost4 = POrw.RowCost4;
//    RetPUrw.RowCost5 = POrw.RowCost5;
//    RetPUrw.ShipCost = POrw.ShipCost;
//    RetPUrw.CustomsCost = POrw.CustomsCost;
    RetPUrw.CostAcc = POrw.CostAcc;
//    RetPUrw.CredAcc = POrw.CredAcc;
    if (nonblank(ARb.RetPUAcc)) then begin
      if (ARb.UsePUAccInRetPU==0) or (blank(RetPUrw.CredAcc))  then begin
        RetPUrw.CredAcc = ARb.RetPUAcc;
      end;
    end;
    RetPUrw.PosCode = "";
    RetPUrw.Coefficient = INr.UnitCoefficient;
    RetPUrw.UnitXval = INr.Width;
    RetPUrw.UnitYval = INr.Height;
    RetPUrw.UnitZval = INr.Depth;
    RetPUrw.VATCode = "";
    RetPUrw.SerialNr = "";
    res = true;
LCopyPOrwToRetPUrwSKIPROW:;
  end;
  CopyPOrwToRetPUrw = res;
  return;
end;


/*
function Integer PastePORowInRetPU(var record RetPUVc RetPUp,LongInt PONr,Integer OrderRow,Integer retpurownr)
begin
  Integer retval;
  record POVc POr;
  row POVc POrw;
  Integer OrdRow;
  Integer i,porwcnt,retpurowcnt,currow;
  row RetPUVc RetPUrw;
  Boolean firstf;
  
  retval = GetPO(PONr,POr,RetPUp.VECode);
  if (retval==0) then begin
    firstf = true;
    currow = retpurownr;
    if (OrderRow>=0) then begin
      OrdRow = OrderRow  - 1;
    end else begin
      OrdRow = OrderRow;
    end;
    porwcnt = MatRowCnt(POr);
    retpurowcnt = MatRowCnt(RetPUp);
    if (OrdRow==-1) then begin
      if (((porwcnt+(retpurowcnt-1)) > 199) or (OrdRow >=porwcnt)) then begin
        retval = 1;
        goto LPastePORowInRetPU;
      end;
      for (i=0;i<porwcnt;i=i+1) begin
        ClearRow(RetPUp,RetPUrw,1);
        MatRowGet(POr,i,POrw);
        if (CopyPOrwToRetPUrw(POr,POrw,i,RetPUp,RetPUp.VECode,RetPUrw)) then begin
          if (firstf) then begin
            firstf = false;
            MatRowPut(RetPUp,currow,RetPUrw);
            currow = currow + 1;
          end else begin
            MatRowInsert(RetPUp,currow,RetPUrw);
            currow = currow + 1;
          end;
        end else begin
//          retval = 5;//just skip received rows
        end;
      end;
    end else begin
      if (OrdRow>=porwcnt) then begin
        retval = 5;
        goto LPastePORowInRetPU;
      end;  
      if (OrdRow<0) then begin
        retval = 5;
        goto LPastePORowInRetPU;
      end;
      ClearRow(RetPUp,RetPUrw,1);
      MatRowGet(POr,OrdRow,POrw);
      if (CopyPOrwToRetPUrw(POr,POrw,OrdRow,RetPUp,RetPUp.VECode,RetPUrw)) then begin
        MatRowPut(RetPUp,currow,RetPUrw);
      end else begin
        retval = 5;
      end;
    end;
  end;
LPastePORowInRetPU:;
  PastePORowInRetPU = retval;
  return;
end;
*/

function Boolean CopyPUrwToRetPUrw(record PUVc PUp,row PUVc PUrw,LongInt PURow,var record RetPUVc RetPUp,string VECode,var row RetPUVc RetPUrw)
begin
  Boolean res;
  val rem,p,t,pv,sv,v1,v2,totqty;
  record INVc INr;
  record CostAccBlock CAb;  
  record AccBlock ARb;  
  record POVc POr;
  row POVc POrw;

  BlockLoad(CAb);
  BlockLoad(ARb);
  POr.SerNr = PUrw.PONr;
  rem = PUrw.Quant;
  if (ReadFirstMain(POr,1,true)) then begin
    MatRowGet(POr,PUrw.OrdRow,POrw);
    rem = POrw.Shipd1;
  end;
  if (rem>0) then begin
    if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin end;
    if (INr.ItemType!=1) then begin 
      if (CAb.CostAccForNonStocked==0) then begin
        goto LCopyPUrwToRetPUrwSKIPROW; 
      end;
    end;
    if (blank(RetPUp.VECode)) then begin
      RetPUp.VECode = PUp.VECode;
      RetPUp.VEName = PUp.VEName;
      RetPUp.Location = PUp.Location;
      RetPUp.Comment = PUp.Comment;
      RetPUp.CurncyCode = PUp.CurncyCode;
      RetPUp.FrRate = PUp.FrRate;
      RetPUp.ToRateB1 = PUp.ToRateB1;
      RetPUp.ToRateB2 = PUp.ToRateB2;
      RetPUp.BaseRate1 = PUp.BaseRate1;
      RetPUp.BaseRate2 = PUp.BaseRate2;
      if (((PUp.BaseRate1!=0) and (PUp.BaseRate2!=0)) or
         ((PUp.ToRateB1!=0) or (PUp.ToRateB2!=0))) then begin
        RetPUp.FrRate = PUp.FrRate;
        RetPUp.ToRateB1 = PUp.ToRateB1;
        RetPUp.ToRateB2 = PUp.ToRateB2;
        RetPUp.BaseRate1 = PUp.BaseRate1;
        RetPUp.BaseRate2 = PUp.BaseRate2;
      end;    
    end;
    if (CheckIfOnePOOnRetPU(RetPUp,PUp.PONr)) then begin
      RetPUp.PONr = PUp.PONr;
    end else begin
      RetPUp.PONr = -1;
    end;
    RetPUrw.PONr = PUp.PONr;
    RetPUrw.OrdRow = PUrw.OrdRow;
    RetPUrw.PUNr = PUp.SerNr;
    RetPUrw.PURow = PURow;
    RetPUrw.ArtCode = PUrw.ArtCode;
    RetPUrw.Quant = PUrw.Quant;
    RetPUrw.Spec = PUrw.Spec;
    RetPUrw.SerialNr = PUrw.SerialNr;
//    RetPUrw.VEItemCode = PUrw.VEArtCode;
    RetPUrw.FIFORowVal = blankval;
    RetPUrw.FIFO = blankval;
    RetPUrw.Objects = PUrw.Objects;
    RetPUrw.PUCostPrice = PUrw.Sum/PUrw.Quant;
//    RetPUrw.RowCost1 = PUrw.RowCost1;
//    RetPUrw.RowCost2 = PUrw.RowCost2;
//    RetPUrw.RowCost3 = PUrw.RowCost3;
//    RetPUrw.RowCost4 = PUrw.RowCost4;
//    RetPUrw.RowCost5 = PUrw.RowCost5;
//    RetPUrw.ShipCost = PUrw.ShipCost;
//    RetPUrw.CustomsCost = PUrw.CustomsCost;
    RetPUrw.CostAcc = PUrw.CostAcc;
    RetPUrw.CredAcc = PUrw.CredAcc;
    RetPUrw.Location = PUrw.Location;
    if (nonblank(ARb.RetPUAcc)) then begin
      if (ARb.UsePUAccInRetPU==0) or (blank(RetPUrw.CredAcc))  then begin
        RetPUrw.CredAcc = ARb.RetPUAcc;
      end;
    end;
    RetPUrw.PosCode = PUrw.PosCode;
    RetPUrw.Coefficient = INr.UnitCoefficient;
    RetPUrw.UnitXval = INr.Width;
    RetPUrw.UnitYval = INr.Height;
    RetPUrw.UnitZval = INr.Depth;
    RetPUrw.VATCode = "";
    res = true;
LCopyPUrwToRetPUrwSKIPROW:;
  end;
  CopyPUrwToRetPUrw = res;
  return;
end;

function Integer PastePORowInRetPU(var record RetPUVc RetPUp,LongInt PONr,Integer OrderRow,Integer retpurownr)
begin
  Integer retval;
  record POVc POr;
  row POVc POrw;
  Integer OrdRow;
  Integer i,porwcnt,retpurowcnt,currow;
  row RetPUVc RetPUrw;
  Boolean firstf;
  record PUVc PUr;
  row PUVc PUrw;
  val rem;
  Boolean loopf,found,found2;
  Integer pui,purwcnt;
  string 255 keystr;
  
  retval = GetPO(PONr,POr,RetPUp.VECode,true);
  if (retval==0) then begin
    firstf = true;
    currow = retpurownr;
    if (OrderRow>=0) then begin
      OrdRow = OrderRow  - 1;
    end else begin
      OrdRow = OrderRow;
    end;
    porwcnt = MatRowCnt(POr);
    retpurowcnt = MatRowCnt(RetPUp);
    if (OrdRow==-1) then begin
      if (((porwcnt+(retpurowcnt-1)) > 199) or (OrdRow >=porwcnt)) then begin
        retval = 1;
        goto LPastePORowInRetPU;
      end;
      for (i=0;i<porwcnt;i=i+1) begin
        ClearRow(RetPUp,RetPUrw,1);
        MatRowGet(POr,i,POrw);

        ResetLoop(PUr);
        rem = POrw.Shipd2;
        loopf = true;
        while (loopf) begin
          found = true;
          PUr.PONr = POr.SerNr;
          while (LoopKey("PONr",PUr,1,found)) begin
            if (PUr.PONr!=POr.SerNr) then begin found = false; end;
            if (found) then begin
              purwcnt = MatRowCnt(PUr);
              for (pui=0;pui<purwcnt;pui=pui+1) begin
                MatRowGet(PUr,pui,PUrw);
                if (PUrw.OrdRow==i) then begin
                  if (CopyPUrwToRetPUrw(PUr,PUrw,pui,RetPUp,RetPUp.VECode,RetPUrw)) then begin
                    if (firstf) then begin
                      firstf = false;
                      MatRowPut(RetPUp,currow,RetPUrw);
                      currow = currow + 1;
                    end else begin
                      MatRowInsert(RetPUp,currow,RetPUrw);
                      currow = currow + 1;
                    end;
                    retval = 0;
                    rem = rem - PUrw.Quant;
                    if (rem<=0) then begin 
                      found = false; 
                      found2 = false;
                    end else begin
                      found2 = true;
                    end;
                  end else begin
                    retval = 5;
                    goto LPastePORowInRetPU;
                  end;                  
                end;
              end;
            end;
          end;
          if (found2==false) then begin loopf = false; end;
        end;  

        if (rem>0) then begin loopf = true; end;
        found2 = false;
        while (loopf) begin
          found = true;
          ResetLoop(PUr);      
          keystr = "RowPONr:" & POr.SerNr;
          while (LoopKey(keystr,PUr,1,found)) begin
            if (found) then begin
              purwcnt = MatRowCnt(PUr);
              for (pui=0;pui<purwcnt;pui=pui+1) begin
                MatRowGet(PUr,pui,PUrw);
                if (PUrw.OrdRow==i) and (PUrw.PONr==POr.SerNr) then begin
                  if (CopyPUrwToRetPUrw(PUr,PUrw,pui,RetPUp,RetPUp.VECode,RetPUrw)) then begin
                    if (firstf) then begin
                      firstf = false;
                      MatRowPut(RetPUp,currow,RetPUrw);
                      currow = currow + 1;
                    end else begin
                      MatRowInsert(RetPUp,currow,RetPUrw);
                      currow = currow + 1;
                    end;
                    retval = 0;
                    rem = rem - PUrw.Quant;
                    if (rem<=0) then begin 
                      found = false; 
                      found2 = false;
                    end else begin
                      found2 = true;
                    end;
                  end else begin
                    retval = 5;
                    goto LPastePORowInRetPU;
                  end;                  
                end;
              end;
            end;
          end;
          if (found2==false) then begin loopf = false; end;
        end;
        
      end;
    end else begin
      if (OrdRow>=porwcnt) then begin
        retval = 5;
        goto LPastePORowInRetPU;
      end;  
      if (OrdRow<0) then begin
        retval = 5;
        goto LPastePORowInRetPU;
      end;
      ClearRow(RetPUp,RetPUrw,1);
      MatRowGet(POr,OrdRow,POrw);
      
      ResetLoop(PUr);
      rem = POrw.Shipd2;
      loopf = true;
      while (loopf) begin
        found = true;
        PUr.PONr = POr.SerNr;
        while (LoopKey("PONr",PUr,1,found)) begin
          if (PUr.PONr!=POr.SerNr) then begin found = false; end;
          if (found) then begin
            purwcnt = MatRowCnt(PUr);
            for (pui=0;pui<purwcnt;pui=pui+1) begin
              MatRowGet(PUr,pui,PUrw);
              if (PUrw.OrdRow==OrdRow) then begin
                if (CopyPUrwToRetPUrw(PUr,PUrw,pui,RetPUp,RetPUp.VECode,RetPUrw)) then begin
                  if (firstf) then begin
                    firstf = false;
                    MatRowPut(RetPUp,currow,RetPUrw);
                    currow = currow + 1;
                  end else begin
                    MatRowInsert(RetPUp,currow,RetPUrw);
                    currow = currow + 1;
                  end;
                  retval = 0;
                  rem = rem - PUrw.Quant;
                  if (rem<=0) then begin 
                    found = false; 
                    found2 = false;
                  end else begin
                    found2 = true;
                  end;
                end else begin
                  retval = 5;
                  goto LPastePORowInRetPU;
                end;                  
              end;
            end;
          end;
        end;
        if (found2==false) then begin loopf = false; end;
      end;  

      if (rem>0) then begin loopf = true; end;
      found2 = false;
      while (loopf) begin
        found = true;
        ResetLoop(PUr);      
        keystr = "RowPONr:" & POr.SerNr;
        while (LoopKey(keystr,PUr,1,found)) begin
          if (found) then begin
            purwcnt = MatRowCnt(PUr);
            for (pui=0;pui<purwcnt;pui=pui+1) begin
              MatRowGet(PUr,pui,PUrw);
              if (PUrw.OrdRow==OrdRow) and (PUrw.PONr==POr.SerNr) then begin
                if (CopyPUrwToRetPUrw(PUr,PUrw,pui,RetPUp,RetPUp.VECode,RetPUrw)) then begin
                  if (firstf) then begin
                    firstf = false;
                    MatRowPut(RetPUp,currow,RetPUrw);
                    currow = currow + 1;
                  end else begin
                    MatRowInsert(RetPUp,currow,RetPUrw);
                    currow = currow + 1;
                  end;

                  retval = 0;
                  rem = rem - PUrw.Quant;
                  if (rem<=0) then begin 
                    found = false; 
                    found2 = false;
                  end else begin
                    found2 = true;
                  end;
                end else begin
                  retval = 5;
                  goto LPastePORowInRetPU;
                end;                  
              end;
            end;
          end;
        end;
        if (found2==false) then begin loopf = false; end;
        end;
      
    end;
  end;
LPastePORowInRetPU:;
  PastePORowInRetPU = retval;
  return;
end;

global
function Integer RetPUVc_PasteOrdRow(var record RetPUVc RetPUp,Integer rownr,Boolean changedf)
begin
  row RetPUVc RetPUrw;
  Integer retval;
  Integer i,rwcnt;
  
  if (rownr>=0) then begin
    MatRowGet(RetPUp,rownr,RetPUrw);
    retval = PastePORowInRetPU(RetPUp,RetPUrw.PONr,RetPUrw.OrdRow,rownr);
    RetPUSumUp(RetPUp);
  end;
  switch (retval) begin
    case 1: retval = 20407;
    case 2: retval = 1215;
    case 3: retval = 1138;
    case 4: retval = 1026;
    case 5: retval = 1459;  
  end;
  RetPUVc_PasteOrdRow = retval;
  return;
end;

global
function Integer RetPUVc_PastePUNr(var record RetPUVc RetPUp,Integer rownr)
begin
  row RetPUVc RetPUrw;
  record PUVc PUr;
  Integer res;

  if (rownr>=0) then begin
    MatRowGet(RetPUp,rownr,RetPUrw);
    if (RetPUrw.PUNr>0) then begin
      PUr.SerNr = RetPUrw.PUNr;
      if (ReadFirstMain(PUr,1,true)==false) then begin
        res = 1290;
      end;
    end;
  end;
  RetPUVc_PastePUNr = res;
  return;
end;

function Integer PastePURowInRetPU(var record RetPUVc RetPUp,Integer retpurownr)
begin
  Integer retval;
  record POVc POr;
  record PUVc PUr;
  row PUVc PUrw;
  Integer PURow;
  Integer i,purwcnt,retpurowcnt,currow;
  row RetPUVc RetPUrw;
  Boolean firstf;
  
  MatRowGet(RetPUp,retpurownr,RetPUrw);
  PUr.SerNr = RetPUrw.PUNr;
  if (ReadFirstMain(PUr,1,true)) then begin
    if (RetPUp.VECode==PUr.VECode) or (blank(RetPUp.VECode)) then begin
      firstf = true;
      currow = retpurownr;
      if (RetPUrw.PURow>=0) then begin
        PURow = RetPUrw.PURow  - 1;
      end else begin
        PURow = RetPUrw.PURow;
      end;
      purwcnt = MatRowCnt(PUr);
      retpurowcnt = MatRowCnt(RetPUp);
      if (PURow==-1) then begin
        if (((purwcnt+(retpurowcnt-1)) > 199) or (PURow >=purwcnt)) then begin
          retval = 1;
          goto LPastePURowInRetPU;
        end;
        for (i=0;i<purwcnt;i=i+1) begin
          ClearRow(RetPUp,RetPUrw,1);
          MatRowGet(PUr,i,PUrw);        
          if (CopyPUrwToRetPUrw(PUr,PUrw,i,RetPUp,RetPUp.VECode,RetPUrw)) then begin
            if (firstf) then begin
              firstf = false;
              MatRowPut(RetPUp,currow,RetPUrw);
              currow = currow + 1;
            end else begin
              MatRowInsert(RetPUp,currow,RetPUrw);
              currow = currow + 1;
            end;
          end else begin
  //          retval = 5;//just skip received rows
          end;
        end;
      end else begin
        if (PURow>=purwcnt) then begin
          retval = 5;
          goto LPastePURowInRetPU;
        end;  
        if (PURow<0) then begin
          retval = 5;
          goto LPastePURowInRetPU;
        end;
        ClearRow(RetPUp,RetPUrw,1);
        MatRowGet(PUr,PURow,PUrw);
        if (CopyPUrwToRetPUrw(PUr,PUrw,PURow,RetPUp,RetPUp.VECode,RetPUrw)) then begin
          MatRowPut(RetPUp,currow,RetPUrw);
        end else begin
          retval = 5;
        end;
      end;
    end;
  end;
LPastePURowInRetPU:;
  PastePURowInRetPU = retval;
  return;
end;

global
function Integer RetPUVc_PastePURow(var record RetPUVc RetPUp,Integer rownr,Boolean changedf)
begin
  Integer res;
  
  if (rownr>=0) then begin
    res = PastePURowInRetPU(RetPUp,rownr);
    RetPUSumUp(RetPUp);
  end;
  RetPUVc_PastePURow = res;
  return;
end;

global
procedure RetPUVc_PasteSerialNr(var record RetPUVc RetPUp,Integer rownr,var string warning)
BEGIN
  row RetPUVc RetPUrw;
  record BatchTextVc btr;
  string 255 tstr;
  val UnitXval,UnitYval,UnitZval;
  record SerBalVc SBr;
  Boolean serialfound;
  record ItemHistVc sourceIHr;
  record INVc INr;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  warning = "";
  MatRowGet(RetPUp,rownr,RetPUrw);
  if (blank(RetPUrw.ArtCode)) then begin 
    if (SerialNrForOneItem(RetPUrw.SerialNr,SBr)) then begin
      RetPUrw.ArtCode = SBr.Item;
      RetPUrw.Quant = 1;
      if blank(RetPUp.Location) then begin 
        RetPUp.Location = SBr.Location;
      end;
      RetPUrw.PosCode = FindPositionWithSerialNr(RetPUp.Location,RetPUrw.ArtCode,RetPUrw.SerialNr,RetPUrw.Location);
      MatRowPut(RetPUp,rownr,RetPUrw);
      if (RetPUVc_PasteArtCode(RetPUp,rownr,1,false)) then begin
      end;   
      MatRowGet(RetPUp,rownr,RetPUrw);
      
      sourceIHr.ArtCode = RetPUrw.ArtCode;
      sourceIHr.SerialNr = RetPUrw.SerialNr;
      sourceIHr.FileName = "PUVc";
      if (ReadLastKey("ArtCodeSerialNr",sourceIHr,3,true)) then begin
        RetPUrw.PUNr = sourceIHr.TransNr;
        RetPUrw.PURow = sourceIHr.Row + 1;
        MatRowPut(RetPUp,rownr,RetPUrw);
        RetPUVc_PastePURow(RetPUp,rownr,true);      
        MatRowGet(RetPUp,rownr,RetPUrw);
        RetPUrw.Location = SBr.Location;
      end;
    end;
  end else begin
    ReadFirstItem(RetPUrw.ArtCode,INr,true,true);
    if (nonblank(RetPUrw.ArtCode)) and (INr.SerNrf==1) then begin
      if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,true,RetPUrw.ArtCode,RetPUrw.SerialNr,RetPUrw.Quant)) then begin
        MatRowPut(RetPUp,rownr,RetPUrw);
        MatRowGet(RetPUp,rownr,RetPUrw);
      end;
    end;
  end;
  if ((SNrb.BulkSerialNos==0) or (InString(RetPUrw.SerialNr,":")==0)) then begin
    SerialNrDimensions(RetPUrw.ArtCode,RetPUrw.SerialNr,UnitXval,UnitYval,UnitZval);
    if (UnitXval!=0) then begin RetPUrw.UnitXval = UnitXval; end;
    if (UnitYval!=0) then begin RetPUrw.UnitYval = UnitYval; end;
    if (UnitZval!=0) then begin RetPUrw.UnitZval = UnitZval; end;
    if (CheckSerialStatus(RetPUrw.ArtCode,RetPUrw.SerialNr,tstr)==1) then begin
      warning = tstr;
    end;    
    if (serialfound==false) then begin 
      RetPUrw.Quant = CalculateSerialNrQuantity(RetPUrw.ArtCode,"","",false,RetPUrw.UnitXval,RetPUrw.UnitYval,RetPUrw.UnitZval,RetPUrw.Quant);
    end;
  end;
  MatRowPut(RetPUp,rownr,RetPUrw);
  RetPUSumUp(RetPUp);
  RETURN;
END;

global
procedure RetPUVc_PasteLocation(var record RetPUVc RetPUr,Integer rownr)
begin
  if (rownr==-1) then begin
    RetPUr.Sorting = FindCustRoute(RetPUr.VECode,RetPUr.Location,RetPUr.DelAddrCode);
  end;
  return;
end;

global
procedure RetPUVc_PasteQuant(var record RetPUVc RetPUr,Integer rownr)
begin
  row RetPUVc RetPUrw;
  record INVc INr;
  record SerNrTrackBlock SNrb;
  record RoundBlock ROb;

  BlockLoad(SNrb);
  BlockLoad(ROb);
  MatRowGet(RetPUr,rownr,RetPUrw);
  ReadFirstItem(RetPUrw.ArtCode,INr,true,true);
  if (nonblank(RetPUrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,true,RetPUrw.ArtCode,RetPUrw.SerialNr,RetPUrw.Quant)) then begin
      MatRowPut(RetPUr,rownr,RetPUrw);
      MatRowGet(RetPUr,rownr,RetPUrw);
    end;
  end;
  RetPUrw.FIFORowVal = Round(RetPUrw.FIFO*RetPUrw.Quant,GetCostRoundMode(ROb));
  MatRowPut(RetPUr,rownr,RetPUrw);
  RetPUSumUp(RetPUr);
  return;
end;

global
updating procedure RetPUVcRecordUpdateClientRemote(record RetPUVc RetPUr,record RetPUVc RetPU2r,string TaxAdminServSeal)
begin
  if (HasLocalization("PRT")) then begin
    StoreeShipTaxAuthReply("RetPUVc",RetPUr.SerNr,RetPUr.OfficialSerNr,TaxAdminServSeal);
  end;
  return;
end;