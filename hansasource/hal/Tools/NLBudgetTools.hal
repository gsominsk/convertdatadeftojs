external function Integer GetLocalCompanyNr(string,Boolean);
external procedure Base1ToBase2(var val,Date,var val);
external function val DivWithRateToBase1(string,Date,val,roundmode);
external function LongInt DateDiff(Date,Date);

function val AddBudVal(Integer basecurncy,date psdp,date pedp,date bsdp,date bedp,var val bvp)
begin
  LongInt bpl,mpl;
  Date bd,ed;
  val a,b,c;
  val res;
  
  res = 0;
  if (nonblankdate(bedp)) then begin//??
    if (psdp>bedp) then begin goto BudEnd; end;
  end;  
  if (pedp<bsdp) then begin goto BudEnd; end;
  if ((bsdp>=psdp) and (bedp<=pedp)) then begin
    if (basecurncy!=0) then begin
      Base1ToBase2(bvp,bsdp,b);
      res = res + b;
    end else begin
      res = res + bvp;
    end;
    goto BudEnd;
  end;
  bpl = DateDiff(bedp,bsdp);
  bd = bsdp;
  ed = bedp;
  if (psdp>bsdp) then begin bd = psdp; end;
  if (pedp<bedp) then begin ed = pedp; end;
  mpl = DateDiff(ed,bd);
  a = bpl;
  b = mpl;
  c = b * bvp;
  b = c / a;
  if (basecurncy!=0) then begin
    Base1ToBase2(b,bsdp,b);
  end;
  res = res + b;
BudEnd:;
  AddBudVal = res;
  return;
end;

/* Commented this out and just copied Bugd1 for Budg2 for Consolidation
global
function val Budg2Calc(string accstr,string objs,string crncycode,Date sdp,Date edp)
BEGIN
  record Bud2Vc Bud2r;
  row Bud2Vc Bud2rw;
  row Bud2Vc Bud22rw;
  Integer i,rwcnt;
  Boolean TrHs;
  Date sd,ed;
  Date curdat;
  val res;

  res = 0;
  curdat = CurrentDate;
  Bud2r.AccNumber = accstr;
  Bud2r.Objects = objs;
  TrHs = true;
  while (LoopMain(Bud2r,2,TrHs)) begin
    if (TrHs) then begin
      if (Bud2r.AccNumber<>accstr) then begin TrHs = false; end;
      if (Bud2r.Objects<>objs) then begin TrHs = false; end;
    end;
    if (TrHs) then begin
      curdat = Bud2r.StartDate;
      rwcnt = MatRowCnt(Bud2r);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Bud2r,i,Bud2rw);
        sd = Bud2rw.BudDate;
        if (BlankDate(sd)) then begin
          goto BudCalcEnd2;
        end;  
        if (i<(rwcnt-1)) then begin
          MatRowGet(Bud2r,i+1,Bud22rw);
          ed = Bud22rw.BudDate;
          if (BlankDate(ed)) then begin
            ed = Bud2r.EndDate;
          end else begin
            ed = AddDay(ed,-1);
          end;
        end else begin
          ed = Bud2r.EndDate;
        end;  
        res = res + AddBudVal(sdp,edp,sd,ed,Bud2rw.sval);        
      end;
BudCalcEnd2:;
    end;
  end;
  if (nonblank(crncycode)) then begin    
    res = DivWithRateToBase1(crncycode,curdat,res,DefaultCurRoundOff);
  end;    
  Budg2Calc = res;
  RETURN;
END;
*/

function val Budg2CalcVal(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer sorting)
BEGIN
  string 60 fracc,toacc;
  record Bud2Vc Bud2r;
  row Bud2Vc Bud2rw;
  row Bud2Vc Bud22rw;
  Integer i,rwcnt;
  Boolean TrHs,testf;
  Date sd,ed;
  Date curdat;
  val res,t;
  string 255 keystr;
  Integer segs;

  transaction string 5 keycurcod;
  transaction record RcVc KeyRepSpec;
  transaction string 255 gKeyRn_columncod;
  transaction record TRVc gKeyRn_TRr;
  row TRVc TRrw;
  Integer tri,trrwcnt;
  
  fracc = FirstInRange(accstr,20);
  toacc = LastInRange(accstr,20);
  curdat = CurrentDate;
  switch (sorting) begin
    case 1:
      Bud2r.Objects = objs;
      keystr = "ObjAccKey";
      segs = 1;
    otherwise
      Bud2r.AccNumber = fracc;
      Bud2r.Objects = objs;
      keystr = "AccObjKey";
      segs = 2;
  end;
  TrHs = true;
  while (LoopKey(keystr,Bud2r,segs,TrHs)) begin
    if (TrHs) then begin
      switch (sorting) begin
        case 1:
          if (Bud2r.Objects<>objs) then begin TrHs = false; end;
        otherwise
          if (Bud2r.AccNumber<fracc) then begin TrHs = false; end;
          if (Bud2r.AccNumber>toacc) then begin TrHs = false; end;
          if (Bud2r.Objects<>objs) then begin TrHs = false; end;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      switch (sorting) begin
        case 1:
          if (Bud2r.AccNumber<fracc) or (Bud2r.AccNumber>toacc) then begin testf = false; end;
      end;
      if (Bud2r.Class!=class) then begin testf = false; end;
      if (testf) then begin
        t = 0;
        curdat = Bud2r.StartDate;
        rwcnt = MatRowCnt(Bud2r);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Bud2r,i,Bud2rw);
          sd = Bud2rw.BudDate;
          if (BlankDate(sd)) then begin goto LBudg2CalcVal; end;
          if (i<(rwcnt-1)) then begin
            MatRowGet(Bud2r,i+1,Bud22rw);
            ed = Bud22rw.BudDate;
            if (BlankDate(ed)) then begin
              ed = Bud2r.EndDate;
            end else begin  
              ed = AddDay(ed,-1);
            end;
          end else begin
            ed = Bud2r.EndDate;
          end;
          t = t + AddBudVal(basecurncy,sdp,edp,sd,ed,Bud2rw.sval);
        end;
/*        
        if (basecurncy!=0) then begin
          Base1ToBase2(t,Bud2r.StartDate,t);
        end;  
*/        
        if (KeyRepSpec.critname=="KeyRClass") then begin
        switch (KeyRepSpec.AccSpec) begin
          case 4:
            if (t!=0) then begin
              trrwcnt = MatRowCnt(gKeyRn_TRr);
              for (tri=0;tri<trrwcnt;tri=tri+1) begin
                MatRowGet(gKeyRn_TRr,tri,TRrw);

                if (TRrw.TFromFileName==gKeyRn_columncod) then begin
                  TRrw.AccNumber = Bud2r.AccNumber;
                  TRrw.Comment = Bud2r.Comment;
                  TRrw.Objects = objs;
                  TRrw.VATCode = "";
                  TRrw.DebVal = -t;
                  MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
                  SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,-t);
                end;
              end;
            end;
        end;  
        end;
        
        res = res + t;
      end;
LBudg2CalcVal:;
    end;
  end;      
  if (nonblank(crncycode)) then begin    
    res = DivWithRateToBase1(crncycode,curdat,res,DefaultCurRoundOff);
  end;
  Budg2CalcVal = res;
  RETURN;
END;

function val Budg2CalcDaughters(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer sorting)
BEGIN
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCrw;
  record ConsolidationBlock cr;
  record AccVc Accr;
  Boolean Accs,testf;
  Integer i,rwcnt;
  Integer oldcomp;
  val res;

  oldcomp = CurrentCompany;  
  BlockLoad(DCb);
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCrw);
    if (SetCompanyCode(DCrw.CompCode,false)) then begin
      BlockLoad(cr);
      res = res + Budg2CalcVal(accstr,objs,crncycode,class,sdp,edp,cr.ConsCrncy,sorting);
/*
is it needed at all ? 
if AccNumber is in report definition
it is taken again as ConsAccNumber
      Accr.ConsAccNumber = accstr;
      Accr.AccNumber = "";
      Accs = true;
      ResetLoop(Accr);
      while (LoopKey("ConsAccNumber",Accr,1,Accs)) begin
        if (Accr.ConsAccNumber<>accstr) then begin Accs = false; end;
        if (Accs) then begin
          if (Accr.AccNumber!=accstr) then begin
            res = res + Budg2CalcVal(Accr.AccNumber,objs,crncycode,sdp,edp,cr.ConsCrncy);
          end;
        end;
      end;
*/
    end;
  end;
  ResetCompany(oldcomp);
  Budg2CalcDaughters = res;
  RETURN;
END;

global
function val Budg2Calc2(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter,Integer sorting)
begin
  val res;

  res = Budg2CalcVal(accstr,objs,crncycode,class,sdp,edp,basecurncy,sorting);
  if (IncDaughter<>0) then begin
    res = res + Budg2CalcDaughters(accstr,objs,crncycode,class,sdp,edp,basecurncy,sorting);
  end;  
  Budg2Calc2 = res;
  return;
end;

global
function val Budg2Calc(string accstr,string objs,string crncycode,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter,Integer sorting)
begin
  Budg2Calc = Budg2Calc2(accstr,objs,crncycode,"",sdp,edp,basecurncy,IncDaughter,sorting);
  return;
end;

function val Budg1CalcVal(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer sorting)
BEGIN
  string 60 fracc,toacc;
  record Bud1Vc Bud1r;
  row Bud1Vc Bud1rw;
  row Bud1Vc Bud12rw;
  Integer i,rwcnt;
  Boolean TrHs,testf;
  Date sd,ed;
  Date curdat;
  val res,t;
  string 255 keystr;
  Integer segs;

  transaction string 5 keycurcod;
  transaction record RcVc KeyRepSpec;
  transaction string 255 gKeyRn_columncod;
  transaction record TRVc gKeyRn_TRr;
  row TRVc TRrw;
  Integer tri,trrwcnt;
  
  fracc = FirstInRange(accstr,20);
  toacc = LastInRange(accstr,20);
  curdat = CurrentDate;
  switch (sorting) begin
    case 1:
      Bud1r.Objects = objs;
      keystr = "ObjAccKey";
      segs = 1;
    otherwise
      Bud1r.AccNumber = fracc;
      Bud1r.Objects = objs;
      keystr = "AccObjKey";
      segs = 2;
  end;
  TrHs = true;
  while (LoopKey(keystr,Bud1r,segs,TrHs)) begin
    if (TrHs) then begin
      switch (sorting) begin
        case 1:
          if (Bud1r.Objects<>objs) then begin TrHs = false; end;
        otherwise
          if (Bud1r.AccNumber<fracc) then begin TrHs = false; end;
          if (Bud1r.AccNumber>toacc) then begin TrHs = false; end;
          if (Bud1r.Objects<>objs) then begin TrHs = false; end;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      switch (sorting) begin
        case 1:
          if (Bud1r.AccNumber<fracc) or (Bud1r.AccNumber>toacc) then begin testf = false; end;
      end;
      if (Bud1r.Class!=class) then begin testf = false; end;
      if (testf) then begin
        t = 0;
        curdat = Bud1r.StartDate;
        rwcnt = MatRowCnt(Bud1r);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Bud1r,i,Bud1rw);
          sd = Bud1rw.BudDate;
          if (BlankDate(sd)) then begin goto LBudg1CalcVal; end;
          if (i<(rwcnt-1)) then begin
            MatRowGet(Bud1r,i+1,Bud12rw);
            ed = Bud12rw.BudDate;
            if (BlankDate(ed)) then begin
              ed = Bud1r.EndDate;
            end else begin  
              ed = AddDay(ed,-1);
            end;
          end else begin
            ed = Bud1r.EndDate;
          end;
          t = t + AddBudVal(basecurncy,sdp,edp,sd,ed,Bud1rw.sval);
        end;
/*
budget start date ?         
        if (basecurncy!=0) then begin
          Base1ToBase2(t,Bud1r.StartDate,t);
        end;  
*/        
        if (KeyRepSpec.critname=="KeyRClass") then begin
        switch (KeyRepSpec.AccSpec) begin
          case 4:
            if (t!=0) then begin
              trrwcnt = MatRowCnt(gKeyRn_TRr);
              for (tri=0;tri<trrwcnt;tri=tri+1) begin
                MatRowGet(gKeyRn_TRr,tri,TRrw);

                if (TRrw.TFromFileName==gKeyRn_columncod) then begin
                  TRrw.AccNumber = Bud1r.AccNumber;
                  TRrw.Comment = Bud1r.Comment;
                  TRrw.Objects = objs;
                  TRrw.VATCode = "";
                  TRrw.DebVal = -t;
                  MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
                  SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,-t);
                end;
              end;
            end;
        end;  
        end;
        
        res = res + t;
      end;
LBudg1CalcVal:;
    end;
  end;      
  if (nonblank(crncycode)) then begin    
    res = DivWithRateToBase1(crncycode,curdat,res,DefaultCurRoundOff);
  end;
  Budg1CalcVal = res;
  RETURN;
END;

function val Budg1CalcDaughters(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer sorting)
BEGIN
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCrw;
  record ConsolidationBlock cr;
  record AccVc Accr;
  Boolean Accs,testf;
  Integer i,rwcnt;
  Integer oldcomp;
  val res;

  oldcomp = CurrentCompany;  
  BlockLoad(DCb);
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCrw);
    if (SetCompanyCode(DCrw.CompCode,false)) then begin
      BlockLoad(cr);
      res = res + Budg1CalcVal(accstr,objs,crncycode,class,sdp,edp,cr.ConsCrncy,sorting);
      res = res + Budg1CalcDaughters(accstr,objs,crncycode,class,sdp,edp,basecurncy,sorting);
/*
is it needed at all ? 
if AccNumber is in report definition
it is taken again as ConsAccNumber
      Accr.ConsAccNumber = accstr;
      Accr.AccNumber = "";
      Accs = true;
      ResetLoop(Accr);
      while (LoopKey("ConsAccNumber",Accr,1,Accs)) begin
        if (Accr.ConsAccNumber<>accstr) then begin Accs = false; end;
        if (Accs) then begin
          if (Accr.AccNumber!=accstr) then begin
            res = res + Budg1CalcVal(Accr.AccNumber,objs,crncycode,sdp,edp,cr.ConsCrncy);
          end;
        end;
      end;
*/
    end;
  end;
  ResetCompany(oldcomp);
  Budg1CalcDaughters = res;
  RETURN;
END;

global
function val Budg1Calc2(string accstr,string objs,string crncycode,string class,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter,Integer sorting)
begin
  val res;

  res = Budg1CalcVal(accstr,objs,crncycode,class,sdp,edp,basecurncy,sorting);
  if (IncDaughter<>0) then begin
    res = res + Budg1CalcDaughters(accstr,objs,crncycode,class,sdp,edp,basecurncy,sorting);
  end;  
  Budg1Calc2 = res;
  return;
end;

global
function val Budg1Calc(string accstr,string objs,string crncycode,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter,Integer sorting)
begin
  Budg1Calc = Budg1Calc2(accstr,objs,crncycode,"",sdp,edp,basecurncy,IncDaughter,sorting);
  return;
end;
