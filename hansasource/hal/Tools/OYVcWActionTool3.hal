external function roundmode DefaultRoundMode();
external procedure CalcProc(val,val,var val);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure SendArtStat(string,string,string,val,val,val,Date,Integer);

global
procedure OYDchsum(record OYVc OYr,Integer rownr)
begin
  row OYVc OYrw;
  row OYVc OY2rw;
  val t,s;
  val rowinbase;
  val tproc;
  val unitprdisc;
  string 60 location;
  record TaxMatrixVc TMr;
  val gp;
  Integer i,rwcnt;

  if (rownr>=0) then begin
    MatRowGet(OYr,rownr,OYrw);
  end;
  OYr.TotGP = OYr.TotGP - OYrw.rowGP;
  location = "";
  unitprdisc = BlankVal;
  t = OYrw.Quant * OYrw.BasePrice;
  if (OYrw.PriceFactor<>0) then begin
    t = t / OYrw.PriceFactor;
  end;
  s = MulRateToBase1(OYr.CurncyCode,OYrw.Sum,OYr.FrRate,OYr.ToRateB1,OYr.ToRateB2,OYr.BaseRate1,OYr.BaseRate2,DefaultCurRoundOff);
  UnpackRowFieldMatrix(OYrw,"TaxMatrix",TMr);
  FindSalesExVat(TMr,OYrw.VATCode,s,OYr.InclVAT,OYr.NoTAXonVAT,rowinbase);
  OYrw.rowGP = rowinbase - t;
  unitprdisc = Round(OYrw.Sum / OYrw.Quant,DefaultRoundMode);
  if (rownr>=0) then begin
    MatRowPut(OYr,rownr,OYrw);
  end;
  gp = OYrw.rowGP;
  rwcnt = MatRowCnt(OYr);  
  for (i=rownr+1;i<rwcnt;i=i+1) begin
    MatRowGet(OYr,i,OY2rw);
    switch (OY2rw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        if (OY2rw.MotherArtCode==OYrw.ArtCode) then begin
          gp = gp + OY2rw.rowGP;
        end;
      otherwise
        i = rwcnt;
    end;
  end;    
  CalcProc(rowinbase,gp,tproc);
  SendArtStat(OYrw.ArtCode,location,"",gp,tproc,unitprdisc,OYr.OYDate,1);
  return;
end;
