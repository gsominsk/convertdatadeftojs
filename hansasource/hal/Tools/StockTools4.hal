external function Integer SDApprovalStatus(record SDVc,var record AcceptanceRulesVc);
external function Integer IVApprovalStatus(record IVVc,var record AcceptanceRulesVc);
external function Integer PUApprovalStatus(record PUVc,var record AcceptanceRulesVc);
external procedure GetItemStatusSupersessions(string,string,string,Integer,var val,var val,var val,var val,var val,var val,var val);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function roundmode SetRoundModeD(Integer);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function roundmode GetCostRoundMode(record RoundBlock);
external updating procedure SetPositionStatus(string,Integer);
external updating procedure PUOvstUpdateNLTransaction(Date,LongInt,val,var Boolean);
external updating procedure PurUpdateCostPrice(record PUVc,Boolean);
external updating procedure UpdateSerStock(string,string,string,val,val);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external function Boolean TestArtCode(string,string,record INVc);
external updating procedure UpdateLocationWeightedAv(string,string,val,val,val,val,Boolean);
external procedure Base1ToBase2(var val,Date,var val);
external procedure ExpandStructure(record INVc,string,string,Integer,var val,var val,Boolean);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure FindStockValue(string,string,var record ItemStatusVc);

function val ItemDeliveryPositionQty(string location,string item)
begin
  val res;
  record LocationVc Locr;
  record PISVc PISr;
  
  Locr.Code = location;
  ReadFirstMain(Locr,1,true);
  if (Locr.RequirePos==0) then begin
    PISr.ArtCode = item;
    PISr.Position = Locr.WHMDeliveryPosCode;
    if (ReadFirstMain(PISr,2,true)) then begin
      res = PISr.Instock;
    end;
  end;
  ItemDeliveryPositionQty = res;
  return;
end;

global
function Boolean GetItemStatus(string item,string location,string arecepy,Integer inclsupersessin,var val stockp,var val ordp,var val purchp,var val unitcoefficientp,var val prodordp,var val rsrv,var val inprice)
begin
  record ItemStatusVc ISr;
  record INVc INr;
  record MainStockBlock MSb;
  Boolean foundf;
  val stocksin,ordsin,purchsin,unitcoefficientsin,prodordsin,rsrvsin,q;
  string 255 recepy;

  foundf = false;
  BlockLoad(MSb);
  stockp = BlankVal;
  ordp = BlankVal;
  purchp = BlankVal;
  prodordp = BlankVal;
  rsrv = blankval;
  if (ReadFirstItem(item,INr,true,false)) then begin
    inprice = INr.InPrice;
    foundf = true;
    recepy = arecepy;
    if (blank(recepy)) then begin
      recepy = INr.Recepy;
    end;
    if ((INr.ItemType==kItemTypeStructured) and (nonblank(recepy))) then begin
      ExpandStructure(INr,recepy,location,MSb.UpdateAvailable,stockp,ordp,false);
      FindStockValue(item,location,ISr);
      ordp = ISr.OrddOut;
    end else begin
      FindStockValue(item,location,ISr);
      switch (MSb.UpdateAvailable) begin
        case 0:
          stockp = ISr.Instock - ItemDeliveryPositionQty(location,item);
          ordp = ISr.OrddOut;
          purchp = ISr.POUnOKQty;
        case 1:
          stockp = ISr.Instock - ISr.InShipment - ItemDeliveryPositionQty(location,item);
          ordp = ISr.OrddOut - ISr.InShipment;
          if (ordp<0) then begin ordp = blankval; end; //can hapen in case of order with blank location and delievry for other location
          purchp = ISr.POUnOKQty;
      end;
      if (inclsupersessin) then begin
        GetItemStatusSupersessions(item,location,recepy,inclsupersessin,stocksin,ordsin,purchsin,unitcoefficientsin,prodordsin,rsrvsin,inprice);
        stockp = stockp + stocksin;
        ordp = ordp + ordsin;
        purchp = purchp + purchsin;
        prodordp = prodordp + prodordsin;
        rsrv = rsrv + rsrvsin;
      end;
    end;

    unitcoefficientp = INr.UnitCoefficient;
    prodordp = ISr.ProdOrd;
    switch (MSb.UpdateAvailable) begin
      case 0:
        rsrv = ISr.RsrvQty + ISr.StockRsrvQty;
      case 1:
        q = ISr.RsrvQty + ISr.StockRsrvQty - ISr.InShipment;
        if (q>0) then begin
          rsrv = q;
        end;
    end;
  end;
  GetItemStatus = foundf;
  return;
end;

global
function val ItemInStock(var record INVc INr,string alocation)
begin
  val res;
  record ItemStatusVc ISr;
  record MainStockBlock MSb;
  val ord;
  Boolean found;
  string 255 location;
  
  ISr.Code = INr.Code;
  if (alocation<>"") then begin
    location = alocation;
  end else begin
    BlockLoad(MSb);
    location = MSb.MainStock;
  end;
  if ((INr.ItemType==2) and (nonblank(INr.Recepy))) then begin
    ExpandStructure(INr,INr.Recepy,location,MSb.UpdateAvailable,res,ord,true);
  end else begin 
    found = true;
    ISr.Code = INr.Code;
    ISr.Location = location;
    while (LoopMain(ISr,2,found)) begin
      if (ISr.Code!=INr.Code) then begin found = false; end;
      if (ISr.Location!=location) then begin found = false; end;
      if (found) then begin
        res = res + ISr.Instock;
      end;
    end; 
/*  
    if (ReadFirstMain(ISr,2,true)) then begin
      res = ISr.Instock;
    end;
*/    
  end;
  ItemInStock = res;
  return;
end;

function
Boolean CheckIfUpdateLockOKNr(record WSVc WSp)
BEGIN
  record INVc INr;
  row WSVc WSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    INr.Code = WSrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1 /*or INr.ItemType==2*/) then begin/*structured or stocked*/
        res = true;
        goto LCheckIfUpdateLockOKNr;
      end;// only stockeditems, structured are not allowd right now
    end;
  end;  
LCheckIfUpdateLockOKNr:;
  CheckIfUpdateLockOKNr = res;
  RETURN;
END;

function Date GetLaterDate(Date d1,Date d2)
begin
  Date res;
  
  if (d1>d2) then begin
    res = d1;
  end else begin
    res = d2;
  end;
  
  GetLaterDate = res;
  return;
end;

global
function Boolean ExistStockTrans(string location,Date dp,var Integer errcode,var string errstr,
                                 string fnr,LongInt SerNr,record MainStockBlock MainStockRec)
begin
  record PUVc PUr;
  record ProdVc Prodr;
  record StockMovVc SMr;
  record SHVc SHr;
  record SDVc SDr;
  record SRVc SRr;
  record IVVc IVr;
  record WSVc WSr;
  record RetVc Retr;
  record RetPUVc RetPUr;
  record IVCashVc IVCashr;
  record LocationVc Locr;
  Boolean res,matchf;
  string 255 keystr;
  Integer keys,approvalstatus;
  Date earliestdate;
  record AcceptanceRulesVc Acptr;

  errstr = "";
  switch (MainStockRec.Chronology) begin
    case 0: goto LExistStockTrans;
    case 1: matchf = true; keystr = "LocOK";
    case 2: matchf = false; keystr = "OKFlagTransDate";
  end;
  Locr.Code = location;
  if (ReadFirstMain(Locr,1,true)) then begin
    if (Locr.IgnoreChronology!=0) then begin goto LExistStockTrans; end;
  end;
//This procedure checks if there exists earlier not NotOKed stock transactions  and 
//later OKed transations
//locationperrow  
  if (MainStockRec.ChronologyOkOnly==0) then begin
    RetPUr.Location = location;
    PUr.Location = location;
    Prodr.Location = location;
    SMr.FrLocation = location;
    SHr.Location = location;
    SDr.Location = location;
    SRr.Location = location;
    IVr.Location = location;
    WSr.Location = location;
    Retr.Location = location;
    IVCashr.Location = location;
    IVr.UpdStockFlag = 1;
    Retr.UpdStockFlag = 1;
    RetPUr.OKFlag = 0;
    PUr.OKFlag = 0;
    Prodr.FinnishedFlag = 0;
    SMr.OKFlag = 0;
    SHr.OKFlag = 0;
    SDr.OKFlag = 0;
    SRr.OKFlag = 0;
    IVr.OKFlag = 0;
    WSr.OKFlag = 0;
    Retr.OKFlag = 0;
    IVCashr.OKFlag = 0;  
    if (ReadFirstKey(keystr,WSr,2,matchf) and (WSr.OKFlag==0) and
      (WSr.TransDate<dp) and ((fnr!="WSVc") or (WSr.SerNr!=SerNr))) then begin
      if (CheckIfUpdateLockOKNr(WSr)) then begin
        errcode = 1997;
        res = true;
        goto LExistStockTrans;
      end;
    end;
    if (ReadFirstKey(keystr,RetPUr,2,matchf) and (RetPUr.OKFlag==0) and
      (RetPUr.TransDate<dp) and ((fnr!="RetPUVc") or (RetPUr.SerNr!=SerNr))) then begin
      errcode = 20595;
      res = true;
      goto LExistStockTrans;
    end;
    if (ReadFirstKey(keystr,PUr,2,matchf) and (PUr.OKFlag==0) and
      (PUr.TransDate<dp) and ((fnr!="PUVc") or (PUr.SerNr!=SerNr))) then begin
      approvalstatus = PUApprovalStatus(PUr,Acptr);
      if (approvalstatus!=kAcceptanceStateRejected) then begin
        errcode = 1985;
        res = true;
        goto LExistStockTrans;
      end;
    end;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "LocOK";
      case 2: keystr = "FinnishedFlagProdDate";
    end;
    if (ReadFirstKey(keystr,Prodr,2,matchf) and (Prodr.PRStatusFlag==0) and
      (Prodr.ProdDate<dp) and ((fnr!="ProdVc") or (Prodr.SerNr!=SerNr))) then begin
      errcode = 1986;
      res = true;
      goto LExistStockTrans;
    end;
  
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "FrLocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    if (ReadFirstKey(keystr,SMr,2,matchf) and (SMr.OKFlag==0) and
      (SMr.TransDate<dp) and (nonblankdate(SMr.TransDate)) and ((fnr!="StockMovVc") or (SMr.SerNr!=SerNr))) then begin
      errcode = 1987;
      res = true;
      goto LExistStockTrans;
    end;
  
    SMr.FrLocation = location;
    SMr.SentOKFlag = 0;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "FrLocSentOK";
      case 2: keystr = "SentOKFlagSentTransDate";
    end;
    if (ReadFirstKey(keystr,SMr,2,matchf) and (SMr.SentOKFlag==0) and (nonblank(SMr.ThrouLocation)) and
      ((SMr.TransDate<dp) and (nonblankdate(SMr.TransDate))) and ((fnr!="StockMovVc") or (SMr.SerNr!=SerNr))) then begin
      errcode = 1987;
      res = true;
      goto LExistStockTrans;
    end;
  
    SMr.ToLocation = location;
    SMr.OKFlag = 0;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "ToLocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    if (ReadFirstKey(keystr,SMr,2,matchf) and (SMr.OKFlag==0) and
      (SMr.TransDate<dp) and (nonblankdate(SMr.TransDate)) and ((fnr!="StockMovVc") or (SMr.SerNr!=SerNr))) then begin
      errcode = 1987;
      res = true;
      goto LExistStockTrans;
    end;
  
    SMr.ThrouLocation = location;
    SMr.OKFlag = 0;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "FrThrouLocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    if (ReadFirstKey(keystr,SMr,2,matchf) and (SMr.OKFlag==0) and
      ((SMr.TransDate<dp) and (nonblankdate(SMr.TransDate))) and ((fnr!="StockMovVc") or (SMr.SerNr!=SerNr))) then begin
      errcode = 1987;
      res = true;
      goto LExistStockTrans;
    end;
    SMr.ThrouLocation = location;
    SMr.SentOKFlag = 0;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "ToThrouLocOK";
      case 2: keystr = "SentOKFlagSentTransDate";
    end;
    if (ReadFirstKey(keystr,SMr,2,matchf) and 
      ((SMr.SentOKFlag==0) and (nonblank(SMr.ThrouLocation))) and
      (SMr.SentTransDate<dp) and (nonblankdate(SMr.SentTransDate)) and ((fnr!="StockMovVc") or (SMr.SerNr!=SerNr))) then begin
      errcode = 1987;
      res = true;
      goto LExistStockTrans;
    end;
    
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "LocOK";
      case 2: keystr = "OKFlagShipDate";
    end;
    if (ReadFirstKey(keystr,SHr,2,matchf) and (SHr.OKFlag==0) and
      (SHr.ShipDate<dp) and ((fnr!="SHVc") or (SHr.SerNr!=SerNr))) then begin
      errcode = 1988;
      res = true;
      goto LExistStockTrans;
    end;
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "LocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    if (ReadFirstKey(keystr,SDr,2,matchf) and (SDr.OKFlag==0) and
      (SDr.TransDate<dp) and ((fnr!="SDVc") or (SDr.SerNr!=SerNr))) then begin
      approvalstatus = SDApprovalStatus(SDr,Acptr);
      if (approvalstatus!=kAcceptanceStateRejected) then begin
        errcode = 1989;
        res = true;
        goto LExistStockTrans;
      end;
    end;
    if (ReadFirstKey(keystr,SRr,2,matchf) and (SRr.OKFlag==0) and
      (SRr.TransDate<dp) and ((fnr!="SRVc") or (SRr.SerNr!=SerNr))) then begin
      errcode = 20888;
      res = true;
      goto LExistStockTrans;
    end;
  
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "LocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    if (ReadFirstKey(keystr,IVr,3,matchf) and (IVr.OKFlag==0) and
      (IVr.TransDate<dp) and ((fnr!="IVVc") or (IVr.SerNr!=SerNr))) then begin
      approvalstatus = IVApprovalStatus(IVr,Acptr);
      if (approvalstatus!=kAcceptanceStateRejected) then begin
        errcode = 1990;
        res = true;
        goto LExistStockTrans;
      end;
    end;
  
    switch (MainStockRec.Chronology) begin
      case 1: keystr = "LocOK";
      case 2: keystr = "OKFlagTransDate";
    end;
    ReadFirstKey(keystr,Retr,2,matchf);
    if (ReadFirstKey(keystr,Retr,3,matchf) and (Retr.OKFlag==0) and
      (Retr.TransDate<dp) and ((fnr!="RetVc") or (Retr.SerNr!=SerNr))) then begin
      errcode = 20594;
      res = true;
      goto LExistStockTrans;
    end;
    /*
    if (ReadFirstKey("LocOK",IVCashr,3,matchf) and (IVCashr.OKFlag==0) and
(IVCashr.Invalid==0)
      (IVCashr.TransDate<dp) and ((fnr!="IVCashVc") or (IVCashr.SerNr!=SerNr))) then begin
      errcode = 1990;
      res = true;
      goto LExistStockTrans;
    end;
    */
  end;
  
  //locationperrow  
  RetPUr.Location = location;
  PUr.Location = location;
  Prodr.Location = location;
  SMr.FrLocation = location;
  SHr.Location = location;
  SDr.Location = location;
  SRr.Location = location;
  IVr.Location = location;
  WSr.Location = location;
  Retr.Location = location;
  IVCashr.Location = location;
  IVr.UpdStockFlag = 1;
  Retr.UpdStockFlag = 1;
  RetPUr.OKFlag = 1;
  PUr.OKFlag = 1;
  Prodr.FinnishedFlag = 1;
  SMr.OKFlag = 1;
  SHr.OKFlag = 1;
  SDr.OKFlag = 1;
  SRr.OKFlag = 1;
  IVr.OKFlag = 1;
  WSr.OKFlag = 1;
  Retr.OKFlag = 1;
  IVCashr.OKFlag = 1;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 2;
    case 2: keystr = "OKFlagTransDate";  keys = 1;
  end; 
  if ((ReadLastKey(keystr,WSr,keys,matchf)) and (WSr.OKFlag==1) and (WSr.TransDate>dp)) then begin
    errcode = 1998;
    res = true;
    earliestdate = GetLaterDate(earliestdate,WSr.TransDate);
  end;
  if ((ReadLastKey(keystr,PUr,keys,matchf)) and (PUr.OKFlag==1) and (PUr.TransDate>dp)) then begin
    errcode = 1991;
    res = true;
    earliestdate = GetLaterDate(earliestdate,PUr.TransDate);
  end;
  if ((ReadLastKey(keystr,RetPUr,keys,matchf)) and (RetPUr.OKFlag==1) and (RetPUr.TransDate>dp)) then begin
    errcode = 20887;
    res = true;
    earliestdate = GetLaterDate(earliestdate,RetPUr.TransDate);
  end;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 2;
    case 2: keystr = "FinnishedFlagProdDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,Prodr,keys,matchf)) and (Prodr.FinnishedFlag==1) and (Prodr.ProdDate>dp)) then begin
    errcode = 1992;
    res = true;
    earliestdate = GetLaterDate(earliestdate,Prodr.ProdDate);
  end;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "FrLocOK"; keys = 2;
    case 2: keystr = "OKFlagTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SMr,keys,matchf)) and (SMr.OKFlag==1) and (SMr.TransDate>dp)) then begin
    if (blank(SMr.ThrouLocation)) then begin
      errcode = 1993;
      res = true;
      earliestdate = GetLaterDate(earliestdate,SMr.TransDate);
    end;
  end;

  SMr.FrLocation = location;
  SMr.SentOKFlag = 1;
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "FrLocSentOK"; keys = 2;
    case 2: keystr = "SentOKFlagSentTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SMr,keys,matchf)) and (SMr.SentOKFlag==1) and (SMr.SentTransDate>dp)) then begin
    errcode = 1993;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SMr.SentTransDate);
  end;

  SMr.ThrouLocation = location;
  SMr.SentOKFlag = 1;
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "ToThrouLocOK"; keys = 2;
    case 2: keystr = "SentOKFlagSentTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SMr,keys,matchf)) and (SMr.SentOKFlag==1) and (SMr.SentTransDate>dp)) then begin
    errcode = 1993;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SMr.SentTransDate);
  end;  

  SMr.ToLocation = location;
  SMr.OKFlag = 1;
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "ToLocOK"; keys = 2;
    case 2: keystr = "OKFlagTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SMr,keys,matchf)) and (SMr.OKFlag==1) and (SMr.TransDate>dp)) then begin
    errcode = 1993;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SMr.TransDate);
  end;

  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 2;
    case 2: keystr = "OKFlagShipDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SHr,keys,matchf)) and (SHr.OKFlag==1) and (SHr.ShipDate>dp)) then begin
    errcode = 1994;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SHr.ShipDate);
  end;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 2;
    case 2: keystr = "OKFlagTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,SDr,keys,matchf)) and (SDr.OKFlag==1) and (SDr.TransDate>dp)) then begin
    errcode = 1995;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SDr.TransDate);
  end;
  if ((ReadLastKey(keystr,SRr,keys,matchf)) and (SRr.OKFlag==1) and (SRr.TransDate>dp)) then begin
    errcode = 20889;
    res = true;
    earliestdate = GetLaterDate(earliestdate,SRr.TransDate);
  end;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 3;
    case 2: keystr = "OKFlagTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,IVr,keys,matchf)) and (IVr.OKFlag==1) and (IVr.TransDate>dp) and (IVr.SerNr!=SerNr)) then begin
    errcode = 1996;
    res = true;
    earliestdate = GetLaterDate(earliestdate,IVr.TransDate);
  end;
  
  switch (MainStockRec.Chronology) begin
    case 1: keystr = "LocOK"; keys = 2;
    case 2: keystr = "OKFlagTransDate"; keys = 1;
  end;
  if ((ReadLastKey(keystr,Retr,keys,matchf)) and (Retr.OKFlag==1) and (Retr.TransDate>dp) and (Retr.SerNr!=SerNr)) then begin
    errcode = 20886;
    res = true;
    earliestdate = GetLaterDate(earliestdate,Retr.TransDate);
  end;
  
  /*  
  if ((ReadLastKey("LocOK",IVCashr,3,matchf)) and (IVCashr.OKFlag==1) and
      (IVCashr.TransDate>dp) and (IVCashr.SerNr!=SerNr)) then begin
    errcode = 1996;
    res = true;
    goto LExistStockTrans;
  end;
  */  
  
  if (res) then begin
    errcode = 26200;
    errstr = earliestdate;
  end;
  
LExistStockTrans:;
  ExistStockTrans = res;
  RETURN;
END;

procedure ArtCodeOnThisProdOperation(Integer cnt,record ProdOperationVc ProdOpr,string artcode,record INVc INr,var val resp)
BEGIN
  row ProdOperationVc ProdOprw;
  Integer rwcnt,i;

  resp = blankval;
  rwcnt = MatRowCnt(ProdOpr); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (TestArtCode(ProdOprw.Item,artcode,INr)) then begin
      switch (ProdOpr.RowsHoldActualQty) begin
        case 1: resp = resp + ProdOprw.OutQty;
        otherwise resp = resp + ProdOprw.OutQty*ProdOpr.Qty;
      end;            
    end;
  end;
  RETURN;
END;

global
updating procedure ProdOperationUpdateCostPrice(record ProdOperationVc ProdOpr)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row ProdOperationVc ProdOprw;
  row ProdOperationVc ProdOpr2w;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,realq,trs,trsb2,qonrec;
  record RoundBlock RoundRec;
  record WeigAvVc war;

  BlockLoad(RoundRec);  
  outrows = 0;
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (ProdOprw.OutQty!=0) then begin
      found = ReadFirstItemInclClosed(ProdOprw.Item,INr,false,false);
      if (INr.ItemType==1) then begin
        RecordCopy(oldINr,INr);
        if ((found) and (ProdOprw.ItemCost!=0)) then begin
          rs = ProdOprw.ItemCost;
          Base1ToBase2(rs,ProdOpr.ProdDate,rsb2);
          FindStockValue(INr.Code,"",ISr);        
          switch (ProdOpr.RowsHoldActualQty) begin
            case 1: realq = ProdOprw.OutQty;
            otherwise realq = ProdOprw.OutQty*ProdOpr.Qty;
          end;      
          q = ISr.Instock - realq;

          for (j=i+1;j<rwcnt;j=j+1) begin
            MatRowGet(ProdOpr,j,ProdOpr2w);
            if (TestArtCode(ProdOpr2w.Item,ProdOprw.Item,INr)) then begin
              switch (ProdOpr.RowsHoldActualQty) begin
                case 1: q = q - ProdOpr2w.OutQty;
                otherwise q = q - ProdOpr2w.OutQty*ProdOpr.Qty;
              end;            
            end;
          end;
          
          if (q!=0) then begin
            t = q*INr.WeighedAvPrice;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            t2 = realq*rs;
            t = t + t2;
            q = q + realq;
            trs = t/q;
            INr.WeighedAvPrice = trs;

            t = q*INr.WeighedAvPriceB2;
            t2 = realq*rsb2;
            t = t + t2;
            q = q + realq;
            trsb2 = t/q;
            INr.WeighedAvPriceB2 = trsb2;

            ArtCodeOnThisProdOperation(i+1,ProdOpr,ProdOprw.Item,INr,qonrec);                      
            UpdateLocationWeightedAv(INr.Code,ProdOpr.Location,realq,rs,rsb2,qonrec,false);
          end else begin
            INr.WeighedAvPrice = ProdOprw.ItemCost;
            Base1ToBase2(ProdOprw.ItemCost,ProdOpr.ProdDate,rsb2);
            INr.WeighedAvPriceB2 = rsb2;

            war.ArtCode = INr.Code;
            war.Location = ProdOpr.Location;
            if (ReadFirstMain(war,2,true)==false) then begin
              war.ArtCode = INr.Code;
              war.Location = ProdOpr.Location;
              war.WeighedAvPrice = ProdOprw.ItemCost;
              war.WeighedAvPriceB2 = rsb2;
              if (RecordStore(war,false)) then begin
              end;
            end;
          end;
          INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
          INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
          switch (INr.UpdateCost) begin
            case 1:
              if (INr.InPrice!=ProdOprw.ItemCost) then begin  // inprice has changed 
                INr.InPrice = ProdOprw.ItemCost;
                INr.LastPriceChange = CurrentDate;
              end else begin
                found = false;
              end;
              if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
                INr.InPriceB2 = rsb2;
              end;
            case 3:
              if (INr.InPrice!=ProdOprw.ItemCost) then begin  // inprice has changed 
                INr.InPrice = ProdOprw.ItemCost;
                INr.LastPriceChange = CurrentDate;
              end else begin
                found = false;
              end;
              if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
                INr.InPriceB2 = rsb2;
              end;
            case 2:
              rs = ProdOprw.ItemCost;
              Base1ToBase2(rs,ProdOpr.ProdDate,rsb2);
              FindStockValue(INr.Code,"",ISr);
              switch (ProdOpr.RowsHoldActualQty) begin
                case 1: realq = ProdOprw.OutQty;
                otherwise realq = ProdOprw.OutQty*ProdOpr.Qty;
              end;                  
              q = ISr.Instock - realq;
              t = q*INr.WeighedAvPrice;
              if (INr.PriceFactor!=0) then begin
                rs = rs*INr.PriceFactor;
              end;
              t2 = realq*rs;
              t = t + t2;
              q = q + realq;
              trs = t/q;

              t = q*INr.InPriceB2;
              if (INr.PriceFactor!=0) then begin
                rsb2 = rsb2*INr.PriceFactor;
              end;
              t2 = realq*rsb2;
              t = t + t2;
              q = q + realq;
              trsb2 = t/q;

              ArtCodeOnThisProdOperation(i+1,ProdOpr,ProdOprw.Item,INr,qonrec);                      
              if (INr.InPrice!=INr.WeighedAvPrice) then begin  // inprice has changed 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end else begin
                found = false;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin  // inprice has changed 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
            otherwise 
              found = false;
           end;
           switch(INr.UpdateCost) begin
             case 0:;
             otherwise
               INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
               INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
               INr.LastPriceChange = CurrentDate;
           end;
           INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
           INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
           if (RecordUpdate(oldINr,INr,false)==0) then begin
           end;
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure UpdateBatchBestBefore(string item,string comment,string serialnr,Date prodddate,Date bestbeforep,val UnitXval,val UnitYval,val UnitZval,Integer consigstock,Integer TREO,Boolean negf,
                                         string SuppSerialNr,string MajStoneDet,string Colour,string Clarity,string Cert,string MinStoneDet,string Metal,string RowWeight,
                                         string Size,string Length, string WatchBrand, string StyleName, string WatchMetal, string Movement, string BrcStr, string Gender, 
                                         string Other, string Other2)
begin
  record BatchTextVc oldbtr;
  record BatchTextVc btr;
  row BatchTextVc btrw;
  Boolean found;
  
  btr.ArtCode = item;
  btr.SerialNr = serialnr;
  found = ReadFirstMain(btr,2,true);
  if (negf) then begin
    if (found) then begin
      if (btr.BestBefore<CurrentDate) then begin
        RecordDelete(btr);
      end;
    end;
    goto LUpdateBatchBestBefore;
  end;
  RecordCopy(oldbtr,btr);
  if (found==false) then begin
    btr.ArtCode = item;
    btr.SerialNr = serialnr;
  end;
  btr.ProductionDate = prodddate;
  if (nonblankdate(bestbeforep)) then begin
    btr.BestBefore = bestbeforep;
  end;
  if (UnitXval!=0) then begin
    btr.UnitXval = UnitXval;
  end;
  if (UnitYval!=0) then begin
    btr.UnitYval = UnitYval;
  end;
  if (UnitZval!=0) then begin
    btr.UnitZval = UnitZval;
  end;
  if (nonblank(SuppSerialNr)) then begin
    btr.SuppSerialNr = SuppSerialNr;
  end;
  if (nonblank(Colour)) then begin
    btr.Colour = Colour;
  end;
  if (nonblank(Clarity)) then begin
    btr.Clarity = Clarity;
  end;
  if (nonblank(Cert)) then begin
    btr.Cert = Cert;
  end;
  if (nonblank(RowWeight)) then begin
    btr.RowWeight = RowWeight;
  end;
  if (nonblank(MajStoneDet)) then begin
    btr.MajStoneDet = MajStoneDet;
  end;
  if (nonblank(MinStoneDet)) then begin
    btr.MinStoneDet = MinStoneDet;
  end;
  if (nonblank(Metal)) then begin
    btr.Metal = Metal;
  end;
  if (nonblank(Size)) then begin
    btr.Size = Size;
  end;
  if (nonblank(Length)) then begin
    btr.Length = Length;
  end;
  if (nonblank(WatchBrand)) then begin
    btr.WatchBrand = WatchBrand;
  end;
  if (nonblank(StyleName)) then begin
    btr.StyleName = StyleName;
  end;
  if (nonblank(WatchMetal)) then begin
    btr.WatchMetal = WatchMetal;
  end;
  if (nonblank(Movement)) then begin
    btr.Movement = Movement;
  end;
  if (nonblank(BrcStr)) then begin
    btr.BrcStr = BrcStr;
  end;
  if (nonblank(Gender)) then begin
    btr.Gender = Gender;
  end;
  if (nonblank(Other)) then begin
    btr.Other = Other;
  end;
  if (nonblank(Other2)) then begin
    btr.Other2 = Other2;
  end;
  if (found==false) then begin
    if ((blankdate(bestbeforep)) and (UnitXval==0) and (consigstock==0) and (TREO==0) and (blank(SuppSerialNr)) and (blank(MajStoneDet)) and (blank(Colour)) and (blank(Clarity)) and (blank(Cert)) and (blank(MinStoneDet)) and (blank(Metal)) and (blank(RowWeight)) and (blank(Size)) and (blank(Length)) and (blank(WatchBrand)) and (blank(StyleName)) and (blank(WatchMetal)) and (blank(Movement)) and (blank(BrcStr)) and (blank(Gender)) and (blank(Other)) and (blank(Other2))) then begin
      goto LUpdateBatchBestBefore;
    end;
  end;
  if (found==false) then begin
    btr.ConsigStock = consigstock;
    btr.TREOFlag = TREO;
    btr.Comment = comment;
    if (RecordStore(btr,true)) then begin end;
  end else begin
    if (RecordUpdate(oldbtr,btr,found)==0) then begin end;
  end;
LUpdateBatchBestBefore:;
  RETURN;
END;

global
updating procedure DeleteBatchBestBefore(string item,string serialnr)
BEGIN
  record BatchTextVc btr;
  
  btr.ArtCode = item;
  btr.SerialNr = serialnr;
  if (ReadFirstMain(btr,2,true)) then begin
    RecordDelete(btr);
  end;
  RETURN;
END;

global
updating procedure PurUpdateOvst(record PUVc PUr,record PUVc oldPUr)
BEGIN
  record MainStockBlock MSb;
  record ItemHistVc IHr;
  record ItemHistVc oldIHr;
  Integer i,rwcnt,oldrwcnt;
  row PUVc PUrw;
  row PUVc oldPUrw;
  string 10 location;
  string 10 thelocation;
  val t,t2,q2;
  Boolean updmarkf,testf;
  
  updmarkf = true;
  location = PUr.Location;
  BlockLoad(MSb);
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(PUr);
  oldrwcnt = MatRowCnt(oldPUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if (blank(PUrw.Location)) then begin
      thelocation = location;
    end else begin
      thelocation = PUrw.Location;
    end;
    if (i<oldrwcnt) then begin
      MatRowGet(oldPUr,i,oldPUrw);
    end;
    testf = false;
    if ((PUrw.ovst!=0) and (oldPUrw.ovst==0)) then begin
      testf = true;
    end;
    if ((oldPUr.Invalid==0) and (PUr.Invalid!=0)) then begin
      if (oldPUrw.ovst==0) then begin
        testf = true;
      end;
    end;
    if (testf) then begin
      IHr.FileName = "PUVc";
      IHr.TransNr = PUr.SerNr;
      IHr.Row = i;
      if (ReadFirstKey("FNTransNr",IHr,3,true)) begin
        RecordCopy(oldIHr,IHr);
        IHr.RemQty = 0;
        IHr.StockAffectf = 0;
        if (RecordUpdate(oldIHr,IHr,true)==0) then begin end;
        
        if (nonblank(PUrw.SerialNr)) then begin
          if ((nonblankdate(PUrw.BestBefore)) or (PUrw.UnitXval!=0)) then begin
            DeleteBatchBestBefore(PUrw.ArtCode,PUrw.SerialNr);
          end;
        end;
        UpdateSerStock(PUrw.ArtCode,thelocation,PUrw.SerialNr,-PUrw.Quant,-PUrw.CostPrice);
        t2 = -PUrw.Quant;
        if (MSb.UnitConvCalc==0) then begin
          q2 = t2*PUrw.Coefficient;
        end else begin
          q2 = t2/PUrw.Coefficient;
        end;
        UpdateInstock("PUVc",PUr.SerNr,PUrw.ArtCode,thelocation,PUr.TransDate,t2,t,t,t2,t2,q2,t,t,t);
      end;    
//      PUOvstUpdateNLTransaction(CurrentDate,PUr.SerNr,PUrw.CostPrice,updmarkf);
    end;
  end;
  PurUpdateCostPrice(PUr,true);
  RETURN;
END;

global
updating procedure UpdatePosition(string artcode,string location,string position,val q,val q2,val instockmov)
BEGIN
  record POSVc POSr;
  record PISVc PISr;
  record PISVc oldPISr;
  Boolean found,deltest;
  record INVc INr;
  record TestItemStatusBlock TestISb;
  Integer keys;

  if (blank(artcode) or blank(position)) then begin
    goto LUpdatePosition;
  end;
  BlockLoad(TestISb);

  if (artcode==TestISb.ArtCode) then begin
    LogText(0,"UpdatePosition q " & chr(9) & q & chr(9) & " instockmov " & chr(9) & instockmov & " location " & chr(9) & location & chr(9) & "position" & chr(9) & position & chr(9) & " artcode " & chr(9) & artcode);
  end;
  
  keys = 3;

  PISr.ArtCode = artcode;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    if (artcode!=INr.Code) then begin
      PISr.Variety = right(artcode,len(artcode)-len(INr.Code));
      PISr.ArtCode = INr.Code;
      keys = 4;
    end;
  end;
  PISr.Location = location;
  PISr.Position = position;
  found = ReadFirstMain(PISr,keys,true);
  RecordCopy(oldPISr,PISr);
  if (found==false) then begin
    PISr.ArtCode = artcode;
    if (nonblank(INr.Code)) then begin
      if (artcode!=INr.Code) then begin
        PISr.Variety = right(artcode,len(artcode)-len(INr.Code));
        PISr.ArtCode = INr.Code;
      end;
    end;
    PISr.Location = location;
    PISr.Position = position;
  end;
  PISr.Instock = PISr.Instock + q;
  PISr.Instock2 = PISr.Instock2 + q2;
  PISr.InStockMov = PISr.InStockMov + instockmov;
  PISr.LeftQty = PISr.Instock - PISr.InStockMov;
  POSr.Code = PISr.Position;
  if (ReadFirstMain(POSr,1,true)) then begin end;
  PISr.LocArea = POSr.LocArea;
  PISr.PickOrder = POSr.PickOrder;
  if (PISr.Instock==0) and (PISr.InStockMov==0) then begin deltest = true; end;
  if (deltest==false) then begin
    if (found==false) then begin
      if (RecordStore(PISr,true)) then begin end;
    end else begin
      if (RecordUpdate(oldPISr,PISr,found)==0) then begin end;
    end;
  end else begin
    if (found) then begin
      RecordDelete(oldPISr);
//      if (RecordUpdate(oldPISr,PISr,found)==0) then begin end;
      SetPositionStatus(PISr.Position,0);
    end;
  end;
  if (location!=";;;") then begin
    if (artcode==TestISb.ArtCode) then begin
  //    LogText(0," q " & chr(9) & q & chr(9) & " instockmov " & chr(9) & instockmov & " location " & chr(9) & location & chr(9) & "position" & chr(9) & position & chr(9) & " tcode " & chr(9) & tcode);
    end;
  end;
  if (location!=";;;") then begin
    UpdatePosition(artcode,";;;",position,q,q2,instockmov);
  end;
 LUpdatePosition:; 
  RETURN;
END;

global
procedure IVCashUpdateFIFO(record IVCashVc IVCashp,Boolean trflg)
BEGIN
  record MainStockBlock MainStockRec;
  record CostAccBlock CostAccRec;
  row IVCashVc IVCashrw;
  row IVCashVc IVCash2rw;
  record INVc INr;
  record SHVc recSHr;
  val t;
  Integer rwcnt;
  Integer i,j;
  string 255 location;
  val adjstockv;
     
  location = IVCashp.Location;
  BlockLoad(MainStockRec);
  BlockLoad(CostAccRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(IVCashp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashp,i,IVCashrw);
    if (IVCashrw.stp==1) then begin
      if (nonblank(IVCashrw.ArtCode)) then begin
        if (ReadFirstItem(IVCashrw.ArtCode,INr,true,true)==false) then begin goto L80IVCashUpdateFIFO; end;
        if ((INr.ItemType!=1)) then begin
          if ((CostAccRec.CostAccForNonStocked==0) or (INr.ItemType==2)) then begin
            goto L80IVCashUpdateFIFO;
          end;
        end;
      end else begin
        goto L80IVCashUpdateFIFO;
      end;
      if (true) then begin
        if (trflg) then begin
          if (IVCashrw.Quant>0) then begin
            adjstockv = blankval;
            for (j=0;j<i;j=j+1) begin
              MatRowGet(IVCashp,j,IVCash2rw);
              if (IVCash2rw.ArtCode==IVCashrw.ArtCode) then begin
                adjstockv = adjstockv + IVCash2rw.Quant; 
              end; 
            end;       
            IVCashrw.FIFORowVal = FindCostPrice(IVCashrw.ArtCode,"",IVCashrw.SerialNr,IVCashrw.Quant,adjstockv,false);
            IVCashrw.FIFORowVal = Round(IVCashrw.FIFORowVal,SetRoundModeD(5));
            IVCashrw.FIFO = IVCashrw.FIFORowVal/IVCashrw.Quant;
          end else begin
            IVCashrw.FIFO = blankval;
          end;    
        end;
      end;
    end;
L80IVCashUpdateFIFO:;
    MatRowPut(IVCashp,i,IVCashrw);
  end;
  RETURN;
END;

global
function Boolean CheckStructureItemsLevel(string artcode,string recepy,string location,val quantp)
BEGIN
  Boolean res;
  record ItemStatusVc ISr;
  record INVc INr;
  record SHVc SHr;
  row SHVc SHrw;
  row SHVc SHrw2;
  Boolean isstruct;
  Integer i,rwcnt;
  Integer cnt;
  val prev,t;
      
  res = true;
  ReadFirstItem(artcode,INr,true,false);
  if (INr.ItemType!=kItemTypeStructured) then begin
    goto LCheckStructureItemsLevel;
  end;
  isstruct = ExpandStructItem(artcode,recepy,quantp,SHr);
  if (isstruct) then begin
    rwcnt = MatRowCnt(SHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHr,i,SHrw);
      prev = blankval;
      for (cnt=0;cnt<i;cnt=cnt+1) begin
        MatRowGet(SHr,cnt,SHrw2);
        if (SHrw.ArtCode==SHrw2.ArtCode) then begin prev = prev + SHrw2.Ship; end;
      end;
      prev = prev + SHrw.Ship;
      INr.Code = SHrw.ArtCode;
      ReadFirstItem(SHrw.ArtCode,INr,true,false);
      switch (INr.ItemType) begin
        case 1:
          FindStockValue(SHrw.ArtCode,location,ISr);
          if ((ISr.Instock<prev) and (prev>0)) then begin
            res = false;
            goto LCheckStructureItemsLevel;
          end;
        case 2:
          if (nonblank(INr.Recepy)) then begin
            t = quantp*prev;
            if (CheckStructureItemsLevel(SHrw.ArtCode,INr.Recepy,location,t)==false) then begin
              res = false;
              goto LCheckStructureItemsLevel;
            end;
          end;
        otherwise
          ;
      end;  
    end;
  end;
LCheckStructureItemsLevel:;  
  CheckStructureItemsLevel = res;
  RETURN;
END;