external function roundmode DefaultRoundMode();
external procedure CalcProc(val,val,var val);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure SendArtStat(string,string,string,val,val,val,Date,Integer);

global
procedure QTDchsum(record QTVc QTr,Integer rownr)
begin
  row QTVc QTrw;
  row QTVc QT2rw;
  val t,s;
  val rowinbase;
  val tproc;
  val unitprdisc;
  string 60 location;
  record TaxMatrixVc TMr;
  val gp;
  Integer i,rwcnt;

  if (rownr>=0) then begin
    MatRowGet(QTr,rownr,QTrw);
  end;
  QTr.TotGP = QTr.TotGP - QTrw.rowGP;
  location = "";
  unitprdisc = BlankVal;
  t = QTrw.Quant * QTrw.BasePrice;
  if (QTrw.PriceFactor<>0) then begin
    t = t / QTrw.PriceFactor;
  end;
  s = MulRateToBase1(QTr.CurncyCode,QTrw.Sum,QTr.FrRate,QTr.ToRateB1,QTr.ToRateB2,QTr.BaseRate1,QTr.BaseRate2,DefaultCurRoundOff);
  UnpackRowFieldMatrix(QTrw,"TaxMatrix",TMr);
  FindSalesExVat(TMr,QTrw.VATCode,s,QTr.InclVAT,QTr.NoTAXonVAT,rowinbase);
  QTrw.rowGP = rowinbase - t;
  unitprdisc = Round(QTrw.Sum / QTrw.Quant,DefaultRoundMode);
  if (rownr>=0) then begin
    MatRowPut(QTr,rownr,QTrw);
  end;
  gp = QTrw.rowGP;
  rwcnt = MatRowCnt(QTr);  
  for (i=rownr+1;i<rwcnt;i=i+1) begin
    MatRowGet(QTr,i,QT2rw);
    switch (QT2rw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        if (QT2rw.MotherArtCode==QTrw.ArtCode) then begin
          gp = gp + QT2rw.rowGP;
        end;
      otherwise
        i = rwcnt;
    end;
  end;    
  CalcProc(rowinbase,gp,tproc);
  SendArtStat(QTrw.ArtCode,location,"",gp,tproc,unitprdisc,QTr.QTDate,1);
  return;
end;
