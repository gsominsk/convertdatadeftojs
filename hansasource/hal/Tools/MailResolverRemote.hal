external procedure ResolveMailboxNumber(var row MailVc);

procedure RemoveDuplicateAddressLines(var record MailVc Mailr)
begin
  row MailVc Mailrw;
  Integer i,j,rwcnt;
  vector Boolean addrs;
  
  j = 0;
  rwcnt = MatRowCnt(Mailr);
  
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(Mailr,i,Mailrw);
    if (addrs[Mailrw.AddrCode]==false) then begin
      addrs[Mailrw.AddrCode] = true;
      MatRowPut(Mailr,j,Mailrw);
      j = j + 1;
    end;
  end;
  
  for (i = rwcnt - 1; i>=j; i = i - 1) begin
    MatRowDelete(Mailr,i);
  end;
  
  return;
end;

global
procedure ResolveExternalEmailAddress(string extaddr,array string mailboxes)
begin
  string 255 res,indexname;
  LongInt rwcnt,i;
  record ConfVc Confr;
  record EmailAddrVc EAr;
  row EmailAddrVc EArw;

  indexname = "ExtEmailAddrs:" & extaddr;
  if (len(indexname)<=60) then begin
    Confr.SerNr = -1;

    while (LoopKey(indexname,Confr,0,true)) begin
      if (Confr.Closed==0) then begin
        mailboxes[mailboxes.length] = Confr.AddrName;
      end;
    end;
  end;

  indexname = "ExternalEmail:" & extaddr;
  if (len(indexname)<=60) then begin
    EAr.SerNr = -1;

    while (LoopKey(indexname,EAr,0,true)) begin
      rwcnt = MatRowCnt(EAr);
      for (i = 0; i<rwcnt; i = i + 1) begin
        MatRowGet(EAr,i,EArw);
        if (extaddr==EArw.ExternalEmail) then begin
          mailboxes[mailboxes.length] = EAr.AddrName;
        end;
      end;
    end;
  end;
end;

global
function Boolean DoResolveIncomingMail(var record MailVc Mailr,var string IncomingMailToAddress)
begin
  LongInt i,j,rwcnt;
  row MailVc Mailrw;
  Boolean mbfoundf;
  record MailSettingsBlock MSb;
  string 255 mailto;
  array string 255 AddrArray;
  record ConfVc Confr;

  mailto = "";
  mbfoundf = false;

  rwcnt = MatRowCnt(Mailr);
  
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(Mailr,i,Mailrw);
    ResolveExternalEmailAddress(Mailrw.AddrCode,AddrArray);
    for (j = 0; j<AddrArray.length; j = j + 1) begin
      ClearRow(Mailr,Mailrw,1);
      Mailrw.AddrCode = AddrArray[j];
      ResolveMailboxNumber(Mailrw);

      if (j==0) then begin
        MatRowPut(Mailr,i,Mailrw);
      end else begin
        MatRowInsert(Mailr,i + j,Mailrw);
      end;

      if (blank(mailto)) then begin
        mailto = Mailrw.AddrCode;
      end;
      mbfoundf = true;
    end;
    if (AddrArray.length>0) then begin
      i = i + AddrArray.length - 1;
      rwcnt = rwcnt + AddrArray.length - 1;
    end;
  end;


  if (mbfoundf==false) then begin
    BlockLoad(MSb);
    
    Confr.AddrName = MSb.Postmaster;
    if (ReadFirstKey("AddrName",Confr,1,true)) then begin
      ClearRow(Mailr,Mailrw,1);
      Mailrw.AddrCode = MSb.Postmaster;
      if (blank(mailto)) then begin
        mailto = Mailrw.AddrCode;
      end;
      ResolveMailboxNumber(Mailrw);
      MatRowPut(Mailr,MatRowCnt(Mailr),Mailrw);
      mbfoundf = true;
    end;
  end;
  
//LogText(0,"DoResolveIncomingMail mailto " & mailto);  
  RemoveDuplicateAddressLines(Mailr);
  IncomingMailToAddress = mailto;
  DoResolveIncomingMail = mbfoundf;
  
  return;
end;

global
function string 255 CleanupUTF8String(string tstr)
begin
  longint i,l;
  string 255 res,ch;
  
  l = len(tstr);
  for (i=0;i<l;i=i+1) begin
    ch = mid(tstr,i,1);
    if (len(ch)!=1) then begin
      res = res & "?";
    end else begin
      res = res & ch;
    end;
  end;
  
  CleanupUTF8String = res;
  return;
end;

procedure CleanMail(record MailVc Mailr)
begin
  row MailVc Mailrw;
  integer i,rwcnt;

  Mailr.Header = CleanupUTF8String(Mailr.Header);

  rwcnt = MatRowCnt(Mailr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Mailr,i,Mailrw);
    Mailrw.AddrCode = CleanupUTF8String(Mailrw.AddrCode);
    MatRowPut(Mailr,i,Mailrw);
  end;
  return;
end;

global
updating function Boolean DoInsertIncomingMail(var record MailVc Mailr,string IncomingMailToAddress)
begin
  Boolean OldDontResend;
  record MailVc Mail2r;
  transaction string 255 gIncomingMailToAddress;
  LongInt htmlflag;
  record MailVc oldMailr;
  Boolean res;

  gIncomingMailToAddress = IncomingMailToAddress;
  OldDontResend = GetDontResend;
  SetDontResend(true);

  CleanMail(Mailr);
  
  if (TestEnablerFile("EnNoDuplicateMail")) then begin
    if (nonblank(Mailr.MessageID)) then begin
      Mail2r.MessageID = Mailr.MessageID;
      if (ReadFirstKey("MessageID",Mail2r,1,true)) then begin
        LogText(0,"DoInsertIncomingMail(): Skipping MailVc record with subject, as it's a duplicate:");
        LogText(0,Mailr.Header);
        goto LSkipEmail;
      end;
    end;
  end;
  LogText(0,"DoInsertIncomingMail(): About to insert MailVc record with subject:");
  LogText(0,Mailr.Header);
//  LogText(0," gIncomingMailToAddress:" & gIncomingMailToAddress);
  
  htmlflag =  Mailr.HtmlFlag;
  Mailr.HtmlFlag = 0;
  res = RecordInsert(Mailr,false);
  if (res) then begin
    if (Mailr.SerNr>0) then begin
      Mail2r.SerNr = Mailr.SerNr;
      res = ReadFirstMain(Mailr,1,true);
    end;
  end;

  if (res) then begin
    LogText(0,"SerNr:" & Mailr.SerNr);

    oldMailr = Mailr;
    Mailr.HtmlFlag = htmlflag;
    RecordUpdate(oldMailr,Mailr,false);
  end else begin
    LogText(0,"Failed to store mail");
  end;

LSkipEmail:;
  gIncomingMailToAddress = "";
  SetDontResend(OldDontResend);
  DoInsertIncomingMail = res;
end;
