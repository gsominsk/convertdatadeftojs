external function Integer InString2(string,string);
external function Integer CountObjects(string);
external function Boolean GetGlobalUserMainCompany(string,var string);
external procedure ClassTypef(string,string,var Boolean);
external function Boolean SetInSet2(string,string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external updating function longint EShipPRTWClassSendDo(record RcVc,var record eShipTaxAuthReplyVc);
remote function integer TestEinvoiceQueueRemote(LongInt);
remote updating function Integer StandardPersonalIDWClassSaveRemote(string,string);
remote updating function Integer GetRemoteUserMonthNumbers();
external function Boolean HasModIN();
external function Boolean HasMultiLocations();
remote updating procedure RemoteLicensesUpdate(var array record LicensesVc,Longint);
remote updating procedure RemoteLicensesUpdateFromClient(var array record LicensesVc,Longint);
external function string 60 AddObjectToObjectList(string,string);
external function Boolean IsSessionOpen(string,string,Date,Time);
external procedure SetActTypeValues(record ActVc);
external procedure ActVcRecordDefServer(var record ActVc);
external procedure Base1ToOther(var string,val,val,val,val,val,val,var val,roundmode);
external procedure TBBUVc_PasteCurncyCode(var record TBBUVc,string,Boolean);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Integer TypeOfCurncy(var string,var Integer);
external function Integer GetIntYc(Date);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external function string 255 GetNextValue(var string);
external function string 255 AddStr(string,string,string);
remote updating function Integer UpdateUserLicenses(Integer);
remote updating procedure UpdateRemoteUserChargeFields();
remote updating procedure UpdateRemoteCompaniesChargeFields();
remote procedure GetRemoteUserChargeFields(var Integer,var Integer,var Integer,var Integer,var Date);
remote procedure GetRemoteCompaniesChargeFields(var Integer,var Integer,var Integer,var Integer,var Date);
external function Boolean PasteActTypeInAct(string,var record ActVc);

global
function val FindPaidInPeriod_IVVc(record IVVc orgIVp,Boolean curncyf,Date StartDate,Date EndDate)
BEGIN
  val res;
  record IPrsVc IPrsr;
  record IVVc IVr;
  row IVVc IVrw;
  record IPVc IPr;
  row IPVc IPrw;
  record PurgeTRVc PurgeTRr;
  record TRVc TRr;
  row TRVc TRrw;
  record CLInVc CLInr;
  row CLInVc CLInrw;
  record CLOutVc CLOutr;
  row CLOutVc CLOutrw;
  Integer i,rwcnt;
  Boolean found;
  val t,t2;
  Integer oldstyle;  
  record BaseCurBlock bcur;

  BlockLoad(bcur);
  found = true;
  if (orgIVp.InvType==kInvoiceTypeCredit or orgIVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
    if (orgIVp.CredInv>0) then begin
      IVr.SerNr = orgIVp.CredInv;
      if (ReadFirstMain(IVr,1,true)) then begin
        if (curncyf) then begin
          res = res + IVr.Sum4;
        end else begin
          res = res + IVr.BaseSum4;
        end;
      end;
      found = false;
    end;
  end;
  if (found) then begin    
    found = true;
    IPrsr.IVNr = orgIVp.SerNr;
    IPrsr.TransDate = StartDate;
    while (LoopKey("IVKeyTransDate",IPrsr,1,found)) begin
      if (IPrsr.IVNr!=orgIVp.SerNr) then begin found = false; end;
      if (IPrsr.TransDate>EndDate) then begin found = false; end;
      if (found) then begin
        switch (IPrsr.TransType) begin
          case kIPrsTransTypeInvoice:
            if (IPrsr.TransNr!=orgIVp.SerNr) then begin
              IVr.SerNr = IPrsr.TransNr;
              if (ReadFirstMain(IVr,1,true)) then begin
                if (IVr.Invalid==0) then begin
                  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                    if (curncyf) then begin
                      res = res + IVr.Sum4;
                    end else begin
                      res = res + IVr.BaseSum4;
                    end;
                  end;
                end;
              end;
            end;
          case kIPrsTransTypeReceipt:
            IPr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(IPr,1,true)) then begin
              if (IPr.RejectedFlag==0) then begin
                rwcnt = MatRowCnt(IPr);
                for (i=0;i<rwcnt;i=i+1) begin
                  MatRowGet(IPr,i,IPrw);
                  if ((IPrw.ovst==0)) then begin
                    if (IPrw.InvoiceNr==IPrsr.IVNr) then begin
                      if (IPrw.stp==1) or (IPrw.stp==5) or (IPrw.stp==6) then begin
                        if (IPrw.PayDate==IPrsr.CustDate) then begin
                          if (curncyf) then begin
                            res = res + IPrw.InvVal;
                          end else begin
                            if (IPrw.BankCurncy==bcur.BaseCur1) then begin   
                              res = res + IPrw.BankVal;
                            end else begin
                              res = res + MulWithRateToBase1(IPrw.RecCurncy,IPr.TransDate,IPrw.RecVal,DefaultCurRoundOff);
                            end;
                          end;
                        end;    
                      end;
                    end;
                  end;
                end;
              end;
            end;    
          case kIPrsTransTypePurgeNLTransaction:
            PurgeTRr.Number = IPrsr.TransNr;
            PurgeTRr.IntYc = GetIntYc(IPrsr.TransDate);
            PurgeTRr.TransRow = IPrsr.TransRow;
            if (ReadFirstMain(PurgeTRr,3,true)) then begin
              if ((PurgeTRr.Typ==1) and (PurgeTRr.SerNr==IPrsr.IVNr)) then begin
                if (PurgeTRr.CompCode==IPrsr.CustCode) then begin
                  t = PurgeTRr.CurCredVal - PurgeTRr.CurDebVal;
                  t2 = PurgeTRr.CredVal - PurgeTRr.DebVal;
                  if ((PurgeTRr.CurDebVal==0) and (PurgeTRr.CurCredVal==0)) then begin
                    t = t2;
                  end;                        
                  if (TypeOfCurncy(PurgeTRr.Curncy,oldstyle)==2) then begin
                    t = PurgeTRr.CredVal2 - PurgeTRr.DebVal2;
                  end;
                  if (curncyf) then begin
                    res = res + t;
                  end else begin
                    res = res + t2;
                  end;
                end;  
              end;
            end;                      
          case kIPrsTransTypeNLTransaction:
            TRr.Number = IPrsr.TransNr;
            TRr.IntYc = GetIntYc(IPrsr.TransDate);
            if (ReadFirstMain(TRr,2,true)) then begin
              rwcnt = MatRowCnt(TRr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(TRr,i,TRrw);
                if ((TRrw.Typ==1) and (TRrw.SerNr==IPrsr.IVNr)) then begin
                  if (TRrw.CompCode==IPrsr.CustCode) then begin
                    t = TRrw.CurCredVal - TRrw.CurDebVal;
                    t2 = TRrw.CredVal - TRrw.DebVal;
                    if ((TRrw.CurDebVal==0) and (TRrw.CurCredVal==0)) then begin
                      t = t2;
                    end;                        
                    if (TypeOfCurncy(TRrw.Curncy,oldstyle)==2) then begin
                      t = TRrw.CredVal2 - TRrw.DebVal2;
                    end;
                    if (curncyf) then begin
                      res = res + t;
                    end else begin
                      res = res + t2;
                    end;
                  end;  
                end;
              end;
            end;                      
          case kIPrsTransTypeCashIn:            
            CLInr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(CLInr,1,true)) then begin
              if (CLInr.Invalid==0) then begin
                rwcnt = MatRowCnt(CLInr);
                for (i=0;i<rwcnt;i=i+1) begin
                  MatRowGet(CLInr,i,CLInrw);
                  if ((CLInrw.Type==1) and (CLInrw.TransNr==IPrsr.IVNr)) then begin
                    if (CLInr.CUCode==IPrsr.CustCode) then begin
                      if (curncyf) then begin
                        res = res + CLInrw.Sum;
                      end else begin
                        res = res + MulRateToBase1(CLInr.CurncyCode,CLInrw.Sum,CLInr.FrRate,CLInr.ToRateB1,CLInr.ToRateB2,CLInr.BaseRate1,CLInr.BaseRate2,DefaultCurRoundOff);;
                      end;
                    end;
                  end;
                end;
              end;
            end;                      
          case kIPrsTransTypeCashOut:            
            CLOutr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(CLOutr,1,true)) then begin
              if (CLOutr.Invalid==0) then begin
                rwcnt = MatRowCnt(CLOutr);
                for (i=0;i<rwcnt;i=i+1) begin
                  MatRowGet(CLOutr,i,CLOutrw);
                  if ((CLOutrw.Type==1) and (CLOutrw.TransNr==IPrsr.IVNr)) then begin
                    if (CLOutr.CUCode==IPrsr.CustCode) then begin
                      if (curncyf) then begin
                        res = res - CLOutrw.Sum;
                      end else begin
                        res = res - MulRateToBase1(CLOutr.CurncyCode,CLOutrw.Sum,CLOutr.FrRate,CLOutr.ToRateB1,CLOutr.ToRateB2,CLOutr.BaseRate1,CLOutr.BaseRate2,DefaultCurRoundOff);;
                      end;
                    end;
                  end;
                end;
              end;
            end;
        end;
      end;
    end;
  end;
  FindPaidInPeriod_IVVc = res;
  RETURN;
END;

global
function string 255 CurDrawerCode(string MachineName)
begin
  string 255 drawer;
  record POSEventVc POSEventr;
  record CashierDefBlock Cashierb;
  Boolean found;
  Date td;
  Time tt;
  
  BlockLoad(Cashierb);
  if (Cashierb.MultipleSessionsPerLocalMachine==0) then begin
    POSEventr.MachineName = MachineName;
    POSEventr.TransDate = CurrentDate;
    POSEventr.TransTime = CurrentTime;
    if (ReadLastKey("MachineDate",POSEventr,3,false)) then begin    
    end;
    drawer = POSEventr.Drawer;
  end else begin
    td = CurrentDate;
    tt = CurrentTime;
    found = true;
    POSEventr.MachineName = MachineName;
    POSEventr.Event = 1;
    POSEventr.TransDate = td;
    POSEventr.TransTime = tt;
    while (LoopBackKey("MachineNameMembersEvent:" & CurrentUser,POSEventr,3,found)) begin
      if (POSEventr.MachineName!=MachineName) then begin found = false; end;
      if (POSEventr.Event!=1) then begin found = false; end;
      if (POSEventr.TransDate>td) then begin found = false; end;
      if (found) then begin
        if (IsSessionOpen(POSEventr.MachineName,POSEventr.Drawer,td,tt)) then begin
          drawer = POSEventr.Drawer;
          goto LCurDrawerCode;
        end;
      end;
    end;
LCurDrawerCode:;  
  end;
  CurDrawerCode = drawer;  
  return;
end;

global
procedure TBIVGetRate(var record TBIVVc TBIVp)
begin
  val from,to1,to2,base1,base2;
  string 5 crncy;
 
  crncy = TBIVp.CurncyCode;
  GetFullCurncyRate(crncy,TBIVp.TransDate,from,to1,to2,base1,base2);
  TBIVp.CurncyCode = crncy;
  TBIVp.FrRate = from;
  TBIVp.ToRateB1 = to1;
  TBIVp.ToRateB2 = to2;
  TBIVp.BaseRate1 = base1;
  TBIVp.BaseRate2 = base2;  
  return;
end;

global
procedure TBIVCalcInCurValues(var record TBIVVc TBIVr)
begin
  val t;

  Base1ToOther(TBIVr.CurncyCode,TBIVr.Price,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.PriceInCur,DefaultCurRoundOff);
  Base1ToOther(TBIVr.CurncyCode,TBIVr.Sum,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.SumInCur,DefaultCurRoundOff);
  if (Mid(TBIVr.Markup,len(TBIVr.Markup)-1,1)!="%") then begin    
    t = StringToVal(TBIVr.Markup,M45Val);
    Base1ToOther(TBIVr.CurncyCode,t,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,t,DefaultCurRoundOff);
    TBIVr.MarkupInCur = t;
  end;

  Base1ToOther(TBIVr.CurncyCode,TBIVr.CostPrice,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.CostPriceInCur,DefaultCurRoundOff);
  Base1ToOther(TBIVr.CurncyCode,TBIVr.GP,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.GPInCur,DefaultCurRoundOff);
  return;
end;

global
procedure CalcInCurtoTBIV(var record TBIVVc TBIVr)
begin
  record PRVc PRr;
  record BaseCurBlock BCb;

  PRr.Code = TBIVr.PRCode;
  ReadFirstMain(PRr,1,true);
  if (nonblank(PRr.CurncyCode)) then begin
    BlockLoad(BCb);
    TBIVr.CurncyCode = PRr.CurncyCode;
    TBIVGetRate(TBIVr);    
    if (TBIVr.CurncyCode!=BCb.BaseCur1) then begin
      TBIVCalcInCurValues(TBIVr);
    end;
  end;
  return;
end;

global
procedure TBIVCalcInCur_SalesPrice(var record TBIVVc TBIVr)
begin
  record PRVc PRr;
  val t;

  PRr.Code = TBIVr.PRCode;
  ReadFirstMain(PRr,1,true);
  if (nonblank(PRr.CurncyCode)) then begin
    TBIVr.CurncyCode = PRr.CurncyCode;
    TBIVGetRate(TBIVr);    
    Base1ToOther(TBIVr.CurncyCode,TBIVr.Price,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.PriceInCur,DefaultCurRoundOff);
    Base1ToOther(TBIVr.CurncyCode,TBIVr.Sum,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.SumInCur,DefaultCurRoundOff);
    if (Mid(TBIVr.Markup,len(TBIVr.Markup)-1,1)!="%") then begin    
      t = StringToVal(TBIVr.Markup,M45Val);
      Base1ToOther(TBIVr.CurncyCode,t,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,t,DefaultCurRoundOff);
      TBIVr.MarkupInCur = t;
    end;
  end;
  return;
end;

global
procedure TBIVCalcInCur_CostPrice(var record TBIVVc TBIVr)
begin
  record PRVc PRr;

  PRr.Code = TBIVr.PRCode;
  ReadFirstMain(PRr,1,true);
  if (nonblank(PRr.CurncyCode)) then begin
    TBIVr.CurncyCode = PRr.CurncyCode;
    TBIVGetRate(TBIVr);    
    Base1ToOther(TBIVr.CurncyCode,TBIVr.CostPrice,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.CostPriceInCur,DefaultCurRoundOff);
  end;
  return;
end;

global
procedure TBIVCalcInBaseCurValues(var record TBIVVc TBIVr)
begin
  val t;

  TBIVr.Price = MulRateToBase1(TBIVr.CurncyCode,TBIVr.PriceInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);
  TBIVr.CostPrice = MulRateToBase1(TBIVr.CurncyCode,TBIVr.CostPriceInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);
  TBIVr.Sum = MulRateToBase1(TBIVr.CurncyCode,TBIVr.SumInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);
  TBIVr.GP = MulRateToBase1(TBIVr.CurncyCode,TBIVr.GPInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);
  if (Mid(TBIVr.Markup,len(TBIVr.Markup)-1,1)!="%") then begin    
    t = StringToVal(TBIVr.MarkupInCur,M45Val);
    t = MulRateToBase1(TBIVr.CurncyCode,TBIVr.GPInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);
    TBIVr.Markup = t;
  end;
  return;
end;

global
procedure AddInBaseCurtoTBIV(var record TBIVVc TBIVr)
begin
  if (nonblank(TBIVr.CurncyCode)) then begin
    TBIVGetRate(TBIVr);    
    TBIVCalcInBaseCurValues(TBIVr);
  end;
  return;
end;

global
procedure AddInCurtoTBIVwithRate(var record TBIVVc TBIVr,string crncy,val fr,val to1,val to2,val br1,val br2)
begin
  val t;

  if (nonblank(TBIVr.CurncyCode)) then begin
  end else begin
    CalcInCurtoTBIV(TBIVr);
  end;
  return;
end;

global
updating procedure ServerMakeActEndedPhoneCall(string cucode,string person,string callerid,string user,LongInt oldAct)
begin
end;

global
updating procedure ServerMakeActEndedPhoneCall3(string cucode,string person,string callerid,string user,LongInt oldAct,Integer oldCompno,string nr1,string nr2,Boolean missedf,string queue)
begin
  record CUVc CUr;
  Boolean res;
  Integer oldcomp,queuecompany;
  record GlobalCRMBlock GCRMb;
  record ActVc Actr;
  record ASTBlock ASTb;
  record ContactRelVc ContactRelr;
  record PBXQueueVc PBXQr;
  record ActVc Act2r;
  string 255 queuename;
  string 255 queuecode;

  ServerMakeActEndedPhoneCall(cucode,person,callerid,user,oldAct); //For halcust backward compatibility

  oldcomp = CurrentCompany;

  if (missedf and oldAct==-1) then begin
    if (blank(callerid) and blank(nr1) and blank(nr2)) then begin
      goto LServerMakeActEndedPhoneCall3;
    end;
    BlockLoad(GCRMb);
    queuename = queue;
    if (queue!="") then begin
      queuecode = right(queue,len(queue)-len("HWQUEUE"));
      PBXQr.Code = queuecode;
      LogText(0,"ServerMakeActEndedPhoneCall3 Queue PBXQr.Code:" & PBXQr.Code);
      if (ReadFirstMain(PBXQr,1,true)) then begin
        queuecompany = StringToLongInt(PBXQr.CRMCompany);
        queuename = PBXQr.Code;
      end;
    end;
    if (queue!="" and queuecompany>0) then begin
      SetCompany(queuecompany,false);
    end else begin
      if (nonblank(GCRMb.MainCRMCompany)) then begin
        SetCompanyCode(GCRMb.MainCRMCompany,false)
      end;
    end;
    BlockLoad(ASTb);
    RecordNew(Actr);
    ActVcRecordDefServer(Actr);
    Actr.SerNr = -1;
    Actr.Invalid = 0;
    Actr.TodoFlag = 1;
    Actr.SymbNr = kActivitySymbolCall;
    Actr.CUCode = cucode;
    Actr.Comment = "";
    CUr.Code = cucode;
    if (ReadFirstMain(CUr,1,true)) then begin
      Actr.CUName = CUr.Name;
      Actr.Contact = CUr.Person;
      Actr.Phone = CUr.Phone;
      if ((CUr.CUType==0) and (CUr.VEType==0)) then begin
        ContactRelr.ContactCode = CUr.Code;
        if (ReadFirstKey("ActContactCode",ContactRelr,1,true)) then begin
          Actr.CUCode = ContactRelr.CustCode;
          Actr.CUName = ContactRelr.CustName;
          Actr.Contact = CUr.Name;
        end;
      end;
    end;
    if (person!="") then begin
      Actr.Contact = person;
    end;
    if (callerid!="") then begin
      Actr.Phone = callerid;
    end;
    if (Actr.Phone=="") then begin
      if (nonblank(nr1) and InString(nr1,"@")==0) then begin
        Actr.Phone = nr1;
      end else begin
        if (nonblank(nr2) and InString(nr2,"@")==0) then begin
          Actr.Phone = nr2;
        end;
      end;
    end;
    if (queuecode!="") then begin
      Actr.PBXQueues = queuecode;
    end;
    Actr.ActType = ASTb.MissedAsteriskCalls;
    Actr.OKFlag = ASTb.MissedAsteriskCallsDone;
    PasteActTypeInAct("",Actr);
    SetActTypeValues(Actr);
    Actr.MainPersons = user;
    Actr.CCPersons = "";
    Actr.AutoGenCallFlag = 1;
    if (nonblank(ASTb.ServerMissedAsteriskCalls)) then begin
      RecordNew(Act2r);
      RecordCopy(Act2r,Actr);
      Act2r.ActType = ASTb.ServerMissedAsteriskCalls;
      Act2r.OKFlag = ASTb.ServerMissedAsteriskCallsDone;
      PasteActTypeInAct("",Act2r);
      SetActTypeValues(Act2r);
      Act2r.SerNr = NextSerNr("ActVc",Act2r.TransDate,-1,false,"");
      RecordStore(Act2r,true);
    end;
    Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
    RecordStore(Actr,false);
    LogText(0,"ServerMakeActEndedPhoneCall3 Actr.SerNr:" & Actr.SerNr & " CurrentCompany:" & CurrentCompany & " Queue:" & Actr.PBXQueues);
  end;
  ResetCompany(oldcomp);
LServerMakeActEndedPhoneCall3:;
end;

global
updating procedure ServerMakeActEndedPhoneCall2(string cucode,string person,string callerid,string user,LongInt oldAct,Integer oldCompno,string nr1,string nr2,Boolean missedf)
begin
  ServerMakeActEndedPhoneCall3(cucode,person,callerid,user,oldAct,oldCompno,nr1,nr2,missedf,"");
end;

//Kept for backward compatibility
global
updating function LongInt ServerOnPhoneCallConnected2(string cucode,string person,string callerid,string user,Integer comidtyp)
begin
  ServerOnPhoneCallConnected2 = -1;
return;
end;

global
updating function LongInt ServerOnPhoneCallConnected4(string cucode,string person,string callerid,string user,Integer comidtyp,string nr1,string nr2,string queue,var Integer ActCompNo)
begin
  record CUVc CUr;
  Boolean res,foundf;
  Integer oldcomp,queuecompany;
  record GlobalCRMBlock GCRMb;
  record ActVc Actr;
  record ASTBlock ASTb;
  record ContactRelVc ContactRelr;
  record ActVc Act2r;
  string 255 phone;
  string 255 compcode;
  record PBXQueueVc PBXQr;
  string 255 queuename;
  string 255 queuecode;

  ServerOnPhoneCallConnected2(cucode,person,callerid,user,comidtyp);

  BlockLoad(GCRMb);

  oldcomp = CurrentCompany;
  if (nonblank(callerid)) then begin
    phone = callerid;
  end;
  if (blank(phone)) then begin
    if (InString(nr1,"@")==0) then begin
      phone = nr1;
    end else begin
      if (InString(nr2,"@")==0) then begin
        phone = nr2;
      end;
    end;
  end;
  queuename = queue;
  if (queue!="") then begin
    queuecode = right(queue,len(queue)-len("HWQUEUE"));
    PBXQr.Code = queuecode;
    LogText(0,"ServerOnPhoneCallConnected4 Queue PBXQr.Code:" & PBXQr.Code);
    if (ReadFirstMain(PBXQr,1,true)) then begin
      queuecompany = StringToLongInt(PBXQr.CRMCompany);
      queuename = PBXQr.Code;
    end;
  end;
  ActCompNo = GetCallerContactRecord(phone,CUr);
  if (ActCompno>-1) then begin
    foundf = true;
  end;
  if (queue!="" and queuecompany>-1) then begin
    ActCompNo = queuecompany;
  end;
  if (ActCompno>-1) then begin
    SetCompany(ActCompNo,false);
  end else begin
    if (GetGlobalUserMainCompany(user,compcode)) then begin
      SetCompanyCode(compcode,false);
    end else begin
      if (nonblank(GCRMb.UserContactCompany)) then begin
        SetCompanyCode(GCRMb.UserContactCompany,false);
      end else begin
        if (nonblank(GCRMb.MainCRMCompany)) then begin
          SetCompanyCode(GCRMb.MainCRMCompany,false);
        end;
      end;
    end;
  end;
  BlockLoad(ASTb);
  RecordNew(Actr);
  ActVcRecordDefServer(Actr);
  Actr.SerNr = -1;
  Actr.Invalid = 0;
  Actr.TodoFlag = 1;
  Actr.SymbNr = kActivitySymbolCall;
  Actr.CUCode = cucode;
  Actr.Comment = "";
  if (ActCompNo<0) then begin
    CUr.Code = cucode;
    if (ReadFirstMain(CUr,1,true)) then begin
      foundf = true;
    end;
  end;
  if (foundf) then begin
    Actr.CUName = CUr.Name;
    Actr.Contact = CUr.Person;
    Actr.Phone = CUr.Phone;
    Actr.CUCode = CUr.Code;
    if ((CUr.CUType==0) and (CUr.VEType==0)) then begin
      ContactRelr.ContactCode = CUr.Code;
      if (ReadFirstKey("ActContactCode",ContactRelr,1,true)) then begin
        Actr.CUCode = ContactRelr.CustCode;
        Actr.CUName = ContactRelr.CustName;
        Actr.Contact = CUr.Name;
      end;
    end;
  end;
  if (person!="") then begin
    Actr.Contact = person;
  end;
  if (phone!="") then begin
    Actr.Phone = phone;
  end;
  if (queuecode!="") then begin
    Actr.PBXQueues = queuecode;
  end;
  Actr.MainPersons = user;
  Actr.CCPersons = "";
  Actr.AutoGenCallFlag = 1;
  RecordNew(Act2r);
  RecordCopy(Act2r,Actr);
  switch (comidtyp) begin
    case comIdTypeSkype:
      Actr.ActType = ASTb.SkypeCalls;
      Actr.OKFlag = ASTb.SkypeCallsDone;
    case comIdTypeAsterisk:
      Actr.ActType = ASTb.AsteriskCalls;
      Actr.OKFlag = ASTb.AsteriskCallsDone;
      Act2r.ActType = ASTb.ServerAsteriskCalls;
      Act2r.OKFlag = ASTb.ServerAsteriskCallsDone;
    case comIdTypeTAPI:
      Actr.ActType = ASTb.AsteriskCalls;
      Actr.OKFlag = ASTb.AsteriskCallsDone;
      Act2r.ActType = ASTb.ServerAsteriskCalls;
      Act2r.OKFlag = ASTb.ServerAsteriskCallsDone;
    otherwise
  end;
  PasteActTypeInAct("",Actr);
  SetActTypeValues(Actr);
  Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
  if (RecordStore(Actr,false)) then begin
  end; 
  if (nonblank(ASTb.ServerAsteriskCalls)) then begin
    Act2r.SerNr = NextSerNr("ActVc",Act2r.TransDate,-1,false,"");
    PasteActTypeInAct("",Act2r);
    SetActTypeValues(Act2r);
    RecordStore(Act2r,true);
  end;
  if (ActCompNo<0) then begin
    ActCompNo = CurrentCompany;
  end;
  ResetCompany(oldcomp);
  LogText(0,"ServerOnPhoneCallConnected4 Actr.SerNr:" & Actr.SerNr & " ActCompNo:" & ActCompNo & " Queue:" & Actr.PBXQueues);
  ServerOnPhoneCallConnected4 = Actr.SerNr;
  return;
end;

global
updating function LongInt ServerOnPhoneCallConnected3(string cucode,string person,string callerid,string user,Integer comidtyp,string nr1,string nr2,var Integer ActCompNo)
begin
  ServerOnPhoneCallConnected3 = ServerOnPhoneCallConnected4(cucode,person,callerid,user,comidtyp,nr1,nr2,"",ActCompNo);
end;

global
updating function LongInt ServerOnPhoneCallConnected(string cucode,string person,string callerid,string user)
begin
  Integer company;
  ServerOnPhoneCallConnected = ServerOnPhoneCallConnected3(cucode,person,callerid,user,comIdTypePhone,"","",company);
end;

global
updating procedure ServerMakeActOutgoingPhoneCall(string cucode,string person,string callerid,string user)
begin
  //Kept for backward compatibility, use ServerOnPhoneCallConnected
end;

global
function string 10 GetClassificationOfType(string Classifications,string CType,var string Comment)
begin
  string 10 res;
  string 255 Code,RemClass;
  record CClassVc CClassr;
  
  Comment = "";
  RemClass = Classifications;
  Code = GetNextValue(RemClass);
  while (nonblank(Code)) begin
    CClassr.Code = Code;
    if (ReadFirstMain(CClassr,1,true)) then begin
      if (CClassr.CType==CType) then begin
        res = Code;
        Comment = CClassr.Comment;
        goto LGetClassificationOfType;
      end;
    end;
    Code = GetNextValue(RemClass);
  end;
LGetClassificationOfType:;
  GetClassificationOfType = res;
  return;
end;

global
function string 255 RemoveClassificationsOfType(string Classifications,string CType)
begin
  string 10 res;
  string 255 Code,RemClass;
  record CClassVc CClassr;
  
  RemClass = Classifications;
  Code = GetNextValue(RemClass);
  while (nonblank(Code)) begin
    CClassr.Code = Code;
    if (ReadFirstMain(CClassr,1,true)) then begin
      if (CClassr.CType!=CType) then begin
        res = AddStr(res,Code,",");
      end;
    end;
    Code = GetNextValue(RemClass);
  end;
  RemoveClassificationsOfType = res;
  return;
end;

global
function string 255 AddBranchObjectToObjectList(string branchid,string objects)
begin
  string 255 res;
  record CUVc BranchCUr;
  
  res = objects;
  if (nonblank(branchid)) then begin
    BranchCUr.Code = branchid;
    ReadFirstMain(BranchCUr,1,true);
    res = AddObjectToObjectList(res,BranchCUr.Objects);
  end;
  AddBranchObjectToObjectList = res;
  return;
end;

global
function Integer OpenArtStat(Integer mwn,record RcVc RepSpec,Boolean selectf)
begin
  Integer res;
  
  if (GuiType!=kGuiiPhone) then begin
    if (IsWebClient) then begin
      res = OpenWindow("ArtStatIClass",0,mwn,"","",RepSpec);
    end else begin
      res = OpenWindow("ArtStatIClass",0,0,"","",RepSpec);
      if (selectf) then begin
        SelectWindow(mwn);
      end;
    end;
  end;

  OpenArtStat = res;
end;

global 
procedure GetListOfUsers(var array string Usersa,var Longint cnta)
begin
  record UserVc Userr;
  Boolean foundf,AddtoListf;
  Integer usertyp;

  cnta = 0;
  Usersa[cnta] = "";
  foundf = true;  
  Userr.Code = "";
  while (LoopMain(Userr,1,foundf)) begin
    if (Userr.Closed==0) then begin
      usertyp = Userr.TypeOfUser;
      AddtoListf = false;
      switch (usertyp) begin
        case kTypeOfUserNamed:        
              AddtoListf = true;
        case kTypeOfUserConcurrent:   
        case kTypeOfUserBusinessCommunicator:
      end;
      if (AddtoListf) then begin 
        Usersa[cnta] = Userr.Code & "," & Userr.Name;
        cnta = cnta + 1;
      end;
    end;
  end;
  return;
end;

global
procedure GetValidUntilDates(array string Usersa,var array date Datesa,var array Integer Activea,Longint cnta,string ProductID,var string funcp) 
begin
  record LicensesVc Lr;
  Integer setno;
  string 255 datastr,func,UserCode,tstr2,tstr3,index,storesku;
  LongInt pos,j;
  date blankdateset,HighestDate; 
  Boolean found,testf,getLatesDatef,functiontagpackagef;
  Integer keys;

//GetSetNr
  switch (GuiType) begin
    case kGuiCocoa:   //kLicItemSourceMacAppStore
      setno = 536; 
    case kGuiiPhone:  //kLicItemSourceiTunesStore
      setno = 537;
  end;  
//    case kLicItemSourceAndroidMarket:
//      setno = 538;
//    case kLicItemSourceCromeWebStore:
//      setno = 539;
//    case kLicItemSourceWindowsMarketplace:
//      setno = 540;
//    case kLicItemSourceHansaWorld:
//      setno = 541;
    
  storesku = StringSetFromString(setno,ProductID);
  datastr = StringFromStringSet(setno,ProductID);
  GetNextSubstring(datastr,pos,":",func); 
  funcp = func;
  if (InString2(funcp,"|")>=0) then begin
    functiontagpackagef = true;
  end;
  
  getLatesDatef = false;
  for (j = 0; j<cnta; j = j + 1) begin
    tstr2 = Usersa[j];
    UserCode = GetNextValue(tstr2);    
    Datesa[j] = blankdateset;
    Activea[j] = 0;
    ResetLoop(Lr);    
    if (TestEnablerFile("EnCopyMarketPlaceLicensesToClient")) then begin 
      keys = 2;
      Lr.UserCode = UserCode;
    end else begin
      keys = 1;
      getLatesDatef = true;
    end;
/*    
    index = "ActiveFunction";
    Lr.Function = func;
    if (functiontagpackagef) then begin
      index = "ActiveStoreSKU";
      Lr.StoreSKU = storesku;
    end;
*/    
    keys = 1;
    index = "ActiveStoreSKU";
    Lr.StoreSKU = storesku;
    found = true;
    while (LoopKey(index,Lr,keys,found)) begin
      if (index=="ActiveFunction") then begin
        if (Lr.Function!=func) then begin found = false; end;
        if (TestEnablerFile("EnCopyMarketPlaceLicensesToClient")) then begin 
          if (Lr.UserCode!=UserCode) then begin found = false; end;
        end;
      end else begin
        if (Lr.StoreSKU!=storesku) then begin found = false; end;
      end;
      if (TestEnablerFile("EnCopyMarketPlaceLicensesToClient")) then begin 
        if (Lr.UserCode!=UserCode) then begin found = false; end;
      end;
      if (found) then begin
        testf = true;
        if (TestEnablerFile("EnCopyMarketPlaceLicensesToClient")) then begin 
          if (Lr.UserCode!=UserCode) then begin testf = false; end;
        end;
        if (testf) then begin
          if (nonblankdate(Lr.EndDate)) then begin
            if (getLatesDatef) then begin 
              if (Datesa[j] < Lr.EndDate) then begin 
                Datesa[j] = Lr.EndDate;
              end;
            end else begin
              Datesa[j] = Lr.EndDate;
              found = false;
            end;
          end;
          if (Lr.Active!=0) then begin 
            Activea[j] = 1;
          end;
        end;
      end;
    end; 
  end; 
  return;
end;

global
procedure GetValidUntilDatesLocalMarketPlace(array string Usersa,var array date Datesa,var array Integer Activea,Longint cnta,string ProductID,var string funcp) 
begin
  GetValidUntilDates(Usersa,Datesa,Activea,cnta,ProductID,funcp);
  return;
end;


updating procedure GetActiveLicencesMacAppStore()
begin
  record LicensesVc Licensesr,OldLicensesr,LicensesrTemp;
  array record LicensesVc Licensesra;
  boolean foundf,updatef;
  Longint i,cnta;
  string 255 UserCode;
  
  cnta = 0;
  foundf= true;
  UserCode = CurrentUser;
  Licensesr.UserCode = UserCode;
  while (LoopKey("ActiveFunction",Licensesr,1,foundf)) begin
    if (Licensesr.UserCode!=UserCode) then begin foundf = false; end;
    if (foundf) then begin
      Licensesra[cnta] = Licensesr;
      cnta = cnta + 1;
    end;
  end;  
  if (cnta > 0) then begin 
    RemoteLicensesUpdate(Licensesra,cnta);
    for (i=0; i<cnta; i=i+1) begin
      updatef = false;

      LicensesrTemp = Licensesra[i];
      Licensesr.SerNr = LicensesrTemp.SerNr;
      if (ReadFirstMain(Licensesr,1,true)) then begin
        if (Licensesr.StoreTransId != LicensesrTemp.StoreTransId) then begin  updatef = true;  end;
        if (Licensesr.Qty != LicensesrTemp.Qty) then begin  updatef = true;  end;
        if (Licensesr.Active != LicensesrTemp.Active) then begin  updatef = true;  end;
        if (updatef) then begin 
          RecordCopy(OldLicensesr,Licensesr);
          Licensesr.Qty = LicensesrTemp.Qty;
          Licensesr.Active = LicensesrTemp.Active;
          Licensesr.StoreTransId = LicensesrTemp.StoreTransId;          
          RecordUpdate(OldLicensesr,Licensesr,false);  
        end;
      end;
    end;
  end; 
  return;
end;

global
updating procedure SendLicensesVctoServer()
begin
  record LicensesVc Licensesr,OldLicensesr,LicensesrTemp;
  array record LicensesVc Licensesra;
  boolean foundf,updatef;
  Longint i,cnta;
  string 255 UserCode;
  
  cnta = 0;
  foundf = true;
  Licensesr.Function = "ServerSlot";
  while (LoopMain(Licensesr,1,foundf)) begin
    if (Licensesr.Function!="ServerSlot") then begin foundf = false; end;
    if (foundf) then begin
      Licensesra[cnta] = Licensesr;
      cnta = cnta + 1;
    end;
  end;  
  if (cnta>0) then begin 
    RemoteLicensesUpdateFromClient(Licensesra,cnta);
  end; 
  return;
end;

global
updating procedure UpdateLocalUserChargeFields()
begin
  record CurLicensesBlock CLb;
  Integer NrUsersToCharge,NrUsersChargedForCurPeriod,AvailableMonths,TotalUserMonths;
  Date CurPeriodEndDate;
  
  if (ClientMode==false or UseExternalLicenseModel==false) then begin
    goto LUpdateLocalUserChargeFields;
  end;
  UpdateRemoteUserChargeFields;
  BlockLoad(CLb);
  GetRemoteUserChargeFields(NrUsersToCharge,NrUsersChargedForCurPeriod,AvailableMonths,TotalUserMonths,CurPeriodEndDate);
  CLb.NrUsersToCharge = NrUsersToCharge;
  CLb.NrUsersChargedForCurPeriod = NrUsersChargedForCurPeriod;
  CLb.AvailableMonths = AvailableMonths;
  CLb.TotalUserMonths = TotalUserMonths;
  CLb.CurPeriodEndDate = CurPeriodEndDate;
  BlockStore(CLb);
LUpdateLocalUserChargeFields:;
end;

global
updating procedure UpdateLocalCompaniesChargeFields()
begin
  record CurLicensesBlock CLb;
  Integer NrCompaniesToCharge,NrCompaniesChargedForCurPeriod,CompaniesAvailableMonths,TotalCompaniesMonths;
  Date CurPeriodEndDate;
  
  if (ClientMode==false or UseExternalLicenseModel==false) then begin
    goto LUpdateLocalCompaniesChargeFields;
  end;
  UpdateRemoteCompaniesChargeFields;
  BlockLoad(CLb);
  GetRemoteCompaniesChargeFields(NrCompaniesToCharge,NrCompaniesChargedForCurPeriod,CompaniesAvailableMonths,TotalCompaniesMonths,CurPeriodEndDate);
  CLb.NrCompaniesToCharge = NrCompaniesToCharge;
  CLb.NrCompaniesChargedForCurPeriod = NrCompaniesChargedForCurPeriod;
  CLb.CompaniesAvailableMonths = CompaniesAvailableMonths;
  CLb.TotalCompaniesMonths = TotalCompaniesMonths;
  CLb.CurPeriodEndDate = CurPeriodEndDate;
  BlockStore(CLb);
LUpdateLocalCompaniesChargeFields:;
end;

global
updating procedure InitMarketPlaceLicenseCopytoClient()
begin
  if (IsStandardProduct) then begin  
    if (GuiType==kGuiCocoa or GuiType==kGuiiPhone) then begin 
      //Temporarily disabled
      if (TestEnablerFile("EnCopyMarketPlaceLicensesToClient")) then begin 
        GetActiveLicencesMacAppStore;    
      end else begin
        SendLicensesVctoServer;
      end;
    end;
  end;
  return;
end;

global
updating procedure StdLocationsCheck()
begin
  record LocationVc Locationr;
  record MainStockBlock MSb;

  if (IsStandardProduct) then begin  
    if (HasModIN==false) then begin
      if (CountRecords("LocationVc")>0) then begin
        if (CountRecords("ItemHistVc")==0) then begin         
          while (LoopMain(Locationr,0,true)) begin
            RecordDelete(Locationr);
            StepBack(Locationr);
          end;
          BlockLoad(MSb);
          MSb.MainStock = "";
          MSb.DefServiceLoc = "";
          BlockStore(MSb); 
        end;    
      end;    
    end;    
  end;
  return;
end;

global
updating procedure StandardPersonalIDWClassSave()
begin
  record RcVc RepSpec;
  integer wn,res;
  
  wn = CurWindow;
  if (wn > 0) then begin 
    if (GetWindowClass(wn)=="StandardPersonalIDWClass") then begin 
      DeselectWindow(wn,false);
      GetWindowRecord(wn,RepSpec);
      if (blank(RepSpec.f3)) then begin 
        MessageBox(1058,": " & USetStr(8909));
        WindowFieldGoto(wn,RepSpec,-1,"f3",true);  
        beep;
        goto LStandardPersonalIDWClassSave;
      end;
      res = StandardPersonalIDWClassSaveRemote(RepSpec.f1,RepSpec.f3);
      if (res!=0) then begin 
        MessageBox(9062,": " & RepSpec.f1);
        CloseWindow(wn);
      end else begin
        beep;
      end;
    end;
  end;
LStandardPersonalIDWClassSave:; 
  return;
end;

global
function integer TestEinvoiceinQueue(LongInt IVserNr)
begin
  integer res;
  record EInvoiceBlock EIb;
  
  res = 0;
  if (HasLocalization("ARG,EST,FIN,HRV,LAT,MEX,NOR,SVN,SWE")) then begin //all envoice countries
    BlockLoad(EIb);
    if (EIb.OutEInvoices!=0) then begin 
      res = TestEinvoiceQueueRemote(IVserNr);
    end;
  end;
  
  TestEinvoiceinQueue = res;
  return;
end;

global
updating procedure EShipPRTWClassSend()
begin
  record RcVc RepSpec;
  Integer wn,mwn,ewn;
  LongInt res;
  record eShipTaxAuthReplyVc eSTARr;
  record SHVc SHr;
  record StockMovVc SMr;
  record RetPUVc RetPUr;
  
  wn = CurWindow;
  if (wn > 0) then begin 
    if (GetWindowClass(wn)=="EShipPRTWClass") then begin 
      DeselectWindow(wn,false);
      GetWindowRecord(wn,RepSpec);
      if (blank(RepSpec.f2)) then begin 
        MessageBox(1058,"");
        WindowFieldGoto(wn,RepSpec,-1,"f2",true);  
        beep;
        goto LEShipPRTWClassSend;
      end;
      if (blank(RepSpec.f3)) then begin 
        MessageBox(1058,"");
        WindowFieldGoto(wn,RepSpec,-1,"f3",true);  
        beep;
        goto LEShipPRTWClassSend;
      end;
      res = EShipPRTWClassSendDo(RepSpec,eSTARr);
      if (res!=0) then begin 
        if (eSTARr.SerNr>0) then begin
          ewn = OpenWindow("eShipTaxAuthReplyDClass",0,0,"","",eSTARr);
        end;
        MessageBox(res,"");        
      end else begin
        MessageBox(33423,"");
      end;
      mwn = MotherWindow(wn);
      CloseWindow(wn);
      if (ewn>0) then begin
        SelectWindow(ewn);
      end;
      if (mwn>0 and res==0) then begin
        switch (RepSpec.f5) begin
          case "SHVc":
            SHr.SerNr = RepSpec.long1;
            if (ReadFirstMain(SHr,1,true)) then begin
              PutWindowRecord(mwn,SHr);
              SetWindowState(mwn,Rs_normal);
            end;
          case "StockMovVc":
            SMr.SerNr = RepSpec.long1;
            if (ReadFirstMain(SMr,1,true)) then begin
              PutWindowRecord(mwn,SMr);
              SetWindowState(mwn,Rs_normal);
            end;
          case "RetPUVc":
            RetPUr.SerNr = RepSpec.long1;
            if (ReadFirstMain(RetPUr,1,true)) then begin
              PutWindowRecord(mwn,RetPUr);
              SetWindowState(mwn,Rs_normal);
            end;
        end;
      end;
    end;
  end;
LEShipPRTWClassSend:; 
  return;
end;

global
function boolean HasFiscalRows()
begin
  boolean res;
  Integer i,rwcnt;
  record YearBlock Yearb;

  res = true;
  if (IsStandardProduct) then begin 
    BlockLoad(Yearb);
    res = (MatRowCnt(Yearb)>0);
  end;  
  HasFiscalRows = res;
  return;
end;

global
function Boolean CheckCreditInvTotOnOrigIV(record IVVc IVp,var string ResultStr,var LongInt Error)
begin
  Boolean res,found,testf;
  record IVVc CredIVVr;
  record IVVc OrigIVVr;
  val CreditTotal,OriginalTotal;
  
  ResultStr = "";
  Error = 0;
  res = false;
  if (IVp.CredInv==-1) then begin 
    goto LCheckCreditInvTotOnOrigIV;
  end;
 
  OrigIVVr.SerNr = IVp.CredInv;
  if (ReadFirstMain(OrigIVVr,1,true)==false) then begin
    goto LCheckCreditInvTotOnOrigIV;
  end;
  OriginalTotal = MulRateToBase1(OrigIVVr.CurncyCode,OrigIVVr.Sum4,OrigIVVr.FrRate,OrigIVVr.ToRateB1,OrigIVVr.ToRateB2,OrigIVVr.BaseRate1,OrigIVVr.BaseRate2,DefaultCurRoundOff);

  found = true;
  ResetLoop(CredIVVr);
  CredIVVr.CredInv = IVp.CredInv;
  while (Loopkey("CredInv",CredIVVr,1,true)) begin
    if (CredIVVr.CredInv != IVp.CredInv) then begin 
      found = false;
    end;
    if (found) then begin 
      testf = true;
      if (CredIVVr.OKFlag==0) then begin 
        testf = false;
      end;
      if (CredIVVr.Invalid!=0) then begin 
        testf = false;
      end;
      if (CredIVVr.SerNr==IVp.SerNr) then begin 
        testf = false;
      end;      
      if (testf) then begin 
        if (CredIVVr.InvType==kInvoiceTypeCredit or CredIVVr.InvType==kInvoiceTypeCreditSpecialSales) then begin 
          CreditTotal = CreditTotal +  MulRateToBase1(CredIVVr.CurncyCode,CredIVVr.Sum4,CredIVVr.FrRate,CredIVVr.ToRateB1,CredIVVr.ToRateB2,CredIVVr.BaseRate1,CredIVVr.BaseRate2,DefaultCurRoundOff);
        end;
      end;
    end;
  end;
  
  CreditTotal = CreditTotal +  MulRateToBase1(IVp.CurncyCode,IVp.Sum4,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  if (CreditTotal>OriginalTotal) then begin 
    res = true;
    ResultStr = "";
    Error = 33708;
  end;
LCheckCreditInvTotOnOrigIV:;  
  CheckCreditInvTotOnOrigIV = res;
  return;
end;

updating procedure AccBlockUpdate()
begin
  record AccBlock AccRec;
  
  if (HasLocalization("PRT")) then begin
    BlockLoad(AccRec);
    if (AccRec.CreditIVTotNotExceedInvCheck!=1) then begin 
      AccRec.CreditIVTotNotExceedInvCheck = 1;      
      BlockStore(AccRec);
    end;
  end;  
  return;
end;

global
updating procedure UpdateSettingsforCountries()
begin

  AccBlockUpdate;
  return;
end;

global
function Boolean ItemInItemGroupOrClass(string itemcode,string itemgroup,string itemclass)
begin
  record INVc INr;
  boolean res,testf;
  
  testf = true;
  if (nonblank(itemgroup) or nonblank(itemclass)) then begin
    if (ReadFirstItem(itemcode,INr,false,false)==false) then begin testf = false;  end;
    if (testf and nonblank(itemgroup)) then begin 
      if (INr.Group!=itemgroup) then begin
        testf = false;
      end;
    end;
    if (testf and nonblank(itemclass)) then begin 
      if (SetInSet2(itemclass,INr.DispGroups)==false) then begin
        testf = false;
      end;
    end;              
  end;
  res = testf;
  ItemInItemGroupOrClass = res;
  return;
end;

global
function Boolean RentalItemInItemGroupOrClass(string itemcode,string itemgroup,string itemclass)
begin
  record RentINVc RentINr;
  boolean res,testf;
  
  testf = true;
  if (nonblank(itemgroup) or nonblank(itemclass)) then begin
    RentINr.Code = itemcode;
    testf = ReadFirstMain(RentINr,1,true);
    if (testf and nonblank(itemgroup)) then begin 
      testf = (RentINr.Group==itemgroup);
    end;
// Possible if classifcation gets added to rental item register    
//     if (testf and nonblank(itemclass)) then begin 
//       if (SetInSet2(itemclass,INr.DispGroups)==false) then begin
//         testf = false;
//       end;
//     end;              
  end;
  res = testf;
  RentalItemInItemGroupOrClass = res;
  return;
end;

global
function Boolean ContactInGroupClass2(string contactcode,string category,string class,string classtype,string cattype,string compcat,string comnpareclass)
begin
  record CUVc CUr;
  boolean res,testf;
  string 255 testcompcat,testcomnpareclass;
  string 5 fromcat,tocat;
  
  testf = true;
  if ((blank(compcat) or blank(comnpareclass)) and nonblank(contactcode)) then begin 
    CUr.Code = contactcode;
    if (ReadFirstMain(CUr,1,true)==false) then begin 
      testf = false; 
    end else begin
      switch (cattype) begin
        case "CUST":  testcompcat = CUr.CustCat;
        case "SUPP":  testcompcat = CUr.VECat;
        otherwise
          testcompcat = CUr.CustCat;
      end;  
      testcomnpareclass = CUr.Classification;      
    end;
  end else begin
    testcompcat = compcat;
    testcomnpareclass = comnpareclass;
  end;
  if (testf) then begin 
    if (nonblank(category)) then begin 
      fromcat = FirstInRange(category,5);
      tocat = LastInRange(category,5);
      if (testcompcat<fromcat) or (testcompcat>tocat) then begin
        testf = false;
      end;
    end;
    if (testf and nonblank(class)) then begin 
      if (SetInSet2(class,testcomnpareclass)==false) then begin
        testf = false;
      end;
    end;  
    if (testf and nonblank(classtype)) then begin 
      testf = false;
      ClassTypef(classtype,testcomnpareclass,testf);
    end;                    
  end;
  res = testf;
  ContactInGroupClass2 = res;
  return;
end;


global
function Boolean ContactInGroupClass(string contactcode,string category,string class,string cattype,string compcat,string comnpareclass)
begin
  ContactInGroupClass = ContactInGroupClass2(contactcode,category,class,"",cattype,compcat,comnpareclass);
 return;
end;

global
function Boolean CheckEmailStr(string email)
begin
  Boolean res;
  Integer i,l,lastdotpos,atpos;

  l = len(email);
  atpos = -1;
  lastdotpos = -1;
  for (i = 0; i<l; i = i + 1) begin
    if ((mid(email,i,1)=="@") and (atpos!=-1)) then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="@") then begin atpos = i; end;
    if (mid(email,i,1)==".") then begin lastdotpos = i; end;
    if (mid(email,i,1)==" ") then begin goto LCheckEmailStr; end;

// (),:;<>@[\] requires the Quoted-string form which RFC5321 recommends not to be used:
// "a host that expects to receive mail SHOULD avoid defining mailboxes where the Local-part requires (or uses) the Quoted-string form"

    if (mid(email,i,1)==",") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="(") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)==")") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)==":") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)==";") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="<") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)==">") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="[") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="\\") then begin goto LCheckEmailStr; end;
    if (mid(email,i,1)=="]") then begin goto LCheckEmailStr; end;
  end;

  if (atpos>0) then begin
    if ((lastdotpos>(atpos+1)) and (lastdotpos!=(l-1))) then begin
      res = true;
    end;
  end;

LCheckEmailStr:;
  CheckEmailStr = res;
  return;
end;
global
function Boolean INInvRecepyExists(string InvRecepy)
begin
  record RecVc Recr;
  Boolean res;

  if (nonblank(InvRecepy)) then begin 
    Recr.Code = InvRecepy;
    res = ReadFirstMain(Recr,1,true);
  end;
  INInvRecepyExists = res;
  return;
end;

global
procedure OutEmpty(record RcVc RepSpec,Integer Count)
begin
  Integer i;
  
  if (RepSpec.Media==mtFile or RepSpec.Media==mtExcel or RepSpec.Media==mtClipBoard) then begin
    for (i=0;i<Count;i=i+1) begin
      OutString(0,0,"",false);
    end;
  end;
  return;
end;


global
function string 255 GetCurrentStoreName()
begin
  string 255 res;
  switch (GuiType) begin
    case kGuiCocoa:
      res = StringFromSet(528,kLicItemSourceMacAppStore);
    case kGuiiPhone:
      res = StringFromSet(528,kLicItemSourceiTunesStore);
    case kGuiAndroid:
      res = StringFromSet(528,kLicItemSourceAndroidMarket);
    case kGuiMetro:
      res = StringFromSet(528,kLicItemSourceWindowsMarketplace);
  end;
  GetCurrentStoreName = res;
end;

global
procedure OpenMyServers()
begin
  string 255 myserversurl;

  myserversurl = "http://myservers.hansaworld.com"; //Create service to find out!
  OpenWebBrowser(myserversurl);
end;

global
procedure ReportToUserOrLog(Boolean automatic,Integer no,string extrainfo)
begin
  if (automatic==false) then begin
    MessageBox(no,extrainfo);
  end;
//  end else begin
    LogText(no,extrainfo);
//  end;
  return;
end;


function string 255 FileSizeToStringHelper(Val sz,string sign)
begin
  string 255 res;
  val v1,divisor;

  switch (sign) begin
    case "G": divisor = 1073741824;
    case "M": divisor = 1048576;
    case "K": divisor = 1024;
    otherwise
      divisor = 1;
  end;

  if (sz>=divisor) then begin
    v1 = sz / divisor;
    if (v1<10) then begin
      res = ValToString(v1,M41Val,"",".",0);
    end else begin
      res = ValToString(v1,M40Val,"",".",0);
    end;
  end;

  if (right(res,2)==".0") then begin
    res = left(res,len(res)-2);
  end;

  if (nonblank(res)) then begin
    res = res & sign;
  end;

  FileSizeToStringHelper = res;
  return;
end;

global
function string 255 FileSizeToString(Val sz)
begin
  string 255 res;

  res = FileSizeToStringHelper(sz,"G");
  if (blank(res)) then begin res = FileSizeToStringHelper(sz,"M"); end;
  if (blank(res)) then begin res = FileSizeToStringHelper(sz,"K"); end;
  if (blank(res)) then begin
    res = ValToString(sz,M40Val,"",".",0);
    if (blank(res)) then begin res = "0"; end;
    res = res & "B";
  end;

LFileSizeToString:;
  FileSizeToString = res;
  return;
end;
