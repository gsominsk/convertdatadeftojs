external function val NumberOfStayDays(Date,Date,Time,Time,Integer);
external function Boolean DateTimeInsideDateTime(Date,Time,Date,Time,Date,Time,Date,Time);
external function roundmode SetRoundModeD(Integer);
external function Boolean SkipResTest(record ReservationStatusVc,Boolean);
external function Integer GetIntYc(Date);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
remote procedure BIChart_remote_DebtorsCreditorsAsyncCallback(Integer,array string,array val,array string,array val);
remote procedure BIChart_remote_TopCustomersAsyncCallback(Integer,array string,array val);
remote procedure BIChart_remote_ItemGroupsAsyncCallback(Integer,array string,array val);
remote procedure BIChart_remote_TopSalesmenAsyncCallback(Integer,array string,array val);
remote procedure BIChart_remote_PnLAsyncCallback(Integer,array string,array val);
remote procedure BIChart_remote_PipelineAsyncCallback(Integer,array string,array val);
remote procedure ResDCLass_BIChart_remote_AsyncCallback(Integer,val,Array val,Array Integer);
remote procedure ResTypeDClass_BICharts_remote_AsyncCallback(Integer,val,Array val,Array Integer,vector val);
external function val GetCUTurnover(record CUVc,string,string,string,Date,Date,string,string,string,string);
external function LongInt TimeDiffinMinutes(Time,Time);
external function LongInt DateDiff(Date,Date);
external function LongInt RTLen(Date,Date,Time,LongInt,LongInt);

global
procedure CUDCLass_BIChart_Tool(record CUVc CUr,var val maxv,var Array val vsales,var Array Integer vmonth)
begin
  Date sd,ed;
  Integer i;

  sd = CurrentDate;
  sd = AddMonth(sd,-11);
  
  for (i=1;i<=12;i=i+1) begin
    sd.day = 1;
    ed = sd;
    ed.day = DaysInMonth(ed.year,ed.month);
    vsales[i] = GetTurnover(CUr,"salesexclvat",sd,ed);
    vmonth[i] = ed.month;
    sd = AddMonth(sd,1);
    if (maxv<vsales[i]) then begin maxv = vsales[i]; end;
  end;
  return;
end;

global
procedure INDCLass_BIChart_Tool(record INVc INr,var val maxv,var Array val vsales,var Array Integer vmonth)
begin
  Date sd,ed;
  Integer i;

  sd = CurrentDate;
  sd = AddMonth(sd,-11);
  
  for (i=1;i<=12;i=i+1) begin
    sd.day = 1;
    ed = sd;
    ed.day = DaysInMonth(ed.year,ed.month);
    vsales[i] = GetTurnover(INr,"salesexclvat",sd,ed);
    vmonth[i] = ed.month;
    sd = AddMonth(sd,1);
    if (maxv<vsales[i]) then begin maxv = vsales[i]; end;
  end;
  return;
end;

global
procedure ITDCLass_BIChart_Tool(record ITVc ITr,var val maxv,var Array val vsales,var Array Integer vmonth)
begin
  Date sd,ed;
  Integer i;
  Boolean found;
  record INVc INr;
  
  found = true;
  INr.Group = ITr.Code;
  while (LoopKey("Group",INr,1,found)) begin
    if (INr.Group!=ITr.Code) then begin found = false; end;
    if (found) then begin
      sd = CurrentDate;
      sd = AddMonth(sd,-11);
      for (i=1;i<=12;i=i+1) begin
        sd.day = 1;
        ed = sd;
        ed.day = DaysInMonth(ed.year,ed.month);
        vsales[i] = vsales[i] + GetTurnover(INr,"salesexclvat",sd,ed);
        vmonth[i] = ed.month;
        sd = AddMonth(sd,1);
        if (maxv<vsales[i]) then begin maxv = vsales[i]; end;
      end;
    end;
  end;
  return;
end;

global
procedure CCATDCLass_BIChart_Tool(record CCATVc CCatr,var val maxv,var Array val vsales,var Array Integer vmonth)
begin
  Date sd,ed;
  Integer i;
  Boolean found;
  record CUVc CUr;
  
  found = true;
  CUr.CustCat = CCatr.Code;
  while (LoopKey("Group",CUr,1,found)) begin
    if (CUr.CustCat!=CCatr.Code) then begin found = false; end;
    if (found) then begin
      sd = CurrentDate;
      sd = AddMonth(sd,-11);
      for (i=1;i<=12;i=i+1) begin
        sd.day = 1;
        ed = sd;
        ed.day = DaysInMonth(ed.year,ed.month);
        vsales[i] = vsales[i] + GetTurnover(CUr,"salesexclvat",sd,ed);
        vmonth[i] = ed.month;
        sd = AddMonth(sd,1);
        if (maxv<vsales[i]) then begin maxv = vsales[i]; end;
      end;
    end;
  end;
  return;
end;

function val OutstandingQuotations()
begin
  val res;
  record QTVc QTr;
  Boolean found;
  
  found = true;
  QTr.Rejected = 0;
  while (LoopKey("Rejected",QTr,1,found)) begin
    if (QTr.Rejected!=0) then begin found = false; end;
    if (found) then begin
      res = res + QTr.BaseSum4;
    end;
  end;
  OutstandingQuotations = res;
  return;
end;

function val OutstandingOrders()
begin
  val res;
  record ORVc ORr;
  Boolean found;
  
  found = true;
  ORr.OSFlag = 1;
  while (LoopKey("OSFlag",ORr,1,found)) begin
    if (ORr.OSFlag!=1) then begin found = false; end;
    if (found) then begin
      res = res + ORr.BaseSum4;
    end;
  end;
  OutstandingOrders = res;
  return;
end;

function val OpenInvoices()
begin
  val res;
  record ARVc ARr;
  Boolean found;
  
  found = true;
  while (LoopMain(ARr,1,found)) begin
    if (found) then begin
      res = res + ARr.BookRVal;
    end;
  end;
  OpenInvoices = res;
  return;
end;

global
procedure BIChart_remote_Pipeline(var array string labels,var array val val0)
begin
  labels[0] = USetStr(38150);
  val0[0] = OutstandingQuotations;
  
  labels[1] = USetStr(38151);
  val0[1] = OutstandingOrders;
  
  labels[2] = USetStr(38152);
  val0[2] = OpenInvoices;  
end;

global
procedure BIChart_remote_PnL(var array string labels,var array val val0)
begin
  Date sd,ed,ld;
  Integer i;
  record ObjBalVc ObjBalr;
  record AccVc Accr;
  Boolean found,testf;
  
  ClearArray(labels);
  ClearArray(val0);
  ld = AddMonth(CurrentDate,-1);
  sd = AddMonth(ld,-5);
  sd.day = 1;
  ld.day = DaysInMonth(ld.year,ld.month);
  while (sd<ld) begin  
    i = labels.length;
    labels[i] = USetStr(2870+sd.month);
    found = true;
    ResetLoop(Accr);
    RecordClear(Accr);
//    Accr.AccNumber = "41900";
    while (LoopMain(Accr,1,found)) begin
//      if (Accr.AccNumber!="41900") then begin found = false; end;
      if (found) then begin
        testf = false;
        if (Accr.AccType==kAccTypeIncome or Accr.AccType==kAccTypeExpense) then begin
          testf = true;
        end;
        if (testf) then begin
          ObjBalr.AccNumber = Accr.AccNumber;
          ObjBalr.Object = "";
          ed = sd;
          ed.day = DaysInMonth(ed.year,ed.month);
          val0[i] = val0[i] - GetTurnover(ObjBalr,"transdebit",sd,ed) + GetTurnover(ObjBalr,"transcredit",sd,ed);
        end;
      end;
    end;
    sd = AddMonth(sd,1);
  end;
end;

function val SalesmanTurnover(string salesman,date sd,date ed)
begin
  record IUSVc IUSr;
  val res;
  Boolean foundf;
  
  foundf = true;
  IUSr.UserCode = salesman;
  
  while (LoopMain(IUSr,1,foundf)) begin
    if (IUSr.UserCode!=salesman) then begin foundf = false; end;
    if (foundf) then begin
      res = res + GetTurnover(IUSr,"salesexclvat",sd,ed);
      // totgp = totgp + GetTurnover(IUSr,"grossprofit",sDate,eDate);
    end;
  end;
  
  SalesmanTurnover = res;
end;

global
procedure BIChart_remote_TopSalesMen(var array string labels,var array val val0)
begin
  record UserVc USr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw;

  ClearArray(labels);
  ClearArray(val0);
  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);

  while (LoopMain(USr,1,true)) begin
    IVrw.Sum = SalesmanTurnover(USr.Code,sd,ed);
    IVrw.Spec = USr.Code;
    if (IVrw.Sum!=0) then begin
      MatRowPut(IVr,MatRowCnt(IVr),IVrw);
    end;
  end;

  SortRows(IVr,"Sum",false);

  for (rw = 0; rw<5; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[4-rw] = IVrw.Sum;
    labels[4-rw] = IVrw.Spec;
    //StopAlert(rw & "-" & IVrw.Spec & "-" & IVrw.Sum);
  end;
end;

global
procedure BIChart_remote_TopCustomers(var array string labels,var array val val0)
begin
  record IVVc IVr;
  row IVVc IVrw;
  record CSVc CSr;
  record CUVc CUr;
  val t;
  date sd,ed;
  LongInt rw,rwcnt;
  Boolean testf;
  vector Boolean vcustf;
  
  ClearArray(labels);
  ClearArray(val0);
  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);
  while (LoopMain(CSr,1,true)) begin
    testf = true;
    if (vcustf[CSr.CustCode]) then begin testf = false; end;
    if (testf) then begin
      CUr.Code = CSr.CustCode;
      ReadFirstMain(CUr,1,true);
      t = GetCUTurnover(CUr,"","","salesexclvat",sd,ed,"","","","");
      IVrw.Sum = t;
      if (IVrw.Sum!=0) then begin
        IVrw.Spec = CUr.SearchKey;
        if (blank(IVrw.Spec)) then begin
          IVrw.Spec = Left(CUr.Name,10);
        end;
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
      end;
      vcustf[CSr.CustCode] = true;
    end;
  end;
  
  SortRows(IVr,"Sum",false);

  rwcnt = MatRowCnt(IVr);
  if (rwcnt>5) then begin rwcnt = 5; end;
  
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[rwcnt-1-rw] = IVrw.Sum;
    labels[rwcnt-1-rw] = IVrw.Spec;
  end;
end;

function val GetITTurnover(record ITVc ITr,date sd,date ed)
begin
  Integer i;
  Boolean found;
  record INVc INr;
  val res;
  
  found = true;
  INr.Group = ITr.Code;
  
  while (LoopKey("Group",INr,1,found)) begin
    if (INr.Group!=ITr.Code) then begin found = false; end;
    if (found) then begin
      res = res + GetTurnover(INr,"salesexclvat",sd,ed);
    end;
  end;
  
  GetITTurnover = res;
  return;
end;

global
procedure BIChart_remote_ItemGroups(var array string labels,var array val val0)
begin
  record ITVc ITr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw;
  
  ClearArray(labels);
  ClearArray(val0);
  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);
  
  while (LoopMain(ITr,1,true)) begin
    IVrw.Sum = GetITTurnover(ITr,sd,ed);
    IVrw.Spec = ITr.Code;
    if (IVrw.Sum!=0) then begin
      MatRowPut(IVr,MatRowCnt(IVr),IVrw);
    end;
  end;
  
  SortRows(IVr,"Sum",false);
  
  for (rw = 0; rw<5; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[4-rw] = IVrw.Sum;
    labels[4-rw] = IVrw.Spec;
    //StopAlert(rw & "-" & IVrw.Spec & "-" & IVrw.Sum);
  end;
end;

function val GetCUBalance(record CUVc CUr)
begin
  record ARVc ARr;
  record APVc APr;
  val res;
  Boolean foundf;
  
  ARr.CustCode = CUr.Code;
  foundf = true;
  while (LoopKey("CustCode",ARr,1,foundf)) begin
    if (ARr.CustCode<>CUr.Code) then begin foundf = false; end;
    if (foundf) then begin
      res = res + ARr.RVal;
    end;
  end;
  
  APr.VECode = CUr.Code;
  foundf = true;
  while (LoopKey("VECode",APr,1,foundf)) begin
    if (APr.VECode<>CUr.Code) then begin foundf = false; end;
    if (foundf) then begin
      res = res - APr.RVal;
    end;
  end;
  
  GetCUBalance = res;
end;

global
procedure BIChart_remote_DebtorsCreditors(var array string labels0,var array val val0,var array string labels1,var array val val1)
begin
  record CSVc CSr;
  record ARVc ARr;
  record CUVc CUr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw,rwcnt;
  Boolean testf;
  vector Boolean vcustf;
  string 255 lastcu;
  
  ClearArray(labels0);
  ClearArray(val0);
  ClearArray(labels1);
  ClearArray(val1);


  sd = "01/01/1980";
  ed = CurrentDate;
  ed.day = DaysInMonth(ed.year,ed.month);
  while (LoopMain(CSr,1,true)) begin
    testf = true;
    if (vcustf[CSr.CustCode]) then begin testf = false; end;
    if (testf) then begin
      CUr.Code = CSr.CustCode;
      ReadFirstMain(CUr,1,true);
      IVrw.Sum = GetCUTurnover(CUr,"","","salesexclvat",sd,ed,"","","","");
      if (IVrw.Sum!=0) then begin
        IVrw.Spec = Left(CUr.Name,40);
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
      end;
    end;
  end;
  SortRows(IVr,"Sum",false);
  rwcnt = MatRowCnt(IVr);
  if (rwcnt>6) then begin rwcnt = 6; end;
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    if (IVrw.Sum!=0) then begin
      val0[rw] = IVrw.Sum;
      labels0[rw] = IVrw.Spec;
    end;
  end;

// some verison of GetOnAccBalance
  RecordClear(IVr);
  ClearRow(IVr,IVrw,kInvoiceRowTypeNormal);
  while (LoopKey("CustCode",ARr,1,true)) begin
    if (ARr.CustCode!=lastcu and nonblank(lastcu)) then begin
      if (IVrw.Sum!=0) then begin
        CUr.Code = lastcu;
        ReadFirstMain(CUr,1,true);
        IVrw.Spec = Left(CUr.Name,40);
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
        ClearRow(IVr,IVrw,kInvoiceRowTypeNormal);
      end;
    end;
    IVrw.Sum = IVrw.Sum + ARr.RVal;
    lastcu = ARr.CustCode;
  end;  
  if (IVrw.Sum!=0) then begin
    CUr.Code = lastcu;
    ReadFirstMain(CUr,1,true);
    IVrw.Spec = Left(CUr.Name,40);
    MatRowPut(IVr,MatRowCnt(IVr),IVrw);
  end;
  

  SortRows(IVr,"Sum",false);  
  rwcnt = MatRowCnt(IVr);
  if (rwcnt>6) then begin rwcnt = 6; end;
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    if (IVrw.Sum!=0) then begin
      val1[rw] = IVrw.Sum;
      labels1[rw] = IVrw.Spec;
    end;
  end;
  
end;



//-------- ASYNC
procedure AddOnAccToDebtorsArray(vector LongInt vcustcoderownr,var record IVVc IVr,string custcode,val t)
begin
  record CUVc CUr;
  row IVVc IVrw;
  LongInt rownr;

  rownr = vcustcoderownr[custcode];
  if (rownr<0) then begin
    ClearRow(IVr,IVrw,kInvoiceRowTypeNormal);
    CUr.Code = custcode;
    ReadFirstMain(CUr,1,true);
    IVrw.Spec = Left(CUr.Name,40);
    rownr = MatRowCnt(IVr);
    vcustcoderownr[custcode] = rownr;
  end else begin
    MatRowGet(IVr,rownr,IVrw);
  end;
  IVrw.Sum = IVrw.Sum - t;
  MatRowPut(IVr,rownr,IVrw);
  return;
end;

procedure AddOnAccBalance(vector LongInt vcustcoderownr,var record IVVc IVr)
begin
  record IPrsVc IPrsr;
  record ARPayHistVc ARPHr;  

  record IPVc IPr;
  row IPVc IPrw;
  record TRVc TRr;
  row TRVc TRrw;
  record PurgeTRVc PurgeTRr;
  Integer i,rwcnt;
  Boolean found,testf;
  val t;
  vector Boolean viprowprntdf;

  IPrsr.IVNr = -1;
  IPrsr.TransType = kIPrsTransTypeReceipt;
  found = true;
  while (LoopKey("OnAcc",IPrsr,1,found)) begin
    if (IPrsr.IVNr!=-1) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (testf) then begin
        switch (IPrsr.TransType) begin
          case kIPrsTransTypeReceipt:
            IPr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(IPr,1,true)) then begin
              if (IPr.RejectedFlag==0) then begin
                rwcnt = MatRowCnt(IPr);
                for (i=0;i<rwcnt;i=i+1) begin
                  MatRowGet(IPr,i,IPrw);
                  if ((IPrw.InvoiceNr==-1) and (IPrw.CUPNr==-1) and (IPrw.stp==1)) then begin
                    if (IPr.TransDate==IPrsr.TransDate and viprowprntdf[IPr.SerNr & ":" & i]==false) then begin
                      viprowprntdf[IPr.SerNr & ":" & i] = true;
                
                      t = IPrw.B1BankVal;
                      if (blank(t)) then begin
                        t = MulWithRateToBase1(IPrw.BankCurncy,IPr.TransDate,IPrw.BankVal,DefaultCurRoundOff);
                      end;
                      AddOnAccToDebtorsArray(vcustcoderownr,IVr,IPrw.CustCode,t);
                    end;
                  end;
                end;
              end;
            end;
          case kIPrsTransTypeNLTransaction:
            testf = true;
            TRr.Number = IPrsr.TransNr;
            TRr.IntYc = GetIntYc(IPrsr.TransDate);                
            if (ReadFirstMain(TRr,2,true)) then begin
              if (TRr.TransDate!=IPrsr.TransDate) then begin
                testf = false;
              end;
              if (testf) then begin          
                rwcnt = MatRowCnt(TRr);
                for (i=0; i<rwcnt; i=i+1) begin
                  MatRowGet(TRr,i,TRrw);
                  if (TRrw.ovst==0 and TRrw.stp==1) then begin
                    if (TRrw.SerNr==-1 and TRrw.Typ==1) then begin
                      t = TRrw.CredVal;
                      if (blank(t)) then begin
                        t = -TRrw.DebVal;
                      end;
                      AddOnAccToDebtorsArray(vcustcoderownr,IVr,TRrw.CompCode,t);
                    end;
                  end;
                end;
              end;
            end;
          case kIPrsTransTypePurgeNLTransaction:
            testf = true;
            PurgeTRr.Number = IPrsr.TransNr;
            PurgeTRr.IntYc = GetIntYc(IPrsr.TransDate);                
            PurgeTRr.TransRow = IPrsr.TransRow;
            if (ReadFirstMain(PurgeTRr,3,true)) then begin
              if (PurgeTRr.TransDate!=IPrsr.TransDate) then begin testf = false; end;
              if (PurgeTRr.SerNr!=-1) then begin testf = false; end;
              if (PurgeTRr.Typ!=1) then begin testf = false; end;
              if (testf) then begin          
                t = PurgeTRr.CredVal;
                if (blank(t)) then begin
                  t = -PurgeTRr.DebVal;
                end;
                AddOnAccToDebtorsArray(vcustcoderownr,IVr,PurgeTRr.CompCode,t);
              end;
            end;
        end;
      end;
    end;
  end;

  found = true;
  while (LoopKey("CustCode",ARPHr,1,found)) begin
    if (found) then begin
      t = 0;
      switch (ARPHr.FileName) begin
        case "IVVc":
          t = -ARPHr.BookVal;
        case "IPVc":
          t = ARPHr.BookVal;
        case "CLInVc":
          t = ARPHr.BookVal;
        case "CLOutVc":
          t = -ARPHr.BookVal;
      end;
      AddOnAccToDebtorsArray(vcustcoderownr,IVr,ARPHr.CustCode,t);
    end;
  end;
  return;
end;

global
procedure BIChart_remote_DebtorsCreditorsAsync(Integer wn)
begin
  array string 255 labels0; 
  array val val0;
  array string 255 labels1;
  array val val1;
  record CSVc CSr;
  record ARVc ARr;
  record CUVc CUr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw,rwcnt;
  Boolean testf;
  vector Boolean vcustf;
  string 255 lastcu;
  vector LongInt vcustcoderownr;

  if (ThisIsMainThread) then begin
    LogText(0,"Warning: Processing BI on main thread (check Parallel Reports setting)");
  end;

  sd = "01/01/1980";
  ed = CurrentDate;
  ed.day = DaysInMonth(ed.year,ed.month);
  while (LoopMain(CSr,1,true)) begin
    testf = true;
    if (vcustf[CSr.CustCode]) then begin testf = false; end;
    if (testf) then begin
      CUr.Code = CSr.CustCode;
      ReadFirstMain(CUr,1,true);
      IVrw.Sum = GetCUTurnover(CUr,"","","salesexclvat",sd,ed,"","","","");
      if (IVrw.Sum!=0) then begin
        IVrw.Spec = Left(CUr.Name,40);
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
      end;
    end;
  end;
  SortRows(IVr,"Sum",false);
  rwcnt = MatRowCnt(IVr);
  if (rwcnt>6) then begin rwcnt = 6; end;
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    if (IVrw.Sum!=0) then begin
      val0[rw] = IVrw.Sum;
      labels0[rw] = IVrw.Spec;
    end;
  end;

// some verison of GetOnAccBalance
  RecordClear(IVr);
  ClearRow(IVr,IVrw,kInvoiceRowTypeNormal);
  while (LoopKey("CustCode",ARr,1,true)) begin
    if (ARr.CustCode!=lastcu and nonblank(lastcu)) then begin
      if (IVrw.Sum!=0) then begin
        CUr.Code = lastcu;
        ReadFirstMain(CUr,1,true);
        IVrw.Spec = Left(CUr.Name,40);
        rw = MatRowCnt(IVr);
        MatRowPut(IVr,rw,IVrw);
        vcustcoderownr[lastcu] = rw;
        ClearRow(IVr,IVrw,kInvoiceRowTypeNormal);
      end;
    end;
    IVrw.Sum = IVrw.Sum + ARr.BookRVal;
    lastcu = ARr.CustCode;
  end;  
  if (IVrw.Sum!=0) then begin
    CUr.Code = lastcu;
    ReadFirstMain(CUr,1,true);
    IVrw.Spec = Left(CUr.Name,40);
    rw = MatRowCnt(IVr);
    MatRowPut(IVr,rw,IVrw);
    vcustcoderownr[lastcu] = rw;
  end;
  AddOnAccBalance(vcustcoderownr,IVr);

  SortRows(IVr,"Sum",false);  
  rwcnt = MatRowCnt(IVr);
  if (rwcnt>6) then begin rwcnt = 6; end;
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    if (IVrw.Sum!=0) then begin
      val1[rw] = IVrw.Sum;
      labels1[rw] = IVrw.Spec;
    end;
  end;
  clientremoteasync.BIChart_remote_DebtorsCreditorsAsyncCallback(wn,labels0,val0,labels1,val1);
  return;  
end;

function Longint DateTimeDiffInMinutes(date d1,time t1,date d2,time t2)
begin
  integer days;
  longint minutes;

  minutes = TimeDiffInMinutes(t2,t1);
  days = DateDiff(d2,d1);
  if ((days==1) and (minutes<=1440)) then begin minutes = minutes + 1440; end;
  if (days>1) then begin minutes = minutes + (1440*(days-1)); end;

  DateTimeDiffInMinutes = minutes;
  return;
end;

global
procedure CloudNodeDCLass_Chart_Tool(record CloudNodeVc CNr,var array val aMem,var array val aDisk,var array val aSysCPU,var array val aSwap,var array Date aDate,var array string aTime)
begin
  record CloudMachineStatsVc CMSr;
  Boolean TrHs,testf,foundf,firstf;
  string 20 tag;
  Date lastdate;
  Integer i,hourmod;
  vector Boolean vAdded;
  Longint diff;
  Date sd;
  Time st,oldst;
  Integer cnt;

  /*
  CMSr.ServerCode = CNr.Code;
  CMSr.Date = AddDay(CurrentDate,-15);
  TrHs = true;
  while (LoopKey("MainKey",CMSr,2,TrHs)) begin
    if (CNr.Code!=CMSr.ServerCode) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      hourmod = Mod(GetHour(CMSr.Time),12);
      if (hourmod==0 and vAdded[CMSr.Date & ":" & Left(CMSr.Time,2)]==false) then begin
        aDisk[aDisk.length] = CMSr.ServerDiskFree;
        aDate[aDate.length] = CMSr.Date;
        vAdded[CMSr.Date & ":" & Left(CMSr.Time,2)] = true;
      end;
      diff = DateTimeDiffInMinutes(CMSr.Date,CMSr.Time,CurrentDate,CurrentTime);
      if (diff<360) then begin
        if (vAdded[CMSr.Date & ":" & Left(CMSr.Time,4)]==false) then begin
          aMem[aMem.length] = CMSr.MemTotal - CMSr.MemUsed;
          aSysCPU[aSysCPU.length] = CMSr.SystemCPUTime;
          aSwap[aSwap.length] = CMSr.SwapUsed;
          aTime[aTime.length] = Left(CMSr.Time,5);
          vAdded[CMSr.Date & ":" & Left(CMSr.Time,4)] = true;
        end;
      end;
    end;
  end;
  */

  sd = CurrentDate;
  st = CurrentTime;
  testf = true;
  foundf = true;
  firstf = false;
  while (testf) begin
    ResetLoop(CMSr);
    CMSr.Date = sd;
    CMSr.Time = st;
    CMSr.ServerCode = CNr.Code;
    TrHs = true;
    foundf = false;
    While (LoopBackKey("MainKey",CMSr,3,TrHs)) begin
      if (CMSr.ServerCode!=CNr.Code) then begin
        TrHs = false;
        if (!firstf) then begin
          firstf = true;
        end;
      end else begin
        foundf = true;
        if (CMSr.ReachableFlag==1) then begin
          aMem[aMem.length] = CMSr.MemTotal - CMSr.MemUsed;
          aSysCPU[aSysCPU.length] = CMSr.SystemCPUTime;
          aSwap[aSwap.length] = CMSr.SwapUsed;
          aTime[aTime.length] = Left(CMSr.Time,5);
          TrHs = false;
        end;
        cnt = cnt + 1;
      end;
    end;
    oldst = st;
    st = AddMinutes(st,-10);
    if (GetHour(st)>GetHour(oldst)) then begin //in case of midnight hours
      sd = AddDay(sd,-1);
    end;
    if (aTime.length>30 or foundf==false or cnt>50) then begin
      testf = false;
    end;
  end;

  sd = CurrentDate;
  st = CurrentTime;
  testf = true;
  foundf = true;
  firstf = false;
  cnt = 0;
  while (testf) begin
    ResetLoop(CMSr);
    CMSr.Date = sd;
    CMSr.Time = st;
    CMSr.ServerCode = CNr.Code;
    TrHs = true;
    foundf = false;
    While (LoopBackKey("MainKey",CMSr,3,TrHs)) begin
      if (CMSr.ServerCode!=CNr.Code) then begin
        TrHs = false;
        if (!firstf) then begin
          firstf = true;
        end;
      end else begin
        foundf = true;
        if (CMSr.ReachableFlag==1) then begin
          aDisk[aDisk.length] = CMSr.ServerDiskFree;
          aDate[aDate.length] = CMSr.Date;
          TrHs = false;
        end;
        cnt = cnt + 1;
      end;
    end;
    oldst = st;
    st = AddHours(st,-12);
    if (GetHour(st)>GetHour(oldst)) then begin //in case of midnight hours
      sd = AddDay(sd,-1);
    end;
    if (aDate.length>30 or foundf==false or cnt>50) then begin
      testf = false;
    end;
  end;

  return;
end;

global
procedure BIChart_remote_TopCustomersAsync(Integer wn)
begin
  array string 255 labels;
  array val val0;
  record IVVc IVr;
  row IVVc IVrw;
  record CSVc CSr;
  record CUVc CUr;
  val t;
  date sd,ed;
  LongInt rw,rwcnt;
  Boolean testf;
  vector Boolean vcustf;

  if (ThisIsMainThread) then begin
    LogText(0,"Warning: Processing BI on main thread (check Parallel Reports setting)");
  end;

  ClearArray(labels);
  ClearArray(val0);
  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);
  while (LoopMain(CSr,1,true)) begin
    testf = true;
    if (vcustf[CSr.CustCode]) then begin testf = false; end;
    if (testf) then begin
      CUr.Code = CSr.CustCode;
      ReadFirstMain(CUr,1,true);
      t = GetCUTurnover(CUr,"","","salesexclvat",sd,ed,"","","","");
      IVrw.Sum = t;
      if (IVrw.Sum!=0) then begin
        IVrw.Spec = CUr.SearchKey;
        if (blank(IVrw.Spec)) then begin
          IVrw.Spec = Left(CUr.Name,10);
        end;
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
      end;
      vcustf[CSr.CustCode] = true;
    end;
  end;
  
  SortRows(IVr,"Sum",false);

  rwcnt = MatRowCnt(IVr);
  if (rwcnt>5) then begin rwcnt = 5; end;
  
  for (rw = 0; rw<rwcnt; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[rwcnt-1-rw] = IVrw.Sum;
    labels[rwcnt-1-rw] = IVrw.Spec;
  end;
  clientremoteasync.BIChart_remote_TopCustomersAsyncCallback(wn,labels,val0);
  return;
end;

global
procedure BIChart_remote_ItemGroupsAsync(Integer wn)
begin
  array string 255 labels;
  array val val0;
  record ITVc ITr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw;

  if (ThisIsMainThread) then begin
    LogText(0,"Warning: Processing BI on main thread (check Parallel Reports setting)");
  end;

  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);
  
  while (LoopMain(ITr,1,true)) begin
    IVrw.Sum = GetITTurnover(ITr,sd,ed);
    IVrw.Spec = ITr.Code;
    if (IVrw.Sum!=0) then begin
      MatRowPut(IVr,MatRowCnt(IVr),IVrw);
    end;
  end;
  
  SortRows(IVr,"Sum",false);
  
  for (rw = 0; rw<5; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[4-rw] = IVrw.Sum;
    labels[4-rw] = IVrw.Spec;
    //StopAlert(rw & "-" & IVrw.Spec & "-" & IVrw.Sum);
  end;
  clientremoteasync.BIChart_remote_ItemGroupsAsyncCallback(wn,labels,val0);
  return;
end;

global
procedure BIChart_remote_TopSalesmenAsync(Integer wn)
begin
  array string 255 labels;
  array val val0;
  record UserVc USr;
  record IVVc IVr;
  row IVVc IVrw;
  date sd,ed;
  LongInt rw;

  if (ThisIsMainThread) then begin
    LogText(0,"Warning: Processing BI on main thread (check Parallel Reports setting)");
  end;

  sd = CurrentDate;
  sd.day = 1;
  ed = sd;
  ed.day = DaysInMonth(ed.year,ed.month);

  while (LoopMain(USr,1,true)) begin
    IVrw.Sum = SalesmanTurnover(USr.Code,sd,ed);
    IVrw.Spec = USr.Code;
    if (IVrw.Sum!=0) then begin
      MatRowPut(IVr,MatRowCnt(IVr),IVrw);
    end;
  end;

  SortRows(IVr,"Sum",false);

  for (rw = 0; rw<5; rw = rw + 1) begin
    MatRowGet(IVr,rw,IVrw);
    val0[4-rw] = IVrw.Sum;
    labels[4-rw] = IVrw.Spec;
    //StopAlert(rw & "-" & IVrw.Spec & "-" & IVrw.Sum);
  end;
  clientremoteasync.BIChart_remote_TopSalesmenAsyncCallback(wn,labels,val0);
  return;
end;

global
procedure BIChart_remote_PnLAsync(Integer wn)
begin
  array string 255 labels;
  array val val0;
  Date sd,ed,ld;
  Integer i;
  record ObjBalVc ObjBalr;
  record AccVc Accr;
  Boolean found,testf;
  
  ld = AddMonth(CurrentDate,-1);
  sd = AddMonth(ld,-5);
  sd.day = 1;
  ld.day = DaysInMonth(ld.year,ld.month);
  while (sd<ld) begin  
    i = labels.length;
    labels[i] = USetStr(2870+sd.month);
    found = true;
    ResetLoop(Accr);
    RecordClear(Accr);
//    Accr.AccNumber = "41900";
    while (LoopMain(Accr,1,found)) begin
//      if (Accr.AccNumber!="41900") then begin found = false; end;
      if (found) then begin
        testf = false;
        if (Accr.AccType==kAccTypeIncome or Accr.AccType==kAccTypeExpense) then begin
          testf = true;
        end;
        if (testf) then begin
          ObjBalr.AccNumber = Accr.AccNumber;
          ObjBalr.Object = "";
          ed = sd;
          ed.day = DaysInMonth(ed.year,ed.month);
          val0[i] = val0[i] - GetTurnover(ObjBalr,"transdebit",sd,ed) + GetTurnover(ObjBalr,"transcredit",sd,ed);
        end;
      end;
    end;
    sd = AddMonth(sd,1);
  end;
  clientremoteasync.BIChart_remote_PnLAsyncCallback(wn,labels,val0);
  return;
end;

global
procedure BIChart_remote_PipelineAsync(Integer wn)
begin
  array string 255 labels;
  array val val0;

  if (ThisIsMainThread) then begin
    LogText(0,"Warning: Processing BI on main thread (check Parallel Reports setting)");
  end;

  labels[0] = USetStr(38150);
  val0[0] = OutstandingQuotations;
  
  labels[1] = USetStr(38151);
  val0[1] = OutstandingOrders;
  
  labels[2] = USetStr(38152);
  val0[2] = OpenInvoices;  

  clientremoteasync.BIChart_remote_PipelineAsyncCallback(wn,labels,val0);
  return;
end;

function val FindRoomOccupation(record ResVc Resr,Date sd,Date ed)
begin
  val res;
  record JobVc Jobr;
  Boolean TrHs;
  string 255 ckey;
  Boolean testf;
  LongInt daycnt;
  LongInt startpos;
  LongInt endpos;
  LongInt ddif;
  record ReservationStatusVc RSr;
  Integer lenclass;
  LongInt i,maxdays;
  Date blankd,td;
  record HotelBlock Hotelb;
  
  BlockLoad(Hotelb);
  maxdays = DateDiff(ed,sd) + 1;
  td = sd;
  while (td<=ed) begin
    daycnt = 0;
    ckey = "CalResStartTime";
    lenclass = 4;
    while (lenclass>0) begin
      ResetLoop(Jobr);
      Jobr.ResCode = Resr.Code;
      Jobr.LengthClass = lenclass;
      Jobr.TransDate = td;
      switch (lenclass) begin
        case 4: Jobr.TransDate = blankd;
        case 3: Jobr.TransDate = AddDay(Jobr.TransDate,-366);
        case 2: Jobr.TransDate = AddDay(Jobr.TransDate,-31);
        case 1: Jobr.TransDate = AddDay(Jobr.TransDate,-7);
        case 0: ;
      end;
      TrHs = true;
      while (LoopKey(ckey,Jobr,3,TrHs)) begin
        ddif = DateDiff(Jobr.TransDate,td);
        if (ddif>=maxdays) then begin TrHs = false; end;
        if (Jobr.LengthClass!=lenclass) then begin TrHs = false; end;
        if (Jobr.ResCode!=Resr.Code) then begin TrHs = false; end;
        if (TrHs) then begin
          testf = true;
          if (DateTimeInsideDateTime(Jobr.TransDate,Jobr.StartTime,Jobr.EndDate,Jobr.EndTime,
                             td,Hotelb.CheckIn,td,Hotelb.CheckOut)==false) then begin
            testf = false;
          end;

//          if (DateInRange(td,Jobr.TransDate,Jobr.EndDate)==false) then begin testf = false; end;
          if (testf) then begin
            RSr.Code = Jobr.ResStatus;
            if (ReadFirstMain(RSr,1,true)) then begin
              if (SkipResTest(RSr,true)) then begin
                testf = false;
              end;
            end;
          end;
          if (testf) then begin
            res = res + NumberOfStayDays(Jobr.TransDate,Jobr.EndDate,Jobr.StartTime,Jobr.EndTime,1);
          end;
        end;
      end;
      lenclass = lenclass - 1;
    end;
    td = AddDay(td,1);
  end;
  FindRoomOccupation = res;
  return;  
end;

global
procedure ResDCLass_BIChart_remote_Async(Integer wn,record ResVc Resr)
begin
  Date sd,ed;
  Integer i;
  LongInt maxdays;
  val maxv;
  Array val voccup;
  Array Integer vmonth;


  sd = CurrentDate;
  sd = AddMonth(sd,-11);
  
  for (i=1;i<=12;i=i+1) begin
    sd.day = 1;
    ed = sd;
    ed.day = DaysInMonth(ed.year,ed.month);
    voccup[i] = FindRoomOccupation(Resr,sd,ed);
    maxdays = DateDiff(ed,sd) + 1;
    voccup[i] = voccup[i] / maxdays;
    voccup[i] = voccup[i] * 100;
    voccup[i] = Round(voccup[i],SetRoundModeD(0));
    vmonth[i] = ed.month;
    sd = AddMonth(sd,1);
    if (maxv<voccup[i]) then begin maxv = voccup[i]; end;
  end;

  clientremoteasync.ResDCLass_BIChart_remote_AsyncCallback(wn,maxv,voccup,vmonth);
  return;
end;

function val FindRoomTypeOccupation(record ResTypeVc RTr,Date sd,Date ed,var vector val vrooms)
begin
  val res,rcnt,t;
  record ResVc Resr;
  Boolean found;
  
  found = true;
  Resr.Type = RTr.Code;
  while (LoopKey("Type",Resr,1,found)) begin
    if (Resr.Type!=RTr.Code) then begin found = false; end;
    if (found) then begin
      t = FindRoomOccupation(Resr,sd,ed);
      if (t!=0) then begin
        vrooms[Resr.Code] = vrooms[Resr.Code] + t;
        res = res + t;
      end;
      rcnt = rcnt + 1;
    end;
  end;
  res = res / rcnt;
  FindRoomTypeOccupation = res;
  return;
end;

global
procedure ResTypeDClass_BICharts_remote_Async(Integer wn,record ResTypeVc RTr)
begin
  Date sd,ed;
  Integer i;
  LongInt maxdays;
  val maxoccupv;
  Array val aoccup;
  Array Integer amonth;
  vector val vrooms;

  sd = CurrentDate;
  sd = AddMonth(sd,-11);
  
  vrooms[""] = 0.3;
  for (i=1;i<=12;i=i+1) begin
    sd.day = 1;
    ed = sd;
    ed.day = DaysInMonth(ed.year,ed.month);
    aoccup[i] = FindRoomTypeOccupation(RTr,sd,ed,vrooms);
    maxdays = DateDiff(ed,sd) + 1;
    aoccup[i] = aoccup[i] / maxdays;
    aoccup[i] = aoccup[i] * 100;
    aoccup[i] = Round(aoccup[i],SetRoundModeD(1));
    amonth[i] = ed.month;
    sd = AddMonth(sd,1);
    if (maxoccupv<aoccup[i]) then begin maxoccupv = aoccup[i]; end;
  end;

  clientremoteasync.ResTypeDClass_BICharts_remote_AsyncCallback(wn,maxoccupv,aoccup,amonth,vrooms);
  return;
end;