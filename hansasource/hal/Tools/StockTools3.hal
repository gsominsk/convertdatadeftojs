external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function roundmode GetCostRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external updating procedure UpdatePosition(string,string,string,val,val,val);
external function Boolean ShouldInvoiceRowUpdateStock(record IVVc,row IVVc);
external function val GetStockQty(string,string,Date,Boolean);
external procedure GetStockValue(string,string,var record ItemStatusVc);
external function val CreditedInvoiceRowFIFORowVal(record INVc,string,Integer,LongInt,string,LongInt,string,val,Integer,val);
external function Boolean TestArtCode(string,string,record INVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external procedure Base1ToBase2(var val,Date,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external updating procedure UpdateLocationWeightedAv(string,string,val,val,val,val,Boolean);
external updating procedure UpdateBatchBestBefore(string,string,string,Date,Date,val,val,val,Integer,Integer,Boolean,
                                                  string,string,string,string,string,string,string,string,
                                                  string,string,string,string,string,string,string,string, string,string);
external updating procedure UpdateSerStock(string,string,string,val,val);
external updating procedure LockRecipe(string);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external function Boolean ShouldItemUpdateStock(string);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external updating procedure UpdateInShipment(string,string,Date,val);

/* INRS

updating function Boolean XSUpdateINrs(record IVVc IVp)
begin
  Boolean res;
  record MainStockBlock MainStockRec;
  record INrsVc INrsr;
  record INVc INr;
  record XSVc XSr;
  row XSVc XSrw;
  Integer rwcnt,i,j;
  Boolean save;
  string 10 location;
  
  BlockLoad(MainStockRec);
  XSr.FileName = "IVVc";
  XSr.SerNr = IVp.SerNr;
  if (ReadFirstMain(XSr,2,true)) then begin
    res = true;
    rwcnt = MatRowCnt(XSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(XSr,i,XSrw);
      location = IVrw.Location;
      if (blank(location)) then begin
        location = IVp.Location;
      end;
      if (blank(location)) then begin
        location = MainStockRec.MainStock;
      end;
      INrsr.ItemCode = XSrw.Item;
      INrsr.TheItemCode = XSrw.Item;
      if (ReadFirstItem(XSrw.Item,INr,false,false)) then begin
        INrsr.TheItemCode = INr.Code;
      end;
      INrsr.Location = location;
      INrsr.FileName = "IVVc";
      INrsr.TransNr = IVp.SerNr;
      INrsr.TransDate = IVp.TransDate;
      INrsr.FIFO = 0;
      INrsr.Row = XSrw.Row;
      INrsr.LocOKNr = IVp.LocOKNr;
      INrsr.Qty = blankval;
      INrsr.Quant2 = blankval;
      INrsr.StockAffectf = 0;
      if ((IVp.OrderNr==-1) and (IVp.UpdStockFlag!=0)) then begin INrsr.StockAffectf = 1; end;
      save = true;
      for (j=0;j<i;j=j+1) begin
        MatRowGet(XSr,j,XSrw);
        if (INrsr.ItemCode==XSrw.Item) then begin save = false; end;
      end;
      if (save) then begin
        for (j=i;j<rwcnt;j=j+1) begin
          MatRowGet(XSr,j,XSrw);
          if (INrsr.ItemCode==XSrw.Item) then begin 
            INrsr.Qty = INrsr.Qty - XSrw.Qty;
            INrsr.Quant2 = INrsr.Qty;
          end;
        end;
      end;
      if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
        INrsr.Qty = -INrsr.Qty;
        INrsr.Quant2 = -INrsr.Quant2;
      end;
      if (save) then begin
        if (RecordStore(INrsr,false)) then begin end;
      end;
    end;
  end;
  return;
end;
*/

global
procedure CombineStructure(var record SHVc recSHp)
begin
  record SHVc SHr;
  row SHVc SHrw;
  row SHVc SH2rw;
  Integer rwcnt,i,j,cnt;
  Boolean foundf;
  
  cnt = 0;
  rwcnt = MatRowCnt(recSHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(recSHp,i,SHrw);
    foundf = false;
    for (j=0;j<cnt;j=j+1) begin
      MatRowGet(SHr,j,SH2rw);
      if (SHrw.ArtCode==SH2rw.ArtCode) then begin
        SH2rw.Ship = SH2rw.Ship + SHrw.Ship;
        SH2rw.Ordered = SH2rw.Ordered + SHrw.Ordered;
        MatRowPut(SHr,j,SH2rw);
        foundf = true;
      end;
    end;
    if (foundf==false) then begin
      MatRowPut(SHr,cnt,SHrw);
      cnt = cnt + 1;
    end;
  end;
  RecordCopy(recSHp,SHr);
  return;
end;

global
updating procedure IVUpdateStock2(record IVVc IVp,Boolean negf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record INVc INr;
  record SHVc recSHp;
  row IVVc IVrw;
  row SHVc SHrw2;
  val t,t2,q2;
  Integer i,rwcnt;
  Boolean isstruct,testf;
  Integer j,shrwcnt;
  string 255 location;
  row TempStockVc TSrw;
  
  if (IVp.InvType==kInvoiceTypeDebit) then begin
    goto LIVUpdateStock;
  end;
/*  
  if ((IVp.SVONr != -1) and (IVp.UpdStockFlag!=0))  then begin
    goto LIVUpdateStock;
  end;
add items to invoice created from service order  
*/  
  BlockLoad(MSb);
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeCorrection) then begin
    if (IVrw.NotUpdStockFlag==0) and (IVrw.ovst==0) then begin
      testf = true;
      if (blank(IVrw.ArtCode)) then begin testf = false; end;
      if (testf) then begin
        if (usetmpstkf) then begin
          FindTempStockRow(i,IVrw.ArtCode,blank(IVrw.Recepy),TSr,TSrw);
          if (TSrw.StockAffectf==0) then begin testf = false; end;
          if (TSrw.ItemType!=kItemTypeStocked) then begin testf = false; end;
        end;
      end;
      if (testf) then begin
        location = IVrw.Location;
        if (blank(location)) then begin
          location = IVp.Location;
        end;
        if (blank(location)) then begin
          location = MSb.MainStock;
        end;
        if (ShouldInvoiceRowUpdateStock(IVp,IVrw)) then begin
          isstruct = false;
          if (IVrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
            isstruct = ExpandStructItem(IVrw.ArtCode,IVrw.Recepy,IVrw.Quant,recSHp);
          end;
          if (isstruct==false) then begin
            if (ShouldItemUpdateStock(IVrw.ArtCode)) then begin
              if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
                t2 = -IVrw.Quant;
              end else begin
                switch (IVrw.stp) begin
                  case 11: t2 = -IVrw.Quant;
                  otherwise t2 = IVrw.Quant;
                end;
              end;
              if (MSb.UnitConvCalc==0) then begin
                q2 = t2*IVrw.Coefficient;
              end else begin
                q2 = t2/IVrw.Coefficient;
              end;
              if (IVp.Invalid!=0) or (negf) then begin
                t2 = -t2;
                q2 = -q2;
              end;            
              UpdateInstock("IVVc",IVp.SerNr,IVrw.ArtCode,location,IVp.TransDate,t2,t,t,t,t,q2,t,t,t);
            end;
          end else begin
            if (nonblank(IVrw.Recepy)) then begin
              LockRecipe(IVrw.Recepy);
            end;
            shrwcnt = MatRowCnt(recSHp);
            for (j=0;j<shrwcnt;j=j+1) begin
              MatRowGet(recSHp,j,SHrw2);
              if (ShouldItemUpdateStock(SHrw2.ArtCode)) then begin
                SHrw2.Ship = Round(SHrw2.Ship,SetRoundModeD(3));
                if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin            
                  t2 = -SHrw2.Ship;
                end else begin
                  switch (IVrw.stp) begin
                    case 11: t2 = -SHrw2.Ship;
                    otherwise t2 = SHrw2.Ship;
                  end;            
                end;  
                if (MSb.UnitConvCalc==0) then begin
                  q2 = t2*SHrw2.Coefficient;
                end else begin
                  q2 = t2/SHrw2.Coefficient;
                end;
                if (IVp.Invalid!=0) or (negf) then begin
                  t2 = -t2;
                  q2 = -q2;
                end;            
                UpdateInstock("IVVc",IVp.SerNr,SHrw2.ArtCode,location,IVp.TransDate,t2,t,t,t,t,q2,t,t,t);
              end;
            end;
          end;
        end;
      end;
    end;
    end;
  end;
LIVUpdateStock:;
  return;
end;

global
updating procedure IVUpdateStock(record IVVc IVp,Boolean negf)
begin
  record TempStockVc TSr;
  
  IVUpdateStock2(IVp,negf,TSr,false)
  return;
end;

global
updating procedure StockMovUpdateStockFrom(record StockMovVc SMp,string frlocation,row StockMovVc StockMovrw,record MainStockBlock MainStockRec,record LocationVc toLocr,Boolean sentquantf,Boolean trflag,Boolean maintf,Boolean negf)
begin
  Date blankd;
  val t2,q2,blankv,pins;
  string 20 frpos,topos;
  Boolean testf;

  if (maintf==false) then begin
    if (nonblank(StockMovrw.SerialNr)) then begin
      if (StockMovrw.UnitXval!=0) then begin
        UpdateBatchBestBefore(StockMovrw.ArtCode,StockMovrw.Spec,StockMovrw.SerialNr,blankd,blankd,StockMovrw.UnitXval,StockMovrw.UnitYval,StockMovrw.UnitZval,0,0,negf,"","","","","","","","","","","","","","","","","","");
      end;
    end;
  end;
  if (sentquantf) then begin
    t2 = -StockMovrw.SentQuant;
  end else begin
    t2 = -StockMovrw.Quant;
  end;
  if (MainStockRec.UnitConvCalc==0) then begin
    q2 = t2*StockMovrw.Coefficient;
  end else begin
    q2 = t2/StockMovrw.Coefficient;
  end;
  if (negf) then begin
    t2 = -t2;
    q2 = -q2;
  end;
  if (trflag) then begin
    UpdateInstock("StockMovVc",SMp.SerNr,StockMovrw.ArtCode,frlocation,SMp.TransDate,t2,blankv,blankv,blankv,blankv,q2,blankv,blankv,blankv);
  end;
  if (maintf==false) then begin
    frpos = StockMovrw.FrPosCode;
    if (blank(frpos)) then begin
      frpos = SMp.FrPos;
    end;
    topos = StockMovrw.ToPosCode;
    if (blank(topos)) then begin
      topos = SMp.ToPos;
    end;
    pins = blankval;
    testf = true;
    if (frpos==toLocr.WHMDefPUPosCode) then begin testf = false; end;
    if (frpos==toLocr.WHMDefProdPosCode) then begin testf = false; end;
    if (frpos==toLocr.WHMWraperPosCode) then begin testf = false; end;
    if (frpos==toLocr.WHMDeliveryPosCode) then begin testf = false; end;
    if (frpos==topos) then begin testf = false; end;
    if (testf) then begin
      pins = t2;
    end;
    UpdatePosition(StockMovrw.ArtCode,frlocation,frpos,t2,q2,pins);
  end;
  return;
end;

global
updating procedure StockMovUpdateStockTo(record StockMovVc SMp,string tolocation,row StockMovVc StockMovrw,record MainStockBlock MainStockRec,record LocationVc toLocr,Boolean sentquantf,Boolean trflag,Boolean maintf,Boolean negf)
begin
  val t4,q2,blankv;
  string 20 topos;

  if (sentquantf) then begin
    t4 = StockMovrw.SentQuant;
  end else begin
    t4 = StockMovrw.Quant;
  end;
  if (MainStockRec.UnitConvCalc==0) then begin
    q2 = t4*StockMovrw.Coefficient;
  end else begin
    q2 = t4/StockMovrw.Coefficient;
  end;
  if (negf) then begin
    t4 = -t4;
    q2 = -q2;
  end;
  if (trflag) then begin
    UpdateInstock("StockMovVc",SMp.SerNr,StockMovrw.ArtCode,tolocation,SMp.TransDate,t4,blankv,blankv,blankv,blankv,q2,blankv,blankv,blankv);
  end;
  if (maintf==false) then begin
    topos = StockMovrw.ToPosCode;
    if (blank(topos)) then begin
      topos = SMp.ToPos;
    end;
    UpdatePosition(StockMovrw.ArtCode,tolocation,topos,t4,q2,blankv);
  end;
  return;
end;

global
updating procedure StockMovUpdateReserved(record StockMovVc SMp,Boolean negf,Boolean trflag)
begin
  Date td;
  val t,rsrv;
  row StockMovVc StockMovrw;
  Integer i,rwcnt;

  if (trflag) then begin
    rwcnt = MatRowCnt(SMp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SMp,i,StockMovrw);
      td = SMp.TransDate;
      if (blankdate(td)) then begin
        td = SMp.SentTransDate;
      end;
      if (negf) then begin
        rsrv = -StockMovrw.OrdQuant;
      end else begin
        rsrv = StockMovrw.OrdQuant;
      end;
      UpdateInstock("StockMovVc",SMp.SerNr,StockMovrw.ArtCode,SMp.FrLocation,td,t,t,rsrv,t,t,t,t,t,t);
    end;
  end;
  return;
end;

// maintf is not the best, but it was difficult to fix it fast
global
updating procedure StockMovUpdateStock(record StockMovVc SMp,record StockMovVc prevSMp,Boolean trflag,Boolean maintf,Boolean negf)
begin
  Integer i,rwcnt;
  record MainStockBlock MainStockRec;
  row StockMovVc StockMovrw;
  Boolean fromf,fromthrouf,fromsendf,tof,tothrouf,reservedf;
  record LocationVc toLocr;
    
  BlockLoad(MainStockRec);
  if (SMp.Reserved!=0) then begin
    reservedf = true;
  end else begin
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.Reserved!=0) then begin
        reservedf = true;
      end;
    end;
  end;
  if (SMp.SentOKFlag!=0) then begin
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.SentOKFlag!=0) then begin
        reservedf = false;
      end;
    end;
  end;
  if (SMp.OKFlag!=0) then begin
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.OKFlag!=0) then begin
        reservedf = false;
      end;
    end;
  end;
  if (reservedf) then begin
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.Reserved!=0) then begin
        StockMovUpdateReserved(prevSMp,true,trflag);
      end;
    end;
    if (SMp.Reserved!=0) then begin
      StockMovUpdateReserved(SMp,false,trflag);
    end;
    if ((SMp.SentOKFlag!=0) or ((SMp.SentOKFlag==0) and (SMp.OKFlag!=0))) then begin
      StockMovUpdateReserved(SMp,true,trflag);
    end;
  end;
  
  if (SMp.SentOKFlag==0) then begin
    if (SMp.OKFlag!=0) then begin
      fromf = true;
      tof = true;
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.OKFlag!=0) then begin
          fromf = false;
          tof = false;
        end;
      end;
    end;
  end else begin
    fromsendf = true;
    tothrouf = true;
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.SentOKFlag!=0) then begin
        fromsendf = false;
        tothrouf = false;
      end;
    end;
    if (SMp.OKFlag!=0) then begin
      fromthrouf = true;
      tof = true;
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.OKFlag!=0) then begin
          fromthrouf = false;
          tof = false;
        end;
      end;
    end;
  end;
  
  if (fromf==false) and (fromsendf==false) and (tof==false) and (tothrouf==false) and (fromthrouf==false) then begin
    goto LStockMovUpdateStock;
  end;
    
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
      if (fromsendf) then begin
        if (StockMovrw.SentQuant!=0) then begin
          toLocr.Code = SMp.ThrouLocation;
          ReadFirstMain(toLocr,1,true);
          StockMovUpdateStockFrom(SMp,SMp.FrLocation,StockMovrw,MainStockRec,toLocr,true,trflag,maintf,negf);
        end;
      end else begin
        if (fromf) then begin
          if (StockMovrw.Quant!=0) then begin
            toLocr.Code = SMp.ToLocation;
            ReadFirstMain(toLocr,1,true);
            StockMovUpdateStockFrom(SMp,SMp.FrLocation,StockMovrw,MainStockRec,toLocr,false,trflag,maintf,negf);
          end;
        end;
      end;
      if (tothrouf) then begin
        if (StockMovrw.SentQuant!=0) then begin
          toLocr.Code = SMp.ThrouLocation;
          ReadFirstMain(toLocr,1,true);
          StockMovUpdateStockTo(SMp,SMp.ThrouLocation,StockMovrw,MainStockRec,toLocr,true,trflag,maintf,negf);
        end;
      end;
      if (fromthrouf) then begin
        if (StockMovrw.Quant!=0) then begin
          toLocr.Code = SMp.ToLocation;
          ReadFirstMain(toLocr,1,true);
          StockMovUpdateStockFrom(SMp,SMp.ThrouLocation,StockMovrw,MainStockRec,toLocr,false,trflag,maintf,negf);
        end;
      end;
      if (tof) then begin
        if (StockMovrw.Quant!=0) then begin
          toLocr.Code = SMp.ToLocation;
          ReadFirstMain(toLocr,1,true);
          StockMovUpdateStockTo(SMp,SMp.ToLocation,StockMovrw,MainStockRec,toLocr,false,trflag,maintf,negf);
        end;
      end;
    end;
  end;
LStockMovUpdateStock:;  
  return;
end;

global
updating procedure StockMovUpdateStock_UnOK_FromFrLocation_Quant(record StockMovVc SMp,Boolean negf)
begin
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record MainStockBlock MSb;
  record LocationVc toLocr;

  BlockLoad(MSb);  

  toLocr.Code = SMp.ToLocation;
  ReadFirstMain(toLocr,1,true);
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
      StockMovUpdateStockFrom(SMp,SMp.FrLocation,StockMovrw,MSb,toLocr,false,true,false,negf);
    end;
  end;
  return;
end;

global
updating procedure StockMovUpdateStock_UnOK_ToThrouLocation(record StockMovVc SMp,Boolean negf)
begin
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record MainStockBlock MSb;
  record LocationVc toLocr;

  BlockLoad(MSb);  
  toLocr.Code = SMp.ToLocation;
  ReadFirstMain(toLocr,1,true);
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
      StockMovUpdateStockTo(SMp,SMp.ThrouLocation,StockMovrw,MSb,toLocr,true,true,false,negf);
    end;
  end;
  return;
end;

global
updating procedure StockMovUpdateStock_UnOK_FromFrLocation_SentQuant(record StockMovVc SMp,Boolean negf)
begin
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record MainStockBlock MSb;
  record LocationVc toLocr;

  BlockLoad(MSb);  
  toLocr.Code = SMp.ToLocation;
  ReadFirstMain(toLocr,1,true);
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
      StockMovUpdateStockFrom(SMp,SMp.FrLocation,StockMovrw,MSb,toLocr,true,true,false,negf);
    end;
  end;
  return;
end;

global
updating procedure StockMovUpdateStock_UnOK_FromThrouLocation(record StockMovVc SMp,Boolean negf)
begin
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record MainStockBlock MSb;
  record LocationVc toLocr;

  BlockLoad(MSb);  
  toLocr.Code = SMp.ToLocation;
  ReadFirstMain(toLocr,1,true);
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
      StockMovUpdateStockFrom(SMp,SMp.ThrouLocation,StockMovrw,MSb,toLocr,true,true,false,negf);
    end;
  end;
  return;
end;

global
updating procedure StockMovUpdateStock_UnOK_ToLocation(record StockMovVc SMp,Boolean negf)
begin
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record MainStockBlock MSb;
  record LocationVc toLocr;

  BlockLoad(MSb);  
  toLocr.Code = SMp.ToLocation;
  ReadFirstMain(toLocr,1,true);
  if (toLocr.RequirePos!=0) then begin
    rwcnt = MatRowCnt(SMp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SMp,i,StockMovrw);
      if (ShouldItemUpdateStock(StockMovrw.ArtCode)) then begin
        if (StockMovrw.Quant!=0) then begin
          StockMovUpdateStockTo(SMp,SMp.ToLocation,StockMovrw,MSb,toLocr,false,true,false,negf);
        end;
      end;
    end;
  end;
  return;
end;

procedure ArtCodeOnThisProd(Integer cnt,record ProdVc Prodp,string artcode,record INVc INr,var val resp)
begin
  row ProdVc Prodrw;
  Integer rwcnt,i;

  resp = blankval;
  rwcnt = MatRowCnt(Prodp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    if (TestArtCode(Prodrw.Item,artcode,INr)) then begin
      switch (Prodp.RowsHoldActualQty) begin
        case 1: resp = resp + Prodrw.OutQty;
        otherwise resp = resp + Prodrw.OutQty*Prodp.Qty;//, shouldnt it be OutQty? 
      end;            
//      resp = resp + Prodrw.InQty;
    end;
  end;
  return;
end;

global
updating procedure ProdUpdateCostPrice(record ProdVc Prodp,Boolean negf)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row ProdVc ProdRowr;
  row ProdVc ProdRow2r;
  Boolean found,testf;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,realq,trs,trsb2,qonrec,theq;
  record RoundBlock RoundRec;
  record WeigAvVc war;

  if (nonblank(Prodp.Routing)) then begin
    goto LProdUpdateCostPrice;
  end;
  BlockLoad(RoundRec);  
  outrows = 0;
  rwcnt = MatRowCnt(Prodp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,ProdRowr);
    testf = false;
    if (Prodp.Disassemble!=0) then begin
      if (ProdRowr.InQty!=0) then begin
//        testf = true;
//        theq = ProdRowr.InQty;
      end;
    end else begin
      if (ProdRowr.OutQty!=0) then begin
        testf = true;
        theq = ProdRowr.OutQty;
      end;
    end;

    if (testf) then begin
      found = ReadFirstItemInclClosed(ProdRowr.Item,INr,false,false);
      RecordCopy(oldINr,INr);
      if ((found) and (ProdRowr.ItemCost>=0)) then begin
        qonrec = blankval;
        rs = ProdRowr.ItemCost;
        Base1ToBase2(rs,Prodp.ProdDate,rsb2);
        FindStockValue(INr.Code,"",ISr); 
        switch (Prodp.RowsHoldActualQty) begin
          case 1: realq = theq;
          otherwise realq = theq*Prodp.Qty;
        end;            
        if (negf) then begin
/*        
          if (INr.PriceFactor!=0) then begin
            rs = rs*INr.PriceFactor;
            rsb2 = rsb2*INr.PriceFactor;
          end;
*/          
          q = ISr.Instock + realq;
          trs = q*INr.WeighedAvPrice - realq*rs;
          trsb2 = q*INr.WeighedAvPriceB2 - realq*rsb2;
          if (q==0) then begin
            INr.WeighedAvPrice = blankval;
            INr.WeighedAvPriceB2 = blankval;
          end else begin
            INr.WeighedAvPrice = trs/q;
            INr.WeighedAvPriceB2 = trsb2/q;
          end;
          UpdateLocationWeightedAv(INr.Code,Prodp.Location,realq,rs,rsb2,qonrec,true);

        end else begin
/*        
          if (INr.PriceFactor!=0) then begin
            rs = rs*INr.PriceFactor;
            rsb2 = rsb2*INr.PriceFactor;
          end;
*/                       
          q = ISr.Instock - realq;          
          for (j=i+1;j<rwcnt;j=j+1) begin
            MatRowGet(Prodp,j,ProdRow2r);
            if (TestArtCode(ProdRow2r.Item,ProdRowr.Item,INr)) then begin
              switch (Prodp.RowsHoldActualQty) begin
                case 1: q = q - ProdRow2r.OutQty;
                otherwise q = q - ProdRow2r.OutQty*Prodp.Qty;
              end;            
            end;
          end;
          if (q<0) then begin q = 0; end;
          
          if (q!=0) then begin
            t = q*INr.WeighedAvPrice;
            t2 = realq*rs;
            t = t + t2;
            q = q + realq;
            trs = t/q;
            if (q>=0) then begin
              INr.WeighedAvPrice = trs;
            end;


            t = q*INr.WeighedAvPriceB2;
            t2 = realq*rsb2;
            t = t + t2;
            trsb2 = t/q;
            if (q>=0) then begin
              INr.WeighedAvPriceB2 = trsb2;
            end;
            ArtCodeOnThisProd(i+1,Prodp,ProdRowr.Item,INr,qonrec);                      
            UpdateLocationWeightedAv(INr.Code,Prodp.Location,realq,rs,rsb2,qonrec,false);
          end else begin
            INr.WeighedAvPrice = rs;
            Base1ToBase2(ProdRowr.ItemCost,Prodp.ProdDate,rsb2);
            INr.WeighedAvPriceB2 = rsb2;

            war.ArtCode = INr.Code;
            war.Location = Prodp.Location;
            if (ReadFirstMain(war,2,true)==false) then begin
              war.ArtCode = INr.Code;
              war.Location = Prodp.Location;
              war.WeighedAvPrice = ProdRowr.ItemCost;
              war.WeighedAvPriceB2 = rsb2;
              if (RecordStore(war,false)) then begin
              end;
            end else begin
              war.WeighedAvPrice = ProdRowr.ItemCost;
              war.WeighedAvPriceB2 = rsb2;
              if (RecordStore(war,true)) then begin
              end;
            end;
          end;
        end;
        INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
        INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));      
        switch (INr.UpdateCost) begin
          case 1:
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = CurrentDate;
            end else begin
              found = false;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
          case 3:
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = CurrentDate;
            end else begin
              found = false;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
          case 2:
/*
isnt it calulated above ?           
            rs = ProdRowr.ItemCost;
            Base1ToBase2(rs,Prodp.ProdDate,rsb2);
            FindStockValue(INr.Code,"",ISr);            
            switch (Prodp.RowsHoldActualQty) begin
              case 1: realq = theq;
              otherwise realq = theq*Prodp.Qty;
            end;            

            q = ISr.Instock - realq;
            t = q*INr.WeighedAvPrice;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
            end;
            t2 = realq*rs;
            t = t + t2;
            q = q + realq;
            trs = t/q;

            t = q*INr.InPriceB2;
            if (INr.PriceFactor!=0) then begin
              rsb2 = rsb2*INr.PriceFactor;
            end;
            t2 = realq*rsb2;
            t = t + t2;
            q = q + realq;
            trsb2 = t/q;

            ArtCodeOnThisProd(i+1,Prodp,ProdRowr.Item,INr,qonrec);                      
*/            
            rs = INr.WeighedAvPrice;
            rsb2 = INr.WeighedAvPriceB2;
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = CurrentDate;
            end else begin
              found = false;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
          otherwise 
            found = false;
         end;
         switch(INr.UpdateCost) begin
           case 0:;
           otherwise
             INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
             INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
             INr.LastPriceChange = CurrentDate;
         end;
         INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
         INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
         if (RecordUpdate(oldINr,INr,false)==0) then begin
         end;
      end;
    end;
  end;
LProdUpdateCostPrice:;
  return;
end;

global
updating procedure SHUpdateStock2(record SHVc SHp,Boolean rebuildstockf,Boolean negf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record MainStockBlock MSb;
  record INVc INr;
  record ORVc ORr;
  record SHVc RecSHr;
  row SHVc SHrw;
  row SHVc SH2rw;
  row ORVc ORrw;
  val t,t2,t3,t4,q2,costp;
  val t2noplan,temp;
  Integer i,rwcnt;
  Integer j,shrwcnt;
  Integer resf,orclosedf;
  Boolean planned,orfound;
  Boolean isstruct,testf;
  string 10 location,loc2,ordlocation,ordloc2;
  row TempStockVc TSrw;
  
  ORr.SerNr = SHp.OrderNr;
  orfound = ReadFirstMain(ORr,1,true);
  if (orfound) then begin
    resf = ORr.Reserved;
    orclosedf = ORr.Closed;
  end;
  BlockLoad(MSb);
  location = SHp.Location;
  ordlocation = "";
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  if (orfound) then begin
    ordlocation = ORr.Location;
  end;
  if (blank(ordlocation)) then begin  
    ordlocation = MSb.MainStock;
  end;  
  rwcnt = MatRowCnt(SHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHp,i,SHrw);    
    t2noplan = BlankVal;
    if (nonblank(SHrw.Location)) then begin    
      loc2 = SHrw.Location;
    end else begin
      loc2 = location;
    end;
    if (nonblank(SHrw.ArtCode)) then begin
      ordloc2 = ordlocation;
      if (orfound) then begin
        if ((SHrw.OrdRow<MatRowCnt(ORr)) and (SHrw.OrdRow>-1)) then begin
          MatRowGet(ORr,SHrw.OrdRow,ORrw);
          if (nonblank(ORrw.Location)) then begin
            ordloc2 = ORrw.Location;
          end;
        end;
      end;
      testf = true;
      if (usetmpstkf) then begin
        FindTempStockRow(i,SHrw.ArtCode,blank(SHrw.Recepy),TSr,TSrw);
        if (TSrw.StockAffectf==0) then begin testf = false; end;
        if (TSrw.ItemType!=kItemTypeStocked) then begin testf = false; end;
      end;
      if (testf) then begin
        RecordNew(RecSHr);
        isstruct = false;
        if (SHrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
          isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
        end;
  //      CombineStructure(RecSHr);
        if (isstruct==false) then begin
          t2 = -SHrw.Ship;
          if ((resf!=0) and (rebuildstockf==false)) then begin
            t3 = -SHrw.Ship;
          end else begin
            t3 = blankval;
          end;
        
        
  //        if (orclosedf==0) then begin//INRS since not hapenning on import, not needed
            t2noplan = t2;
  //        end;

          if (SHrw.Ship>SHrw.Ordered) then begin
  //hmm, only order should update on order, what if u have 1st delievry with qty < ordered and 2nd with qty > ordered        
            temp = SHrw.Ordered;
            if (orfound) then begin
              if (MSb.DelOrdQty==0) then begin
                temp = ORrw.Quant;
              end else begin
                if (rebuildstockf) then begin
                  temp = SHrw.Ship;
                end;
                if ((MSb.dontAllowOvership==0) or (MSb.dontAllowOvership==2)) then begin
                  if (SHrw.Ship<=ORrw.Quant) then begin
                    temp = SHrw.Ship;
                  end else begin
                    temp = SHrw.Ordered;
                  end;
                end else begin
                  temp = SHrw.Ordered;
                end;
              end;
            end;
  //          if (orclosedf==0) then begin//INRS since not hapenning on import, not needed
              if (SHrw.Ship>temp) then begin
                t2noplan = -temp;
              end;
  //          end;
          end;
          if (ShouldItemUpdateStock(SHrw.ArtCode)==false) then begin
            t2 = blankval;
          end;
          if (MSb.UnitConvCalc==0) then begin
            q2 = t2*SHrw.Coefficient;
          end else begin
            q2 = t2/SHrw.Coefficient;
          end;
          if (orfound==false) then begin
            t2noplan = 0;
          end;
          if (rebuildstockf==false) then begin
            if (orclosedf!=0) then begin
              if (MSb.UpdateAvailable!=1) then begin
              end else begin
                t2noplan = blankval;
              end;
            end;
          end else begin
  //          if (MSb.UpdateAvailable==1) then begin
  //            t2noplan = blankval;
  //          end;
  /*
            if (MSb.DelOrdQty!=0) then begin
              if (orclosedf!=0) then begin
                t2noplan = blankval;
              end;
            end;
  */
          end;
          if (negf) then begin
            t2 = -t2;
            t3 = -t3;
            t2noplan = -t2noplan;
            q2 = -q2;
          end;
          if (ordloc2==loc2) then begin
            UpdateInstock("SHVc",SHp.SerNr,SHrw.ArtCode,loc2,SHp.ShipDate,t2,t2noplan,t3,t,t,q2,t,t,t);
          end else begin
            UpdateInstock("SHVc",SHp.SerNr,SHrw.ArtCode,loc2,SHp.ShipDate,t2,t,t,t,t,q2,t,t,t);
            UpdateInstock("SHVc",SHp.SerNr,SHrw.ArtCode,ordloc2,SHp.ShipDate,t,t2noplan,t3,t,t,t,t,t,t);
          end;
        end else begin
          if (nonblank(SHrw.Recepy)) then begin
            LockRecipe(SHrw.Recepy);
          end;    
          //? We save the original item as well as the components! 
          t2 = -SHrw.Ship;
          if (negf) then begin
            t2 = -t2;
          end;
          if (ordloc2==loc2) then begin
            UpdateInstock("SHVc",SHp.SerNr,SHrw.ArtCode,loc2,SHp.ShipDate,t,t2,t,t,t,t,t,t,t);
          end else begin
            UpdateInstock("SHVc",SHp.SerNr,SHrw.ArtCode,ordloc2,SHp.ShipDate,t,t2,t,t,t,t,t,t,t);
          end;
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,SH2rw);
            t2 = -SH2rw.Ship;
            if (ShouldItemUpdateStock(SH2rw.ArtCode)==false) then begin t2 = blankval; end;
            if (MSb.UnitConvCalc==0) then begin
              q2 = t2*SH2rw.Coefficient;
            end else begin
              q2 = t2/SH2rw.Coefficient;
            end;
            if (resf!=0) then begin
              t3 = -SH2rw.Ship;
            end else begin
              t3 = blankval;
            end;
  //          if (orclosedf==0) then begin//INRS since not hapenning on import, not needed
              t2noplan = t2;
  //          end;
            if (orfound==false) then begin
              t2noplan = 0;
            end;
            if (negf) then begin
              t2 = -t2;
              t3 = -t3;
              t2noplan = -t2noplan;
              q2 = -q2;
            end;
            if (ordloc2==loc2) then begin
              UpdateInstock("SHVc",SHp.SerNr,SH2rw.ArtCode,loc2,SHp.ShipDate,t2,t2noplan,t3,t,t,q2,t,t,t);
            end else begin
              UpdateInstock("SHVc",SHp.SerNr,SH2rw.ArtCode,loc2,SHp.ShipDate,t2,t,t,t,t,q2,t,t,t);
              UpdateInstock("SHVc",SHp.SerNr,SH2rw.ArtCode,ordloc2,SHp.ShipDate,t,t2noplan,t3,t,t,t,t,t,t);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure SHUpdateStock(record SHVc SHp,Boolean rebuildstockf,Boolean negf)
begin
  record TempStockVc TSr;
  
  SHUpdateStock2(SHp,rebuildstockf,negf,TSr,false);
  return;
end;

global
updating procedure SHUpdateInShipment(record SHVc SHp,Boolean shf,record SHVc SH2p,Boolean sh2f,Boolean remove)
begin
  record MainStockBlock MainStockRec;
  record SHVc RecSHr;
//  record ORVc ORr;
  record INVc INr;
  row SHVc SHrw,SH2rw;
  Integer i,rwcnt;
  Integer j,shrwcnt;
//  Integer resf;
  val t;
  Boolean isstruct;
  string 10 location,loc2;
  
  BlockLoad(MainStockRec);
  location = SHp.Location;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
//  ORr.SerNr = SHp.OrderNr;
//  if (ReadFirstMain(ORr,1,true)) then begin
//    resf = ORr.Reserved;
//  end;
  if (sh2f) then begin  
    location = SH2p.Location;
    if (blank(location)) then begin
      location = MainStockRec.MainStock;
    end;
    rwcnt = MatRowCnt(SH2p);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SH2p,i,SHrw);
      if (nonblank(SHrw.Location)) then begin
        loc2 = SHrw.Location;
      end else begin
        loc2 = location;
      end;
      if (nonblank(SHrw.ArtCode)) then begin
        isstruct = false;
        if (SHrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
          isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
        end;
        if (isstruct==false) then begin
          if (SH2p.OKFlag==0) then begin
            t = -SHrw.Ship;
          end else begin
            t = SHrw.Ship;
          end;
          if (remove) then begin
            t = -t;
          end;
          UpdateInShipment(SHrw.ArtCode,loc2,SH2p.ShipDate,t);
        end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,SH2rw);
            if (SH2p.OKFlag==0) then begin
              t = -SH2rw.Ship;
            end else begin
              t = SH2rw.Ship;
            end;
            if (remove) then begin
              t = -t;
            end;
            UpdateInShipment(SH2rw.ArtCode,loc2,SH2p.ShipDate,t);
          end;
        end;
      end;
    end;
  end;  
  if (shf) then begin
    location = SHp.Location;
    if (blank(location)) then begin
      location = MainStockRec.MainStock;
    end;
    rwcnt = MatRowCnt(SHp);
    t = blankval;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHp,i,SHrw);
      if (nonblank(SHrw.Location)) then begin
        loc2 = SHrw.Location;
      end else begin
        loc2 = location;
      end;
      if (nonblank(SHrw.ArtCode)) then begin
        isstruct = false;
        if (SHrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
          isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
        end;
        if (isstruct==false) then begin
          if (SHp.OKFlag!=0) then begin
            t = -SHrw.Ship;
          end else begin
            t = SHrw.Ship;
          end;
          if (remove) then begin
            t = -t;
          end;
          UpdateInShipment(SHrw.ArtCode,loc2,SHp.ShipDate,t);
       end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,SH2rw);
            if (SHp.OKFlag!=0) then begin
              t = -SH2rw.Ship;
            end else begin
              t = SH2rw.Ship;
            end;
            if (remove) then begin
              t = -t;
            end;
            UpdateInShipment(SH2rw.ArtCode,loc2,SHp.ShipDate,t);
          end;
        end;
      end;
    end;
  end;
  return;
end;

procedure FindMaxProd(string item,string recepy,string location,Integer mode,var val maxp,Boolean inclorder,Boolean mulfactf)
begin
  record SHVc SHr;
  row SHVc SHrw;
  record INVc INr;
  record ItemStatusVc ISr;
  record RecVc Recr;
  row RecVc recrw;
  Integer i;
  Integer recrwcnt;
  Integer shrwcnt,shi;
  val mulfact,mulfact2;
  val t;
  val ord,t2;  
  LongInt maxl;

  RecordNew(SHr);
  ord = 0;
  mulfact2 = 1;
  mulfact = 1;
  Recr.Code = recepy;
  if (ReadFirstMain(Recr,1,true)) then begin
    recrwcnt = MatRowCnt(Recr);
    for (i=0;i<recrwcnt;i=i+1) begin
      MatRowGet(Recr,i,recrw);
      if (recrw.Item==item) then begin
        mulfact2 = recrw.OutQty;
      end;
    end;
    shrwcnt = 0;
    for (i=0;i<recrwcnt;i=i+1) begin
      MatRowGet(Recr,i,recrw);
      INr.Code = recrw.Item;
      if (ReadFirstMain(INr,1,true)) then begin
        if (INr.ItemType==kItemTypeStocked) then begin
          shrwcnt = MatRowCnt(SHr);
          ClearRow(SHr,SHrw,shrwcnt);       
          SHrw.ArtCode = recrw.Item;
          GetStockValue(SHrw.ArtCode,location,ISr);            
          if (mode==0) then begin
            SHrw.InStock = ISr.Instock;
          end;  
          if (mode==1) then begin
            SHrw.InStock = ISr.Instock - ISr.InShipment;
          end;
          if (inclorder) then begin
            if (mode==0) then begin
              SHrw.Ordered = ISr.OrddOut;
            end;
            if (mode==1) then begin
              SHrw.Ordered = ISr.OrddOut - ISr.InShipment;
            end;
            if (recrw.InQty!=0) then begin
              SHrw.InStock = SHrw.InStock - SHrw.Ordered;
            end;
          end;
          SHrw.Ship = SHrw.InStock;//curstock
          SHrw.RowPackages = 0;//produce
          SHrw.FIFO = recrw.InQty*mulfact;//inqty
          SHrw.FIFORowVal = recrw.OutQty*mulfact;//outqty
          MatRowPut(SHr,shrwcnt,SHrw);
        end;
      end;  
    end;
  end;
  shrwcnt = MatRowCnt(SHr);
  if (shrwcnt!=0) then begin
    maxp = 0;
    for (i=0;i<shrwcnt;i=i+1) begin
      MatRowGet(SHr,i,SHrw);    
      t = SHrw.InStock/SHrw.FIFO;
      if (i==0) then begin
        maxp = t;
      end else begin
        if ((SHrw.FIFO)!=0 and (nonblank(SHrw.FIFO))) then begin
          if (t<maxp) then begin
            maxp = t;
          end;  
        end;
      end;
    end;
    if (mulfactf) then begin
      maxp = maxp*mulfact2;
    end;
// The C code was wrong as well, it shouldn't round it should CUT.
// 0.99 means we don't have enough to build one single unit so it should be 0 not 1
//    maxp = Round(maxp,0);
    maxl = maxp;
    maxp = maxl;
  end;  
  return;
end;

global
procedure ExpandStructure(record INVc INr,string recepy,string location,Integer UpdateAvailable,var val maxp,var val ordp,Boolean mulfactf)
begin
  record RecVc Recr;
  val mulfact,mulfact2;
  val max1;

  maxp = 0;
  mulfact2 = 1;
  mulfact = 1;
  FindMaxProd(INr.Code,recepy,location,UpdateAvailable,max1,true,mulfactf);
  FindMaxProd(INr.Code,recepy,location,UpdateAvailable,maxp,false,mulfactf);
  ordp = maxp - max1;
  return;
end;

global
procedure GetStockedItemFromRecepy(record SHVc RecSHp,var string resp,var val recqtyp)
begin
  row SHVc SHrw;
  Integer i,rwcnt;
  record INVc INr;

  resp = "";
  recqtyp = blankval;
  rwcnt = MatRowCnt(RecSHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RecSHp,i,SHrw);
    INr.Code = SHrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1) then begin
        resp = SHrw.ArtCode;
        recqtyp = SHrw.Ship;
        goto LGetStockedItemFromRecepy;
      end;
    end;
  end;
LGetStockedItemFromRecepy:;  
  return;
end;

procedure FindAdjstockvQtyIVVc(string fnr,record IVVc IVp,string stockartcodep,Integer currow,var val adjstockvp)
begin
/*to find all ocurancies of the artcode on the delivery and adjstockv qty for the artcode*/
  Integer j;
  record SHVc RecSHp;
  row IVVc IVrw;
  Boolean isstruct;
  string 20 locartcode;
  val recqty;

  adjstockvp = blankval;
  if (fnr=="IVVc") then begin    
    for (j=0;j<currow;j=j+1) begin
      MatRowGet(IVp,j,IVrw);
      isstruct = ExpandStructItem(IVrw.ArtCode,IVrw.Recepy,IVrw.Quant,RecSHp);
      if (isstruct) then begin
        if (MatRowCnt(RecSHp)!=1) then begin goto LFindAdjstockvQtyIVVc; end;
        GetStockedItemFromRecepy(RecSHp,locartcode,recqty);
        if (stockartcodep==locartcode) then begin
          adjstockvp = adjstockvp - recqty;
        end;  
      end;  
LFindAdjstockvQtyIVVc:;    
    end;  
  end;    
  return;
end;

procedure CalculateIVRowFIFO(record INVc INr,record CostAccBlock CAb,string location,record IVVc IVp,row IVVc IVrw,Integer currow)
begin
  val adjstockv,t;
  Integer j;
  row IVVc IV2rw;
  Boolean testf;
  string 255 serialnr;
  record SerNrTrackBlock SNrb;
  val qty;
  
  BlockLoad(SNrb);
  if (IVrw.ovst!=0) then begin goto LCalculateIVRowFIFO; end;
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin
    MatRowGet(IVp,j,IV2rw);
    testf = true;
    if (TestArtCode(IV2rw.ArtCode,IVrw.ArtCode,INr)==false) then begin testf = false; end;
    if (IV2rw.stp!=IVrw.stp) then begin testf = false; end;
    if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
      if (IVp.OrderNr>0) then begin
        if (IV2rw.OrdRow!=0) then begin testf = false; end;
      end;
    end;
    if (IV2rw.ovst!=0) then begin testf = false; end;
    if (testf) then begin
      adjstockv = adjstockv + IV2rw.Quant;  
    end;    
  end;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
//    if (IVp.CredInv>0) and (IVrw.CreditedRow>=0) then begin
//when credit row is blank we take cost price of item
//when credit row is not balnk and retrned more then inoiced we take FIFO of Org + remqty*INr.InPirce
    switch (IVrw.stp) begin
      case kInvoiceRowTypeNormal:
        IVrw.FIFORowVal = CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,IVrw.ArtCode,IVrw.Quant,IVrw.stp,0);
      case kInvoiceRowTypeStructuredItemComponent:
        IVrw.FIFORowVal = CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,IVrw.ArtCode,IVrw.Quant,IVrw.stp,0);
      case kInvoiceRowTypeCorrection:
        IVrw.FIFORowVal = CreditedInvoiceRowFIFORowVal(INr,location,IVp.InvType,IVp.CredInv,IVrw.SerialNr,IVrw.CreditedRow,IVrw.ArtCode,IVrw.Quant,IVrw.stp,adjstockv);
    end;
  end else begin  
    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
      IVrw.FIFORowVal = blankval;
      qty = blankval;
      serialnr = FirstInRange(IVrw.SerialNr,60);
      while (nonblank(serialnr)) begin
        IVrw.FIFORowVal = IVrw.FIFORowVal + FindCostPrice(IVrw.ArtCode,location,serialnr,1.00,adjstockv,false);
        qty = qty + 1;
        adjstockv = adjstockv + 1;
        serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
        if (qty>=IVrw.Quant) then begin serialnr = ""; end;
      end;
    end else begin
      IVrw.FIFORowVal = FindCostPrice(IVrw.ArtCode,location,IVrw.SerialNr,IVrw.Quant,adjstockv,false);
    end;
  end;
  IVrw.FIFORowVal = Round(IVrw.FIFORowVal,SetRoundModeD(5));
  IVrw.FIFO = IVrw.FIFORowVal/IVrw.Quant;
LCalculateIVRowFIFO:;  
  return;
end;

global
procedure IVUpdateFIFO(record IVVc IVp,Boolean trflg)
begin
  row IVVc IVrw;
  row IVVc IV2rw;
  Integer rwcnt;
  Integer i,j;
  record SHVc SHr;
  record SHVc RecSHp;
  record INVc INr;
  record MainStockBlock MainStockRec;
  record CostAccBlock CAb;
  Boolean isstruct,skpif,testf;
  string 20 stockartcode;
  string 255 location;
  val recqty,t;
  val adjstockv;
     
  BlockLoad(MainStockRec);
  BlockLoad(CAb);
  t = blankval;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.NotUpdStockFlag==0) and (IVrw.ovst==0) then begin
    if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeCorrection) then begin
      testf = true;
      if (nonblank(IVrw.ArtCode)) then begin
        INr.Code = IVrw.ArtCode;
        if (ReadFirstItem(IVrw.ArtCode,INr,true,true)==false) then begin goto L80SKIPROWIVUpdateFIFO; end;
      end;
      if (IVp.OrderNr>0) then begin
        if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
          if (IVp.UpdStockFlag==0) then begin
            testf = false;
          end else begin
            if (IVrw.CreditedRow<0) then begin
              testf = false;
            end;
          end;
        end else begin
          if (IVrw.OrdRow>=0) then begin
            if (INr.ItemType==kItemTypePlain) or (INr.ItemType==kItemTypeService) then begin 
              if (CAb.CostAccForNonStocked==0) then begin
                testf = false;
              end else begin
//                testf = false;//Here ? 
              end;
            end else begin
              testf = false;
            end;
          end;
        end;
      end;
      if (testf) then begin
        location = IVrw.Location;
        if (blank(location)) then begin
          location = IVp.Location;
        end;
        if (blank(location)) then begin
          location = MainStockRec.MainStock;
        end;  
        if (nonblank(IVrw.ArtCode)) then begin
          IVrw.FIFO = blankval;
          IVrw.FIFORowVal = blankval;
          skpif = true;
          if ((INr.ItemType==kItemTypeStocked) or (INr.ItemType==kItemTypeStructured)) then begin skpif = false; end;
          if ((INr.ItemType!=kItemTypeStocked) and (INr.ItemType!=kItemTypeStructured)) then begin 
            if (CAb.CostAccForNonStocked!=0) then begin
              skpif = false; 
            end;
          end;     
          if (skpif) then begin goto L80SKIPROWIVUpdateFIFO; end;
        end else begin
          goto L80SKIPROWIVUpdateFIFO;
        end;        
        if (true) then begin
          if (trflg) then begin
            if (IVrw.Quant>0) then begin
              isstruct = false;
              if (IVrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
                isstruct = ExpandStructItem(IVrw.ArtCode,IVrw.Recepy,IVrw.Quant,RecSHp);
              end;
              if (isstruct) then begin
                if (MatRowCnt(RecSHp)!=1) then begin goto L88SKIPROWIVUpdateFIFO; end;
                GetStockedItemFromRecepy(RecSHp,stockartcode,recqty);
                FindAdjstockvQtyIVVc("IVVc",IVp,stockartcode,i,adjstockv);
                IVrw.FIFORowVal = FindCostPrice(stockartcode,location,IVrw.SerialNr,recqty,adjstockv,false);
                IVrw.FIFORowVal = Round(IVrw.FIFORowVal,SetRoundModeD(5));
                IVrw.FIFO = IVrw.FIFORowVal/recqty;
              end else begin
                CalculateIVRowFIFO(INr,CAb,location,IVp,IVrw,i);
              end;  
            end else begin
              IVrw.FIFO = blankval;
              CalculateIVRowFIFO(INr,CAb,location,IVp,IVrw,i);
            end;  
          end;
        end else begin        
        end;
      end;
    end;
L80SKIPROWIVUpdateFIFO:;
    MatRowPut(IVp,i,IVrw);
    end;
L88SKIPROWIVUpdateFIFO:;
  end;
  return;
end;

