external procedure VIDDefault(Integer,string,var record VIVc);
external procedure VISumup(record VIVc,var val);
forward function Boolean GetWHTaxRow(string,var row WHTaxBlock);
external procedure VIVc_PastePrepayNr(var record VIVc,Integer);
external updating function Integer RecordAction_POOrdDownPay(LongInt,val,val,var record VIVc,var string,integer);
external function Boolean VIVc_PasteVECode(var record VIVc,Integer,Boolean,Boolean,var string);
external function Boolean GetPMRow(string,var row PMBlock);
external function Integer VATType(string);
external procedure SetupVATBase(var record SMVc,var Integer);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val AbsoluteVal(val);
external procedure OPVc_PasteVATCode(var record OPVc,Integer);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external function Boolean FindWHVETax(string,Date,var record WHVEVc);
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external function roundmode DefaultRoundMode();
external function string 255 GetSupplierOnAccountAC(string);
external procedure Mul2VAT(string,val,var val,var val,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure ExtractObj(string,var Integer,var string);
external function Boolean PasteInvIn2OPr(var record OPVc,Integer,Date,Integer,val,var string,Boolean,var Boolean);
external function Integer GetCheck(string,string,LongInt,var string,var string,var string,var val,var Date,var Date);
external function Boolean GetPMCurrency(string,var string);
external procedure MatchOPRowSums(string,string,Date,string,var val,var string,var val,string,var val,Boolean,Boolean,Boolean);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external procedure OPSumup(var record OPVc,Boolean);

forward function Boolean VIHasWHTaxAccNumber(LongInt,string);

function Boolean CheckVERegion(string whtax,string VIRegion, string supplier,date transdate)
begin
  record WHVEVc WHVEr;
  record CUVc VEr;
  row WHVEVc WHVErw;
  Integer i,rwcnt;
  Boolean res;
  record APAccBlock APb;
  row WHTaxBlock WHTaxrw;
  row PMBlock PMrw;  
  
  BlockLoad(APb);
  if (APb.GrossIncomeWithTaxPerRegion!=0) then begin 
    if (FindWHVETax(supplier,transdate,WHVEr)) then begin
      VEr.Code = supplier;
      if ReadFirstMain(VEr,1,true) then begin 
      end;
      rwcnt = MatRowCnt(WHVEr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(WHVEr,i,WHVErw);
        if (whtax==WHVErw.WHTax) then begin
          res = true;
          if (WHVErw.CalculateTax!=kCalculateTax) then begin res = false; end;
          if (nonblank(WHVErw.Region)) then begin
            if (VEr.NoTax2!=0) then begin res = false; end;
          end;
          GetWHTaxRow(WHVErw.WHTax,WHTaxrw);
          GetPMRow(WHTaxrw.PayMode,PMrw);
          switch (PMrw.CheckType) begin
            case kPayModeTypeRegionalWithholding:
              if (WHVErw.Region!=VIRegion) then begin 
                res = false;
              end;
          end;
          i = rwcnt;
        end;  
      end;  
    end;
  end else begin 
    res = true;  
  end;  
  CheckVERegion = res;
  return;
end;  

global
procedure ChangeOPInvVal(row OPVc oprp,Date tdp)
begin
  val t;

  if (oprp.PInvCurncy==oprp.RecCurncy) then begin
    oprp.PInvVal = oprp.RecVal;
  end else begin
    CurValToOtherCur(tdp,oprp.RecCurncy,oprp.RecVal,oprp.PInvCurncy,t,DefaultCurRoundOff);
    oprp.PInvVal = t;
  end;
  return;
end;

procedure ChangeOPRecVal(Integer rownr,row OPVc OPrw,Date tdp)
BEGIN
  val t;
  record APVc APr;
  record OPPVc OPPr;
  record BaseCurBlock BCb;

  if (OPrw.VISerNr>0) then begin 
    APr.SerNr = OPrw.VISerNr; 
    ReadFirstMain(APr,1,true);
  end;
  BlockLoad(BCb);
  ChangeOPInvVal(OPrw,tdp);
  if (OPrw.BankCurncy==OPrw.PInvCurncy) then begin
    OPrw.BankVal = OPrw.PInvVal;
  end else begin
    if (OPrw.BankCurncy==OPrw.RecCurncy) then begin
      OPrw.BankVal = OPrw.RecVal;
    end else begin
      if (OPrw.VISerNr>0) then begin
        if (OPrw.PInvVal==APr.RVal) then begin
          t = APr.BookRVal;
        end else begin
          CurValToOtherCur(tdp,OPrw.RecCurncy,OPrw.RecVal,OPrw.BankCurncy,t,DefaultCurRoundOff);
        end;
      end;
      if (OPrw.PrepayNr>0) then begin
        OPPr.SerNr = OPrw.PrepayNr;
        if (ReadFirstMain(OPPr,1,true)) then begin
          if (OPrw.BankCurncy==BCb.BaseCur1 and OPrw.B1BankVal!=0) then begin
            if (AbsoluteVal(OPrw.PInvVal)==AbsoluteVal(OPPr.PPVal)) then begin
              t = OPPr.BookRVal;
            end else begin
              t = (OPPr.BookRVal*OPrw.PInvVal)/OPPr.PPVal;
            end;
            if (OPrw.PInvVal<0) then begin
              t = -t;
            end;
          end else begin
            CurValToOtherCur(tdp,OPrw.RecCurncy,OPrw.RecVal,OPrw.BankCurncy,t,DefaultCurRoundOff);
          end;
        end else begin
          CurValToOtherCur(tdp,OPrw.RecCurncy,OPrw.RecVal,OPrw.BankCurncy,t,DefaultCurRoundOff);
        end;
      end;
      if (t==0) then begin
        CurValToOtherCur(tdp,OPrw.RecCurncy,OPrw.RecVal,OPrw.BankCurncy,t,DefaultCurRoundOff);
      end;
      OPrw.BankVal = t;      
    end;
  end;
  if (OPrw.PInvVal<0) then begin
    OPrw.B1BankVal = -OPrw.B1BankVal;
    OPrw.B2BankVal = -OPrw.B2BankVal;
  end;
  RETURN;
END;

procedure ChangeOPBankCurncy(var record OPVc OPp,string curcode)
BEGIN
  row OPVc OPrw;
  Integer rwcnt,i;
  
  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    OPrw.BankCurncy = curcode;
    ChangeOPRecVal(i,OPrw,OPp.TransDate);
    MatRowPut(OPp,i,OPrw);
  end;
  RETURN;
END;

global
procedure OPVc_PastePayCurCode(var record OPVc OPp)
BEGIN
  ChangeOPBankCurncy(OPp,OPp.PayCurCode);
  OPSumup(OPp,true);
  RETURN;
END;

procedure ChangeOPTotPay(var record OPVc OPp,val totvalp)
BEGIN
  row OPVc OPrw;
  Integer rwcnt,i;
  val oldbtot,sumt,incr,diff;
  
  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    if ((OPrw.stp==kPaymentRowTypeNormal) and (OPrw.ovst==0)) then begin
      oldbtot = oldbtot + OPrw.BankVal;
    end;
  end;
  diff = totvalp/oldbtot;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    if ((OPrw.stp==kPaymentRowTypeNormal) and (OPrw.ovst==0)) then begin
      sumt = totvalp + oldbtot;
      OPrw.BankVal = OPrw.BankVal*diff;
      OPrw.BankVal = Round(OPrw.BankVal,DefaultRoundMode);
      if (OPrw.BankVal==0) then begin OPrw.BankVal = blankval; end;
      MatRowPut(OPp,i,OPrw);
      incr = incr + OPrw.BankVal;
    end;
  end;
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(OPp,i,OPrw);
    if ((OPrw.stp==kPaymentRowTypeNormal) and (OPrw.ovst==0)) then begin
      if (OPrw.BankVal!=0) then begin
        sumt = totvalp - incr;
        OPrw.BankVal = OPrw.BankVal + sumt;
        if (OPrw.BankVal==0) then begin OPrw.BankVal = blankval; end;
        MatRowPut(OPp,i,OPrw);
        goto LChangeOPTotPay;
      end;
    end;
  end;
LChangeOPTotPay:;
  RETURN;
END;

global
procedure OPVc_PasteCurPayVal(var record OPVc OPp)
BEGIN
  ChangeOPTotPay(OPp,OPp.CurPayVal);
  OPSumup(OPp,true);
  RETURN;
END;

global
procedure OPVc_PasteVECode(var record OPVc OPp,Integer rownr)
BEGIN
  record APAccBlock APAccRec;
  record BaseCurBlock bascur;
  record VIVc VIr;
  record CUVc VEr;
  string 5 crncy,thepm;
  string 255 t1,t2;
  row OPVc OPrw;
  
  MatRowGet(OPp,rownr,OPrw);
  BlockLoad(APAccRec);
  VIr.SerNr = OPrw.VISerNr;
  if (ReadFirstMain(VIr,1,true)) then begin
    if (OPrw.VECode!=VIr.VECode) then begin
      MessageBox(1215," " & OPrw.VECode);
    end;
  end;
  VEr.Code = OPrw.VECode;
  if (ReadFirstMain(VEr,1,true)) then begin
    t1 = VEr.Name;
    if (HasLocalization("SWE")) then begin//vatSwedish
      if (nonblank(VEr.BankAccount)) then begin  //Then bankfile now supports both formats
        t2 = VEr.BankAccount;
      end else begin
        t2 = VEr.Bank;
      end;
    end else begin
      t2 = VEr.IBANCode;
      if (blank(t2)) then begin
        t2 = VEr.BankAccount;
      end;
      if (blank(t2)) then begin
        t2 = VEr.Bank;
      end;
    end;
    if (APAccRec.OnAccUseObj!=0) then begin
      OPrw.Objects = VEr.VEObjects;
    end;    
    if (OPrw.VISerNr<0) then begin
      OPrw.APAcc = GetSupplierOnAccountAC(VEr.Code);
    end;    
  end;
  OPrw.BankAcc = t2;
  OPrw.SortCode = VEr.SortCode;
  OPrw.Comment = t1;
  crncy = VEr.VECurncyCode; 
  if (blank(crncy)) then begin
    BlockLoad(bascur);  
    crncy = bascur.StdBaseCur;
  end;             
  OPrw.PInvCurncy = crncy;  
  OPrw.BankCurncy = crncy;  
  OPrw.RecCurncy = crncy;
  if (nonblank(OPrw.PayMode)) then begin
    thepm = OPrw.PayMode;
  end else begin
    thepm = OPp.PayMode;
  end;  
  if (GetPMCurrency(thepm,crncy)) then begin end;  
  if (nonblank(crncy)) then begin
    OPrw.BankCurncy = crncy;
  end;
  MatRowPut(OPp,rownr,OPrw);
  RETURN;
END;

procedure ChangeOPRecCur(Integer rownr,row OPVc oprp,Date tdp)
BEGIN
  Boolean copytobank;
  val t;

  if (oprp.PInvCurncy==oprp.RecCurncy) then begin
    if (oprp.RecVal!=oprp.BankVal) then begin copytobank = true; end;
    oprp.RecVal = oprp.PInvVal;
  end else begin
    if (oprp.RecVal!=oprp.BankVal) then begin copytobank = true; end;
    CurValToOtherCur(tdp,oprp.PInvCurncy,oprp.PInvVal,oprp.RecCurncy,t,DefaultCurRoundOff);
    oprp.RecVal = t;
  end;
  oprp.RecVal = oprp.RecVal;
  oprp.PInvVal = oprp.PInvVal;
  if (copytobank) then begin
    oprp.BankVal = oprp.RecVal;
    oprp.BankCurncy = oprp.RecCurncy;
    oprp.BankVal = oprp.BankVal;
    oprp.BankCurncy = oprp.BankCurncy;
  end;
  if (oprp.VISerNr==-1) then begin
    oprp.PInvCurncy = oprp.RecCurncy;
    oprp.PInvVal = oprp.RecVal;
  end;  
  RETURN;
END;

global
procedure OPVc_PasteRecCurncy(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  
  MatRowGet(OPp,rownr,OPrw);
  ChangeOPRecCur(rownr,OPrw,OPp.TransDate);
  MatRowPut(OPp,rownr,OPrw);
  if (nonblank(OPrw.VATCode)) then begin
    OPVc_PasteVATCode(OPp,rownr);
  end;
  OPSumup(OPp,true);
  return;
end;

global
function Boolean OPVc_PasteToRateB1BankVal(var record OPVc OPp,Integer rownr)
begin
  Boolean res,apf,calculatedf,testf;
  row OPVc OPrw;
  record BaseCurBlock BCb;
  val fr,to1,to2,br1,br2;
  record APVc APr;
  record OPPVc OPPr;

  BlockLoad(BCb);  
  MatRowGet(OPp,rownr,OPrw);
//  if (nonblank(OPrw.B1BankVal)) then begin

  if (true) then begin
    APr.SerNr = OPrw.VISerNr; 
    apf = ReadFirstMain(APr,1,true);
    if (OPrw.BankCurncy!=BCb.BaseCur1) then begin
      if (HasLocalization("POL") or nonblank(OPrw.B1BankVal) or nonblank(OPrw.FrRateBankVal) or nonblank(OPrw.ToRateB1BankVal) or nonblank(OPrw.ToRateB2BankVal) or nonblank(OPrw.BaseRate1BankVal) or nonblank(OPrw.BaseRate2BankVal)) then begin
        GetFullCurncyRate(OPrw.BankCurncy,OPp.TransDate,fr,to1,to2,br1,br2);
        if (blank(OPrw.FrRateBankVal)==false) then begin fr = OPrw.FrRateBankVal; end;
        if (blank(OPrw.ToRateB1BankVal)==false) then begin to1 = OPrw.ToRateB1BankVal; end;
        if (blank(OPrw.ToRateB2BankVal)==false) then begin to2 = OPrw.ToRateB2BankVal; end;
        if (blank(OPrw.BaseRate1BankVal)==false) then begin br1 = OPrw.BaseRate1BankVal; end;
        if (blank(OPrw.BaseRate2BankVal)==false) then begin br2 = OPrw.BaseRate2BankVal; end;      
//      OPrw.B1BankVal = OPrw.ToRateB1BankVal*OPrw.BankVal;//must be very wrong
//      OPrw.B1BankVal = Round(OPrw.B1BankVal,DefaultRoundMode);
        if (blank(fr)) and ((nonblank(to1)) or (nonblank(to2))) then begin fr = 1; end;
        OPrw.B1BankVal = MulRateToBase1(OPrw.BankCurncy,OPrw.BankVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);
        if (OPrw.B1BankVal==0) then begin OPrw.B1BankVal = blankval; end;
        MatRowPut(OPp,rownr,OPrw);
        res = true;
      end;
    end else begin
      testf = true;
      if (OPrw.PInvVal==APr.RVal) then begin
        if (HasLocalization("POL") or nonblank(OPrw.B1BankVal)) then begin
          OPrw.B1BankVal = APr.BookRVal;
          testf = false;
        end;
      end;
      if (testf) then begin
        calculatedf = false;
        if (OPrw.PrepayNr>0) then begin
          OPPr.SerNr = OPrw.PrepayNr;
          if (ReadFirstMain(OPPr,1,true)) then begin
            if (OPrw.BankCurncy==BCb.BaseCur1 and OPrw.B1BankVal!=0) then begin
              calculatedf = true;
              if (AbsoluteVal(OPrw.PInvVal)==AbsoluteVal(OPPr.PPVal)) then begin
                OPrw.B1BankVal = OPPr.BookRVal;
              end else begin
                OPrw.B1BankVal = (OPPr.BookRVal*OPrw.PInvVal)/OPPr.PPVal;
              end;
              if (OPrw.PInvVal<0) then begin
                OPrw.B1BankVal = -OPrw.B1BankVal;
              end;
            end;
          end;
        end;
        if (calculatedf==false) then begin
          GetFullCurncyRate(OPrw.PInvCurncy,OPp.TransDate,fr,to1,to2,br1,br2);
          if (blank(OPrw.FrRateBankVal)==false) then begin fr = OPrw.FrRateBankVal; end;
          if (blank(OPrw.ToRateB1BankVal)==false) then begin to1 = OPrw.ToRateB1BankVal; end;
          if (blank(OPrw.ToRateB2BankVal)==false) then begin to2 = OPrw.ToRateB2BankVal; end;
          if (blank(OPrw.BaseRate1BankVal)==false) then begin br1 = OPrw.BaseRate1BankVal; end;
          if (blank(OPrw.BaseRate2BankVal)==false) then begin br2 = OPrw.BaseRate2BankVal; end;      
//      OPrw.B1BankVal = OPrw.ToRateB1BankVal*OPrw.PInvVal;
//      OPrw.B1BankVal = Round(OPrw.B1BankVal,DefaultRoundMode);
          if (blank(fr)) and ((nonblank(to1)) or (nonblank(to2))) then begin fr = 1; end;
          if (HasLocalization("POL") or nonblank(OPrw.B1BankVal) or nonblank(OPrw.FrRateBankVal) or nonblank(OPrw.ToRateB1BankVal) or nonblank(OPrw.ToRateB2BankVal) or nonblank(OPrw.BaseRate1BankVal) or nonblank(OPrw.BaseRate2BankVal)) then begin
            OPrw.B1BankVal = MulRateToBase1(OPrw.PInvCurncy,OPrw.PInvVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);
            if (OPrw.B1BankVal==0) then begin OPrw.B1BankVal = blankval; end;
          end;
        end;
      end;
      if (HasLocalization("POL") or nonblank(OPrw.B1BankVal)) then begin
        OPrw.BankVal = OPrw.B1BankVal;
        if (OPrw.BankCurncy==OPrw.RecCurncy) then begin
          OPrw.RecVal = OPrw.BankVal;
        end;
        MatRowPut(OPp,rownr,OPrw);
      end;
      res = true;
    end;
    OPSumup(OPp,false);
  end;
  OPVc_PasteToRateB1BankVal = res;
  RETURN;
END;

global
procedure OPVc_PasteRecVal(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  val t,rs,t1,v;
  record AccBlock Accb;
  record RoundBlock Rb;
  record VIVc VIr;
  
  BlockLoad(Rb);  
  MatRowGet(OPp,rownr,OPrw);
  ChangeOPRecVal(rownr,OPrw,OPp.TransDate);
  
  if (nonblank(OPrw.VATCode)) then begin
    if (OPrw.VISerNr<0) then begin
      BlockLoad(Accb);  
      MulVATIV(OPrw.VATCode,OPrw.PInvVal,t,t1,1,Accb.NoTAXonVAT);
      OPrw.VATVal = Round(t,GetVATRoundMode(Rb));
      OPrw.TAX1Sum = Round(t1,GetVATRoundMode(Rb));
    end else begin
      VIr.SerNr = OPrw.VISerNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        v = VIr.PayVal;
        if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          v = -v;
        end;
        if (nonblank(VIr.VATVal)) then begin
          t = VIr.VATVal;
        end else begin
          t = VIr.CalcVATVal;
        end;
        if (v==OPrw.PInvVal) then begin
          OPrw.VATVal = t;
          if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
            OPrw.VATVal = -OPrw.VATVal;
          end;
        end else begin
          OPrw.VATVal = OPrw.PInvVal*t;
          OPrw.VATVal = OPrw.VATVal/(VIr.PayVal-VIr.WithHoldingTax);
        end;
      end else begin
        Mul2VAT(OPrw.VATCode,OPrw.PInvVal,t,rs,1);
        OPrw.VATVal = Round(t,GetVATRoundMode(Rb));
      end;
    end;
  end else begin
    OPrw.VATVal = blankval;
    OPrw.TAX1Sum = blankval;
  end; 
  MatRowPut(OPp,rownr,OPrw);
  OPVc_PasteToRateB1BankVal(OPp,rownr);
  OPSumup(OPp,true);
  RETURN;
END;

procedure ChangeOPBankVal(Integer rownr,row OPVc oprp,Date tdp)
BEGIN
  val t;
  
  if (oprp.RecVal==0) then begin
    if (oprp.BankCurncy==oprp.PInvCurncy) then begin
      oprp.PInvVal = oprp.BankVal;
    end else begin
      if (oprp.BankCurncy==oprp.RecCurncy) then begin
        oprp.PInvVal = oprp.BankVal;
      end else begin
        CurValToOtherCur(tdp,oprp.BankCurncy,oprp.BankVal,oprp.PInvCurncy,t,DefaultCurRoundOff);
        oprp.PInvVal = t;
      end;
    end;  
    if (oprp.BankCurncy==oprp.RecCurncy) then begin
      oprp.RecVal = oprp.BankVal;
    end else begin
      CurValToOtherCur(tdp,oprp.BankCurncy,oprp.BankVal,oprp.RecCurncy,t,DefaultCurRoundOff);
      oprp.RecVal = t;
    end;
  end;  
  RETURN;
END;

global
procedure OPVc_PasteBankVal(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  record BaseCurBlock BCb;
  
  BlockLoad(BCb);
  MatRowGet(OPp,rownr,OPrw);
  if (OPrw.BankCurncy==OPrw.RecCurncy) then begin
    ChangeOPRecVal(rownr,OPrw,OPp.TransDate);          
  end else begin
    ChangeOPBankVal(rownr,OPrw,OPp.TransDate);
  end;
  if (OPrw.BankCurncy==BCb.BaseCur1) or (blank(OPrw.BankCurncy)) then begin
    if (HasLocalization("POL")) then begin
      if (nonblank(OPrw.B1BankVal)) then begin
        OPrw.B1BankVal = OPrw.BankVal;
      end;
      MatRowPut(OPp,rownr,OPrw);
    end;
  end else begin
    MatRowPut(OPp,rownr,OPrw);
    if (HasLocalization("POL")) then begin
      OPVc_PasteToRateB1BankVal(OPp,rownr);
    end;
  end;
  OPSumup(OPp,true);
  RETURN;
END;

global
procedure OPVc_PasteBankFeeVal(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  
  MatRowGet(OPp,rownr,OPrw);
  ChangeOPBankVal(rownr,OPrw,OPp.TransDate);
  MatRowPut(OPp,rownr,OPrw);
  OPSumup(OPp,true);
  RETURN;
END;

function val SubSameSupplierAmount(record OPVc OPp,Integer rownr,row OPVc oprp,string curncy)
BEGIN
  row OPVc OPrw;
  Integer i,rwcnt;
  val recamount,temp;

  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i!=rownr) then begin
      MatRowGet(OPp,i,OPrw);
      if (OPrw.VECode==oprp.VECode) then begin
        CurValToOtherCur(OPp.TransDate,oprp.RecCurncy,oprp.RecVal,curncy,recamount,DefaultCurRoundOff);
        temp = temp - recamount;
      end;
    end;
  end;
  SubSameSupplierAmount = temp;
  RETURN;
END;

function Boolean PasteVendIn2OPr(var record OPVc OPp,row OPVc OPrw,Date tdp)
BEGIN
  Boolean res;
  record CUVc VEr;
  val tot;
  record APAccBlock APAccRec;
              
  BlockLoad(APAccRec);
  VEr.Code = OPrw.VECode;
  if (ReadFirstMain(VEr,1,true)) then begin  
    OPrw.VECode = VEr.Code;
    OPrw.Comment = VEr.Name;
    OPrw.PInvVal = tot;
    OPrw.PInvCurncy = VEr.VECurncyCode;
    OPrw.BankVal = tot;
    OPrw.BankCurncy = VEr.VECurncyCode;
    OPrw.RecVal = tot;
    OPrw.RecCurncy = VEr.VECurncyCode;
    if (APAccRec.OnAccUseObj!=0) then begin
      OPrw.Objects = VEr.VEObjects;
    end;                
    res = true;
  end else begin
    res = false;
  end;
  PasteVendIn2OPr = res;
  RETURN;
END;

function val FindOwnCheckAmount(var record OPVc OPp,Integer rownr,LongInt checknr,val checkamount,Integer cht)
BEGIN
  val res,t,v;
  row OPVc OPrw;
  Integer i;
  record OwnCheckVc OwnCheckr;
  record CheckVc Checkr;
  LongInt checknr2;
  string 20 curncy2,tstr;
  val checkamount2;
  Date td2,regdate;
  Integer cht2;
  
  res = checkamount;  
  switch (cht) begin
    case 1:
      Checkr.SerNr = checknr;
      if (ReadFirstMain(Checkr,1,true)) then begin
        for (i=0;i<rownr;i=i+1) begin
          MatRowGet(OPp,i,OPrw);
          cht2 = GetCheck(OPp.PayMode,OPrw.PayMode,checknr2,tstr,tstr,curncy2,checkamount2,td2,regdate);
          if (OPrw.ChequeNr==Checkr.SerNr) and (cht==cht2) then begin
            CurValToOtherCur(OPp.TransDate,OPrw.RecCurncy,OPrw.RecVal,Checkr.CurncyCode,t,DefaultCurRoundOff);
            v = v + t;
          end;
        end;
      end;
    case 2:
      OwnCheckr.SerNr = checknr;
      if (ReadFirstMain(OwnCheckr,1,true)) then begin
        for (i=0;i<rownr;i=i+1) begin
          MatRowGet(OPp,i,OPrw);
          cht2 = GetCheck(OPp.PayMode,OPrw.PayMode,checknr2,tstr,tstr,curncy2,checkamount2,td2,regdate);
          if (OPrw.ChequeNr==OwnCheckr.SerNr) and (cht==cht2) then begin
            CurValToOtherCur(OPp.TransDate,OPrw.RecCurncy,OPrw.RecVal,OwnCheckr.CurncyCode,t,DefaultCurRoundOff);
            v = v + t;
          end;
        end;
      end;
  end;
  res = res - v;  
  FindOwnCheckAmount = res;
  RETURN;
END;

function Boolean PasteCheckInOP(var record OPVc OPp,Integer rownr,row OPVc oprp,LongInt checknr)
BEGIN
  Boolean res;
  row OPVc OPrw;
  row OPVc OP2rw;
  val temp,checkamount,checkamount2,recamount,t,openrecval;
  string 20 curncy,curncy2;
  Integer cht,cht2;
  Integer row1,i,rwcnt;
  string 2 thepm;
  string 255 tstr;
  Date td,td2,regdate;
  Boolean newrowf,instf;
  LongInt checknr2;
  
  rwcnt = MatRowCnt(OPp);
  if (nonblank(oprp.PayMode)) then begin
    thepm = oprp.PayMode;
  end else begin
    thepm = OPp.PayMode; 
  end;
  MatRowGet(OPp,rownr,OPrw);
  openrecval = OPrw.RecVal;
  cht = GetCheck(OPp.PayMode,oprp.PayMode,checknr,tstr,tstr,curncy,checkamount,td,regdate);
  checkamount = FindOwnCheckAmount(OPp,rownr,checknr,checkamount,cht);
  if ((cht>0) and (checknr!=-1)) then begin
    if (true) then begin
      if (GetPMCurrency(thepm,tstr)) then begin end;  
      oprp.BankCurncy = tstr;
      OPrw.RecCurncy = curncy;
      
      CurValToOtherCur(OPp.TransDate,curncy,checkamount,oprp.RecCurncy,recamount,DefaultCurRoundOff);
      if (recamount>oprp.RecVal) and (oprp.RecVal<>0) then begin
        CurValToOtherCur(OPp.TransDate,oprp.RecCurncy,oprp.RecVal,curncy,t,DefaultCurRoundOff);
        OPrw.RecVal = t;
      end else begin
        OPrw.RecVal = checkamount;
      end;      
      oprp.BankCurncy = tstr;
      oprp.RecCurncy = curncy;
      oprp.RecVal = OPrw.RecVal;
      MatRowPut(OPp,rownr,oprp);        
      OPVc_PasteRecVal(OPp,rownr);
      MatRowGet(OPp,rownr,oprp);
      if (blank(openrecval)) then begin
        openrecval = OPrw.RecVal;
      end;
    end;  
    if (true) then begin
      CurValToOtherCur(OPp.TransDate,curncy,checkamount,oprp.RecCurncy,recamount,DefaultCurRoundOff);
      if (checkamount<0) then begin checkamount = blankval; end;
      if (recamount<0) then begin recamount = blankval; end;
      if (checkamount!=openrecval) then begin
        CurValToOtherCur(OPp.TransDate,oprp.RecCurncy,oprp.RecVal,curncy,recamount,DefaultCurRoundOff);
        temp = openrecval - checkamount;
        if (rownr<99) then begin
          if (temp>0) then begin          
            row1 = rownr + 1;
            CopyRow(OPp,oprp,OP2rw);
            OP2rw.BankVal = temp;
            OP2rw.PInvVal = temp;
            OP2rw.RecVal = temp;         
            OP2rw.ChequeNr = -1;
            MatRowInsert(OPp,row1,OP2rw);
            OPVc_PasteRecVal(OPp,row1);
          end else begin
            temp = -temp;
            newrowf = true;
            if (rownr<(rwcnt-1)) then begin
              row1 = rownr + 1;
              while (row1<rwcnt) begin
                MatRowGet(OPp,row1,OPrw);        
                if (blank(OPrw.WHTax) and OPrw.VECode==oprp.VECode and OPrw.PayMode==oprp.PayMode) then begin
                  OPrw.ChequeNr = oprp.ChequeNr;
                  MatRowPut(OPp,row1,OPrw);        
                  res = PasteCheckInOP(OPp,row1,OPrw,OPrw.ChequeNr);
                  newrowf = false;
                  goto LOutLoop;
                end;
                row1 = row1 + 1;
              end;
              MatRowGet(OPp,row1,OPrw);              
LOutLoop:;          
            end;    
            if (newrowf) then begin
              row1 = rownr + 1;
              ClearRow(OPp,OP2rw,1);  
              OP2rw.stp = 1;
              OP2rw.VECode = oprp.VECode;
              res = PasteVendIn2OPr(OPp,OP2rw,OPp.TransDate);
              OP2rw.ChequeNr = oprp.ChequeNr;
              OP2rw.PayMode = oprp.PayMode;
              OP2rw.BankCurncy = curncy;
              OP2rw.RecCurncy = curncy;
              OP2rw.PInvCurncy = curncy;
              OP2rw.BankVal = temp;
              OP2rw.PInvVal = temp;
              OP2rw.RecVal = temp;                  
              MatRowInsert(OPp,row1,OP2rw);
              OPVc_PasteRecVal(OPp,row1);
            end;
          end;
        end;
      end else begin
        temp = oprp.RecVal;
        row1 = rownr + 1;
        ClearRow(OPp,OPrw,1);  
        for (i=0;i<row1;i=i+1) begin
          MatRowGet(OPp,i,OPrw);
          cht2 = GetCheck(OPp.PayMode,OPrw.PayMode,checknr2,tstr,tstr,curncy2,checkamount2,td2,regdate);
          if (OPrw.ChequeNr==oprp.ChequeNr) and (cht==cht2) then begin
            if (oprp.RecCurncy==curncy) then begin
              temp = temp - OPrw.RecVal;
            end;
          end;
        end; 
        if (temp>0) then begin        
          MatRowInsert(OPp,row1,OPrw);                 
          temp = oprp.RecVal;        
          if (PasteInvIn2OPr(OPp,rownr,OPp.TransDate,1,temp,tstr,false,instf)) then begin end;
        end;
      end;
      res = true;
    end else begin
      MessageBox(1217,"");
    end;    
  end else begin
    if ((cht>0) and (checknr==-1)) then begin res = false; end;
  end;
  PasteCheckInOP = res;
  RETURN;
END;

global
function Boolean OPVc_PasteChequeNr(var record OPVc OPp,Integer rownr)
BEGIN
  Boolean res;
  row OPVc OPrw;
  
  MatRowGet(OPp,rownr,OPrw);
  if (OPrw.ChequeNr!=-1) then begin
    res = PasteCheckInOP(OPp,rownr,OPrw,OPrw.ChequeNr);
  end;
  MatRowPut(OPp,rownr,OPrw);
  OPSumup(OPp,true);
  OPVc_PasteChequeNr = res;
  RETURN;
END;

procedure PastePOInOPr(var record OPVc OPp,row OPVc oprp,Date tdp)
BEGIN
  record APAccBlock APAccb;
  record RoundBlock RoundRec;
  record CUVc VEr;
  record POVc POr;
  row POVc POrw;
  val rv,rebval;
  val fr,to1,to2,br1,br2;
  val vatval;
  string 2 vatcod;
  string 20 curncycode,thepm,bankcurncy;
  Integer i,rwcnt;
  string 255 objstr;
  string 10 invcur,bankcur,reccur;
  val pinvval,bankval,recval;
  record OPPVc OPPr;
  record INVc INr;
  record SMVc VATr;
  Integer vatcnt;
  
  BlockLoad(RoundRec);  
  BlockLoad(APAccb);  
  POr.SerNr = oprp.PrepayNr;
  curncycode = oprp.PInvCurncy;
  if (ReadFirstMain(POr,1,true)) then begin
    oprp.VECode = POr.VECode;
    oprp.Comment = POr.Addr0;
    VEr.Code = POr.VECode;
    objstr = POr.Objects;
    if (ReadFirstMain(VEr,1,true)) then begin
      oprp.BankAcc = VEr.BankAccount;
    end;
    curncycode = POr.CurncyCode;
    fr = POr.FrRate;
    to1 = POr.ToRateB1;
    to2 = POr.ToRateB2;
    br1 = POr.BaseRate1;
    br2 = POr.BaseRate2;
    oprp.APAcc = GetSupplierOnAccountAC(VEr.Code);
    rwcnt = MatRowCnt(POr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(POr,i,POrw);
      if (POrw.Sum!=0) then begin
        if (blank(vatcod)) then begin
          vatcod = POrw.VATCode;
        end else begin
          if (vatcod!=POrw.VATCode) then begin
            goto L33PastePOInOPr;
          end;
        end;
      end;
    end;
L33PastePOInOPr:;
  end else begin
    VEr.Code = oprp.VECode;
    if (ReadFirstMain(VEr,1,true)) then begin
      vatcod = VEr.VEVATCode;
    end;
    if (blank(vatcod)) then begin
      switch (VEr.ExportFlag) begin
        case 4: vatcod = APAccb.VATCodeExp;
        case 3: vatcod = APAccb.VATCodeEU;
        case 2: vatcod = APAccb.VATCodeExp;
        case 1: vatcod = APAccb.VATCodeEU;
        otherwise vatcod = APAccb.VATCodeDom;
      end;
    end;
    if (APAccb.PreOPBookVAT!=0) then begin
      oprp.VATCode = vatcod;
    end;
    goto LPastePOInOPr;
  end;
  rv = POr.Sum4;
  if (oprp.RecVal>0) then begin
    if (oprp.RecVal<POr.Sum4) then begin  
      rv = oprp.RecVal;
    end;
  end;
  OPPr.SerNr = oprp.PrepayNr;
  if ReadFirstMain(OPPr,1,true) then begin
    if (curncycode==OPPr.CurncyCode) or blank(curncycode) then begin
      curncycode = OPPr.CurncyCode;
      rv = rv - OPPr.PPVal;    
      oprp.VECode = OPPr.VECode;
    end else begin
      oprp.PrepayNr= -1;
    end;
  end else begin
//    goto LPastePOInOPr;
  end;  
  
  if (nonblank(oprp.PayMode)) then begin
    thepm = oprp.PayMode;
  end else begin
    thepm = OPp.PayMode;
  end;
  if (GetPMCurrency(thepm,bankcurncy)) then begin end;
  oprp.BankCurncy = bankcurncy;
  oprp.RecCurncy = curncycode;
  oprp.PInvCurncy = curncycode;
  oprp.PInvVal = rv;
  oprp.RecVal = rv;
/*  
  GetFullCurncyRate(curncycode,OPp.TransDate,fr,to1,to2,br1,br2);
  oprp.FrRateBankVal = fr;
  oprp.ToRateB1BankVal = to1;
  oprp.ToRateB2BankVal = to2;
  oprp.BaseRate1BankVal = br1;
  oprp.BaseRate2BankVal = br2;
*/

  GetFullCurncyRate(curncycode,OPp.TransDate,oprp.FrRateBankVal,oprp.ToRateB1BankVal,oprp.ToRateB2BankVal,oprp.BaseRate1BankVal,oprp.BaseRate2BankVal); 

  if (bankcurncy!=curncycode) then begin
    CurValToOtherCur(OPp.TransDate,curncycode,rv,bankcurncy,rv,DefaultCurRoundOff);
    oprp.BankVal = rv;
   end else begin
    oprp.BankVal = rv;
  end;
  invcur = oprp.PInvCurncy;
  pinvval = oprp.PInvVal;
  bankcur = oprp.BankCurncy;
  bankval = oprp.BankVal;
  reccur = oprp.RecCurncy;
  recval = oprp.RecVal;  
  MatchOPRowSums(OPp.PayMode,oprp.PayMode,OPp.TransDate,invcur,pinvval,bankcur,bankval,reccur,recval,true,true,true);
  oprp.PInvCurncy = invcur;
  oprp.PInvVal = pinvval;
  oprp.BankCurncy = bankcur;
  oprp.BankVal = bankval;
  oprp.RecCurncy = reccur;
  oprp.RecVal = recval;
  oprp.PInvOutstand = blankval;
  if (APAccb.OnAccUseObj!=0) then begin
    oprp.Objects = objstr;
  end;   
  oprp.VATCode = vatcod;
  vatval = POr.Sum3;

  if (APAccb.PreOPBookVAT==kPreOPBookVATTypeVATForDomAndServiceItems) then begin
    if (VEr.ExportFlag==kExportFlagInsideEUPostVAT) or (VEr.ExportFlag==kExportFlagOutsideEUPostVAT) then begin
      RecordClear(VATr);
      SetupVATBase(VATr,vatcnt);          
      rwcnt = MatRowCnt(POr);
      for (i=0;i<rwcnt;i=i+1) begin
       MatRowGet(POr,i,POrw);
        if (nonblank(POrw.ArtCode)) then begin
          ReadFirstItem(POrw.ArtCode,INr,false,true);
          if (INr.ItemType==kItemTypePlain) or (INr.ItemType==kItemTypeService) then begin
            AddVATBase(VATr,POrw.VATCode,POrw.Sum,blankval,vatcnt,POr.InclVAT,POr.NoTAXonVAT);
          end;
        end;
      end;
      CalcVATBaseVAT(VATr,POr.InclVAT,POr.NoTAXonVAT,vatcnt,vatval,rv);
    end;
  end;
  oprp.VATVal = vatval;
LPastePOInOPr:;
  RETURN;
END;

global
procedure OPVc_PastePrepayNr(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  val t,rs;
  
  MatRowGet(OPp,rownr,OPrw);
  PastePOInOPr(OPp,OPrw,OPp.TransDate);
  if (nonblank(OPrw.VATCode)) then begin
    Mul2VAT(OPrw.VATCode,OPrw.PInvVal,t,rs,1);
    OPrw.VATVal = t;
  end else begin
    OPrw.VATVal = blankval;
  end;
  MatRowPut(OPp,rownr,OPrw);
  OPSumup(OPp,true);
  RETURN;
END;

global
procedure OPVc_PasteOrderNr(var record OPVc OPp,Integer rownr)
BEGIN
  row OPVc OPrw;
  
  MatRowGet(OPp,rownr,OPrw);
  OPrw.PrepayNr = OPrw.OrderNr;
  OPrw.OrderNr = OPrw.OrderNr;
  PastePOInOPr(OPp,OPrw,OPp.TransDate);
  MatRowPut(OPp,rownr,OPrw);
  OPSumup(OPp,true);
  RETURN;
END;

function val WHTaxForInvoice(LongInt skipopnr,LongInt vinr,string whtax)
BEGIN
  val res;
  Boolean found,testf;
  record OPrsVc OPrsr;
  record OPVc OPr;
  row OPVc OPrw;
  Integer i,rwcnt;
  
  found = true;
  OPrsr.VINr = vinr;
  OPrsr.TransType = 1;
  while (LoopKey("VIKey",OPrsr,2,found)) begin
    if (OPrsr.TransType!=1) then begin found = false; end;
    if (OPrsr.VINr!=vinr) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (skipopnr>0) then begin
        if (skipopnr==OPrsr.TransNr) then begin testf = false; end;
      end;
      if (testf) then begin
        OPr.SerNr = OPrsr.TransNr;
        if (ReadFirstMain(OPr,1,true)) then begin
          if (OPr.DoneFlag!=0) then begin
            rwcnt = MatRowCnt(OPr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(OPr,i,OPrw);
              if ((OPrw.VISerNr==VINr) and (OPrw.WHTax==whtax)) then begin
                res = res + OPrw.RecVal;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  WHTaxForInvoice = res;
  RETURN;
END;

function val WHTaxForSupplier(record OPVc OPp,string vecode,string whtax)
BEGIN
  val res;
  row OPVc OPrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    if (OPrw.VECode==vecode) then begin
      res = res + WHTaxForInvoice(OPp.SerNr,OPrw.VISerNr,whtax);
    end;
  end;
  WHTaxForSupplier = res;
  RETURN;
END;

function val WHTaxForSupplierInPeriod(Integer periodtype, string vecode,Date td,string whtax)
BEGIN
  val res,t;
  record OPrsVc OPrsr;
  Boolean found;
  Date sd,ed;
  record OPVc OPr;
  row OPVc OPrw;
  Integer i,rwcnt;
  LongInt LastTransNr;
  
  switch (periodtype) begin
    case kWHTaxCalcMonthly:
      sd.year = td.year;
      sd.month = td.month;
      sd.day = 1;
      ed.year = td.year;
      ed.month = td.month;
      ed.day = DaysInMonth(ed.year,ed.month);
    case kWHTaxCalcYearly:
      sd.year = td.year;
      sd.month = 1;
      sd.day = 1;
      ed.year = td.year;
      ed.month = 12;
      ed.day = 31;
  end;    
  found = true;
  OPrsr.TransType = kOPrsTransTypePayment;
  OPrsr.VECode = vecode;
  OPrsr.TransDate = sd;
  while (LoopKey("TransType",OPrsr,3,found)) begin
    if (OPrsr.VECode!=vecode) then begin found = false; end;
    if (OPrsr.TransType!=1) then begin found = false; end;
    if (OPrsr.TransDate>ed) then begin found = false; end;
    if (found) then begin
      if (OPrsr.TransNr!=LastTransNr) then begin
        LastTransNr = OPrsr.TransNr;
        OPr.SerNr = OPrsr.TransNr;
        if (ReadFirstMain(OPr,1,true)) then begin
          if (OPr.DoneFlag!=0) then begin
            rwcnt = MatRowCnt(OPr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(OPr,i,OPrw);
              if (OPrw.VECode==vecode) and (OPrw.WHTax==whtax) then begin
                CurValToOtherCur(OPr.TransDate,OPrw.RecCurncy,OPrw.RecVal,OPrw.BankCurncy,t,DefaultCurRoundOff);
                res = res + t;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  WHTaxForSupplierInPeriod = res;
  RETURN;
END;

procedure SubWHTaxAlreadyPaid(record OPVc OPp,Array Integer areswhtaxcalc,Array string areswhtax,Array string aresvecode,Array LongInt aresvinr,Array val arestaxv,Integer arescnt)
BEGIN
  Integer ai;

  for (ai=0;ai<arescnt;ai=ai+1) begin
    switch (areswhtaxcalc[ai]) begin
      case kWHTaxCalcMonthly://monthly
        arestaxv[ai] = arestaxv[ai] - WHTaxForSupplierInPeriod(kWHTaxCalcMonthly,aresvecode[ai],OPp.TransDate,areswhtax[ai]);
      case kWHTaxCalcYearly://yearly 
        arestaxv[ai] = arestaxv[ai] - WHTaxForSupplierInPeriod(kWHTaxCalcYearly,aresvecode[ai],OPp.TransDate,areswhtax[ai]);
      case kWHTaxCalcPerPayment://per payment
//        arestaxv[ai] = arestaxv[ai] - WHTaxForSupplier(OPp,aresvecode[ai],areswhtax[ai]);
//why to subtract previously calcluated WHtaxes if it is per payment ? 
      case kWHTaxCalcPerInvoice://per Inovice
//        arestaxv[ai] = arestaxv[ai] - WHTaxForInvoice(-1,aresvinr[ai],areswhtax[ai]);
//why to subtract previously calcluated WHtaxes if it is per payment ? 
    end;
  end;
  RETURN;
END;

function Boolean AccountInRange(string acc,string accrange)
BEGIN
  Boolean res;
  string 255 tstr;
  string 10 fracc,toacc;
  Integer pos;
  
  pos = 0;
  ExtractObj(accrange,pos,tstr);
  while (nonblank(tstr)) begin
    fracc = FirstInRange(tstr,10);
    toacc = LastInRange(tstr,10);
    if (acc>=fracc) and (acc<=toacc) then begin
      res = true;
      goto LAccountInRange;
    end;
    ExtractObj(accrange,pos,tstr);
  end;
LAccountInRange:;  
  AccountInRange = res;
  RETURN;
END;

function Boolean WHTaxApplyAccNumberinVI(LongInt VISerNr,string whtaxaccnumbers)
begin
  Boolean res;
  Integer i,rwcnt;
  record VIVc VIr;
  row VIVc VIrw;
  
  VIr.SerNr = VISerNr;
  if (ReadFirstMain(VIr,1,true)) then begin
    rwcnt = MatRowCnt(VIr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(VIr,i,VIrw);
      if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
      if (AccountInRange(VIrw.AccNumber,whtaxaccnumbers)) then begin
        res = true;
        goto LWHTaxApplyAccNumberinVI;
      end;
      end;
    end;
  end;
LWHTaxApplyAccNumberinVI:;  
  WHTaxApplyAccNumberinVI = res;
  return;
end;

function val ThisInvoiceDeductCreditNotes(LongInt VISerNr,string whtax,string accnumbers,var val vinetval,var val vivatval,var val viextaxval,var val vipayval,vector val vvibasev)
BEGIN
  val res;
  record OPrsVc OPrsr;
  Boolean found;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  val vatv,t1,tmp;
  
  found = true;
  OPrsr.VINr = VISerNr;
  OPrsr.TransType = 0;
  while (LoopKey("VIKey",OPrsr,2,found)) begin
    if (OPrsr.VINr!=VISerNr) then begin found = false; end;
    if (OPrsr.TransType!=0) then begin found = false; end;
    if (found) then begin
      VIr.SerNr = OPrsr.TransNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
              if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                tmp =  VIrw.Sum;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                    
                vvibasev[VISerNr & ":net:" & whtax] = vvibasev[VISerNr & ":net:" & whtax] - tmp;
                vinetval = vinetval - tmp;
                MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
                if (VIrw.VATVal!=0) then begin
                  vatv = VIrw.VATVal;
                end;
                tmp = vatv;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                    
                vvibasev[VISerNr & ":vat:" & whtax] = vvibasev[VISerNr & ":vat:" & whtax] - tmp;
                vivatval = vivatval - tmp;
                tmp = t1;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                    
                viextaxval = viextaxval - t1;
              end;
            end;
          end;
          tmp = VIr.PayVal;
          tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                    
          vvibasev[VISerNr & ":pay:" & whtax] = vvibasev[VISerNr & ":pay:" & whtax] - tmp;
          vipayval = vipayval - tmp;
          res = res + tmp;
        end;
      end;
    end;
  end;
  ThisInvoiceDeductCreditNotes = res;
  RETURN;
END;


function val ThisInvoiceDeductCreditNotesFromRowSum(LongInt VISerNr,string accnumbers)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean found;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  
  found = true;
  OPrsr.VINr = VISerNr;
  OPrsr.TransType = 0;
  while (LoopKey("VIKey",OPrsr,2,found)) begin
    if (OPrsr.VINr!=VISerNr) then begin found = false; end;
    if (OPrsr.TransType!=0) then begin found = false; end;
    if (found) then begin
      VIr.SerNr = OPrsr.TransNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
              if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                res = res + VIrw.Sum;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  ThisInvoiceDeductCreditNotesFromRowSum = res;
  return;
end;

function val ThisInvoiceDeductCreditNotesFromTotal(LongInt VISerNr,vector val vcrednotesaccamounts)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean found;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  
  found = true;
  OPrsr.VINr = VISerNr;
  OPrsr.TransType = 0;
  while (LoopKey("VIKey",OPrsr,2,found)) begin
    if (OPrsr.VINr!=VISerNr) then begin found = false; end;
    if (OPrsr.TransType!=0) then begin found = false; end;
    if (found) then begin
      VIr.SerNr = OPrsr.TransNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          res = res + VIr.PayVal;
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
              vcrednotesaccamounts[VIrw.AccNumber] = vcrednotesaccamounts[VIrw.AccNumber] + VIrw.Sum;
            end;
          end;
        end;
      end;
    end;
  end;
  ThisInvoiceDeductCreditNotesFromTotal = res;
  return;
end;

procedure ThisInvoiceAmounts(LongInt VISerNr,string whtax,string accnumbers,var val vinetval,var val vivatval,var val viextaxval,var val vipayval,var val vicreval,
                             var val viapval,vector val vvibasev)
BEGIN
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  val vatv,t1,tmp,tmp2;
  record APVc APr;
  vector val vcrednotesaccamounts;
  
  vinetval = blankval;
  vivatval = blankval;
  viextaxval = blankval;
  viapval = blankval;
  
  VIr.SerNr = VISerNr;
  if (ReadFirstMain(VIr,1,true)) then begin    
    vicreval = ThisInvoiceDeductCreditNotesFromTotal(VIr.SerNr,vcrednotesaccamounts);
    VIr.PayVal = VIr.PayVal - vicreval;
    APr.SerNr = VISerNr;
    ReadFirstMain(APr,1,true);
    rwcnt = MatRowCnt(VIr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(VIr,i,VIrw);
      switch (VIrw.stp) begin
        case kInvoiceRowTypePrepayment:
        otherwise
          if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
            if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
//              VIrw.Sum = VIrw.Sum - ThisInvoiceDeductCreditNotesFromRowSum(VIr.SerNr,VIrw.AccNumber);
              VIrw.Sum = VIrw.Sum - vcrednotesaccamounts[VIrw.AccNumber];
              if (VIrw.Sum!=0) then begin
                tmp =  VIrw.Sum;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
                tmp2 = (tmp*APr.RVal)/VIr.PayVal;
                vvibasev[VISerNr & ":net:" & whtax] = vvibasev[VISerNr & ":net:" & whtax] + tmp2;
                vinetval = vinetval + tmp;        
                MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
              
                if (VIrw.VATVal!=0) then begin
                  vatv = VIrw.VATVal;
                end;
                tmp =  vatv;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                            
                tmp2 = (tmp*APr.RVal)/VIr.PayVal;
                vvibasev[VISerNr & ":vat:" & whtax] = vvibasev[VISerNr & ":vat:" & whtax] + tmp2;
                vivatval = vivatval + tmp;
                tmp =  t1;
                tmp = MulRateToBase1(VIr.CurncyCode,tmp,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                            
                tmp2 = (tmp*APr.RVal)/VIr.PayVal;
                vvibasev[VISerNr & ":pay:" & whtax] = vvibasev[VISerNr & ":pay:" & whtax] + tmp2;
                viextaxval = viextaxval + tmp;
              end;
            end;
          end;
      end;
    end;
    vipayval = MulRateToBase1(VIr.CurncyCode,VIr.PayVal,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);                            
//    vicreval = ThisInvoiceDeductCreditNotes(VISerNr,whtax,accnumbers,vinetval,vivatval,viextaxval,vipayval,vvibasev);
    viapval = MulRateToBase1(VIr.CurncyCode,APr.RVal,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
  end;
  return;
end;

function val ThisInvoicePaymentAmount(LongInt VISerNr,record OPVc OPp)
begin
  record VIVc VIr;
  val res;
  row OPVc OPrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    if (OPrw.VISerNr==VISerNr) then begin
      VIr.SerNr = VISerNr;
      if (ReadFirstMain(VIr,1,true)) then begin 
        res = res + MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,OPrw.PInvVal,DefaultCurRoundOff);
      end;
    end;
  end;
  ThisInvoicePaymentAmount = res;
  return;
end;

global
function Boolean GetWHTaxRow(string whtax,var row WHTaxBlock WHTaxrw)
begin
  Boolean res;
  Integer i,rwcnt;
  record WHTaxBlock WHTaxRec;
  
  ClearRow(WHTaxRec,WHTaxrw,1);
  res = true;
  BlockLoad(WHTaxRec);
  rwcnt = MatRowCnt(WHTaxRec);
  for (i=0 ;i<rwcnt;i=i+1) begin
    MatRowGet(WHTaxRec,i,WHTaxrw);
    if (WHTaxrw.Code==whtax) then begin
      goto LGetWHTaxRow;
    end;
  end;
  res = false;
LGetWHTaxRow:;
  GetWHTaxRow = res;
  RETURN;
END;

global
function Boolean GetWHTaxRowNr(string whtax,var row WHTaxBlock WHTaxrw,var integer rownr)
BEGIN
  Boolean res;
  Integer i,rwcnt;
  record WHTaxBlock WHTaxRec;
  
  ClearRow(WHTaxRec,WHTaxrw,1);
  res = true;
  rownr = -1;
  BlockLoad(WHTaxRec);
  rwcnt = MatRowCnt(WHTaxRec);
  for (i=0 ;i<rwcnt;i=i+1) begin
    MatRowGet(WHTaxRec,i,WHTaxrw);
    if (WHTaxrw.Code==whtax) then begin
      rownr = i;
      goto LGetWHTaxRowNr;
    end;
  end;
  res = false;
LGetWHTaxRowNr:;
  GetWHTaxRowNr = res;
  RETURN;
END;

procedure ThisInvoiceCreditNotesAmount(Integer TaxCalc,Date optransdate,string region,LongInt VISerNr,string vecode,string accnumbers,string whtax,var val totcred,var val vicnnetaccnumbers,var val vicnvataccnumbers)
begin
  record VIVc credVIr;
  Boolean found;
  Integer vi,virwcnt;
  row VIVc VIrw;
  val vatv,t1;
  
  vicnnetaccnumbers = blankval;
  vicnvataccnumbers = blankval;
  totcred = blankval;
  if (VISerNr>0) then begin
    found = true;
  end;
  credVIr.CredInv = VISerNr;
  while (LoopKey("CredInv",credVIr,1,found)) begin
    if (credVIr.CredInv!=VISerNr) then begin found = false; end;
    if (found) and (credVIr.OKFlag==1) then begin
      totcred = totcred + credVIr.PayVal;
      virwcnt = MatRowCnt(credVIr);
      for (vi=0;vi<virwcnt;vi=vi+1) begin
        MatRowGet(credVIr,vi,VIrw);
        if (CheckVERegion(whtax,region,vecode,optransdate)) then begin 
          if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
            if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
              vicnnetaccnumbers = vicnnetaccnumbers + VIrw.Sum;
              MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,credVIr.NoTAXonVAT);
              if (VIrw.VATVal!=0) then begin vatv = VIrw.VATVal; end;
              vicnvataccnumbers = vicnvataccnumbers + vatv;
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;


procedure ThisSupplierPaymentAmount(record WHCalcFormVc WHCalcFormr,LongInt VISerNr,string whtax,string vecode,record OPVc OPp,string accnumbers,var val vivatval,var val vipayval,var val vinetval,vector val vvibasev,Boolean vvibasef,var integer errmess)
BEGIN
  row OPVc OPrw;
  Integer i,rwcnt;
  record VIVc VIr;
  row VIVc VIrw;
  Integer vi,virwcnt;
  val vivat,vatv,t1,tmp;
  Boolean test;
  val vinetaccnumbers,vivataccnumbers,vipayaccnumbers;
  val vicnnetaccnumbers,vicnvataccnumbers,vicnpayaccnumbers,vicred;
  record APVc APr;
  Integer TaxCalc;
  val rowsum,rowvat,finalpayval;
  val invoicebase;

  TaxCalc = WHCalcFormr.TaxCalc;
  //errmess = 1;  
  rwcnt = MatRowCnt(OPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,OPrw);
    if (OPrw.VECode==vecode) and (blank(OPrw.WHTax)) then begin
      VIr.SerNr = OPrw.VISerNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        APr.SerNr = VIr.SerNr;
        ReadFirstMain(APr,1,true);
        virwcnt = MatRowCnt(VIr);
        switch (TaxCalc) begin
          case kWHTaxCalcYearly:
            goto LThisSupplierPaymentAmountMonthly;
          case kWHTaxCalcMonthly:
LThisSupplierPaymentAmountMonthly:;
            vinetaccnumbers = blankval;
            for (vi=0;vi<virwcnt;vi=vi+1) begin
              MatRowGet(VIr,vi,VIrw);
              if (VIrw.stp==kInvoiceRowTypeNormal) then begin
                if (CheckVERegion(whtax,VIr.Region,vecode,OPp.TransDate)) then begin 
                  if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
                    if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                      if (VISerNr<0) or (VISerNr==VIr.SerNr) then begin
                        test = true;
                        vinetaccnumbers = vinetaccnumbers + VIrw.Sum;
                        MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
                        vivataccnumbers = vivataccnumbers + vatv;  
                      end;
                    end;
                  end;
                end;
              end;
            end;
            ThisInvoiceCreditNotesAmount(TaxCalc,OPp.TransDate,VIr.Region,VIr.SerNr,vecode,accnumbers,whtax,vicred,vicnnetaccnumbers,vicnvataccnumbers);
            vinetaccnumbers = vinetaccnumbers - vicnnetaccnumbers;
            vinetaccnumbers = (OPrw.PInvVal*vinetaccnumbers)/(VIr.PayVal-vicred); // APr.RVal;
            vinetaccnumbers = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,vinetaccnumbers,DefaultCurRoundOff);
            vvibasev[OPrw.VISerNr & "row" & i & ":base:" & whtax ] = vinetaccnumbers;
            vinetval = vinetval + vinetaccnumbers;
            vipayval = vipayval + vinetaccnumbers;
            if (vvibasef) then begin
              vvibasev[OPrw.VISerNr & ":net:" & whtax] = vvibasev[OPrw.VISerNr & ":net:" & whtax] + vinetaccnumbers;
              vvibasev[OPrw.VISerNr & ":pay:" & whtax] = vvibasev[OPrw.VISerNr & ":pay:" & whtax] + vinetaccnumbers;
            end;
            
            vivataccnumbers = vivataccnumbers - vicnvataccnumbers;
            vivataccnumbers = (OPrw.PInvVal*vivataccnumbers)/(VIr.PayVal-vicred); // APr.RVal;
            vivataccnumbers = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,vivataccnumbers,DefaultCurRoundOff);
            if (vvibasef) then begin
              vivatval = vivatval + vivataccnumbers;
              vvibasev[OPrw.VISerNr & ":vat:" & whtax] = vvibasev[OPrw.VISerNr & ":vat:" & whtax] + vivataccnumbers;
              vvibasev[OPrw.VISerNr & "row" & i & ":vatbase:" & whtax] = vinetaccnumbers;
            end;
          case kWHTaxCalcPerInvoice: 
            for (vi=0;vi<virwcnt;vi=vi+1) begin
              MatRowGet(VIr,vi,VIrw);
              if (CheckVERegion(whtax,VIr.Region,vecode,OPp.TransDate)) then begin 
                if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
                  if (VIHasWHTaxAccNumber(VIr.SerNr,accnumbers)) then begin
                    if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                      if (VISerNr<0) or (VISerNr==VIr.SerNr) then begin
                        test = true;
                        tmp = (VIrw.Sum*OPrw.PInvVal)/VIr.PayVal;
                        tmp = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,tmp,DefaultCurRoundOff);
                        if (vvibasef) then begin
                          vvibasev[OPrw.VISerNr & ":net:" & whtax] = vvibasev[OPrw.VISerNr & ":net:" & whtax] + tmp;
                          vvibasev[OPrw.VISerNr & "row" & i & ":base:" & whtax ] = tmp;
                        end;
                        vinetval = vinetval + tmp;
                        MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
                        if (VIrw.VATVal!=0) then begin
                          vatv = VIrw.VATVal;
                        end;
                        tmp = (vatv*OPrw.PInvVal)/VIr.PayVal;
                        tmp = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,tmp,DefaultCurRoundOff);
                        if (vvibasef) then begin
                          vvibasev[OPrw.VISerNr & ":vat:" & whtax] = vvibasev[OPrw.VISerNr & ":vat:" & whtax] + tmp;
                          vvibasev[OPrw.VISerNr & "row" & i & ":vatbase:" & whtax ] = tmp;
                        end;
                        vivatval = vivatval + tmp;
    //                  viextaxval = viextaxval + (t1*OPrw.PInvVal)/VIr.PayVal;              
                        tmp = (VIrw.Sum*OPrw.PInvVal)/VIr.PayVal;
                        tmp = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,tmp,DefaultCurRoundOff);
                        if (vvibasef) then begin
                          vvibasev[OPrw.VISerNr & ":pay:" & whtax] = vvibasev[OPrw.VISerNr & ":pay:" & whtax] + tmp;
                        end;
                        vipayval = vipayval + tmp;
                      end;
                    end else begin
                      errmess = 28701;
                    end;
                  end;
                end;
              end;
            end;
          case kWHTaxCalcPerPayment:
            rowsum = 0;
            rowvat = 0;
            for (vi=0;vi<virwcnt;vi=vi+1) begin
              MatRowGet(VIr,vi,VIrw);
              if (CheckVERegion(whtax,VIr.Region,vecode,OPp.TransDate)) then begin 
                if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
                  if (VIHasWHTaxAccNumber(VIr.SerNr,accnumbers)) then begin
                    if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                      if (VISerNr<0) or (VISerNr==VIr.SerNr) then begin
                        rowsum = rowsum + VIrw.Sum;
                        MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
                        if (VIrw.VATVal!=0) then begin
                          vatv = VIrw.VATVal;
                        end;
                        rowvat = rowvat + vatv;
                        test = true;
                      end;
                    end else begin
                      errmess = 28701;
                    end;
                  end;
                end;
              end;
            end;
            if (test) and (rowsum!=0) then begin
              ThisInvoiceCreditNotesAmount(TaxCalc,OPp.TransDate,VIr.Region,VIr.SerNr,vecode,accnumbers,whtax,vicred,vicnnetaccnumbers,vicnvataccnumbers);
              finalpayval = VIr.PayVal - vicred;
              rowsum = rowsum - vicnnetaccnumbers;
              tmp = (rowsum*OPrw.PInvVal)/finalpayval;
              tmp = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,tmp,DefaultCurRoundOff);
              if (vvibasef) then begin
                vvibasev[OPrw.VISerNr & ":net:" & whtax] = vvibasev[OPrw.VISerNr & ":net:" & whtax] + tmp;
              end;
              vinetval = vinetval + tmp;
              vipayval = vipayval + tmp;
              tmp = (rowvat*OPrw.PInvVal)/finalpayval;
              tmp = MulWithRateToBase1(VIr.CurncyCode,OPp.TransDate,tmp,DefaultCurRoundOff);
              if (vvibasef) then begin
                vvibasev[OPrw.VISerNr & ":vat:" & whtax] = vvibasev[OPrw.VISerNr & ":vat:" & whtax] + tmp;
                vvibasev[OPrw.VISerNr & ":pay:" & whtax] = vvibasev[OPrw.VISerNr & ":pay:" & whtax] + tmp;
              end;
              vivatval = vivatval + tmp;
            end;
        end;
      end;
    end;
  end;
  if (test) then begin 
    errmess = 0;
  end;
  RETURN;
END;

function Boolean VIHasWHTaxAccNumber(LongInt VISerNr,string accnumbers)
begin
  Boolean res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  
  res = false;
  VIr.SerNr = VISerNr;
  if (ReadFirstMain(VIr,1,true)==false) then begin goto LVIHasWHTaxAccNumber; end;
  
  rwcnt = MatRowCnt(VIr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(VIr,i,VIrw);
    if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
      if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
        res = true;
        goto LVIHasWHTaxAccNumber;
      end;
    end;
  end;
  
LVIHasWHTaxAccNumber:;
  VIHasWHTaxAccNumber = res;
end;

procedure AddWHTaxToPayment(record BaseCurBlock BCb,var record OPVc OPp,Array Integer areswhtaxcalc,
                            Array string areswhtax,Array string areswhtaxaccnumbers,Array string aresvecode,Array LongInt aresvinr,Array val arestaxv,
                            Array val aresbasev,Array val areswhtaxprc,Array Integer arownr,Integer arescnt,vector val vvibasev,var Integer errmess)
BEGIN
  row OPVc baseOPrw;
  row OPVc taxOPrw;
  Integer ai;
  Integer i,rwcnt,rownr;
  val supptot;
  val tax,base,firstrestaxv;
  vector Boolean whtaxaccnum;
  val vinetval,vivatval,viextaxval,vipayval,vicreval,viapval,startrestaxv;
  val PInvVal,basetotv,tax1,temp;
  row WHTaxBlock WHTaxrw;
  record WHCalcFormVc WHCalcFormr;
  array val paymenttax;
    
  //errmess = 0;  
  rwcnt = MatRowCnt(OPp);
  for (ai=0;ai<arescnt;ai=ai+1) begin
    switch (areswhtaxcalc[ai]) begin
      case kWHTaxCalcYearly: 
         goto LCalcMonthly;
      case kWHTaxCalcMonthly: 
 LCalcMonthly:;
        if (arestaxv[ai]!=0) then begin
          GetWHTaxRow(areswhtax[ai],WHTaxrw);
          WHCalcFormr.PayCode = WHTaxrw.WHCalcForm;
          if (ReadFirstMain(WHCalcFormr,1,true)) then begin 
            if (arestaxv[ai]>=WHCalcFormr.MinAmount and whtaxaccnum[areswhtax[ai]]==false) then begin 
              startrestaxv = arestaxv[ai];
              basetotv = 0;
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(OPp,i,baseOPrw);
                if (baseOPrw.VECode==aresvecode[ai] and arestaxv[ai]!=0 and VIHasWHTaxAccNumber(baseOPrw.VISerNr,areswhtaxaccnumbers[ai])) then begin
                  basetotv = basetotv + baseOPrw.PInvVal;
                end;
              end;
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(OPp,i,baseOPrw);
                if  (baseOPrw.VECode==aresvecode[ai]) and (arestaxv[ai]!=0) then begin
                  if (WHTaxApplyAccNumberinVI(baseOPrw.VISerNr,areswhtaxaccnumbers[ai])) then begin

                    ClearRow(OPp,taxOPrw,1);
                    CopyRow(OPp,baseOPrw,taxOPrw);     
                    CurValToOtherCur(OPp.TransDate,BCb.BaseCur1,startrestaxv,baseOPrw.PInvCurncy,startrestaxv,DefaultCurRoundOff);
                    taxOPrw.RecVal = (startrestaxv*taxOPrw.RecVal)/basetotv;
                    if (taxOPrw.RecVal>baseOPrw.PInvVal) then begin 
                      taxOPrw.RecVal = baseOPrw.PInvVal;
                    end;
                    if (taxOPrw.RecVal!=0) then begin
                      arestaxv[ai] = arestaxv[ai] - MulWithRateToBase1(taxOPrw.RecCurncy,OPp.TransDate,taxOPrw.RecVal,DefaultCurRoundOff)/basetotv;              
                      taxOPrw.WHTax = areswhtax[ai];
                      if (WHCalcFormr.BaseCalcVAT!=0) then begin 
                        //taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & ":vat:" & taxOPrw.WHTax]; 
//not wrking                        taxOPrw.WHTaxAccumBase = vvibasev[taxOPrw.VISerNr & ":vat:" & taxOPrw.WHTax]; 
                        taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & "row" & i & ":vatbase:" & taxOPrw.WHTax]; 
                      end;
                      if (WHCalcFormr.BaseCalcNet!=0) then begin 
                        //taxOPrw.WHTaxBase = taxOPrw.WHTaxBase + vvibasev[taxOPrw.VISerNr & ":net:" & taxOPrw.WHTax]; 
//not wrking                        taxOPrw.WHTaxAccumBase = vvibasev[taxOPrw.VISerNr & ":net:" & taxOPrw.WHTax]; 
                        taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & "row" & i & ":base:" & taxOPrw.WHTax]; 
                      end;
                      taxOPrw.WHTaxPrc = areswhtaxprc[ai];
                      taxOPrw.PayMode = WHTaxrw.PayMode;
                      rownr = MatRowCnt(OPp);
                      ChangeOPRecVal(rownr,taxOPrw,OPp.TransDate);          
                      MatRowInsert(OPp,rownr,taxOPrw);            
                      // baseOPrw.RecVal = baseOPrw.RecVal - taxOPrw.RecVal;
                      paymenttax[i] = paymenttax[i] + taxOPrw.RecVal;
                      whtaxaccnum[areswhtax[ai]] = true;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      case kWHTaxCalcPerPayment: 
        if (arestaxv[ai]>0) then begin
          supptot = 0;
          firstrestaxv = 0;
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(OPp,i,baseOPrw);
            if (baseOPrw.VECode==aresvecode[ai]) then begin
              if (WHTaxApplyAccNumberinVI(baseOPrw.VISerNr,areswhtaxaccnumbers[ai])) then begin
                supptot = supptot + baseOPrw.PInvVal;
                whtaxaccnum[baseOPrw.VISerNr] = true;
              end;
            end;
          end;
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(OPp,i,baseOPrw);
            if (i==arownr[ai]) and (baseOPrw.VECode==aresvecode[ai]) and (arestaxv[ai]>0) and (whtaxaccnum[baseOPrw.VISerNr]==true) then begin
              ClearRow(OPp,taxOPrw,1);              
              CopyRow(OPp,baseOPrw,taxOPrw);
              if (firstrestaxv==0) then begin
                firstrestaxv = arestaxv[ai];
                CurValToOtherCur(OPp.TransDate,BCb.BaseCur1,arestaxv[ai],baseOPrw.RecCurncy,firstrestaxv,DefaultCurRoundOff);
              end;
              base = aresbasev[ai];
              GetWHTaxRow(areswhtax[ai],WHTaxrw);
              WHCalcFormr.PayCode = WHTaxrw.WHCalcForm;
              if (ReadFirstMain(WHCalcFormr,1,true)) then begin
                switch (WHCalcFormr.TaxCalc) begin
                  case kWHTaxCalcPerPayment: 
                    vipayval = blankval; vivatval = blankval; vinetval = blankval;
                    ThisSupplierPaymentAmount(WHCalcFormr,baseOPrw.VISerNr,areswhtax[ai],baseOPrw.VECode,OPp,WHTaxrw.AccNumbers,vivatval,vipayval,vinetval,vvibasev,false,errmess);
                    PInvVal = vipayval - viapval - vicreval;
                    tax = (firstrestaxv*PInvVal)/aresbasev[ai];
                    base = (base*PInvVal)/aresbasev[ai];
                  otherwise
                    tax = (firstrestaxv*baseOPrw.PInvVal)/supptot;
                    base = (base*baseOPrw.PInvVal)/supptot;
                end;
              end else begin
                tax = (firstrestaxv*baseOPrw.PInvVal)/supptot;
                base = (base*baseOPrw.PInvVal)/supptot;
              end;
              if (tax<=baseOPrw.PInvVal) then begin
                taxOPrw.RecVal = tax;
              end else begin
                taxOPrw.RecVal = baseOPrw.PInvVal;
              end;
              if (taxOPrw.RecVal!=0) then begin
                arestaxv[ai] = arestaxv[ai] - taxOPrw.RecVal;
                taxOPrw.WHTax = areswhtax[ai];
                GetWHTaxRow(taxOPrw.WHTax,WHTaxrw);
                WHCalcFormr.PayCode = WHTaxrw.WHCalcForm;
                ReadFirstMain(WHCalcFormr,1,true);
                if (WHCalcFormr.BaseCalcVAT!=0) then begin taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & ":vat:" & taxOPrw.WHTax]; end;
                if (WHCalcFormr.BaseCalcNet!=0) then begin 
                // taxOPrw.WHTaxBase = taxOPrw.WHTaxBase + vvibasev[taxOPrw.VISerNr & ":net:" & taxOPrw.WHTax]; end;
                  taxOPrw.WHTaxBase = base;
                end;  
                taxOPrw.WHTaxPrc = areswhtaxprc[ai];
                taxOPrw.PayMode = WHTaxrw.PayMode;
                rownr = MatRowCnt(OPp);
                ChangeOPRecVal(rownr,taxOPrw,OPp.TransDate);          
                MatRowInsert(OPp,rownr,taxOPrw);            
                // baseOPrw.RecVal = baseOPrw.RecVal - taxOPrw.RecVal;
                paymenttax[i] = paymenttax[i] + taxOPrw.RecVal;
              end;
            end;
          end;
        end;
      case kWHTaxCalcPerInvoice: 
        if (arestaxv[ai]>0) then begin
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(OPp,i,baseOPrw);
            if (baseOPrw.VISerNr==aresvinr[ai]) and (arestaxv[ai]>0) then begin
              ClearRow(OPp,taxOPrw,1);
              CopyRow(OPp,baseOPrw,taxOPrw);
              //if (arestaxv[ai]<=baseOPrw.PInvVal) then begin
                taxOPrw.RecVal = arestaxv[ai];
             // end else begin
              //  taxOPrw.RecVal = baseOPrw.PInvVal;
            //  end;
              if (taxOPrw.RecVal!=0) then begin
                GetWHTaxRow(areswhtax[ai],WHTaxrw);
                arestaxv[ai] = arestaxv[ai] - taxOPrw.RecVal;
                taxOPrw.WHTax = areswhtax[ai];
                WHCalcFormr.PayCode = WHTaxrw.WHCalcForm;
                ReadFirstMain(WHCalcFormr,1,true);
                if (WHCalcFormr.BaseCalcVAT!=0) then begin 
                  taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & ":vat:" & areswhtax[ai]];
                end;
                if (WHCalcFormr.BaseCalcNet!=0) then begin 
                  taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & ":net:"  & areswhtax[ai]];
                end;
/*                
                if (WHCalcFormr.BaseCalcVAT!=0) then begin 
                  taxOPrw.WHTaxBase = vvibasev[taxOPrw.VISerNr & ":vat:" & areswhtax[ai]];
//not wrking                  taxOPrw.WHTaxAccumBase = vvibasev[taxOPrw.VISerNr & ":accumbase:vat:" & areswhtax[ai]];
                 //taxOPrw.WHTaxBase =  vvibasev[taxOPrw.VISerNr & "row" & i & ":vatbase:"  & areswhtax[ai]];
                end;
                if (WHCalcFormr.BaseCalcNet!=0) then begin 
                  taxOPrw.WHTaxBase =  vvibasev[taxOPrw.VISerNr & "row" & i & ":net:"  & areswhtax[ai]];
//not wrking                  taxOPrw.WHTaxAccumBase = taxOPrw.WHTaxBase + vvibasev[taxOPrw.VISerNr & ":accumbase:net:" & areswhtax[ai]]; 
                end;
*/                
//here taxOPrw.RecVal is still in base 1
                CurValToOtherCur(OPp.TransDate,BCb.BaseCur1,taxOPrw.RecVal,taxOPrw.RecCurncy,taxOPrw.RecVal,DefaultCurRoundOff);
//                taxOPrw.WHTaxBase = (taxOPrw.WHTaxBase*taxOPrw.RecVal)/startrestaxv;
//                taxOPrw.WHTaxBase = aresbasev[ai];
                taxOPrw.WHTaxPrc = areswhtaxprc[ai];
                taxOPrw.PayMode = WHTaxrw.PayMode;
                rownr = MatRowCnt(OPp);
                ChangeOPRecVal(rownr,taxOPrw,OPp.TransDate);          
                MatRowInsert(OPp,rownr,taxOPrw);
                //baseOPrw.RecVal = baseOPrw.RecVal - taxOPrw.RecVal;
                paymenttax[i] = paymenttax[i] + taxOPrw.RecVal;
                if (baseOPrw.RecVal!=0) then begin
//                  MatRowDelete(OPp,i);
                end else begin
                  ChangeOPRecVal(i,baseOPrw,OPp.TransDate);
                end;
                MatRowPut(OPp,i,baseOPrw);
              end;
            end;
          end;
        end;
    end;    
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OPp,i,baseOPrw);
    baseOPrw.RecVal = baseOPrw.RecVal - paymenttax[i];
    if (baseOPrw.RecVal==0) then begin
      MatRowDelete(OPp,i);
    end else begin
      ChangeOPRecVal(i,baseOPrw,OPp.TransDate);          
      MatRowPut(OPp,i,baseOPrw);
    end;
  end;    
  RETURN;
END;


procedure ThisSupplierPeriodInvoicesAmounts(string whtax,integer periodtype,row OPVc baseOPrw,Date td,string AccNumbers,var val vinetval,var val vivatval,var val viextaxval,var val vipayval,
                                           var val vicreval,var val viapval,vector val vvibasev)
BEGIN
  record OPrsVc OPrsr;
  Boolean found,whtahcalcf;
  Date sd,ed;
  record OPVc OPr;
  row OPVc OPrw;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Integer opi,oprwcnt;
  val vatv,t1;
  record APVc APr;
  val vivat,tmp,PInvVal;
  val vivataccnumbers,vinetaccnumbers,vicred,vicnnetaccnumbers,vicnvataccnumbers,vitv,t;

  switch (periodtype) begin
    case kWHTaxCalcMonthly:
      sd.year = td.year;
      sd.month = td.month;
      sd.day = 1;
      ed.year = td.year;
      ed.month = td.month;
      ed.day = DaysInMonth(ed.year,ed.month);
    case kWHTaxCalcYearly:
      sd.year = td.year;
      sd.month = 1;
      sd.day = 1;
      ed.year = td.year;
      ed.month = 12;
      ed.day = 31;
  end;
    
  vinetval = blankval;
  vivatval = blankval;
  viextaxval = blankval;
  viapval = blankval;
  vicreval = blankval;
  vipayval = blankval;
  found = true;
  OPrsr.TransType = 1;
  OPrsr.VECode = baseOPrw.VECode;
  OPrsr.TransDate = sd;
  while (LoopKey("TransType",OPrsr,3,found)) begin
    if (OPrsr.VECode!=baseOPrw.VECode) then begin found = false; end;
    if (OPrsr.TransType!=1) then begin found = false; end;
    if (OPrsr.TransDate>ed) then begin found = false; end;
    if (found) then begin
      if (DateInRange(OPrsr.TransDate,sd,ed)) then begin
        OPr.SerNr = OPrsr.TransNr;
        if (ReadFirstMain(OPr,1,true)) then begin
          if (OPr.DoneFlag!=0) then begin
            oprwcnt = MatRowCnt(OPr);
            for (opi=0;opi<oprwcnt;opi=opi+1) begin
              MatRowGet(OPr,opi,OPrw);
              if (OPrw.VISerNr==OPrsr.VINr) then begin
                  VIr.SerNr = OPrw.VISerNr;
                  vinetaccnumbers = blankval;
                  if (ReadFirstMain(VIr,1,true)) then begin
                    if (VIr.VECode==OPrsr.VECode) then begin
                      if (VIr.InvType!=kInvoiceTypeCredit or VIr.InvType!=kInvoiceTypeCreditSpecialSales) then begin//credit note without number?
                        rwcnt = MatRowCnt(VIr);
                        for (i=0;i<rwcnt;i=i+1) begin
                          MatRowGet(VIr,i,VIrw);
                          if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
                            if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
                              vinetaccnumbers = vinetaccnumbers + VIrw.Sum;
                              MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
                              vivataccnumbers = vivataccnumbers + vatv; 
                            end; 
                          end;
                        end;
                        ThisInvoiceCreditNotesAmount(periodtype,OPr.TransDate,VIr.Region,VIr.SerNr,baseOPrw.VECode,accnumbers,whtax,vicred,vicnnetaccnumbers,vicnvataccnumbers);
                        vinetaccnumbers = vinetaccnumbers - vicnnetaccnumbers;
//LogText(0," vicnnetaccnumbers VIr.SerNr " & VIr.SerNr & "//" &  vicnnetaccnumbers);
//LogText(0,"(OPrw.PInvVal*vinetaccnumbers)/(VIr.PayVal-vicred) " & VIr.SerNr & "//" &  "(" & OPrw.PInvVal & "*" & vinetaccnumbers & ")/(" & VIr.PayVal & "-" & vicred & ")");
                        vinetaccnumbers = (OPrw.PInvVal*vinetaccnumbers)/(VIr.PayVal-vicred); // APr.RVal;
//LogText(0,"result= " &  vinetaccnumbers);
                        vinetaccnumbers = MulWithRateToBase1(VIr.CurncyCode,OPr.TransDate,vinetaccnumbers,DefaultCurRoundOff);
                        vinetval = vinetval + vinetaccnumbers;
//LogText(0,"accumulated  " & vinetval);
                        vipayval = vipayval + vinetaccnumbers;
                        //if (vvibasef) then begin
                          vvibasev[OPrw.VISerNr & ":net:" & whtax] = vvibasev[OPrw.VISerNr & ":net:" & whtax] + vinetaccnumbers;
                          vvibasev[OPrw.VISerNr & ":pay:" & whtax] = vvibasev[OPrw.VISerNr & ":pay:" & whtax] + vinetaccnumbers;
                        //end;
                        vivataccnumbers = vivataccnumbers - vicnvataccnumbers;
                        vivataccnumbers = (OPrw.PInvVal*vivataccnumbers)/(VIr.PayVal-vicred); // APr.RVal;
                        vivataccnumbers = MulWithRateToBase1(VIr.CurncyCode,OPr.TransDate,vivataccnumbers,DefaultCurRoundOff);
                        vivatval = vivatval + vivataccnumbers;
                        //if (vvibasef) then begin
                          vvibasev[OPrw.VISerNr & ":vat:" & whtax] = vvibasev[OPrw.VISerNr & ":vat:" & whtax] + vivataccnumbers;
                        //end;
                      end;
                    end;
                  end;
                end;
            end;
          end;
        end;
      end;
    end;
  end;

  RETURN;
END;

procedure ThisSupplierInvoicesAmounts(record OPVc OPp,string whtax,string vecode,string accnumbers,var val vinetval,var val vivatval,var val viextaxval,
                                      var val vipayval,var val vicreval,var val viapval,vector val vvibasev)
begin
  row OPVc OPrw;
  record VIVc VIr;
  row VIVc VIrw;
  Integer vi,vrwcnt;
  val vatv,t1;
  Integer oi,orwcnt;
  record APVc APr;
  
  vinetval = blankval;
  vivatval = blankval;
  viextaxval = blankval;
  vipayval = blankval;
  vicreval = blankval;
  viapval = blankval;
  orwcnt = MatRowCnt(OPp);
  for (oi=0;oi<orwcnt;oi=oi+1) begin
    MatRowGet(OPp,oi,OPrw);
    VIr.SerNr = OPrw.VISerNr;
    if (ReadFirstMain(VIr,1,true)) then begin
      vrwcnt = MatRowCnt(VIr);
      for (vi=0;vi<vrwcnt;vi=vi+1) begin
        MatRowGet(VIr,vi,VIrw);
        if (VATType(VIrw.VATCode)==kVATTypeNormal) then begin
          if (AccountInRange(VIrw.AccNumber,accnumbers)) then begin
            vinetval = vinetval + VIrw.Sum;
            MulVATIV(VIrw.VATCode,VIrw.Sum,vatv,t1,0,VIr.NoTAXonVAT);
            if (VIrw.VATVal!=0) then begin
              vatv = VIrw.VATVal;
            end;
            vivatval = vivatval + vatv;
            viextaxval = viextaxval + t1;
          end;
        end;
      end;
      vipayval = vipayval + VIr.PayVal;
      vicreval = vicreval + ThisInvoiceDeductCreditNotes(OPrw.VISerNr,whtax,accnumbers,vinetval,vivatval,viextaxval,vipayval,vvibasev);
      APr.SerNr = OPrw.VISerNr;
      if (ReadFirstMain(APr,1,true)) then begin end;
      viapval = viapval + APr.RVal;
    end;
  end;
  return;
END;

function val CalulateWithholdTax(string whtax,record WHCalcFormVc WHCalcFormr,Boolean SubNoTaxAmountf,val taxcalcbase,val VEWithtaxprc,val Discount,var val Percent,var Integer errmess)
BEGIN
  val tax,ltaxcalcbase;
  row WHCalcFormVc WHCalcFormrw;
  Integer i,rwcnt,rownr;
  row OPVc taxOPrw;
  val MinAmount;
  
  ltaxcalcbase = AbsoluteVal(taxcalcbase);
  //if (SubNoTaxAmountf) then begin
    ltaxcalcbase = ltaxcalcbase - WHCalcFormr.NoTaxAmount;
  //end else begin
   // ltaxcalcbase = ltaxcalcbase - WHCalcFormr.NoTaxAmount;
  //end;

  tax = blankval;
  rwcnt = MatRowCnt(WHCalcFormr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WHCalcFormr,i,WHCalcFormrw);
    if ((ltaxcalcbase>=WHCalcFormrw.From) and ((ltaxcalcbase<=WHCalcFormrw.To)) or (blank(WHCalcFormrw.To))) then begin
      ltaxcalcbase = ltaxcalcbase - WHCalcFormrw.From;
      Percent = VEWithtaxprc;
      if (blank(Percent)) then begin  //not zero
        Percent = WHCalcFormrw.Percent;
      end;
      if (Percent!=0) then begin
        tax = (ltaxcalcbase*Percent)/100;
      end;
      tax = tax + WHCalcFormrw.FixAmount;
      MinAmount = WHCalcFormrw.MinAmount;

      if (MinAmount==0) then begin
        MinAmount = WHCalcFormr.MinAmount;
      end;
      if (Discount!=0) then begin
        tax = (tax*Discount)/100;
      end;
      if (tax<MinAmount) then begin
        tax = blankval;
        errmess = 28700;
      end;
      goto LCalulateWithholdTax;
    end;
  end;
LCalulateWithholdTax:;
  if (taxcalcbase<0) then begin
    tax = -tax;
  end;
  CalulateWithholdTax = tax;
  RETURN;
END;

procedure AddToWHTaxArray(integer opi, string whtax,string whtaxaccnumbers,string vecode,LongInt VISerNr,val tax,record WHCalcFormVc WHCalcFormr,val percent,val base,val taxprc,
                          Array string areswhtax,Array string areswhtaxaccnumbers,Array string aresvecode,Array LongInt aresvinr,Array val arestaxv,
                          Array Integer areswhtaxcalc,Array val aresbasev,Array val areswhtaxprc,Array Integer aresrownr,var Integer arescnt)
begin
  Integer i;
  
  for (i=0;i<arescnt;i=i+1) begin
    if (opi==aresrownr[i]) and (whtax==areswhtax[i]) and (vecode==aresvecode[i]) and (VISerNr==aresvinr[i]) and (areswhtaxcalc[i]) then begin
      arestaxv[arescnt] = arestaxv[arescnt] + tax;
      goto LAddToWHTaxArray;
    end;
  end;
  areswhtax[arescnt] = whtax;
  areswhtaxaccnumbers[arescnt] = whtaxaccnumbers;
  aresvecode[arescnt] = vecode;
  aresvinr[arescnt] = VISerNr;
  arestaxv[arescnt] = tax;
  areswhtaxcalc[arescnt] = WHCalcFormr.TaxCalc;
  aresbasev[arescnt] = base;
  aresrownr[arescnt] = opi;
  areswhtaxprc[arescnt] = taxprc;
  if (blank(areswhtaxprc[arescnt])) then begin
    areswhtaxprc[arescnt] = percent;
  end;
  arescnt = arescnt + 1;
LAddToWHTaxArray:; 
  return;
end;

procedure AddToAlreadyCalculatedArray(integer opi, string whtax,string vecode,string VISerNr,Integer TaxCalc,
                                      Array string awhtax,Array Integer awhtaxcalc,Array string avecode,Array string avinr,Array Integer arownr,var Integer acnt)
BEGIN
  awhtax[acnt] = whtax;
  awhtaxcalc[acnt] = TaxCalc;
  avecode[acnt] = vecode;
  avinr[acnt] = VISerNr;
  arownr[acnt] = opi;
  acnt = acnt + 1;
  RETURN;
END;


function Boolean WHTaxAlreadyCalculated(integer opi,string whtax,string vecode,string VISerNr,Integer TaxCalc,
                                        Array string awhtax,Array Integer awhtaxcalc,Array string avecode,Array string avinr,Integer acnt)
BEGIN
  Boolean res,testf;
  Integer i;
  
  for (i=0;i<acnt;i=i+1) begin
    testf = false;
    if (awhtax[i]=="ALREADYDONE") and (vecode==avecode[i]) and (VISerNr==avinr[i])  then begin 
      res = true;
      goto LWHTaxAlreadyCalculated;
    end;  
      
    switch (TaxCalc) begin
      case 0:
        if (whtax==awhtax[i]) and (vecode==avecode[i]) then begin
          testf = true;
        end;
      case 1:
        if (whtax==awhtax[i]) and (vecode==avecode[i]) and (VISerNr==avinr[i]) then begin
          testf = true;
        end;
      case 2:
        if (whtax==awhtax[i]) and (VISerNr==avinr[i]) then begin
          testf = true;
        end;
    end;
    if (testf) then begin 
      res = true;
      i = acnt;
    end;
  end;
LWHTaxAlreadyCalculated:;  
  WHTaxAlreadyCalculated = res;
  RETURN;
END;

procedure CalulateWithholdTaxes(record APAccBlock APb,Integer opi,string vecode,string region,string whtax,var record OPVc OPp,row OPVc baseOPrw,val VEWithtaxprc,val Discount,
                                Array string awhtax,Array Integer awhtaxcalc,Array string avecode,Array string avinr,Array Integer arownr,var Integer acnt,
                                Array string aresvecode,Array string areswhtax,Array string areswhtaxaccnumbers,Array LongInt aresvinr,Array val arestaxv,
                                Array Integer areswhtaxcalc,Array val aresbasev,Array val areswhtaxprc,Array Integer aresrownr,var Integer arescnt,vector val vvibasev, var Integer errmess,
                                vector Boolean vvewhtaxdone)
BEGIN
  record VIVc VIr;
  row WHTaxBlock WHTaxrw;
  record WHCalcFormVc WHCalcFormr;
  row WHCalcFormVc WHCalcFormrw;
  row PMBlock PMrw;
  val tax;
  val taxcalcbase;
  val vinetval,vivatval,viextaxval,vipayval,vicreval,viapval;
  val PInvVal,Percent,t;
  LongInt VISerNr;
  Boolean SubNoTaxAmountf;
  row OPVc OPrw;
  
  if (GetWHTaxRow(whtax,WHTaxrw)) then begin
    if (nonblank(WHTaxrw.WHCalcForm)) then begin    
      WHCalcFormr.PayCode = WHTaxrw.WHCalcForm;
      if (ReadFirstMain(WHCalcFormr,1,true)) then begin
        GetPMRow(WHTaxrw.PayMode,PMrw);
        switch (PMrw.CheckType) begin
          case kPayModeTypeRegionalWithholding:
            if (APb.GrossIncomeWithTaxPerRegion==1) then begin 
              MatRowGet(OPp,opi,OPrw);
              VIr.SerNr = OPrw.VISerNr;
              if (ReadFirstMain(VIr,1,true)) then begin
                if (region!=VIr.Region) then begin 
                  errmess = 22029;
                  goto LCalulateWithholdTaxes;
                end;
              end;    
            end;
        end;
        
        taxcalcbase = 0;
        SubNoTaxAmountf = true;
        switch (WHCalcFormr.TaxCalc) begin
          case kWHTaxCalcYearly: // yearly
            if (WHTaxAlreadyCalculated(opi,whtax,vecode,baseOPrw.VISerNr,WHCalcFormr.TaxCalc,awhtax,awhtaxcalc,avecode,avinr,acnt)==false) then begin
              ThisSupplierPeriodInvoicesAmounts(whtax,kWHTaxCalcYearly,baseOPrw,OPp.TransDate,WHTaxrw.AccNumbers,vinetval,vivatval,viextaxval,vipayval,vicreval,viapval,vvibasev);
              if (WHCalcFormr.BaseCalcVAT!=0) then begin 
                if (vivatval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;
              end;
              if (WHCalcFormr.BaseCalcExTax!=0) then begin 
                if (vinetval+viextaxval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;
              end;              
              if (WHCalcFormr.BaseCalcNet!=0) then begin 
                if (vinetval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;              
              end;
              ThisSupplierPaymentAmount(WHCalcFormr,-1,whtax,baseOPrw.VECode,OPp,WHTaxrw.AccNumbers,vivatval,vipayval,vinetval,vvibasev,true,errmess);
//if vipayval is not > than Pinv-credited amount we should not call  ThisSupplierDeductCreditNotes
//              vicreval = ThisInvoiceDeductCreditNotes(baseOPrw.VISerNr,WHTaxrw.AccNumbers,vinetval,vivatval,viextaxval,vipayval);
//must go through all supplier credit notes but that matters only if allowing overpayment which they dont 
              PInvVal = vipayval - viapval - vicreval;
              VISerNr = -1;
            end;
            vvewhtaxdone[vecode & ":" & whtax] = true;
          case kWHTaxCalcMonthly: // monthly
            if (WHTaxAlreadyCalculated(opi,whtax,vecode,baseOPrw.VISerNr,WHCalcFormr.TaxCalc,awhtax,awhtaxcalc,avecode,avinr,acnt)==false) then begin 
              ThisSupplierPeriodInvoicesAmounts(whtax,kWHTaxCalcMonthly,baseOPrw,OPp.TransDate,WHTaxrw.AccNumbers,vinetval,vivatval,viextaxval,vipayval,vicreval,viapval,vvibasev);
              if (WHCalcFormr.BaseCalcVAT!=0) then begin 
                if (vivatval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;
              end;
              if (WHCalcFormr.BaseCalcExTax!=0) then begin 
                if (vinetval+viextaxval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;
              end;              
              if (WHCalcFormr.BaseCalcNet!=0) then begin 
                if (vinetval>WHCalcFormr.NoTaxAmount) then begin
                  SubNoTaxAmountf = false;
                end;              
              end;
              ThisSupplierPaymentAmount(WHCalcFormr,-1,whtax,baseOPrw.VECode,OPp,WHTaxrw.AccNumbers,vivatval,vipayval,vinetval,vvibasev,true,errmess);
//if vipayval is not > than Pinv-credited amount we should not call  ThisSupplierDeductCreditNotes
//             vicreval = ThisInvoiceDeductCreditNotes(baseOPrw.VISerNr,WHTaxrw.AccNumbers,vinetval,vivatval,viextaxval,vipayval);
//must go through all supplier credit notes but that matters only if allowing overpayment which they dont 
              PInvVal = vipayval - viapval - vicreval;
              VISerNr = -1;
            end;
            vvewhtaxdone[vecode & ":" & whtax] = true;
          case kWHTaxCalcPerPayment:
            if (WHTaxAlreadyCalculated(opi,whtax,vecode,baseOPrw.VISerNr,WHCalcFormr.TaxCalc,awhtax,awhtaxcalc,avecode,avinr,acnt)==false) then begin // baseOPrw.VISerNr
              ThisSupplierPaymentAmount(WHCalcFormr,-1,whtax,baseOPrw.VECode,OPp,WHTaxrw.AccNumbers,vivatval,vipayval,vinetval,vvibasev,true,errmess);
              PInvVal = vipayval - viapval - vicreval;
              VISerNr = -1;
            end;
          case kWHTaxCalcPerInvoice:
            if (WHTaxAlreadyCalculated(opi,whtax,vecode,baseOPrw.VISerNr,WHCalcFormr.TaxCalc,awhtax,awhtaxcalc,avecode,avinr,acnt)==false) then begin
              ThisInvoiceAmounts(baseOPrw.VISerNr,whtax,WHTaxrw.AccNumbers,vinetval,vivatval,viextaxval,vipayval,vicreval,viapval,vvibasev);
              PInvVal = ThisInvoicePaymentAmount(baseOPrw.VISerNr,OPp);
              VISerNr = baseOPrw.VISerNr;
            end;
        end;

        if (WHCalcFormr.BaseCalcVAT!=0) then begin taxcalcbase = (PInvVal*vivatval)/vipayval; end;
        if (WHCalcFormr.BaseCalcExTax!=0) then begin taxcalcbase = taxcalcbase + (PInvVal*viextaxval)/vipayval; end;
        if (WHCalcFormr.BaseCalcNet!=0) then begin taxcalcbase = taxcalcbase + (PInvVal*vinetval)/vipayval; end;

        if (WHTaxrw.BaseMin>0) then begin
          if (AbsoluteVal(taxcalcbase)<WHTaxrw.BaseMin) then begin taxcalcbase = 0; end;
        end;
        switch (WHCalcFormr.TaxCalc) begin
          case kWHTaxCalcPerInvoice:
            t = vipayval;
            if (vipayval!=viapval) then begin
              t = t - PInvVal;
            end;
            vvibasev[VISerNr & ":accumbase:vat:" & whtax] = (vvibasev[VISerNr & ":vat:" & whtax]*PInvVal)/t;
            vvibasev[VISerNr & ":accumbase:net:" & whtax] = (vvibasev[VISerNr & ":net:" & whtax]*PInvVal)/t;
            vvibasev[VISerNr & ":accumbase:pay:" & whtax] = (vvibasev[VISerNr & ":pay:" & whtax]*PInvVal)/t;

            vvibasev[VISerNr & ":vat:" & whtax] = taxcalcbase;
            vvibasev[VISerNr & ":net:" & whtax] = taxcalcbase;
            vvibasev[VISerNr & ":pay:" & whtax] = taxcalcbase;
        end;
        if (taxcalcbase!=0) then begin    
          tax = CalulateWithholdTax(whtax,WHCalcFormr,SubNoTaxAmountf,taxcalcbase,VEWithtaxprc,Discount,Percent,errmess);
          if (tax!=0) then begin
            AddToAlreadyCalculatedArray(opi,whtax,vecode,baseOPrw.VISerNr,WHCalcFormr.TaxCalc,awhtax,awhtaxcalc,avecode,avinr,arownr,acnt);
            AddToWHTaxArray(opi,whtax,WHTaxrw.AccNumbers,vecode,VISerNr,tax,WHCalcFormr,Percent,taxcalcbase,VEWithtaxprc,areswhtax,areswhtaxaccnumbers,aresvecode,aresvinr,arestaxv,areswhtaxcalc,aresbasev,areswhtaxprc,aresrownr,arescnt);
          end;
        end;
      end;
    end;
  end;
LCalulateWithholdTaxes:;
  return;
end;

global
function Integer CalculateWithholdTaxesFromOP(var record OPVc OPp)
BEGIN
  Integer res;
  row OPVc OPrw;
  record WHVEExmptVc WHVEEr;
  record WHVEVc WHVEr;
  row WHVEVc WHVErw;
  Integer i,rwcnt,opi,oprwcnt;
  Integer pos;
  string 10 whtax;
  Array string 50 avecode;
  Array string 5 awhtax;
  Array string 20 avinr;
  Array integer arownr;
  Array Integer awhtaxcalc;
  Integer acnt;  
  record CUVc VEr;
  Array string 50 aresvecode;
  Array string 5 areswhtax;
  Array string 100 areswhtaxaccnumbers;
  Array LongInt aresvinr;
  Array val arestaxv;
  Array val aresbasev;
  Array val areswhtaxprc;
  Array Integer aresrownr;
  Array Integer areswhtaxcalc;
  Integer arescnt;  
  record BaseCurBlock BCb;
  Boolean testf;
  vector val vvibasev;
  record APAccBlock APb;
  record VIVc VIr;
  vector Boolean vvewhtaxdone;

  BlockLoad(BCb);  
  BlockLoad(APb);
    
  //bug report
  //PL>>Registers>>Payments>>It's possible to calculate withholding taxes multiple times 
  for (opi=0;opi<MatRowCnt(OPp);opi=opi+1) begin
    MatRowGet(OPp,opi,OPrw);    
    if (nonblank(OPrw.WHTax)) and (OPrw.WHTaxBase!=0) then begin 
      if (WHTaxAlreadyCalculated(-1,"ALREADYDONE",OPrw.VECode,OPrw.VISerNr,-1,awhtax,awhtaxcalc,avecode,avinr,acnt)==false) then begin
        AddToAlreadyCalculatedArray(-1,"ALREADYDONE",OPrw.VECode,OPrw.VISerNr,-1,awhtax,awhtaxcalc,avecode,avinr,arownr,acnt);
      end;
    end;  
  end;  

  oprwcnt = MatRowCnt(OPp);
  for (opi=0;opi<oprwcnt;opi=opi+1) begin
    MatRowGet(OPp,opi,OPrw);    
//    if (OPrw.RecCurncy!=BCb.BaseCur1) then begin
//      res = 24080;
//      goto LCalculateWithholdTaxesFromOP; 
//    end;
    if (blank(OPrw.WHTax)) then begin
    if (FindWHVETax(OPrw.VECode,OPp.TransDate,WHVEr)) then begin
      VEr.Code = OPrw.VECode;
      ReadFirstMain(VEr,1,true);
      rwcnt = MatRowCnt(WHVEr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(WHVEr,i,WHVErw);
        testf = true;
        if (blank(WHVErw.WHTax)) then begin testf = false; end;
        if (WHVErw.CalculateTax!=kCalculateTax) then begin testf = false; end;
        if (nonblank(WHVErw.Region)) then begin
          if (VEr.NoTax2!=0) then begin testf = false; end;
        end;
        if (vvewhtaxdone[OPrw.VECode & ":" & WHVErw.WHTax]) then begin testf = false; end;
        if (testf) then begin 
          res = 0;
          CalulateWithholdTaxes(APb,opi,WHVEr.VECode,WHVErw.Region,WHVErw.WHTax,OPp,OPrw,WHVErw.TAXPrc,WHVErw.Discount,awhtax,awhtaxcalc,avecode,avinr,arownr,acnt,
                                aresvecode,areswhtax,areswhtaxaccnumbers,aresvinr,arestaxv,areswhtaxcalc,aresbasev,areswhtaxprc,aresrownr,arescnt,vvibasev,res,
                                vvewhtaxdone);
          if (res!=0) then begin
            MessageBox(res,"" & OPrw.VISerNr);
            res = 0;
          end;
        end;
      end;
    end;
    end;
  end;

  SubWHTaxAlreadyPaid(OPp,areswhtaxcalc,areswhtax,aresvecode,aresvinr,arestaxv,arescnt);
  AddWHTaxToPayment(BCb,OPp,areswhtaxcalc,areswhtax,areswhtaxaccnumbers,aresvecode,aresvinr,arestaxv,aresbasev,areswhtaxprc,aresrownr,arescnt,vvibasev,res);
LCalculateWithholdTaxesFromOP:;  
  CalculateWithholdTaxesFromOP = res;
  RETURN;
END;

// Used?
/*
global
function val ThisMonthPaidToVE(string vecode,Date td)
BEGIN
  val res;
  Date sd,ed;
  record CUVc VEr;

  sd.year = td.year;
  sd.month = td.month;
  sd.day = 1;
  ed.year = td.year;
  ed.month = td.month;
  ed.day = DaysInMonth(ed.year,ed.month);
  
  VEr.Code = vecode;
  res = -GetTurnover(VEr,"vepaidvalue",sd,ed);
  ThisMonthPaidToVE = res;
  RETURN;
END;
*/

global
function Boolean FindOwnCheque(string paymode,string ownbankacc,string vecode,Date paydate,string curncy,val cheqv,var record OwnCheckVc resOwnCheckr)
begin
  Boolean res;
  record CUVc VEr;
  record OwnCheckVc OwnCheckr;
  Boolean TrHs,testf;
  row PMBlock PMrw;
  
  GetPMRow(paymode,PMrw);
  RecordClear(resOwnCheckr);
  TrHs = true;
  OwnCheckr.SerNr = -1;
  OwnCheckr.Openf = 0;
  while (LoopKey("OpenSerNr",OwnCheckr,1,TrHs)) begin
    if (TrHs) then begin
      testf = true;
      if (OwnCheckr.Amount!=0) then begin
        testf = false;
      end;
      if (nonblank(OwnCheckr.VECode)) then begin
        if (OwnCheckr.VECode!=vecode) then begin
          testf = false;
        end;
      end;
      if (nonblank(ownbankacc)) then begin
        if (nonblank(OwnCheckr.BankAcc)) then begin
          if (OwnCheckr.BankAcc!=ownbankacc) then begin
            testf = false;
          end;
        end;
      end;
      if (nonblank(OwnCheckr.BankCode)) then begin
        if (PMrw.BankCode!=OwnCheckr.BankCode) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        TrHs = false;
        res = true;
        RecordCopy(resOwnCheckr,OwnCheckr);
      end;
    end;
  end;
  FindOwnCheque = res;
  return;
end;

updating procedure AddToInvoice(record OPVc OPr,row OPVc OPrw,array record VIVc aVIr,var string errstr)
begin
  record VIVc oldVIr;
  record VIVc VIr;
  row VIVc VIrw;
  record POVc POr;
  Integer err,rownr;
  record LocalMachineBlock LMb;
  string 255 vewarn;
  Boolean vifound;
  record SRBlock SRb;
  val temp;
  
  errstr = "";
  if (OPrw.OrderNr>0) then begin
    POr.SerNr = OPrw.OrderNr;
    if (ReadFirstMain(POr,1,true)) then begin
      err = RecordAction_POOrdDownPay(POr.SerNr,blankval,OPrw.PInvVal,VIr,errstr,1);
      if (err!=1) then begin
        goto LAddToInvoice;
      end;      
      vifound = ReadFirstMain(VIr,1,true);
    end;
  end;
  if (OPrw.PrepayNr>0) then begin
    if (vifound==false) then begin
      RecordNew(VIr);
      VIr.VECode = OPrw.VECode;
      VIVc_PasteVECode(VIr,0,true,true,vewarn);
    end else begin
      RecordCopy(oldVIr,VIr);
    end;
    ClearRow(VIr,VIrw,kInvoiceRowTypePrepayment);
    VIrw.Comment = USetStr(1288);
    VIrw.VEPNr = OPrw.PrepayNr;
    rownr = MatRowCnt(VIr);
    MatRowPut(VIr,rownr,VIrw);
    VIVc_PastePrepayNr(VIr,rownr)
    if (vifound==false) then begin
      BlockLoad(SRb);
      if (VIr.SerNr<0) then begin
        VIr.SerNr = NextSerNr("VIVc",VIr.TransDate,SRb.LastPurNr,false,"");            
      end;
      if (VIr.SerNr>0) then begin
        RecordStore(VIr,false);
      end;
    end else begin
      VIDDefault(-1,"PayVal",VIr);  
      VISumup(VIr,temp);
      err = RecordUpdate(oldVIr,VIr,true);
//      ReadFirstMain(VIr,1,true);
    end;
  end;
  aVIr[aVIr.length] = VIr;
LAddToInvoice:;
  return;
end;

global
updating procedure MakeDownPayFromOKedOPD(record OPVc OPr,Integer rownr,var array record VIVc aVIr,var string errstr)
begin
  row OPVc OPrw;
  Integer i,rwcnt;
  
  if (rownr<0) then begin
    rwcnt = MatRowCnt(OPr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(OPr,i,OPrw);
      AddToInvoice(OPr,OPrw,aVIr,errstr);
    end;
  end else begin
    MatRowGet(OPr,rownr,OPrw);
    if (OPrw.OrderNr>0) then begin
      AddToInvoice(OPr,OPrw,aVIr,errstr);
    end;
  end;
  return;
end;