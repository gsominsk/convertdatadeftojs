external function Time TimeDiff(Time,Time);external function LongInt DateDiff(Date,Date);external function longint TimeToSeconds2(time);global updatingprocedure RemoveOldTempRecs()begin  record TempProdPlanVc TempPlanr,TempPlan2r;  integer fcnt;  dbhold;  while LoopMain(TempPlanr,1,true) begin    recordremove(TempPlanr);    StepBack(TempPlanr);    fcnt = fcnt + 1;    if fcnt > 10 then begin      fcnt = 0;      dbflush;      dbhold;    end;  end;  dbflush;  return;end;globalprocedure GetNextAvailableWTime(var date td,record MachineShiftVc Shiftr,date gsd,var time starttime,var time endtime,var time ft,var integer rcnt)begin  row MachineShiftVc Shiftrw;  longint dd,ddi;  longint wt;  integer i;  transaction string 10 wtimeChecks;  i = 0;  dd = DateDiff(td,gsd);  ddi = 0;  if dd>=0 and dd < MatRowCnt(Shiftr) then begin    if rcnt>0 then begin      rcnt = rcnt-1;    end else begin      MatRowGet(Shiftr,dd,Shiftrw);      //MatRowGet(Shiftr,1,Shiftrw);      starttime = Shiftrw.StartTime;      endtime = Shiftrw.EndTime;      rcnt = Shiftrw.RepeatCnt;      if rcnt==MatRowCnt(Shiftr)-dd-1 and starttime==endtime then begin        Goto LExitAddPlanTime;      end;    end;  end else begin    starttime = "00:00:00";    endtime = "23:59:00";  end;  wt = wtimeChecks;  wtimeChecks = wt + 1;  while TimeToSeconds2(TimeDiff(starttime,endtime)) <= 0 or ft > endtime begin    wt = wtimeChecks;    wtimeChecks = wt + 1;    dd = dd+1;    ddi = ddi + 1;    if dd>=0 and dd<MatRowCnt(Shiftr) then begin      if rcnt>0 then begin        rcnt = rcnt-1;      end else begin        MatRowGet(Shiftr,dd,Shiftrw);        starttime = Shiftrw.StartTime;        endtime = Shiftrw.EndTime;        rcnt = Shiftrw.RepeatCnt;        if rcnt==MatRowCnt(Shiftr)-dd-1 and starttime==endtime then begin          Goto LExitAddPlanTime;        end;      end;    end else begin      starttime = "00:00:00";      endtime = "23:59:00";    end;    ft = starttime;    i = i + 1;    if blanktime(starttime) or blanktime(endtime) then begin      Goto LExitAddPlanTime;    end;    if i > 100 then begin      Goto LExitAddPlanTime;    end;  end;LExitAddPlanTime:;  td = AddDay(td,ddi);  return;end;globalprocedure AddPlanRow(row TempProdPlanVc Temprw,longint prodopnr,longint prodnr,integer type,string comstr,string addclass,date fromdate,time fromtime,date mdate,time mtime,longint dur,record MachineShiftVc Shiftr,boolean forcesetf,var date FinStartDate,var time FinStartTime,var date FinEndDate,var time FinEndTime,date gsd,time gst,                     array date arStartDate,array time arStartTime,array date arEndDate,array time arEndTime,val qty,var integer arsize,integer debugstep)begin  row MachineShiftVc Shiftrw;  longint tdur;  time ttime;  date fd,pd,prevenddate;  time ft,tt,prevendtime;  integer i,rcnt,wc,wcnt;  time starttime,endtime;  fd = fromdate;  ft = fromtime;  pd = "20.05.2011";  //===== decription  // fromdate & fromtime - the date and time after which we can add the new record  // mdate & mtime - mother date and time  // gsd & gst - date and time of running the planner. It should be as anchor start point and if algorythm calculates for 10 minutes, the gsd and gst shoudl stay the same  // starttime & endtime - shift start and shift end  //if mother record date is after the previous record date  //then mother record should be taken as a basis  if nonblank(mdate) then begin    if mdate > fd then begin      fd = mdate;      ft = mtime;    end else begin      if mdate == fd then begin        if mtime > ft then begin          ft = mtime;        end;      end;    end;  end;  if forcesetf then begin    // for activities    fd = FinStartDate;    ft = FinStartTime;  end else begin    //if global start date of running is after fd then fd should be set to global start data    if fd < gsd then begin      fd = gsd; ft = gst;    end else begin      if fd==gsd then begin        if gst > ft then begin ft = gst; end;      end;    end;  end;  tdur = dur;  Temprw.StartDate = fd;  // finding the starting dates shift start time. If the current day shift is over is not existent, look in next day  rcnt = 0;  if forcesetf==false then begin    GetNextAvailableWTime(Temprw.StartDate,Shiftr,gsd,starttime,endtime,ft,rcnt);  end;  Temprw.ProdOpNr = prodopnr;  Temprw.ProdNr = prodnr;  Temprw.Dur = dur;  Temprw.Qty = qty;  Temprw.EndDate = Temprw.StartDate;  Temprw.StartTime = ft;  if dur > TimeToSeconds2(TimeDiff(Temprw.StartTime,endtime)) then begin    Temprw.EndTime = endtime;  end else begin    Temprw.EndTime = AddSeconds(Temprw.StartTime,dur);  end;  Temprw.Comment = comstr;  Temprw.AddClass = addclass;  Temprw.Type = type;  ttime = Temprw.StartTime;  arsize = 0;  arStartDate[arsize] = Temprw.StartDate;  arStartTime[arsize] = Temprw.StartTime;  arEndDate[arsize] = Temprw.EndDate;  arEndTime[arsize] = Temprw.EndTime;  prevendtime = endtime;  wcnt = 0;  while tdur > TimeToSeconds2(TimeDiff(ttime,prevendtime)) begin    Temprw.EndDate = AddDay(Temprw.EndDate,1);    if forcesetf==false then begin      GetNextAvailableWTime(Temprw.EndDate,Shiftr,gsd,starttime,endtime,tt,rcnt);    end else begin      starttime = "00:00:00";      endtime = "23:59:59";    end;    tdur = tdur - TimeToSeconds2(TimeDiff(ttime,prevendtime));    ttime = starttime;    Temprw.EndTime = addseconds(starttime,tdur);    arEndTime[arsize] = prevendtime;    prevendtime = endtime;    arsize = arsize + 1;    arStartDate[arsize] = Temprw.EndDate;    arStartTime[arsize] = starttime;    arEndDate[arsize] = Temprw.EndDate;    arEndTime[arsize] = Temprw.EndTime;    wcnt = wcnt + 1;  end;SkipAdd:;  finEndDate = Temprw.EndDate;  finEndTime = Temprw.EndTime;  finStartDate = Temprw.StartDate;  finStartTime = Temprw.StartTime;  arEndDate[arsize] = Temprw.EndDate;  arEndTime[arsize] = Temprw.EndTime;  arsize = arsize + 1;LExitAddPlanrow:;  return;end;