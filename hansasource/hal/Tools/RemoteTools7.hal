external updating function LongInt SMVcRecordCheck(var record SMVc,record SMVc,LongInt,LongInt);
external function Boolean DateLocked(Date,string);
external function roundmode GetTotalRoundMode(record RoundBlock);
external procedure OffHireSumUp(var record OffHireVc);
external procedure DispatchSumup(var record DispatchVc);
external procedure IPSumup(var record IPVc);
external procedure IPVc_PasteRecCurncy(var record IPVc,Integer);
external procedure IPVc_PasteRecVal(var record IPVc,Integer);
external function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external function LongInt DateDiff(Date,Date);
external function Integer GetIntYc(Date);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt PasteIPInFEIV(var record FEIVVc,record IPVc,Integer);
external function LongInt PastePUInRetPU(record PUVc,var record RetPUVc);
external procedure PastePrepIPInInv(record IPVc,var record IVVc);
external function string 255 FindNextLegalSerNr(record IVVc,string);
external procedure PasteEDIOrdInOrd(var record EDIORVc,var record ORVc);
external procedure ORSumup(var record ORVc);
external updating function LongInt PastePUInVI(record PUVc,var record VIVc,var string,
                                      Boolean,Boolean,Boolean,Boolean,Boolean,Boolean,Boolean);
external function Boolean CalculateLoanInstallments(var record CuAccVc,Integer);
external function Boolean GetSVOSerialItem(string,string,record SVOSerVc);
external function LongInt GetCurUserLastNr(string);
external updating procedure SaveTrans(record TRVc);
external procedure TRSumup(var record TRVc,var val);
external updating procedure AddSM(record SMVc,Boolean);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external procedure GetARAcc(string,var string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);

global
procedure ChangeSVIPRecCur(row IPVc iprp,Date tdp,val maxvalp)
BEGIN
  Boolean copytobank;
  val v;

  if (iprp.InvCurncy==iprp.RecCurncy) then begin
    if (iprp.RecVal==iprp.BankVal) then begin copytobank = true; end;
    iprp.RecVal = iprp.InvVal;
  end else begin
    if (iprp.RecVal==iprp.BankVal) then begin copytobank = true; end;
    CurValToOtherCur(tdp,iprp.InvCurncy,iprp.InvVal,iprp.RecCurncy,v,DefaultCurRoundOff);
    iprp.RecVal = v;
    CurValToOtherCur(tdp,iprp.RecCurncy,iprp.RecVal,iprp.InvCurncy,v,DefaultCurRoundOff);
    iprp.InvVal = v;
    if (maxvalp!=0) then begin
      if (iprp.RecVal>maxvalp) then begin
        iprp.RecVal = maxvalp;
      end;  
    end;
  end;
  if (copytobank) then begin
    iprp.BankVal = iprp.RecVal;
    iprp.BankCurncy = iprp.RecCurncy;
  end;
  RETURN;
END;

/*
procedure MinM4Val(val a,val b,var val c)
BEGIN
  if (a<b) then begin
    c = a;
  end else begin
    c = b;
  end;
  RETURN;
END;

function Integer InvInAS(Array Integer aRowType,Array LongInt aInvNr,Array string aCustCode,Array string aARAcc,Array string aInvCurncy,
                         Array val aval,Array val ainvoutstand,Array val afrrate,Array val atorate1,Array val atorate2,
                         Array val abaserate1,Array val abaserate2,Integer rows,Integer rowtype,LongInt Inv)
BEGIN
  Integer i;
  Integer res;
  
  res = -1;
  for(i=0;i<rows;i=i+1) begin
    if (aRowType[i]==rowtype) and (aInvNr[i]==Inv) then begin
      res = i;
      goto LInvInAS;
    end;
  end;
LInvInAS:;
  InvInAS = res;
  RETURN;
END;

procedure AddToAS(Array Integer AMpRowType,Array LongInt AMpInvNr,Array string AMpCustCode,Array Integer AMpInvType,Array string AMpInvCurncy,
                  Array val AMpRVal,Array val AMpfrrate,Array val AMptorate1,Array val AMptorate2,Array val AMpbaserate1,
                  Array val AMpbaserate2,Array string AMpARAcc,Integer AMcount,
                  Array Integer aRowType,Array LongInt aInvNr,Array string aCustCode,Array string aARAcc,Array string aInvCurncy,
                  Array val aval,Array val ainvoutstand,Array val afrrate,Array val atorate1,Array val atorate2,
                  Array val abaserate1,Array val abaserate2,Integer asrwcnt,
                  var val PV,Boolean interest,var Integer AScount)
BEGIN
  val t,r;
  Integer line;
  Integer i,rwcnt;
  
  rwcnt = asrwcnt;
  line = -1;
  for (i=0;i<AMcount;i=i+1) begin
    if (interest) then begin
      if (AMpInvType[i]!=4) then begin goto L20AddToAS; end;
    end;
    if (PV!=0) then begin    
      line = InvInAS(aRowType,aInvNr,aCustCode,aARAcc,aInvCurncy,aval,ainvoutstand,afrrate,atorate1,atorate2,abaserate1,abaserate2,rwcnt,AMpRowType[i],AMpInvNr[i]);
      if (line==-1) then begin
        line = rwcnt;
        aRowType[line] = AMpRowType[line];
        aInvNr[line] = AMpInvNr[i];
        aCustCode[line] = "";
        aARAcc[line] = "";
        aCustCode[line] = AMpCustCode[i];
        aInvCurncy[line] = AMpInvCurncy[i];
        aval[line] = blankval;
        ainvoutstand[line] = AMpRVal[i];
        afrrate[line] = AMpfrrate[i];
        atorate1[line] = AMptorate1[i];
        atorate2[line] = AMptorate2[i];
        abaserate1[line] = AMpbaserate1[i];
        abaserate2[line] = AMpbaserate2[i];
        aARAcc[line] = AMpARAcc[i];
        rwcnt = rwcnt + 1;
      end;
      r = AMpRVal[i] - aval[line];
      MinM4Val(PV,r,t);
      aval[line] = aval[line] + t;    
      t = MulRateToBase1(AMpInvCurncy[i],AMpRVal[i],AMpfrrate[i],AMptorate1[i],AMptorate2[i],AMpbaserate1[i],AMpbaserate2[i],DefaultCurRoundOff);
      if (t>=0) then begin //already done for negative amounts in ARCheckDistPay
        PV = PV - t;
      end;  
L20AddToAS:;
    end;
  end;
  AScount = rwcnt;
  RETURN;
END;

procedure AddARtoAM(record ARVc ARp,val PV,Array Integer AMpRowType,Array LongInt AMpInvNr,Array string AMpCustCode,Array Integer AMpInvType,
                    Array string AMpInvCurncy,Array val AMpRVal,Array val AMpfrrate,Array val AMptorate1,
                    Array val AMptorate2,Array val AMpbaserate1,Array val AMpbaserate2,Array string AMpARAcc,
                    var Integer rwcnt,record AccBlock ARAccb,record RoundBlock Roundb)
BEGIN
  record IVVc IVr;
  Boolean testf,rebf;
  val rebval,rval,vatval;
  LongInt rebdays;
  
  rval = ARp.RVal;
  if (rval>PV) then begin
    rval = PV;
  end;
  AMpRowType[rwcnt] = 1;
  AMpARAcc[rwcnt] = "";
  AMpCustCode[rwcnt] = "";
  AMpInvNr[rwcnt] = ARp.InvoiceNr;
  AMpCustCode[rwcnt] = ARp.CustCode;
  AMpRVal[rwcnt] = rval;
  IVr.SerNr = ARp.InvoiceNr;
  if (ReadFirstMain(IVr,1,true)) then begin
    testf = true;
    if (IVr.Invalid!=0) then begin
      testf = false;
    end;
  end;
  if (testf) then begin
    if (IVr.pdvrebt!=0) then begin
      rebdays = DateDiff(ARp.ARRebDate,CurrentDate);
      if (rebdays>=0) then begin
        if (ARAccb.DiscCashVAT!=0) then begin
          vatval = (IVr.Sum3*rval)/ARp.RVal;
          rebval = (rval - vatval)*IVr.pdvrebt;
          rebval = rebval/100;
          rebval = Round(rebval,GetTotalRoundMode(Roundb));
        end else begin
          rebval = rval*IVr.pdvrebt;
          rebval = rebval/100;
          rebval = Round(rebval,GetTotalRoundMode(Roundb));
        end;
        rebf = true;
      end;
      if (rebf==false) then begin
        rebdays = DateDiff(ARp.ARRebDate2,CurrentDate);
        if (rebdays>=0) then begin
          if (ARAccb.DiscCashVAT!=0) then begin
            vatval = (IVr.Sum3*rval)/ARp.RVal;
            rebval = (rval - vatval)*IVr.pdvrebt2;
            rebval = rebval/100;
            rebval = Round(rebval,GetTotalRoundMode(Roundb));
          end else begin
            rebval = rval*IVr.pdvrebt2;
            rebval = rebval/100;
            rebval = Round(rebval,GetTotalRoundMode(Roundb));
          end;
          rebf = true;
        end;
      end;
    end;   
    AMpInvType[rwcnt] = IVr.InvType;
    AMpARAcc[rwcnt] = IVr.ARAcc;
    AMpInvCurncy[rwcnt] = IVr.CurncyCode;
    AMpfrrate[rwcnt] = IVr.FrRate;
    AMptorate1[rwcnt] = IVr.ToRateB1;
    AMptorate2[rwcnt] = IVr.ToRateB2;
    AMpbaserate1[rwcnt] = IVr.BaseRate1;
    AMpbaserate2[rwcnt] = IVr.BaseRate2;
    if (rebf) then begin
      AMpRVal[rwcnt] = rval - rebval;
      rwcnt = rwcnt + 1;

      AMpRowType[rwcnt] = 5;
      AMpInvNr[rwcnt] = ARp.InvoiceNr;
      AMpCustCode[rwcnt] = ARp.CustCode;
      AMpRVal[rwcnt] = rebval;
      AMpInvType[rwcnt] = IVr.InvType;
      AMpARAcc[rwcnt] = IVr.ARAcc;
      AMpInvCurncy[rwcnt] = IVr.CurncyCode;
      AMpfrrate[rwcnt] = IVr.FrRate;
      AMptorate1[rwcnt] = IVr.ToRateB1;
      AMptorate2[rwcnt] = IVr.ToRateB2;
      AMpbaserate1[rwcnt] = IVr.BaseRate1;
      AMpbaserate2[rwcnt] = IVr.BaseRate2;
    end;
  end else begin
    AMpInvType[rwcnt] = -1;
    AMpARAcc[rwcnt] = "9999";
    AMpInvCurncy[rwcnt] = "";
    AMpfrrate[rwcnt] = blankval;
    AMptorate1[rwcnt] = blankval;
    AMptorate2[rwcnt] = blankval;
    AMpbaserate1[rwcnt] = blankval;
    AMpbaserate2[rwcnt] = blankval;
  end;
  rwcnt = rwcnt + 1;
  RETURN;
END;

procedure ARCheckDistPay(string custcode,string curncy,Date dp,var val PV,
                         Array Integer aRowType,Array LongInt aInvNr,Array string aCustCode,Array string aARAcc,Array string aInvCurncy,
                         Array val aval,Array val ainvoutstand,Array val afrrate,Array val atorate1,Array val atorate2,
                         Array val abaserate1,Array val abaserate2,var Integer asrwcnt)
BEGIN
  Boolean TrHs;
  record ARVc ARr;
  Array LongInt AMpInvNr;
  Array string 20 AMpCustCode;
  Array Integer AMpInvType;
  Array string 5 AMpInvCurncy;
  Array val AMpRVal;
  Array val AMpfrrate;
  Array val AMptorate1;
  Array val AMptorate2;
  Array val AMpbaserate1;
  Array val AMpbaserate2;
  Array string 10 AMpARAcc; 
  Array Integer AMpRowType; 
  Integer AMcount;
  Integer AScount,rwcnt;
  Integer i;
  val fr,to1,to2,br1,br2;
  string 255 tstr;
  record AccBlock ARAccb;
  record RoundBlock Roundb;
  val oPV;
  
  oPV = PV;
  BlockLoad(ARAccb);
  BlockLoad(Roundb);
  ARr.CustCode = custcode;
  ARr.InvoiceNr = 0;
  TrHs = true;
  while (LoopKey("CustDue",ARr,2,TrHs)) begin//CustCode
    if ((TrHs==true) and (PV!=0)) then begin
        if (ARr.CustCode==custcode) then begin
          AddARtoAM(ARr,PV,AMpRowType,AMpInvNr,AMpCustCode,AMpInvType,AMpInvCurncy,AMpRVal,AMpfrrate,AMptorate1,
                    AMptorate2,AMpbaserate1,AMpbaserate2,AMpARAcc,AMcount,ARAccb,Roundb);
        end else begin
          goto L80ARCheckDistPay;
        end;      
    end;
  end;
L80ARCheckDistPay:;
  // AMh now contains all open invoices for this customer 
  // Take all negative AR records and get rid of them 
  for (i=0;i<AMcount;i=i+1) begin
    if (AMpRVal[i]<0) then begin // the AR record is < 0 
      aRowType[AScount] = AMpRowType[i];
      aInvNr[AScount] = AMpInvNr[i];
      aval[AScount] = AMpRVal[i];
      aCustCode[AScount] = custcode;
      aInvCurncy[AScount] = AMpInvCurncy[i];
      afrrate[AScount] = AMpfrrate[i];
      atorate1[AScount] = AMptorate1[i];
      atorate2[AScount] = AMptorate2[i];
      abaserate1[AScount] = AMpbaserate1[i];
      abaserate2[AScount] = AMpbaserate2[i];
      aARAcc[AScount] = AMpARAcc[i];
      PV = PV - AMpRVal[i];
      MinM4Val(PV,oPV,PV);
      AScount = AScount + 1;
    end;
  end;

  if (PV>0) then begin
    AddToAS(AMpRowType,AMpInvNr,AMpCustCode,AMpInvType,AMpInvCurncy,AMpRVal,AMpfrrate,AMptorate1,AMptorate2,AMpbaserate1,AMpbaserate2,AMpARAcc,AMcount,
            aRowType,aInvNr,aCustCode,aARAcc,aInvCurncy,aval,ainvoutstand,afrrate,atorate1,atorate2,abaserate1,abaserate2,asrwcnt,
            PV,true,AScount); // look at interest invoices 
    AddToAS(AMpRowType,AMpInvNr,AMpCustCode,AMpInvType,AMpInvCurncy,AMpRVal,AMpfrrate,AMptorate1,AMptorate2,AMpbaserate1,AMpbaserate2,AMpARAcc,AMcount,
            aRowType,aInvNr,aCustCode,aARAcc,aInvCurncy,aval,ainvoutstand,afrrate,atorate1,atorate2,abaserate1,abaserate2,asrwcnt,
            PV,false,AScount); // don't look at interest invoices 
  end;
  if (PV!=0) then begin
    aRowType[AScount] = 1;
    aInvNr[AScount] = -1;
    aval[AScount] = PV;
    ainvoutstand[AScount] = blankval;
    aCustCode[AScount] = custcode;
    aInvCurncy[AScount] = curncy;
    GetFullCurncyRate(curncy,dp,fr,to1,to2,br1,br2);
    afrrate[AScount] = fr;
    atorate1[AScount] = to1;
    atorate2[AScount] = to2;
    abaserate1[AScount] = br1;
    abaserate2[AScount] = br2;
    GetARAcc(custcode,tstr);
    aARAcc[AScount] = tstr;
    AScount = AScount + 1;
  end;
  asrwcnt = AScount;
  RETURN;
END;

global
procedure RecordAction_raExpandPay(var record IPVc IPp,Integer rownr)
BEGIN
  Array LongInt aInvNr;
  Array string 20 aCustCode;
  Array string 10 aARAcc;
  Array string 5 aInvCurncy;
  Array val aval;
  Array val ainvoutstand;  
  Array val afrrate;
  Array val atorate1;
  Array val atorate2;
  Array val abaserate1;
  Array val abaserate2;
  Array Integer aRowType;
  Integer rwcnt,i,j,asrwcnt;
  row IPVc IP0rw;
  row IPVc IP1rw;
  row IPVc IPrw;
  val t,rem;

LRecordAction_raExpandPayBEGIN:;
  rwcnt = MatRowCnt(IPp);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i>=rownr) then begin
    MatRowGet(IPp,i,IP0rw);
    if (IP0rw.stp==1) then begin
      if (IP0rw.InvoiceNr==-1) then begin
        t = IP0rw.RecVal;
        rem = IP0rw.RecVal;
        ARCheckDistPay(IP0rw.CustCode,IP0rw.RecCurncy,IP0rw.PayDate,t,
                       aRowType,aInvNr,aCustCode,aARAcc,aInvCurncy,aval,ainvoutstand,afrrate,atorate1,atorate2,abaserate1,abaserate2,asrwcnt);
        for (j=0;j<asrwcnt;j=j+1) begin
          if (asrwcnt>1) then begin
            MatRowGet(IPp,i+j,IP1rw);
          end;
          if (rem<=0) then begin
            MatRowDelete(IPp,i);
            goto LRecordAction_raExpandPaySKIP;
          end;
          MatRowInsert(IPp,i+j+1,IPrw);
          ClearRow(IPp,IPrw,aRowType[i]);
          IPrw.InvoiceNr = aInvNr[j];
          IPrw.CustCode = aCustCode[j];
          IPrw.InvCurncy = aInvCurncy[j];
          IPrw.CustName = IP0rw.CustName;
          IPrw.RecCurncy = IP0rw.RecCurncy;
          IPrw.ovst = 0;
          IPrw.CUPNr = -1;
          IPrw.PayDate = IP0rw.PayDate;
          IPrw.latedays = 0;
          IPrw.InvVal = aval[j];
          IPrw.InvOutstand = ainvoutstand[j];
          ChangeSVIPRecCur(IPrw,IPrw.PayDate,rem);
          rem = rem - IPrw.RecVal;
          if (IPrw.InvoiceNr==-1) then begin
            IPrw.InvoiceNr = -2;
          end;
          MatRowPut(IPp,i+j+1,IPrw);
        end;
        MatRowDelete(IPp,i);
        goto LRecordAction_raExpandPayBEGIN;        
LRecordAction_raExpandPaySKIP:;        
      end;
    end;
    end;
  end;
  rwcnt = MatRowCnt(IPp);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i>=rownr) then begin
      MatRowGet(IPp,i,IPrw);
      if (IPrw.stp==1) then begin
        if (IPrw.InvoiceNr==-2) then begin
          IPrw.InvoiceNr = -1;
          MatRowPut(IPp,i,IPrw);
        end;
      end;
    end;
  end;
  RETURN;
END;
*/

procedure OpenInvoiceNumber(record IPTBlock IPTb,string custcode, var LongInt lastpos,var record ARVc resARr)
begin
  record ARVc ARr;
  Boolean found;
  string 255 ckey;

  RecordNew(resARr);  
  ARr.CustCode = custcode;
  found = true;
  SetLoopPosition(ARr,lastpos);

  switch (IPTb.DistributeIP) begin
    case 0: ckey = "CustCode";
    case 1: ckey = "CustDue";
  end;
  while (LoopKey(ckey,ARr,1,found)) begin
    if (ARr.CustCode!=custcode) then begin found = false; end;
    if (found) then begin
      lastpos = GetLoopPosition(ARr);
      RecordCopy(resARr,ARr);     
      goto LOpenInvoiceNumber;
    end;    
  end;

/*
  while (LoopKey("CustDue",ARr,1,found)) begin
    if (ARr.CustCode!=custcode) then begin found = false; end;
    if (found) then begin
      RecordCopy(resARr,ARr);     
      lastpos = GetLoopPosition(ARr);
      goto LOpenInvoiceNumber;
    end;    
  end;
*/  
LOpenInvoiceNumber:;
  return;
end;

procedure ChangeIPRows(record IPVc IPp,LongInt InvoiceNr,string reccurncy,Integer currow,var val curv,Boolean installmentf)
begin
  row IPVc IPrw;
  row IPVc newIPrw;
  Integer i,rwcnt;
  val v;
        
  v = curv;
  curv = blankval;
  rwcnt = MatRowCnt(IPp);
  for (i=currow+1;i<rwcnt;i=i+1) begin
    MatRowGet(IPp,i,IPrw);
    if (IPrw.InvoiceNr==InvoiceNr) then begin
	    switch (IPrw.stp) begin
	      case 1:
	        if (installmentf) then begin
	          
	        end;
	      case 5: 
	        CopyRow(IPp,IPrw,newIPrw);
				  newIPrw.RecCurncy = reccurncy;
				  MatRowPut(IPp,i,newIPrw);
				  IPVc_PasteRecCurncy(IPp,i);				  
				  MatRowGet(IPp,i,newIPrw);
	        v = v - newIPrw.RecVal;
	        curv = curv + newIPrw.RecVal;
	    end;
	  end;
  end;

  MatRowGet(IPp,currow,newIPrw);    
  newIPrw.RecCurncy = RecCurncy;
  MatRowPut(IPp,currow,newIPrw);
  IPVc_PasteRecCurncy(IPp,currow);
    MatRowGet(IPp,currow,newIPrw);
	curv = curv + newIPrw.RecVal;
  
	if (installmentf==false) then begin
    MatRowGet(IPp,currow,newIPrw);
    newIPrw.RecVal = v;
    MatRowPut(IPp,currow,newIPrw);
    IPVc_PasteRecVal(IPp,currow);
    MatRowGet(IPp,currow,newIPrw);
  end;
  RETURN;
END;

global
procedure RecordAction_raExpandPay(var record IPVc IPp,Integer rownr)
begin
  row IPVc IP0rw;
  row IPVc newIPrw;
  Integer i,rwcnt,currow;
  record ARVc ARr;
  record IVVc IVr;
  Boolean loopf,testf,installmentf;
  LongInt lastpos;
  record BaseCurBlock BCb;
  val v,remv,chk;  
  record IPTBlock IPTb;
  
  BlockLoad(BCb);
  BlockLoad(IPTb);
  rwcnt = MatRowCnt(IPp);
  currow = rwcnt;
  MatRowGet(IPp,rownr,IP0rw);
  remv = IP0rw.RecVal;
  if (IP0rw.InvoiceNr<0) and (IP0rw.RecVal>0) then begin
    loopf = true;
  end;
  while (loopf) begin
    OpenInvoiceNumber(IPTb,IP0rw.CustCode,lastpos,ARr);    
    if (ARr.InvoiceNr<=0) then begin
      loopf = false;
    end;
    if (remv<=0) then begin
      loopf = false;
    end;
    if (loopf) then begin
      testf = true;
      IVr.SerNr = ARr.InvoiceNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        testf = true;
        if (IVr.Invalid!=0) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        if (IVr.CurncyCode!=IP0rw.RecCurncy) then begin
          CurValToOtherCur(IPp.TransDate,IVr.CurncyCode,ARr.RVal,IP0rw.RecCurncy,v,DefaultCurRoundOff);
        end else begin
          v = ARr.RVal;
        end;
        if (remv<v) then begin
          v = remv;
        end;

        ClearRow(IPp,newIPrw,1)
        newIPrw.InvoiceNr = ARr.InvoiceNr;
        MatRowPut(IPp,currow,newIPrw);
        if (PasteInvIn2IPr(IPp,currow,IPp.TransDate,chk,false,installmentf)) then begin
        end;
        
        ChangeIPRows(IPp,newIPrw.InvoiceNr,IP0rw.RecCurncy,currow,v,installmentf);
                
//        currow = currow + 1;
        currow = MatRowCnt(IPp);
        remv = remv - v;        
      end;
    end;    
  end;  
  
  MatRowDelete(IPp,rownr);
  if (remv>0) then begin
    currow = MatRowCnt(IPp);
    CopyRow(IPp,IP0rw,newIPrw);
    MatRowPut(IPp,currow,newIPrw);
    MatRowGet(IPp,currow,newIPrw);
    newIPrw.RecVal = remv;
    MatRowPut(IPp,currow,newIPrw);
    IPVc_PasteRecVal(IPp,currow);
  end;
  IPSumup(IPp);
  return;
end;



/*
PasteInvInIPr(IPr,IPrw,rownr,5);

if (IVr.pdvrebt!=0) then begin
      rebdays = DateDiff(ARp.ARRebDate,CurrentDate);
      if (rebdays>=0) then begin
        if (ARAccb.DiscCashVAT!=0) then begin
          vatval = (IVr.Sum3*rval)/ARp.RVal;
          rebval = (rval - vatval)*IVr.pdvrebt;
          rebval = rebval/100;
          rebval = Round(rebval,Roundb.RndTotal);
        end else begin
          rebval = rval*IVr.pdvrebt;
          rebval = rebval/100;
          rebval = Round(rebval,Roundb.RndTotal);
        end;
        rebf = true;
      end;
      if (rebf==false) then begin
        rebdays = DateDiff(ARp.ARRebDate2,CurrentDate);
        if (rebdays>=0) then begin
          if (ARAccb.DiscCashVAT!=0) then begin
            vatval = (IVr.Sum3*rval)/ARp.RVal;
            rebval = (rval - vatval)*IVr.pdvrebt2;
            rebval = rebval/100;
            rebval = Round(rebval,Roundb.RndTotal);
          end else begin
            rebval = rval*IVr.pdvrebt2;
            rebval = rebval/100;
            rebval = Round(rebval,Roundb.RndTotal);
          end;
          rebf = true;
        end;
      end;
    end;   
*/
/* Changed the name of this function, because it has a "Global variety" that looks almost the same. */
updating function Integer SMBookTRLoc(record SMVc SMp,Date untildatp,Integer lmod)
BEGIN
  Integer res;
  record SRBlock SRRec;
  record TRVc TRr;
  record SMVc oldSMr;
  row TRVc TRrw;
  row SMVc SMrw;
  Integer i,rwcnt;
  LongInt newnr;
  Integer tri;
  Boolean onemore;
  Boolean savesm;
  val t,fr,to1,to2,br1,br2;
  string 10 curncy;  

  RecordCopy(oldSMr,SMp);
  TRr.IntYc = 0;
  BlockLoad(SRRec);
  savesm = false;
L22SMBookTRLoc:;
  RecordClear(TRr);
  TRr.TransDate = SMp.TransDate;
  TRr.RegDate = CurrentDate;
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,SMrw);
    if (SMrw.RowSimStat==0) then begin
      if (nonblankdate(SMrw.TransDate)) then begin
        TRr.TransDate = SMrw.TransDate;
      end;
      if ((TRr.TransDate<=untildatp) or (blankdate(untildatp))) then begin i = rwcnt; end;
    end;
  end;
  if ((TRr.TransDate>untildatp) and (nonblankdate(untildatp))) then begin goto L88SMBookTRLoc; end;
  newnr = GetCurUserLastNr("TRVc");
  if (newnr==-1) then begin
    newnr = SRRec.LastTRNr;
  end;
  TRr.Number = NextSerNr("TRVc",TRr.TransDate,newnr,false,-1);
  if (TRr.Number==-1) then begin
    res = 1033; 
    goto LSMBookTRLoc;
  end;
  TRr.IntYc = GetIntYc(TRr.TransDate);
  onemore = false;
  TRr.Comment = SMp.Comment;
  TRr.RefStr = SMp.RefStr;
  tri = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,SMrw);
    if ((SMrw.RowSimStat==0) or (SMrw.RowSimStat==3) or (SMrw.RowSimStat==4)) then begin // kypp
      if ((SMrw.TransDate==TRr.TransDate) or
          ((blankdate(SMrw.TransDate)) and (SMp.TransDate==TRr.TransDate))) then begin
        ClearRow(TRr,TRrw,1);
        TRrw.stp = 1;
        TRrw.ovst = 0;
        GetFullCurncyRate(curncy,TRr.TransDate,fr,to1,to2,br1,br2);
        TRrw.Curncy = curncy;
        TRrw.FrRate = fr;
        TRrw.ToRateB1 = to1;
        TRrw.ToRateB2 = to2;
        TRrw.BaseRate1 = br1;
        TRrw.BaseRate2 = br2;
        TRrw.AccNumber = SMrw.AccNumber;
        TRrw.Objects = SMrw.Objects;
        TRrw.Comment = SMrw.Comment;
        TRrw.ExtraComment = SMrw.ExtraComment;
        TRrw.VATCode = SMrw.VATCode;
        TRrw.Curncy = SMrw.CurncyCode;
        TRrw.CurDebVal = SMrw.CurDebVal;
        TRrw.CurCredVal = SMrw.CurCredVal;
        TRrw.DebVal = SMrw.DebVal;
        TRrw.CredVal = SMrw.CredVal;
        TRrw.DebVal2 = SMrw.DebVal2;
        TRrw.CredVal2 = SMrw.CredVal2;
        if (blank(TRrw.DebVal2)) then begin
          TRrw.DebVal2 = MulRateToBase2(curncy,TRrw.DebVal,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2,DefaultCurRoundOff);        
          if (TRrw.DebVal2==0) then begin
            TRrw.DebVal2 = blankval;
          end;          
        end;
        if (blank(TRrw.CredVal2)) then begin
          TRrw.CredVal2 = MulRateToBase2(curncy,TRrw.CredVal,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2,DefaultCurRoundOff);        
          if (TRrw.CredVal2==0) then begin
            TRrw.CredVal2 = blankval;
          end;          
        end;
        if (HasLocalization("ARG,PRT")) then begin
          if (SMrw.RowSimStat==3) then begin 
            TRrw.SAFTType = kTransactionFiscalTypeYearEndStage1;
          end;
          if (SMrw.RowSimStat==4) then begin 
            TRrw.SAFTType = kTransactionFiscalTypeYearEndStage2;
          end;
        end;
        MatRowPut(TRr,tri,TRrw);
        tri = tri + 1;
        SMrw.RowSimStat = 1;
        MatRowPut(SMp,i,SMrw);
        savesm = true;
      end else begin
        onemore = true;
      end;
    end;
  end;
  if (DateLocked(TRr.TransDate,"TRVc")) then begin
    res = 1046; 
    goto LSMBookTRLoc;
  end;
  if (tri>0) then begin
    TRSumup(TRr,t);
    TRr.FileName = "SMVc";
    TRr.TransNr = SMp.SerNr;
//CheckTRansaction    
    SaveTrans(TRr);
  end;
  if (onemore) then begin
    if (RecordUpdate(oldSMr,SMp,true)==0) then begin end;
//false changed to true so below sommented out    
//    AddSM(oldSMr,true);
//    AddSM(SMp,false);
    goto L22SMBookTRLoc;
  end;
L88SMBookTRLoc:;
  if (savesm) then begin
    if (RecordUpdate(oldSMr,SMp,true)==0) then begin end;
//false changed to true so below sommented out    
//    AddSM(oldSMr,true);
//    AddSM(SMp,false);    
  end;
LSMBookTRLoc:;
  SMBookTRLoc = res;
  RETURN;
END;

updating function Integer acSMLBook(var record SMVc SMp)
BEGIN
  Date td;
  Integer res;
  
  res = SMBookTRLoc(SMp,td,0);
  acSMLBook = res;
  RETURN;
END;

global
updating function Integer RecordAction_rlSMLBook(var record SMVc SMp)
BEGIN
  Integer res;
  record SMVc dummySMr;

  if (IsRecordLocked(SMp)==false) then begin
    if (ReadFirstMain(SMp,0,true)==false) then begin goto LRecordAction_rlSMLBook; end;  
    SetRecordCheckVc("SMVc");
    if (SMVcRecordCheck(SMp,dummySMr,Rs_update,1)!=0) then begin goto LRecordAction_rlSMLBook; end;      
    res = acSMLBook(SMp);
  end;
LRecordAction_rlSMLBook:;
  RecordAction_rlSMLBook = res;
  RETURN;
END;

procedure PasteSVOInSVGM(record SVOVc SVOp,var record SVGMVc SVGMp)
BEGIN
  row SVOVc SVOrw;
  row SVGMVc SVGMrw;
  record SVOSerVc SVOSerr;
  record INVc INr;
  Integer rwcnt,i,srw;
  record MainStockBlock MainStockRec;

  BlockLoad(MainStockRec);  
  SVGMp.SVONr = SVOp.SerNr;
  SVGMp.CustCode = SVOp.CustCode;
  SVGMp.Addr0 = SVOp.Addr0;
  SVGMp.CustContact = SVOp.CustContact;
  SVGMp.Comment1 = SVOp.Comment1;
  SVGMp.Comment2 = SVOp.Comment2;
  SVGMp.Comment3 = SVOp.Comment3;
  SVGMp.Comment4 = SVOp.Comment4;
  SVGMp.CurncyCode = SVOp.CurncyCode;
  SVGMp.FrRate = SVOp.FrRate;
  SVGMp.ToRateB1 = SVOp.ToRateB1;
  SVGMp.ToRateB2 = SVOp.ToRateB2;
  SVGMp.BaseRate1 = SVOp.BaseRate1;
  SVGMp.BaseRate2 = SVOp.BaseRate2;
  srw = 0;
  rwcnt = MatRowCnt(SVOp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SVOp,i,SVOrw);
    ClearRow(SVGMp,SVGMrw,1);
    INr.Code = SVOrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1) then begin
        SVGMrw.Location = MainStockRec.DefServiceLoc;
        SVGMrw.MotherNr = "";
        SVGMrw.VECode = "";
        SVGMrw.Contact = "";
        SVGMrw.ArtCode = SVOrw.ArtCode;
        SVGMrw.Spec = SVOrw.Spec;
        SVGMrw.SerialNr = SVOrw.SerialNr;
        if (GetSVOSerialItem(SVOrw.ArtCode,SVOrw.SerialNr,SVOSerr)) then begin
          SVGMrw.SalesPrice = SVOSerr.SalesPrice;
          SVGMrw.CostPrice = SVOSerr.CostPrice;
          SVGMrw.SoldDate = SVOSerr.SoldDate;
          SVGMrw.WarrantyUntil = SVOSerr.WarrantyUntil;
/* Should read from the Internal Stock Support register instead now.
          if (SVOp.DoneMark!=0) then begin
            if (SVOSerr.xInStock>0) then begin
              SVGMrw.OutQuant = SVOrw.Quant;
            end;
          end else begin
            if (SVOSerr.xInStock==0) then begin
              SVGMrw.InQuant = SVOrw.Quant;
            end;
          end;
*/
        end;
        MatRowPut(SVGMp,srw,SVGMrw);
        srw = srw + 1;
      end;
    end;
  end;
  RETURN;
END;

global
updating function LongInt RecordAction_raPasteSVOInSVGM(record SVOVc SVOp,var record SVGMVc SVGMp)
BEGIN
  LongInt res;

  if (ReadFirstMain(SVOp,0,true)) then begin end;  
  RecordNew(SVGMp);
  SVGMp.SVONr = SVOp.SerNr;
  PasteSVOInSVGM(SVOp,SVGMp);
  SVGMp.SerNr = NextSerNr("SVGMVc",SVGMp.TransDate,-1,false,"");
  if (SVGMp.SerNr==-1) then begin goto LRecordAction_raPasteSVOInSVGM; end;
  if ((MatRowCnt(SVGMp)>0) and (SVGMp.SerNr!=-1)) then begin
    if (RecordStore(SVGMp,false)) then begin
      res = 1;
    end;
  end;
LRecordAction_raPasteSVOInSVGM:;
  RecordAction_raPasteSVOInSVGM = res;
  RETURN;
END;

global
procedure RecordAction_raCalculateInstalments(var record CuAccVc CuAccp,Boolean readf)
BEGIN
  LongInt res;

  if (readf) then begin
    if (ReadFirstMain(CuAccp,0,true)) then begin end;  
  end;
  if (CalculateLoanInstallments(CuAccp,0)) then begin
  end;
  RETURN;
END;

global
procedure RecordAction_raCalculateDecInstalments(var record CuAccVc CuAccp,Boolean readf)
BEGIN
  LongInt res;

  if (readf) then begin
    if (ReadFirstMain(CuAccp,0,true)) then begin end;  
  end;
  if (CalculateLoanInstallments(CuAccp,1)) then begin
  end;
  RETURN;
END;

global
updating function LongInt RecordAction_raPastePUInVI(record PUVc PUp,var record VIVc VIp,var string errmsg)
BEGIN
  LongInt res,newnr;
  record SRBlock SRRec;

  if (ReadFirstMain(PUp,0,true)) then begin end;  
  BlockLoad(SRRec);
  RecordNew(VIp);
  res = PastePUInVI(PUp,VIp,errmsg,true,true,true,true,true,true,true);
  if (res!=0) then begin
    goto LRecordAction_raPastePUInVI; 
  end;
  if (VIp.SerNr<=0) then begin
    newnr = GetCurUserLastNr("VIVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastVINr;
    end;
    VIp.SerNr = NextSerNr("VIVc",VIp.TransDate,newnr,false,"");
  end;  
  if (VIp.SerNr<=0) then begin goto LRecordAction_raPastePUInVI; end;  
  if (MatRowCnt(VIp)>0) then begin
    if (RecordStore(VIp,false)) then begin
      res = 0;
      CreateRecordLink(PUp,CurrentCompany,VIp,CurrentCompany);  
      CreateRecordLink(VIp,CurrentCompany,PUp,CurrentCompany);  
    end;
  end else begin
    if (res==0) then begin
      res = -1;
    end;
  end;
LRecordAction_raPastePUInVI:;
  RecordAction_raPastePUInVI = res;
  RETURN;
END;

function Boolean PONrinPURow(record PUVc PUr) 
begin
  Boolean res;
  row PUVc PUrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if (PUrw.PONr>0)  then begin
      res = true;
      i = rwcnt;
    end;
  end;
  PONrinPURow = res;
  return;
end;

global
updating function LongInt RecordAction_raPastePUInRetPU(record PUVc PUp,var record RetPUVc RetPUp)
BEGIN
  record MainStockBlock MainStockRec;
  LongInt res;
  
  BlockLoad(MainStockRec);
  
  if (ReadFirstMain(PUp,0,true)) then begin end;  
    if (PUp.PONr<=0) and (PONrinPURow(PUp)==false) then begin
    goto LRecordAction_raPastePUInRetPU;
  end;
  RecordNew(RetPUp);
  res = PastePUInRetPU(PUp,RetPUp);
  if (res>0) then begin
    goto LRecordAction_raPastePUInRetPU;
  end;
  if (RetPUp.SerNr<=0) then begin
    RetPUp.SerNr = NextSerNr("RetPUVc",RetPUp.TransDate,-1,false,"");
  end;  
  if (RetPUp.SerNr<=0) then begin 
    res = 1747;
    goto LRecordAction_raPastePUInRetPU; 
  end;  
  if (MatRowCnt(RetPUp)>0) then begin
    if (RecordStore(RetPUp,false)) then begin
      CreateRecordLink(PUp,CurrentCompany,RetPUp,CurrentCompany);
      CreateRecordLink(RetPUp,CurrentCompany,PUp,CurrentCompany);
      res = 0;
    end;
  end;
LRecordAction_raPastePUInRetPU:;
  RecordAction_raPastePUInRetPU = res;
  RETURN;
END;

global
updating function LongInt RecordAction_raPasteEDIOrdInOrd(var record EDIORVc EDIORp,var record ORVc ORp,Boolean readf)
BEGIN
  LongInt res,newnr;
  record SRBlock SRRec;
  record EDIORVc oldEDIORr;

  if (readf) then begin
    if (ReadFirstMain(EDIORp,0,true)) then begin end;  
  end;
  BlockLoad(SRRec);
  RecordNew(ORp);
  RecordCopy(oldEDIORr,EDIORp);
  PasteEDIOrdInOrd(EDIORp,ORp);
  if (ORp.SerNr<=0) then begin
    newnr = GetCurUserLastNr("ORVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastOrdNr;
    end;
    ORp.SerNr = NextSerNr("ORVc",ORp.OrdDate,newnr,false,"");
  end;  
  if (ORp.SerNr<=0) then begin goto LRecordAction_raPasteEDIOrdInOrd; end;  
  if (MatRowCnt(ORp)>0) then begin
    ORSumup(ORp);
    if (RecordStore(ORp,false)) then begin
      EDIORp.ORSerNr = ORp.SerNr;
      if (RecordUpdate(oldEDIORr,EDIORp,false)==0) then begin end;
      res = 1;
    end;
  end;
LRecordAction_raPasteEDIOrdInOrd:;
  RecordAction_raPasteEDIOrdInOrd = res;
  RETURN;
END;

global
updating function LongInt RecordAction_raPastePrepIPInInv(record IPVc IPp,var record IVVc IVp)
BEGIN
  LongInt res,newnr;
  record SRBlock SRRec;
  string 255 tstr;
  record CUVc CUr;

  BlockLoad(SRRec);
  RecordNew(IVp);
  PastePrepIPInInv(IPp,IVp);
  if (IVp.SerNr<=0) then begin
    newnr = GetCurUserLastNr("IVVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastInvNr;
    end;
    IVp.SerNr = NextSerNr("IVVc",IVp.TransDate,newnr,false,IVp.LangCode);
    CUr.Code = IVp.CustCode;
    if (ReadFirstMain(CUr,1,true)) then begin end;
//    IVp.OfficialSerNr = FindNextLegalSerNr(IVp,CUr.Classification);  //POSN
  end;  
  if (IVp.SerNr<=0) then begin goto LRecordAction_raPastePrepIPInInv; end;  
  if (MatRowCnt(IVp)>0) then begin
    if (RecordStore(IVp,false)) then begin
      CreateRecordLink(IPp,CurrentCompany,IVp,CurrentCompany);  
      CreateRecordLink(IVp,CurrentCompany,IPp,CurrentCompany);  
      res = 1;
    end;
  end;
LRecordAction_raPastePrepIPInInv:;
  RecordAction_raPastePrepIPInInv = res;
  RETURN;
END;

function val AlreadyInOffHire(LongInt SVONr,string artcode,string serialnr)
begin
  val res;
  record OffHireVc OHr;
  row OffHireVc OHrw;
  Integer i,rwcnt;
  Boolean found;
  
  found = true;
  OHr.SVONr = SVONr;
  while (LoopKey("SVONr",OHr,1,found)) begin
    if (OHr.SVONr!=SVONr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(OHr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(OHr,i,OHrw);
        if (OHrw.ArtCode==artcode) and (OHrw.SerialNr==serialnr) then begin
          res = res + OHrw.Quant;
        end;
      end;
    end;
  end;
  AlreadyInOffHire = res;
  return;
end;

function Integer PasteSVOInOffHire(record SVOVc SVOp,var record OffHireVc OHr)
begin
  Integer res;
  row SVOVc SVOrw;
  row OffHireVc OHrw;
  record SVOSerVc SVOSerr;
  record INVc INr;
  Integer rwcnt,i,srw;
  record MainStockBlock MSb;
  val q;

  res = 1547;
  BlockLoad(MSb);  
  RecordNew(OHr);
  OHr.SVONr = SVOp.SerNr;
  OHr.CustCode = SVOp.CustCode;
  OHr.Addr0 = SVOp.Addr0;
  OHr.Location = SVOp.ServLocation;  
  if (blank(OHr.Location)) then begin
    OHr.Location = MSb.DefServiceLoc;  
  end;
  OHr.ClientContact = SVOp.CustContact;  
  srw = 0;
  rwcnt = MatRowCnt(SVOp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SVOp,i,SVOrw);
    ClearRow(OHr,OHrw,1);
    INr.Code = SVOrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1) then begin
        q = AlreadyInOffHire(OHr.SVONr,SVOrw.ArtCode,SVOrw.SerialNr);
        if (q<SVOrw.Quant) then begin
          OHrw.ArtCode = SVOrw.ArtCode;
          OHrw.Quant = SVOrw.Quant;
          OHrw.SerialNr = SVOrw.SerialNr;
          if (GetSVOSerialItem(SVOrw.ArtCode,SVOrw.SerialNr,SVOSerr)) then begin
            OHrw.Cost = SVOSerr.CostPrice;
            OHrw.PurchaseDate = SVOSerr.SoldDate;
            OHrw.WarrantyUntil = SVOSerr.WarrantyUntil;
          end;
          if (OHrw.Cost==0) then begin
            OHrw.Cost = INr.InPrice;
          end;
          OHrw.Spec = SVOrw.Spec;
          OHrw.Status = 4;
  //        OHrw.Cost = SVOrw.Cost;
  //        OHrw.Value = SVOrw.Cost;
          OHrw.ServiceQty = SVOrw.Quant;
          MatRowPut(OHr,srw,OHrw);
          srw = srw + 1;
          res = 0;          
        end;
      end;
    end;
  end;
  OffHireSumUp(OHr);
  PasteSVOInOffHire = res;
  return;
end;

global
updating function Integer RecordAction_raPasteSVOInOffHire(record SVOVc SVOp,var record OffHireVc OHr)
begin
  Integer res;

  if (ReadFirstMain(SVOp,0,true)) then begin end;  
  RecordNew(OHr);
  res = PasteSVOInOffHire(SVOp,OHr);
  if (res!=0) then begin
    goto LRecordAction_raPasteSVOInOffHire;
  end;
  OHr.SerNr = NextSerNr("OffHireVc",OHr.TransDate,-1,false,"");
  if (OHr.SerNr==-1) then begin 
    res = 1747;
    goto LRecordAction_raPasteSVOInOffHire; 
  end;  
  if ((MatRowCnt(OHr)>0) and (OHr.SerNr!=-1)) then begin
    if (RecordStore(OHr,false)) then begin
      res = 0;
      CreateRecordLink(OHr,CurrentCompany,SVOp,CurrentCompany);  
      CreateRecordLink(SVOp,CurrentCompany,OHr,CurrentCompany);  
    end;
  end;
LRecordAction_raPasteSVOInOffHire:;
  RecordAction_raPasteSVOInOffHire = res;
  return;
end;

function val AlreadyInDispatch(LongInt SVONr,string artcode,string serialnr)
begin
  val res;
  record DispatchVc Dispr;
  row DispatchVc Disprw;
  Integer i,rwcnt;
  Boolean found;
  
  found = true;
  Dispr.SVONr = SVONr;
  while (LoopKey("SVONr",Dispr,1,found)) begin
    if (Dispr.SVONr!=SVONr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(Dispr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Dispr,i,Disprw);
        if (Disprw.ArtCode==artcode) and (Disprw.SerialNr==serialnr) then begin
          res = res + Disprw.Quant;
        end;
      end;
    end;
  end;
  AlreadyInDispatch = res;
  return;
end;

function Integer PasteSVOInDispatch(record SVOVc SVOp,var record DispatchVc Dispr)
begin
  Integer res;
  row SVOVc SVOrw;
  row DispatchVc Disprw;
  record SVOSerVc SVOSerr;
  record INVc INr;
  Integer rwcnt,i,srw;
  record MainStockBlock MSb;
  val q;

  res = 1547;
  BlockLoad(MSb);  
  RecordNew(Dispr);
  Dispr.DeliveryDate = CurrentDate;
  
  Dispr.SVONr = SVOp.SerNr;
  Dispr.CustCode = SVOp.CustCode;
  Dispr.Comment = SVOp.Comment1;  

  Dispr.Addr0 = SVOp.ShipAddr0;
  Dispr.Addr1 = SVOp.ShipAddr1;
  Dispr.Addr2 = SVOp.ShipAddr2;
  Dispr.Addr3 = SVOp.ShipAddr3;
  Dispr.DelAddr3 = SVOp.DelAddr3;
  Dispr.DelAddr4 = SVOp.DelAddr4;
  if (blank(Dispr.Addr0)) then begin
    Dispr.Addr0 = SVOp.Addr0;
    Dispr.Addr1 = SVOp.Addr1;
    Dispr.Addr2 = SVOp.Addr2;
    Dispr.Addr3 = SVOp.Addr3;
    Dispr.DelAddr3 = SVOp.DelAddr3;
    Dispr.DelAddr4 = SVOp.DelAddr4;
  end;
  Dispr.SalesMan = SVOp.SalesMan;
  Dispr.ShipMode = SVOp.ShipMode;  
  Dispr.ShipDeal = SVOp.ShipDeal;  

  Dispr.Location = SVOp.ServLocation;  
  if (blank(Dispr.Location)) then begin
    Dispr.Location = MSb.DefServiceLoc;  
  end;
  Dispr.ClientContact = SVOp.CustContact;  
  
  srw = 0;
  rwcnt = MatRowCnt(SVOp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SVOp,i,SVOrw);
    ClearRow(Dispr,Disprw,1);
    INr.Code = SVOrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1) then begin
        q = AlreadyInDispatch(Dispr.SVONr,SVOrw.ArtCode,SVOrw.SerialNr);
        if (q<SVOrw.Quant) then begin
          Disprw.ArtCode = SVOrw.ArtCode;
          Disprw.Quant = SVOrw.Quant;
          Disprw.SerialNr = SVOrw.SerialNr;
          Disprw.Spec = SVOrw.Spec;
//          Disprw.Value = SVOrw.Spec;
          MatRowPut(Dispr,srw,Disprw);
          srw = srw + 1;
          res = 0;          
        end;
      end;
    end;
  end;
  DispatchSumUp(Dispr);
  PasteSVOInDispatch = res;
  return;
end;

global
updating function Integer RecordAction_raPasteSVOInDispatch(record SVOVc SVOp,var record DispatchVc Dispr)
begin
  Integer res;

  if (ReadFirstMain(SVOp,0,true)) then begin end;  
  RecordNew(Dispr);
  res = PasteSVOInDispatch(SVOp,Dispr);
  if (res!=0) then begin
    goto LRecordAction_raPasteSVOInDispatch;
  end;
  Dispr.SerNr = NextSerNr("DispatchVc",Dispr.TransDate,-1,false,"");
  if (Dispr.SerNr==-1) then begin 
    res = 1747;
    goto LRecordAction_raPasteSVOInDispatch; 
  end;  
  if ((MatRowCnt(Dispr)>0) and (Dispr.SerNr!=-1)) then begin
    if (RecordStore(Dispr,false)) then begin
      res = 0;
      CreateRecordLink(Dispr,CurrentCompany,SVOp,CurrentCompany);  
      CreateRecordLink(SVOp,CurrentCompany,Dispr,CurrentCompany);  
    end;
  end;
LRecordAction_raPasteSVOInDispatch:;
  RecordAction_raPasteSVOInDispatch = res;
  return;
end;

global
updating function Boolean RecordAction_rlPULOK(var record PUVc PUp)
begin
  Boolean res;
  record PUVc oldPUp;
  
  if (IsRecordLocked(PUp)==false) then begin
    if (ReadFirstMain(PUp,0,true)) then begin end;  
    RecordCopy(oldPUp,PUp);
    if (PUp.OKFlag==0) then begin
      PUp.OKFlag = 1;
      if (RecordUpdate(oldPUp,PUp,true)==0) then begin
        res = true;
      end;
    end;
  end;
  RecordAction_rlPULOK = res;
  return;
end;
