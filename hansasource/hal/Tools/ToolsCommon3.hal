remote function val HasObjectsMaxNumber();
external function string 60 AddObjectToObjectList(string,string);

global
procedure GetPayModeAccNumber(string paymode,var string res)
BEGIN
  record PMBlock PMRec;
  row PMBlock PMrw;
  Integer i,rwcnt;
  
  res = "";
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMRec,i,PMrw);  
    if (PMrw.Code==paymode) then begin
      res = PMrw.AccNr;
      i = rwcnt;
    end;
  end;  
  RETURN;
END;

global
procedure FBSumup(var record FBVc FBp)
BEGIN
  Integer i,rwcnt;
  row FBVc FBrw;
  
  FBp.DSum = blankval;
  FBp.CSum = blankval;
  FBp.D2Sum = blankval;
  FBp.C2Sum = blankval;
  rwcnt = MatRowCnt(FBp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(FBp,i,FBrw);
    if (FBrw.DebVal!=0) then begin
      FBp.DSum = FBp.DSum + FBrw.DebVal;
    end;
    if (FBrw.CredVal!=0) then begin
      FBp.CSum = FBp.CSum - FBrw.CredVal;
    end;
    if (FBrw.Deb2Val!=0) then begin
      FBp.D2Sum = FBp.D2Sum + FBrw.Deb2Val;
    end;
    if (FBrw.Cred2Val!=0) then begin
      FBp.C2Sum = FBp.C2Sum - FBrw.Cred2Val;
    end;
  end;
  FBp.DiffVal = FBp.DSum + FBp.CSum;
  FBp.Diff2Val = FBp.D2Sum + FBp.C2Sum;
  RETURN;
END;

global
procedure ExtractObjWithSeparator(string separator,string ostr,Boolean skipblankf,var Integer pos,var string rstr)
begin
  string 1 c1;
  Boolean sepf;

  rstr = "";
  if (skipblankf==false) then begin
LNEXTCHAR:;
    if (pos>=len(ostr)) then begin goto L99; end;
    c1 = Mid(ostr,pos,1); 
    pos = pos + 1;
    if (c1==separator) then begin
      goto L99; 
    end else begin
      rstr = rstr & c1;
      goto LNEXTCHAR;
    end;
  end else begin
L477:;
    if (pos>=len(ostr)) then begin goto L99; end;
    c1 = Mid(ostr,pos,1); 
    pos = pos + 1;
    if (c1==separator) then begin
      if (len(rstr)==0) then begin 
        goto L477; 
      end;
      goto L8888;
    end;
    if ((len(rstr)<255)) then begin 
      rstr = rstr & c1;
    end;
    goto L477;
L8888:;
    if (pos>len(ostr)) then begin goto L99; end;
    c1 = Mid(ostr,pos,1);  
    pos = pos + 1;
    if (c1==separator) then begin goto L8888; end;
    pos = pos - 1;
  end;
L99:;
  return;
end;

global
procedure ExtractObj(string ostr,var Integer pos,var string rstr)
BEGIN
  string 1 c1;

  rstr = "";
L47:;
  if (pos>=len(ostr)) then begin goto L999; end;
  c1 = Mid(ostr,pos,1); 
  pos = pos + 1;
  if ((c1==",") or (c1==".") or (c1==";")) then begin
    if (len(rstr)==0) then begin 
      goto L47; 
    end;
    goto L888;
  end;
  if ((len(rstr)<20)) then begin 
    rstr = rstr & c1;
  end;
  goto L47;
L888:;
  if (pos>len(ostr)) then begin goto L999; end;
  c1 = Mid(ostr,pos,1);  
  pos = pos + 1;
  if ((c1==",") or (c1==".") or (c1==";")) then begin goto L888; end;
  pos = pos - 1;
L999:;
  RETURN;
END;

global
function Boolean  EobjInEobj(string d,string e)
BEGIN
  Boolean res;
  Integer pos1,pos2;
  string 255 ostr1,ostr2;
  
  res = false;
  if (blank(d)) then begin
    res = true;
    goto LEobjInEobj;
  end;
  if (blank(d) and blank(e)) then begin
    res = true;
    goto LEobjInEobj;
  end;
  pos1 = 0;
  ExtractObj(d,pos1,ostr1);
  if (blank(ostr1)) then begin goto LEobjInEobj; end;
  while (nonblank(ostr1)) begin
    if (nonblank(ostr1)) then begin
      pos2 = 0;
      ExtractObj(e,pos2,ostr2);
      while (nonblank(ostr2)) begin
        if (ostr1==ostr2) then begin goto LEobj44; end;
        ExtractObj(e,pos2,ostr2);
      end;
      goto LEobjInEobj;
LEobj44:;
    end;
    ExtractObj(d,pos1,ostr1);
  end;
  res = true;
LEobjInEobj:;
  EobjInEobj = res;
  RETURN;
END;

global
function Boolean IncludeSim(Integer rowsimstat,Integer simf)
BEGIN
  Boolean res;
  
  res = false;
  if (simf==0) then begin
  end;  
  if (simf==1) then begin
    if ((rowsimstat==0) or (rowsimstat==3) or (rowsimstat==4)) then begin res = true; end;
  end;  
  if (simf==2) then begin
    if (rowsimstat==3) then begin res = true; end;
  end;  
  if (simf==3) then begin
    if ((rowsimstat==3) or (rowsimstat==4)) then begin res = true; end;
  end;  
  IncludeSim = res;
  RETURN;
END;

global
Procedure GetVatRegPL(String i,var String vatnr,var String vatPos,var String dom0,var String dom1,var String dom2)
Begin
Record CUVc Sup;
   Sup.Code = i;
   vatpos = "";
   vatnr  = "";
   if ReadFirstMain(Sup,1,true) then begin
       vatnr  = Sup.VATNr;
       vatpos = Sup.RegNr2;
       dom0   = Sup.Name;
       dom1   = Sup.InvAddr0;
       dom2   = Sup.InvAddr1;
   end;
   Return;
End;

global
procedure ToStrTRCode(var string rstr,Integer ycp,LongInt nrp)
begin
  string 255 t2;
  
  t2 = nrp;
  rstr = StrTRCode(ycp);
  if (nonblank(rstr)) then begin
    rstr = rstr & ".";
  end;  
  rstr = rstr & t2;
  return;
end;

global
procedure TRExtYc(record TRVc TRr,var string rstr)
BEGIN
  ToStrTRCode(rstr,TRr.IntYc,TRr.Number);
  RETURN;
END;

global
procedure PurgeTRExtYc(record PurgeTRVc PurgeTRr,var string rstr)
BEGIN
  ToStrTRCode(rstr,PurgeTRr.IntYc,PurgeTRr.Number);
  RETURN;
END;

global
procedure NormalizeObjstr(var string objstr)
BEGIN 
  record SMVc SMobjsr;
  record SMVc SMresobjsr;
  row SMVc SMorw;
  row SMVc SMrrw;
  row SMVc SM2rrw;
  Integer i,j,k;
  Integer ocnt;
  Integer pos;
  Integer nlen;
  Integer maxobjcnt;
  string 255 ostr;
  string 60 maxobjstr;
  Integer rrwcnt;
  
  //RecordClear(SMobjsr);
  //RecordClear(SMresobjsr);
  pos = 0;
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    SMorw.Objects = ostr;
    MatRowPut(SMobjsr,ocnt,SMorw);
    ExtractObj(objstr,pos,ostr);
    ocnt = ocnt + 1;    
  end;    
  if (IsStandardProduct) then begin
//    maxobjstr = HasObjectsMaxNumber;//done in record check
    maxobjstr = USetStr(1799);
  end else begin
    maxobjstr = USetStr(1799);
  end;
  maxobjcnt = StringToInt(maxobjstr);
  if (nonblank(maxobjstr)) then begin
    if (ocnt>maxobjcnt) then begin ocnt = maxobjcnt; end;
  end;

  for (i=0;i<ocnt; i=i+1) begin
    for (j=0;j<i;j=j+1) begin     
      MatRowGet(SMobjsr,i,SMorw);
      rrwcnt = MatRowCnt(SMresobjsr);    
      if (rrwcnt<>0) then begin      
        MatRowGet(SMresobjsr,j,SMrrw);
      end;  
      if (SMorw.Objects<SMrrw.Objects) then begin goto L44; end;
    end;
L44:;
    rrwcnt = MatRowCnt(SMresobjsr);    
    for (k=i;k>=j;k=k-1) begin
      if (rrwcnt<>0) then begin
        MatRowGet(SMresobjsr,k,SMrrw);
      end;  
      MatRowPut(SMresobjsr,k+1,SMrrw);
    end;
    MatRowGet(SMobjsr,i,SMorw);
    SMrrw.Objects = SMorw.Objects;
    MatRowPut(SMresobjsr,j,SMrrw);
  end;  
  objstr = "";
  for (i=0;i<ocnt;i=i+1) begin
    MatRowGet(SMresobjsr,i,SMrrw);
    if (nonblank(SMrrw.Objects)) then begin
      nlen = len(objstr)+len(SMrrw.Objects);
      if (i<>0) then begin nlen = nlen + 1; end;;
      if (nlen>60) then begin goto L99; end;
      if (i<>0) then begin objstr = objstr & ","; end;
      objstr = objstr & SMrrw.Objects;
    end;
  end; 
L99:;
  RETURN;
END;

global
procedure AddPerson(var string persstr,string newpers)
BEGIN
  LongInt nlen;

  if (nonblank(newpers)) then begin
    nlen = len(persstr)+len(newpers);
    if (nlen>60) then begin goto LAddPerson; end;
    if (nonblank(persstr)) then begin persstr = persstr & ","; end;
    persstr = persstr & newpers;
  end;
LAddPerson:;
  RETURN;
END;

global
procedure NormalizePersons(var string objstr,string removepers,Boolean removepersf)
BEGIN
  Array string 20 objs;
  Array string 20 resobjs;
  Integer i,j,k;
  Integer ocnt;
  Integer pos;
  string 255 ostr;

  pos = 0;
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    objs[ocnt] = ostr;
    ExtractObj(objstr,pos,ostr);
    ocnt = ocnt + 1;
  end;

  for (i=0;i<ocnt;i=i+1) begin
    for (j=0;j<i;j=j+1) begin
      if (objs[i]<resobjs[j]) then begin goto L44NormalizePersons; end;
    end;
L44NormalizePersons:;
    for (k=i;k>=j;k=k-1) begin
      resobjs[k+1] = resobjs[k];
    end;
    resobjs[j] = objs[i];
  end;
  objstr = "";
  for (i=0;i<ocnt;i=i+1) begin
    if (removepersf) then begin
      if (resobjs[i]==removepers) then begin goto LNormalizePersons; end;
    end;
    AddPerson(objstr,resobjs[i]);
LNormalizePersons:;
  end;
  RETURN;
END;

global
function Boolean ObjIncluded(string object,string objects)
BEGIN
  Boolean res ;

  res = false;
  if (EobjInEobj(object,objects)) then begin res = true; end;
  ObjIncluded = res;
  RETURN;
END;

procedure Add3Objs(var string objstr,string nobjstr)
BEGIN
  Integer pos;
  string 255 ostr;
  
  pos = 0;
  ExtractObj(nobjstr,pos,ostr);
  while (nonblank(ostr)) begin
    if (ObjIncluded(ostr,objstr)==false) then begin
      if (len(ostr)+len(objstr)>=59) then begin goto L19; end;
      if (nonblank(objstr)) then begin
        objstr = objstr & ",";
      end;  
      objstr = objstr & ostr;
    end;
    ExtractObj(nobjstr,pos,ostr);
  end;
L19:;
  RETURN;
END;

global
procedure AutoObj(var string objstr)
BEGIN
  record ObjVc Objr;
  string 255 ostr;
  Integer pos;

  pos = 0;
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    Objr.Code = ostr;
    if (ReadFirstMain(Objr,1,true)) then begin
      if (nonblank(Objr.AutoObjects)) then begin
        Add3Objs(objstr,Objr.AutoObjects);
      end;
    end;
    ExtractObj(objstr,pos,ostr);
  end;
  NormalizeObjstr(objstr);
  RETURN;
END;

global
procedure NoDupObjs(string inobj,var string outobj)
BEGIN
  Integer pos;
  string 255 ostr;

  outobj = "";
  pos = 0;
  ExtractObj(inobj,pos,ostr);
  while (nonblank(ostr)) begin
    Add3Objs(outobj,ostr);
    ExtractObj(inobj,pos,ostr);
  end;
  RETURN;
END;

global
function Integer CountObjects(string objstr)
BEGIN
  string 255 tstr;
  Integer pos;
  Integer res;
  
  ExtractObj(objstr,pos,tstr);
  while (nonblank(tstr)) begin
    res = res + 1;
    ExtractObj(objstr,pos,tstr);
  end;
  CountObjects = res;
  RETURN;
END;  

global
function Integer GetIntYc(Date dp)
BEGIN
  Integer res;
  Integer i,rwcnt;
  record YearBlock YearRec;
  row YearBlock yearrw;
  
  res = 1;
  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(YearRec,i,yearrw);
    if ((dp>=yearrw.StartDate) and (dp<=yearrw.EndDate)) then begin
      res = yearrw.IntYc;
      goto LGetIntYc;
    end;
  end;
LGetIntYc:;
  GetIntYc = res;
  RETURN;
END;

global
function Boolean TransInFiscal(Date dat)
BEGIN
  Boolean res;
  Integer i,rwcnt;
  record YearBlock YearRec;
  row YearBlock yearrw;
  
  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(YearRec,i,yearrw);
    if ((dat>=yearrw.StartDate) and
        (dat<=yearrw.EndDate)) then begin
      res = true;
      goto LTransInFiscal;
    end;
  end;
LTransInFiscal:;
  TransInFiscal = res;
  RETURN;
END;

global
procedure StrToYcNr(string astr,var string ycp,var LongInt np)
begin
  Integer i;
  string 255 s0;
  
  s0 = astr;
  for (i=0;i<=len(s0);i=i+1) begin 
    if (Mid(s0,i,1)==".") then begin
      s0 = Left(s0,i);
      s0 = s0 & ":";
      s0 = s0 & Right(astr,len(astr)-i-1);
    end;
  end;
  ycp = FirstInRange(s0,10);
  np = LastInRange(s0,10);
  return;
end;

global
function Integer StrToYc(string ystr)
BEGIN
  Integer res;
  record YearBlock YearRec;
  row YearBlock Yearrw;
  Integer i,rwcnt;
 
  if (ystr==USetStr(1150)) then begin
    res = IVYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1151)) then begin
    res = IPYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1152)) then begin
    res = VIYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1153)) then begin
    res = OPYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1157)) then begin
    res = PUYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1449)) then begin
    res = VariancePUYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1158)) then begin
    res = SHYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1639)) then begin
    res = DropSHYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1195)) then begin
    res = SDYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1170)) then begin
    res = ExpYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1171)) then begin
    res = PPYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1172)) then begin
    res = STMovYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1448)) then begin
    res = SentSTMovYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1174)) then begin
    res = PVYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1193)) then begin
    res = CLInYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1194)) then begin
    res = CLOutYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1344)) then begin
    res = STRYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1416)) then begin
    res = OPOYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1417)) then begin
    res = OPBYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1418)) then begin
    res = IPOYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1419)) then begin
    res = IPBYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1420)) then begin
    res = ProdYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1421)) then begin
    res = RetYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1422)) then begin
    res = WSYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1423)) then begin
    res = CheckYc;
    goto LStrToYc;
  end;  
  if (ystr==USetStr(1424)) then begin
    res = Check0Yc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1427)) then begin
    res = Check2Yc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1428)) then begin
    res = OwnCheck0Yc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1429)) then begin
    res = OwnCheckYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1430)) then begin
    res = AT2WrofYc;
    goto LStrToYc;
  end;  
  if (ystr==USetStr(1431)) then begin
    res = IVCashYc;
    goto LStrToYc;
  end;  
  if (ystr==USetStr(1443)) then begin
    res = INTransferYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1436)) then begin
    res = RestAccYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1437)) then begin
    res = ChqDepYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1438)) then begin
    res = TSYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1439)) then begin
    res = ActYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1441)) then begin
    res = VATIVYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1442)) then begin
    res = VATVIYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1444)) then begin
    res = LateCostYc;
    goto LStrToYc;
  end;  
  if (ystr==USetStr(1446)) then begin
    res = RetPUYc;
    goto LStrToYc;
  end;  
  if (ystr==USetStr(1447)) then begin
    res = IntIVYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1633)) then begin
    res = ProdOperationYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1635)) then begin
    res = CredManYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1636)) then begin
    res = SRYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1638)) then begin
    res = BuyBackReconYc;
    goto LStrToYc;
  end;
  if (ystr==USetStr(1640)) then begin
    res = ForexTRYc;
    goto LStrToYc;
  end;
    
  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(YearRec,i,Yearrw);
    if (ystr==Yearrw.YearCode) then begin
      res = Yearrw.IntYc;
      goto LStrToYc;
    end;
  end;
LStrToYc:;
  StrToYc = res;
  RETURN;
END;

global
procedure YcToStr(Integer intyc,var string ycstr)
BEGIN
  record YearBlock YearRec;
  row YearBlock Yearrw;
  Integer i,rwcnt;
 
  ycstr = "";
  switch (intyc) begin
    case IVYc: ycstr = USetStr(1150);
    case IPYc: ycstr = USetStr(1151);
    case VIYc: ycstr = USetStr(1152);
    case OPYc: ycstr = USetStr(1153);
    case PUYc: ycstr = USetStr(1157);
    case VariancePUYc: ycstr = USetStr(1449);
    case SHYc: ycstr = USetStr(1158);
    case DropSHYc: ycstr = USetStr(1639);
    case SDYc: ycstr = USetStr(1195);
    case ExpYc: ycstr = USetStr(1170);
    case PPYc: ycstr = USetStr(1171);
    case STMovYc: ycstr = USetStr(1172);
    case SentSTMovYc: ycstr = USetStr(1448);
    case PVYc: ycstr = USetStr(1174);
    case CLInYc: ycstr = USetStr(1193);
    case CLOutYc: ycstr = USetStr(1194);
    case STRYc: ycstr = USetStr(1344);
    case OPOYc: ycstr = USetStr(1416);
    case OPBYc: ycstr = USetStr(1417);
    case IPOYc: ycstr = USetStr(1418);
    case IPBYc: ycstr = USetStr(1419);
    case ProdYc: ycstr = USetStr(1420);
    case RetYc: ycstr = USetStr(1421);
    case WSYc: ycstr = USetStr(1422);
    case CheckYc: ycstr = USetStr(1423);
    case Check0Yc: ycstr = USetStr(1424);
    case Check2Yc: ycstr = USetStr(1427);
    case OwnCheck0Yc: ycstr = USetStr(1428);
    case OwnCheckYc: ycstr = USetStr(1429);
    case AT2WrofYc: ycstr = USetStr(1430);
    case IVCashYc: ycstr = USetStr(1431);
    case INTransferYc: ycstr = USetStr(1443);
    case LateCostYc: ycstr = USetStr(1444);
    case RetPUYc: ycstr = USetStr(1446);
    case IntIVYc: ycstr = USetStr(1447);
    case VATIVYc: ycstr = USetStr(1441);
    case VATVIYc: ycstr = USetStr(1442);
    case RestAccYc: ycstr = USetStr(1436);
    case ProdOperationYc: ycstr = USetStr(1633);
    case CredManYc: ycstr = USetStr(1635);
    case SRYc: ycstr = USetStr(1636);
    case BuyBackReconYc: ycstr = USetStr(1638);
    case ChqDepYc: ycstr = USetStr(1437);
    case ForexTRYc: ycstr = USetStr(1640);
  end;
  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(YearRec,i,Yearrw);
    if (intyc==Yearrw.IntYc) then begin
      ycstr = Yearrw.YearCode;
      goto LYcToStr;
    end;
  end;
LYcToStr:;
  RETURN;
END;

global
function Boolean GetObjBal(string Acc,string SObj,var record ObjBalVc ObjBalp)
BEGIN
  Boolean res;
  
  res = false;
  ObjBalp.AccNumber = Acc;
  ObjBalp.Object = SObj;
  res = ReadFirstMain(ObjBalp,2,true);
  if (res==false) then begin
    ObjBalp.AccNumber = Acc;
    ObjBalp.Object = SObj;
  end;
  GetObjBal = res;
  RETURN;
END;

global
function string 5 AddVATCodeToVATAccRows(string vatcode)
begin
  string 5 res;
  record CYBlock CYRec;
  
  BlockLoad(CYRec);
  if (CYRec.AddVATCodeToVATAccRows!=0) then begin
    res = vatcode;
  end;
  AddVATCodeToVATAccRows = res;
  return;
end;

global
procedure FindFiscalYear(Date curdate,var Date fsd,var Date fed)
BEGIN
  record YearBlock YearRec;
  row YearBlock YearRecrw;
  Integer i,rwcnt;

  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(YearRec,i,YearRecrw);
    if (curdate>=YearRecrw.StartDate) then begin
      if (curdate<=YearRecrw.EndDate) then begin
        fsd = YearRecrw.StartDate;
        fed = YearRecrw.EndDate;
        goto L22;
      end;
    end;
  end;  
L22:;
  RETURN;
END;

procedure SkipSpace(string aost,var Integer np)
BEGIN
  while ((np<=len(aost)) and (Mid(aost,np,1)==" ")) begin
    np = np + 1;
  end;  
  RETURN;
END;

global
function Boolean GetNextTokenReturn(string aost,var Integer np,var string anitem)
BEGIN
  string 1 nc;
  string 255 ost;
  string 255 nitem;
  Integer i;
  Boolean res,TrHs;

  ost = aost;
  nitem = anitem;
  nitem = "";
  SkipSpace(ost,np);
  TrHs = true;
  while (TrHs) begin
    if (np>len(ost)) then begin TrHs = false; end;
    nc = Mid(ost,np,1);//  nc = ost[*np];
    if ((nc==" ") or (nc==";") or (nc==":") or (nc==",") or (nc=="-") or (nc=="+")) then begin 
      TrHs = false;
    end;
    if (TrHs) then begin
      nitem = nitem & nc;
      np = np + 1;
    end;
  end;
  anitem = nitem;
  if (blank(nitem)) then begin
    res = false;
  end else begin
    res = true;  
  end; 
  GetNextTokenReturn = res;   
  RETURN;
END;

global
procedure GetNextToken(string aost,var Integer np,var string anitem)
BEGIN
  Boolean testf;
  
  testf = GetNextTokenReturn(aost,np,anitem);
  RETURN;
END;

global
procedure GetNext2Sep(string aost,var Integer np,var string anitem)
BEGIN
  string 255 ost;
  string 255 nitem;
  string 1 nc;
  Boolean res,TrHs;  

  ost = aost;
  nitem = anitem;
  nitem = "";
  TrHs = true;
  while (TrHs) begin
    if (np>len(ost)) then begin TrHs = false; end;
    if (TrHs) then begin
      nc = Mid(ost,np,1);//  nc = ost[*np];
      if ((nc!=":") and (nc!="-") and (nc!="+") and
          (nc!="*") and (nc!=",") and (nc!=".")) then 
      begin
        TrHs = false;
      end;  
      if (TrHs) then begin
        nitem = nitem & nc;
        np = np + 1;    
      end;  
    end;  
  end;
  if (blank(nitem)) then begin
    res = false;
  end else begin
    res = true;
  end;  
  anitem = nitem;
  RETURN;  
END;

global
function Boolean GetNext3Sep(string aost,var Integer np,var string anitem)
BEGIN
  string 255 ost;
  string 255 nitem;
  string 1 nc;
  Boolean res,TrHs;  

  ost = aost;
  nitem = anitem;
  nitem = "";
  TrHs = true;
  while (TrHs) begin
    if (np>len(ost)) then begin TrHs = false; end;
    if (TrHs) then begin
      nc = Mid(ost,np,1);//  nc = ost[*np];
      if ((asc(nc)>=asc("0")) and (asc(nc)<=asc("9"))) then begin
        TrHs = false;
      end;  
      if ((asc(nc)>=asc("a")) and (asc(nc)<=asc("z"))) then begin
        TrHs = false;
      end;
      if ((asc(nc)>=asc("A")) and (asc(nc)<=asc("Z"))) then begin
        TrHs = false;
      end;      
      if (TrHs) then begin
        nitem = nitem & nc;
        np = np + 1;    
      end;  
    end;  
  end;
  if (blank(nitem)) then begin
    res = false;
  end else begin
    res = true;
  end;  
  anitem = nitem;
  GetNext3Sep = res;
  RETURN;  
END;

global
function Boolean AccInRange(string accn,string Numb)
BEGIN
  Boolean res;
  Boolean addflag;
  string 255 Nitem,Nitem2,tstr;
  string 5 nsep;
  Integer np;
  Boolean testf

  res = false;
  np = 0;

  ExtractObj(Numb,np,tstr);
  testf = nonblank(tstr);
  while (testf) begin
    Nitem = FirstInRange(tstr,10);
    Nitem2 = LastInRange(tstr,10);
    if (blank(Nitem2)) then begin
      if (Nitem==accn) then begin res = true; end;
    end else begin
      if ((accn>=Nitem) and (accn<=Nitem2)) then begin res = true; end;
    end;
    ExtractObj(Numb,np,tstr);
    testf = nonblank(tstr);
    if (res) then begin testf = false; end;
  end;
/*  
//this was too slow when run from CheckOTs
//if I made mistake by changing AccInRange please make 2 functions one for CheckOTs with new code and old code for 
//places with bugs caused by it

  GetNext2Sep(Numb,np,nsep);
  while (GetNextTokenReturn(Numb,np,Nitem)) begin
    if (nsep=="-") then begin 
      addflag = false;
    end else begin 
      addflag = true;
    end;  
    GetNext2Sep(Numb,np,nsep);
    if (nsep==".") then begin
//        GetNextToken(Numb,np,NRu);
        GetNext2Sep(Numb,np,nsep);
    end else begin
    end;    
    if (nsep==":") then begin
      GetNextToken(Numb,np,Nitem2);
      GetNext2Sep(Numb,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    if (blank(Nitem2)) then begin
      if (Nitem==accn) then begin res = true; end;
    end else begin
      if ((accn>=Nitem) and (accn<=Nitem2)) then begin res = true; end;
    end;
    if (res) then begin goto LAccInRange; end;
  end;  
LAccInRange:;  
 */
  AccInRange = res;
  RETURN;
END;

global
procedure GetAccText(record AccVc Accr,var string accname,Integer flen)
begin
  record CYBlock CYr;
  row AccVc Accrw;
  Integer rwcnt,i;

  accname = Left(Accr.Comment,flen);
  BlockLoad(CYr);
  if (CYr.AccInCompLang!=0) then begin
    rwcnt = MatRowCnt(Accr);
    for (i=0; i<rwcnt; i=i+1) begin
      MatRowGet(Accr,i,Accrw);
      if (CYr.LangCode==Accrw.LangCode) then begin
        accname = Left(Accrw.Text,flen);
        i = rwcnt;
      end;
    end;
  end;
  return;
end;

global
function Boolean GetAccName(string acc,var string accname,Integer flen)
BEGIN
  record AccVc Accr;
  Boolean Accs;
  string 255 tstr;

  accname = "";
  if (nonblank(acc)) then begin
    Accr.AccNumber = acc;
    Accs = ReadFirstKey("AccNumber",Accr,1,true);
    if (Accs) then begin
      GetAccText(Accr,accname,flen);
    end;
  end;
  if (Accs==false) then begin    
    tstr = USetStr(1023);
    accname = Left(tstr,flen);
  end;
  GetAccName = Accs;
  RETURN;
END;

global
function Integer GetAccNamCurVAT(string acc,var string accname,var string vatcod,Integer flen,string curncy)
BEGIN
  Integer res;
  record AccVc Accr;
  Boolean Accs;
  string 255 tstr;

  res = 1;
  accname = "";
  if (nonblank(acc)) then begin
    Accr.AccNumber = acc;
    Accs = ReadFirstKey("AccNumber",Accr,1,true);
    if (Accs) then begin
      res = 0;
      GetAccText(Accr,accname,flen);
      vatcod = Accr.VATCode;
      if ((nonblank(Accr.Curncy)) and nonblank(curncy)) then begin
        if (curncy!=Accr.Curncy) then begin 
          Accs = false; 
          res = 2;
        end;
      end;  
    end;
  end;
  if (Accs==false) then begin
    tstr = USetStr(1023);
    accname = Left(tstr,flen);
    vatcod = "";
  end;
  GetAccNamCurVAT = res;
  RETURN;
END;

global
function Boolean GetAccNamVAT(string acc,var string accname,var string vatcod,Integer flen)
BEGIN
  record AccVc Accr;
  Boolean Accs;
  string 255 tstr;

  accname = "";
  if (blank(acc)) then begin
    goto LGetAccNamVAT;
  end;
  Accr.AccNumber = acc;
  Accs = ReadFirstKey("AccNumber",Accr,1,true);
  if (Accs) then begin
    GetAccText(Accr,accname,flen);
    if (nonblank(vatcod)) then begin
      vatcod = Accr.VATCode;
    end;
  end;
LGetAccNamVAT:;
  if (Accs==false) then begin
    tstr = USetStr(1023);
    accname = Left(tstr,flen);
    vatcod = "";
  end;
  RETURN;
END;

global
procedure GetACShortAccount(string acshortcode,var string res,var string objects)
BEGIN
  record ACShortVc ACShortr;
  
  ACShortr.Code = acshortcode;
  if (ReadFirstMain(ACShortr,1,true)) then begin
    res = ACShortr.AccNumber;
    objects = ACShortr.Objects;
  end;
  RETURN;
END;

function Integer CheckOTs(string accstr,Array string ots,Integer ocnt,var string resstr)
BEGIN
  Integer res;
  Integer i,rwcnt;
  Integer j;
  record OTCheckBlock OTCheckr;
  row OTCheckBlock otcrw;

  res = 0;
  BlockLoad(OTCheckr);
  rwcnt = MatRowCnt(OTCheckr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(OTCheckr,i,otcrw);
    if (AccInRange(accstr,otcrw.Accs)) then begin
      for (j=0; j<ocnt; j=j+1) begin
        if (otcrw.ObjType==ots[j]) then begin 
          goto LSKIPCheckOTs;
        end;  
      end;
      res = 1083;
      resstr = otcrw.ObjType;
      goto LCheckOTs;
LSKIPCheckOTs:;
    end;
  end;  
LCheckOTs:;
  CheckOTs = res;
  RETURN;
END;

function Integer CheckOTsNew(string accstr,Array string ots,Integer ocnt,
                             Array string otcheckaccs,Array string otcheckobjtyps,Integer otcheckcnt,var string resstr)
BEGIN
  Integer res;
  Integer i,j,rwcnt;
  string 255 fracc,toacc; 

  res = 0;
  for (i=0; i<otcheckcnt; i=i+1) begin
    fracc = FirstInRange(otcheckaccs[i],10);
    toacc = LastInRange(otcheckaccs[i],10);
    if ((accstr>=fracc) and (accstr<=toacc))then begin
      for (j=0; j<ocnt; j=j+1) begin
        if (otcheckobjtyps[i]==ots[j]) then begin 
          goto LSKIPCheckOTsNew;
        end;  
      end;      
      res = 1083;
      resstr = otcheckobjtyps[i];
      goto LCheckOTsNew;
LSKIPCheckOTsNew:;
    end;
  end;  
LCheckOTsNew:;
  CheckOTsNew = res;
  RETURN;
END;

global
function Integer CheckObjs(string accstr,string orgobjstr,var string resstr)
BEGIN
  Integer res;
  string 255 rstr;
  Integer ocnt,j;
  record ObjVc RUr;
  record CUVc CUr;
  vector Boolean found;
  Array string 5 ots;
  Integer pos;
  string 255 ostr,objstr,maxobjstr;
  LongInt starttick;
  Integer maxobjcnt;
  record CYBlock CYb;

  starttick = GetCurTick;
  resstr = "";
  res = 0;
  if (IsStandardProduct) then begin
    maxobjstr = HasObjectsMaxNumber;
  end else begin
    maxobjstr = USetStr(1799);
  end;
  if (nonblank(maxobjstr)) then begin
    maxobjcnt = StringToInt(maxobjstr);
    if (CountObjects(orgobjstr)>maxobjcnt) then begin
      res = 20577;
      goto LCheckObjs;
    end;
  end;
  if (len(orgobjstr)>60) then begin//len of NL transaction Obj
    res = 20577;
    goto LCheckObjs;
  end;
  BlockLoad(CYb);
  pos = 0;
  ocnt = 0;
  objstr = orgobjstr;
  AutoObj(objstr);
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    ots[ocnt] = "";
    if (nonblank(ostr)) then begin
      ots[ocnt] = "";
      RUr.Code = ostr;
      found["ObjVc"] = ReadFirstMain(RUr,1,true);
      if (found["ObjVc"]==false) then begin
        if (CYb.ContactCodeAsObject!=0) then begin
          CUr.Code = ostr;
          found["CUVc"] = ReadFirstMain(CUr,1,true);
        end;
      end;
      if (found["ObjVc"]==false and found["CUVc"]==false) then begin
        res = 0;
        if (blank(rstr)) then begin
          rstr = "  ";
          rstr = rstr & ostr;
        end else begin
          rstr = rstr & ",";
          rstr = rstr & ostr;
        end;
      end else begin
        if (found["ObjVc"]) then begin
          if (RUr.TerminateFlag!=0) then begin
            res = 1084;
            resstr = ostr;
            goto LCheckObjs;
          end;
          if (nonblank(RUr.OTCode)) then begin
            ots[ocnt] = RUr.OTCode;
            for (j=0;j<ocnt ;j=j+1) begin
              if (ots[j]==ots[ocnt]) then begin
                res = 1071;
                resstr = ostr;
                goto LCheckObjs;
              end;
            end;
          end;
        end;
        if (found["CUVc"]) then begin
          if (CUr.blockedFlag!=0) then begin
            res = 1084;
            resstr = ostr;
            goto LCheckObjs;
          end;
        end;
      end;
    end;
    ExtractObj(objstr,pos,ostr);
    ocnt = ocnt + 1;
  end;
  if (nonblank(rstr)) then begin
    res = 1043;
    resstr = rstr;
    goto LCheckObjs;
  end;
  if (true) then begin
//  if (found["ObjVc"]) then begin //object missing only when we FOUND object ? sick'o ..
    if (nonblank(accstr)) then begin
      res = CheckOTs(accstr,ots,ocnt,resstr);
      if (res!=0) then begin
        goto LCheckObjs;
      end;
    end;
  end;
LCheckObjs:;
  CheckObjs = res;
  RETURN;
END;

global
function Integer CheckObjsNew(string accstr,string orgobjstr,
                              Array string otcheckaccs,Array string otcheckobjtyps,Integer otcheckcnt,var string resstr)
BEGIN
  Integer res;
  string 255 rstr;
  Integer ocnt,i,j;
  record ObjVc RUr;
  Boolean found;
  Array string 5 ots;
  Integer pos;
  string 255 ostr,objstr,maxobjstr;
  vector Boolean otfound;
  string 255 fracc,toacc; 
  Integer maxobjcnt;

  resstr = "";
  res = 0;  
  if (IsStandardProduct) then begin
    maxobjstr = HasObjectsMaxNumber;
  end else begin
    maxobjstr = USetStr(1799);
  end;
  if (nonblank(maxobjstr)) then begin
    maxobjcnt = StringToInt(maxobjstr);
    if (CountObjects(orgobjstr)>maxobjcnt) then begin
      res = 20577;
      goto LCheckObjsNew;
    end;
  end;
  pos = 0;
  ocnt = 0;
  objstr = orgobjstr;
  AutoObj(objstr);
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    ots[ocnt] = "";
    if (nonblank(ostr)) then begin
      ots[ocnt] = "";
      RUr.Code = ostr;
      found = ReadFirstMain(RUr,1,true);
      if (found==false) then begin
        res = 0;
        if (blank(rstr)) then begin
          rstr = "  ";
          rstr = rstr & ostr;
        end else begin
          rstr = rstr & ",";
          rstr = rstr & ostr;
        end;
      end else begin
        if (RUr.TerminateFlag!=0) then begin
          res = 1084;
          resstr = ostr;
          goto LCheckObjsNew;
        end;
        if (nonblank(RUr.OTCode)) then begin
          if (otfound[RUr.OTCode]) then begin
            res = 1071;
            resstr = ostr;
            goto LCheckObjsNew;
          end;
          otfound[RUr.OTCode] = true;        
/*        
          ots[ocnt] = RUr.OTCode;
          for (j = 0 ;j<ocnt ;j=j+1) begin
            if (ots[j]==ots[ocnt]) then begin
              res = 1071;
              resstr = ostr;
              goto LCheckObjsNew;
            end;
          end;
*/          
        end;
      end;
    end;
    ExtractObj(objstr,pos,ostr);
    ocnt = ocnt + 1;
  end;
  if (nonblank(rstr)) then begin
    res = 1043;
    resstr = rstr;
    goto LCheckObjsNew;
  end;
  if (nonblank(accstr)) then begin
/*  
    res = CheckOTsNew(accstr,ots,ocnt,otcheckaccs,otcheckobjtyps,otcheckcnt,resstr);
*/        

    for (i=0; i<otcheckcnt; i=i+1) begin
      fracc = FirstInRange(otcheckaccs[i],10);
      toacc = LastInRange(otcheckaccs[i],10);
      if ((accstr>=fracc) and (accstr<=toacc))then begin
        if (otfound[otcheckobjtyps[i]]==false) then begin
          res = 1083;
          resstr = otcheckobjtyps[i];
          goto LCheckObjsNew;
        end;
      end;
    end;    
    if (res!=0) then begin
      goto LCheckObjsNew;
    end;
  end;
LCheckObjsNew:;
  CheckObjsNew = res;
  RETURN;
END;

global
function Integer CheckVATCodes(string accstr,string vatcode,string taxtemplatecode,var string resstr)
begin
  Integer res;
  record VATCodeControlBlock VATCCb;
  row VATCodeControlBlock VATCCbrw;
  Integer i,rwcnt;
  record CYBlock CYb;
  string 255 firstacc,lastacc;
  Boolean testf;

  resstr = "";
  BlockLoad(CYb);  
  BlockLoad(VATCCb);  
  rwcnt = MatRowCnt(VATCCb);
  if (rwcnt>0) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(VATCCb,i,VATCCbrw);
      testf = false;
      if (InString(VATCCbrw.Accounts,",")==0) then begin
        firstacc = FirstInRange(VATCCbrw.Accounts,10);
        lastacc = LastInRange(VATCCbrw.Accounts,10);
        if ((accstr>=firstacc) and (accstr<=lastacc)) then begin testf = true; end;
      end else begin
        if (SetInSet(accstr,VATCCbrw.Accounts)) then begin testf = true; end;
      end;
      if (testf) then begin
        res = 24218;
        if (CYb.UseTaxTemplatesforTaxCalc!=0) then begin
          if (VATCCbrw.TaxTemplateCode==taxtemplatecode) then begin
            res = 0;
            goto LCheckVATCodes;
          end;
        end else begin
          if (VATCCbrw.VATCode==vatcode) then begin
            res = 0;
            goto LCheckVATCodes;
          end;
        end;
      end;
    end;
  end;
LCheckVATCodes:;
  if (res!=0) then begin
    if (CYb.UseTaxTemplatesforTaxCalc!=0) then begin
      resstr = taxtemplatecode;
    end else begin
      resstr = vatcode;
    end;
  end;
  CheckVATCodes = res;
  return;
end;

global
function string 255 FindINObjects(string itemobjects,string itemgroup)
BEGIN
  string 255 res;
  record ITVc ITr;
  
  res = itemobjects;
  if (blank(res)) then begin
    ITr.Code = itemgroup;
    if (ReadFirstMain(ITr,1,true)) then begin
      res = ITr.Objects;
    end;
  end;
  FindINObjects = res;
  RETURN;
END;

global
procedure GetINObjects(string artcode,var string res)
BEGIN
  record INVc INr;
  
  res = "";
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)) then begin
    res = FindINObjects(INr.Objects,INr.Group);
  end;
  RETURN;
END;

global
function string 10 FindWithHoldAcc(string apacc, string objects)
BEGIN
  Integer errcode;
  record APAccBlock APAccRec;
  string 255 tstr;
  string 10 accnr;
    
  errcode = 0;
  if (nonblank(objects)) then begin
    errcode = CheckObjs(apacc,objects,tstr);
  end;  
  if (errcode==0) then begin
    BlockLoad(APAccRec);
    accnr = APAccRec.WHTaxAcc;
  end else begin
    accnr = apacc;
  end;
  FindWithHoldAcc = accnr;
  RETURN;
END;  

global
updating procedure SetMailboxReadFlagHAL(LongInt confsernr,LongInt sernr,Integer accode)
BEGIN
  record MailReadVc mrr;
  record MailReadVc locmrr;
  string 60 mailboxcode,mailboxname;  
  LongInt l;

  mrr.mailSerNr = sernr;
  mrr.mailBoxNr = confsernr;
  mrr.accode = accode;
  mrr.fDate = CurrentDate;
  mrr.fTime = CurrentTime;
  if (accode==0) then begin
//    OnReadMail();
  end;
  RecordCopy(locmrr,mrr);
  if (ReadFirstMain(locmrr,0,true)==false) then begin
    if (RecordStore(mrr,false)) then begin
    end;
  end;
  RETURN;
END;

global
procedure InitOTCheckArray(record OTCheckBlock OTCheckr,
                     Array string otcheckaccs,Array string otcheckobjtyps,var Integer otcheckcnt)
begin
  row OTCheckBlock otcrw;
  Integer i,rwcnt,pos;
  string 255 tstr,fracc,toacc;

  BlockLoad(OTCheckr);
  rwcnt = MatRowCnt(OTCheckr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(OTCheckr,i,otcrw);
    pos = 0;
    ExtractObj(otcrw.Accs,pos,tstr);
    while (nonblank(tstr)) begin
      fracc = FirstInRange(tstr,10);
      toacc = LastInRange(tstr,10);
      otcheckobjtyps[otcheckcnt] = otcrw.ObjType;
      otcheckaccs[otcheckcnt] = fracc & ":" & toacc;
      otcheckcnt = otcheckcnt + 1;
      ExtractObj(otcrw.Accs,pos,tstr);
    end;
  end;
  return;
end;

global
procedure VerifyRowObjects(String Ledger,String HeaderObj,String RowObj,String AccStr,var Integer errcode,var String errstr,
                          var Boolean initotcheckf,Array string otcheckaccs,Array string otcheckobjtyps,var Integer otcheckcnt)
BEGIN
  record OTCheckBlock OTCheckr;
  String 255 Objstr;
  record AccBlock ARAccRec; 
  record APAccBlock APAccb; 
 
  Objstr = RowObj;
  switch (Ledger) begin
    case "SL":
      BlockLoad(ARAccRec);
      if (ARAccRec.SkipObjectsOnIVFromHeader==0) then begin
        Objstr = AddObjectToObjectList(Objstr,HeaderObj);
      end;    
    case "PL":
      BlockLoad(APAccb);  
      if (APAccb.SkipObjectsOnVIFromHeader==0) then begin
        Objstr = AddObjectToObjectList(Objstr,HeaderObj);
      end;    
    case "NONE":
        Objstr = AddObjectToObjectList(Objstr,HeaderObj);
  end;
  if (initotcheckf==false) then begin
    InitOTCheckArray(OTCheckr,otcheckaccs,otcheckobjtyps,otcheckcnt);
    initotcheckf = true;
  end;
  errcode = CheckObjsNew(AccStr,Objstr,otcheckaccs,otcheckobjtyps,otcheckcnt,errstr);     
  RETURN;
END;