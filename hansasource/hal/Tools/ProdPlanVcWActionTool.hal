external function string 255 FindMachineforItem(string,string);
external procedure CalcPlannedStartDate(string,Date,var val,Time);
external function LongInt TimeToMinutes(Time);
external procedure ProdSumup(var record ProdVc);
external function roundmode SetRoundModeD(Integer);
external procedure CalcProdTime(record RecVc,val,var val,var time);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean PasteRecInProdOrder(var record ProdOrderVc);
external function Boolean PasteRecInProd(var record ProdVc);
external procedure CalcProdDuration(var record ProdOrderVc);
external procedure CalcProdTime(record RecVc,val,var val,var time);

function val RecipeOutQty(string recipe,string itemcode)
begin
  val res;
  record RecVc Recr;
  row RecVc Recrw;
  Integer rwcnt,i;

  Recr.Code = recipe;
  if (ReadFirstMain(Recr,1,true)) then begin
    rwcnt = MatRowCnt(Recr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Recr,i,Recrw);
      if (Recrw.Item==itemcode) then begin
        if (Recrw.OutQty>0) then begin
          res = Recrw.OutQty;
          i = rwcnt;
        end;
      end;
    end;
  end;
  RecipeOutQty = res;
  return;
end;

function val RecipeInQty(string recipe,LongInt AboveRecipeRow)
begin
  val res;
  record RecVc Recr;
  row RecVc Recrw;

  Recr.Code = recipe;
  if (ReadFirstMain(Recr,1,true)) then begin
    if (AboveRecipeRow>=MatRowCnt(Recr)) then begin
      res = 1.00;
    end else begin
      MatRowGet(Recr,AboveRecipeRow,Recrw);
      res = Recrw.InQty;
    end;
  end;
  RecipeInQty = res;
  return;
end;

global
procedure GetNewProdStart(string artcode,string reccode,val sugqty,val qty,Date thedat,var val days,var Date dat)
begin
  record RecVc Recr;
  val theqty;
  val t,dayqty;
  Time timeqty;
  Date bldat;
  record ProdSettingsBlock PSb;
  LongInt mins;
  string 255 machine;

  BlockLoad(PSb); 
  days = 0;
  dat = thedat;
  if (blank(qty)) then begin
    theqty = sugqty;
  end else begin
    theqty = qty;
  end;
  Recr.Code = reccode;
  if (ReadFirstMain(Recr,1,true)) then begin
    CalcProdTime(Recr,theqty,dayqty,timeqty);
    if (PSb.RoundUpToOneDay!=0) then begin
      mins = TimeToMinutes(timeqty);
      if (mins>60) then begin
        dayqty = dayqty + 1;
      end;
    end;
    machine = FindMachineforItem(artcode,reccode);
    CalcPlannedStartDate(machine,thedat,dayqty,timeqty);
    dayqty = dayqty + PSb.DayBuffer;
    
/*
    if (SFPb.RoundOff==0) then begin
      days = Round(dayqty+0.49,SFPb.RoundOff);
    end else begin
      days = Round(dayqty,SFPb.RoundOff);
    end;
*/
    days = Round(dayqty+0.49,SetRoundModeD(0));
    if (days<0) then begin
      days = 0;
    end;
    dat = AddDay(thedat,-days);
  end;    
  return;
end;

global
procedure RecalcProdStart(var record ProdPlanVc ProdPlanr,Date thedat,Integer rownr,Boolean docalc)
begin
  row ProdPlanVc ProdPlanrw;
  Integer rwcnt,i;
  record INVc INr;
  val days;
  Date dat;
  
  MatRowGet(ProdPlanr,rownr,ProdPlanrw);
  if (ReadFirstItem(ProdPlanrw.ItemCode,INr,false,false)) then begin
    if (docalc) then begin
      GetNewProdStart(INr.Code,INr.Recepy,ProdPlanrw.SugQty,ProdPlanrw.Qty,thedat,days,dat);
    end else begin
      days = ProdPlanrw.ProdDays;
      if (days<0) then begin
        days = 0;
      end;
      dat = AddDay(thedat,-days);
    end;
    ProdPlanrw.ProdDays = days;
    ProdPlanrw.ProdStartDate = dat;
    ProdPlanrw.NeededDate = AddDay(ProdPlanrw.ProdStartDate,days);
    MatRowPut(ProdPlanr,rownr,ProdPlanrw);
  end;
  rwcnt = MatRowCnt(ProdPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i!=rownr) then begin
      MatRowGet(ProdPlanr,i,ProdPlanrw);
      if (ProdPlanrw.stp==kProdPlanRowTypeSubrecipe) then begin
        if (ProdPlanrw.ProdPlanRow==rownr) then begin
          RecalcProdStart(ProdPlanr,dat,i,true);
        end;
      end;
    end;
  end;
  return;
end;

function Integer GetRecalcProdStartRow(record ProdPlanVc ProdPlanr,Integer rownr)
begin
  row ProdPlanVc ProdPlanrw;
  Integer res;
  
  res = rownr;
  MatRowGet(ProdPlanr,rownr,ProdPlanrw);
  if (ProdPlanrw.stp==kProdPlanRowTypeSubrecipe) then begin
    res = GetRecalcProdStartRow(ProdPlanr,ProdPlanrw.ProdPlanRow);
  end;
  GetRecalcProdStartRow = res;
  return;
end;

function val AlreadyInProdPlan(record ProdPlanVc ProdPlanr,string recipe,Integer AboveRecipeRow,Integer currownr,Boolean sugqtyf)
begin
  val res;
  Integer rwcnt,i;
  row ProdPlanVc subProdPlanrw;
  row ProdPlanVc ProdPlanrw;
  Boolean testf
  
  rwcnt = MatRowCnt(ProdPlanr);
  for (i=0;i<currownr;i=i+1) begin
    MatRowGet(ProdPlanr,i,subProdPlanrw);
    if (subProdPlanrw.stp==kProdPlanRowTypeSubrecipe) then begin
      MatRowGet(ProdPlanr,subProdPlanrw.ProdPlanRow,ProdPlanrw);
      testf = true;
      if (ProdPlanrw.Recipe!=recipe) then begin testf = false; end;
      if (subProdPlanrw.AboveRecipeRow!=AboveRecipeRow) then begin testf = false; end;
      if (testf) then begin
        if (sugqtyf) then begin
          res = res + subProdPlanrw.SugQty;
        end else begin
          res = res + subProdPlanrw.Qty;
        end;
      end;
    end;
  end;
  AlreadyInProdPlan = res;
  return;
end;

procedure CalcSugQty(var record ProdPlanVc ProdPlanr,string recipe,Integer orgrow,Integer subrownr,val prcval,Integer action)
begin
  row ProdPlanVc ProdPlanrw;
  Integer rwcnt,i;
  val prcval2,alreadyinplan;

  rwcnt = MatRowCnt(ProdPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i!=subrownr) then begin
      MatRowGet(ProdPlanr,i,ProdPlanrw);
      if (ProdPlanrw.stp==kProdPlanRowTypeSubrecipe) then begin
        if ((ProdPlanrw.ProdPlanRow==orgrow) and (subrownr==-1)) or (ProdPlanrw.ProdPlanRow==subrownr) then begin
          ProdPlanrw.SugQty = prcval * RecipeInQty(recipe,ProdPlanrw.AboveRecipeRow);
          alreadyinplan = AlreadyInProdPlan(ProdPlanr,recipe,ProdPlanrw.AboveRecipeRow,i,true);
          ProdPlanrw.SugQty = ProdPlanrw.SugQty - alreadyinplan;
          if (ProdPlanrw.SugQty>0) then begin
            MatRowPut(ProdPlanr,i,ProdPlanrw);
            prcval2 = (ProdPlanrw.SugQty/RecipeOutQty(ProdPlanrw.Recipe,ProdPlanrw.ItemCode));
            CalcSugQty(ProdPlanr,ProdPlanrw.Recipe,orgrow,i,prcval2,action);
          end;
        end;
      end;
    end;
  end;
  return;
end;

procedure CalcQty(var record ProdPlanVc ProdPlanr,string recipe,Integer orgrow,Integer subrownr,val prcval,Integer action)
begin
  row ProdPlanVc ProdPlanrw;
  Integer rwcnt,i;
  val prcval2,alreadyinplan;

  rwcnt = MatRowCnt(ProdPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i!=subrownr) then begin
      MatRowGet(ProdPlanr,i,ProdPlanrw);
      if (ProdPlanrw.stp==kProdPlanRowTypeSubrecipe) then begin
        if ((ProdPlanrw.ProdPlanRow==orgrow) and (subrownr==-1)) or (ProdPlanrw.ProdPlanRow==subrownr) then begin
          ProdPlanrw.Qty = prcval * RecipeInQty(recipe,ProdPlanrw.AboveRecipeRow);
          alreadyinplan = AlreadyInProdPlan(ProdPlanr,recipe,ProdPlanrw.AboveRecipeRow,i,false);
          ProdPlanrw.Qty = ProdPlanrw.Qty - alreadyinplan;
          if (ProdPlanrw.Qty>0) then begin
            MatRowPut(ProdPlanr,i,ProdPlanrw);
            prcval2 = (ProdPlanrw.Qty/RecipeOutQty(ProdPlanrw.Recipe,ProdPlanrw.ItemCode));
            CalcQty(ProdPlanr,ProdPlanrw.Recipe,orgrow,i,prcval2,action);
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
procedure ProdPlanDClassQtyRemote(var record ProdPlanVc ProdPlanr,Integer rownr,Integer action)
begin
  row ProdPlanVc ProdPlanrw;
  val prcval;

  MatRowGet(ProdPlanr,rownr,ProdPlanrw);
  ProdPlanrw.AdjQtyDate = CurrentDate;
  MatRowPut(ProdPlanr,rownr,ProdPlanrw);
  prcval = ProdPlanrw.Qty/RecipeOutQty(ProdPlanrw.Recipe,ProdPlanrw.ItemCode);
  CalcQty(ProdPlanr,ProdPlanrw.Recipe,rownr,ProdPlanrw.ProdPlanRow,prcval,action);
//*PPSD  RecalcProdStart(ProdPlanr,ProdPlanr.EndDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  RecalcProdStart(ProdPlanr,ProdPlanr.StartDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  return;
end;

global
procedure ProdPlanDClassSugQtyRemote(var record ProdPlanVc ProdPlanr,Integer rownr,Integer action)
begin
  row ProdPlanVc ProdPlanrw;
  val prcval;

  MatRowGet(ProdPlanr,rownr,ProdPlanrw);
  prcval = ProdPlanrw.SugQty/RecipeOutQty(ProdPlanrw.Recipe,ProdPlanrw.ItemCode);
  CalcSugQty(ProdPlanr,ProdPlanrw.Recipe,rownr,ProdPlanrw.ProdPlanRow,prcval,action);
//*PPSD  RecalcProdStart(ProdPlanr,ProdPlanr.EndDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  RecalcProdStart(ProdPlanr,ProdPlanr.StartDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  return;
end;

procedure PasteRecepy(record ProdPlanVc ProdPlanr,val plansugqty,val planqty,string itemcode,string recepy,var LongInt reclevelrownr)
begin
  record INVc INr;
  record RecVc Recr;
  row RecVc Recrw;
  Integer i,rwcnt;
  val prcval,newqty,newsugqty;
  row ProdPlanVc ProdPlanrw;
  LongInt subpprownr,pprownr;

  Recr.Code = recepy;
  if (ReadFirstMain(Recr,1,true)) then begin
    rwcnt = MatRowCnt(Recr);
    for(i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Recr,i,Recrw);
      if (Recrw.Item==itemcode) then begin
        if (Recrw.OutQty>0) then begin
          prcval = Recrw.OutQty;
          i = rwcnt;
        end;
      end;
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Recr,i,Recrw);
      if (Recrw.InQty!=0) then begin
        INr.Code = Recrw.Item;
        if (ReadFirstMain(INr,1,true)) then begin
          newqty = round(((planqty * Recrw.InQty) / prcval)+49999.00/100000.00,SetRoundModeD(0));
          newsugqty = round(((plansugqty * Recrw.InQty) / prcval)+49999.00/100000.00,SetRoundModeD(0));
          if (nonblank(INr.Recepy)) then begin
            ClearRow(ProdPlanr,ProdPlanrw,2);
            ProdPlanrw.ItemCode = INr.Code;
            ProdPlanrw.Spec = INr.Name;
            ProdPlanrw.SugQty = newsugqty;            
            ProdPlanrw.Qty = newqty;
            if (ProdPlanrw.SugQty==0) then begin
              ProdPlanrw.SugQty = blankval;
            end;
            if (ProdPlanrw.Qty==0) then begin
              ProdPlanrw.Qty = blankval;
            end;
            ProdPlanrw.ProdPlanRow = reclevelrownr;
            ProdPlanrw.Recipe = INr.Recepy;
            ProdPlanrw.AboveRecipeRow = i;
            pprownr = MatRowCnt(ProdPlanr);
            MatRowInsert(ProdPlanr,pprownr,ProdPlanrw);
            PasteRecepy(ProdPlanr,ProdPlanrw.SugQty,ProdPlanrw.Qty,ProdPlanrw.ItemCode,INr.Recepy,pprownr);
          end;
        end;
      end;
    end;
  end;
  return;
end;

function string 255 FindItemRecipe(string itemcode,Date startdate,Date enddate)
begin
  string 255 res;
  record ProdItemVc PIr;
  Boolean found,testf;
  record INVc INr;
  
  found = true;
  PIr.ItemCode = itemcode;
  PIr.StartDate = startdate;
  while (LoopKey("ItemCode",PIr,2,found)) begin
    if (PIr.ItemCode!=itemcode) then begin found = false; end;
    if (PIr.StartDate>enddate) then begin found = false; end;
    if (PIr.EndDate<startdate) then begin found = false; end;
    if (found) then begin
      res = PIr.Recipe;
      goto LFindItemRecipe;
    end;
  end;
  ResetLoop(PIr);
  found = true;
  PIr.ItemCode = itemcode;
  PIr.EndDate = startdate;
  while (LoopKey("ItemCodeED",PIr,2,found)) begin
    if (PIr.ItemCode!=itemcode) then begin found = false; end;
    if (PIr.EndDate<startdate) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (PIr.StartDate>enddate) then begin testf = false; end;    
      if (testf) then begin
        res = PIr.Recipe;
        goto LFindItemRecipe;
      end;
    end;
  end;
  INr.Code = itemcode;
  if (ReadFirstMain(INr,1,true)) then begin
  end;
  res = INr.Recepy;
LFindItemRecipe:;  
  FindItemRecipe = res;
  return;
end;

global
procedure ProdPlanDClassItemCodeRemote(var record ProdPlanVc ProdPlanr,Integer rownr)
begin
  row ProdPlanVc ProdPlanrw;
  record INVc INr;
  LongInt pprownr;  
  
  MatRowGet(ProdPlanr,rownr,ProdPlanrw);
  if (ReadFirstItem(ProdPlanrw.ItemCode,INr,false,false)) then begin
    ProdPlanrw.Spec = INr.Name;
  end;
  ProdPlanrw.Recipe = FindItemRecipe(INr.Code,ProdPlanr.StartDate,ProdPlanr.EndDate);
  MatRowPut(ProdPlanr,rownr,ProdPlanrw);
  if (nonblank(INr.Recepy)) then begin
    pprownr = rownr;
    PasteRecepy(ProdPlanr,ProdPlanrw.SugQty,ProdPlanrw.Qty,ProdPlanrw.ItemCode,INr.Recepy,pprownr);
  end;
//*PPSD  RecalcProdStart(ProdPlanr,ProdPlanr.EndDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  RecalcProdStart(ProdPlanr,ProdPlanr.StartDate,GetRecalcProdStartRow(ProdPlanr,rownr),true);
  return;
end;

function Boolean FindPlannedQty(record INVc INp,record RecVc Recp,var val curstp)
BEGIN
  Boolean res;
  val outsum,t,t2;
  row RecVc Recrw;
  Integer i,rwcnt;
  
  Recp.Code = INp.Recepy;
  res = ReadFirstMain(Recp,1,true);
  t2 = 1;
  rwcnt = MatRowCnt(Recp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Recp,i,Recrw);
    if (INp.Code==Recrw.Item) then begin
      outsum = outsum + Recrw.OutQty;
    end;
  end;
  if (outsum>0) then begin
    t = curstp/outsum;
    curstp = Round(t,SetRoundModeD(0));
    t = curstp*outsum;
    if (t<t2) then begin
      curstp = 1;
    end;
  end else begin
    res = false;
  end;
  FindPlannedQty = res;
  RETURN;
END;

global
updating function Integer CreateProdOrderFromProdPlan(var record ProdPlanVc PPr,Date frdat,Date todat)
begin
  Integer res;
  record ProdOrderVc ProdOr;
  record ProdVc Prodr;
  record ProdSettingsBlock PSb;
  Integer i,rwcnt;
  row ProdPlanVc PPrw;
  Boolean testf;
  Integer prodi,prodcnt;
  row ProdVc Prodrw;
  record INVc INr;
  record RecVc Recr;
  val qty;
  
  res = 1;
  if (UserCanAction("ProdPlanOK",true)==false) then begin
    res = 1274;
    goto LCreateProdOrderFromProdPlan;
  end;
  BlockLoad(PSb);
  rwcnt = MatRowCnt(PPr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PPr,i,PPrw);
    testf = true;
    if (PPrw.ProdOrder>0) then begin
      testf = false;
    end;
    if (nonblankdate(frdat)) then begin
      if (DateInRange(PPrw.ProdStartDate,frdat,todat)==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      if (PSb.AutoGenProd==0) then begin
        RecordNew(Prodr);
        Prodr.RowsHoldActualQty = PSb.ProdRowsHoldActualQty;
        Prodr.Recepy = PPrw.Recipe;
        Prodr.StartDate = PPrw.ProdStartDate;
        Prodr.ProdDate = PPrw.NeededDate;
        if (PasteRecInProd(Prodr)) then begin end;
        Prodr.SerNr = NextSerNr("ProdVc",Prodr.ProdDate,-1,false,"");
        if (nonblank(PPrw.Qty)) then begin
          Prodr.Qty = PPrw.Qty;
        end else begin
          Prodr.Qty = PPrw.SugQty;
        end;
        switch (Prodr.RowsHoldActualQty) begin
          case 1: 
            prodcnt = MatRowCnt(Prodr);
            for (prodi=0;prodi<prodcnt;prodi=prodi+1) begin         
              MatRowGet(Prodr,prodi,Prodrw);
              if (Prodrw.OutQty>0) then begin
                prodi = prodcnt;
              end;
            end;
            Prodr.Qty = Prodr.Qty/Prodrw.OutQty;
            for (prodi=0;prodi<prodcnt;prodi=prodi+1) begin         
              MatRowGet(Prodr,prodi,Prodrw);
              if (Prodrw.InQty>0) then begin
                Prodrw.InQty = Prodrw.InQty*Prodr.Qty;
              end;
              if (Prodrw.OutQty>0) then begin
                Prodrw.OutQty = Prodrw.OutQty*Prodr.Qty;
              end;
              MatRowPut(Prodr,prodi,Prodrw);
            end;          
          otherwise
            if (ReadFirstItem(PPrw.ItemCode,INr,false,false)) then begin
              Recr.Code = INr.Recepy;
              if (ReadFirstMain(Recr,1,true)) then begin
                qty = Prodr.Qty;
                if (FindPlannedQty(INr,Recr,qty)) then begin
                end;
                Prodr.Qty = qty;
              end;
            end;
        end;
                
//        CalcProdTime(Recp,Prodr.Qty,daystoadd,timeqty);
        if (Prodr.SerNr>0) then begin
          ProdSumup(Prodr);
          if (RecordStore(Prodr,false)) then begin end;
          PPrw.ProdOrder = Prodr.SerNr;
          MatRowPut(PPr,i,PPrw);
          res = 0;
        end;
      end else begin
        RecordNew(ProdOr);
        ProdOr.Recipe = PPrw.Recipe;
        ProdOr.StartDate = PPrw.ProdStartDate;
        ProdOr.PlannedStartDate = PPrw.ProdStartDate;
        ProdOr.DueDate = PPrw.NeededDate;
        if (PasteRecInProdOrder(ProdOr)) then begin end;
        ProdOr.SerNr = NextSerNr("ProdOrderVc",ProdOr.StartDate,-1,false,"");
        if (nonblank(PPrw.Qty)) then begin
          ProdOr.Qty = PPrw.Qty;
        end else begin
          ProdOr.Qty = PPrw.SugQty;
          if (ReadFirstItem(PPrw.ItemCode,INr,false,false)) then begin
            Recr.Code = PPrw.Recipe;
            if (ReadFirstMain(Recr,1,true)) then begin
              qty = ProdOr.Qty;
              if (FindPlannedQty(INr,Recr,qty)) then begin
              end;
              ProdOr.Qty = qty;
            end;
          end;              
        end;
        CalcProdDuration(ProdOr);
        if (ProdOr.SerNr>0) then begin
          if (RecordStore(ProdOr,false)) then begin end;
          PPrw.ProdOrder = ProdOr.SerNr;
          MatRowPut(PPr,i,PPrw);
          res = 0;
        end;
      end;
    end;
  end;
LCreateProdOrderFromProdPlan:;  
  if (res==0) then begin
    PPr.OKFlag = 1;
  end;
  CreateProdOrderFromProdPlan = res;
  return;
end;
