external procedure PUCalcPerc(val,string,var val);
external procedure MulVATIVExecute(string,val,var val,var val,Integer,Integer,roundmode);
external function roundmode DefaultRoundMode();
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);

global
updating procedure UpdateVarianceStatusRow(LongInt PONr,LongInt OrdRow,val PUQuant,val PUAmount,val PUBaseAmount,val VIQuant,val VIAmount,val VIBaseAmount,val DoneBaseAmount)
BEGIN
  record VarianceStatusVc VarStatr;
  record VarianceStatusVc oldVarStatr;
  Boolean found,bookf,deletef;
  val q;

  VarStatr.PONr = PONr;
  VarStatr.OrdRow = OrdRow;
  found = ReadFirstMain(VarStatr,2,true);
  if (found) then begin
    RecordCopy(oldVarStatr,VarStatr);
  end else begin
    VarStatr.PONr = PONr;
    VarStatr.OrdRow = OrdRow;
  end;
  if (VarStatr.OrdRow>=0) then begin
    VarStatr.PUQuant = VarStatr.PUQuant + PUQuant;
    VarStatr.PUAmount = VarStatr.PUAmount + PUAmount;
    VarStatr.PUBaseAmount = VarStatr.PUBaseAmount + PUBaseAmount;
    VarStatr.VIQuant = VarStatr.VIQuant + VIQuant;
    VarStatr.VIAmount = VarStatr.VIAmount + VIAmount;
    VarStatr.VIBaseAmount = VarStatr.VIBaseAmount + VIBaseAmount;
    VarStatr.DoneAmount = VarStatr.DoneAmount + DoneBaseAmount;
    if (VarStatr.PUQuant-VarStatr.DoneQuant<VarStatr.VIQuant-VarStatr.DoneQuant) then begin
      q = VarStatr.PUQuant-VarStatr.DoneQuant;
    end else begin
      q = VarStatr.VIQuant-VarStatr.DoneQuant;
    end;  
    VarStatr.DoneQuant = VarStatr.DoneQuant + q;

    if ((VarStatr.DoneQuant==VarStatr.PUQuant) and (VarStatr.DoneQuant==VarStatr.VIQuant)) then begin
//      deletef = true; no deleting, it must stay in case Credit Note and ret goods to supplier arrives
    end;
  end else begin
    VarStatr.PUQuant = PUQuant;
    VarStatr.VIQuant = VIQuant;
    VarStatr.PUAmount = VarStatr.PUAmount + PUAmount;
    VarStatr.PUBaseAmount = VarStatr.PUBaseAmount + PUBaseAmount;
    VarStatr.VIAmount = VarStatr.VIAmount + VIAmount;
    VarStatr.VIBaseAmount = VarStatr.VIBaseAmount + VIBaseAmount;
    if (VarStatr.VIQuant==VarStatr.PUQuant) then begin
      deletef = true; //deleting for extra costs only
    end;        
  end;
  if (found) then begin
    if (deletef) then begin
      RecordDelete(oldVarStatr);
    end else begin
      if (RecordUpdate(oldVarStatr,VarStatr,false)) then begin end;
    end;
  end else begin
    if (RecordStore(VarStatr,false)) then begin end;
  end;
  RETURN;
END;

global
updating procedure UpdateVarianceStatusPU(record PUVc PUr)
BEGIN
  row PUVc PUrw;
  Integer i,rwcnt;
  record AccBlock ARAccb;
  val vatv,t1,t;
  roundmode rm;
  val v,bv;
  LongInt PONr;
  Boolean extracostvarf;
  
  BlockLoad(ARAccb);
  if (ARAccb.BookPriceVar!=0) then begin  
    rwcnt = MatRowCnt(PUr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUr,i,PUrw);
      if (PUrw.OrdRow>=0) then begin
        PONr = PUrw.PONr;
        if (PONr<=0) then begin PONr = PUr.PONr; end;      
        if (PONr>0) then begin
          if (PUr.InclVAT!=0) then begin
            rm = DefaultRoundMode;
            rm.decimals = 5;
            MulVATIVExecute(PUrw.VATCode,PUrw.UPrice,vatv,t1,PUr.InclVAT,0,rm);
  //            MulVATIV(PUrw.VATCode,PUrw.UPrice,vatv,t1,PUr.InclVAT,0);
            v = Round(PUrw.Quant*(PUrw.UPrice-vatv),DefaultRoundMode);
            bv = MulRateToBase1(PUr.CurncyCode,v,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
            UpdateVarianceStatusRow(PONr,PUrw.OrdRow,PUrw.Quant,v,bv,blankval,blankval,blankval,PUrw.VarianceAmount);
          end else begin
            v = Round(PUrw.Quant*PUrw.UPrice,DefaultRoundMode);
            bv = MulRateToBase1(PUr.CurncyCode,v,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
            UpdateVarianceStatusRow(PONr,PUrw.OrdRow,PUrw.Quant,v,bv,blankval,blankval,blankval,PUrw.VarianceAmount);
          end;
          if (PUrw.PONr>0) then begin
            extracostvarf = true;
            if (PUrw.RowCost1!=0) then begin
              UpdateVarianceStatusRow(PONr,-2,1,PUrw.RowCost1,PUrw.RowCost1,blankval,blankval,blankval,blankval);
            end;
            if (PUrw.RowCost2!=0) then begin
              UpdateVarianceStatusRow(PONr,-3,1,PUrw.RowCost2,PUrw.RowCost2,blankval,blankval,blankval,blankval);
            end;
            if (PUrw.RowCost3!=0) then begin
              UpdateVarianceStatusRow(PONr,-4,1,PUrw.RowCost3,PUrw.RowCost3,blankval,blankval,blankval,blankval);
            end;
            if (PUrw.RowCost4!=0) then begin
              UpdateVarianceStatusRow(PONr,-5,1,PUrw.RowCost4,PUrw.RowCost4,blankval,blankval,blankval,blankval);
            end;
            if (PUrw.RowCost5!=0) then begin
              UpdateVarianceStatusRow(PONr,-6,1,PUrw.RowCost5,PUrw.RowCost5,blankval,blankval,blankval,blankval);
            end;
            if (nonblank(PUrw.CustomsCost)) then begin
              PUCalcPerc(PUrw.UPrice,PUrw.CustomsCost,t);
              UpdateVarianceStatusRow(PONr,-7,1,t,t,blankval,blankval,blankval,blankval);
            end;
            if (PUrw.ShipCost!=0) then begin
              UpdateVarianceStatusRow(PONr,-8,1,PUrw.ShipCost,PUrw.ShipCost,blankval,blankval,blankval,blankval);
            end;
          end;
        end;
      end;
    end;
    if (PUr.PONr>0 and extracostvarf==false) then begin
      if (PUr.Cost1!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-2,1,PUr.Cost1,PUr.Cost1,blankval,blankval,blankval,blankval);
      end;
      if (PUr.Cost2!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-3,1,PUr.Cost2,PUr.Cost2,blankval,blankval,blankval,blankval);
      end;
      if (PUr.Cost3!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-4,1,PUr.Cost3,PUr.Cost3,blankval,blankval,blankval,blankval);
      end;
      if (PUr.Cost4!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-5,1,PUr.Cost4,PUr.Cost4,blankval,blankval,blankval,blankval);
      end;
      if (PUr.Cost5!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-6,1,PUr.Cost5,PUr.Cost5,blankval,blankval,blankval,blankval);
      end;
      if (PUr.CustomsCost!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-7,1,PUr.CustomsCost,PUr.CustomsCost,blankval,blankval,blankval,blankval);
      end;
      if (PUr.ShipCost!=0) then begin
        UpdateVarianceStatusRow(PUr.PONr,-8,1,PUr.ShipCost,PUr.ShipCost,blankval,blankval,blankval,blankval);
      end;
    end;
  end;
  RETURN;
END;

global
function val FindAmForVariance(LongInt PONr,LongInt OrdRow,val PUQuant,val PUAmount,val PUBaseAmount,val VIQuant,val VIAmount,val VIBaseAmount,var Boolean mulratef)
begin
  val res;
  record VarianceStatusVc VarStatr;
  Boolean found,bookf;
  val q,v;
  val totPUQuant,totPUAmount,totPUBaseAmount,totVIQuant,totVIAmount,totVIBaseAmount;

  mulratef = false;
  VarStatr.PONr = PONr;
  VarStatr.OrdRow = OrdRow;
  found = ReadFirstMain(VarStatr,2,true);

  totPUQuant = VarStatr.PUQuant + PUQuant;
  totPUAmount = VarStatr.PUAmount + PUAmount;
  totPUBaseAmount = VarStatr.PUBaseAmount + PUBaseAmount;
  totVIQuant = VarStatr.VIQuant + VIQuant;
  totVIAmount = VarStatr.VIAmount + VIAmount;
  totVIBaseAmount = VarStatr.VIBaseAmount + VIBaseAmount;
  mulratef = blank(totPUBaseAmount)==false and blank(totVIBaseAmount)==false and blank(PUBaseAmount)==false and blank(VIBaseAmount)==false;
  bookf = false;
  
  if (totPUQuant-VarStatr.DoneQuant<totVIQuant-VarStatr.DoneQuant) then begin
    q = totPUQuant-VarStatr.DoneQuant;
  end else begin
    q = totVIQuant-VarStatr.DoneQuant;
  end;  
  if (q>0) then begin bookf = true; end;  
  if (totPUQuant<=0) then begin bookf = false; end;
  if (totVIQuant<=0) then begin bookf = false; end;
  if (bookf) then begin
    if (mulratef) then begin
      v = (totVIAmount/totVIQuant - totPUAmount/totPUQuant)*(VarStatr.DoneQuant+q);
    end else begin
      v = (totVIBaseAmount/totVIQuant - totPUBaseAmount/totPUQuant)*(VarStatr.DoneQuant+q);
    end;
    res = v - VarStatr.DoneAmount;    
  end; 
  FindAmForVariance = res;
  return;
end;

global
procedure FillAmForVariancePU(record PUVc PUr)
BEGIN
  Integer i,rwcnt;
  row PUVc PUrw;
  record AccBlock ARAccb;
  val v,bv;
  Boolean mulratef;
  
  BlockLoad(ARAccb);
  if (ARAccb.BookPriceVar!=0) then begin
    if (PUr.PONr>0) then begin
      rwcnt = MatRowCnt(PUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(PUr,i,PUrw);
        if (PUrw.OrdRow>=0) then begin
          v = Round(PUrw.Quant*PUrw.UPrice,DefaultRoundMode);
          bv = MulRateToBase1(PUr.CurncyCode,v,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
          PUrw.VarianceAmount = FindAmForVariance(PUr.PONr,PUrw.OrdRow,PUrw.Quant,v,bv,blankval,blankval,blankval,mulratef);
          if (mulratef) then begin
            PUrw.VarianceAmount = MulRateToBase1(PUr.CurncyCode,PUrw.VarianceAmount,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
          end;
          MatRowPut(PUr,i,PUrw);
        end;
      end;
    end;
  end;
  RETURN;
END;

global  
function string 20 FindItemPriceVarianceAcc(string ItemPriceVar,string itcode,Integer ItemGroupAccounts)
BEGIN
  string 20 res;
  record ITVc ITr;
  
  if (ItemGroupAccounts!=0) then begin
    ITr.Code = itcode;
    if (ReadFirstMain(ITr,1,true)) then begin
      res = ITr.PriceVarianceAcc;
    end;  
  end;
  if (blank(res)) then begin
    res = ItemPriceVar;
  end;
  FindItemPriceVarianceAcc = res;
  RETURN;
END;

global
procedure FillAmForVarianceRetPU(record RetPUVc RetPUr)
BEGIN
  Integer i,rwcnt;
  row RetPUVc RetPUrw;
  record AccBlock ARAccb;
  Boolean mulratef;
  
  BlockLoad(ARAccb);
  if (ARAccb.BookPriceVar!=0) then begin
    if (RetPUr.PONr>0) then begin
      rwcnt = MatRowCnt(RetPUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        if (RetPUrw.OrdRow>=0) then begin
          RetPUrw.VarianceAmount = FindAmForVariance(RetPUr.PONr,RetPUrw.OrdRow,blankval,blankval,blankval,-RetPUrw.Quant,-RetPUrw.FIFORowVal,blankval,mulratef);
          if (mulratef) then begin
            RetPUrw.VarianceAmount = MulRateToBase1(RetPUr.CurncyCode,RetPUrw.VarianceAmount,RetPUr.FrRate,RetPUr.ToRateB1,RetPUr.ToRateB2,RetPUr.BaseRate1,RetPUr.BaseRate2,DefaultCurRoundOff);
          end;
          MatRowPut(RetPUr,i,RetPUrw);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating procedure UpdateVarianceStatusRetPU(record RetPUVc RetPUr)
BEGIN
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  record AccBlock ARAccb;
  record PUVc PUr;
  row PUVc PUrw;
  record POVc POr;
  row POVc POrw;
  Boolean puf;
  val costv,vatv,t1;
  roundmode rm;
  
  BlockLoad(ARAccb);
  if (ARAccb.BookPriceVar!=0) then begin  
    if (RetPUr.PONr>0) then begin
      rwcnt = MatRowCnt(RetPUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        if (RetPUrw.OrdRow>=0) then begin
          costv = blankval;
          if (RetPUrw.PURow>=0) then begin
            PUr.SerNr = RetPUrw.PUNr;
            if (PUr.SerNr<0) then begin
              PUr.SerNr = RetPUr.PUNr;
            end;
            puf = ReadFirstMain(PUr,1,true);
            if (puf) then begin
              if (RetPUrw.PURow<MatRowCnt(PUr)) then begin
                MatRowGet(PUr,RetPUrw.PURow,PUrw);
                if (PUr.InclVAT!=0) then begin
                  rm = DefaultRoundMode;
                  rm.decimals = 5;
                  MulVATIVExecute(PUrw.VATCode,PUrw.UPrice,vatv,t1,PUr.InclVAT,0,rm);
                  costv = Round(RetPUrw.Quant*(PUrw.UPrice-vatv),rm);
                end else begin
                  costv = Round(RetPUrw.Quant*PUrw.UPrice,rm);
                end;
              end;
            end;
          end;
          if (puf==false) then begin
            POr.SerNr = RetPUrw.PONr;
            if (POr.SerNr<0) then begin
              POr.SerNr = RetPUr.PONr;
            end;
            if (ReadFirstMain(PUr,1,true)) then begin
              if (RetPUrw.OrdRow<MatRowCnt(POr)) then begin
                MatRowGet(POr,RetPUrw.OrdRow,POrw);
                if (POr.InclVAT!=0) then begin
                  rm = DefaultRoundMode;
                  rm.decimals = 5;
                  MulVATIVExecute(POrw.VATCode,POrw.Price,vatv,t1,POr.InclVAT,0,rm);
                  costv = Round(RetPUrw.Quant*(POrw.Price-vatv),rm);
                end else begin
                  costv = Round(RetPUrw.Quant*POrw.Price,rm);
                end;
              end;
            end;
          end;
          UpdateVarianceStatusRow(RetPUr.PONr,RetPUrw.OrdRow,-RetPUrw.Quant,-costv,-costv,blankval,blankval,blankval,RetPUrw.VarianceAmount);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating procedure UpdateVarianceStatusVI(record VIVc VIr,Boolean invalidatef)
BEGIN
  row VIVc VIrw;
  Integer i,rwcnt;
  record AccBlock ARAccb;
  val qty,sum,varnce,bsum;
  
  BlockLoad(ARAccb);
  if (ARAccb.BookPriceVar!=0) then begin  
    if (VIr.POSerNr>0) then begin
      rwcnt = MatRowCnt(VIr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(VIr,i,VIrw);
        if (VIrw.OrdRow>=0) then begin
          if (invalidatef) then begin
            if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              qty = VIrw.qty;
              sum = VIrw.Sum;
              varnce = VIrw.VarianceAmount;
            end else begin
              qty = -VIrw.qty;
              sum = -VIrw.Sum;
              varnce = -VIrw.VarianceAmount;
            end;
            bsum = MulRateToBase1(VIr.CurncyCode,sum,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
            UpdateVarianceStatusRow(VIr.POSerNr,VIrw.OrdRow,blankval,blankval,blankval,qty,sum,bsum,varnce);
          end else begin
            if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              qty = -VIrw.qty;
              sum = -VIrw.Sum;
            end else begin
              qty = VIrw.qty;
              sum = VIrw.Sum;
            end;
            bsum = MulRateToBase1(VIr.CurncyCode,sum,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
            UpdateVarianceStatusRow(VIr.POSerNr,VIrw.OrdRow,blankval,blankval,blankval,qty,sum,bsum,VIrw.VarianceAmount);
          end;
        end;
        if (VIrw.OrdRow<-1) then begin//extra costs
          if (invalidatef) then begin
            UpdateVarianceStatusRow(VIr.POSerNr,VIrw.OrdRow,-1,blankval,blankval,-1,blankval,blankval,blankval);
          end else begin
            UpdateVarianceStatusRow(VIr.POSerNr,VIrw.OrdRow,1,blankval,blankval,1,blankval,blankval,blankval);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

global
function val FindExtraCostsVariance(LongInt PONr,LongInt OrdRow,val VIAmount)
BEGIN
  val res;
  record VarianceStatusVc VarStatr;

  VarStatr.PONr = PONr;
  VarStatr.OrdRow = OrdRow;
  if (ReadFirstMain(VarStatr,2,true)) then begin end;
//VarStatr.PUAmount is in base 1  
  res = VIAmount - VarStatr.PUAmount;  
  FindExtraCostsVariance = res;
  RETURN;
END;

function val FindDropSHCostPrice(LongInt POSerNr,Integer ordrow,val qty)
begin
  val res;
  record DropSHVc DropSHr;
  row DropSHVc DropSHrw;
  Boolean found;
  Integer i,rwcnt;

  found = true;
  DropSHr.POOrderNr = POSerNr;
  while (LoopKey("POOrderNr",DropSHr,1,found)) begin
    if (DropSHr.POOrderNr!=POSerNr) then begin
      found = false;
    end;
    if (found) then begin
      rwcnt = MatRowCnt(DropSHr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(DropSHr,i,DropSHrw);
        if (DropSHrw.POOrdRow==OrdRow) then begin
          res = res + qty*DropSHrw.CostPrice;
        end;
      end;
    end;
  end;
  FindDropSHCostPrice = res;
  return;
end;

global
procedure FillAmForVarianceVI(record VIVc VIr)
BEGIN
  Integer i,rwcnt;
  row VIVc VIrw;
  record AccBlock ARAccb;
  val t,bv;
  Boolean mulratef;
  
  if (VIr.POSerNr>0) then begin
    BlockLoad(ARAccb);
    switch (VIr.OrderType) begin        
      case kOrderTypeDropShip:
        rwcnt = MatRowCnt(VIr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(VIr,i,VIrw);
          if (VIrw.OrdRow>=0 and VIrw.OrderType==kOrderTypeDropShip) then begin
            t = FindDropSHCostPrice(VIr.POSerNr,VIrw.OrdRow,VIrw.qty);
            VIrw.VarianceAmount = MulRateToBase1(VIr.CurncyCode,t,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff) - MulRateToBase1(VIr.CurncyCode,t,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
            MatRowPut(VIr,i,VIrw);
          end;
        end;
      otherwise
        if (ARAccb.BookPriceVar!=0) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VIrw.OrdRow>=0) then begin
              bv = MulRateToBase1(VIr.CurncyCode,VIrw.Sum,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
              VIrw.VarianceAmount = FindAmForVariance(VIr.POSerNr,VIrw.OrdRow,blankval,blankval,blankval,VIrw.qty,VIrw.Sum,bv,mulratef);
              if (mulratef) then begin
                VIrw.VarianceAmount = MulRateToBase1(VIr.CurncyCode,VIrw.VarianceAmount,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
              end;
              MatRowPut(VIr,i,VIrw);
            end;
            if (VIrw.OrdRow<-1) then begin//extra costs
              t = MulRateToBase1(VIr.CurncyCode,VIrw.Sum,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
              t = FindExtraCostsVariance(VIr.POSerNr,VIrw.OrdRow,t);
//in MakeTransFromVI we assume VarianceAmount is in base 1
//and all costs in PO and PU are in base 1
//              VIrw.VarianceAmount = MulRateToBase1(VIr.CurncyCode,t,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);

              VIrw.VarianceAmount = t;
              MatRowPut(VIr,i,VIrw);
            end;        
          end;
        end;
    end;
  end;
  RETURN;
END;

