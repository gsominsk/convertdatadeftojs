external function Boolean HasEInvoiceExpired();
external function Boolean HasEInvoicing();
external function Boolean TouchScreenLook();
external function string 255 AddBranchObjectToObjectList(string,string);
external updating function LongInt MailVcRecordCheck(var record MailVc,record MailVc,LongInt,LongInt);
external function Integer IVApprovalStatus(record IVVc,var record AcceptanceRulesVc);
external function Boolean HasApprovals();
external function string 255 NumToHex2(string,Integer);
external function string 100 FindNumberAfterSymbol(string,integer,string,boolean);
external function Boolean TestNextOfficialSerialNr_IVVc(row LegalInvNrBlock,string,record IVVc,Boolean);
external procedure PrepareOfficialSerialNrBlock_IVVc(var record LegalInvNrBlock);
external procedure GetLegalInvNrRow(string,var row LegalInvNrBlock);
external procedure ReverseString(string,var string);
external procedure GetCountryName(string,string,var string);
external procedure FindSourcePU(LongInt,var record ItemHistVc);
external function Boolean FindLocalSerialPortDevice(Integer,LongInt,string,var record LSerialPortDeviceVc);
external procedure IVVc_PasteQuant(var record IVVc,Integer,Boolean,var Boolean,string);
external procedure MailTextRow(string,string,string,var row MailTextVc,var Integer);
external function Boolean FindLocationAccRow(string,row LocationAccBlock);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean IVDchrsum(var record IVVc,Integer);
external procedure IVDchsum(var record IVVc,Integer);
external function boolean AddEMailRecipients(var record MailVc,string,string,integer);
external updating procedure SendPamFaxIVRemote(record IVVc);
external function roundmode SetRoundModeD(Integer);
external function Boolean GetItemPriceDiscount3(string,val,var record INVc,string,val,val,val,val,val,string,string,string,string,
                                                var val,var string,var val,var string,var val,var string,Integer,var Boolean,Date,Time,
                                                string,Boolean,var Boolean,string,var string,var val,string,string,var string);
external function Integer AddPortugueseType();
external function string 255 FindReservationCancellationTerms(string,Date,string);
external function LongInt DateDiff(Date,Date);
external function Integer CLInVc_PasteTransNr(var record CLInVc,Integer);
external procedure IVVc_CalculatePayDate(var record IVVc);
external procedure IVVc_PastePriceList(var record IVVc);
external function Boolean GetPD(var record PDVc);
external procedure GetPriceList(string,Date,Time,var string,var Integer);
external procedure SetSalesMan(var string,string);
external function Boolean GetPM(string,var string,var string);
external function Integer GetCreditedInvoiceType(record IVVc);
external function Boolean CLInforIVExists(LongInt,string,var LongInt);
external procedure IVSumup(var record IVVc,Boolean);
external procedure IVVcRecordDuplicateDo(var record IVVc,Boolean,Boolean);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure IVVc_PastePayDeal(var record IVVc,string,string);
external updating function LongInt IVVcRecordCheck(record IVVc,record IVVc,LongInt,LongInt);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure FEIVSumup(record FEIVVc);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure FindUserMailboxName(string,var string,var string);
external function Boolean FindCustomerRelation(string,string,var record CUVc);
external procedure GetPayDealText(string,string,var string);

function val FEIVQuantFract(LongInt curfeivnr,LongInt ordernr,LongInt ivsernr,Integer rownr)
BEGIN
  record FEIVVc FEIVr;
  row FEIVVc FEIVrw;
  Boolean TrHs,testf;
  val res;
  Integer i,rwcnt;
  
  if (ivsernr==-1) then begin
    goto LFEIVQuantFract;
  end;
  if (ordernr!=-1) then begin
    goto LFEIVQuantFract;
  end;
  TrHs = true;
  FEIVr.IVNr = ivsernr;
  while (LoopKey("IVNr",FEIVr,1,TrHs)) begin
    if (FEIVr.IVNr!=ivsernr) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      testf = true;
      if (FEIVr.SerNr==curfeivnr) then begin
        testf = false;
      end;
      if (testf) then begin
        rwcnt = MatRowCnt(FEIVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(FEIVr,i,FEIVrw);
          if (FEIVrw.IVRow==rownr) then begin
            res = res + FEIVrw.QuantFract;
          end;
        end;
      end;
    end;
  end;
LFEIVQuantFract:;  
  FEIVQuantFract = res;
  RETURN;
END;

function val FEIVQuantFractOrder(LongInt curfeivnr,LongInt ordernr,LongInt ivsernr,Integer ordrow)
BEGIN
  record ORVc ORr;
  row ORVc ORrw;
  record FEIVVc FEIVr;
  row FEIVVc FEIVrw;
  Boolean TrHs,testf;
  val res;
  Integer i,rwcnt;
  
  if (ordernr==-1) then begin
    goto LFEIVQuantFractOrder;
  end;
  TrHs = true;
  FEIVr.OrderNr = ordernr;
  while (LoopKey("OrderNr",FEIVr,1,TrHs)) begin
    if (FEIVr.OrderNr!=ordernr) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      testf = true;
      if (FEIVr.PrepaymentNr==-1) then begin
        testf = false;
      end;
      if (FEIVr.SerNr==curfeivnr) then begin
//        testf = false;
      end;
      if (testf) then begin
        rwcnt = MatRowCnt(FEIVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(FEIVr,i,FEIVrw);
          if (FEIVrw.OrdRow==ordrow) then begin
            res = res + FEIVrw.QuantFract;
          end;
        end;
      end;
    end;
  end;
/*  
  ORr.SerNr = ordernr;
  if (ReadFirstMain(ORr,1,true)) then begin
    if (ordrow<MatRowCnt(ORr)) then begin
      MatRowGet(ORr,ordrow,ORrw);
      if (ORrw.) 
    end;
  end;
  StopAlert("rowquantfract " & rowquantfract);      
*/  
LFEIVQuantFractOrder:;    
  FEIVQuantFractOrder = res;
  RETURN;
END;

procedure PasteInvInFEIV(var record FEIVVc FEIVp,record IVVc IVp,Boolean rowqf)
BEGIN
  record IVVc orgIVr;
  record FEIVVc lFEIVr;
  row IVVc IVrw;
  row FEIVVc FEIVrw;
  record CUVc CUr;
  record INVc INr;
  Integer i,rwcnt,srw,oldsrw;
  Boolean testf,infound;
  record GeneralOptionBlock GenOptRec;
  val s,rowsum,t,rowquantfract;
  Boolean createfeivf;
  record TaxMatrixVc TMr;

  lFEIVr.IVNr = IVp.SerNr;
  if (ReadFirstKey("IVNr",lFEIVr,1,true)) then begin
    goto LPasteInvInFEIV;
  end;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
    orgIVr.SerNr = IVp.CredInv;
    if (ReadFirstMain(orgIVr,1,true)) then begin
    end;
  end;
  BlockLoad(GenOptRec);
  FEIVp.TransDate = IVp.TransDate;
  FEIVp.IVTransDate = IVp.TransDate;
  FEIVp.CredInv = IVp.CredInv;
  FEIVp.InvType = IVp.InvType;
  FEIVp.IVNr = IVp.SerNr;
  FEIVp.OrderNr = IVp.OrderNr;
  if (FEIVp.OrderNr==-1) then begin
    if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
      FEIVp.OrderNr = orgIVr.OrderNr;
    end;
  end;
  FEIVp.PrepaymentNr = -1;
  FEIVp.CustCode = IVp.CustCode;
  FEIVp.Addr0 = IVp.Addr0;
  FEIVp.Addr1 = IVp.Addr1;
  FEIVp.Addr2 = IVp.Addr2;
  FEIVp.Addr3 = IVp.Addr3;
  FEIVp.InvAddr3 = IVp.InvAddr3;
  FEIVp.InvAddr4 = IVp.InvAddr4;
  FEIVp.PayDeal = IVp.PayDeal;
  FEIVp.VATNr = IVp.VATNr;    
  FEIVp.OrgCust = "";
  FEIVp.ExportFlag = IVp.ExportFlag;
  FEIVp.ClientContact = IVp.ClientContact;
  FEIVp.OurContact = IVp.OurContact;
  FEIVp.Objects = IVp.Objects;
  FEIVp.SalesMan = IVp.SalesMan;
  FEIVp.CurncyCode = IVp.CurncyCode;
  FEIVp.LangCode = IVp.LangCode;
  FEIVp.InvComment = IVp.InvComment;
  FEIVp.Sorting = IVp.Sorting;
  FEIVp.InclVAT = IVp.InclVAT;
  FEIVp.NoTAXonVAT = IVp.NoTAXonVAT;
  FEIVp.TotalwoTAX = IVp.TotalwoTAX;
  FEIVp.FrRate = IVp.FrRate;
  FEIVp.ToRateB1 = IVp.ToRateB1;
  FEIVp.ToRateB2 = IVp.ToRateB2;
  FEIVp.BaseRate1 = IVp.BaseRate1;
  FEIVp.BaseRate2 = IVp.BaseRate2;
  FEIVp.VATNr = IVp.VATNr;  
  FEIVp.Phone = IVp.Phone;
  FEIVp.Fax = IVp.Fax;
  FEIVp.CredMark = IVp.CredMark;
  CUr.Code = IVp.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  if (CUr.blockedFlag!=0) then begin goto LPasteInvInFEIV; end;
  if (blank(FEIVp.VATNr)) then begin FEIVp.VATNr = CUr.VATNr; end;
  if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
    createfeivf = true;
  end;
  rwcnt = MatRowCnt(IVp);
  oldsrw = MatRowCnt(FEIVp);
  srw = oldsrw;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.stp==10) then begin
      ClearRow(FEIVp,FEIVrw,10);
      MatRowPut(FEIVp,srw,FEIVrw);
      srw = srw + 1;      
      goto LSKIPROW;
    end;    
    if (IVrw.stp==9) then begin
      ClearRow(FEIVp,FEIVrw,9);
      FEIVrw.Sum = IVrw.Sum;
      MatRowPut(FEIVp,srw,FEIVrw);
      srw = srw + 1;      
      goto LSKIPROW;
    end;
    if (IVrw.stp==3) then begin
      ClearRow(FEIVp,FEIVrw,3);
      FEIVrw.OrdRow = IVrw.OrdRow;
      MatRowPut(FEIVp,srw,FEIVrw);
      srw = srw + 1;      
      goto LSKIPROW;
    end;
    if (IVrw.stp==11) then begin
      createfeivf = true;//we allow to create credit notes only for correction invoice, and we don't from credit notes
      ClearRow(FEIVp,FEIVrw,11);
      FEIVrw.stp = 11;
      FEIVrw.IVRow = i;
      FEIVrw.OrdRow = IVrw.OrdRow;
      FEIVrw.ArtCode = IVrw.ArtCode;
      FEIVrw.Quant = IVrw.Quant;
      FEIVrw.QuantFract = IVrw.Quant;
      FEIVrw.Spec = IVrw.Spec;
      FEIVrw.Price = IVrw.Price;
      FEIVrw.vRebate = IVrw.vRebate;
      FEIVrw.SalesAcc = IVrw.SalesAcc;
      FEIVrw.VATCode = IVrw.VATCode;
      FEIVrw.Objects = IVrw.Objects;
      FEIVrw.PriceFactor = IVrw.PriceFactor;
      FEIVrw.Sum = IVrw.Sum;
      MatRowPut(FEIVp,srw,FEIVrw);
      srw = srw + 1;      
      goto LSKIPROW;
    end;
    testf = true;    
    if (IVrw.stp!=kInvoiceRowTypeNormal) and (IVrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
      testf = false;    
    end;
    if (testf) then begin
      ClearRow(FEIVp,FEIVrw,1);
      FEIVrw.stp = 1;
      FEIVrw.IVRow = i;
      FEIVrw.OrdRow = IVrw.OrdRow;
      FEIVrw.ArtCode = IVrw.ArtCode;
      FEIVrw.Quant = IVrw.Quant;
      rowquantfract = blankval;
      if (rowqf) then begin
        if (FEIVp.OrderNr==-1) then begin
          rowquantfract = FEIVQuantFract(FEIVp.SerNr,FEIVp.OrderNr,IVp.SerNr,i);
        end else begin
          rowquantfract = FEIVQuantFractOrder(FEIVp.SerNr,FEIVp.OrderNr,IVp.SerNr,IVrw.OrdRow);
        end;
      end;
      FEIVrw.QuantFract = IVrw.Quant - rowquantfract;
      if (FEIVrw.QuantFract==0) then begin
        FEIVrw.QuantFract = blankval;
      end;
      FEIVrw.Spec = IVrw.Spec;
      FEIVrw.Price = IVrw.Price;
      FEIVrw.vRebate = IVrw.vRebate;
      FEIVrw.SalesAcc = IVrw.SalesAcc;
      FEIVrw.VATCode = IVrw.VATCode;
      FEIVrw.Objects = IVrw.Objects;
      FEIVrw.PriceFactor = IVrw.PriceFactor;
      CalcSum(FEIVrw.QuantFract,FEIVrw.Price,FEIVrw.PriceFactor,FEIVrw.vRebate,t,GenOptRec.UseDiscount);
      FEIVrw.Sum = t;
      if ((FEIVrw.Sum==0) and (FEIVrw.QuantFract==blankval) and (FEIVrw.Price==blankval)) then begin
        FEIVrw.Sum = blankval;
      end;
      INr.Code = FEIVrw.ArtCode;
      infound = ReadFirstMain(INr,1,true);
      FEIVrw.BasePrice = IVrw.BasePrice;
      if (nonblank(FEIVrw.ArtCode)) then begin
        t = FEIVrw.QuantFract*FEIVrw.BasePrice;   // cost  
        if (FEIVrw.PriceFactor!=0) then begin
          t = t/FEIVrw.PriceFactor;
        end;
        s = MulRateToBase1(FEIVp.CurncyCode,FEIVrw.Sum,FEIVp.FrRate,FEIVp.ToRateB1,FEIVp.ToRateB2,FEIVp.BaseRate1,FEIVp.BaseRate2,DefaultCurRoundOff);// sales
        FindSalesExVat(TMr,FEIVrw.VATCode,s,FEIVp.InclVAT,FEIVp.NoTAXonVAT,rowsum);
//        FEIVrw.rowGP = rowsum - t;        // GP    
      end else begin
//        FEIVrw.rowGP = 0;
        FEIVrw.BasePrice = 0;
      end;
//      FEIVrw.Coefficient = INr.UnitCoefficient;
      FEIVrw.UnitCode = IVrw.UnitCode;
      FEIVrw.UnitFactQuant = IVrw.UnitFactQuant;
      FEIVrw.UnitFactPrice = IVrw.UnitFactPrice;
      FEIVrw.UnitXval = IVrw.UnitXval;
      FEIVrw.UnitYval = IVrw.UnitYval;
      FEIVrw.UnitZval = IVrw.UnitZval;
      MatRowPut(FEIVp,srw,FEIVrw);
      srw = srw + 1;
    end;
LSKIPROW:;      
  end;
  FEIVp.Commision = IVp.Commision;
  FEIVSumup(FEIVp);
  if (createfeivf==false) then begin
    RecordNew(FEIVp);
  end;
LPasteInvInFEIV:;  
  RETURN;
END;

procedure CheckQuantFractIP(record FEIVVc FEIVp,Array val aqfract,Array string aartcode,var Integer acnt,LongInt PrepaymentNr)
BEGIN
  record FEIVVc lFEIVr;
  row FEIVVc lFEIVrw;
  row FEIVVc FEIVrw;
  Integer li,lrwcnt;
  Integer i,rwcnt,ai;
  Boolean TrHs;
  
  TrHs = true;
  lFEIVr.PrepaymentNr = PrepaymentNr;
  while (LoopKey("PrepaymentNr",lFEIVr,1,TrHs)) begin
    if (lFEIVr.PrepaymentNr!=PrepaymentNr) then begin
      TrHs = false;
    end;
    if (TrHs) and (lFEIVr.SerNr!=FEIVp.SerNr) then begin
      lrwcnt = MatRowCnt(lFEIVr);
      rwcnt = MatRowCnt(FEIVp);
      for (li=0;li<lrwcnt;li=li+1) begin
        MatRowGet(lFEIVr,li,lFEIVrw);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(FEIVp,i,FEIVrw);
          if ((lFEIVrw.ArtCode==FEIVrw.ArtCode) and (lFEIVrw.Price==FEIVrw.Price) and (lFEIVrw.vRebate==FEIVrw.vRebate)) then begin
            for (ai=0;ai<acnt;ai=ai+1) begin
              if (lFEIVrw.ArtCode==aartcode[ai]) then begin
                aqfract[ai] = aqfract[ai] + lFEIVrw.QuantFract;
                goto LSKIPNEWROW;
              end;
            end;
            aartcode[acnt] = lFEIVrw.ArtCode;
            aqfract[acnt] =  lFEIVrw.QuantFract;
            acnt = acnt + 1;
LSKIPNEWROW:;
//          StopAlert("1 - i " & i & " aqfract[i] " & aqfract[i]);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure CheckQuantFractIV(record FEIVVc FEIVp,Array val aqfract,Array string aartcode,var Integer acnt,LongInt ivnr)
BEGIN
  record FEIVVc lFEIVr;
  row FEIVVc lFEIVrw;
  row FEIVVc FEIVrw;
  Integer li,lrwcnt;
  Integer i,rwcnt,ai;
  Boolean TrHs;
  
  TrHs = true;
  lFEIVr.IVNr = ivnr;
  while (LoopKey("IVNr",lFEIVr,1,TrHs)) begin
    if (lFEIVr.IVNr!=ivnr) then begin
      TrHs = false;
    end;
    if (TrHs) and (lFEIVr.SerNr!=FEIVp.SerNr) then begin
      lrwcnt = MatRowCnt(lFEIVr);
      rwcnt = MatRowCnt(FEIVp);
      for (li=0;li<lrwcnt;li=li+1) begin
        MatRowGet(lFEIVr,li,lFEIVrw);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(FEIVp,i,FEIVrw);
          if ((lFEIVrw.ArtCode==FEIVrw.ArtCode) and (lFEIVrw.Price==FEIVrw.Price) and (lFEIVrw.vRebate==FEIVrw.vRebate)) then begin
            for (ai=0;ai<acnt;ai=ai+1) begin
              if (lFEIVrw.ArtCode==aartcode[ai]) then begin
                aqfract[ai] = aqfract[ai] + lFEIVrw.QuantFract;
                goto LSKIPNEWROW;
              end;
            end;
            aartcode[acnt] = lFEIVrw.ArtCode;
            aqfract[acnt] =  lFEIVrw.QuantFract;
            acnt = acnt + 1;
LSKIPNEWROW:;
//          StopAlert("1 - i " & i & " aqfract[i] " & aqfract[i]);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure ChangeQuantFract(record FEIVVc FEIVp,Array val aqfract,Array string aartcode,Integer acnt)
BEGIN
  Integer i,ai,rwcnt;
  row FEIVVc FEIVrw;
  val t;
  record GeneralOptionBlock GenOptRec;

  BlockLoad(GenOptRec);
  rwcnt = MatRowCnt(FEIVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(FEIVp,i,FEIVrw);
    for (ai=0;ai<acnt;ai=ai+1) begin
//    stopAlert("item " & aartcode[ai] & " q " & aqfract[ai]);
      if (FEIVrw.ArtCode==aartcode[ai]) then begin
        FEIVrw.QuantFract = FEIVrw.QuantFract - Round(aqfract[ai],SetRoundModeD(5));
      end;
    end;
    if (FEIVrw.QuantFract<0) then begin
      FEIVrw.QuantFract = 0;
    end;
    CalcSum(FEIVrw.QuantFract,FEIVrw.Price,FEIVrw.PriceFactor,FEIVrw.vRebate,t,GenOptRec.UseDiscount);
    FEIVrw.Sum = t;
    MatRowPut(FEIVp,i,FEIVrw);
  end;
  RETURN;
END;

function LongInt PasteInvInFEIVPrep(var record FEIVVc FEIVp,record IVVc IVp)
BEGIN
  LongInt res;
  row IVVc IVrw;
  Integer i,rwcnt;
  Array val aqfract;
  Array string 20 aartcode;
  Integer acnt;
  record FEIVVc lFEIVr;
  
  res = 0;
  PasteInvInFEIV(FEIVp,IVp,false);
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if ((IVrw.stp==6) and (IVrw.CUPNr!=-1)) then begin
      lFEIVr.PrepaymentNr = IVrw.CUPNr;
      if (ReadFirstKey("PrepaymentNr",lFEIVr,1,true)==false) then begin
        RecordNew(FEIVp);
        res = 2180;
        goto LPasteInvInFEIVPrep;
      end;
      CheckQuantFractIP(FEIVp,aqfract,aartcode,acnt,IVrw.CUPNr);
    end;
  end;
  CheckQuantFractIV(FEIVp,aqfract,aartcode,acnt,IVp.SerNr);
  ChangeQuantFract(FEIVp,aqfract,aartcode,acnt);
  FEIVSumup(FEIVp);
LPasteInvInFEIVPrep:;
  PasteInvInFEIVPrep = res;  
  RETURN;
END;

global
function LongInt PasteIVInFEIV(var record FEIVVc FEIVp,record IVVc IVr)
BEGIN
  LongInt res;
  row IVVc IVrw;
  Integer i,rwcnt;
  Boolean prepf;
  
  res = 0;
  RecordNew(FEIVp);
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if ((IVrw.stp==6) and (IVrw.CUPNr!=-1)) then begin
      prepf = true;
      goto LSTOP;
    end;
  end;
LSTOP:;  
  if (prepf) then begin
    res = PasteInvInFEIVPrep(FEIVp,IVr);
  end else begin
    PasteInvInFEIV(FEIVp,IVr,true);
  end;
  
  if (FEIVp.Sum4==0) then begin
    if (res==0) then begin
      res = 1;
    end;
  end;
  PasteIVInFEIV = res;
  RETURN
END; 

global
updating function LongInt IVCheckIfSaveAllowed(var record IVVc IVr,record IVVc IV2r,LongInt stat,LongInt long4)
begin
  LongInt res;

  SetRecordCheckVc("IVVc");
  res = IVVcRecordCheck(IVr,IV2r,stat,long4);  
  IVCheckIfSaveAllowed = res;
  return;
end;


procedure ApplyCreditNoteTerms(record IVVc CreditIVr)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  record CNDVc CNDr;
  row CNDVc CNDrw;
  record JobVc Jobr;
  string 255 cnterm;
  val cntermprc;
  record HCUDVc HCUDr;
  
  if (CreditIVr.JobNr>0) then begin
    Jobr.SerNr = CreditIVr.JobNr;
    if (ReadFirstMain(Jobr,1,true)) then begin
      cnterm = FindReservationCancellationTerms(Jobr.CUCode,Jobr.TransDate,Jobr.ResStatus);
      if (blank(cnterm)) then begin
        goto LApplyCreditNoteTerms;
      end;
      CNDr.Code = cnterm;
      if (ReadFirstMain(CNDr,1,true)) then begin
        rwcnt = MatRowCnt(CNDr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(CNDr,i,CNDrw);
          if (DateDiff(Jobr.TransDate,CurrentDate)<=CNDrw.Days) then begin
            cntermprc = CNDrw.Percentage;
            i = rwcnt;
          end;
        end;
        if (cntermprc!=0) then begin
          rwcnt = MatRowCnt(CreditIVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(CreditIVr,i,IVrw);
            switch (IVrw.stp) begin
              case 11:
                if (cntermprc>0) then begin
                  IVrw.Sum = (IVrw.Sum*cntermprc)/100;
                end else begin
                  IVrw.Sum = IVrw.Sum + (IVrw.Sum*cntermprc)/100;
                end;
              otherwise
                if (cntermprc>0) then begin
                  IVrw.Sum = (IVrw.Sum*cntermprc)/100;
                end else begin
                  IVrw.Sum = IVrw.Sum + (IVrw.Sum*cntermprc)/100;
                end;
            end;
            MatRowPut(CreditIVr,i,IVrw);
          end;
        end;
      end;
    end;
  end;
LApplyCreditNoteTerms:;  
  return;
end;

global
function Integer CreateCreditNoteIV(record IVVc IVr,Integer invtype,var record IVVc CreditIVr,string defreturnlocation,Boolean correctionf)
begin
/*similar to LastCreditedRowSum*/
  Integer res;
  boolean TrHs,testf,updrf;
  longint newnr;
  record SRBlock SRRec;
  record PDVc PDr;
  val fr,to1,to2,br1,br2;
  row IVVc IVrw;
  Integer i,rwcnt,stp;
  record ModuleBlock Mb;
  record IVVc tmpIVr;
  row IVVc tmpIVrw;
  Integer t,trwcnt;

  res = 1958;
  BlockLoad(Mb);
  RecordCopy(CreditIVr,IVr);
  CreditIVr.PayDeal = "";
  CreditIVr.InvType = invtype;
  IVVcRecordDuplicateDo(CreditIVr,false,false);
  CreditIVr.SerNr = -1;
  CreditIVr.InvType = invtype;
  CreditIVr.CredMark = USetStr(1078);
  CreditIVr.InvDate = CurrentDate;
  CreditIVr.TransDate = CreditIVr.InvDate;
  CreditIVr.PayDate = CreditIVr.InvDate;
  CreditIVr.OKFlag = 0;
  if (HasLocalization("POL")) then begin
    CreditIVr.FiscalFlag = 0;
  end;
  if (HasLocalization("ARG")) then begin 
    CreditIVr.BranchID = IVr.BranchID;
  end;
  
  //find the first Pay.Term with Credit Note type
  TrHs = true;
  while (LoopMain(PDr,1,TrHs)) begin
    if (PDr.PDType==invtype) then begin //credit/debit note
      TrHs = false;
      CreditIVr.PayDeal = PDr.Code;
      IVVc_PastePayDeal(CreditIVr,"","");
      res = 0;
    end;
  end;  
  if (IsStandardProduct and CreditIVr.InvType==kInvoiceTypeCredit) then begin
    CreditIVr.UpdStockFlag = IVr.UpdStockFlag;
  end;
  CreditIVr.pdvrebt = IVr.pdvrebt;
  CreditIVr.pdvrebt2 = IVr.pdvrebt2;
  CreditIVr.InstallmentInv = IVr.InstallmentInv;
  CreditIVr.OrderNr = IVr.OrderNr;
  CreditIVr.QTNr = IVr.QTNr;
  CreditIVr.FrRate = IVr.FrRate;
  CreditIVr.ToRateB1 = IVr.ToRateB1;
  CreditIVr.ToRateB2 = IVr.ToRateB2;
  CreditIVr.BaseRate1 = IVr.BaseRate1;
  CreditIVr.BaseRate2 = IVr.BaseRate2;
  CreditIVr.CredInv = IVr.SerNr;  
  CreditIVr.SVONr = IVr.SVONr;  
  CreditIVr.CredOfficialSerNr = IVr.OfficialSerNr;  
  if (Mb.CredUpdStock!=0) then begin
    if (nonblank(defreturnlocation)) then begin
      CreditIVr.Location = defreturnlocation;
    end;
  end;

  rwcnt = MatRowCnt(CreditIVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CreditIVr,i,IVrw);
    if ((i-1)>=0) then begin
      MatRowGet(IVr,i-1,tmpIVrw);
    end;
    switch (IVrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;
        updrf = false;
        if (IVrw.OrdRow>=0) then begin
          IVrw.NotUpdStockFlag = 1;
          updrf = true;
        end;
        if (Mb.CredUpdStock!=0) then begin
          if (nonblank(defreturnlocation)) then begin
            MatRowGet(CreditIVr,i,IVrw);
            if (nonblank(IVrw.Location)) then begin
              IVrw.Location = defreturnlocation;
              updrf = true;
            end;
          end;
        end;
        if (updrf) then begin
          MatRowPut(CreditIVr,i,IVrw);
        end;
      case 0:
        MatRowDelete(CreditIVr,i);
        rwcnt = MatRowCnt(CreditIVr);
      case 6:
        MatRowDelete(CreditIVr,i);
        rwcnt = MatRowCnt(CreditIVr);
      case kInvoiceRowTypeCashPayment:
        MatRowDelete(CreditIVr,i);
        rwcnt = MatRowCnt(CreditIVr);
      case kInvoiceRowTypeLoyaltyPointsPayment:
        MatRowDelete(CreditIVr,i);
        rwcnt = MatRowCnt(CreditIVr);
      case kInvoiceRowTypeCreditCardPayment:
        MatRowDelete(CreditIVr,i);
        rwcnt = MatRowCnt(CreditIVr);
    end;
  end;
  switch (invtype) begin
    case kInvoiceTypeDebit:
      ClearRow(CreditIVr,IVrw,kInvoiceRowTypeDebit);
      IVrw.OrdRow = IVr.SerNr;
      IVrw.CredOfficialSerNr = IVr.OfficialSerNr;  
      MatRowInsert(CreditIVr,0,IVrw);
    case kInvoiceTypeNormalSpecialSales:
      goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
LkInvoiceTypeCredit:;    
      if (MatRowCnt(CreditIVr)>0) then begin
        MatRowGet(CreditIVr,0,IVrw);
        IVrw.OrdRow = IVr.SerNr;
        IVrw.CredOfficialSerNr = IVr.OfficialSerNr;  
        MatRowPut(CreditIVr,0,IVrw);
      end else begin
        ClearRow(CreditIVr,IVrw,3);
        IVrw.OrdRow = IVr.SerNr;
        IVrw.CredOfficialSerNr = IVr.OfficialSerNr;  
        MatRowInsert(CreditIVr,0,IVrw);
      end;
      ApplyCreditNoteTerms(CreditIVr);
  end;
  if (correctionf) then begin
    RecordCopy(tmpIVr,CreditIVr);
    rwcnt = MatRowCnt(CreditIVr);
    ClearRow(CreditIVr,IVrw,1);
    IVrw.stp = kInvoiceRowTypeNormal;
    IVrw.Spec = USetStr(2078);
    MatRowInsert(CreditIVr,1,IVrw);
    ClearRow(CreditIVr,IVrw,1);
    IVrw.stp = kInvoiceRowTypeNormal;
    IVrw.Spec = USetStr(2079);
    MatRowPut(CreditIVr,rwcnt+1,IVrw);
    for (i=1;i<rwcnt;i=i+1) begin
      MatRowGet(tmpIVr,i,IVrw);
      stp = IVrw.stp;
      IVrw.stp = kInvoiceRowTypeCorrection;
      if (stp==kInvoiceRowTypeDownpayment) then begin
        if (IVrw.Price==0) then begin
          IVrw.Price = IVrw.Sum/IVrw.Quant;
        end;
      end;
      MatRowPut(CreditIVr,rwcnt+1+i,IVrw);      
    end;
    
    rwcnt = MatRowCnt(CreditIVr);
    tmpIVr.CredInv = IVr.SerNr;
    ResetLoop(tmpIVr);
    TrHs = true;
    while (LoopBackKey("CredInv",tmpIVr,1,TrHs)) begin
      if (tmpIVr.CredInv!=IVr.SerNr) then begin TrHs = false; end;
      if (TrHs) then begin
        trwcnt = MatRowCnt(tmpIVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(CreditIVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeCorrection) then begin
            for (t=0;t<trwcnt;t=t+1) begin
              MatRowGet(tmpIVr,t,tmpIVrw);
              testf = true;
              if (tmpIVrw.stp!=kInvoiceRowTypeCorrection) then begin
                testf = false;
              end;
              if (tmpIVrw.CreditedRow!=IVrw.CreditedRow) then begin
                testf = false;
              end;
              if (testf) then begin
                if (IVrw.Price!=0) then begin
                  IVrw.Price = tmpIVrw.Price;
                  IVrw.Quant = tmpIVrw.Quant;
                  MatRowPut(CreditIVr,i,IVrw);
                  if (IVDchrsum(CreditIVr,i)) then begin
                    IVDchsum(CreditIVr,i);
                  end;  
                  t = trwcnt;
                  TrHs = false;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  IVSumup(CreditIVr,true);
LCreateCreditNoteIV:;  
  CreateCreditNoteIV = res;
  return;
end;

global
updating function Integer CreateExternalMailFromIVD(record IVVc IVr,var string warning,Boolean additemstobodyf,string pdfform)
begin
  Integer res;
  record LTxtVc LTxtr;
  record CUVc CUr;
  record CUVc ContactCUr;
  row IVVc IVrw;
  Integer i,rwcnt;
  string 255 tstr;
  string 1 TAB;
  record IVMailBlock IVMailr;
  record MailSettingsBlock MSb;
  string 255 docname,fname;

  string 255 emailaddr;
  string 255 subject;
  area body;
  
  res = 0;
  if (ReadFirstMain(IVr,0,true)) then begin end;  
  TAB = chr(9);
  BlockLoad(IVMailr);
  CUr.Code = IVr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  emailaddr = CUr.eMail;
  if (nonblank(IVr.ClientContact)) then begin
    if (FindCustomerRelation(CUr.Code,IVr.ClientContact,ContactCUr)) then begin
      if (nonblank(ContactCUr.eMail)) then begin
        emailaddr = ContactCUr.eMail;
      end;
    end;
  end;
  LogText(0,"emailaddr: " & emailaddr);
  if (blank(emailaddr)) then begin
    res = 2289;
    warning = CUr.Code;
    goto LCreateExternalMailFromIVD;
  end;
  if (nonblank(IVMailr.Header)) then begin
    subject = IVMailr.Header & " ";
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeCredit:
      subject = subject & USetStr(1805) & " ";
    case kInvoiceTypeCreditSpecialSales:
      subject = subject & USetStr(1805) & " ";
    otherwise
      subject = subject & USetStr(1803) & " ";
  end;
  subject = subject & IVr.SerNr;
  LogText(0,"subject: " & subject);

  LTxtr.Code = IVMailr.FirstTxt;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    rwcnt = LineTextCnt(LTxtr);
    for (i=0;i<rwcnt;i=i+1) begin
      tstr = LineTextGet(LTxtr,i);
      AddTextToArea(tstr,body);
      AddTextToArea(chr(13) & chr(10),body);
    end;
  end;
  if (additemstobodyf) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==10) then begin 
        goto LIVHIDDENLine;
      end;
      tstr = IVrw.ArtCode & TAB;
      tstr = tstr & ValToString(IVrw.Quant,M4UVal,"",".",0) & TAB;
      tstr = tstr & Left(IVrw.Spec,60) & TAB;
      tstr = tstr & IVrw.Price & TAB;
      if (IVrw.vRebate!=0) then begin
        tstr = tstr & "-" & ValToString(IVrw.vRebate,M4UVal,"",".",0) & "%" &  TAB;
      end;
      tstr = tstr & IVrw.Sum & TAB;
        AddTextToArea(tstr,body);
        AddTextToArea(chr(13) & chr(10),body);        
    end;
  end;
LIVHIDDENLine:;  
  tstr = TAB & TAB & TAB & "=====";
  AddTextToArea(tstr,body);
  AddTextToArea(chr(13) & chr(10),body);
  tstr = TAB & TAB & TAB & USetStr(2685) & TAB & IVr.Sum1;
  AddTextToArea(tstr,body);
  AddTextToArea(chr(13) & chr(10),body);
  tstr = TAB & TAB & TAB & USetStr(2686) & TAB & IVr.Sum3;
  AddTextToArea(tstr,body);
  AddTextToArea(chr(13) & chr(10),body);
  tstr = TAB & TAB & TAB & USetStr(2687) & TAB & IVr.Sum4;
  AddTextToArea(tstr,body);
  AddTextToArea(chr(13) & chr(10),body);
  GetPayDealText(IVr.PayDeal,IVr.LangCode,tstr);
  tstr = USetStr(3060) & " " & tstr;
  AddTextToArea(tstr,body);
  AddTextToArea(chr(13) & chr(10),body);
  LTxtr.Code = IVMailr.LastTxt;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    rwcnt = LineTextCnt(LTxtr);
    for (i=0;i<rwcnt;i=i+1) begin
      tstr = LineTextGet(LTxtr,i);
      AddTextToArea(tstr,body);
      AddTextToArea(chr(13) & chr(10),body);
    end;    
  end;

  docname = pdfform;
  if (blank(docname)) then begin
    docname = "InvForm";
    switch (IVr.InvType) begin
      case kInvoiceTypeCash: docname = "CashInvForm";
      case kInvoiceTypeCashInvoiceReceiptPRT: docname = "CashInvRecPRTForm";
      case kInvoiceTypeCredit: docname = "CredInvForm";
      case kInvoiceTypeInterest: docname = "IIInvForm";
      case kInvoiceTypeCreditSpecialSales: docname = "CredInvForm";
    end;
    if ((IVr.InvType==kInvoiceTypeNormal or IVr.InvType==kInvoiceTypeNormalSpecialSales) or (IVr.InvType==kInvoiceTypeDownpayment)) then begin
      if (nonblank(IVr.PRCode)) then begin    
        docname = "ProjInvForm";
      end;
    end;
  end;
  fname = "tmp/" & USetStr(1803) & " " & IVr.SerNr & ".pdf";
  LogText(0,"fname: " & fname);
  SetDocumentFilename(fname);
  SetMedia(mtPdf);
  PrintDocument(IVr,docname,false);
  SetDocumentFilename("");
  SendExtEmailWithAttach(emailaddr,fname,subject,body);
//  Delete_File(fname);
LCreateExternalMailFromIVD:;  
  CreateExternalMailFromIVD = res;
  return;
end;

global
updating function Integer CreateMailFromIVD(record IVVc IVr,var record MailVc Mailr,var string warning,Boolean additemstobodyf,string pdfform)
begin
  Integer res;
  record MailVc dummyMailr;
  record MailVc Mail2r;
  record LTxtVc LTxtr;
  record CUVc CUr;
  record CUVc ContactCUr;
  row IVVc IVrw;
  row MailVc MArw;
  Integer i,rwcnt;
  string 255 mailboxnr,tstr;
  string 1 TAB;
  record IVMailBlock IVMailr;
  record MailSettingsBlock MSb;
  string 255 docname,fname;
  string 20 custemail;
  record IVVc oldIVr;
  row MailTextVc MTrw;
  Integer IgnoreRecordDetails;
  LongInt err;
  record COCUServiceBlock CSb;

  res = 0;
  if (ReadFirstMain(IVr,0,true)) then begin end;  
  TAB = chr(9);

  BlockLoad(IVMailr);
  tstr = IVMailr.EmailSender;
  if (blank(tstr)) then begin
    FindUserMailboxName(CurrentUser,mailboxnr,tstr);
  end;
  if (blank(tstr)) then begin
    BlockLoad(MSb);
    tstr = MSb.FromSystem;
  end;
  if (blank(tstr)) then begin
    res = 2289;
    warning = CurrentUser;
    goto LCreateMailFromIVD;
  end;  
  MArw.RowTyp = 1;
  MArw.AddrCode = tstr;
  MatRowPut(Mailr,0,MArw);
  CUr.Code = IVr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  custemail = CUr.eMail;
  if (nonblank(IVr.ClientContact)) then begin
    if (FindCustomerRelation(CUr.Code,IVr.ClientContact,ContactCUr)) then begin
      if (nonblank(ContactCUr.eMail)) then begin
        MArw.AddrCode = ContactCUr.eMail;
        custemail = ContactCUr.eMail;
      end;
    end;
  end;
  if (nonblank(IVr.eMail)) then begin
    custemail = IVr.eMail;
  end;
  if (AddEMailRecipients(Mailr,CUr.Code,custemail,kMailInvoice)==false) then begin
    res = 2289;
    warning = CUr.Code;
    goto LCreateMailFromIVD;
  end;
  MailTextRow("IVVc","",IVr.LangCode,MTrw,IgnoreRecordDetails);
  if (nonblank(MTrw.Header)) then begin  
    Mailr.Header = MTrw.Header;
  end else begin
    if (nonblank(IVMailr.Header)) then begin
      Mailr.Header = IVMailr.Header & " ";
    end;
    Mailr.Header = Mailr.Header;
  end;
  switch (IVr.InvType) begin
    case kInvoiceTypeCredit:
      Mailr.Header = Mailr.Header & USetStr(1805) & " ";
    case kInvoiceTypeCreditSpecialSales:
      Mailr.Header = Mailr.Header & USetStr(1805) & " ";
    otherwise
      Mailr.Header = Mailr.Header & USetStr(1803) & " ";
  end;
  Mailr.Header = Mailr.Header & IVr.SerNr;
  
  if (nonblank(MTrw.FirstTxt)) then begin
    LTxtr.Code = MTrw.FirstTxt;
  end else begin
    LTxtr.Code = IVMailr.FirstTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    Mailr.HtmlFlag = LTxtr.HtmlFlag;
  end;
  if (Mailr.HtmlFlag==0) then begin
    if (nonblank(MTrw.LastTxt)) then begin
      LTxtr.Code = MTrw.LastTxt;
    end else begin
      LTxtr.Code = IVMailr.LastTxt;
    end;
    if (ReadFirstMain(LTxtr,1,true)) then begin
      Mailr.HtmlFlag = LTxtr.HtmlFlag;
    end;
  end;
  
  Mailr.TransDate = CurrentDate;
  Mailr.SerNr = NextSerNr("MailVc",Mailr.TransDate,-1,false,"");
  RecordCopy(Mail2r,Mailr);
  SetRecordCheckVc("MailVc");
  err = MailVcRecordCheck(Mail2r,dummyMailr,Rs_insert,0);
  if (err!=0) then begin
    res = -1;
    goto LCreateMailFromIVD;
  end;
  if (RecordStore(Mailr,false)) then begin 
    CreateRecordLink(Mailr,CurrentCompany,IVr,CurrentCompany);  
    CreateRecordLink(IVr,CurrentCompany,Mailr,CurrentCompany);  
  end;
  
  RecordCopy(Mail2r,Mailr);  
  if (nonblank(MTrw.FirstTxt)) then begin
    LTxtr.Code = MTrw.FirstTxt;
  end else begin
    LTxtr.Code = IVMailr.FirstTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    if (Mailr.HtmlFlag==0) then begin
      rwcnt = LineTextCnt(LTxtr);
      for (i=0;i<rwcnt;i=i+1) begin
        tstr = LineTextGet(LTxtr,i);
        LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
      end;    
      AddCRToText(Mailr);
    end else begin
      if (LTxtr.HtmlFlag==0) then begin
        AddToHtmlRecord(Ltxtr,false,Mailr,true,true);
      end else begin
        AddHtmlRecordToHtmlRecord(Ltxtr,Mailr,true);
      end;
      LineTextPutToHtmlRecord(Mailr,chr(13),false,true);
    end;
  end;
  if (additemstobodyf or IgnoreRecordDetails==0) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==10) then begin 
        goto LIVHIDDENLine;
      end;
      tstr = IVrw.ArtCode & TAB;
      tstr = tstr & ValToString(IVrw.Quant,M4UVal,"",".",0) & TAB;
      tstr = tstr & Left(IVrw.Spec,60) & TAB;
      tstr = tstr & IVrw.Price & TAB;
      if (IVrw.vRebate!=0) then begin
        tstr = tstr & "-" & ValToString(IVrw.vRebate,M4UVal,"",".",0) & "%" &  TAB;
      end;
      tstr = tstr & IVrw.Sum & TAB;
      if (Mailr.HtmlFlag==0) then begin
        LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
      end else begin
        LineTextPutToHtmlRecord(Mailr,tstr,false,true);
      end;
    end;
LIVHIDDENLine:;  
    tstr = TAB & TAB & TAB & "=====";
    if (Mailr.HtmlFlag==0) then begin
      LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
    end else begin
      LineTextPutToHtmlRecord(Mailr,tstr,false,true);
    end;
    tstr = TAB & TAB & TAB & USetStr(2685) & TAB & IVr.Sum1;
    if (Mailr.HtmlFlag==0) then begin
      LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
    end else begin
      LineTextPutToHtmlRecord(Mailr,tstr,false,true);
    end;
    tstr = TAB & TAB & TAB & USetStr(2686) & TAB & IVr.Sum3;
    if (Mailr.HtmlFlag==0) then begin
      LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
    end else begin
      LineTextPutToHtmlRecord(Mailr,tstr,false,true);
    end;
    tstr = TAB & TAB & TAB & USetStr(2687) & TAB & IVr.Sum4;
    if (Mailr.HtmlFlag==0) then begin
      LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
    end else begin
      LineTextPutToHtmlRecord(Mailr,tstr,false,true);
    end;
    GetPayDealText(IVr.PayDeal,IVr.LangCode,tstr);
    tstr = USetStr(3060) & " " & tstr;
    if (Mailr.HtmlFlag==0) then begin
      LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
    end else begin
      LineTextPutToHtmlRecord(Mailr,tstr,false,true);
    end;
  end;
  if (nonblank(MTrw.LastTxt)) then begin
    LTxtr.Code = MTrw.LastTxt;
  end else begin
    LTxtr.Code = IVMailr.LastTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    if (Mailr.HtmlFlag==0) then begin
      rwcnt = LineTextCnt(LTxtr);
      for (i=0;i<rwcnt;i=i+1) begin
        tstr = LineTextGet(LTxtr,i);
        LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
      end;
      AddCRToText(Mailr);
    end else begin
      if (LTxtr.HtmlFlag==0) then begin
        AddToHtmlRecord(Ltxtr,false,Mailr,true,true);
      end else begin
        AddHtmlRecordToHtmlRecord(Ltxtr,Mailr,true);
      end;
    end;
  end;
  
  RecordUpdate(Mail2r,Mailr,false);

  docname = pdfform;
  if (blank(docname)) then begin
    docname = "InvForm";
    switch (IVr.InvType) begin
      case kInvoiceTypeCash: docname = "CashInvForm";
      case kInvoiceTypeCashInvoiceReceiptPRT: docname = "CashInvRecPRTForm";
      case kInvoiceTypeCredit: docname = "CredInvForm";
      case kInvoiceTypeInterest: docname = "IIInvForm";
      case kInvoiceTypeCreditSpecialSales: docname = "CredInvForm";
    end;
    if ((IVr.InvType==kInvoiceTypeNormal or IVr.InvType==kInvoiceTypeNormalSpecialSales) or (IVr.InvType==kInvoiceTypeDownpayment)) then begin
      if (nonblank(IVr.PRCode)) then begin    
        docname = "ProjInvForm";
      end;
    end;
  end;
  fname = "tmp/" & USetStr(1803) & " " & IVr.SerNr & ".pdf";
  SetDocumentFilename(fname);
  SetMedia(mtPdf);
  PrintDocument(IVr,docname,false);
  if (FileExists(fname)) then begin
    if (RecordLinkFile(fname,0,Mailr,CurrentCompany)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.Prntdf = 1;
      RecordUpdate(oldIVr,IVr,false);
    end;
  end;
  SetDocumentFilename("");
  Delete_File(fname);

LCreateMailFromIVD:;  
  CreateMailFromIVD = res;
  return;
end;

procedure AddIVArrayToMailHeader(var string mailheader,array LongInt IVSerNrs)
begin
  record IVVc IVr;
  Integer i;
  array LongInt invoices;
  array LongInt creditnotes;
  
  for (i = 0; i<IVSerNrs.length; i = i + 1) begin
    IVr.SerNr = IVSerNrs[i];
    if (ReadFirstMain(IVr,1,true)) then begin
      switch (IVr.InvType) begin
        case kInvoiceTypeCredit:
          creditnotes[creditnotes.length] = IVr.SerNr;
        case kInvoiceTypeCreditSpecialSales:
          creditnotes[creditnotes.length] = IVr.SerNr;
        otherwise
          invoices[invoices.length] = IVr.SerNr;
      end;
    end;
  end;
  
  if (invoices.length>0) then begin
    if (invoices.length==1) then begin
      mailheader = mailheader & USetStr(1803) & " " & invoices[0];
    end else begin
      mailheader = mailheader & USetStr(10672);
      if (invoices.length<=3) then begin
        for (i = 0; i<invoices.length; i = i + 1) begin
          if (i==0) then begin
            mailheader = mailheader & " ";
          end else begin
            mailheader = mailheader & USetStr(1327);
          end;
          mailheader = mailheader & invoices[i];
        end;
      end;
    end;
  end;
  
  if (creditnotes.length>0) then begin
    if (invoices.length>0) then begin
      mailheader = mailheader & USetStr(1319);
    end;
    if (creditnotes.length==1) then begin
      mailheader = mailheader & USetStr(1805) & " " & creditnotes[0];
    end else begin
      mailheader = mailheader & USetStr(10673);
      if (creditnotes.length<=3) then begin
        for (i = 0; i<creditnotes.length; i = i + 1) begin
          if (i==0) then begin
            mailheader = mailheader & " ";
          end else begin
            mailheader = mailheader & USetStr(1327);
          end;
          mailheader = mailheader & creditnotes[i];
        end;
      end;
    end;
  end;
end;

global
updating function Integer CreateMailFromIVArray(array LongInt IVSerNrs,var record MailVc Mailr,var string warning,Boolean additemstobodyf,string pdfform)
begin
  Integer res;
  record MailVc Mail2r;
  record LTxtVc LTxtr;
  record CUVc CUr;
  record CUVc ContactCUr;
  record IVVc IVr;
  row IVVc IVrw;
  row MailVc MArw;
  Integer i,i2,rwcnt;
  string 255 mailboxnr,tstr;
  string 1 TAB;
  record IVMailBlock IVMailr;
  record MailSettingsBlock MSb;
  string 255 docname,fname;
  string 20 custemail;
  record IVVc oldIVr;
  row MailTextVc MTrw;
  Integer IgnoreRecordDetails;
  record COCUServiceBlock CSb;

  res = 0;
  if (IVSerNrs.length==0) then begin
    res = 1;
    goto LCreateMailFromIVArray;
  end;
  IVr.SerNr = IVSerNrs[0];
  ReadFirstMain(IVr,0,true);
  TAB = chr(9);

  BlockLoad(IVMailr);
  tstr = IVMailr.EmailSender;
  if (blank(tstr)) then begin
    FindUserMailboxName(CurrentUser,mailboxnr,tstr);
  end;
  if (blank(tstr)) then begin
    BlockLoad(MSb);
    tstr = MSb.FromSystem;
  end;
  if (blank(tstr)) then begin
    res = 2289;
    warning = CurrentUser;
    goto LCreateMailFromIVArray;
  end;
  MArw.RowTyp = 1;
  MArw.AddrCode = tstr;
  MatRowPut(Mailr,0,MArw);
  CUr.Code = IVr.CustCode;
  ReadFirstMain(CUr,1,true);
  custemail = CUr.eMail;
  if (nonblank(IVr.ClientContact)) then begin
    if (FindCustomerRelation(CUr.Code,IVr.ClientContact,ContactCUr)) then begin
      if (nonblank(ContactCUr.eMail)) then begin
        MArw.AddrCode = ContactCUr.eMail;
        custemail = ContactCUr.eMail;
      end;
    end;
  end;
  if (AddEMailRecipients(Mailr,CUr.Code,custemail,kMailInvoice)==false) then begin
    res = 2289;
    warning = CUr.Code;
    goto LCreateMailFromIVArray;
  end;
  MailTextRow("IVVc","",IVr.LangCode,MTrw,IgnoreRecordDetails);
  if (nonblank(MTrw.Header)) then begin
    Mailr.Header = MTrw.Header;
  end else begin
    if (nonblank(IVMailr.Header)) then begin
      Mailr.Header = IVMailr.Header & " ";
    end;
    Mailr.Header = Mailr.Header;
  end;
  AddIVArrayToMailHeader(Mailr.Header,IVSerNrs);
  
  if (nonblank(MTrw.FirstTxt)) then begin
    LTxtr.Code = MTrw.FirstTxt;
  end else begin
    LTxtr.Code = IVMailr.FirstTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    Mailr.HtmlFlag = LTxtr.HtmlFlag;
  end;
  if (Mailr.HtmlFlag==0) then begin
    if (nonblank(MTrw.LastTxt)) then begin
      LTxtr.Code = MTrw.LastTxt;
    end else begin
      LTxtr.Code = IVMailr.LastTxt;
    end;
    if (ReadFirstMain(LTxtr,1,true)) then begin
      Mailr.HtmlFlag = LTxtr.HtmlFlag;
    end;
  end;
  
  Mailr.TransDate = CurrentDate;
  Mailr.SerNr = NextSerNr("MailVc",Mailr.TransDate,-1,false,"");
  if (RecordStore(Mailr,false)) then begin
    for (i = 0; i<IVSerNrs.length; i = i + 1) begin
      IVr.SerNr = IVSerNrs[i];
      if (ReadFirstMain(IVr,1,true)) then begin
        CreateRecordLink(Mailr,CurrentCompany,IVr,CurrentCompany);
        CreateRecordLink(IVr,CurrentCompany,Mailr,CurrentCompany);
      end;
    end;
  end;
  RecordCopy(Mail2r,Mailr);
  
  if (nonblank(MTrw.FirstTxt)) then begin
    LTxtr.Code = MTrw.FirstTxt;
  end else begin
    LTxtr.Code = IVMailr.FirstTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    if (Mailr.HtmlFlag==0) then begin
      rwcnt = LineTextCnt(LTxtr);
      for (i=0;i<rwcnt;i=i+1) begin
        tstr = LineTextGet(LTxtr,i);
        LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
      end;
      AddCRToText(Mailr);
    end else begin
      if (LTxtr.HtmlFlag==0) then begin
        AddToHtmlRecord(Ltxtr,false,Mailr,true,true);
      end else begin
        AddHtmlRecordToHtmlRecord(Ltxtr,Mailr,true);
      end;
    end;
  end;
  if (additemstobodyf or IgnoreRecordDetails==0) then begin
    for (i2 = 0; i2<IVSerNrs.length; i2 = i2 + 1) begin
      IVr.SerNr = IVSerNrs[i2];
      if (ReadFirstMain(IVr,1,true)) then begin
        switch (IVr.InvType) begin
          case kInvoiceTypeCredit:
            tstr = USetStr(1805) & " ";
          case kInvoiceTypeCreditSpecialSales:
            tstr = USetStr(1805) & " ";
          otherwise
            tstr = USetStr(1803) & " ";
        end;
        tstr = tstr & IVr.SerNr;
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        tstr = "====================";
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        rwcnt = MatRowCnt(IVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==10) then begin 
            goto LIVArrayHIDDENLine;
          end;
          tstr = IVrw.ArtCode & TAB;
          tstr = tstr & ValToString(IVrw.Quant,M4UVal,"",".",0) & TAB;
          tstr = tstr & Left(IVrw.Spec,60) & TAB;
          tstr = tstr & IVrw.Price & TAB;
          if (IVrw.vRebate!=0) then begin
            tstr = tstr & "-" & ValToString(IVrw.vRebate,M4UVal,"",".",0) & "%" & TAB;
          end;
          tstr = tstr & IVrw.Sum & TAB;
          if (Mailr.HtmlFlag==0) then begin
            LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
          end else begin
            LineTextPutToHtmlRecord(Mailr,tstr,false,true);
          end;
        end;
LIVArrayHIDDENLine:;
        tstr = TAB & TAB & TAB & "=====";
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        tstr = TAB & TAB & TAB & USetStr(2685) & TAB & IVr.Sum1;
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        tstr = TAB & TAB & TAB & USetStr(2686) & TAB & IVr.Sum3;
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        tstr = TAB & TAB & TAB & USetStr(2687) & TAB & IVr.Sum4;
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
        GetPayDealText(IVr.PayDeal,IVr.LangCode,tstr);
        tstr = USetStr(3060) & " " & tstr;
        if (Mailr.HtmlFlag==0) then begin
          LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
        end else begin
          LineTextPutToHtmlRecord(Mailr,tstr,false,true);
        end;
      end;
      if (Mailr.HtmlFlag==0) then begin
        LineTextPut(Mailr,LineTextCnt(Mailr),"");
        LineTextPut(Mailr,LineTextCnt(Mailr),"");
      end else begin
        LineTextPutToHtmlRecord(Mailr,"",false,true);
        LineTextPutToHtmlRecord(Mailr,"",false,true);
      end;
    end;
  end;
  if (nonblank(MTrw.LastTxt)) then begin
    LTxtr.Code = MTrw.LastTxt;
  end else begin
    LTxtr.Code = IVMailr.LastTxt;
  end;
  if (ReadFirstMain(LTxtr,1,true)) then begin
    if (Mailr.HtmlFlag==0) then begin
      rwcnt = LineTextCnt(LTxtr);
      for (i=0;i<rwcnt;i=i+1) begin
        tstr = LineTextGet(LTxtr,i);
        LineTextPut(Mailr,LineTextCnt(Mailr),tstr);
      end;
      AddCRToText(Mailr);
    end else begin
      if (LTxtr.HtmlFlag==0) then begin
        AddToHtmlRecord(Ltxtr,false,Mailr,true,true);
      end else begin
        AddHtmlRecordToHtmlRecord(Ltxtr,Mailr,true);
      end;
    end;
  end;
  
  RecordUpdate(Mail2r,Mailr,false);
  
  for (i = 0; i<IVSerNrs.length; i = i + 1) begin
    IVr.SerNr = IVSerNrs[i];
    if (ReadFirstMain(IVr,1,true)) then begin
      docname = pdfform;
      if (blank(docname)) then begin
        docname = "InvForm";
        switch (IVr.InvType) begin
          case kInvoiceTypeCash: docname = "CashInvForm";
          case kInvoiceTypeCashInvoiceReceiptPRT: docname = "CashInvRecPRTForm";
          case kInvoiceTypeCredit: docname = "CredInvForm";
          case kInvoiceTypeInterest: docname = "IIInvForm";
          case kInvoiceTypeCreditSpecialSales: docname = "CredInvForm";
        end;
        if ((IVr.InvType==kInvoiceTypeNormal or IVr.InvType==kInvoiceTypeNormalSpecialSales) or (IVr.InvType==kInvoiceTypeDownpayment)) then begin
          if (nonblank(IVr.PRCode)) then begin
            docname = "ProjInvForm";
          end;
        end;
      end;
      fname = "tmp/" & USetStr(1803) & " " & IVr.SerNr & ".pdf";
      SetDocumentFilename(fname);
      SetMedia(mtPdf);
      PrintDocument(IVr,docname,false);
      if (FileExists(fname)) then begin
        if (RecordLinkFile(fname,0,Mailr,CurrentCompany)) then begin
          RecordCopy(oldIVr,IVr);
          IVr.Prntdf = 1;
          RecordUpdate(oldIVr,IVr,false);
        end;
      end;
      SetDocumentFilename("");
      Delete_File(fname);
    end;
  end;
  
LCreateMailFromIVArray:;
  CreateMailFromIVArray = res;
end;

global
function Boolean DoCLInFromIVDRemote(record IVVc IVr,var record CLInVc CLInr)
begin
  LongInt clin;
  record MainCLBlock MainCLRec;
  string 255 tstr;
  val frrate,to1,to2,br1,br2;
  string 10 curncy;
  Boolean res;
  row CLInVc CLInrw;
  Integer rwcnt,err;
  row IVVc IVrw;
  Integer i;

  res = true;
  BlockLoad(MainCLRec);
  if (MainCLRec.CashCollection!=0) then begin
    if (IVr.InvType!=kInvoiceTypeCash and IVr.InvType!=kInvoiceTypeCashInvoiceReceiptPRT) then begin
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (GetCreditedInvoiceType(IVr)!=2) then begin
          res = true;
          goto LDoCLInFromIVD;
        end;
      end else begin
        res = true;
        goto LDoCLInFromIVD;
      end;
    end;
    if (CLInforIVExists(IVr.SerNr,"IVVc",clin)) then begin
      res = true;
      goto LDoCLInFromIVD;
    end;
  end;
  RecordNew(CLinr);
  CLInr.RefStr = USetStr(1150) & "." & IVr.SerNr;
  CLInr.SerNr = -1;
  CLInr.NetVal = IVr.Sum1;
  CLInr.VATVal = IVr.Sum3;
  CLInr.Total = IVr.Sum4-IVr.TAX1Sum;
  CLInr.TAX1Sum = IVr.TAX1Sum;
  if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
    CLInr.NetVal = -CLInr.NetVal;
    CLInr.VATVal = -CLInr.VATVal;
    CLInr.Total = -CLInr.Total;
  end;   
  CLInr.TransDate = CurrentDate;
  CLInr.PayMode = IVr.PayDeal;
  if (GetPM(CLInr.PayMode,tstr,tstr)==false) then begin
    CLInr.PayMode = "";
  end;  
  if (blank(CLInr.PayMode)) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==kInvoiceRowTypeCashPayment) or (IVrw.stp==kInvoiceRowTypeLoyaltyPointsPayment) then begin
        CLInr.PayMode = IVrw.PayMode;
      end;
    end;
  end;
  if (blank(CLInr.PayMode)) then begin
    CLInr.PayMode = MainCLRec.DefPM;
  end;
  CLInr.CorspCode = MainCLRec.DefCorspCode;
  SetSalesMan(tstr,IVr.SalesMan);
  CLInr.Person = tstr;  
  CLInr.ARonTR = IVr.ARonTR;
  CLInr.CUCode = IVr.CustCode;
  CLInr.CUName = IVr.Addr0;
  CLInr.Addr0 = IVr.Addr1;
  CLInr.Addr1 = IVr.Addr2;
  CLInr.Addr2 = IVr.Addr3;
  CLInr.Addr3 = IVr.InvAddr3;
  CLInr.Addr4 = IVr.InvAddr4;
  CLInr.Comment = IVr.InvComment;
  CLInr.CurncyCode = IVr.CurncyCode;
//    CLInr.VATCode = IVr.VATCode;
  curncy = CLInr.CurncyCode;
  GetFullCurncyRate(curncy,CLInr.TransDate,frrate,to1,to2,br1,br2);
  CLInr.CurncyCode = curncy;
  CLInr.FrRate = frrate;
  CLInr.ToRateB1 = to1; 
  CLInr.ToRateB2 = to2;
  CLInr.BaseRate1 = br1;
  CLInr.BaseRate2 = br2;
  if (MainCLRec.CashCollection==0) then begin
    if (IVr.InvType!=kInvoiceTypeCash and IVr.InvType!=kInvoiceTypeCashInvoiceReceiptPRT) then begin
      ClearRow(CLInr,CLInrw,1);
      CLInrw.Type = 1;
      CLInrw.TransNr = IVr.SerNr;
      CLInrw.TransOfficialSerNr = IVr.OfficialSerNr;
      rwcnt = MatRowCnt(CLInr);
      MatRowPut(CLInr,rwcnt,CLInrw);
      err = CLInVc_PasteTransNr(CLInr,rwcnt);
    end;
    if (err==0) then begin
      CLInr.FileName = "IVVc";
      CLInr.FSerNr = IVr.SerNr;  
    end;
  end else begin
    CLInr.FileName = "IVVc";
    CLInr.FSerNr = IVr.SerNr;  
  end;
LDoCLInFromIVD:;
  DoCLInFromIVDRemote = res;
  return;
end;

global
procedure PastePDInInv(var record IVVc IVp,string prevpaydeal,Boolean pastepdpricelistf)
BEGIN
  record PDVc prevPDr;
  record PDVc PDr;
  Integer i,mrwcnt;
  LongInt restdays;
  Date td;
  Integer newInvType,pdtype;
  LongInt sernr;
  record ModuleBlock mt;
  record AccBlock ARAccRec;
  record CCatVc CCatr;
  record CUVc CUr;

  if (nonblank(prevpaydeal)) then begin
    prevPDr.Code = prevpaydeal;
    if (GetPD(prevPDr)) then begin
    end;
  end;
  PDr.Code = IVp.PayDeal;
  if (GetPD(PDr)) then begin
    goto LSkipMainCL;
  end;
   IVp.PayDeal = "";
   goto LPastePDInInv;

LSkipMainCL:;
    BlockLoad(ARAccRec);
    IVp.PayDeal = PDr.Code;
    IVp.pdays = PDr.pdays;
    IVp.pdvrebt = PDr.pdvrebt;
    IVp.pdvrebt2 = PDr.pdvrebt2;
    IVp.pdrdays = PDr.pdrdays;
    IVp.pdrdays2 = PDr.pdrdays2;
    IVp.pdComment = "";
    if (nonblank(PDr.Installment)) then begin
      IVp.InstallmentInv = 1;
    end else begin
      IVp.InstallmentInv = 0;
    end;
    pdtype = PDr.PDType;
//    if ((blank(IVp.PriceList)) and (nonblank(PDr.PriceList))) then begin
    if (pastepdpricelistf) then begin
//      if (((nonblank(IVp.PriceList)) or (nonblank(PDr.PriceList))) and (IVp.PriceList!=PDr.PriceList)) then begin
      if ((nonblank(PDr.PriceList)) and (IVp.PriceList!=PDr.PriceList)) then begin
        IVp.PriceList = PDr.PriceList;
        if (IVp.InvType!=kInvoiceTypeCredit) and (IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
          IVVc_PastePriceList(IVp);
        end;
      end;
    end;
//    end;  
L88:;
    newInvType = pdtype;

    if (pdtype==kInvoiceTypePrepayment) then begin newInvType = kInvoiceTypeInterest; end;
    if (pdtype==kInvoiceTypeInterest) then begin newInvType = kInvoiceTypeNormal; end;
    if (pdtype==kInvoiceTypeDebit) then begin newInvType = kInvoiceTypeInterest; end; // 5 is a manual Interest Inv.
    if (pdtype==kInvoiceTypeDownpayment) then begin newInvType = kInvoiceTypeNormal; end;
    if (pdtype==0) then begin newInvType = kInvoiceTypeNormal; end;
//    if (IVp.InvType<kInvoiceTypeInterest) or (prevPDr.PDType==kInvoiceTypeDebit) or (prevPDr.PDType==kInvoiceTypeNormalSpecialSales) then begin
    if (IVp.InvType!=kInvoiceTypeInterest and IVp.InvType!=kInvoiceTypeDownpayment) or (prevPDr.PDType==kInvoiceTypeDebit) then begin
      IVp.InvType = newInvType;
    end;  

    if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
      BlockLoad(mt);
      
      IVp.CredMark = USetStr(1078);
      IVp.UpdStockFlag = mt.CredUpdStock;
    end else begin
      IVp.CredMark = "";
    end;

    IVVc_CalculatePayDate(IVp);
    
    if (IVp.InvType==kInvoiceTypeCash or IVp.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin
      if (nonblank(PDr.pdCashAcc)) then begin
        IVp.ARAcc = PDr.pdCashAcc;
      end else begin
        if (nonblank(ARAccRec.CashAcc)) then begin
          IVp.ARAcc = ARAccRec.CashAcc;
        end;
      end;
//    end else begin
//      IVVc_CalculatePayDate(IVp);
    end;  
  if (IVp.InvType==kInvoiceTypeCash or IVp.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin
    if (nonblank(PDr.pdCashAcc)) then begin
      IVp.ARAcc = PDr.pdCashAcc;
    end;
  end else begin
    if (nonblank(prevpaydeal)) then begin
      if (prevpaydeal!=IVp.PayDeal) then begin
        CUr.Code = IVp.CustCode;
        if (ReadFirstMain(CUr,1,true)) then begin end;
        CCatr.Code = CUr.CustCat;
        if (ReadFirstMain(CCatr,1,true)) then begin end;
        IVp.ARAcc = CCatr.ARAcc;
        if (blank(IVp.ARAcc)) then begin
          IVp.ARAcc = ARAccRec.ARAcc;
        end;    
      end;
    end;
  end;
LPastePDInInv:;
  RETURN;
END;

global
function Boolean PasteCustInInv(var record IVVc IVr)
BEGIN
  record CUVc CUr;
  Boolean found;
  
  CUr.Code = IVr.CustCode;
  found = ReadFirstMain(CUr,1,true);
  if (found) then begin
    IVr.Addr0 = CUr.Name;
    IVr.Addr1 = CUr.InvAddr0;
    IVr.Addr2 = CUr.InvAddr1;
    IVr.Addr3 = CUr.InvAddr2;
    IVr.InvAddr3 = CUr.InvAddr3;
    IVr.InvAddr4 = CUr.InvAddr4;
    IVr.ClientContact = CUr.Person;
    IVr.CustCat = CUr.CustCat;
    IVr.Objects = CUr.Objects;
    IVr.LangCode = CUr.LangCode;
    IVr.ShipDeal = CUr.ShipDeal;
    IVr.ShipMode = CUr.ShipMode;
    if (nonblank(CUr.VATCode)) then begin
      IVr.CustVATCode = CUr.VATCode;
    end;  
    if ((nonblank(CUr.DelAddr0)) or
        (nonblank(CUr.DelAddr1)) or
        (nonblank(CUr.DelAddr2))) then begin
      IVr.ShipAddr0 = CUr.Name;
      IVr.ShipAddr1 = CUr.DelAddr0;
      IVr.ShipAddr2 = CUr.DelAddr1;
      IVr.ShipAddr3 = CUr.DelAddr2;
      IVr.DelAddr3 = CUr.DelAddr3;
      IVr.DelAddr4 = CUr.DelAddr4;
    end;
    if (nonblank(CUr.CurncyCode)) then begin
      IVr.CurncyCode = CUr.CurncyCode;
    end;  
    IVr.VATNr = CUr.VATNr;
    IVr.RegNr1 = CUr.RegNr1;
    IVr.PriceList = CUr.PLCode;
    IVr.RebCode = CUr.RebCode;
    IVr.Phone = CUr.Phone;
    IVr.Fax = CUr.Fax;
    IVr.Sorting = CUr.Sorting;
    IVr.NoRemndrFlag = 0;
    IVr.NoInterestFlag = 0;
    GetPriceList(IVr.CustCat,IVr.TransDate,IVr.TransTime,IVr.PriceList,IVr.InclVAT);
    IVr.ExportFlag = CUr.ExportFlag;
    IVr.PayDeal = CUr.PayDeal;
    IVr.FiscalFlag = CUr.FiscalFlag;
    PastePDInInv(IVr,"",false);
  end;
  PasteCustInInv = found;
  RETURN;
END;

global
procedure IVVc_PasteLocation(var record IVVc IVr,Integer rownr)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  Integer exportflag;
  record INVc INr;
  val price,vreb,baseprice,tax2prc;
  string 255 curitemname,vatcode,salesacc,tax2code,location,taxtemplatecode;
  Boolean calcprice,dummyf;
  row LocationAccBlock LAbrw;
  
  if (rownr<0) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      location = IVrw.Location;
      if (blank(location)) then begin
        location = IVr.Location;
      end;
      exportflag = IVr.ExportFlag;
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
        exportflag = exportflag + AddPortugueseType;
      end;
/*
      GetItemPriceDiscount3(IVrw.ArtCode,IVrw.Quant,INr,IVr.CurncyCode,
                            IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,
                            IVr.LangCode,IVr.CustCat,IVr.PriceList,IVr.RebCode,
                            price,curitemname,vreb,vatcode,baseprice,salesacc,
                            exportflag,calcprice,IVr.TransDate,IVr.TransTime,IVr.CustCode,true,dummyf,IVr.PayDeal,
                            tax2code,tax2prc,IVr.Region,location,taxtemplatecode);
*/
      if (FindLocationAccRow(location,LAbrw)) then begin
        switch (exportflag) begin
          case 1: salesacc = LAbrw.EUSalesAcc;
          case 2: salesacc = LAbrw.ExpSalesAcc;
          case 3: salesacc = LAbrw.EUSalesAcc;
          case 4: salesacc = LAbrw.ExpSalesAcc;
          otherwise salesacc = LAbrw.SalesAcc;
        end;
        if (nonblank(salesacc)) then begin
          IVrw.SalesAcc = salesacc;
          MatRowPut(IVr,i,IVrw);
        end;
      end;
    end;
  end else begin
    MatRowGet(IVr,rownr,IVrw);
    location = IVrw.Location;
    if (blank(location)) then begin
      location = IVr.Location;
    end;
    exportflag = IVr.ExportFlag;
    if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
      exportflag = exportflag + AddPortugueseType;
    end;
/*
    GetItemPriceDiscount3(IVrw.ArtCode,IVrw.Quant,INr,IVr.CurncyCode,
                          IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,
                          IVr.LangCode,IVr.CustCat,IVr.PriceList,IVr.RebCode,
                          price,curitemname,vreb,vatcode,baseprice,salesacc,
                          exportflag,calcprice,IVr.TransDate,IVr.TransTime,IVr.CustCode,true,dummyf,IVr.PayDeal,
                          tax2code,tax2prc,IVr.Region,location,taxtemplatecode);
*/
    if (FindLocationAccRow(location,LAbrw)) then begin
       switch (exportflag) begin
        case 1: salesacc = LAbrw.EUSalesAcc;
        case 2: salesacc = LAbrw.ExpSalesAcc;
        case 3: salesacc = LAbrw.EUSalesAcc;
        case 4: salesacc = LAbrw.ExpSalesAcc;
        otherwise salesacc = LAbrw.SalesAcc;
      end;
      if (nonblank(salesacc)) then begin
        IVrw.SalesAcc = salesacc;
        MatRowPut(IVr,i,IVrw);
      end;
    end;
  end;
  IVSumup(IVr,true); 
  return;
end;

global
function Integer IVVc_CalcRetentionLine(var record IVVc IVr,var val retentionv,var string retentionacc,var string retentionvatcode)
begin
  Integer res;
  record PRVc PRr;
  val v;
  record PRAccBlock PRAb;
  
  retentionacc = "";
  retentionv = blankval;
  PRr.Code = IVr.PRCode;
  if (ReadFirstMain(PRr,1,true)) then begin
    BlockLoad(PRAb);
    retentionv = PRr.RetSum - PRr.RetInvd;
    retentionacc = PRAb.RetentionAcc;
    retentionvatcode = PRAb.RetentionVATCode;
    if (blank(retentionacc)) then begin
      res = 22083;
    end;
  end;
  IVVc_CalcRetentionLine = res;
  return;
end;

global 
function Boolean FindLastInvoiceRowForSerial(LongInt invoice,string customer,string serialnr, var row IVVc IVrw)
begin
  record ItemHistVc IHr;
  record IVVc IVr;
  Boolean res;
  Boolean TrHs;
    
  IHr.SerialNr = serialnr;
  IHr.FileName  = "IVVc";
  TrHs = true;
  if (LoopBackKey("SerialNr",IHr,2,TrHs)) then begin
    if (IHr.SerialNr<>serialnr) then begin 
      TrHs = false;
    end;  
    if (IHr.FileName<>"IVVc") then begin 
      TrHs = false;
    end;
    if TrHs then begin   
      IVr.SerNr = IHr.TransNr;
      if ReadFirstMain(IVr,1,true) then begin 
        if (IVr.InvType<>kInvoiceTypeCredit and IVr.InvType!=kInvoiceTypeCreditSpecialSales) and (IVr.CustCode==customer) and (IVr.SerNr<>invoice)  then begin 
          MatRowGet(IVr,IHr.Row,IVrw);
          res = true;
          TrHs = false;
        end;
      end;
    end;  
  end;
  FindLastInvoiceRowForSerial = res;
  return;
end;  

global
updating procedure SendPamFaxIV()
begin
  integer wn;
  record IVVc IVr;

  wn = CurWindow;
  GetWindowRecord(wn,IVr);
  SendPamFaxIVRemote(IVr);
  return;
end;

function Boolean TestXSrsExists(LongInt sernr)
begin
  Boolean res;
  record XSrsVc XSrsr;

  XSrsr.TransType = 0;
  XSrsr.ToFileName = "IVVc";
  XSrsr.ToSerNr = sernr;
  res = ReadFirstKey("MainKey",XSrsr,3,true);
  TestXSrsExists = res;
  return;
end;

global
function Boolean TestIVDClassInsertRow(record IVVc IVr)
begin
  Boolean res;

//  res = !TestXSrsExists(IVr.SerNr);  
  TestIVDClassInsertRow = res;
  return;
end;

global
function Boolean TestIVDClassDeleteRow(record IVVc IVr)
begin
  Boolean res;

//  res = !TestXSrsExists(IVr.SerNr);  
  TestIVDClassDeleteRow = res;
  return;
end;

global
function Integer CalculateLoyaltyPointsPayment_IVVc(record IVVc IVr,val maxpointstouse,var val PointsBalance,var val totusedpoints,var val totsumb1)
begin
  Integer err;
  row IVVc IVrw;
  record LoyPointsRedeemVc LPRr;
  row LoyPointsRedeemVc LPRrw;
  Integer i,rwcnt;
  Integer li,lrwcnt;
  record LocLoyPointsRedeemVc LLPRr;
  row LocLoyPointsRedeemVc LLPRrw;
  row LocLoyPointsRedeemVc foundLLPRrw;
  Boolean found,testf,calculatedf;
  val usedpoints,maxpayment,sum,t;
  record BaseCurBlock BCb;
  record INVc INr;
  record LoyaltyCardVc LCr;
  roundmode rnd;

  err = 0;
  LCr.SerNr = IVr.LoyaltyCardNr;
  if (ReadFirstMain(LCr,1,true)==false) then begin
    err = 26434;
    goto LCalculateLoyaltyPointsPayment_IVVc;
  end;
  if (LCr.Closed!=0) then begin
    err = 26434;
    goto LCalculateLoyaltyPointsPayment_IVVc;
  end;
  rwcnt = MatRowCnt(IVr);

  PointsBalance = LCr.PointsBalance;
  if (blank(maxpointstouse)==false) then begin
    if (maxpointstouse<PointsBalance) then begin
       PointsBalance = maxpointstouse;
    end;
  end;
  rnd = DefaultValRoundoff;
  rnd.decimals = 0;
  rnd.mode = kRoundingModeTruncate;

  LLPRr.Location = IVr.Location;
  LLPRr.LCMLevel = IVr.LCMLevel;
  found = ReadFirstMain(LLPRr,2,true);
  if (found==false) then begin
    LLPRr.Location = IVr.Location;
    found = ReadFirstMain(LLPRr,1,true);
  end;

  if (found) then begin
    lrwcnt = MatRowCnt(LLPRr);
    if (lrwcnt==0) then begin
      totsumb1 = MulRateToBase1(IVr.CurncyCode,IVr.Sum4,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
      maxpayment = PointsBalance/LLPRr.Points;
      maxpayment = maxpayment*LLPRr.Amount;
      if (totsumb1>maxpayment) then begin
        totsumb1 = maxpayment;
        totusedpoints = PointsBalance;
      end else begin
        totusedpoints = Round((PointsBalance*totsumb1)/maxpayment,rnd);
      end;
    end else begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        calculatedf = false;
        if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeVoid) then begin
          sum = IVrw.Sum;
          if (IVrw.stp==kInvoiceRowTypeVoid) then begin
            sum = -sum;
          end;
          for (li=0;li<lrwcnt;li=li+1) begin
            MatRowGet(LLPRr,li,LLPRrw);
            testf = false;
            switch (LLPRrw.CodeType) begin
              case 0:
                if (ReadFirstItem(IVrw.ArtCode,INr,true,true)) then begin 
                  if (INr.Group==LLPRrw.ITCode) then begin
                    testf = true;
                  end;  
                end;
              case 1:
                if (IVrw.ArtCode==LLPRrw.ITCode) then begin
                  testf = true;
                end;  
            end;
            if (testf) then begin
              t = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
              usedpoints = PointsBalance - totusedpoints;
              maxpayment = usedpoints/LLPRrw.Points;
              maxpayment = maxpayment*LLPRrw.Amount;
              if (t>maxpayment) then begin
                t = maxpayment;
              end else begin
                usedpoints = Round((usedpoints*totsumb1)/maxpayment,rnd);
              end;
              totsumb1 = totsumb1 + t;
              totusedpoints = totusedpoints + usedpoints;
              calculatedf = true;
              li = lrwcnt;
            end;
          end;
          if (calculatedf==false) then begin
            t = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
            usedpoints = PointsBalance - totusedpoints;
            maxpayment = usedpoints/LLPRr.Points;
            maxpayment = maxpayment*LLPRr.Amount;
            if (t>maxpayment) then begin
              t = maxpayment;
            end else begin
              usedpoints = Round((usedpoints*totsumb1)/maxpayment,rnd);
            end;
            totsumb1 = totsumb1 + t;
            totusedpoints = totusedpoints + usedpoints;
          end;
        end;
      end;
    end;
  end else begin
    LPRr.LCMLevel = IVr.LCMLevel;
    found = ReadFirstMain(LPRr,2,true);
    if (found==false) then begin
      LPRr.LCMLevel = "";
      found = ReadFirstMain(LPRr,1,true);
    end;
    if (found) then begin
      lrwcnt = MatRowCnt(LPRr);
      if (lrwcnt==0) then begin
        totsumb1 = MulRateToBase1(IVr.CurncyCode,IVr.Sum4,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
        maxpayment = PointsBalance/LPRr.Points;
        maxpayment = maxpayment*LPRr.Amount;
        if (totsumb1>maxpayment) then begin
          totsumb1 = maxpayment;
          totusedpoints = PointsBalance;
        end else begin
          totusedpoints = Round((PointsBalance*totsumb1)/maxpayment,rnd);
        end;
      end else begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeVoid) then begin
            sum = IVrw.Sum;
            if (IVrw.stp==kInvoiceRowTypeVoid) then begin
              sum = -sum;
            end;
            calculatedf = false;
            for (li=0;li<lrwcnt;li=li+1) begin
              MatRowGet(LPRr,li,LPRrw);
              testf = false;
              switch (LPRrw.CodeType) begin
                case 0:
                  if (ReadFirstItem(IVrw.ArtCode,INr,true,true)) then begin 
                    if (INr.Group==LPRrw.ITCode) then begin
                      testf = true;
                    end;  
                  end;
                case 1:
                  if (IVrw.ArtCode==LPRrw.ITCode) then begin
                    testf = true;
                  end;  
              end;
              if (testf) then begin
                t = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
                usedpoints = PointsBalance - totusedpoints;
                maxpayment = usedpoints/LPRrw.Points;
                maxpayment = maxpayment*LPRrw.Amount;
                if (t>maxpayment) then begin
                  t = maxpayment;
                end else begin
                  usedpoints = Round((usedpoints*totsumb1)/maxpayment,rnd);
                end;
                totsumb1 = totsumb1 + t;
                totusedpoints = totusedpoints + usedpoints;
                calculatedf = true;
                li = lrwcnt;
              end;
            end;
            if (calculatedf==false) then begin
              t = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
              usedpoints = PointsBalance - totusedpoints;
              maxpayment = usedpoints/LPRr.Points;
              maxpayment = maxpayment*LPRr.Amount;
              if (t>maxpayment) then begin
                t = maxpayment;
              end else begin
                usedpoints = Round((usedpoints*totsumb1)/maxpayment,rnd);
              end;
              totsumb1 = totsumb1 + t;
              totusedpoints = totusedpoints + usedpoints;
            end;
          end;
        end;
      end;
    end;
  end;
LCalculateLoyaltyPointsPayment_IVVc:;  
  CalculateLoyaltyPointsPayment_IVVc = err;
  return;
end;

global
procedure LoyaltyPointsPayment_IVVc(var record IVVc IVr,val maxpointstouse,string paymode)
begin
  Boolean found;
  val totsumb1,totusedpoints;
  record BaseCurBlock BCb;
  row IVVc IVrw;
  val PointsBalance;

  if (IVr.OKFlag==0) and nonblank(IVr.LoyaltyCardNr) then begin
      found = CalculateLoyaltyPointsPayment_IVVc(IVr,maxpointstouse,PointsBalance,totusedpoints,totsumb1)==0;

      if (found) then begin
        BlockLoad(BCb);
        ClearRow(IVr,IVrw,kInvoiceRowTypeLoyaltyPointsPayment);        
        IVrw.Points = totusedpoints;
        IVrw.Sum = totsumb1;
        IVrw.CurncyCode = IVr.CurncyCode;
        GetFullCurncyRate(IVrw.CurncyCode,IVr.TransDate,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2);
        CurValToOtherCur(IVr.TransDate,BCb.BaseCur1,IVrw.Sum,IVrw.CurncyCode,IVrw.Sum,DefaultCurRoundOff);
        IVrw.PayMode = paymode;        
        IVrw.Spec = UsetStr(24182);
        MatRowPut(IVr,MatRowCnt(IVr),IVrw);
      end;
  end;
  return;
end;  

global
function Boolean IVVc_PasteQuantityRemote(var record IVVc IVr,Integer rownr,string lmcode,string defretloc,var Boolean serportf,var record LSerialPortDeviceVc LSPDr)
begin
  Boolean res;
  Boolean chsum;
  record ModuleBlock OptFeature;
  
  BlockLoad(OptFeature);
  if (OptFeature.NoQtyDepPrices==0) then begin
    IVVc_PasteQuant(IVr,rownr,true,chsum,defretloc);
  end;
  IVSumup(IVr,true);
    
  IVVc_PasteQuantityRemote = true;
  return;
end;

global
procedure GetSerialNumberCountryOfOrg(string filename,LongInt transnr,LongInt rownr,string artcode,string serialnr,var string countryoforg,var string customsnr)
begin
  record ItemHistVc IHr;
  record ItemHistVc PUsourceIHr;
  record PUVc PUr;
  row PUVc PUrw;
  Integer i,rwcnt;
  Boolean found;
  
  countryoforg = "";
  customsnr = "";
  if (nonblank(filename)) and (transnr>0) and (rownr>=0) then begin
    IHr.FileName = filename;
    IHr.TransNr = transnr;
    IHr.Row = rownr;
    found = ReadFirstKey("FNTransNr",IHr,3,true);
    if (found) then begin
       FindSourcePU(IHr.SerNr,PUsourceIHr);
       PUr.SerNr = PUsourceIHr.TransNr;
       found = ReadFirstMain(PUr,1,true);
    end;
  end;
  if (found==false) then begin
    IHr.ArtCode = artcode;
    IHr.SerialNr = serialnr;
    IHr.FileName = "PUVc";
    if (ReadFirstKey("ArtCodeSerialNr",IHr,3,true)) then begin
      PUr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PUr,1,true)) then begin
      end;  
    end;
  end;
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if ((PUrw.ArtCode==artcode) and (PUrw.SerialNr==serialnr)) then begin
      customsnr = PUrw.CustomsNr;
      countryoforg = PUrw.CountryOfOrg;
    end;
  end;      
  return;
end;

global
function string 255 FindTaxAuthID(string TaxAuthID,record IVVc IVr)
begin
  record CUVc CUr;
  record LegalInvNrBlock LINBb;
  row LegalInvNrBlock LINBbrw;
  Integer i,rwcnt;
  string 255 res,invserie,invnumber,branchid;
  Boolean testf;
 
  BlockLoad(LINBb);
  if (nonblank(TaxAuthID)) then begin
    res = TaxAuthID;
    goto LFindTaxAuthID;
  end;
  if (HasLocalization("BOL")) then begin
    branchid = IVr.BranchID;
    if (blank(branchid)) then begin
      branchid = CurBranchID;
    end;
    rwcnt = MatRowCnt(LINBb);    
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINBb,i,LINBbrw);
      testf = true;        
      if (branchid!=LINBbrw.Branch) then begin//CAR+
        testf = false;        
      end;      
      if (DateInRange(IVr.TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
        testf = false;
      end;
      if (testf) then begin        
        res = LINBbrw.TaxAuthID;
        goto LFindTaxAuthID;
      end;
    end;
  end;

  CUr.Code = IVr.CustCode;
  ReadFirstMain(CUr,1,true);
  invnumber = FindNumberAfterSymbol(IVr.OfficialSerNr,2,"-",false);
  invserie = Left(IVr.OfficialSerNr,Len(IVr.OfficialSerNr)-Len(invnumber));
  PrepareOfficialSerialNrBlock_IVVc(LINBb);
  rwcnt = MatRowCnt(LINBb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINBb,i,LINBbrw);
    testf = true;   
    testf = TestNextOfficialSerialNr_IVVc(LINBbrw,CUr.Classification,IVr,false);
    if (invserie!=LINBbrw.Serie) then begin
      testf = false;
    end;
    if (invnumber<LINBbrw.TSerStart) or (invnumber>LINBbrw.TSerEnd) then begin
      testf = false;
    end;
    if (DateInRange(IVr.TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
      testf = false;
    end;
    if (testf) then begin
      res = LINBbrw.TaxAuthID;
      goto LFindTaxAuthID;
    end;
  end;

LFindTaxAuthID:;
  FindTaxAuthID = res;
  return;
end;

global
function Date FindTaxAuthIDToDate(record IVVc IVr)
begin
  record CUVc CUr;
  record LegalInvNrBlock LINBb;
  row LegalInvNrBlock LINBbrw;
  Integer i,rwcnt;
  string 255 res,invserie,invnumber;
  Boolean testf;

  if (HasLocalization("BOL")) then begin
    BlockLoad(LINBb);
    rwcnt = MatRowCnt(LINBb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINBb,i,LINBbrw);
      testf = true;    
      if (IVr.BranchID!=LINBbrw.Branch) then begin
        testf = false;
      end;
      if (DateInRange(IVr.TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        res = LINBbrw.EndDate;
        goto LFindTaxAuthIDToDate;
      end;
    end;
  end else begin
    BlockLoad(LINBb);
  
    rwcnt = MatRowCnt(LINBb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINBb,i,LINBbrw);
      CUr.Code = IVr.CustCode;
      ReadFirstMain(CUr,1,true);
      invnumber = FindNumberAfterSymbol(IVr.OfficialSerNr,2,"-",false);
      invserie = Left(IVr.OfficialSerNr,Len(IVr.OfficialSerNr)-Len(invnumber));
      PrepareOfficialSerialNrBlock_IVVc(LINBb);
      rwcnt = MatRowCnt(LINBb);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(LINBb,i,LINBbrw);
        testf = true;   
        testf = TestNextOfficialSerialNr_IVVc(LINBbrw,CUr.Classification,IVr,false);
        if (invserie!=LINBbrw.Serie) then begin
          testf = false;
        end;
        if (invnumber<LINBbrw.TSerStart) or (invnumber>LINBbrw.TSerEnd) then begin
          testf = false;
        end;
       if (DateInRange(IVr.TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
          testf = false;
        end;
        if (testf) then begin
          res = LINBbrw.EndDate;
          goto LFindTaxAuthIDToDate;
        end;  
      end;
    end;
  end;
LFindTaxAuthIDToDate:;
  FindTaxAuthIDToDate = res;
  return;
end;

global
function Date FindTaxAuthIDLimitDateBOL(record IVVc IVr)
begin
  record LegalInvNrBlock LINBb;
  row LegalInvNrBlock LINBbrw;
  Integer i,rwcnt;
  Date res;
  Boolean testf;
  string 255 ofinvno,branchid;
  
  branchid = IVr.BranchID;
  if (blank(branchid)) then begin
    branchid = CurBranchID; 
  end;
  GetLegalInvNrRow(IVr.OfficialSerNr,LINBbrw);
  ofinvno = Right(IVr.OfficialSerNr,len(IVr.OfficialSerNr)-Len(LINBbrw.Serie));
 
  BlockLoad(LINBb);
  rwcnt = MatRowCnt(LINBb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINBb,i,LINBbrw);
    testf = true;    
    if ((ofinvno<LINBbrw.TSerStart) or (ofinvno>LINBbrw.TSerEnd)) then begin
      testf = false;
    end;
    if (branchid!=LINBbrw.Branch) then begin
      testf = false;
    end;
    if (DateInRange(IVr.TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
      testf = false;
    end;
    if (testf) then begin
      res = LINBbrw.EndDate;
      goto LFindTaxAuthIDLimitDateBOL;
    end;
  end;
LFindTaxAuthIDLimitDateBOL:;
  FindTaxAuthIDLimitDateBOL = res;
  return;
end;

function string 255 FindTaxBOLAuthIDDKey(LongInt SerNr,Date TransDate)
begin
  record LegalInvNrBlock LINBb;
  row LegalInvNrBlock LINBbrw;
  Integer i,rwcnt;
  string 255 res;
  Boolean testf;
  record IVVc IVr;
  string 255 branchid;
      
  branchid = IVr.BranchID;
  if (blank(branchid)) then begin
    branchid = CurBranchID; 
  end;
  BlockLoad(LINBb);
  rwcnt = MatRowCnt(LINBb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINBb,i,LINBbrw);
    testf = true;    
    if (branchid!=LINBbrw.Branch) then begin//CAR+
      testf = false;
    end;
    if (DateInRange(TransDate,LINBbrw.PurchDate,LINBbrw.EndDate)==false) then begin
      testf = false;
    end;
    if (testf) then begin
      res = LINBbrw.DosageKey;
      goto LFindTaxBOLAuthIDDKey;
    end;
  end;
LFindTaxBOLAuthIDDKey:;
  FindTaxBOLAuthIDDKey = res;
  return;
end;

global
function string 255 FindTaxAuthIDDosageKey(string TaxAuthID,record IVVc IVr)
begin
  record CUVc CUr;
  record LegalInvNrBlock LINBb;
  row LegalInvNrBlock LegalInvNrBlbrw;
  Integer i,rwcnt;
  string 255 res,invserie,invnumber;
  Boolean testf;
  
  BlockLoad(LINBb);

  if (nonblank(TaxAuthID)) then begin
    rwcnt = MatRowCnt(LINBb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINBb,i,LegalInvNrBlbrw);
      if (LegalInvNrBlbrw.TaxAuthID==TaxAuthID) then begin
        if (DateInRange(IVr.TransDate,LegalInvNrBlbrw.PurchDate,LegalInvNrBlbrw.EndDate)==true) then begin
          res = LegalInvNrBlbrw.DosageKey;
          goto LFindTaxAuthIDDosageKey;
         end;  
      end;
    end;  
  end else begin
    CUr.Code = IVr.CustCode;
    ReadFirstMain(CUr,1,true);
    invnumber = FindNumberAfterSymbol(IVr.OfficialSerNr,2,"-",false);
    invserie = Left(IVr.OfficialSerNr,Len(IVr.OfficialSerNr)-Len(invnumber));
    PrepareOfficialSerialNrBlock_IVVc(LINBb);
    rwcnt = MatRowCnt(LINBb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINBb,i,LegalInvNrBlbrw);
      testf = true;   
      testf = TestNextOfficialSerialNr_IVVc(LegalInvNrBlbrw,CUr.Classification,IVr,false);
      if (invserie!=LegalInvNrBlbrw.Serie) then begin
        testf = false;
      end;
      if (invnumber<LegalInvNrBlbrw.TSerStart) or (invnumber>LegalInvNrBlbrw.TSerEnd) then begin
        testf = false;
      end;
      if (DateInRange(IVr.TransDate,LegalInvNrBlbrw.PurchDate,LegalInvNrBlbrw.EndDate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        res = LegalInvNrBlbrw.DosageKey;
        goto LFindTaxAuthIDDosageKey;
      end;
    end;
  end;
LFindTaxAuthIDDosageKey:;
  FindTaxAuthIDDosageKey = res;
  return;
end;

procedure InitVerhoeffD(Array Integer Djk)
begin
  Djk[0] = 0; Djk[1] = 1; Djk[2] = 2; Djk[3] = 3; Djk[4] = 4; Djk[5] = 5; Djk[6] = 6; Djk[7] = 7; Djk[8] = 8; Djk[9] = 9;
  Djk[10] = 1; Djk[11] = 2; Djk[12] = 3; Djk[13] = 4; Djk[14] = 0; Djk[15] = 6; Djk[16] = 7; Djk[17] = 8; Djk[18] = 9; Djk[19] = 5;  
  Djk[20] = 2; Djk[21] = 3; Djk[22] = 4; Djk[23] = 0; Djk[24] = 1; Djk[25] = 7; Djk[26] = 8; Djk[27] = 9; Djk[28] = 5; Djk[29] = 6;
  Djk[30] = 3; Djk[31] = 4; Djk[32] = 0; Djk[33] = 1; Djk[34] = 2; Djk[35] = 8; Djk[36] = 9; Djk[37] = 5; Djk[38] = 6; Djk[39] = 7; 
  Djk[40] = 4; Djk[41] = 0; Djk[42] = 1; Djk[43] = 2; Djk[44] = 3; Djk[45] = 9; Djk[46] = 5; Djk[47] = 6; Djk[48] = 7; Djk[49] = 8;  
  Djk[50] = 5; Djk[51] = 9; Djk[52] = 8; Djk[53] = 7; Djk[54] = 6; Djk[55] = 0; Djk[56] = 4; Djk[57] = 3; Djk[58] = 2; Djk[59] = 1;  
  Djk[60] = 6; Djk[61] = 5; Djk[62] = 9; Djk[63] = 8; Djk[64] = 7; Djk[65] = 1; Djk[66] = 0; Djk[67] = 4; Djk[68] = 3; Djk[69] = 2;  
  Djk[70] = 7; Djk[71] = 6; Djk[72] = 5; Djk[73] = 9; Djk[74] = 8; Djk[75] = 2; Djk[76] = 1; Djk[77] = 0; Djk[78] = 4; Djk[79] = 3;  
  Djk[80] = 8; Djk[81] = 7; Djk[82] = 6; Djk[83] = 5; Djk[84] = 9; Djk[85] = 3; Djk[86] = 2; Djk[87] = 1; Djk[88] = 0; Djk[89] = 4;
  Djk[90] = 9; Djk[91] = 8; Djk[92] = 7; Djk[93] = 6; Djk[94] = 5; Djk[95] = 4; Djk[96] = 3; Djk[97] = 2; Djk[98] = 1; Djk[99] = 0;
  return;
end;

procedure InitVerhoeffP(Array Integer Pposnum)
begin
  Pposnum[0] = 0; Pposnum[1] = 1; Pposnum[2] = 2; Pposnum[3] = 3; Pposnum[4] = 4; Pposnum[5] = 5; Pposnum[6] = 6; Pposnum[7] = 7; Pposnum[8] = 8; Pposnum[9] = 9;
  Pposnum[10] = 1; Pposnum[11] = 5; Pposnum[12] = 7; Pposnum[13] = 6; Pposnum[14] = 2; Pposnum[15] = 8; Pposnum[16] = 3; Pposnum[17] = 0; Pposnum[18] = 9; Pposnum[19] = 4;  
  Pposnum[20] = 5; Pposnum[21] = 8; Pposnum[22] = 0; Pposnum[23] = 3; Pposnum[24] = 7; Pposnum[25] = 9; Pposnum[26] = 6; Pposnum[27] = 1; Pposnum[28] = 4; Pposnum[29] = 2;
  Pposnum[30] = 8; Pposnum[31] = 9; Pposnum[32] = 1; Pposnum[33] = 6; Pposnum[34] = 0; Pposnum[35] = 4; Pposnum[36] = 3; Pposnum[37] = 5; Pposnum[38] = 2; Pposnum[39] = 7; 
  Pposnum[40] = 9; Pposnum[41] = 4; Pposnum[42] = 5; Pposnum[43] = 3; Pposnum[44] = 1; Pposnum[45] = 2; Pposnum[46] = 6; Pposnum[47] = 8; Pposnum[48] = 7; Pposnum[49] = 0;  
  Pposnum[50] = 4; Pposnum[51] = 2; Pposnum[52] = 8; Pposnum[53] = 6; Pposnum[54] = 5; Pposnum[55] = 7; Pposnum[56] = 3; Pposnum[57] = 9; Pposnum[58] = 0; Pposnum[59] = 1;  
  Pposnum[60] = 2; Pposnum[61] = 7; Pposnum[62] = 9; Pposnum[63] = 3; Pposnum[64] = 8; Pposnum[65] = 0; Pposnum[66] = 6; Pposnum[67] = 4; Pposnum[68] = 1; Pposnum[69] = 5;  
  Pposnum[70] = 7; Pposnum[71] = 0; Pposnum[72] = 4; Pposnum[73] = 6; Pposnum[74] = 9; Pposnum[75] = 1; Pposnum[76] = 3; Pposnum[77] = 2; Pposnum[78] = 5; Pposnum[79] = 8;  
  return;
end;

procedure InitVerhoeffJ(Array Integer jinv)
begin
  jinv[0] = 0; jinv[1] = 4; jinv[2] = 3; jinv[3] = 2; jinv[4] = 1; jinv[5] = 5; jinv[6] = 6; jinv[7] = 7; jinv[8] = 8; jinv[9] = 9;
  return;
end;

function Integer VerhoeffCheck(string l)
begin
  string 255 tstr;
  Array Integer Djk;
  Array Integer Pposnum;
  Array Integer jinv;
  Array Integer la;
  Integer i,c,p,x;
  
  InitVerhoeffD(Djk);
  InitVerhoeffP(Pposnum);
  InitVerhoeffJ(jinv);
  
  ReverseString(l,tstr);
  for (i=0;i<len(tstr);i=i+1) begin
    la[i] = StringToInt(Mid(tstr,i,1));
  end;
  c = 0;
  x = 1;
  for (i=0;i<len(tstr);i=i+1) begin
    p = Pposnum[la[i] + (Mod(i,8)*10)];    
    x = x*jinv[p];    
    c = Djk[p + (c*10)];
  end;  
  VerhoeffCheck = c;
  return;
end;

function Integer VerhoeffCheckDigit(string l)
begin
  string 255 tstr;
  Array Integer Djk;
  Array Integer Pposnum;
  Array Integer jinv;
  Array Integer la;
  Integer i,c,p,x;
  
  InitVerhoeffD(Djk);
  InitVerhoeffP(Pposnum);
  InitVerhoeffJ(jinv);
  ReverseString(l & "0",tstr);
  for (i=0;i<len(tstr);i=i+1) begin
    la[i] = StringToInt(Mid(tstr,i,1));
  end;
  c = 0;
  for (i=0;i<len(tstr);i=i+1) begin
    x = StringToInt(Mid(tstr,i,1));
    p = Pposnum[x + mod(i,8)*10];       
    c = Djk[p + (c*10)];
  end;
  c = jinv[c];
  VerhoeffCheckDigit = c;
  return;
end;

function val Modulus(val v1,val v2)
begin
  val res;
  LongInt l;
  
  l = v1/v2;
  res = v1 - l*v2;
  Modulus = res;
  return;
end;

procedure Base64Dict(Array string D)
begin
  D[0]="0"; D[1]="1"; D[2]="2"; D[3]="3"; D[4]="4"; D[5]="5"; D[6]="6"; D[7]="7"; D[8]="8"; D[9]="9"; 
  D[10]="A"; D[11]="B"; D[12]="C"; D[13]="D"; D[14]="E"; D[15]="F"; D[16]="G"; D[17]="H"; D[18]="I"; 
  D[19]="J"; D[20]="K"; D[21]="L"; D[22]="M"; D[23]="N"; D[24]="O"; D[25]="P"; D[26]="Q"; D[27]="R"; D[28]="S";
  D[29]="T"; D[30]="U"; D[31]="V"; D[32]="W"; D[33]="X"; D[34]="Y"; D[35]="Z"; D[36]="a"; D[37]="b"; D[38]="c";
  D[39]="d"; D[40]="e"; D[41]="f"; D[42]="g"; D[43]="h"; D[44]="i"; D[45]="j"; D[46]="k"; D[47]="l"; D[48]="m";
  D[49]="n"; D[50]="o"; D[51]="p"; D[52]="q"; D[53]="r"; D[54]="s"; D[55]="t"; D[56]="u"; D[57]="v"; D[58]="w";
  D[59]="x"; D[60]="y"; D[61]="z"; D[62]="+"; D[63]="/";
  return;
end;

function string 255 Base64(LongInt number)
begin
  string 255 res;
  Array string 1 D;
  LongInt lnumber;
  
  lnumber = number;
  Base64Dict(D);
  while(lnumber>0)begin
  	res = D[Mod(lnumber,64)] & res; 
    lnumber = lnumber/64;
  end;
  Base64 = res;    
  return;
end;

function string 255 RC4(Array Integer key,Integer keylen,Array Integer tstr,Integer datalen)
begin
  string 255 res;
  Array Integer resi;
  Array Integer S;
  Integer i,a,b,j,k;
  Integer x,y;
  string 255 t1;
    
  for (i=0;i<256;i=i+1) begin
    S[i] = i;
  end;
  j = 0; k = 0;
  for (i=0;i<256;i=i+1) begin    
    a = S[i];
    j = Mod(j + a + key[k],256);
    S[i] = S[j]; S[j] = a;    
    k = k + 1;
    if (k>=keylen) then begin k = 0; end;            
  end;
  
  x = 0; y = 0;
  for (i=0;i<datalen;i=i+1) begin
    x = x + 1;
    a = S[x];
    y = Mod(y + a,256);
    b = S[y];
    S[x] = S[y];
    S[y] = a;
    resi[i] = BITXOR(S[Mod(a+b,256)],tstr[i]);
  end;
  for (i=0;i<datalen;i=i+1) begin
    t1 = NumToHex2(resi[i],2);
    res = res & t1;
  end;
  RC4 = res;
  return;
end;

global
function string 255 FindTaxAuthIDControlCode(string deftaxauthidcc,record IVVc IVr)
begin
  string 255 res,tstr;
  string 255 taxauthid,invno,vatnr,dates,sums,vs,dosagekey;
  val v,t;
  Array Integer keyi;
  Array Integer vsi;
  Integer i,dk1l,dk2l,dk3l,dk4l,dk5l;
  string 255 dk1,dk2,dk3,dk4,dk5;
  string 255 VD;
  LongInt tot,pa1,pa2,pa3,pa4,pa5;
  string 255 ofinvno,branchid;
  row LegalInvNrBlock LINrbrw;
  
  if (nonblank(deftaxauthidcc)) then begin
    res = deftaxauthidcc;
  end else begin
    tot = 0; pa1 = 0; pa2 = 0; pa3 = 0; pa4 = 0; pa5 = 0;
    taxauthid = FindTaxAuthID(IVr.TaxAuthID,IVr);
    if (HasLocalization("BOL")) then begin //EMZ
      dosagekey = FindTaxBOLAuthIDDKey(IVr.SerNr,IVr.TransDate);
      branchid = CurBranchID; 
      GetLegalInvNrRow(IVr.OfficialSerNr,LINrbrw);
      ofinvno = Right(IVr.OfficialSerNr,len(IVr.OfficialSerNr)-Len(LINrbrw.Serie));
      ofinvno = StringToLongInt(ofinvno);
      invno = ofinvno & VerhoeffCheckDigit(ofinvno);
    end else begin
      dosagekey = FindTaxAuthIDDosageKey(IVr.TaxAuthID,IVr);
      tstr = FindNumberAfterSymbol(IVr.OfficialSerNr,2,"-",true);    
      invno = tstr & VerhoeffCheckDigit(tstr);
    end;
    invno = invno & VerhoeffCheckDigit(invno);//2 Verhoef digits
    
    vatnr = IVr.VATNr & VerhoeffCheckDigit(IVr.VATNr);
    vatnr = vatnr & VerhoeffCheckDigit(vatnr);//2 Verhoef digits

    dates = DateToString(IVr.TransDate,"YYYYMMDD");
    dates = dates & VerhoeffCheckDigit(dates);
    dates = dates & VerhoeffCheckDigit(dates);//2 Verhoef digits
    
    t = MulRateToBase1(IVr.CurncyCode,IVr.Sum1,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
    sums = ValToString(Round(t,SetRoundModeD(0)),M40Val,"","",0);//net 
    sums = sums & VerhoeffCheckDigit(sums);
    sums = sums & VerhoeffCheckDigit(sums);//2 Verhoef digits

    v = 0;
    v = v + StringToVal(invno,M4Val);
    v = v + StringToVal(vatnr,M4Val);
    v = v + StringToVal(dates,M4Val);
    v = v + StringToVal(sums,M4Val);

    vs = ValToString(v,M40Val,"","",0);

    for (i=0;i<5;i=i+1) begin
      vs = vs & VerhoeffCheckDigit(vs);
    end;

    VD = Right(vs,5);

    dk1l = StringToInt(Mid(VD,0,1)) + 1;
    dk2l = StringToInt(Mid(VD,1,1)) + 1;
    dk3l = StringToInt(Mid(VD,2,1)) + 1;
    dk4l = StringToInt(Mid(VD,3,1)) + 1;
    dk5l = StringToInt(Mid(VD,4,1)) + 1;

    dk1 = Mid(dosagekey,0,dk1l); i = dk1l;
    dk2 = Mid(dosagekey,i,dk2l); i = i + dk2l;
    dk3 = Mid(dosagekey,i,dk3l); i = i + dk3l;
    dk4 = Mid(dosagekey,i,dk4l); i = i + dk4l;
    dk5 = Mid(dosagekey,i,dk5l);

    taxauthid = taxauthid & dk1;
    invno = invno & dk2;
    vatnr = vatnr & dk3;
    dates = dates & dk4;
    sums = sums & dk5;
    
    dosagekey = dosagekey & VD;
    vs = taxauthid & invno & vatnr & dates & sums;
    
    for (i=0;i<len(dosagekey);i=i+1) begin
      keyi[i] = asc(Mid(dosagekey,i,1));
    end;

    for (i=0;i<len(vs);i=i+1) begin
      vsi[i] = asc(Mid(vs,i,1));
    end;
    
    tstr = RC4(keyi,len(dosagekey),vsi,len(vs));
    
    for (i=0;i<len(tstr);i=i+1) begin
      tot = tot + asc(Mid(tstr,i,1));
    end;
    
    i = 1;
    while (i<=len(tstr)) begin
      pa1 = pa1 + asc(Mid(tstr,i-1,1));
      i = i + 5;
    end;
    i = 2;
    while (i<=len(tstr)) begin
      pa2 = pa2 + asc(Mid(tstr,i-1,1));
      i = i + 5;
    end;
    i = 3;
    while (i<=len(tstr)) begin
      pa3 = pa3 + asc(Mid(tstr,i-1,1));
      i = i + 5;
    end;
    i = 4;
    while (i<=len(tstr)) begin
      pa4 = pa4 + asc(Mid(tstr,i-1,1));
      i = i + 5;
    end;
    i = 5;
    while (i<=len(tstr)) begin
      pa5 = pa5 + asc(Mid(tstr,i-1,1));
      i = i + 5;
    end;  

    pa1 = pa1*tot/dk1l;
    pa2 = pa2*tot/dk2l;
    pa3 = pa3*tot/dk3l;
    pa4 = pa4*tot/dk4l;
    pa5 = pa5*tot/dk5l;

    tot = pa1 + pa2 + pa3 + pa4 + pa5;  
    vs = Base64(tot);
      
    for (i=0;i<len(vs);i=i+1) begin
      vsi[i] = asc(Mid(vs,i,1));
    end;

    tstr = RC4(keyi,len(dosagekey),vsi,len(vs));

    res = Left(tstr,2) & "-";
    res = res & Mid(tstr,2,2);
    if (len(tstr)>4) then begin
      res = res & "-";
    end;    
    res = res & Mid(tstr,4,2);
    if (len(tstr)>6) then begin
      res = res & "-";
    end;  
    res = res & Mid(tstr,6,2);
    if (len(tstr)>8) then begin
      res = res & "-";
    end;  
    res = res & Mid(tstr,8,2);
  end;
  FindTaxAuthIDControlCode = res;
  return;
end;

global
procedure IVDClassOnOpenWindowRemote(var record IVVc IVr,var Integer AcceptanceStatusFlag)
begin
  record AcceptanceRulesVc Acptr;
  record ActVc Actr;
  
  if (HasApprovals) then begin
    AcceptanceStatusFlag = IVApprovalStatus(IVr,Acptr);
  end;
  return;
end;

global
function LongInt IVDuplicateClient(var record IVVc IVr,record IVVc IV2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  record EInvoiceBlock EIb;

  if (IsStandardProduct) then begin
    BlockLoad(EIb);  
    if (EIb.OutEInvoices!=0) then begin
      if (HasEInvoiceExpired or HasEInvoicing==false) then begin
        MessageBox(20678," " & USetStr(37008) & " " & USetStr(37009));
      end;
    end;
  end;
  IVDuplicateClient = res;
  return;
end;
