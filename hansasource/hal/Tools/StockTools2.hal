external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function roundmode DefaultRoundMode();
external procedure CombineStructure(var record SHVc);
external function val ItemHist_ComponentItem_CostPrice(record CostAccBlock,string,LongInt,LongInt,string,val,string);
external procedure FindAdjstockvQtyRetVc(record RetVc,string,Integer,var val);
external procedure GetStockedItemFromRecepy(record SHVc,var string,var val);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function val FindCostPrice_ReturnedGoods_FromSH(record CostAccBlock,record INVc,record RetVc,row RetVc,Integer,Integer);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function roundmode GetCostRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val FindCostPriceWA(Integer,record INVc,string);
external updating procedure DeleteBatchBestBefore(string,string);
external procedure PUCalcPerc(val,string,var val);
external function Integer ArtCodeWAPerLocation(string);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function val FindCostPrice_ReturnedGoods_FromSH_Source(record INVc,record RetVc,row RetVc,Integer,Integer,Integer);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external procedure CalcNewPrice(val,string,var val);
external function val FindCostPrice_ReturnedGoods(record RetVc,row RetVc);
external procedure RetSumUp(var record RetVc);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function Boolean GetCuAccUseRow(string,var row CuAccBlock);
external function Boolean TestArtCode(string,string,record INVc);
external procedure RetPUSumUp(var record RetPUVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external procedure Base1ToBase2(var val,Date,var val);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external updating procedure UpdateLocationWeightedAv(string,string,val,val,val,val,Boolean);
external updating procedure UpdateLocationWeightedAv2(string,string,val,val,val,val);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external updating procedure UpdateSVOSerStock(string,string,string,string,string,string,string,val,val,Date,Date,val,string);
external updating procedure UpdateSVOSerHist(string,string,string,LongInt,Date,string,string);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating procedure UpdateSerStock(string,string,string,val,val);
external function Boolean ShouldItemUpdateStock(string);


procedure CalculateStockMovRowFIFO(record CostAccBlock CostAccRec,record SerNrTrackBlock SNrb,string frlocation,record StockMovVc SMp,row StockMovVc StockMovrw,Integer currow,
                                   Boolean fillsentf,Boolean fillrcvf)
begin
  val adjstockv,t;
  row StockMovVc StockMovrw2;
  Integer j;
  string 255 fromlocation;
  record INVc INr;
  string 255 serialnr;
  val qty,sum;

  ReadFirstItem(StockMovrw.ArtCode,INr,true,false);
  if (fillsentf) then begin
    if (StockMovrw.SentQuant!=0) then begin
      adjstockv = blankval;
      for (j=0;j<currow;j=j+1) begin
        MatRowGet(SMp,j,StockMovrw2);
        if (TestArtCode(StockMovrw2.ArtCode,StockMovrw.ArtCode,INr)) then begin
          adjstockv = adjstockv + StockMovrw2.SentQuant;
        end;
      end;
      if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
        StockMovrw.SentFIFORowVal = blankval;
        qty = blankval;
        serialnr = FirstInRange(StockMovrw.SerialNr,60);
        while (nonblank(serialnr)) begin
          StockMovrw.SentFIFORowVal = StockMovrw.SentFIFORowVal + FindCostPrice(StockMovrw.ArtCode,frlocation,serialnr,1.00,adjstockv,false);
          qty = qty + 1;
          adjstockv = adjstockv + 1;
          serialnr = NextSerialNumber(StockMovrw.ArtCode,serialnr,SNrb);
          if (qty>=StockMovrw.SentQuant) then begin serialnr = ""; end;
        end;
      end else begin
        StockMovrw.SentFIFORowVal = FindCostPrice(StockMovrw.ArtCode,frlocation,StockMovrw.SerialNr,StockMovrw.SentQuant,adjstockv,false);
      end;
      StockMovrw.SentFIFORowVal = Round(StockMovrw.SentFIFORowVal,SetRoundModeD(5));
      StockMovrw.SentOldPrice = StockMovrw.SentFIFORowVal/StockMovrw.SentQuant;      
      StockMovrw.SentOldPrice = Round(StockMovrw.SentOldPrice,SetRoundModeD(5));
      CalcNewPrice(StockMovrw.SentOldPrice,StockMovrw.SentExtraSCost,t);
      StockMovrw.SentNewPrice = Round(t,SetRoundModeD(5));
    end;
  end;
  
  if (fillrcvf) then begin
    fromlocation = frlocation;
    if (nonblank(SMp.ThrouLocation)) then begin
      fromlocation = SMp.ThrouLocation;
    end;
    adjstockv = blankval;
    for (j=0;j<currow;j=j+1) begin
      MatRowGet(SMp,j,StockMovrw2);
      if (TestArtCode(StockMovrw2.ArtCode,StockMovrw.ArtCode,INr)) then begin
        adjstockv = adjstockv + StockMovrw2.Quant;  
      end;
    end;    
    if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
      StockMovrw.FIFORowVal = blankval;
      qty = blankval;
      serialnr = FirstInRange(StockMovrw.SerialNr,60);
      while (nonblank(serialnr)) begin
        StockMovrw.FIFORowVal = StockMovrw.FIFORowVal + FindCostPrice(StockMovrw.ArtCode,fromlocation,serialnr,1.00,adjstockv,false);
        qty = qty + 1;
        adjstockv = adjstockv + 1;
        serialnr = NextSerialNumber(StockMovrw.ArtCode,serialnr,SNrb);
        if (qty>=StockMovrw.Quant) then begin serialnr = ""; end;
      end;
    end else begin
      StockMovrw.FIFORowVal = FindCostPrice(StockMovrw.ArtCode,fromlocation,StockMovrw.SerialNr,StockMovrw.Quant,adjstockv,false);
    end;
    StockMovrw.FIFORowVal = Round(StockMovrw.FIFORowVal,SetRoundModeD(5));
    StockMovrw.OldPrice = StockMovrw.FIFORowVal/StockMovrw.Quant;      
    StockMovrw.OldPrice = Round(StockMovrw.OldPrice,SetRoundModeD(5));
    CalcNewPrice(StockMovrw.OldPrice,StockMovrw.ExtraSCost,t);
    StockMovrw.NewPrice = Round(t,SetRoundModeD(5));
  end;
  return;
end;

global
procedure UpdateStockMovFIFO(var record StockMovVc SMp,record StockMovVc prevSMp,Integer stat)
begin
  Integer i,j,rwcnt;
  row StockMovVc StockMovrw, StockMovrw2;
  val t,adjstockv;
  string 10 curcode;
  val fr,to1,to2,br1,br2;
  record CostAccBlock CostAccRec;
  record MainStockBlock MainStockRec;
  Boolean fillsentf,fillrcvf;
  record SerNrTrackBlock SNrb;
          
  BlockLoad(CostAccRec);
  BlockLoad(MainStockRec);
  BlockLoad(SNrb);
  SMp.CurncyCode = ""; // Need to switch to base currency when autofilling FIFO
  GetFullCurncyRate(curcode,SMp.TransDate,fr,to1,to2,br1,br2);
  SMp.CurncyCode = curcode;
  SMp.FrRate = fr;
  SMp.ToRateB1 = to1; 
  SMp.ToRateB2 = to2;
  SMp.BaseRate1 = br1;
  SMp.BaseRate2 = br2;

  if (nonblank(SMp.ThrouLocation)) then begin
    fillsentf = true;
    fillrcvf = true;
  end else begin
    fillrcvf = true;
  end;
  if (SMp.OKFlag!=0) then begin
    fillrcvf = true;
    if (stat==2) then begin  
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.OKFlag!=0) then begin
          fillrcvf = false;
        end;
      end;
    end;
  end;
  if (SMp.SentOKFlag!=0) then begin
    fillsentf = true;
    if (stat==2) then begin  
      if (RecordValid(prevSMp)) then begin
        if (prevSMp.SentOKFlag!=0) then begin
          fillsentf = false;
        end;
      end;
    end;
  end;
//StopAlert("fillsentf " & fillsentf  & " fillrcvf " & fillrcvf);
  
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,StockMovrw);
    CalculateStockMovRowFIFO(CostAccRec,SNrb,SMp.FrLocation,SMp,StockMovrw,i,fillsentf,fillrcvf);
    MatRowPut(SMp,i,StockMovrw);
  end;
LUpdateStockMovFIFO:;
  return;
end;

global
procedure CalculateRetPURowFIFO(record CostAccBlock CostAccRec,string location,record RetPUVc RetPUp,row RetPUVc RetPUrw,Integer currow)
begin
  val adjstockv;
  row RetPUVc RetPU2rw;
  Integer j;
  record INVc INr;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty,sum;
  
  BlockLoad(SNrb);
  if (ReadFirstItem(RetPUrw.ArtCode,INr,true,false)) then begin end;
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin    
    MatRowGet(RetPUp,j,RetPU2rw);
    if (TestArtCode(RetPU2rw.ArtCode,RetPUrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + RetPU2rw.Quant;
    end;
  end;
  if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
    RetPUrw.FIFORowVal = blankval;
    qty = blankval;
    serialnr = FirstInRange(RetPUrw.SerialNr,60);
    while (nonblank(serialnr)) begin
      RetPUrw.FIFORowVal = RetPUrw.FIFORowVal + FindCostPrice(RetPUrw.ArtCode,location,serialnr,1.00,adjstockv,false);
      qty = qty + 1;
      adjstockv = adjstockv + 1;
      serialnr = NextSerialNumber(RetPUrw.ArtCode,serialnr,SNrb);
      if (qty>=RetPUrw.Quant) then begin serialnr = ""; end;
    end;
  end else begin
    RetPUrw.FIFORowVal = FindCostPrice(RetPUrw.ArtCode,location,RetPUrw.SerialNr,RetPUrw.Quant,adjstockv,false);
  end;
  RetPUrw.FIFORowVal = Round(RetPUrw.FIFORowVal,SetRoundModeD(5));
  RetPUrw.FIFO = RetPUrw.FIFORowVal/RetPUrw.Quant;
  RetPUrw.FIFO = Round(RetPUrw.FIFO,SetRoundModeD(5));
  return;
end;


global
procedure RetPUUpdateFIFO(var record RetPUVc RetPUp)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  string 10 location;
  record PUVc PUr;
  row PUVc PUrw;
  LongInt PUNr;

  BlockLoad(CAb);

  rwcnt = MatRowCnt(RetPUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (nonblank(RetPUrw.ArtCode)) then begin
      if (RetPUrw.Quant!=0) then begin
        location = RetPUrw.Location;
        if (blank(location)) then begin
          location = RetPUp.Location;
        end;
        if (blank(location)) then begin
          BlockLoad(MSb);
          location = MSb.MainStock;
        end;
        CalculateRetPURowFIFO(CAb,location,RetPUp,RetPUrw,i);
        MatRowPut(RetPUp,i,RetPUrw);
      end;
    end;
  end;
  RetPUSumUp(RetPUp);
  return;
end;

global
procedure CalculateRetRowFIFO(record CostAccBlock CAb,string location,record RetVc Retp,row RetVc Retrw,Integer currow)
begin
  val adjstockv,ecv,temp;
  row RetVc Ret2rw;
  Integer j;
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;
  record SHVc recSHr;
  row SHVc recSHrw;
  Boolean isstruct;
  record MainStockBlock MSb;
  Integer i,rwcnt2;
  string 255 stockartcode;

  if (ReadFirstItem(Retrw.ArtCode,INr,true,false)) then begin end;
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
  if (INr.ItemType==0) or (INr.ItemType==3) then begin
  end else begin
    waperloc = WAPerLocation(INr,ITr,CAb);
  end;
  adjstockv = blankval;
  isstruct = ExpandStructItem(Retrw.ArtCode,Retrw.Recepy,Retrw.Quant,recSHr);  
  if (isstruct==false) then begin
    for (j=0;j<currow;j=j+1) begin    
      MatRowGet(Retp,j,Ret2rw);
      if (TestArtCode(Ret2rw.ArtCode,Retrw.ArtCode,INr)) then begin
        adjstockv = adjstockv + Ret2rw.Quant;
      end;
    end;
  //rememebr about PasteSHInRet when changing this
    if (CAb.RetCostPriceFromSH!=0) then begin 
      switch (primary) begin
        case kCostModelNone:
          Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH_Source(INr,Retp,Retrw,primary,CAb.QueuedCostModel,currow);
        case kCostModelCostPrice: 
          Retrw.CostPrice = INr.InPrice;
        case kCostModelNoneItem:
          Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retp,Retrw,CAb.QueuedCostModel,currow);
        otherwise
          Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retp,Retrw,CAb.QueuedCostModel,currow);
  //        Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH_Source(INr,Retp,Retrw,primary,CAb.QueuedCostModel,currow);
      end;
      Retrw.CostPrice = Round(Retrw.CostPrice,SetRoundModeD(5));
      Retrw.UPrice = Retrw.CostPrice;
      PUCalcPerc(Retrw.UPrice,Retrw.Extra,ecv);
      Retrw.UPrice = Retrw.UPrice + ecv;
      Retrw.UPrice = Round(Retrw.UPrice,SetRoundModeD(5));
    end else begin
  //we must use what people entered, like on GR, not override what they speicified
      if (blank(Retrw.CostPrice)) then begin
        switch (primary) begin
          case kCostModelNone:
            Retrw.CostPrice = INr.InPrice;
          case kCostModelCostPrice:
            Retrw.CostPrice = INr.InPrice;
          case kCostModelPctBasePrice:
            Retrw.CostPrice = INr.InPrice;
          case kCostModelWA:
    //        Retrw.CostPrice = FindCostPriceWA(waperloc,INr,location);
            Retrw.CostPrice = INr.InPrice;
          case kCostModelQueued: 
            Retrw.CostPrice = INr.InPrice;
          case kCostModelNoneItem:
            switch (queuecostmodel) begin
              case kQueuedCostModelPerSerialNr:
    //from delivery
              otherwise
                Retrw.CostPrice = INr.InPrice;
            end;
            if (blank(Retrw.CostPrice)) then begin
              Retrw.CostPrice = FindCostPrice_ReturnedGoods(Retp,Retrw)/Retrw.Quant;
            end;
          otherwise
            Retrw.CostPrice = FindCostPrice_ReturnedGoods(Retp,Retrw)/Retrw.Quant;
        end;
        Retrw.CostPrice = Round(Retrw.CostPrice,SetRoundModeD(5));
        Retrw.UPrice = Retrw.CostPrice;
        PUCalcPerc(Retrw.UPrice,Retrw.Extra,ecv);
        Retrw.UPrice = Retrw.UPrice + ecv;
        Retrw.UPrice = Round(Retrw.UPrice,SetRoundModeD(5));
      end;
    end;
  end else begin
    Retrw.CostPrice = blankval;
    CombineStructure(recSHr);
    recSHr.Location = location;
    rwcnt2 = MatRowCnt(recSHr);
    for (j=0;j<rwcnt2;j=j+1) begin
      MatRowGet(recSHr,j,recSHrw);
      GetStockedItemFromRecepy(recSHr,stockartcode,temp);
      FindAdjstockvQtyRetVc(Retp,stockartcode,i,adjstockv);
        
      Retrw.CostPrice = Retrw.CostPrice + ItemHist_ComponentItem_CostPrice(CAb,"SHVc",Retp.SHNr,Retrw.SHRow,RecSHrw.ArtCode,RecSHrw.Ship,location);
    end;
    Retrw.CostPrice = Round(Retrw.CostPrice,DefaultRoundMode);
    Retrw.UPrice = Retrw.CostPrice;
  end;

  Retrw.BasePrice = INr.InPrice;
  return;
end;

global
procedure RetUpdateFIFO(var record RetVc Retp)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row RetVc Retrw;
  Integer i,rwcnt;
  string 10 location;
  Boolean testf;
  
  BlockLoad(CAb);
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (nonblank(Retrw.ArtCode)) then begin
      location = Retrw.Location;
      if (blank(location)) then begin
        location = Retp.Location;
      end;
      if (blank(location)) then begin
        BlockLoad(MSb);
        location = MSb.MainStock;
      end;
      testf = true;
      if (Retrw.Quant==0) then begin
        testf = false;
      end;
      if (testf) then begin
        CalculateRetRowFIFO(CAb,location,Retp,Retrw,i);
        MatRowPut(Retp,i,Retrw);
      end;
    end;
  end;
  RetSumUp(Retp);
  return;
end;

global
updating procedure OffHireUpdateSVO(record OffHireVc OffHirer)
begin
  record MainStockBlock MainStockRec;
  row OffHireVc OffHirerw;
  Integer i,rwcnt;
  val t,t2,q2;
  string 10 location,loc2;
  string 200 cucode,name;
  
  location = OffHirer.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(OffHirer);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(OffHirer,i,OffHirerw);
    if (nonblank(OffHirerw.Location)) then begin
      loc2 = OffHirerw.Location;
    end else begin
      loc2 = location;
    end;
    if (nonblank(OffHirerw.ArtCode)) then begin
      if (MainStockRec.updateSVGM!=0) then begin
        t = OffHirerw.Quant;
        if (OffHirer.AgreementNr>0) then begin
          cucode = "";
          name = USetStr(11760);
        end else begin
          cucode = OffHirer.CustCode;
          name = OffHirer.Addr0;
        end;
        UpdateSVOSerStock(OffHirerw.ArtCode,OffHirerw.Spec,OffHirerw.SerialNr,"","",cucode,name,
                          OffHirerw.Cost,OffHirerw.Value,OffHirerw.PurchaseDate,OffHirerw.WarrantyUntil,t,OffHirerw.VECode);
        UpdateSVOSerHist(OffHirerw.ArtCode,OffHirerw.SerialNr,"OffHireVc",OffHirer.SerNr,OffHirer.TransDate,OffHirer.CustCode,OffHirerw.VECode);
      end;
    end;
  end;
  return;
end;

global
updating procedure DispatchUpdateSVO(record DispatchVc Dispatchr)
begin
  record MainStockBlock MainStockRec;
  row DispatchVc Dispatchrw;
  Integer i,rwcnt;
  val t,t2,q2;
  Date bld;
  string 10 location;
  
  location = Dispatchr.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(Dispatchr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Dispatchr,i,Dispatchrw);
    if (nonblank(Dispatchrw.ArtCode)) then begin
      if (MainStockRec.updateSVGM!=0) then begin
        t = -Dispatchrw.Quant;
        UpdateSVOSerStock(Dispatchrw.ArtCode,Dispatchrw.Spec,Dispatchrw.SerialNr,"","",Dispatchr.CustCode,Dispatchr.Addr0,
                          BlankVal,BlankVal,bld,bld,t,"");
        UpdateSVOSerHist(Dispatchrw.ArtCode,Dispatchrw.SerialNr,"DispatchVc",Dispatchr.SerNr,Dispatchr.TransDate,Dispatchr.CustCode,"");
      end;
    end;
  end;
  return;
end;

procedure ArtCodeOnThisRet(Integer cnt,record RetVc Retp,string artcode,record INVc INr,var val resp)
begin
  row RetVc Retrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(Retp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (TestArtCode(Retrw.ArtCode,artcode,INr)) then begin
      resp = resp + Retrw.Quant;
    end;  
  end;
  return;
end;

global
updating procedure RetUpdateCostPrice(record RetVc Retp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row RetVc Retrw;
  row RetVc Ret2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2,startq;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  record BaseCurBlock BCb;
  string 255 location;
  
  BlockLoad(CostAccRec);    
  if (CostAccRec.UpdWeightAvFromRet==0) then begin
    goto LRetUpdateCostPrice;
  end;
  BlockLoad(RoundRec);    
  BlockLoad(BCb);    
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (Retrw.Quant!=0) then begin
      if (ReadFirstItemInclClosed(Retrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
        rs = Retrw.CostPrice;

        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(rs,Retp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - Retrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(Retp,j,Ret2rw);
          if (TestArtCode(Ret2rw.ArtCode,Retrw.ArtCode,INr)) then begin
            q = q - Ret2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        startq = q;

        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor;
//this is sick isnt it ? at least causing WA be not same as NL transaction from Ret , and what is someone changes this afterwads ? shouldnt we use Ret value always? 
//but maybe calc cost price when editng Ret ? 
        end;
        q = q + Retrw.Quant;
        if (q!=0) then begin
          t2 = Retrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;

        q = startq;
        t = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
//this is sick isnt it ? at least causing WA be not same as NL transaction from Ret , and what is someone changes this afterwads ? shouldnt we use Ret value always? 
//but maybe calc cost price when editng Ret ? 
          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + Retrw.Quant;
        if (q!=0) then begin
          t2 = Retrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisRet(i+1,Retp,Retrw.ArtCode,INr,qonrec);

        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(Retrw.CostPrice,Retp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        location = Retrw.Location;
        if (blank(location)) then begin
          location = Retp.Location;
        end;
        UpdateLocationWeightedAv(INr.Code,location,Retrw.Quant,Retrw.CostPrice,rsb2,qonrec,false);
        if ((Retrw.Quant!=0) and (INr.ItemType==1)) then begin//CostPrice
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
          INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
              INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LRetUpdateCostPrice:;  
  return;
end;

procedure ArtCodeOnThisIV(Integer cnt,record IVVc IVp,string artcode,record INVc INr,var val resp)
begin
  row IVVc IVrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(IVp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (TestArtCode(IVrw.ArtCode,artcode,INr)) then begin
      resp = resp + IVrw.Quant;
    end;  
  end;
  return;
end;

global
updating procedure IVUpdateCostPrice(record IVVc IVp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row IVVc IVrw;
  row IVVc IV2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2,startq;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  Boolean testf;
  string 255 location;
  
  BlockLoad(RoundRec);    
  BlockLoad(CostAccRec);    
  if (CostAccRec.UpdWeightAvFromRet==0) then begin
    goto LIVUpdateCostPrice;
  end;
  if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
    if (IVp.Invalid==0) then begin
      goto LIVUpdateCostPrice;
    end;
  end;
  if (IVp.UpdStockFlag==0) then begin
    goto LIVUpdateCostPrice;
  end;
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    testf = true;
    if (IVrw.stp!=kInvoiceRowTypeNormal) and (IVrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin testf = false; end;
    if (IVrw.Quant<=0) then begin testf = false; end;
    if (IVp.OrderNr>0) then begin 
      if (IVrw.OrdRow>=0) then begin testf = false; end;
    end;
    if (testf) then begin
      if (ReadFirstItemInclClosed(IVrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
        rs = IVrw.FIFORowVal/IVrw.Quant;
        Base1ToBase2(rs,IVp.TransDate,rsb2);
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - IVrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(IVp,j,IV2rw);
          if (TestArtCode(IV2rw.ArtCode,IVrw.ArtCode,INr)) then begin
            q = q - IV2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        startq = q;

        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor;
        end;
        q = q + IVrw.Quant;
        if (q!=0) then begin
          t2 = IVrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;

        q = startq;
        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + IVrw.Quant;
        if (q!=0) then begin
          t2 = IVrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisIV(i+1,IVp,IVrw.ArtCode,INr,qonrec);
        rs = IVrw.FIFORowVal/IVrw.Quant;
        Base1ToBase2(rs,IVp.TransDate,rsb2);
        location = IVrw.Location;
        if (blank(location)) then begin
          location = IVp.Location;
        end;
        UpdateLocationWeightedAv(INr.Code,location,IVrw.Quant,IVrw.FIFORowVal/IVrw.Quant,rsb2,qonrec,false);
        if ((IVrw.Quant!=0) and (INr.ItemType==1)) then begin//CostPrice
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
          INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
              INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LIVUpdateCostPrice:;  
  return;
end;

procedure ArtCodeOnThisStockMov(Integer cnt,record StockMovVc StockMovp,string artcode,record INVc INr,var val resp,Boolean sendf)
begin
  row StockMovVc StockMovrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(StockMovp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(StockMovp,i,StockMovrw);
    if (TestArtCode(StockMovrw.ArtCode,artcode,INr)) then begin
      if (sendf) then begin 
        resp = resp + StockMovrw.SentQuant;
      end else begin
        resp = resp + StockMovrw.Quant;
      end;
    end;  
  end;
  return;
end;

global
updating procedure StockMovUpdateCostPrice(record StockMovVc SMp,record StockMovVc prevSMp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row StockMovVc SMrw;
  row StockMovVc SM2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,trs,trsb2,qonrec;
  val rswaperloc,rswaperlocb2;
  record RoundBlock RoundRec;
  Boolean updatewithsendf,updatef;
  val startwa,startwab2;
  
  BlockLoad(RoundRec);     
  if (SMp.OKFlag!=0) then begin
    updatef = true;
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.OKFlag!=0) then begin
        updatef = false;
      end;
    end;
  end;

  if (SMp.SentOKFlag!=0) then begin
    updatewithsendf = true;
    if (RecordValid(prevSMp)) then begin
      if (prevSMp.SentOKFlag!=0) then begin
        updatewithsendf = false;
      end;
    end;
  end;
  if (updatef==false) and (updatewithsendf==false) then begin goto LStockMovUpdateCostPrice; end;
  
  
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(SMp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMp,i,SMrw);
    if (updatewithsendf) then begin
    if (SMrw.SentQuant!=0) then begin
      found = ReadFirstItemInclClosed(SMrw.ArtCode,INr,false,true);
      RecordCopy(oldINr,INr);
      if (found) then begin
        switch (INr.UpdateCost) begin
          otherwise//WA always
            if (ArtCodeWAPerLocation(INr.Code)) then begin 
              if (startwa==0) then begin
                startwa = INr.WeighedAvPrice;
              end;
              if (startwab2==0) then begin
                startwab2 = INr.WeighedAvPriceB2;
              end;
              rs = startwa;              
              if (nonblank(SMrw.SentExtraSCost)) then begin
                PUCalcPerc(rs,SMrw.SentExtraSCost,t);
                rs = rs + t;            
              end;
            end else begin
              rs = SMrw.SentNewPrice;
            end;
            rswaperloc = SMrw.SentNewPrice;
            rsb2 = MulRateToBase2(SMp.CurncyCode,rs,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            rswaperlocb2 = MulRateToBase2(SMp.CurncyCode,rswaperloc,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            FindStockValue(INr.Code,"",ISr);
            q = ISr.Instock - SMrw.SentQuant;
            qonrec = 0;
            for (j=i+1;j<rwcnt;j=j+1) begin
              MatRowGet(SMp,j,SM2rw);
              if (TestArtCode(SM2rw.ArtCode,SMrw.ArtCode,INr)) then begin
                qonrec = qonrec + SM2rw.SentQuant;
              end;
            end;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPrice;            
/*
this does not happen n GR
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;

              rswaperloc = rswaperloc*INr.PriceFactor;
              rswaperlocb2 = rswaperlocb2*INr.PriceFactor;
            end;
*/
            t2 = rs*SMrw.SentQuant;
            t = t + t2;
            q = q + SMrw.SentQuant;
            trs = t/q;
            if (q>=0) then begin
              INr.WeighedAvPrice = trs;
            end;

            q = ISr.Instock - SMrw.SentQuant;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPriceB2;
            t2 = rsb2*SMrw.SentQuant;
            t = t + t2;
            q = q + SMrw.SentQuant;
            trsb2 = t/q;
            if (q>=0) then begin
              INr.WeighedAvPriceB2 = trsb2;
            end;
            
            ArtCodeOnThisStockMov(i+1,SMp,SMrw.ArtCode,INr,qonrec,true);            
            UpdateLocationWeightedAv(INr.Code,SMp.ThrouLocation,SMrw.SentQuant,rswaperloc,rswaperlocb2,qonrec,false);
            found = false;
            if (nonblank(SMrw.SentExtraSCost)) then begin
              INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
              INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
              if (RecordUpdate(oldINr,INr,false)==0) then begin end;
            end;
        end;
      end;
    end;
    end;
    if (updatef) then begin
    if (SMrw.Quant!=0) then begin
      found = ReadFirstItem(SMrw.ArtCode,INr,false,true);
      RecordCopy(oldINr,INr);
      if (found) then begin
        switch (INr.UpdateCost) begin
          otherwise//WA always
            if (ArtCodeWAPerLocation(INr.Code)) then begin 
              if (startwa==0) then begin
                startwa = INr.WeighedAvPrice;
              end;
              if (startwab2==0) then begin
                startwab2 = INr.WeighedAvPriceB2;
              end;
              rs = startwa;              
              if (nonblank(SMrw.ExtraSCost)) then begin
                PUCalcPerc(rs,SMrw.ExtraSCost,t);
                rs = rs + t;            
              end;
            end else begin
              rs = SMrw.NewPrice;
            end;
            rswaperloc = SMrw.NewPrice;
            rsb2 = MulRateToBase2(SMp.CurncyCode,rs,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            rswaperlocb2 = MulRateToBase2(SMp.CurncyCode,rswaperloc,SMp.FrRate,SMp.ToRateB1,SMp.ToRateB2,SMp.BaseRate1,SMp.BaseRate2,DefaultCurRoundOff);
            FindStockValue(INr.Code,"",ISr);
            q = ISr.Instock - SMrw.Quant;
            qonrec = 0;
            for (j=i+1;j<rwcnt;j=j+1) begin
              MatRowGet(SMp,j,SM2rw);
              if (TestArtCode(SM2rw.ArtCode,SMrw.ArtCode,INr)) then begin
                qonrec = qonrec + SM2rw.Quant;
              end;
            end;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPrice;
/*
this does not happen n GR
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
*/
            t2 = rs*SMrw.Quant;
            t = t + t2;
            q = q + SMrw.Quant;
            trs = t/q;
            INr.WeighedAvPrice = trs;

            q = ISr.Instock - SMrw.Quant;
            q = q - qonrec;
            if (q<0) then begin q = blankval; end;
            t = q*INr.WeighedAvPriceB2;
            t2 = rsb2*SMrw.Quant;
            t = t + t2;
            q = q + SMrw.Quant;
            trsb2 = t/q;
            INr.WeighedAvPriceB2 = trsb2;
            ArtCodeOnThisStockMov(i+1,SMp,SMrw.ArtCode,INr,qonrec,false);            
            UpdateLocationWeightedAv(INr.Code,SMp.ToLocation,SMrw.Quant,rswaperloc,rswaperlocb2,qonrec,false);
            found = false;
            if (nonblank(SMrw.ExtraSCost)) then begin
/*      Elar ?      
              switch (INr.UpdateCost) begin
                case 2:
                  if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                    INr.InPrice = INr.WeighedAvPrice;
                    INr.LastPriceChange = CurrentDate;
                  end;
                  if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                    INr.InPriceB2 = INr.WeighedAvPriceB2;
                  end;
              end;
*/              
              INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
              INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
/*              
              switch(INr.UpdateCost) begin
                case 0:;
                otherwise
                  INr.InPrice = Round(INr.InPrice,RoundRec.RndFIFO);
                  INr.InPriceB2 = Round(INr.InPriceB2,RoundRec.RndFIFO);
                  INr.LastPriceChange = CurrentDate;
              end;
*/              
              if (RecordUpdate(oldINr,INr,false)==0) then begin end;
            end;
        end;
      end;
    end;
    end;
  end;
LStockMovUpdateCostPrice:;  
  return;
end;

procedure ArtCodeOnThisLateCost(Integer cnt,record LateCostVc LateCostp,string artcode,record INVc INr,var val resp)
begin
  row LateCostVc LateCostrw;
  Integer rwcnt,i;


  resp = blankval;
  rwcnt = MatRowCnt(LateCostp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(LateCostp,i,LateCostrw);
    if (TestArtCode(LateCostrw.ArtCode,artcode,INr)) then begin
      resp = resp + LateCostrw.Quant;
    end;
  end;
  return;
end;

global
updating procedure LateCostUpdateCostPrice(record LateCostVc LateCostp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row LateCostVc LateCostrw;
  row LateCostVc LateCost2rw;
  Integer j,rwcnt,i;
  val rs,rsb2,t,t2,q,trs,trsb2,qonrec;
  Date curdate;
  record RoundBlock RoundRec;
  
  if ((LateCostp.OKFlag==1) and (LateCostp.Invalid==0)) then begin
    BlockLoad(RoundRec);
    curdate = CurrentDate;
    rwcnt = MatRowCnt(LateCostp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LateCostp,i,LateCostrw);
      if ((LateCostrw.stp==3) or (LateCostrw.ovst!=0)) then begin
        goto LSKIPLateCostROW;
      end;
      if (LateCostrw.Quant!=0) then begin
      if (ReadFirstItemInclClosed(LateCostrw.ArtCode,INr,false,false)) then begin
        RecordCopy(oldINr,INr);
//      CopyM4Val(&INr.LastLateCostrchPrice,&rs);
        INr.LastPurchPrice2 = LateCostrw.UPrice;
        INr.LastPurchPrice = LateCostrw.CostPrice;
        INr.LastPurchCurncyCode = LateCostp.CurncyCode;          
        rs = LateCostrw.CostPrice;
        Base1ToBase2(rs,LateCostp.TransDate,rsb2);
        
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock - LateCostrw.Quant;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(LateCostp,j,LateCost2rw);
          if (TestArtCode(LateCost2rw.ArtCode,LateCostrw.ArtCode,INr)) then begin
            q = q - LateCost2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        t = q*INr.WeighedAvPrice;
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor;
        end;
        q = q + LateCostrw.Quant;
        if (q!=0) then begin
          t2 = LateCostrw.Quant*rs;
          t = t + t2;
          trs = t/q;
        end;
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;
        t = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
          rsb2 = rsb2*INr.PriceFactor;
        end;
        q = q + LateCostrw.Quant;
        if (q!=0) then begin
          t2 = LateCostrw.Quant*rsb2;
          t = t + t2;
          trsb2 = t/q;
        end;
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisLateCost(i+1,LateCostp,LateCostrw.ArtCode,INr,qonrec);          
        UpdateLocationWeightedAv(INr.Code,LateCostp.Location,LateCostrw.Quant,rs,rsb2,qonrec,false);
        switch (INr.UpdateCost) begin
          case 1:
            rs = LateCostrw.CostPrice;
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
              INr.LastPriceChange = curdate;
            end;
          case 2:
            if (INr.InPrice!=INr.WeighedAvPrice) then begin  // inprice has changed 
              INr.InPrice = INr.WeighedAvPrice;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin  // inprice has changed 
              INr.InPriceB2 = INr.WeighedAvPriceB2;
            end;
          case 3:
            rs = LateCostrw.UPrice;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
        end;
        INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
        INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
        switch(INr.UpdateCost) begin
          case 0:;
          otherwise
            INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
            INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
            INr.LastPriceChange = CurrentDate;
        end;
        if (RecordUpdate(oldINr,INr,false)==0) then begin
        end;
      end;
      end;
LSKIPLateCostROW:;      
    end;    
  end;
  return;
end;

procedure ArtCodeOnThisRetPU(Integer cnt,record RetPUVc RetPUp,string artcode,record INVc INr,var val resp)
begin
  row RetPUVc RetPUrw;
  Integer i,rwcnt;

  resp = blankval;
  rwcnt = MatRowCnt(RetPUp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (TestArtCode(RetPUrw.ArtCode,artcode,INr)) then begin
      resp = resp + RetPUrw.Quant;
    end;  
  end;
  return;
end;

global
updating procedure RetPUUpdateCostPrice(record RetPUVc RetPUp)
begin
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row RetPUVc RetPUrw;
  row RetPUVc RetPU2rw;
  Boolean found;
  Integer i,j,rwcnt,outrows;
  val q,t,t2,rs,rsb2,qonrec,trs,trsb2;
  record RoundBlock RoundRec;
  record CostAccBlock CostAccRec;
  record BaseCurBlock BCb;
  string 255 location;
  
  BlockLoad(RoundRec);    
  BlockLoad(CostAccRec);    
  BlockLoad(BCb);    
  if (CostAccRec.UpdWeightAvFromRetPU==0) then begin
    goto LRetPUUpdateCostPrice;
  end;
  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(RetPUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RetPUp,i,RetPUrw);
    if (RetPUrw.Quant!=0) then begin
      if (ReadFirstItemInclClosed(RetPUrw.ArtCode,INr,false,false)) then begin
        FindStockValue(INr.Code,"",ISr);
        q = ISr.Instock;
        
//        ArtCodeOnThisRetPU(i+1,RetPUp,RetPUrw.ArtCode,INr,qonrec);//totally not correct
//        q = q - qonrec;        

        qonrec = 0;
        for (j=0;j<i;j=j+1) begin
          MatRowGet(RetPUp,j,RetPU2rw);
          if (TestArtCode(RetPU2rw.ArtCode,RetPUrw.ArtCode,INr)) then begin
            qonrec = qonrec + RetPU2rw.Quant;
          end;
        end;
        q = ISr.Instock - qonrec;
        RecordCopy(oldINr,INr);
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(rs,RetPUp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        trs = q*INr.WeighedAvPrice; 
        if (INr.PriceFactor!=0) then begin
          trs = trs*INr.PriceFactor;
        end;        
        t = RetPUrw.Quant*RetPUrw.FIFO;
        if (INr.PriceFactor!=0) then begin
          t = t*INr.PriceFactor;
        end;        
        trs = trs - t;
        q = q - RetPUrw.Quant;
        trs = trs/q;
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
        end;
        
        q = ISr.Instock - qonrec;
        trsb2 = q*INr.WeighedAvPriceB2;
        if (INr.PriceFactor!=0) then begin
          trsb2 = trsb2*INr.PriceFactor;
        end;       
         
        t = RetPUrw.Quant*RetPUrw.FIFO;
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(t,RetPUp.TransDate,t);
        end else begin
          t = blankval;
        end;
        if (INr.PriceFactor!=0) then begin
          t = t*INr.PriceFactor;
        end;        
        trsb2 = trsb2 - t;
        q = q - RetPUrw.Quant;
        trsb2 = trsb2/q;        
        if (q>=0) then begin
          INr.WeighedAvPriceB2 = trsb2;
        end;
        if (nonblank(BCb.BaseCur2)) then begin
          Base1ToBase2(RetPUrw.FIFO,RetPUp.TransDate,rsb2);
        end else begin
          rsb2 = blankval;
        end;
        location = RetPUrw.Location;
        if (blank(location)) then begin
          location = RetPUp.Location;
        end;
        UpdateLocationWeightedAv2(INr.Code,location,RetPUrw.Quant,RetPUrw.FIFO,rsb2,qonrec);
        if ((RetPUrw.Quant!=0) and (INr.ItemType==1)) then begin//FIFO
          switch (INr.UpdateCost) begin
            case 2:
              if (INr.InPrice!=INr.WeighedAvPrice) then begin 
                INr.InPrice = INr.WeighedAvPrice;
                INr.LastPriceChange = CurrentDate;
              end;
              if (INr.InPriceB2!=INr.WeighedAvPriceB2) then begin 
                INr.InPriceB2 = INr.WeighedAvPriceB2;
              end;
          end;
          if (qonrec<=0) then begin
            INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
            INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
//otherwise no rounding, more precise WA            
          end;
          switch(INr.UpdateCost) begin
            case 0:;
            otherwise
              INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
              INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
              INr.LastPriceChange = CurrentDate;
          end;
          if (RecordUpdate(oldINr,INr,false)==0) then begin end;
        end;
      end;
    end;
  end;
LRetPUUpdateCostPrice:;  
  return;
end;

global
updating function val NextLocOKNr(string loc)
begin
  record LocationVc Locr;
  record MainStockBlock MainStockRec;
  val LocOKNrp;
  
  LocOKNrp = blankval;
  BlockLoad(MainStockRec);
  switch (MainStockRec.Chronology) begin
    case 0:
      MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
      LocOKNrp = MainStockRec.LastOKNr;
      BlockStore(MainStockRec);
    case 1:
      Locr.Code = loc;
      if (blank(Locr.Code)) then begin
        Locr.Code = MainStockRec.MainStock;
      end;
      if (ReadFirstMain(Locr,1,true)) then begin
        Locr.LastOKNr = Locr.LastOKNr + 1;
        LocOKNrp = Locr.LastOKNr;
        if (RecordStore(Locr,true)) then begin
        end;;
      end else begin
        MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
        LocOKNrp = MainStockRec.LastOKNr;
        BlockStore(MainStockRec);
      end;   
/*
we do not need number per location
1 2 3 4 5
2 5 
works same
but how to update ?
*/
    case 2: 
      MainStockRec.LastOKNr = MainStockRec.LastOKNr + 1;
      LocOKNrp = MainStockRec.LastOKNr;
      BlockStore(MainStockRec);
  end;
LNextLocOKNr:; 
  NextLocOKNr = LocOKNrp;
  return;
end;

global
function Boolean GetCuAccUseRow2(string cuacc,var row CuAccBlock rescuaccrw)
begin
  record CuAccVc CuAccr;
  string 60 objstr;
  Boolean res;

  CuAccr.Code = cuacc;
  if (ReadFirstMain(CuAccr,1,true)) then begin
    objstr = CuAccr.Objects;
  end;  
  if (GetCuAccUseRow(objstr,rescuaccrw)) then begin res = true; end;
  GetCuAccUseRow2 = res;
  return;
end;

procedure GetLocationFromOrder(record ORVc ORr,LongInt OrdRow,string mainstock,var string ordlocation,var val qty,var val ordqty)
begin
  row ORVc ORrw;
  Integer i,rwcnt;

  ordqty = blankval;
  qty = blankval;
  ordlocation = "";
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (OrdRow==i) then begin
      ordlocation = ORrw.Location;
      qty = ORrw.Quant - ORrw.Shipd1;
      if (ORr.Closed==0) then begin      
        ordqty = ORrw.Quant;
      end;
      goto LGetLocationFromOrder;
    end;
  end;
LGetLocationFromOrder:;
  if (blank(ordlocation)) then begin
    ordlocation = ORr.Location;
  end;  
  if (blank(ordlocation)) then begin
    ordlocation = mainstock;
  end;  
  return;
end;

global
updating procedure RetUpdateStock2(record RetVc Retp,Boolean removef,Boolean rebuildstockf,vector val vgrecalcitemstat_retvc,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record INVc INr;
  row RetVc Retrw;
  record MainStockBlock MSb;
  string 255 location;
  string 10 ordlocation;
  Integer i,rwcnt;
  val t,orq,qty,q2,tmp,ordqty,rsrved;
  record ORVc ORr;
  row ORVc ORrw;
  Boolean orfound,closedf,testf;
  record SHVc RecSHr;
  row SHVc RecSHrw;
  Boolean isstruct;
  Integer j,shrwcnt;
  transaction string 255 gRuniningMaint;
  row TempStockVc TSrw;

  BlockLoad(MSb);
  closedf = false;
  ORr.SerNr = Retp.OrdNr;
  orfound = ReadFirstMain(ORr,1,true);
  if (orfound) then begin
    if (ORr.Closed!=0) then begin
      closedf = true;
    end;
  end;
  
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    testf = true;
    if (usetmpstkf) then begin
      FindTempStockRow(i,Retrw.ArtCode,blank(Retrw.Recepy),TSr,TSrw);
      if (TSrw.StockAffectf==0) then begin testf = false; end;
      if (TSrw.ItemType!=kItemTypeStocked) then begin testf = false; end;
    end;
    if (testf) then begin  //Retp.UpdStockFlag!=0
      location = Retrw.Location;
      if (blank(location)) then begin
        location = Retp.Location;
      end;
      if (blank(location)) then begin
        location = MSb.MainStock;
      end;
      if (removef) then begin
        qty = -Retrw.Quant;
      end else begin
        qty = Retrw.Quant;
      end;
//      if (ShouldItemUpdateStock(Retrw.ArtCode)==false) then begin
//in case of return goods we cannot use it, it returns true for structured items as well
//which is wrong, we should allow structure items on ret goods(to update order)
//and return stocked items from recepy
      if (ReadFirstItem(Retrw.ArtCode,INr,false,false)) then begin
      end;      
      if (INr.ItemType!=1) and (INr.ItemType!=2) then begin
        qty = blankval;
      end else begin
        isstruct = ExpandStructItem(Retrw.ArtCode,Retrw.Recepy,Retrw.Quant,RecSHr);
        if (isstruct==false) then begin
          if (Retp.Type==0) then begin
            orq = qty;
          end else begin
            if (rebuildstockf) then begin
              orq = qty;
            end else begin
              orq = blankval;
            end;
          end;
          if (MSb.UnitConvCalc==0) then begin
            q2 = qty*Retrw.Coefficient;
          end else begin
            q2 = qty/Retrw.Coefficient;
          end;
          if (Retp.UpdStockFlag!=0) then begin
            UpdateInstock("RetVc",Retp.SerNr,Retrw.ArtCode,location,Retp.TransDate,qty,t,t,t,t,q2,t,t,t);
          end;
          if (orfound) then begin
            if (Retrw.OrdRow>=0) then begin
              GetLocationFromOrder(ORr,Retrw.OrdRow,MSb.MainStock,ordlocation,qty,ordqty);
              MatRowGet(ORr,Retrw.OrdRow,ORrw);
              if ((ORrw.Quant - ORrw.Shipd2)>=0) then begin //for over-deliverd we dont touch
                if (rebuildstockf) then begin
                  if (MSb.DelOrdQty!=0) then begin
                    if (orq>ORrw.Quant) then begin orq = ORrw.Quant; end;
                    if ((ORrw.Quant - ORrw.Shipd2 - orq)<0) then begin
                      orq = ORrw.Quant - ORrw.Shipd2;
                    end;
                    if (orq<=0) then begin
                      orq = blankval;
                    end;
                  end;
                end else begin
                  if (orq>ORrw.Shipd2) then begin
                    orq = ORrw.Shipd2;
                  end;
                  if (orq>ORrw.Quant) then begin
                    orq = ORrw.Quant;
                  end;
                  if (orq<=0) then begin
                    orq = blankval;
                  end;
                end;
              end else begin
                if (rebuildstockf==false) then begin
                  orq = ORrw.Quant - ORrw.Shipd2 + orq;
                  if (orq<0) then begin
                    orq = blankval;
                  end;
                end else begin
                  if (orq>ORrw.Quant) then begin
                    orq = ORrw.Quant;
                  end;
                end;
              end;
            end else begin
              orq = blankval;
            end;       
            if (Retp.Type==0) then begin
              if (ORr.Closed==0) then begin
                if (ORr.Reserved!=0) then begin
                  rsrved = orq;
                end;
              end else begin
                if (MSb.DelOrdQty!=0) then begin
/*
                  if (ORr.Closed!=0) then begin
                    orq = blankval;
                  end;
*/
                  if (orq<=0) then begin
                    orq = blankval;
                  end;
                end;
              end;
            end;
/*
            if (Importing==false) then begin // We shouldn't check settings for this, it should be stored on the record.
              if (MSb.UpdateAvailable!=0) then begin
//                if (qty==0) then begin orq = 0; end; // So, if you have deliveredd what you have ordered, make sure that ordered qty is zero.... makes NO sense...
                if (qty<0) then begin
                  orq = orq + qty;
                  if (orq<0) then begin orq = 0; end;
                end;
              end;
            end;
*/          
            if (orq!=0) or (rsrved!=0) then begin
/*
SO->SH->Ret full qty and SH->Ret full qty again, code here causes item status being worng
              if (rebuildstockf and orfound) then begin
                if (gRuniningMaint=="RecalcItemStatusMn") then begin
                  if ((vgrecalcitemstat_retvc[Retp.OrdNr & ":" & Retrw.OrdRow] + orq)>ORrw.Quant) then begin
                    orq = ORrw.Quant - vgrecalcitemstat_retvc[Retp.OrdNr & ":" & Retrw.OrdRow];
                  end;
                  vgrecalcitemstat_retvc[Retp.OrdNr & ":" & Retrw.OrdRow] = vgrecalcitemstat_retvc[Retp.OrdNr & ":" & Retrw.OrdRow] + orq;
                end;
              end;
*/
              UpdateInstock("RetVc",Retp.SerNr,Retrw.ArtCode,ordlocation,Retp.TransDate,t,orq,rsrved,t,t,t,t,t,t);
            end;
          end;
        end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,RecSHrw);
            if (removef) then begin
              qty = -RecSHrw.Ship;
            end else begin
              qty = RecSHrw.Ship;
            end;
            qty = Round(qty,SetRoundModeD(3));
            if (Retp.Type==0) then begin
              orq = qty;
            end else begin
              orq = blankval;
            end;
            if (closedf) then begin
              orq = blankval;
            end;
            if (MSb.UnitConvCalc==0) then begin
              q2 = qty*RecSHrw.Coefficient;
            end else begin
              q2 = qty/RecSHrw.Coefficient;
            end;
            if (Retp.UpdStockFlag!=0) then begin
              UpdateInstock("RetVc",Retp.SerNr,RecSHrw.ArtCode,location,Retp.TransDate,qty,t,t,t,t,q2,t,t,t);
            end;
            if (orfound) then begin
              if (Retrw.OrdRow>=0) then begin
                GetLocationFromOrder(ORr,Retrw.OrdRow,MSb.MainStock,ordlocation,tmp,ordqty);
                if (closedf) then begin
                end else begin
                  MatRowGet(ORr,Retrw.OrdRow,ORrw);
                  if ((ORrw.Quant - ORrw.Shipd2)>=0) then begin //for over-deliverd we dont touch
                  end else begin
                    if (rebuildstockf==false) then begin
                      orq = ORrw.Quant - ORrw.Shipd2 + orq;
                      if (orq<0) then begin
                        orq = blankval;
                      end;
                    end;    
                  end;
                end;
              end else begin
                orq = blankval;
                ordqty = blankval;
              end;
              UpdateInstock("RetVc",Retp.SerNr,RecSHrw.ArtCode,ordlocation,Retp.TransDate,t,qty,t,t,t,q2,t,t,t);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure RetUpdateStock(record RetVc Retp,Boolean removef,Boolean rebuildstockf,vector val vgrecalcitemstat_retvc)
begin
  record TempStockVc TSr;
  
  RetUpdateStock2(Retp,removef,rebuildstockf,vgrecalcitemstat_retvc,TSr,false);
  return;
end;
