external procedure RowCalculateTaxMatrix_RestAccVc(var record RestAccVc,Integer,row RestAccVc);
external function string 255 GetItemDept(record LocalMachineBlock,string,string);
external function Boolean BlockedBranchItem(string,string);
external function string 255 OverrideTaxMatrix(string,var record TaxMatrixVc);
external procedure RowCalculateTaxMatrix_RestAccVc(var record RestAccVc,Integer,row RestAccVc);
external procedure RestAccDchsum(record RestAccVc,Integer);
external function string 255 FillupTaxMatrix(Integer,string,string,string,string,string,var record TaxMatrixVc);
external procedure CalculateRestAccVcPoints(var record RestAccVc);
external function Boolean RestAccDchrsum(var record RestAccVc,Integer,Integer);
external function Boolean ReadRestOpenHours(string,var record RestOpenHoursVc);
external function roundmode DefaultRoundMode();
external function Boolean TimeInRange(Time,Time,Time);
external function string 20 FindJobCustomerCode(record JobVc);
external function string 60 FindJobCustomerName(record JobVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Integer PMCheckType(string,var string,var string);
external updating function LongInt RestAccVcRecordCheck(var record RestAccVc,record RestAccVc,LongInt,LongInt);
external procedure RestAccSumup(var record RestAccVc,string);
external procedure RestAccVcGetCalcItemPrice(record INVc,record RestAccVc,Integer,var val);
external function Boolean GetItemPriceDiscount3(string,val,var record INVc,string,val,val,val,val,val,string,string,string,string,
                                                var val,var string,var val,var string,var val,var string,Integer,var Boolean,Date,Time,
                                                string,Boolean,var Boolean,string,var string,var val,string,string,var string);
                                                
external function Boolean RestAccIsReserved(record RestAccVc,var record JobVc);

function val HappyHourQty(val qty)
begin
  val res,hhq;  

  res = qty;
  while (res>=2) begin
    res = res - 2;
    hhq = hhq + 1;
  end;
  if (res==1) then begin
    hhq = hhq + 1;
  end;
  HappyHourQty = hhq;
  return;
end;

global 
function val GetServiceCharge(var record RestAccVc RestAccr,record LocalMachineBlock LMb,boolean CheckTypef)
begin
  record ServiceChargeVc ServiceCharger;
  record RestOpenHoursVc ROHr;
  row RestAccVc RestAccrw;
  val sum,rs,ssum;
  Integer i,rwcnt;
  Boolean happyf,testf;
  
  ServiceCharger.MachineCode = LMb.LocalMachineCode;
  ssum = 0;
  if (ReadFirstMain(ServiceCharger,1,true)) then begin
    ReadRestOpenHours(ServiceCharger.MachineCode,ROHr);
    if ((nonblanktime(ROHr.HHMonStart)) and (nonblanktime(ROHr.HHMonEnd))) then begin
      if (TimeInRange(RestAccr.TransTime,ROHr.HHMonStart,ROHr.HHMonEnd)) then begin
       happyf = true;
      end;
    end;  
    rwcnt = MatRowCnt(RestAccr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(RestAccr,i,RestAccrw);      
      if (RestAccrw.ovst==0) then begin
        if (RestAccrw.stp==1) then begin
          if (happyf==false) then begin
            rs = RestAccrw.Quant*RestAccrw.Price;
          end else begin
            rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
        end;
        if (RestAccrw.stp==3) then begin
          if (happyf==false) then begin
            rs = -RestAccrw.Quant*RestAccrw.Price;
          end else begin
            rs = -HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
        end;
      end;
    end;
    if (CheckTypef) then begin 
      testf = true;
      if (RestAccr.Persons < ServiceCharger.Covers) then begin 
        testf = false;
      end;
      if (ServiceCharger.ChargeType<>2) then begin
        testf = false;
      end;
      if (testf) then begin
        ssum = sum * ServiceCharger.ChargePrc / 100.00;      
      end;
    end else begin
      ssum = sum * ServiceCharger.ChargePrc / 100.00;
    end;
  end;
  GetServiceCharge = ssum;
  return;
end;

function Boolean FindRoomCode(var record RestAccVc RestAccp)
BEGIN
  Boolean res;
  record ResVc Roomr;
  Boolean TrHs;
  string 255 tstr;
  Integer pos;
  
  Roomr.Code = RestAccp.Resource;
  if (ReadFirstMain(Roomr,1,true)) then begin
    res = true;
    goto LFindRoomCode;
  end;
  tstr = RestAccp.Resource;
  TrHs = true;
  Roomr.Code = "";
  ResetLoop(Roomr);
  while (LoopMain(Roomr,1,TrHs)) begin
    pos = InString(Roomr.Code,tstr);
    if (pos!=0) then begin
      RestAccp.Resource = Roomr.Code;
      res = true;
      goto LFindRoomCode;
    end;
  end;
LFindRoomCode:;  
  FindRoomCode = res;
  RETURN;
END;

procedure PasteDefaultRoomPayMode(var record RestAccVc RestAccp)
BEGIN
  record RestPMBlock RestPMRec;
  row RestPMBlock RestPMrw;
  Integer i,rwcnt;
  string 255 tstr;
  
  BlockLoad(RestPMRec);
  rwcnt = MatRowCnt(RestPMRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestPMRec,i,RestPMrw);
    if (PMCheckType(RestPMrw.PMCode,tstr,tstr)==6) then begin
      RestAccp.PayDeal = RestPMrw.PMCode;
      goto LPasteDefaultRoomPayMode;
    end;
  end;
LPasteDefaultRoomPayMode:;  
  RETURN;
END;

global
function Boolean RestAccVc_PasteResource(var record RestAccVc RestAccp)
BEGIN
  Boolean res;
  record JobVc Jobr;
  row JobVc Jobrw;
  
  RestAccp.CUCode = "";
  RestAccp.CUName = "";
  RestAccp.GuestCode = "";
  RestAccp.GuestName = "";
  if (nonblank(RestAccp.Resource)) then begin
    if (FindRoomCode(RestAccp)) then begin
      if (RestAccIsReserved(RestAccp,Jobr)) then begin
        res = true;
        RestAccp.CUCode = FindJobCustomerCode(Jobr);
        RestAccp.CUName = FindJobCustomerName(Jobr);
        if (MatRowCnt(Jobr)==1) then begin
          MatRowGet(Jobr,0,Jobrw);
          RestAccp.GuestCode = Jobrw.GuestCode;
          RestAccp.GuestName = Jobrw.CUName;        
        end;
        PasteDefaultRoomPayMode(RestAccp);
      end;
    end else begin
      res = false;
    end;
  end;
  RestAccVc_PasteResource = res;
  RETURN;
END;

function Boolean FindGuestAccount(string guest,record JobVc Jobp,var string tstr)
BEGIN
  row JobVc Jobrw;
  Integer rwcnt,i;
  Boolean res;
  
  tstr = "";
  rwcnt = MatRowCnt(Jobp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Jobp,i,Jobrw);
    if (nonblank(Jobrw.GuestCode)) then begin
      if (Jobrw.GuestCode==guest) then begin
        if (nonblank(Jobrw.CUCode)) then begin
          tstr = Jobrw.CUCode;
        end else begin
          tstr = FindJobCustomerCode(Jobp);
        end;
        res = true;
        i = rwcnt;
      end;
    end;
  end;
  FindGuestAccount = res;
  RETURN;
END;

function Boolean FindAccountGuest(string account,record JobVc Jobp,var string tstr)
BEGIN
  row JobVc Jobrw;
  Integer rwcnt,i;
  Boolean res;
  
  tstr = "";
  rwcnt = MatRowCnt(Jobp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Jobp,i,Jobrw);
    if (nonblank(Jobrw.CUCode)) then begin
      if (Jobrw.CUCode==account) then begin
        if (nonblank(Jobrw.GuestCode)) then begin
          tstr = Jobrw.GuestCode;
        end else begin
          tstr = FindJobCustomerCode(Jobp);
        end;
        res = true;
        i = rwcnt;
      end;
    end;
  end;
  FindAccountGuest = res;
  RETURN;
END;

global
function Boolean RestAccVc_BeforeGuestCode(var record RestAccVc RestAccp,var string psname)
BEGIN
  record JobVc Jobr;
  Boolean res;
  
  psname = "";
  if (RestAccIsReserved(RestAccp,Jobr)) then begin
    if (MatRowCnt(Jobr)==1) then begin
      res = true;
      goto LRestAccVc_BeforeGuestCode;
    end;
  end else begin
    res = false;
  end;
  if (blank(RestAccp.Resource)) then begin
    res = false;
    psname = "ProfileSClass";
  end else begin
    res = true;
    psname = "GuestSClass";
  end;  
LRestAccVc_BeforeGuestCode:;  
  RestAccVc_BeforeGuestCode = res;
  RETURN;
END;

global
function Boolean RestAccVc_PasteGuestCode(var record RestAccVc RestAccp)
BEGIN
  Boolean res;
  record JobVc Jobr;
  record CUVc CUr;
  record CUVc Guestr;
  string 255 tstr;
  Boolean foundf;
  record HotelBlock Hotelsettings;
  
  Guestr.Code = RestAccp.GuestCode;
  if (ReadFirstKey("GuestActCode",Guestr,1,true)) then begin
    RestAccp.GuestName = Guestr.Name;
    if (nonblank(Guestr.PLCode)) then begin
      RestAccp.PriceList = Guestr.PLCode;
    end;
  end;  
  if (blank(RestAccp.Resource)) then begin
    BlockLoad(Hotelsettings);   
    foundf = true;
    Jobr.ResStatus = HotelSettings.ChInSt;
    while (LoopKey("ResStatus",Jobr,1,foundf)) begin
      if (Jobr.ResStatus!=HotelSettings.ChInSt) then begin
        foundf = false;
      end;
      if (foundf) then begin
        if (FindGuestAccount(RestAccp.GuestCode,Jobr,tstr)) then begin
          RestAccp.Resource = Jobr.ResCode;
          foundf = false;
        end;
      end;
    end;
  end;
  if (RestAccIsReserved(RestAccp,Jobr)) then begin
    if (FindGuestAccount(RestAccp.GuestCode,Jobr,tstr)) then begin    
      if (nonblank(tstr)) then begin
        if (tstr!=RestAccp.CUCode) then begin
          RestAccp.CUCode = tstr;
          CUr.Code = tstr;
          ReadFirstMain(CUr,1,true);
          RestAccp.CUName = CUr.Name;
          if (nonblank(CUr.PLCode)) then begin
            RestAccp.PriceList = CUr.PLCode;
          end;
        end;
      end;
      res = true;
    end else begin
      res = false;
    end;
  end;
  RestAccVc_PasteGuestCode = res;
  RETURN;
END;

global
procedure RestAccVc_FillupTaxTemplate(var record RestAccVc RestAccr)
begin
  row RestAccVc RestAccrw;
  Integer i,rwcnt;
  record TaxMatrixVc TMr;
  val t,s,price,vreb,baseprice,tax2prc;
  record INVc INr;
  string 255 tstr,tax2code,location,taxtemplatecode,itemtaxtemplatecode,dummystr,curitemname,vatcode,salesacc;
  Boolean calcpricef;
  Integer exportflag;
  Boolean dummyf;
  Time blankt;

  rwcnt = MatRowCnt(RestAccr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccr,i,RestAccrw);
    if (nonblank(RestAccrw.ArtCode)) then begin
      if (GetItemPriceDiscount3(RestAccrw.ArtCode,RestAccrw.Quant,INr,"",
                                blankval,blankval,blankval,blankval,blankval,
                                "","",RestAccr.PriceList,RestAccr.RebCode,
                                price,curitemname,vreb,vatcode,baseprice,salesacc,
                                0,calcpricef,RestAccr.TransDate,blankt,RestAccr.CUCode,false,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode)) then 
      begin
        RestAccrw.TaxTemplateCode = FillupTaxMatrix(0,RestAccr.BranchID,RestAccr.CUCode,RestAccr.CustCat,"",itemtaxtemplatecode,TMr);
        PackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
        MatRowPut(RestAccr,i,RestAccrw);
        RowCalculateTaxMatrix_RestAccVc(RestAccr,i,RestAccrw);
        MatRowPut(RestAccr,i,RestAccrw);
        RestAccDchrsum(RestAccr,i,0);
        RestAccDchsum(RestAccr,i);
      end;
    end;
  end;     
  return;
end;

global
function Boolean RestAccVc_PasteCUCode(var record RestAccVc RestAccp)
BEGIN
  Boolean res;
  record JobVc Jobr;
  record CUVc CUr;
  record CUVc Guestr;
  string 255 tstr;
  Boolean foundf;
  record HotelBlock Hotelsettings;
  record AccBlock ARb;
  
  CUr.Code = RestAccp.CUCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    BlockLoad(ARb);
    RestAccp.CUName = CUr.Name;
    if (nonblank(CUr.PLCode)) then begin
      RestAccp.PriceList = CUr.PLCode;
    end;
    RestAccp.RebCode = CUr.RebCode;
    RestAccp.FiscalFlag = CUr.FiscalFlag;
    RestAccp.VATNr = CUr.VATNr;
    RestAccp.Addr0 = CUr.Name;
    RestAccp.Addr1 = CUr.InvAddr0;
    RestAccp.Addr2 = CUr.InvAddr1;
    RestAccp.Addr3 = CUr.InvAddr2;
    RestAccp.InvAddr3 = CUr.InvAddr3; 
    RestAccp.InvAddr4 = CUr.InvAddr4;
    RestAccp.Objects = CUr.Objects;
    RestAccp.LangCode = CUr.LangCode;    
    RestAccp.CustCat = CUr.CustCat;
    if (HasLocalization("POL")) then begin
      switch (CUr.IPBookVAT) begin
        case 1:
          RestAccp.IPBookVAT = CUr.IPBookVAT;
        case 2:
          RestAccp.IPBookVAT = 0;
        otherwise
          RestAccp.IPBookVAT = ARb.IPBookVAT;
      end;
    end else begin
      RestAccp.IPBookVAT = ARb.IPBookVAT;  
    end;
    if (CUr.TaxTemplateCode!=RestAccp.CustTaxTemplateCode) then begin
      RestAccVc_FillupTaxTemplate(RestAccp);
      RestAccp.CustTaxTemplateCode = CUr.TaxTemplateCode;
    end;    
  end;
  if (blank(RestAccp.Resource)) then begin
    BlockLoad(Hotelsettings);   
    foundf = true;
    Jobr.ResStatus = HotelSettings.ChInSt;
    while (LoopKey("ResStatus",Jobr,1,foundf)) begin
      if (Jobr.ResStatus!=HotelSettings.ChInSt) then begin
        foundf = false;
      end;
      if (foundf) then begin
        if (FindAccountGuest(RestAccp.CUCode,Jobr,tstr)) then begin
          RestAccp.Resource = Jobr.ResCode;
          foundf = false;
        end;
      end;
    end;
  end;
  if (RestAccIsReserved(RestAccp,Jobr)) then begin
    if (FindAccountGuest(RestAccp.CUCode,Jobr,tstr)) then begin    
      if (nonblank(tstr)) then begin
        if (tstr!=RestAccp.GuestCode) then begin
          RestAccp.GuestCode = tstr;
          Guestr.Code = tstr;
          if (ReadFirstMain(Guestr,1,true)) then begin
            tstr = Guestr.Name;
          end else begin
            tstr = "";
          end;
          RestAccp.GuestName = tstr;
        end;
      end;
      res = true;
    end else begin
      res = false;
    end;
  end;
  RestAccVc_PasteCUCode = res;
  RETURN;
END;

global
procedure  RestAccVc_PasteQuant(var record RestAccVc RestAccr,Integer rownr,record LocalMachineBlock LMb)
begin
  row RestAccVc RestAccrw;
  record INVc INr;
  string 255 salesacc,vatcode,curitemname,tax2code,taxtemplatecode;
  val vreb,baseprice,price,t,tax2prc;
  Boolean calcpricef;
  Boolean chrsum,chsum;
  Boolean dummyf;
  Time blankt;


  MatRowGet(RestAccr,rownr,RestAccrw);

  vreb = RestAccrw.vRebate;  
  price = RestAccrw.Price;
  RestAccrw.Quant = Round(RestAccrw.Quant,DefaultRoundMode);
  GetItemPriceDiscount3(RestAccrw.ArtCode,RestAccrw.Quant,INr,"",
                       blankval,blankval,blankval,blankval,blankval,
                       "","",RestAccr.PriceList,RestAccr.RebCode,
                       price,curitemname,vreb,vatcode,baseprice,salesacc,
                       0,calcpricef,RestAccr.TransDate,blankt,RestAccr.CUCode,false,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode); 
  RestAccrw.vRebate = vreb;
  MatRowPut(RestAccr,rownr,RestAccrw);
  RestAccDchrsum(RestAccr,rownr,0);
  RestAccDchsum(RestAccr,rownr);
  RestAccr.ServCharge = GetServiceCharge(RestAccr,LMb,true);
  RestAccSumup(RestAccr,"");
  return;
end;

global
procedure  RestAccVc_AddQuant(var record RestAccVc RestAccr,Integer rownr,val qty,record LocalMachineBlock LMb)
begin
  row RestAccVc RestAccrw;
  record INVc INr;
  string 255 salesacc,vatcode,curitemname,tax2code,taxtemplatecode;
  val vreb,baseprice,price,t,tax2prc;
  Boolean calcpricef;
  Boolean chrsum,chsum;
  Boolean dummyf;
  Time blankt;

  MatRowGet(RestAccr,rownr,RestAccrw);
  vreb = RestAccrw.vRebate;  
  price = RestAccrw.Price;
  RestAccrw.Quant = Round(RestAccrw.Quant+qty,DefaultRoundMode);
  GetItemPriceDiscount3(RestAccrw.ArtCode,RestAccrw.Quant,INr,"",
                       blankval,blankval,blankval,blankval,blankval,
                       "","",RestAccr.PriceList,RestAccr.RebCode,
                       price,curitemname,vreb,vatcode,baseprice,salesacc,
                       0,calcpricef,RestAccr.TransDate,blankt,RestAccr.CUCode,false,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode); 
  RestAccrw.vRebate = vreb;
  MatRowPut(RestAccr,rownr,RestAccrw);
  RestAccDchrsum(RestAccr,rownr,0);
  RestAccDchsum(RestAccr,rownr);
  RestAccSumup(RestAccr,"");
  RestAccr.ServCharge = GetServiceCharge(RestAccr,LMb,true);
  RestAccSumup(RestAccr,"");
  return;
end;

global
procedure RestAccVc_PasteTaxTemplateCode(var record RestAccVc RestAccr,Integer rownr)
begin
  row RestAccVc RestAccrw;
  record TaxMatrixVc TMr;
  
  MatRowGet(RestAccr,rownr,RestAccrw);
  RestAccrw.TaxTemplateCode = OverrideTaxMatrix(RestAccrw.TaxTemplateCode,TMr);
  PackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
  MatRowPut(RestAccr,rownr,RestAccrw);
  RowCalculateTaxMatrix_RestAccVc(RestAccr,rownr,RestAccrw);
  MatRowPut(RestAccr,rownr,RestAccrw);
  RestAccDchrsum(RestAccr,rownr,0);
  return;
end;

global
function Boolean RestAccVc_PasteArtCode(var record RestAccVc RestAccr,Integer rownr,record LocalMachineBlock LMb,string printgroupcode,Integer Modifier,val defqty,
                                        var string inwarning)
BEGIN
  Boolean res;
  record INVc INr;  
  row RestAccVc RestAccrw;
  Boolean chsum,calcpricef,bool;
  val price,vreb,baseprice,tax2prc;
  string 255 curitemname,vatcode,salesacc,tax2code,taxtemplatecode;
  Boolean dummyf;
  record TaxMatrixVc TMr;
  Time blankt;

  inwarning = "";
  MatRowGet(RestAccr,rownr,RestAccrw);
  if (blank(RestAccrw.Quant)) then begin
    RestAccrw.Quant = defqty;
  end;

  res = false;
  if (GetItemPriceDiscount3(RestAccrw.ArtCode,RestAccrw.Quant,INr,"",
                          blankval,blankval,blankval,blankval,blankval,
                          "","",RestAccr.PriceList,RestAccr.RebCode,
                          price,curitemname,vreb,vatcode,baseprice,salesacc,
                          0,calcpricef,RestAccr.TransDate,blankt,RestAccr.CUCode,false,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode)) then 
  begin
/*should i put branch as argument ? */
    if (BlockedBranchItem(LMb.BranchID,RestAccrw.ArtCode)==false) then begin
      RestAccrw.TaxTemplateCode = FillupTaxMatrix(0,RestAccr.BranchID,RestAccr.CUCode,RestAccr.CustCat,"",taxtemplatecode,TMr);

      if (calcpricef) then begin
        RestAccrw.Quant = blankval;
        RestAccVcGetCalcItemPrice(INr,RestAccr,rownr,price);
      end;
      RestAccrw.Spec = curitemname;
      RestAccrw.Price = price;
      RestAccrw.BasePrice = baseprice;
      RestAccrw.PriceFactor = INr.PriceFactor;
      RestAccrw.VATCode = vatcode;
      RestAccrw.Modifier = Modifier;
      RestAccrw.PrintGroupCode = printgroupcode;
      RestAccrw.KitchenDepartment = GetItemDept(LMb,RestAccrw.ArtCode,RestAccr.BranchID);
      PackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
      MatRowPut(RestAccr,rownr,RestAccrw);
      RestAccDchrsum(RestAccr,rownr,0);
      RestAccDchsum(RestAccr,rownr);
      chsum = true;
      res = true;
    end else begin
      inwarning = USetStr(21445);
    end;
  end;  
  if (chsum) then begin
    RestAccr.ServCharge = GetServiceCharge(RestAccr,LMb,true);
    RestAccSumup(RestAccr,"");
  end;  
  RestAccVc_PasteArtCode = res;
  RETURN;
END;

global
updating function LongInt RestAccCheckIfSaveAllowed(var record RestAccVc RestAccr,record RestAccVc RestAcc2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  SetRecordCheckVc("RestAccVc");
  res = RestAccVcRecordCheck(RestAccr,RestAcc2r,stat,long4);  
  RestAccCheckIfSaveAllowed = res;
  RETURN;
END;

global
updating procedure CreateCashDrawerAct(string curuser)
begin
  record ActVc Actr;
  
  RecordNew(Actr);
  Actr.MainPersons = curuser;
  Actr.TransDate = CurrentDate;
  Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
  Actr.Invalid = 0;
  Actr.TodoFlag = 0;
  Actr.Comment = USetStr(1755);
/* Needs a setting
  BlockLoad(ASTRec);
  Actr.ActType = ASTRec.GenSalesOrd;
  Actr.OKFlag = ASTRec.OrderDone;
*/
  if (RecordInsert(Actr,false)) then begin
  end;
  return;
end;

// This function makes no sense. I replaced this function with a setting in the Local Machine called Default Displaygroup
global
function string 40 RestAccITDefaultRemote(string default,string curmachine)
BEGIN
  string 40 lsubset;
  record DIVc DIr;
  record RestITVc RestITr;
  row RestITVc RestITrw;
  Integer i,rwcnt;
  Boolean found;
  
  lsubset = default;
  if (nonblank(curmachine)) then begin
    RestITr.Code = curmachine;
    if (ReadFirstMain(RestITr,1,true)) then begin
      rwcnt = MatRowCnt(RestITr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RestITr,i,RestITrw);
        DIr.Code = RestITrw.ITCode;
        if (ReadFirstMain(DIr,1,true)) begin
          lsubset = DIr.Code;
          found = true;
          goto LRestAccITDefaultRemote;
        end;
      end;
    end;
  end;
  ResetLoop(DIr);
  found = true;
  while (LoopMain(DIr,1,found)) begin
    lsubset = DIr.Code;
    goto LRestAccITDefaultRemote;
  end;
LRestAccITDefaultRemote:;
  RestAccITDefaultRemote = lsubset;
  RETURN;
END;

global 
procedure slRestAccHALRemote(string subset,var Array string anames, var LongInt acnt)
BEGIN
  record DIVc DIr;
  Boolean found;
  string 255 ckey,t2,tstr;

  found = true;
  ckey = "DICode:" & subset;
  while (LoopKey(ckey,DIr,1,found)) begin
    tstr = DIr.Name & " ";
    tstr = tstr & DIr.colnr;
    anames[acnt] = tstr;
    acnt = acnt + 1;
  end;
  RETURN;
END;          

global
procedure BuildRestaurantOrder(record RestAccVc RestAccr,var array Integer kitcharr,var Integer kitchi,var array Integer bararr,var Integer bari)
begin
  record INVc INr;
  record RestITVc RestITr;
  row RestITVc RestITrw;
  row RestAccVc RestAccrw;
  Integer i,rwcnt;
  Integer j,rwcntj;
  Boolean AddToKitch;

  bari = 0;
  kitchi = 0;
  for (i=0;i<1000;i=i+1) begin
    kitcharr[i] = 0;
    bararr[i] = 0;
  end;
  RestITr.Code = RestAccr.MachineName;
  AddToKitch = false;
  if (ReadFirstMain(RestITr,1,true)) then begin
    rwcntj = MatRowCnt(RestITr);
    rwcnt = MatRowCnt(RestAccr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(RestAccr,i,RestAccrw);
      if (RestAccrw.stp==1) or (RestAccrw.stp==3) then begin
      if (RestAccrw.AlreadyPrintedToKitchen==0) then begin
// If no item, it should remember the previous lines type and end up in the appropriate array (for comments).
        if (ReadFirstItem(RestAccrw.ArtCode,INr,true,true)) then begin
          AddToKitch = false;
          for (j=0;j<rwcntj;j=j+1) begin
            MatRowGet(RestITr,j,RestITrw);
            if (SetInSet(RestITrw.ITCode,INr.DispGroups)) then begin
              AddToKitch = true;
              j = rwcntj;
            end;
          end;
        end;
        if (AddToKitch) then begin
          kitcharr[kitchi] = i;
          kitchi = kitchi + 1;
        end else begin
          bararr[bari] = i;
          bari = bari + 1;
        end;
      end;
      end;
    end;
  end;
  return;
end;

global
procedure RestAccDUpdatePrices(var record RestAccVc RestAccp)
begin
  row RestAccVc RestAccrw;
  record INVc INr;
  Integer i,rwcnt;
  Boolean chsum,calcpricef,bool;
  val price,vreb,baseprice,tax2prc;
  string 255 curitemname,vatcode,salesacc,tax2code,taxtemplatecode;
  Boolean dummyf;
  record GeneralOptionBlock GenOptRec;
  Time blankt;

  BlockLoad(GenOptRec);
  rwcnt = MatRowCnt(RestAccp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    if (nonblank(RestAccrw.ArtCode)) then begin
      RestAccrw.Price = blankval;
      GetItemPriceDiscount3(RestAccrw.ArtCode,RestAccrw.Quant,INr,"",
                            blankval,blankval,blankval,blankval,blankval,
                            "","",RestAccp.PriceList,"",
                            price,curitemname,vreb,vatcode,baseprice,salesacc,
                            0,calcpricef,RestAccp.TransDate,blankt,RestAccp.CUCode,false,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode);
      RestAccrw.Price = price;  
      RestAccrw.ArtCode = INr.Code;
      RestAccrw.vRebate = vreb;
//      RestAccrw.SalesAcc = salesacc;
/*      
      if (nonblank(RestAccp.CustVATCode)) then begin
        RestAccrw.VATCode = RestAccp.CustVATCode;
      end;
*/      
      MatRowPut(RestAccp,i,RestAccrw);
      RestAccDchrsum(RestAccp,i,0);//GenOptRec.UseDiscount
      RestAccDchsum(RestAccp,i);
    end;
  end;
  RestAccSumup(RestAccp,"");
  if (nonblank(RestAccp.LoyaltyCardNr)) then begin 
    CalculateRestAccVcPoints(RestAccp);
  end;
  return;
end;

global
procedure RestAccVc_PasteRebCode(var record RestAccVc RestAccp)
begin
  RestAccDUpdatePrices(RestAccp);
  return;
end;

procedure FindAlreadyReturnedItems_RestAccVc(LongInt OrgRestAccNr,var vector val valreadyreturned)
begin
  record RestAccVc RestAccr;
  row RestAccVc RestAccrw;
  Boolean found,testf;
  string 255 keystr;
  Integer i,rwcnt;
  
  found = true;
  keystr = "OrgRestAccNr:" & OrgRestAccNr;
  while (LoopKey(keystr,RestAccr,1,found)) begin
    if (found) then begin
      testf = true;
      if (RestAccr.Closed==0) then begin testf = false; end;
      if (testf) then begin
        rwcnt = MatRowCnt(RestAccr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(RestAccr,i,RestAccrw);
          switch (RestAccrw.stp) begin
            case kInvoiceRowTypeNormal:
              valreadyreturned[RestAccrw.ArtCode] = valreadyreturned[RestAccrw.ArtCode] - RestAccrw.Quant;
            case kInvoiceRowTypeStructuredItemComponent:
              valreadyreturned[RestAccrw.ArtCode] = valreadyreturned[RestAccrw.ArtCode] - RestAccrw.Quant;
          end;
        end;
      end;
    end;
  end;
  return;
end;  

global
procedure RestAccDClassTouchScreenReturnRemote(record RestAccVc RestAccr,var record RestAccVc newRestAccr)
begin
  Integer i,rwcnt,rownr;
  row RestAccVc newRestAccrw;
  vector val valreadyreturned;
  record GeneralOptionBlock GOb;

  BlockLoad(GOb);
  FindAlreadyReturnedItems_RestAccVc(RestAccr.SerNr,valreadyreturned);
  rwcnt = MatRowCnt(RestAccr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccr,i,newRestAccrw);
    switch (newRestAccrw.stp) begin
      case kInvoiceRowTypeCreditCardPayment:
        if (blank(newRestAccrw.AuthorizationCode)) then begin
          newRestAccrw.Sum = -newRestAccrw.Sum;
          newRestAccrw.AuthorizationCode = "";
          newRestAccrw.CreditCard = "";
          MatRowPut(newRestAccr,MatRowCnt(newRestAccr),newRestAccrw);
        end;
      case kInvoiceRowTypeCashPayment:
//          newRestAccrw.Sum = -newRestAccrw.Sum;
//          MatRowPut(newRestAccr,MatRowCnt(newRestAccr),newRestAccrw);
      case kInvoiceRowTypeLoyaltyPointsPayment:
//          newRestAccrw.Sum = -newRestAccrw.Sum;
//          MatRowPut(newRestAccr,MatRowCnt(newRestAccr),newRestAccrw);
      case kInvoiceRowTypeGiftVoucherPayment:
//          newRestAccrw.Sum = -newRestAccrw.Sum;
//          MatRowPut(newRestAccr,MatRowCnt(newRestAccr),newRestAccrw);
      case kInvoiceRowTypeMultiBuyDiscount:
          rownr = MatRowCnt(newRestAccr);
          newRestAccrw.Quant = -newRestAccrw.Quant;
          newRestAccrw.Sum = -newRestAccrw.Sum;
          MatRowPut(newRestAccr,rownr,newRestAccrw);
//          RestAccDchrsum(RestAccr,rownr,GOb.UseDiscount);
//          RestAccDchsum(RestAccr,rownr);
      otherwise
        if (valreadyreturned[newRestAccrw.ArtCode]<newRestAccrw.Quant) then begin
          newRestAccrw.Quant = -newRestAccrw.Quant;
          newRestAccrw.Sum = -newRestAccrw.Sum;
          newRestAccrw.rowGP = -newRestAccrw.rowGP;
          rownr = MatRowCnt(newRestAccr);
          RowCalculateTaxMatrix_RestAccVc(newRestAccr,rownr,newRestAccrw);
          MatRowPut(newRestAccr,rownr,newRestAccrw);
        end else begin
          valreadyreturned[newRestAccrw.ArtCode] = valreadyreturned[newRestAccrw.ArtCode] - newRestAccrw.Quant;
        end;
    end;      
  end;
  if (MatRowCnt(newRestAccr)>0) then begin
    if (RestAccr.SerNr!=newRestAccr.SerNr) then begin
      ClearRow(newRestAccr,newRestAccrw,kInvoiceRowTypeReturnIVNr);    
      newRestAccrw.OrgRestAccNr = RestAccr.SerNr;
      MatRowPut(newRestAccr,MatRowCnt(newRestAccr),newRestAccrw);
    end;
  end;

  return;
end;  
