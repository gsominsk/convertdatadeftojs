external function Boolean StockMovVc_PasteQuant(var record StockMovVc,Integer);
external function boolean UpdateExistingVarietyRowsf();
external procedure RemoveInvalidVarietyItemAfterPasting_RecVc(var record RecVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_ProdVc(var record ProdVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_ORVc(var record ORVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_IVVc(var record IVVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_IVCashVc(var record IVCashVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_StockMovVc(var record StockMovVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_StockTakeVc(var record StockTakeVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_QTVc(var record QTVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_PUVc(var record PUVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_POVc(var record POVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_IntORVc(var record IntORVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_POQTVc(var record POQTVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_SDVc(var record SDVc,var integer);
external procedure RemoveInvalidVarietyItemAfterPasting_SRVc(var record SRVc,var integer);
external procedure POQTVc_PasteQuant(var record POQTVc,Integer);
external procedure POVc_PasteQuant(var record POVc,Integer);
external procedure IVSumup(var record IVVc,Boolean);
external procedure IVCashSumup(var record IVCashVc,Boolean);
external function Boolean IVCashDchrsum(record IVCashVc,Integer,Integer);
external procedure IVCashDchsum(record IVCashVc,Integer);
external function Boolean IVCashVc_PasteArtCode(var record IVCashVc,Integer,Boolean,var string,var Integer);
external procedure SplitEclass(string,var Array string);
external function Boolean StockTakeVc_PasteArtCode(var record StockTakeVc,Integer,Integer,var string);
external procedure RecVc_PasteItem(var record RecVc,Integer);
external procedure RecSumup(record RecVc);
external procedure ProdOperationSumup(var record ProdOperationVc);
external procedure ProdOperationVc_PasteItem(var record ProdOperationVc,Integer);
external procedure ProdSumup(var record ProdVc);
external procedure ProdVc_PasteItem(var record ProdVc,Integer);
external function Boolean ORVc_ExplodeRecepy(record INVc,val,record ORVc,string,Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure IVDchsum(var record IVVc,Integer);
external procedure ORDchsum(var record ORVc,Integer);
external procedure QTDchsum(record QTVc,Integer);
external function Boolean POQTDchrsum(record POQTVc,Integer);
external function Boolean IntORchrsum(record IntORVc,Integer);
external function Boolean PODchrsum(record POVc,Integer);
external function Boolean QTDchrsum(var record QTVc,Integer,Integer);
external function Boolean IVDchrsum(var record IVVc,Integer);
external function Boolean ORDchrsum(var record ORVc,Integer);
external function Boolean SDVc_PasteArtCode(var record SDVc,Integer,Integer,var string,var string);
external procedure SDSumUp(var record SDVc);
external function Boolean SRVc_PasteArtCode(var record SRVc,Integer,Boolean,var string);
external procedure SRSumUp(var record SRVc);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external procedure FillMaskVAR(string,string,string,Array string,Array string);
external procedure FillOneItemOneVAR(string,string,string,Array string,var Array string,Integer,Boolean);
external function Boolean PUVc_PasteArtCode(var record PUVc,Integer,var string,var string);
external function Boolean ORVc_PasteArtCode(var record ORVc,Integer,var string,var string,Boolean);
external function Boolean POVc_PasteArtCode(var record POVc,Integer,Boolean);
external function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external function Boolean QTVc_PasteArtCode(var record QTVc,Integer,var string,var string);
external function Boolean POQTVc_PasteArtCode(var record POQTVc,Integer,Boolean);
external function Boolean IntORVc_PasteArtCode(var record IntORVc,Integer,Boolean);
external function Boolean StockMovVc_PasteArtCode(var record StockMovVc,Integer,Integer,var array string);
external procedure PUSumUp(var record PUVc);
external procedure ORSumup(var record ORVc);
external procedure POSumup(var record POVc);
external procedure QTSumup(var record QTVc);
external procedure POQTSumup(var record POQTVc);
external procedure SumupIntOR(var record IntORVc,var val);
external procedure StockMovSumUp(var record StockMovVc);

global
procedure PasteRowsToIVRemote(var record IVVc IVr,var Integer currow,array string incode,array val qty,Integer pos,Boolean TouchScreenLookf)
begin
  row IVVc IVrw;
  Integer i,ri,rwcnt;
  string 255 warning;
  record INVc INr;
  Integer sernrf;
  vector Boolean vfound;
  string 255 lastartcode;
  record INVc IN2r;
  row IVVc IVprevrw;

  MatRowGet(IVr,currow,IVrw);
  if (UpdateExistingVarietyRowsf) then begin 
    MatRowGet(IVr,currow,IVprevrw);
    if (nonblank(IVrw.ArtCode) and (ReadFirstItem(IVrw.ArtCode,INr,true,true)==false)) then begin 
      MatRowDelete(IVr,currow);
    end;
    ReadFirstItem(IVrw.ArtCode,INr,true,false);
  end else begin
    MatRowDelete(IVr,currow);
  end;   
  
  rwcnt = MatRowCnt(IVr);
  if (UpdateExistingVarietyRowsf) then begin 
    for (ri=0;ri<rwcnt;ri=ri+1) begin
      MatRowGet(IVr,ri,IVrw);
      for (i=0;i<pos;i=i+1) begin
        if (nonblank(IVrw.ArtCode) and nonblank(incode[i]) and (IVrw.ArtCode==incode[i])) then begin
          IVrw.Quant = qty[i];
          MatRowPut(IVr,ri,IVrw);
          if (IVDchrsum(IVr,ri)) then begin end;
          IVDchsum(IVr,ri);
          vfound[IVrw.ArtCode] = true;
        end;
        if (ReadFirstItem(IVrw.ArtCode,IN2r,true,true)) then begin
          if (INr.Code==IN2r.Code) then begin 
            lastartcode = IN2r.Code;
            MatRowGet(IVr,ri,IVprevrw);
          end;
        end; 
      end;
    end;
    RemoveInvalidVarietyItemAfterPasting_IVVc(IVr,rwcnt);  
    currow = rwcnt;
  end;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      IVrw.ArtCode = incode[i];
      IVrw.Quant = qty[i];
      if (ReadFirstItem(IVrw.ArtCode,INr,true,true)) then begin
        IVrw.Spec = INr.Name;
      end;
      MatRowInsert(IVr,currow,IVrw);
      if (UpdateExistingVarietyRowsf==false) then begin
        if (IVVc_PasteArtCode(IVr,currow,warning,warning,TouchScreenLookf,sernrf)) then begin end;
      end else begin
        if (nonblank(lastartcode)) then begin
         if (ReadFirstItem(lastartcode,IN2r,true,false)) then begin 
            if (INr.Code==IN2r.Code) then begin 
              IVprevrw.ArtCode = IVrw.ArtCode;
              IVprevrw.Quant = IVrw.Quant;
              IVprevrw.Spec = IVrw.Spec;
              MatRowPut(IVr,currow,IVprevrw);
            end;          
         end;  
        end else begin
          if (IVVc_PasteArtCode(IVr,currow,warning,warning,TouchScreenLookf,sernrf)) then begin end;
        end;
        if (IVDchrsum(IVr,currow)) then begin end;
        IVDchsum(IVr,currow);
      end;
      currow = currow + 1;
    end;
  end;
  IVSumUp(IVr,true);
  return;
end;

global
procedure PasteRowsToORRemote(var record ORVc ORr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  record INVc INr;
  row ORVc ORrw;
  Integer i,ri,rwcnt;
  string 255 warning;
  vector Boolean vfound;
  string 255 lastartcode;
  record INVc IN2r;
  row ORVc ORprevrw;
  
  MatRowGet(ORr,currow,ORrw);
  if (UpdateExistingVarietyRowsf) then begin
    MatRowGet(ORr,currow,ORprevrw);
    if (nonblank(ORrw.ArtCode) and (ReadFirstItem(ORrw.ArtCode,INr,true,true)==false)) then begin 
      MatRowDelete(ORr,currow);
    end;  
    ReadFirstItem(ORrw.ArtCode,INr,true,false);
  end else begin
    MatRowDelete(ORr,currow);
  end;        

  if (UpdateExistingVarietyRowsf) then begin   
    rwcnt = MatRowCnt(ORr);
    for (ri=0;ri<rwcnt;ri=ri+1) begin
      MatRowGet(ORr,ri,ORrw);
      for (i=0;i<pos;i=i+1) begin
        if (nonblank(ORrw.ArtCode) and nonblank(incode[i]) and (ORrw.ArtCode==incode[i])) then begin
          ORrw.Quant = qty[i];
          MatRowPut(ORr,ri,ORrw);
          if (ORDchrsum(ORr,ri)) then begin end;
          ORDchsum(ORr,ri);
          vfound[ORrw.ArtCode] = true;
        end;
        if (ReadFirstItem(ORrw.ArtCode,IN2r,true,true)) then begin
          if (INr.Code==IN2r.Code) then begin 
            lastartcode = IN2r.Code;
            MatRowGet(ORr,ri,ORprevrw);
          end;
        end;         
      end;
    end;
    RemoveInvalidVarietyItemAfterPasting_ORVc(ORr,rwcnt);
    currow = rwcnt;
  end;
  
  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      ORrw.ArtCode = incode[i];
      ORrw.Quant = qty[i];
      if (ReadFirstItem(ORrw.ArtCode,INr,true,true)) then begin
        ORrw.Spec = INr.Name;
      end;
      MatRowInsert(ORr,currow,ORrw);
      if (UpdateExistingVarietyRowsf==false) then begin
        if (ORVc_PasteArtCode(ORr,currow,warning,warning,true)) then begin end;
      end else begin
        if (nonblank(lastartcode)) then begin
         if (ReadFirstItem(lastartcode,IN2r,true,false)) then begin 
            if (INr.Code==IN2r.Code) then begin 
              ORprevrw.ArtCode = ORrw.ArtCode;
              ORprevrw.Quant = ORrw.Quant;
              ORprevrw.Spec = ORrw.Spec;
              MatRowPut(ORr,currow,ORprevrw);
            end;          
         end;  
        end else begin
          if (ORVc_PasteArtCode(ORr,currow,warning,warning,true)) then begin end;
        end;      
        if (ORDchrsum(ORr,currow)) then begin end;
        ORDchsum(ORr,currow);
      end;
      MatRowGet(ORr,currow,ORrw);
      if (ReadFirstItem(ORrw.ArtCode,INr,true,false)) then begin
        if ((INr.ExplodeRec!=0) and (nonblank(ORrw.Recepy))) then begin
          INr.Code = ORrw.ArtCode;
          if (ORVc_ExplodeRecepy(INr,ORrw.Quant,ORr,INr.Recepy,currow)) then begin
            MatRowGet(ORr,currow,ORrw);
            ORrw.Recepy = "";
            MatRowPut(ORr,currow,ORrw);
            INr.Code = ORrw.ArtCode;
          end;
        end;
      end;
      currow = currow + 1;
    end;
  end;
  ORSumUp(ORr);
  return;
end;

global
procedure PasteRowsToIVCashRemote2(var record IVCashVc IVCashr,var Integer currow,array string incode,array val qty,Integer pos,var Integer sernrf)
begin
  record INVc INr;
  row IVCashVc IVCashrw;
  Integer i,ri,rwcnt;
  string 255 warning;
  record GeneralOptionBlock GenOptRec;
  vector Boolean vfound;
  string 255 lastartcode;
  record INVc IN2r;
  row IVCashVc IVprevrw;

  BlockLoad(GenOptRec);

  MatRowGet(IVCashr,currow,IVCashrw);
  if (UpdateExistingVarietyRowsf) then begin 
    if (nonblank(IVCashrw.ArtCode) and (ReadFirstItem(IVCashrw.ArtCode,INr,true,true)==false)) then begin 
      MatRowDelete(IVCashr,currow);
    end;  
  end else begin
    MatRowDelete(IVCashr,currow);
  end;

  rwcnt = MatRowCnt(IVCashr);
  if (UpdateExistingVarietyRowsf) then begin 
    for (ri=0;ri<rwcnt;ri=ri+1) begin
      MatRowGet(IVCashr,ri,IVCashrw);
      for (i=0;i<pos;i=i+1) begin
        if (nonblank(IVCashrw.ArtCode) and nonblank(incode[i]) and (IVCashrw.ArtCode==incode[i])) then begin
          IVCashrw.Quant = qty[i];
          MatRowPut(IVCashr,ri,IVCashrw);
          if (IVCashDchrsum(IVCashr,ri,GenOptRec.UseDiscount)) then begin end;
          IVCashDchsum(IVCashr,ri);
          vfound[IVCashrw.ArtCode] = true;
        end;
      end;
    end;
    RemoveInvalidVarietyItemAfterPasting_IVCashVc(IVCashr,rwcnt);
    currow = rwcnt;
  end;  
  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      IVCashrw.ArtCode = incode[i];
      IVCashrw.Quant = qty[i];
      if (ReadFirstItem(IVCashrw.ArtCode,INr,true,true)) then begin
        IVCashrw.Spec = INr.Name;
      end;
      MatRowPut(IVCashr,currow,IVCashrw);
      if (UpdateExistingVarietyRowsf==false) then begin
        if (IVCashVc_PasteArtCode(IVCashr,currow,false,warning,sernrf)) then begin end;
      end else begin
        if (IVCashDchrsum(IVCashr,currow,GenOptRec.UseDiscount)) then begin end;
        IVCashDchsum(IVCashr,currow);
      end;
      MatRowGet(IVCashr,currow,IVCashrw);
      currow = currow + 1;
    end;
  end;
  IVCashSumUp(IVCashr,true);
  return;
end;

global
procedure PasteRowsToIVCashRemote(var record IVCashVc IVCashr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  Integer sernrf;
  
  PasteRowsToIVCashRemote2(IVCashr,currow,incode,qty,pos,sernrf);
  return;
end;

global
procedure PasteRowsToStockMovRemote(var record StockMovVc StockMovr,var Integer currow,array string incode,array val qty,Integer pos,var array string aWarning)
begin
  row StockMovVc StockMovrw;
  Integer i,ri,rwcnt;
  string 255 warning;
  record INVc INr;
  vector Boolean vfound;
  record VarietyBlock VBr;  
  
  BlockLoad(VBr);
  MatRowGet(StockMovr,currow,StockMovrw);
  if (nonblank(StockMovrw.ArtCode) and (ReadFirstItem(StockMovrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(StockMovr,currow);
  end;
  
  rwcnt = MatRowCnt(StockMovr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(StockMovr,ri,StockMovrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(StockMovrw.ArtCode) and nonblank(incode[i]) and (StockMovrw.ArtCode==incode[i])) then begin
        StockMovrw.Quant = qty[i];
        MatRowPut(StockMovr,ri,StockMovrw);
        vfound[StockMovrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_StockMovVc(StockMovr,rwcnt);  
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      StockMovrw.ArtCode = incode[i];
      StockMovrw.OrdQuant = qty[i];
      if (ReadFirstItem(StockMovrw.ArtCode,INr,true,true)) then begin
        StockMovrw.Spec = INr.Name;
      end;
      MatRowInsert(StockMovr,currow,StockMovrw);
      if (VBr.UseInfoFromRow==0) then begin
        StockMovVc_PasteArtCode(StockMovr,currow,1,aWarning);
      end else begin
        StockMovVc_PasteArtCode(StockMovr,currow,1,aWarning);
        MatRowGet(StockMovr,currow,StockMovrw);
        StockMovrw.OrdQuant = qty[i];
        MatRowPut(StockMovr,currow,StockMovrw);
        StockMovVc_PasteQuant(StockMovr,currow);
        MatRowGet(StockMovr,currow,StockMovrw);
      end;
      currow = currow + 1;
    end;
  end;
  StockMovSumUp(StockMovr);
  return;
end;

global
procedure PasteRowsToStockTakeRemote(var record StockTakeVc StockTaker,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row StockTakeVc StockTakerw;
  Integer i,ri,rwcnt;
  string 255 warning;
  record SysFormatBlock SysFormatRec;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(StockTaker,currow,StockTakerw);
  if (nonblank(StockTakerw.ArtCode) and (ReadFirstItem(StockTakerw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(StockTaker,currow);
  end;
  
  rwcnt = MatRowCnt(StockTaker);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(StockTaker,ri,StockTakerw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(StockTakerw.ArtCode) and nonblank(incode[i]) and (StockTakerw.ArtCode==incode[i])) then begin
        StockTakerw.Qty = qty[i];
        MatRowPut(StockTaker,ri,StockTakerw);
        vfound[StockTakerw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_StockTakeVc(StockTaker,rwcnt);  
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      StockTakerw.ArtCode = incode[i];
      StockTakerw.Qty = qty[i];
      if (ReadFirstItem(StockTakerw.ArtCode,INr,true,true)) then begin
        StockTakerw.Spec = INr.Name;
      end;
      MatRowInsert(StockTaker,currow,StockTakerw);
      if (VBr.UseInfoFromRow==0) then begin
        if (StockTakeVc_PasteArtCode(StockTaker,currow,1,warning)) then begin end;
      end else begin
    //    StockTakeDchrsum(StockTaker,currow);
    //    StockTakeDchrum(StockTaker,currow);
      end;
      currow = currow + 1;
    end;
  end;
//  StockTakeSumUp(StockTaker);
  return;
end;

global
procedure PasteRowsToQTRemote(var record QTVc QTr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row QTVc QTrw;
  Integer i,ri,rwcnt;
  string 255 warning;
  record INVc INr;
  vector Boolean vfound;
  string 255 lastartcode;
  record INVc IN2r;
  row QTVc QTprevrw;  
  
  MatRowGet(QTr,currow,QTrw);
  if (UpdateExistingVarietyRowsf) then begin
    MatRowGet(QTr,currow,QTprevrw);
    if (nonblank(QTrw.ArtCode) and (ReadFirstItem(QTrw.ArtCode,INr,true,true)==false)) then begin 
      MatRowDelete(QTr,currow);
    end;
    ReadFirstItem(QTrw.ArtCode,INr,true,false);
  end else begin
    MatRowDelete(QTr,currow);
  end;
  
  rwcnt = MatRowCnt(QTr);
  if (UpdateExistingVarietyRowsf) then begin 
    for (ri=0;ri<rwcnt;ri=ri+1) begin
      MatRowGet(QTr,ri,QTrw);
      for (i=0;i<pos;i=i+1) begin
        if (nonblank(QTrw.ArtCode) and nonblank(incode[i]) and (QTrw.ArtCode==incode[i])) then begin
          QTrw.Quant = qty[i];
          MatRowPut(QTr,ri,QTrw);
          if (QTDchrsum(QTr,ri,0)) then begin end;
          QTDchsum(QTr,ri);
          vfound[QTrw.ArtCode] = true;
        end;
        if (ReadFirstItem(QTrw.ArtCode,IN2r,true,true)) then begin
          if (INr.Code==IN2r.Code) then begin 
            lastartcode = IN2r.Code;
            MatRowGet(QTr,ri,QTprevrw);
          end;
        end;         
      end;
    end;
    RemoveInvalidVarietyItemAfterPasting_QTVc(QTr,rwcnt);    
    currow = rwcnt;
  end;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      QTrw.ArtCode = incode[i];
      QTrw.Quant = qty[i];
      if (ReadFirstItem(QTrw.ArtCode,INr,true,true)) then begin
        QTrw.Spec = INr.Name;
      end;
      MatRowInsert(QTr,currow,QTrw);
      if (UpdateExistingVarietyRowsf==false) then begin
        if (QTVc_PasteArtCode(QTr,currow,warning,warning)) then begin end;
      end else begin
        if (nonblank(lastartcode)) then begin
         if (ReadFirstItem(lastartcode,IN2r,true,false)) then begin 
            if (INr.Code==IN2r.Code) then begin 
              QTprevrw.ArtCode = QTrw.ArtCode;
              QTprevrw.Quant = QTrw.Quant;
              QTprevrw.Spec = QTrw.Spec;
              MatRowPut(QTr,currow,QTprevrw);
            end;          
         end;  
        end else begin
          if (QTVc_PasteArtCode(QTr,currow,warning,warning)) then begin end;
        end;        
        if (QTDchrsum(QTr,currow,0)) then begin end;
        QTDchsum(QTr,currow);
      end;
      currow = currow + 1;
    end;
  end;
  QTSumUp(QTr);
  return;
end;

global
procedure PasteRowsToPURemote(var record PUVc PUr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row PUVc PUrw;
  Integer i,ri,rwcnt;
  string 255 warning,inwarn;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(PUr,currow,PUrw);
  if (nonblank(PUrw.ArtCode) and (ReadFirstItem(PUrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(PUr,currow);
  end;
  
  rwcnt = MatRowCnt(PUr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(PUr,ri,PUrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(PUrw.ArtCode) and nonblank(incode[i]) and (PUrw.ArtCode==incode[i])) then begin
        PUrw.Quant = qty[i];
        MatRowPut(PUr,ri,PUrw);
        vfound[PUrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_PUVc(PUr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      PUrw.ArtCode = incode[i];
      PUrw.Quant = qty[i];
      if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
        PUrw.Spec = INr.Name;
      end;
      MatRowInsert(PUr,currow,PUrw);
    // Very special calculations, has to paste...
    //  if (VBr.UseInfoFromRow==0) then begin
        if (PUVc_PasteArtCode(PUr,currow,warning,inwarn)) then begin end;
    //  end else begin
    //    PUDchrsum(PUr,currow);
    //  end;
      currow = currow + 1;
    end;
  end;
  PUSumUp(PUr);
  return;
end;

global
procedure PasteRowsToPORemote(var record POVc POr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row POVc POrw;
  row POVc prevPOrw;
  Integer i,ri,rwcnt;
  record VarietyBlock VBr;
  record INVc INr;
  Integer poi,porwcnt;
  Boolean prevrowf;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(POr,currow,POrw);
  if (nonblank(POrw.ArtCode) and (ReadFirstItem(POrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(POr,currow);
  end; 

  rwcnt = MatRowCnt(POr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(POr,ri,POrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(POrw.ArtCode) and nonblank(incode[i]) and (POrw.ArtCode==incode[i])) then begin
        POrw.Quant = qty[i];
        MatRowPut(POr,ri,POrw);
        POVc_PasteQuant(POr,ri);
        MatRowGet(POr,ri,POrw);
        vfound[POrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_POVc(POr,rwcnt);  
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      POrw.ArtCode = incode[i];
      POrw.Quant = qty[i];
/*      
      if (ReadFirstItem(POrw.ArtCode,INr,true,true)) then begin
        POrw.Spec = INr.Name;
      end;
*/      
      MatRowInsert(POr,currow,POrw);
      if (VBr.UseInfoFromRow==0) then begin
        if (POVc_PasteArtCode(POr,currow,true)) then begin end;
        MatRowGet(POr,currow,POrw);
        POrw.Quant = qty[i];
        MatRowPut(POr,currow,POrw);
        POVc_PasteQuant(POr,currow);
        MatRowGet(POr,currow,POrw);
      end else begin
        if (POVc_PasteArtCode(POr,currow,true)) then begin end;
        MatRowGet(POr,currow,POrw);
        POrw.Quant = qty[i];
        MatRowPut(POr,currow,POrw);
        POVc_PasteQuant(POr,currow);
        MatRowGet(POr,currow,POrw);
      end;
      currow = currow + 1;
    end;
  end;
  POSumUp(POr);
  return;
end;

global
procedure PasteRowsToIntORRemote(var record IntORVc IntORr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row IntORVc IntORrw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(IntORr,currow,IntORrw);
  if (nonblank(IntORrw.ArtCode) and (ReadFirstItem(IntORrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(IntORr,currow);
  end;

  rwcnt = MatRowCnt(IntORr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(IntORr,ri,IntORrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(IntORrw.ArtCode) and nonblank(incode[i]) and (IntORrw.ArtCode==incode[i])) then begin
        IntORrw.Quant = qty[i];
        MatRowPut(IntORr,ri,IntORrw);
        IntORchrsum(IntORr,ri);
        vfound[IntORrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_IntORVc(IntORr,rwcnt);    
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      IntORrw.ArtCode = incode[i];
      IntORrw.Quant = qty[i];
      if (ReadFirstItem(IntORrw.ArtCode,INr,true,true)) then begin
        IntORrw.Spec = INr.Name;
      end;
      MatRowInsert(IntORr,currow,IntORrw);
      if (VBr.UseInfoFromRow==0) then begin
        if (IntORVc_PasteArtCode(IntORr,currow,true)) then begin end;
        if (IntORchrsum(IntORr,currow)) then begin end;
      end else begin
        if (IntORchrsum(IntORr,currow)) then begin end;
    //    IntORchsum(IntORr,currow);
      end;
      currow = currow + 1;
    end;
  end;
  SumupIntOR(IntORr,v);
  IntORr.Total = v;
  return;
end;

global
procedure PasteRowsToPOQTRemote(var record POQTVc POQTr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row POQTVc POQTrw;
  Integer i,ri,rwcnt;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(POQTr,currow,POQTrw);
  if (nonblank(POQTrw.ArtCode) and (ReadFirstItem(POQTrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(POQTr,currow);
  end;

  rwcnt = MatRowCnt(POQTr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(POQTr,ri,POQTrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(POQTrw.ArtCode) and nonblank(incode[i]) and (POQTrw.ArtCode==incode[i])) then begin
        POQTrw.Quant = qty[i];
        MatRowPut(POQTr,ri,POQTrw);
        POQTVc_PasteQuant(POQTr,currow);
        MatRowGet(POQTr,currow,POQTrw);
        vfound[POQTrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_POQTVc(POQTr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      POQTrw.ArtCode = incode[i];
      POQTrw.Quant = qty[i];

      if (ReadFirstItem(POQTrw.ArtCode,INr,true,true)) then begin
        POQTrw.Spec = INr.Name;
      end;
      MatRowInsert(POQTr,currow,POQTrw);
      if (VBr.UseInfoFromRow==0) then begin
        if (POQTVc_PasteArtCode(POQTr,currow,false)) then begin end;
        MatRowGet(POQTr,currow,POQTrw);
        POQTrw.Quant = qty[i];
        MatRowPut(POQTr,currow,POQTrw);
        POQTVc_PasteQuant(POQTr,currow);
        MatRowGet(POQTr,currow,POQTrw);
      end else begin
        if (POQTDchrsum(POQTr,currow)) then begin end;
        MatRowGet(POQTr,currow,POQTrw);
        POQTrw.Quant = qty[i];
        MatRowPut(POQTr,currow,POQTrw);
        POQTVc_PasteQuant(POQTr,currow);
        MatRowGet(POQTr,currow,POQTrw);
  //    POQTDchsum(POQTr,currow);
      end;
      currow = currow + 1;
    end;
  end;
  POQTSumup(POQTr);
  return;
end;

global
procedure PasteRowsToSDRemote(var record SDVc SDr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row SDVc SDrw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(SDr,currow,SDrw);
  if (nonblank(SDrw.ArtCode) and (ReadFirstItem(SDrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(SDr,currow);
  end;

  rwcnt = MatRowCnt(SDr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(SDr,ri,SDrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(SDrw.ArtCode) and nonblank(incode[i]) and (SDrw.ArtCode==incode[i])) then begin
        SDrw.Qty = qty[i];
        MatRowPut(SDr,ri,SDrw);
        vfound[SDrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_SDVc(SDr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      SDrw.ArtCode = incode[i];
      SDrw.Qty = qty[i];
      if (ReadFirstItem(SDrw.ArtCode,INr,true,true)) then begin
        SDrw.Spec = INr.Name;
      end;
      MatRowInsert(SDr,currow,SDrw);
      if (VBr.UseInfoFromRow==0) then begin
        if (SDVc_PasteArtCode(SDr,currow,1,warning,warning)) then begin end;
      end else begin
    //    SDDchrsum(SDr,currow);
    //    SDDchsum(SDr,currow);
      end;
      currow = currow + 1;
    end;
  end;
  SDSumUp(SDr);
  return;
end;

global
procedure PasteRowsToSRRemote(var record SRVc SRr,var Integer currow,array string incode,array val qty,Integer pos)
begin
  row SRVc SRrw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(SRr,currow,SRrw);
  if (nonblank(SRrw.ArtCode) and (ReadFirstItem(SRrw.ArtCode,INr,true,true)==false)) then begin 
    MatRowDelete(SRr,currow);
  end;

  rwcnt = MatRowCnt(SRr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(SRr,ri,SRrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(SRrw.ArtCode) and nonblank(incode[i]) and (SRrw.ArtCode==incode[i])) then begin
        SRrw.Qty = qty[i];
        MatRowPut(SRr,ri,SRrw);
        vfound[SRrw.ArtCode] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_SRVc(SRr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      SRrw.ArtCode = incode[i];
      SRrw.Qty = qty[i];
      if (i>0 and currow<MatRowCnt(SRr)) then begin
        MatRowInsert(SRr,currow,SRrw);
      end;
      if (ReadFirstItem(SRrw.ArtCode,INr,true,true)) then begin
        SRrw.Spec = INr.Name;
      end;
      MatRowInsert(SRr,currow,SRrw);
      if (VBr.UseInfoFromRow==0) then begin
        if (SRVc_PasteArtCode(SRr,currow,true,warning)) then begin end;
      end;
      currow = currow + 1;
    end;
  end;
  SRSumUp(SRr);
  return;
end;

global
procedure PasteRowsToProdRemote(var record ProdVc Prodr,var Integer currow,string fieldname,array string incode,array val qty,Integer pos)
begin
  row ProdVc Prodrw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(Prodr,currow,Prodrw);
  if (nonblank(Prodrw.Item) and (ReadFirstItem(Prodrw.Item,INr,true,true)==false)) then begin 
    MatRowDelete(Prodr,currow);
  end;

  rwcnt = MatRowCnt(Prodr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(Prodr,ri,Prodrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(Prodrw.Item) and nonblank(incode[i]) and (Prodrw.Item==incode[i])) then begin
        switch (fieldname) begin
          case "InQty": Prodrw.InQty = qty[i];
          case "OutQty": Prodrw.OutQty = qty[i];
        end;
        MatRowPut(Prodr,ri,Prodrw);
        vfound[Prodrw.Item] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_ProdVc(Prodr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      Prodrw.Item = incode[i];
      switch (fieldname) begin
        case "InQty": Prodrw.InQty = qty[i];
        case "OutQty": Prodrw.OutQty = qty[i];
      end;
      if (ReadFirstItem(Prodrw.Item,INr,true,true)) then begin
        Prodrw.Comment = INr.Name;
      end;
      MatRowInsert(Prodr,currow,Prodrw);
      if (VBr.UseInfoFromRow==0) then begin
        ProdVc_PasteItem(Prodr,currow);
      end else begin
    //    ProdDchrsum(Prodr,currow);
    //    ProdDchsum(Prodr,currow);
      end;
      currow = currow + 1;
    end;
  end;  
  ProdSumup(Prodr);
  return;
end;

global
procedure PasteRowsToProdOperationRemote(var record ProdOperationVc ProdOpr,var Integer currow,string fieldname,array string incode,array val qty,Integer pos)
begin
  row ProdOperationVc ProdOprw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(ProdOpr,currow,ProdOprw);
  if (nonblank(ProdOprw.Item) and (ReadFirstItem(ProdOprw.Item,INr,true,true)==false)) then begin 
    MatRowDelete(ProdOpr,currow);
  end;

  rwcnt = MatRowCnt(ProdOpr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(ProdOpr,ri,ProdOprw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(ProdOprw.Item) and nonblank(incode[i]) and (ProdOprw.Item==incode[i])) then begin      
        switch (fieldname) begin
          case "InQty": ProdOprw.InQty = qty[i];
          case "OutQty": ProdOprw.OutQty = qty[i];
        end;
        MatRowPut(ProdOpr,ri,ProdOprw);
        vfound[ProdOprw.Item] = true;
      end;
    end;
  end;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      ProdOprw.Item = incode[i];
      switch (fieldname) begin
        case "InQty": ProdOprw.InQty = qty[i];
        case "OutQty": ProdOprw.OutQty = qty[i];
      end;
      if (ReadFirstItem(ProdOprw.Item,INr,true,true)) then begin
        ProdOprw.Comment = INr.Name;
      end;
      MatRowInsert(ProdOpr,currow,ProdOprw);
      if (VBr.UseInfoFromRow==0) then begin
        ProdOperationVc_PasteItem(ProdOpr,currow);
      end else begin
    //    ProdOpDchrsum(ProdOpr,currow);
    //    ProdOpDchsum(ProdOpr,currow);
      end;
      currow = currow + 1;
    end;
  end;  
  ProdOperationSumup(ProdOpr);
  return;
end;

global
procedure PasteRowsToRecRemote(var record RecVc Recr,var Integer currow,string fieldname,array string incode,array val qty,Integer pos)
begin
  row RecVc Recrw;
  Integer i,ri,rwcnt;
  val v;
  string 255 warning;
  record VarietyBlock VBr;
  record INVc INr;
  vector Boolean vfound;
  
  BlockLoad(VBr);

  MatRowGet(Recr,currow,Recrw);
  if (nonblank(Recrw.Item) and (ReadFirstItem(Recrw.Item,INr,true,true)==false)) then begin 
    MatRowDelete(Recr,currow);
  end;

  rwcnt = MatRowCnt(Recr);
  for (ri=0;ri<rwcnt;ri=ri+1) begin
    MatRowGet(Recr,ri,Recrw);
    for (i=0;i<pos;i=i+1) begin
      if (nonblank(Recrw.Item) and nonblank(incode[i]) and (Recrw.Item==incode[i])) then begin      
        switch (fieldname) begin
          case "InQty": Recrw.InQty = qty[i];
          case "OutQty": Recrw.OutQty = qty[i];
        end;
        MatRowPut(Recr,ri,Recrw);
        vfound[Recrw.Item] = true;
      end;
    end;
  end;
  RemoveInvalidVarietyItemAfterPasting_RecVc(Recr,rwcnt);      
  currow = rwcnt;

  for (i=0;i<pos;i=i+1) begin
    if ((vfound[incode[i]]==false) and (nonblank(incode[i]))) then begin
      Recrw.Item = incode[i];
      switch (fieldname) begin
        case "InQty": Recrw.InQty = qty[i];
        case "OutQty": Recrw.OutQty = qty[i];
      end;
      if (ReadFirstItem(Recrw.Item,INr,true,true)) then begin
        Recrw.Comment = INr.Name;
      end;
      MatRowInsert(Recr,currow,Recrw);
      if (VBr.UseInfoFromRow==0) then begin
        RecVc_PasteItem(Recr,currow);
      end else begin
    //    RecDchrsum(Recr,currow);
    //    RecDchsum(Recr,currow);
      end;
      currow = currow + 1;
    end;
  end;  
  RecSumup(Recr);
  return;
end;

global
function Boolean MATVARINSClassOnOKWindowPaste(var string tstr,var string sepstr,var string msk,var string mskrep,var string varsubset,
                 var Array string maskvar2,var Array string maskvarsz2,var Array string maskvar,var Array string maskvarsz,
                 var Array string varsx,var Array string varsy)
begin
  Boolean res;
  
  res = false;
  if (FindItemVAR(tstr,sepstr,msk,mskrep,varsubset)) then begin
    FillMaskVAR(tstr,sepstr,msk,maskvar2,maskvarsz2);
    FillMaskVAR(tstr,sepstr,msk,maskvar,maskvarsz);//FillMaskVAR(tstr,sepstr,mskrep,maskvar,maskvarsz); //JJ?? why mskrep here and msk above
    FillOneItemOneVAR(tstr,"",varsubset,maskvar,varsx,1,true);
    FillOneItemOneVAR(tstr,"",varsubset,maskvar,varsy,2,true);
    res = true;
  end;
  MATVARINSClassOnOKWindowPaste = res;
  return;
end;

global
function string 255 UpWindDI_IN2SClass(string subset,Integer topm)
begin
  string 255 res;
  record MainStockBlock MSb;
  Array string 255 ac;
  string 255 tstr;
  record DIVc DIr;

  DIr.Code = subset;
  if (topm==1) then begin
    if (ReadFirstMain(DIr,1,true)) then begin
      SplitEclass(DIr.DispGroups,ac);
      res = ac[0];
    end;
  end;
  if ((blank(res)) or (topm==0)) then begin
    BlockLoad(MSb);
    res = MSb.StartClass;
  end;
  UpWindDI_IN2SClass = res;
  return;
end;

global
procedure IN2SClassOnOKWindowExecute(string subset,var Array string adi,var Integer acnt)
begin
  record DIVc DIr;
  Boolean found;
  string 255 ckey;
  string 255 tstr;

  found = true;
  ckey = "DICode:";
  ckey = ckey & subset; 
  while (LoopKey(ckey,DIr,1,found)) begin
    if (found) then begin
      tstr = DIr.Code;           
      tstr = tstr & "   ";
      if (nonblank(DIr.Name)) then begin
        tstr = DIr.Name;
      end else begin
        tstr = tstr & DIr.Name;
      end;
     adi[acnt] = tstr;
     acnt = acnt + 1;     
    end;
  end;
  return;
end;

global
function string 255 GetSelDI_IN2SClass(string startdi,LongInt Sel,var Array string adi,var Integer acnt)
begin
  string 255 res;
  string 255 ckey;
  string 255 t2;
  record DIVc DIr;
  Integer i;
  Boolean found;

  res = startdi;
  if (Sel<0) then begin
    goto LGetSelDI_IN2SClass;
  end;  
  ckey = "DICode:";
  ckey = ckey & startdi;
  found = true;
  while (LoopKey(ckey,DIr,1,found)) begin
    if (Sel==i) then begin
      res = DIr.Code;
      goto LGetSelDI_IN2SClass;
    end;
    i= i + 1;
  end;
LGetSelDI_IN2SClass:;
  if (nonblank(res)) then begin
    IN2SClassOnOKWindowExecute(res,adi,acnt);
  end;
  GetSelDI_IN2SClass = res;
  return;
end;

global
function string 255 UpWindDI_ActType2SClass(string subset,Integer topm)
begin
  string 255 res;

  res = "";
  UpWindDI_ActType2SClass = res;
  return;
end;

global
function string 255 GetSelDI_ActType2SClass(string startdi,LongInt Sel,string seltag)
begin
  string 255 res;
  string 255 ckey;
  string 255 t2;
  record ActTypeGrVc ATGr;
  Integer i;
  Boolean found;
  
  res = startdi;
  if (Sel<0) then begin
    goto LGetSelDI_ActType2SClass;
  end;
  found = true;
  
  ATGr.Code = seltag;
  if (ReadFirstKey("Code",ATGr,1,found)) begin
    if (seltag==ATGr.Code) then begin
      res = ATGr.Code;
      goto LGetSelDI_ActType2SClass;
    end;
  end;
  
LGetSelDI_ActType2SClass:;
  GetSelDI_ActType2SClass = res;
  return;
end;

global
procedure ActType2SClassOnOKWindowDo(string subset,Array string adi,Array string aci,var Integer acnt)
begin
  record ActTypeGrVc ATGr;
  Boolean found;
  string 255 tstr;
  
  found = true;
  while (LoopKey("Code",ATGr,1,found)) begin
    if (found) then begin
      tstr = ATGr.Code;
      if (nonblank(ATGr.Comment)) then begin
        tstr = tstr & "   ";
        tstr = ATGr.Comment;
      end;
      adi[acnt] = tstr;
      aci[acnt] = ATGr.Code;
      acnt = acnt + 1;
    end;
  end;
  return;
end;

global
function string 255 UpWindDI_Acc2SClass(string subset,Integer topm)
begin
  string 255 res;
  record CYBlock CYb;
  Array string 255 ac;
  string 255 tstr;
  record AccClassVc ACr;

  ACr.Code = subset;
  if (topm==1) then begin
    if (ReadFirstMain(ACr,1,true)) then begin
      SplitEclass(ACr.AccClasses,ac);
      res = ac[0];
    end;
  end;
  if ((blank(res)) or (topm==0)) then begin
    BlockLoad(CYb);
    res = CYb.AccClass;
  end;
  UpWindDI_Acc2SClass = res;
  return;
end;

global
procedure Acc2SClassOnOKWindowDo(string subset,var Array string adi,var Integer acnt)
begin
  record AccClassVc ACr;
  Boolean found;
  string 255 ckey;
  string 255 tstr;

  found = true;
  ckey = "ACCode:";
  ckey = ckey & subset; 
  while (LoopKey(ckey,ACr,1,found)) begin
    if (found) then begin
      tstr = ACr.Code;           
      tstr = tstr & "   ";
      if (nonblank(ACr.Comment)) then begin
        tstr = ACr.Comment;
      end else begin
        tstr = tstr & ACr.Comment;
      end;
     adi[acnt] = tstr;
     acnt = acnt + 1;     
    end;
  end;
  return;
end;

global
function string 255 GetSelDI_Acc2SClass(string startac,LongInt Sel,var Array string adi,var Integer acnt)
begin
  string 255 res;
  string 255 ckey;
  string 255 t2;
  record AccClassVc ACr;
  Integer i;
  Boolean found;

  res = startac;
  if (Sel<0) then begin
    goto LGetSelDI_Acc2SClass;
  end;  
  ckey = "ACCode:";
  ckey = ckey & startac;
  found = true;
  while (LoopKey(ckey,ACr,1,found)) begin
    if (Sel==i) then begin
      res = ACr.Code;
      goto LGetSelDI_Acc2SClass;
    end;
    i= i + 1;
  end;
LGetSelDI_Acc2SClass:;
  if (nonblank(res)) then begin
    Acc2SClassOnOKWindowDo(res,adi,acnt);
  end;
  GetSelDI_Acc2SClass = res;
  return;
end;

global
procedure Obj2SClassOnOKWindowDo(string subset,var Array string adi,var Integer acnt)
begin
  record OTVc OTr;
  Boolean found;
  string 255 ckey;
  string 255 tstr;

  found = true;
  OTr.Code = subset;
  while (LoopKey("Code",OTr,1,found)) begin
    if (nonblank(subset)) then begin
      if (OTr.Code!=subset) then begin
        found = false;
      end;
    end;
    if (found) then begin
      tstr = OTr.Code;           
      tstr = tstr & "   ";
      if (nonblank(OTr.Comment)) then begin
        tstr = OTr.Comment;
      end else begin
        tstr = tstr & OTr.Comment;
      end;
     adi[acnt] = tstr;
     acnt = acnt + 1;     
    end;
  end;
  return;
end;

global
function string 255 GetSelDI_Obj2SClass(string startot,LongInt Sel,var Array string adi,var Integer acnt)
begin
  string 255 res;
  string 255 t2;
  record OTVc OTr;
  Integer i;
  Boolean found;

  res = startot;
  if (Sel<0) then begin
    goto LGetSelDI_Obj2SClass;
  end;  
  found = true;
  OTr.Code = startot;
  while (LoopKey("Code",OTr,1,found)) begin
    if (Sel==i) then begin
      res = OTr.Code;
      goto LGetSelDI_Obj2SClass;
    end;
    i= i + 1;
  end;
LGetSelDI_Obj2SClass:;
  Obj2SClassOnOKWindowDo(res,adi,acnt);
  GetSelDI_Obj2SClass = res;
  return;
end;

global
function Boolean EBookkeepingEClassOnOKWindow(Integer wn)
begin
  boolean res;
  record RcVc RepSpec;
  
  res = true;
  GetWindowRecord(wn, RepSpec);
  if (GetDay(RepSpec.sStartDate)!=1) or (GetDay(RepSpec.sEndDate)!=DaysInMonth(GetYear(RepSpec.sEndDate),GetMonth(RepSpec.sEndDate))) or
     (GetMonth(RepSpec.sStartDate)!=GetMonth(RepSpec.sEndDate)) then begin
    MessageBox(1163,"");
    res = false;
  end;
  
  if ((RepSpec.flags[2]==1) and (RepSpec.ArtMode==1) and (Blank(RepSpec.d1))) then begin
    MessageBox(0,USetStr(33640));
    WindowFieldGoto(wn, RepSpec, -1, "d1", true);
    res = false;
  end;
  
  if (Blank(RepSpec.f1)) then begin
    MessageBox(0,USetStr(33641));
    WindowFieldGoto(wn, RepSpec, -1, "f1", true);
    res = false;
  end;

  EBookkeepingEClassOnOKWindow = res;
  return;
end;