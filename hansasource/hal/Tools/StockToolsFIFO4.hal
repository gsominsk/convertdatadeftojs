external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer FIFOPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer GetFIFOPerSerialNr(record INVc,record ITVc,record CostAccBlock);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Integer ArtCodeWAPerLocation(string);
external function val FindProdOperationsCost_FinalProduct(LongInt,LongInt,LongInt);
external function val FindProdOperationsFinishedCost_FinalProduct(LongInt,LongInt,LongInt,var val);
external function val QtyUsedBeforeFromSH(record ItemHistVc);
external function roundmode SetRoundModeD(Integer);
external function val ItemHist_ComponentItem_CostPrice(record CostAccBlock,string,LongInt,LongInt,string,val,string);
external updating procedure StoreItemHistory_In(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,string,record TempStockVc,Boolean);
external updating function Boolean RetStoreItemHist_In_InQue_Comp(record MainStockBlock,record CostAccBlock,record RetVc,row RetVc,Integer,row SHVc,Integer,string,record TempStockVc,Boolean);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function val FindCostPriceWA(Integer,record INVc,string);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function val FindCostPriceLIFO(Integer,record INVc,string,string,val,val,Boolean,Boolean,Boolean,Integer,Integer);
external function Boolean ConsigmentStock(string,string,Date);
external function Boolean TREOStock(string,string,Date);
external procedure PrintItemHistLine(record ItemHistVc,val);
external procedure GetCostsFromRecords(record ItemHistVc,var val,var val,Boolean,Date);
external function val GetStockQty(string,string,Date,Boolean);
external function Boolean TestArtCode(string,string,record INVc);
external function roundmode CostPriceDecimals();
external function val CalculateQty2(val,val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function Integer ItemCostPerLocation(record INVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function Integer ArtCodeCostPerLocation(string);
external updating procedure StoreItemHistory_In_RetGoods_InQue(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,LongInt,Boolean,record TempStockVc,Boolean);

// This returns the total WA price for all isqtyp, which is different from how CP and BP functions work...
global
function val FindWAPriceBackdated(Integer WAPerLocation,record INVc INr,string location,val isqtyp,Date todatp,Boolean curncytday,Integer repcalcwa)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found;
  Integer keys;
  string 255 ckey;
  val q;
  Boolean perlocf,testf;
  val instock,curwa;
  
  if (blankdate(todatp) or isqtyp<0) then begin
    res = isqtyp*INr.WeighedAvPrice;
  end else begin
    if (repcalcwa!=0) then begin
      instock = 0;
      if (WAPerLocation!=0) and nonblank(location) then begin
        ckey = "ArtCodeLocSN";
        keys = 3;
        IHr.Location = location;
        perlocf = true;
      end else begin
        ckey = "ArtCodeSN";
        keys = 2;
        perlocf = false;
      end;
      IHr.ArtCode = INr.Code;
      IHr.SerNr = -1;
      found = true;
      while (LoopKey(ckey,IHr,keys,found)) begin    
        if (found) then begin
          if (IHr.ArtCode!=INr.Code) then begin found = false; end;
        end; 
        if (perlocf) then begin
          if (IHr.Location!=location) then begin found = false; end;
        end;
        if (found) then begin
          testf = true;
          if (IHr.Invalid!=0) then begin testf = false; end;
          if (IHr.StockAffectf==0) begin testf = false; end;
          if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
          if (IHr.TransDate>todatp) begin testf = false; end;
          if (IHr.Qty==0) then begin testf = false; end;
          if (testf) then begin
            if (instock==0) then begin
              curwa = IHr.TotCostPrice / IHr.Qty;
              instock = IHr.Qty;
            end else begin
              if (IHr.Qty>0) then begin
                curwa = ((curwa * instock) + IHr.TotCostPrice) / (IHr.Qty + instock);
              end;
              instock = instock + IHr.Qty;
            end;
          end;
        end;
        res = curwa * isqtyp;
      end;
    end else begin
      if (WAPerLocation!=0) and nonblank(location) then begin
        ckey = "ArtCodeLoc";
        keys = 3;
        IHr.Location = location;
        perlocf = true;
      end else begin
        ckey = "ArtCode";
        keys = 2;
        perlocf = false;
      end;
      IHr.ArtCode = INr.Code;
      IHr.TransDate = todatp;
      found = true;
      while (LoopBackKey(ckey,IHr,keys,found)) begin    
        if (found) then begin
          if (IHr.ArtCode!=INr.Code) then begin found = false; end;
        end; 
        if (perlocf) then begin
          if (IHr.Location!=location) then begin found = false; end;
        end;
        if (found) then begin
          testf = true;
          if (IHr.Invalid!=0) then begin testf = false; end;
          if (IHr.StockAffectf==0) begin testf = false; end;
          if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
          if (IHr.Qty==0) then begin testf = false; end;
          if (testf) then begin
            q = IHr.Qty;
            if (q<0) then begin q = -q; end;
            if (perlocf) then begin
              res = (isqtyp*IHr.WATotCostPerLoc)/q;
            end else begin
              res = (isqtyp*IHr.WATotCost)/q;
            end;
            found = false;
          end;
        end;
      end;
    end;
  end;
  FindWAPriceBackdated = res;  
  RETURN;
END;

global
function val FindCostPriceLIFOBackDated(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,Boolean costfrrecf,Integer print,Boolean ondayratef,Integer OverwriteCostModel,Integer consigstock,Integer repcalcwa)
begin
  record ItemHistVc IHr;
  record ItemHistVc nextIHr;
  record ItemHistVc outIHr;
  record ItemHistVc printIHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,firstf,testf;
  val qcnt,res,instock,inprice;
  val remcostprice,totcostprice,t,usedqty,outqty,nextqty;
  record CostAccBlock CAb;
  LongInt looppos;
  
  res = 0;
  testf = false;
  if (blankdate(td)) or (td==CurrentDate) then begin
    testf = true;
  end;  
  switch (OverwriteCostModel) begin
    case 1:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
    case 2:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
  end;
  if (testf) then begin
    inprice = FindCostPriceLIFO(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,costfrrecf,print!=0,ondayratef,OverwriteCostModel,consigstock);
    goto LFindCostPriceLIFOBackDated;
  end;
  BlockLoad(CAb);
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  
/*if FIFO per location it is not that simple at all
*/
  
  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    keys = 2;
    instock = GetStockQty(INr.Code,"",td,false);
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
    instock = GetStockQty(INr.Code,location,td,false);
  end;
  
  RecordNew(nextIHr);
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + IHr.Qty;
        if (IHr.Qty<0) then begin 
          outqty = outqty - IHr.Qty;
        end;
        if (qcnt>=(instock-adjustqty)) then begin
          looppos = GetLoopPosition(IHr);
          RecordCopy(nextIHr,IHr);
          RecordCopy(printIHr,IHr);
          printIHr.RemQty = printIHr.Qty;
          switch (OverwriteCostModel) begin 
            case 3:
              printIHr.RemCostPrice = printIHr.TotCostPrice;
            otherwise
              printIHr.RemCostPrice = printIHr.TotCostPrice;
          end;
          foundf = false;
        end;
      end;
    end;
  end;

  outqty = 0;
  RecordCopy(outIHr,nextIHr);

  outIHr.ArtCode = INr.Code;
  outIHr.Location = location;
  outIHr.FIFODate = td;
  
  qcnt = 0;
// shuld be possible to move to loop above    
  foundf = true;
  while (LoopBackKey(thekey,outIHr,keys,foundf)) begin // Start from the nextIHr record and find all out things
    if (outIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (outIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (outIHr.StockAffectf==0) then begin testf = false; end;
      if (outIHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + outIHr.Qty;
        if (qcnt>=(instock-adjustqty)) then begin
          foundf = false;
        end;
        if (outIHr.Qty>0) then begin 
          if (CAb.RetFIFOQue!=0) then begin
            if (outIHr.FileName=="RetVc") then begin
            end else begin
              testf = false; 
            end;
          end else begin
            testf = false; 
          end;
        end;
      end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        outqty = outqty - outIHr.Qty;
      end;
    end;
  end;

  outqty = outqty + adjustqty;

  ResetLoop(nextIHr);

  nextIHr.ArtCode = INr.Code;
  nextIHr.Location = location;
//  SetLoopPosition(nextIHr,looppos-1);  

  inprice = 0;
  usedqty = 0;
  firstf = true;
  foundf = true;
  while (LoopBackKey(thekey,nextIHr,2,foundf)) begin // Start from the nextIHr record
    if (nextIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (nextIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (nextIHr.FIFODate>td) then begin
      foundf = false;
    end;
    if (usedqty>=qty) then begin
      foundf = false;
    end;
    if (foundf) then begin
      testf = true;
      if (nextIHr.StockAffectf==0) then begin testf = false; end;
      if (nextIHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (nextIHr.Invalid!=0) then begin testf = false; end;
      if (nextIHr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        nextqty = nextIHr.Qty - outqty;
        outqty = outqty - nextIHr.Qty;
        if (outqty<0) then begin
          outqty = 0;
        end;
        if (nextqty<0) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        if ((usedqty+nextqty)>qty) then begin
          nextqty = qty - usedqty;
        end else begin
          nextqty = nextqty; 
        end;
        usedqty = usedqty + nextqty;
        switch (consigstock) begin
          case 1: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)) then begin
//            if (nextIHr.ConsigStock!=0) then begin 
              testf = false;
            end;
          case 2: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)==false) then begin
//            if (nextIHr.ConsigStock==0) then begin 
              testf = false;
            end;
        end;
        if (testf) then begin
        
        switch (OverwriteCostModel) begin 
          case 3:
            if (FIFOPerLocation!=0) then begin
              t = nextIHr.WATotCostPerLoc/nextIHr.Qty;
            end else begin
              t = nextIHr.WATotCost/nextIHr.Qty;
            end;
            t = FindWAPriceBackdated(FIFOPerLocation,INr,nextIHr.Location,1,td,false,repcalcwa);
            if (nextIHr.FileName=="RetVc") then begin
              if (CAb.RetFIFOQue!=0) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextIHr.RemQty*t;
              end;
            end else begin
              remcostprice = nextIHr.RemQty*t;
            end;
            if (nextIHr.Qty>0) then begin
              totcostprice = nextIHr.Qty*t;
            end else begin
              totcostprice = nextIHr.Qty*t;
            end;
//StopAlert("totcostprice " & totcostprice & " nextIHr.SerNr " & nextIHr.SerNr);        
            
          case 2:
            remcostprice = nextIHr.BPTotCost;
            totcostprice = nextIHr.BPTotCost;
          case 1:
            if (INr.PriceFactor!=0) then begin
              remcostprice = nextIHr.CPTotCost / INr.PriceFactor;
              totcostprice = nextIHr.CPTotCost / INr.PriceFactor;
            end else begin
              remcostprice = nextIHr.CPTotCost;
              totcostprice = nextIHr.CPTotCost;
            end;
          otherwise
//            remcostprice = nextIHr.RemCostPrice;
            remcostprice = nextIHr.TotCostPrice;
            totcostprice = nextIHr.TotCostPrice;
        end;

        if (costfrrecf) or (ondayratef) then begin
          GetCostsFromRecords(nextIHr,remcostprice,totcostprice,ondayratef,td);
        end;
        if (print==2) then begin
          if (remcostprice!=0) and (nextqty!=0) then begin
            RecordCopy(printIHr,nextIHr);
            switch (OverwriteCostModel) begin 
              case 3:
                if (nextIHr.FileName=="RetVc") then begin
                  if (CAb.RetFIFOQue!=0) then begin
                    printIHr.RemQty = nextIHr.Qty;
                  end;
                end;
            end;
            printIHr.RemQty = nextqty;
            PrintItemHistLine(printIHr,nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals));
          end;          
        end;
        
        inprice = inprice + nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals);
        printIHr.RemQty = printIHr.RemQty + nextqty;
        end;
      end;
    end;
  end;
  if (print==1) then begin
    if (printIHr.TotCostPrice!=0) then begin
      PrintItemHistLine(printIHr,Round(printIHr.TotCostPrice,CostPriceDecimals));
    end;
  end;
LFindCostPriceLIFOBackDated:;  
  res = Round(inprice,CostPriceDecimals);
  FindCostPriceLIFOBackDated = res;
  return;
end;

global
function val CreditedInvoiceRowFIFORowVal_Queued(Integer InvType,Integer primary,Integer queuecostmodel,LongInt CreditedInv,LongInt CreditedRow,string artcode,var val remqty)
begin
  val res;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  Boolean testf,foundf;
  val sq,qty;

  switch (queuecostmodel) begin
    case 0:
      IHr.FileName = "IVVc";
      IHr.TransNr = CreditedInv;
      IHr.Row = CreditedRow;
      foundf = true;
      while (LoopKey("FNTransNr",IHr,3,foundf)) begin
        if (IHr.FileName!="IVVc") then begin foundf = false; end;
        if (IHr.TransNr!=CreditedInv) then begin foundf = false; end;
        if (IHr.Row!=CreditedRow) then begin foundf = false; end;
        if (remqty<=0) then begin foundf = false; end;
        testf = true;
        if (IHr.Invalid!=0) then begin testf = false; end;
        if (foundf and testf) then begin
          if (IHr.ArtCode==artcode) then begin
            switch (primary) begin
              case kCostModelWA:
                IHr.Qty = -IHr.Qty; IHr.RemQty = -IHr.RemQty;
                sq = IHr.Qty - IHr.RemQty;
                if (IHr.Qty>remqty) then begin          
                  qty = remqty;
                end else begin
                  qty = sq;
                end;
                if (ArtCodeWAPerLocation(IHr.ArtCode)) then begin
                   res = res + (IHr.WATotCostPerLoc/sq)*qty;
                end else begin
                   res = res + (IHr.WATotCost/sq)*qty;
                 end;
                remqty = remqty - qty;            
              otherwise
                sourceIHr.SerNr = IHr.Source;
                if (ReadFIrstMain(sourceIHr,1,true)) then begin
                  sq = sourceIHr.Qty - sourceIHr.RemQty;
                  if (sourceIHr.Qty>remqty) then begin          
                    qty = remqty;
                  end else begin
                    qty = sq;
                  end;
                  res = res + ((sourceIHr.TotCostPrice-sourceIHr.RemCostPrice)/sq)*qty;
                  remqty = remqty - qty;            
                end else begin
                  if (InvType==kInvoiceTypeCredit or InvType==kInvoiceTypeCreditSpecialSales) then begin
                    IHr.Qty = -IHr.Qty; IHr.RemQty = -IHr.RemQty;
                    sq = IHr.Qty - IHr.RemQty;
                    if (IHr.Qty>remqty) then begin          
                      qty = remqty;
                    end else begin
                      qty = sq;
                    end;
                    res = res + ((IHr.TotCostPrice-IHr.RemCostPrice)/sq)*qty;
                    remqty = remqty - qty;            
                  end;
                end;
            end;
          end;
        end;
      end;
    case 1:
      IHr.FileName = "IVVc";
      IHr.TransNr = CreditedInv;
      IHr.Row = CreditedRow;
      foundf = true;
      while (LoopBackKey("FNTransNr",IHr,3,foundf)) begin
        if (IHr.FileName!="IVVc") then begin foundf = false; end;
        if (IHr.TransNr!=CreditedInv) then begin foundf = false; end;
        if (IHr.Row!=CreditedRow) then begin foundf = false; end;
        if (remqty<=0) then begin foundf = false; end;
        testf = true;
        if (IHr.Invalid!=0) then begin testf = false; end;
        if (foundf and testf) then begin
          if (IHr.ArtCode==artcode) then begin
            switch (primary) begin
              case kCostModelWA:
                IHr.Qty = -IHr.Qty; IHr.RemQty = -IHr.RemQty;
                sq = IHr.Qty - IHr.RemQty;
                if (IHr.Qty>remqty) then begin          
                  qty = remqty;
                end else begin
                  qty = sq;
                end;
                 res = res + (IHr.WATotCost/sq)*qty;
                remqty = remqty - qty;            
              otherwise
                sourceIHr.SerNr = IHr.Source;
                if (ReadFIrstMain(sourceIHr,1,true)) then begin
                  sq = sourceIHr.Qty - sourceIHr.RemQty;
                  if (sourceIHr.Qty>remqty) then begin          
                    qty = remqty;
                  end else begin
                    qty = sq;
                  end;
                  res = res + ((sourceIHr.TotCostPrice-sourceIHr.RemCostPrice)/sq)*qty;
                  remqty = remqty - qty;            
                end else begin
                  if (InvType==kInvoiceTypeCredit or InvType==kInvoiceTypeCreditSpecialSales) then begin
                    IHr.Qty = -IHr.Qty; IHr.RemQty = -IHr.RemQty;
                    sq = IHr.Qty - IHr.RemQty;
                    if (IHr.Qty>remqty) then begin          
                      qty = remqty;
                    end else begin
                      qty = sq;
                    end;
                    res = res + ((IHr.TotCostPrice-IHr.RemCostPrice)/sq)*qty;
                    remqty = remqty - qty;            
                  end;
                end;
            end;
          end;
        end;
      end;
  end;
  CreditedInvoiceRowFIFORowVal_Queued = res;
  return;
end;

global
procedure GetItemCostPrc(record INVc INr,record CostAccBlock CAb,record ITVc ITr,Integer primary,var val costprc)
begin
  if (primary==2) then begin
    if (CAb.ItemGroupCostModel!=0) then begin
      costprc = ITr.CostPerc;
      if (nonblank(costprc)) then begin
        goto LGetItemCostPrc;
      end;
    end;
    costprc = INr.CostPerc;
    if (blank(costprc)) then begin
      costprc = CAb.CostPerc;
    end;
    if (blank(costprc)) then begin
      costprc = 100;
    end;
  end;
LGetItemCostPrc:;  
  return;
end;

global
updating procedure StoreItemHistory_In_WithSource(record MainStockBlock MSb,string artcode,string serialnr,string location,string filename,Date td,Date fifod,val qty,val coeff,val totalcost,val recordcost,LongInt transnr,Integer rownr,Integer stockaffectf,LongInt source,string position,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record INVc INr;
  val t;
  record ITVc ITr;
  record CostAccBlock CAb;
  Integer primary,queuecostmodel;
  Boolean setremqty;
  Date blankd;
  row TempStockVc TSrw;
  
  if (blank(artcode)) then begin 
    goto LStoreItemHistory_In_WithSource;
  end;
  BlockLoad(CAb);
  RecordNew(IHr);
  setremqty = true;
  IHr.ArtCode = artcode;
  IHr.Variety = "";
  IHr.StockAffectf = stockaffectf;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    if (artcode!=INr.Code) then begin
      IHr.Variety = right(artcode,len(artcode)-len(INr.Code));
      IHr.ArtCode = INr.Code;
    end;
    switch (INr.ItemType) begin
      case 0:
        switch (filename) begin
          case "SHVc": ;
          otherwise IHr.StockAffectf = 0;
        end;
        setremqty = false;
      case 1: ;
      case 2:
        if (nonblank(INr.Recepy)) then begin
          IHr.StockAffectf = 0;
        end;
      case 3:
        IHr.StockAffectf = 0;
    end;
  end;
  IHr.SerialNr = serialnr;
  IHr.Location = location;
  IHr.FileName = filename;
  IHr.TransDate = td;
  IHr.FIFODate = fifod;
  IHr.Qty = qty;
  IHr.Qty2 = CalculateQty2(IHr.Qty,coeff);
  IHr.TransNr = transnr;
  IHr.Row = rownr;
  if (setremqty) then begin
    IHr.RemQty = qty;
  end else begin
    IHr.RemQty = blankval;
  end;
  IHr.Source = source;
  if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.ConsigStock = 1;
  end;
  if (TREOStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.TREOStock = 1;
  end;
  if (recordcost!=0) then begin
    IHr.TotCostPrice = recordcost;
    IHr.RemCostPrice = recordcost;
  end else begin
    IHr.TotCostPrice = totalcost;
    IHr.RemCostPrice = totalcost;
  end;
  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin
  end;
  if (usetmpstkf) then begin
    FindTempStockRow(IHr.Row,IHr.ArtCode,true,TSr,TSrw);
    IHr.PrimaryCostModel = TSrw.PrimaryCostModel;
    IHr.QueuedCostModel = TSrw.QueuedCostModel;
    IHr.ItemType = TSrw.ItemType;
    IHr.FIFOPerSerialNr = TSrw.FIFOPerSerialNr;
    IHr.FIFOPerLocation = TSrw.FIFOPerLocation;
    IHr.NoNLCostOnShip = TSrw.NoNLCostOnShip;
    IHr.WAPerLocation = TSrw.WAPerLocation;
    IHr.WABase2 = TSrw.WABase2;
    IHr.UpdWeightAvFromRet = TSrw.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = TSrw.UpdWeightAvFromRetPU;
    IHr.StockAffectf = TSrw.StockAffectf;
  end else begin
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    IHr.PrimaryCostModel = primary;
    IHr.QueuedCostModel = queuecostmodel;
    IHr.ItemType = INr.ItemType;
    IHr.FIFOPerSerialNr = GetFIFOPerSerialNr(INr,ITr,CAb);
    IHr.FIFOPerLocation = FIFOPerLocation(INr,ITr,CAb);
    IHr.NoNLCostOnShip = CAb.NoNLCostOnShip;
    IHr.WAPerLocation = WAPerLocation(INr,ITr,CAb);
    IHr.WABase2 = CAb.WABase2;
    IHr.UpdWeightAvFromRet = CAb.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = CAb.UpdWeightAvFromRetPU;
  end;
  IHr.WATotCost = IHr.Qty*INr.WeighedAvPrice;
  IHr.WATotCostPerLoc = IHr.Qty*FindCostPriceWA(1,INr,location);

  IHr.CPTotCost = IHr.Qty*INr.InPrice;
//  IHr.CPTotCostPerLoc = IHr.Qty*;
  IHr.BPTotCost = IHr.Qty*FindCostPriceBasePrice(CAb,INr,ITr);
//  IHr.BPTotCostPerLoc = IHr.Qty*;
  IHr.Position = position;
/*  
  switch (primary) begin
    case 1:
      if (recordcost!=0) then begin
        IHr.CPTotCost = recordcost;
      end else begin
        IHr.CPTotCost = totalcost;
      end;
//      IHr.CPTotCostPerLoc = totalcost;
    case 2:
      if (recordcost!=0) then begin
        IHr.BPTotCost = recordcost;
      end else begin
        IHr.BPTotCost = totalcost;
      end;
//      IHr.BPTotCostPerLoc = totalcost;
    case 3:
      if (recordcost!=0) then begin
        IHr.WATotCost = recordcost;
        IHr.WATotCostPerLoc = recordcost;
      end else begin
        IHr.WATotCost = totalcost;
        IHr.WATotCostPerLoc = totalcost;
      end;
  end;
*/
  IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");
  if (RecordStore(IHr,false)) then begin end;
LStoreItemHistory_In_WithSource:;
  return;
end;

updating function Boolean RetStoreItemHist_In_InQue(Integer primary,record MainStockBlock MSb,record CostAccBlock CAb,record RetVc Retp,row RetVc Retrw,Integer rownr,Integer updatestockf,
                                             string location,record TempStockVc TSr,Boolean usetmpstkf)
begin
  Boolean res;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ItemHistVc oldsourceIHr;
  Boolean foundf;
  Date fifod;
  val cost;
  val qty,remqty,usedqty,tmpqty;

  if (CAb.RetCostPriceFromSH==0) and (CAb.RetFIFOQue==0) then begin
//store with values entered in returned goods
    goto LRetStoreItemHist_In_InQue;
  end;
  remqty = Retrw.Quant;
  foundf = true;
  IHr.FileName = "SHVc";
  IHr.TransNr = Retp.SHNr;
  IHr.Row = Retrw.SHRow;
  while (LoopKey("FNTransNr",IHr,3,foundf)) begin
    if (IHr.FileName!="SHVc") then begin foundf = false; end;
    if (IHr.TransNr!=Retp.SHNr) then begin foundf = false; end;
    if (IHr.Row!=Retrw.SHRow) then begin foundf = false; end;
    if (remqty<=0) then begin foundf = false; end;
    if (foundf) then begin
      usedqty = QtyUsedBeforeFromSH(IHr);
      if (IHr.Source>0) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
//          tmpqty = sourceIHr.Qty - usedqty;
          tmpqty = -IHr.Qty;
          if (tmpqty<0) then begin tmpqty = 0; end;

          if (remqty>tmpqty) then begin
            qty = tmpqty;
          end else begin
            qty = remqty;
          end;
          if (qty!=0) then begin
            fifod = sourceIHr.FIFODate;                
            switch (primary) begin
/*
              case kCostModelWA:
                if (remqty>(-IHr.Qty)) then begin
                  qty = -IHr.Qty;
                end else begin
                  qty = remqty;
                end;
                cost = -(IHr.WATotCost/IHr.Qty)*qty;
*/
              otherwise
                cost = (sourceIHr.TotCostPrice/sourceIHr.Qty)*qty;
            end;
            if (ArtCodeCostPerLocation(Retrw.ArtCode)!=0) then begin
              if (location!=sourceIHr.Location) then begin
                fifod = Retp.TransDate;
                StoreItemHistory_In_WithSource(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,fifod,qty,Retrw.Coefficient,cost,blankval,Retp.SerNr,rownr,updatestockf,IHr.Source,Retrw.PosCode,TSr,usetmpstkf);
                StepForward(IHr,1);
              end else begin
                if (CAb.RetFIFOQue!=0) then begin
/*         
because of pricing we cannot put GR back with remqty + retgr qty
        
                  RecordCopy(oldsourceIHr,sourceIHr);                
                  sourceIHr.RemQty = sourceIHr.RemQty + qty;
                  sourceIHr.RemCostPrice = sourceIHr.RemCostPrice + cost;
                  if (RecordUpdate(oldsourceIHr,sourceIHr,false)) then begin end;
*/                  
                  StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,sourceIHr.FIFODate,qty,Retrw.Coefficient,qty*Retrw.UPrice,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end else begin
                  if (CAb.RetCostPriceFromSH==0) then begin 
                    StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,qty,Retrw.Coefficient,cost,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                  end else begin
                    StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,qty,Retrw.Coefficient,qty*Retrw.UPrice,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                  end;
                end;
                StepForward(IHr,1);
              end;
            end else begin
              if (CAb.RetFIFOQue!=0) then begin 
/*         
becasuse of pricing we cannot put GR back with remqty + retgr qty
                RecordCopy(oldsourceIHr,sourceIHr);
                sourceIHr.RemQty = sourceIHr.RemQty + qty;
                sourceIHr.RemCostPrice = sourceIHr.RemCostPrice + cost;
                if (RecordUpdate(oldsourceIHr,sourceIHr,false)) then begin end;
*/                
                if (CAb.RetCostPriceFromSH==0) then begin 
                  StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,sourceIHr.FIFODate,qty,Retrw.Coefficient,qty*Retrw.UPrice,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end else begin
                  StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,sourceIHr.FIFODate,qty,Retrw.Coefficient,cost,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end;
              end else begin
                if (CAb.RetCostPriceFromSH==0) then begin 
                  StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,qty,Retrw.Coefficient,cost,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end else begin
                  StoreItemHistory_In_RetGoods_InQue(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,qty,Retrw.Coefficient,qty*Retrw.UPrice,Retp.SerNr,rownr,updatestockf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end;
              end;
              StepForward(IHr,1);
            end;
            remqty = remqty - qty;
            res = true;
          end;
        end;
      end;
    end;
  end;
LRetStoreItemHist_In_InQue:;
  RetStoreItemHist_In_InQue = res; 
  return;
end;

global
updating procedure RetStoreItemHistory_In(record INVc INr,record MainStockBlock MSb,record CostAccBlock CAb,record RetVc Retp,row RetVc Retrw,Integer rownr,Integer stockaffectf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  Boolean isstruct;
  string 255 location;
  val cost;
  record SHVc RecSHr;
  row SHVc RecSHrw;
  Integer j,shrwcnt;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  val sum;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty;

  BlockLoad(SNrb);
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
  location = Retrw.Location;
  if (blank(location)) then begin
    location = Retp.Location;
  end;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  isstruct = ExpandStructItem(Retrw.ArtCode,Retrw.Recepy,Retrw.Quant,RecSHr);
  switch (CAb.RetFIFOQue) begin
    case 0: 
      if (isstruct==false) then begin
        if (RetStoreItemHist_In_InQue(primary,MSb,CAb,Retp,Retrw,rownr,stockaffectf,location,TSr,usetmpstkf)==false) then begin
          if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
            qty = blankval;
            serialnr = FirstInRange(Retrw.SerialNr,60);
            while (nonblank(serialnr)) begin
              StoreItemHistory_In(MSb,Retrw.ArtCode,serialnr,location,"RetVc",Retp.TransDate,Retp.TransDate,1.00,Retrw.Coefficient,Retrw.UPrice,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);
              qty = qty + 1;
              serialnr = NextSerialNumber(Retrw.ArtCode,serialnr,SNrb);
              if (qty>=Retrw.Quant) then begin serialnr = ""; end;
            end;
          end else begin          
            StoreItemHistory_In(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,Retrw.Quant,Retrw.Coefficient,Retrw.Quant*Retrw.UPrice,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);
          end;
        end;
      end else begin
        shrwcnt = MatRowCnt(RecSHr);
        for (j=0;j<shrwcnt;j=j+1) begin
          MatRowGet(RecSHr,j,RecSHrw);
          if (RetStoreItemHist_In_InQue_Comp(MSb,CAb,Retp,Retrw,rownr,RecSHrw,stockaffectf,location,TSr,usetmpstkf)==false) then begin
            cost = ItemHist_ComponentItem_CostPrice(CAb,"SHVc",Retp.SHNr,Retrw.SHRow,RecSHrw.ArtCode,RecSHrw.Ship,location);
            StoreItemHistory_In(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,RecSHrw.Ship,RecSHrw.Coefficient,RecSHrw.Ship*cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);//RecSHrw.Ship*Retrw.UPrice
          end;
        end;
      end;
    case 1:
      if (Retp.SHNr<=0) then begin
        if (isstruct==false) then begin
          if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
            qty = blankval;
            serialnr = FirstInRange(Retrw.SerialNr,60);
            while (nonblank(serialnr)) begin
              StoreItemHistory_In(MSb,Retrw.ArtCode,serialnr,location,"RetVc",Retp.TransDate,Retp.TransDate,1.00,Retrw.Coefficient,Retrw.UPrice,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);
              qty = qty + 1;
              serialnr = NextSerialNumber(Retrw.ArtCode,serialnr,SNrb);
              if (qty>=Retrw.Quant) then begin serialnr = ""; end;
            end;
          end else begin
            StoreItemHistory_In(MSb,Retrw.ArtCode,Retrw.SerialNr,location,"RetVc",Retp.TransDate,Retp.TransDate,Retrw.Quant,Retrw.Coefficient,Retrw.Quant*Retrw.UPrice,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);
          end;
        end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,RecSHrw);
            cost = ItemHist_ComponentItem_CostPrice(CAb,"SHVc",Retp.SHNr,Retrw.SHRow,RecSHrw.ArtCode,RecSHrw.Ship,location);
            StoreItemHistory_In(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,RecSHrw.Ship,RecSHrw.Coefficient,RecSHrw.Ship*cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,"",TSr,usetmpstkf);//RecSHrw.Ship*Retrw.UPrice
          end;
        end;
      end else begin
        if (isstruct==false) then begin
          RetStoreItemHist_In_InQue(primary,MSb,CAb,Retp,Retrw,rownr,stockaffectf,location,TSr,usetmpstkf);        
        end else begin
          shrwcnt = MatRowCnt(RecSHr);
          for (j=0;j<shrwcnt;j=j+1) begin
            MatRowGet(RecSHr,j,RecSHrw);
            RetStoreItemHist_In_InQue_Comp(MSb,CAb,Retp,Retrw,rownr,RecSHrw,stockaffectf,location,TSr,usetmpstkf);        
          end;
        end;
      end;
  end;
  RETURN;
END;

// StoreItemHistory_Out (and it's local functions) moved to StockToolsFIFO3.hal

global
function val DisassembledProdFIFORowVal_fromSource(record INVc INr,record ProdVc orgProdr,record ProdVc Prodp,row ProdVc Prodrw)
begin
  val res;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  Boolean found,testf;
  val qty,remqty,sq,instock;  
  row ProdVc orgProdrw;

  if (Prodrw.OrgProdRow>=0) then begin    
    switch (INr.ItemType) begin
      case 1:
        if (Prodrw.InQty!=0) then begin
          remqty = Prodrw.InQty;
        end else begin
          remqty = Prodrw.OutQty;
        end;
        IHr.FileName = "ProdVc";
        IHr.TransNr = Prodp.OrgProdNr;
        IHr.Row = Prodrw.OrgProdRow;
        found = true;
        while (LoopBackKey("FNTransNr",IHr,3,found)) begin
          if (IHr.FileName!="ProdVc") then begin found = false; end;
          if (IHr.TransNr!=Prodp.OrgProdNr) then begin found = false; end;
          if (IHr.Row!=Prodrw.OrgProdRow) then begin found = false; end;
          if (remqty<=0) then begin found = false; end;
          testf = true;
          if (IHr.Invalid!=0) then begin testf = false; end;
          if (found and testf) then begin
            if (IHr.ArtCode==Prodrw.Item) then begin
              if (Prodrw.OutQty!=0) then begin
                sq = -IHr.Qty;
                if (sq>remqty) then begin          
                  qty = remqty;
                end else begin
                  qty = sq;
                end;
                res = res + (IHr.TotCostPrice*qty)/sq;
                remqty = remqty - qty;            
              end;
              if (Prodrw.InQty!=0) then begin
                sq = IHr.Qty;
                if (sq>remqty) then begin          
                  qty = remqty;
                end else begin
                  qty = sq;
                end;
                res = res + (IHr.TotCostPrice*qty)/sq;
                remqty = remqty - qty;            
              end;
            end;
          end;
        end;  
      otherwise
        if (Prodrw.OrgProdRow<MatRowCnt(orgProdr)) then begin
          MatRowGet(orgProdr,Prodrw.OrgProdRow,orgProdrw);
          res = (Prodrw.OutQty*(orgProdrw.ItemCost*orgProdrw.InQty))/orgProdrw.InQty;
        end;
    end;  
   end;    
  DisassembledProdFIFORowVal_fromSource = res;
  return;
end;

global
function val DisassembledProdFIFORowVal(record INVc INr,record ProdVc orgProdr,record ProdVc Prodp,row ProdVc Prodrw)
begin
  val res;
  row ProdVc orgProdrw;
  
  if (Prodrw.OrgProdRow>=0) then begin
    if (Prodrw.OrgProdRow<MatRowCnt(orgProdr)) then begin
      MatRowGet(orgProdr,Prodrw.OrgProdRow,orgProdrw);
      res = (Prodrw.OutQty*orgProdrw.FIFORowVal)/orgProdrw.InQty;
    end;
  end;
  DisassembledProdFIFORowVal = res;
  return;
end;

global
function Boolean ProdOperationForFinalProduct(record ProdOperationVc ProdOpr)
begin
  Boolean res;
  record ProdOperationVc lastProdOpr;
  
  lastProdOpr.ProdNr = ProdOpr.ProdNr;
  lastProdOpr.Sequence = 1000000;
  if (ReadLastKey("ProdNrSeq",lastProdOpr,2,false)) then begin end;
  if (lastProdOpr.Sequence==ProdOpr.Sequence) then begin
    res = true;
  end;
  ProdOperationForFinalProduct = res;
  return;
end;

global
procedure ProdOperationFillFIFO(record ProdOperationVc ProdOpr,Boolean overwriteval)
BEGIN
  record INVc INr;
  row ProdOperationVc ProdOprw;
  row ProdOperationVc ProdOp2rw;
  Integer i,j,rwcnt,outrows;
  val qty,valv,extra,value,value2,outqty,finqty;
  val totrelprices,fifoshare,totfifo,actqty,t2;
  Integer stockf;
  record ProdSettingsBlock PSb;
  val adjstockv,q;
  Boolean finalproductf;
  record ProdVc Prodr;
  
  Prodr.SerNr = ProdOpr.ProdNr;
  if (ReadFirstMain(Prodr,1,true)) then begin
  end;
  finalproductf = ProdOperationForFinalProduct(ProdOpr);

  outrows = 0;
  i = -1;
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (ProdOprw.OutQty!=0) then begin
      outrows = outrows + 1;
      t2 = ProdOprw.OutQty*ProdOprw.RelVal;      
      totrelprices = totrelprices + t2;     
    end;
  end;
  BlockLoad(PSb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    stockf = 0;
    if (ReadFirstItem(ProdOprw.Item,INr,true,true)) then begin
      stockf = INr.ItemType;
    end;
// This shouldn't be done on nonstocked items 
//   Allow service and plain
    switch (ProdOpr.RowsHoldActualQty) begin
      case 1: qty = ProdOprw.InQty;
      otherwise qty = ProdOprw.InQty*ProdOpr.Qty;
    end;          

    if (stockf<2) then begin
      if (ProdOprw.InQty!=0) then begin
        switch (stockf) begin
          case 1:
            adjstockv = 0;
            for (j=0;j<i;j=j+1) begin  
              MatRowGet(ProdOpr,j,ProdOp2rw);
              if (ProdOprw.Item==ProdOp2rw.Item) and (ProdOp2rw.InQty!=0)then begin                
                switch (ProdOpr.RowsHoldActualQty) begin
                  case 1: adjstockv = adjstockv + ProdOp2rw.InQty;
                  otherwise adjstockv = adjstockv + ProdOpr.Qty*ProdOp2rw.InQty;
                end;          
              end;
            end;
            switch (ProdOpr.RowsHoldActualQty) begin
              case 1: q = ProdOprw.InQty;
              otherwise q = ProdOpr.Qty*ProdOprw.InQty;
            end;                      
            ProdOprw.FIFORowVal = FindCostPrice(ProdOprw.Item,ProdOpr.Location,ProdOprw.SerialNr,q,adjstockv,false);
            ProdOprw.ItemCost = ProdOprw.FIFORowVal;
          otherwise
            if (ProdOprw.Item!=PSb.MachineCostItem) then begin
              ProdOprw.ItemCost = qty*INr.InPrice;
              ProdOprw.FIFORowVal = ProdOprw.ItemCost;
            end;
        end;
        totfifo = totfifo + ProdOprw.ItemCost;
        valv = valv + ProdOprw.ItemCost;        
        switch (ProdOpr.RowsHoldActualQty) begin
          case 1: ;
          otherwise valv = valv/ProdOpr.Qty;
        end;                      
        ProdOprw.ItemCost = ProdOprw.ItemCost/qty;
        ProdOprw.FIFORowVal = Round(ProdOprw.FIFORowVal,SetRoundModeD(5));
        MatRowPut(ProdOpr,i,ProdOprw);
      end;
      if (finalproductf) then begin
        if (ProdOprw.OutQty!=0) then begin
          switch (ProdOpr.RowsHoldActualQty) begin
            case 1: outqty = ProdOprw.OutQty;
            otherwise outqty = ProdOprw.OutQty*ProdOpr.Qty;
          end;
        end;
      end;
    end else begin
      ProdOprw.FIFORowVal = FindCostPrice(ProdOprw.Item,ProdOpr.Location,ProdOprw.SerialNr,qty,blankval,false);      
      if (PSb.FixedTime!=0) then begin
        if (ProdOprw.FIFORowVal==0) then begin
          ProdOprw.FIFORowVal = qty*PSb.WorkCostPerHour;
        end;
      end else begin
        if (ProdOprw.FIFORowVal==0) then begin
          ProdOprw.FIFORowVal = qty*ProdOprw.ItemCost;
        end;
      end;
      ProdOprw.ItemCost = ProdOprw.FIFORowVal/qty;
      MatRowPut(ProdOpr,i,ProdOprw);
      totfifo = totfifo + (ProdOprw.ItemCost*qty);
    end;
  end;
  totfifo = totfifo + extra;
  if (outrows>0) then begin
    if (finalproductf) then begin
      value = FindProdOperationsCost_FinalProduct(ProdOpr.ProdNr,ProdOpr.Sequence-1,ProdOpr.SerNr);
      value2 = FindProdOperationsFinishedCost_FinalProduct(ProdOpr.ProdNr,ProdOpr.Sequence,ProdOpr.SerNr,finqty);

      totfifo = totfifo + (((value - value2)/(Prodr.Qty-finqty))*ProdOpr.ActualQty);

//      totfifo = totfifo + (((value - value2)/(Prodr.Qty-finqty))*ProdOpr);
//      totfifo = totfifo + (value - value2);
//StopAlert("totfifo " & totfifo & " value " & value & " value2 " & value2 & " finqty " & finqty & " Prodr.Qty " & Prodr.Qty);  
    end;
//StopAlert(" value2 " & value2 & " Prodr.Qty " & Prodr.Qty & " finqty " & finqty & " value " & value);    
//StopAlert("finalproductf " & finalproductf & " totfifo " & totfifo & " value " & value & " value2 " & value2 & " outqty " & outqty );    
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ProdOpr,i,ProdOprw);
      if (ProdOprw.OutQty!=0) then begin
        t2 = ProdOprw.OutQty*ProdOprw.RelVal;   
        if (t2!=0) then begin   
          fifoshare = t2/totrelprices;
          t2 = fifoshare*totfifo;
        end else begin
          if (totrelprices!=0) then begin
            ProdOprw.ItemCost = 0;
            MatRowPut(ProdOpr,i,ProdOprw);
            goto L66ProdOperationFillFIFO;
          end else begin
            t2 = totfifo;
          end;
        end;          
        switch (ProdOpr.RowsHoldActualQty) begin
          case 1: actqty = ProdOprw.OutQty;
          otherwise actqty = ProdOprw.OutQty*ProdOpr.Qty;
        end;              
        ProdOprw.FIFORowVal = Round(t2,SetRoundModeD(5));
        ProdOprw.ItemCost = ProdOprw.FIFORowVal/actqty;
        MatRowPut(ProdOpr,i,ProdOprw);
      end;
 L66ProdOperationFillFIFO:;  
    end;
  end;
  return;
end;
