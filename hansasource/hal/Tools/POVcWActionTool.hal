external function Integer POApprovalStatus(record POVc,var record AcceptanceRulesVc);
external function Boolean HasApprovals();
external procedure GetItemSalesAcc(string,Integer,var string);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external function string 255 FillupTaxMatrix(Integer,string,string,string,string,string,var record TaxMatrixVc);
external procedure GetItemTaxTemplateCode(string,Integer,var string,Boolean);
external function Boolean UseTaxTemplatesforTaxCalc();
external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external function val CalculateTotalVATFromTaxMatrix(record TaxMatrixVc,Integer);
external procedure RowCalculateTaxMatrix_PUVc(var record PUVc,Integer,row PUVc,Integer);
external procedure RowCalculateTaxMatrix_VIVc(var record VIVc,Integer,row VIVc,Integer);
external procedure DropSHSumUp(var record DropSHVc);
external procedure VIDDefault(Integer,string,var record VIVc);
external function roundmode SetRoundModeD(Integer);
external function roundmode DefaultRoundMode();
external procedure MulM4ProcVal(val,val,var val);
external procedure PUAddFreightRow(record PUVc,record VIVc,record AccBlock,record APAccBlock,record BaseCurBlock,var Integer);
external function val FindVAT(string,val,Integer,Integer);
external function Integer VIRowExists(record CYBlock,record VIVc,string,string,string,val,val);
external function Boolean PUQtyInvoiced(LongInt,LongInt,LongInt,var val);
external procedure VICalcVals(var record VIVc);
external function val CalcPalletsNr(val,string);
external procedure POGetRate(var record POVc);
external function Boolean PODchrsum(record POVc,Integer);
external function Integer VATType(string);
external function string 255 POSerialNrFromPU(LongInt,Integer);
external procedure BuildReservationArray(LongInt,string,var array val,var array string,var Integer);
external function string 255 FindINObjects(string,string);
external procedure AddExtraCostRow(record AccBlock,record BaseCurBlock,record VIVc,string,val,Integer,Integer,Integer,string,var record SMVc,Integer);
external procedure GetPIPurchseCost(string,string,string,var val);
external procedure FindPUStockAcc(string,record CostAccBlock,string,string,string,record INVc,Integer,var string,var string,Boolean);
external function Boolean PUVc_PasteArtCode(var record PUVc,Integer,var string,var string);
external function string 20 FindFreePositionInLocArea_ExcludePositionFromArray(string,string,val,record INVc,Integer,Array string,Integer);
external procedure CalculatePURowSum(val,val,string,var val,val,
                                     val,val,val,val,val,
                                     string,var val,Boolean,string,
                                     val,val,val,val,val);
external function Boolean IsQtyAllowed_QtyonPallet(val,string);
external function Boolean GetFirstItem(var string,var record INVc);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure DivPIFactor(val,val,var val);
external function Boolean FindItemVAR2(string,var string,var string,var string);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure VICalcEReb(var record VIVc);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external procedure RoundVATSum(string,string,string,var val);
external procedure VISumup(record VIVc,var val);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure GetITPurchAcc(string,var string,Integer);
external function Boolean GetAccName(string,var string,Integer);
external procedure GetAPAcc(string,var string);
external procedure SetupVATBase(var record SMVc,var Integer);
external function LongInt GetCurUserLastNr(string);
external function Boolean CorrectItemVAR(string,var string,var string,Boolean);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external procedure CalcSum2(val,val,val,val,var val,Integer);
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                                   val,val,val,val,val,
                                   val,val,val,val,val,val,
                                   string,var val,val,var val,string,Integer);
external procedure CalcExtra(val,string,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure PUSumUp(var record PUVc);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure POSumup(var record POVc );
external function Boolean VIVc_PasteVECode(var record VIVc,Integer,Boolean,Boolean,var string);

procedure CreateNewPUFromPO(record PUVc PUp,record POVc POp,LongInt ponr)
BEGIN
  record SRBlock SRRec;
  LongInt newnr;
  val fr,to1,to2,br1,br2;

  RecordNew(PUp);
  PUp.PONr = ponr;
  if (PUp.SerNr==-1) then begin
    BlockLoad(SRRec);
    newnr = GetCurUserLastNr("PUVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastPurNr;      
    end;    
    PUp.SerNr = NextSerNr("PUVc",PUp.TransDate,newnr,false,"");
  end;
  PUp.PUClass = POp.POClass;
  PUp.VECode = POp.VECode;
  PUp.VEName = POp.Addr0;
  PUp.CurncyCode = POp.CurncyCode;
  PUp.Location = POp.Location;
  PUp.Comment = POp.Comment;
  if ((POp.BaseRate1!=0) and (POp.BaseRate2!=0)) then begin
    PUp.FrRate = POp.FrRate;
    PUp.ToRateB1 = POp.ToRateB1;
    PUp.ToRateB2 = POp.ToRateB2;
    PUp.BaseRate1 = POp.BaseRate1;
    PUp.BaseRate2 = POp.BaseRate2;
  end else begin
    GetFullCurncyRate(PUp.CurncyCode,PUp.TransDate,fr,to1,to2,br1,br2);
    PUp.FrRate = fr;
    PUp.ToRateB1 = to1; 
    PUp.ToRateB2 = to2;
    PUp.BaseRate1 = br1;
    PUp.BaseRate2 = br2;
  end;
  PUp.InclVAT = 0;
  RETURN;
END;

procedure AddToSkiposArray(string poscode,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i;
  
  if (blank(poscode)) then begin goto LAddToSkiposArray; end;
  for (i=0;i<acnt;i=i+1) begin
    if (askippos[i]==poscode) then begin
      goto LAddToSkiposArray;
    end;
  end;
  askippos[acnt] = poscode; 
  acnt = acnt + 1;
LAddToSkiposArray:;  
  RETURN;
END;

procedure PrepareSkiposArray(record PUVc PUr,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt-1;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    AddToSkiposArray(PUrw.PosCode,askippos,acnt);
    AddToSkiposArray(PUrw.ToPosCode,askippos,acnt);
  end;
  RETURN;
END;

updating function Integer PUFromPO_PasteQuant(var record PUVc PUr,LongInt pordnr,Integer rownr,Integer maxrownr,record POVc POp)
BEGIN
  Integer res,i;
  row PUVc PUrw,orgPUrw;
  row PUVc palletPUrw;
  val p,s;
  Boolean chsum,testf;
  record MainStockBlock MSb;
  record INVc INr;
  val orgquant;
  string 255 tstr,tstr2;
  Integer lrownr;
  Array string 20 askippos;
  Integer acnt;
  record LocationVc LocRec;
  val defposhight;
  array val aqty;
  array string 20 aloc;
  Integer arescnt;
  Integer apos;
  
  LocRec.Code = PUr.Location;
  if (blank(LocRec.Code)) then begin 
    BlockLoad(MSb);
    LocRec.Code = MSb.MainStock;
  end;
  if (ReadFirstMain(LocRec,1,true)) then begin end;  
  res = 0;    
  lrownr = rownr;
  MatRowGet(PUr,lrownr,PUrw);
  CopyRow(PUr,PUrw,orgPUrw);
  orgquant = orgPUrw.Quant;
  BuildReservationArray(pordnr,PUrw.ArtCode,aqty,aloc,arescnt);
  apos = 0;
LPUFromPO_PasteQuantAGAIN:;  
  if (apos<arescnt) then begin
    if (aqty[apos]<PUrw.Quant) then begin
      PUrw.Quant =  aqty[apos];
    end;
    PUrw.Location =  aloc[apos];
  end;
  if (LocRec.RequirePos!=0) then begin    
    PrepareSkiposArray(PUr,askippos,acnt);
    if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
      if (nonblank(INr.DefPalletItem)) then begin
        if (INr.QtyonPallet>0) then begin
          if (PUrw.Quant>INr.QtyonPallet) then begin
            PUrw.Quant = INr.QtyonPallet;
          end;
        end;
      end;
    end;
  end;
  
  CalculatePURowSum(PUrw.Quant,PUrw.UPrice,PUrw.Extra,PUrw.CostPrice,PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,false,PUr.CurncyCode,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2);

  PUrw.Sum = p;
  chsum = true;
  if (LocRec.RequirePos!=0) then begin    
    if (blank(PUrw.PosCode)) then begin PUrw.PosCode = LocRec.WHMDefPUPosCode; end;
    if (blank(PUrw.ToPosCode)) then begin
      defposhight = INr.DefPosHeight;
      if (defposhight==0) then begin
        defposhight = INr.PalletHeight + 3; 
      end;
      PUrw.ToPosCode = FindFreePositionInLocArea_ExcludePositionFromArray(LocRec.Code,INr.LocArea,defposhight,INr,LocRec.WHMHighestPosCodeFirst,askippos,acnt);
    end;
  end;

  MatRowPut(PUr,lrownr,PUrw);    
  if ((LocRec.RequirePos!=0) or (apos<arescnt)) then begin
    if (nonblank(INr.DefPalletItem)) then begin
      lrownr = lrownr + 1;
      ClearRow(PUr,palletPUrw,1);
      palletPUrw.PosCode = PUrw.PosCode;
      palletPUrw.ToPosCode = PUrw.ToPosCode;
      palletPUrw.ArtCode = INr.DefPalletItem;
      palletPUrw.Quant = 1;
      palletPUrw.MotherPURow = lrownr;
      MatRowInsert(PUr,lrownr,palletPUrw); 
      testf = PUVc_PasteArtCode(PUr,lrownr,tstr,tstr2);       
    end;
    lrownr = lrownr + 1;
    if (maxrownr>0) then begin
      if (lrownr>=maxrownr) and (POp.SerNr!=-2) then begin
        PUSumUp(PUr);
        if (RecordStore(PUr,false)) then begin end;
        CreateRecordLink(PUr,CurrentCompany,POp,CurrentCompany);
        CreateRecordLink(POp,CurrentCompany,PUr,CurrentCompany);
        CreateNewPUFromPO(PUr,POp,POp.SerNr);
        lrownr = 0;
      end;
    end;
    orgquant = orgquant - PUrw.Quant;
    apos = apos + 1; // Hmmm. Will not work with RequirePos functions...
    if (orgquant>0) then begin
      CopyRow(PUr,orgPUrw,PUrw);
      PUrw.Quant = orgquant;
      goto LPUFromPO_PasteQuantAGAIN;
    end;
  end;
  
LPUFromPO_PasteQuant:; 
  PUSumUp(PUr);
  PUFromPO_PasteQuant = res;
  RETURN;
END;

global
function Boolean GetOPPrepaymentRate(string curncy,LongInt ordernr,var val fr,var val to1,var val to2,var val br1,var val br2)
begin
  Boolean res;
  record OPPVc OPPr;
  Boolean found;
  record OPVc OPr;
  row OPVc OPrw;
  Integer i,rwcnt;
  record APPayHistVc APPayHistr;
  
  found = true;
  OPPr.OrderNr = ordernr;
  while (LoopKey("OrderNr",OPPr,1,found)) begin
    if (OPPr.OrderNr!=ordernr) then begin found = false; end;
    if (found) then begin
      APPayHistr.VEPNr = OPPr.SerNr;
      APPayHistr.FileName = "OPVc";
      if (ReadFirstMain(APPayHistr,2,true)) then begin
        OPr.SerNr = APPayHistr.SerNr;
        if (ReadFirstMain(OPr,1,true)) then begin
          rwcnt = MatRowCnt(OPr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(OPr,i,OPrw);
            if (OPrw.PrepayNr==APPayHistr.VEPNr) then begin
              fr = OPrw.FrRateBankVal;
              to1 = OPrw.ToRateB1BankVal;
              to2 = OPrw.ToRateB2BankVal;
              br1 = OPrw.BaseRate1BankVal;
              br2 = OPrw.BaseRate2BankVal;
              res = true;
//Trace("APPayHistr.Val " & APPayHistr.Val,"");              
            end;
          end;
        end;
      end;
    end;
  end;
  GetOPPrepaymentRate = res;
  return;
end;

function val Max(val a,val b)
begin
  val res;
  
  if (a>=b) then begin
    res = a;
  end else begin
    res = b;
  end;
  Max = res;
  return;
end;

global
function Boolean CalculateOPPrepaymentAvgRate(record PUVc PUp,LongInt ordernr,val totpuincur,var val fr,var val to1,var val to2,var val br1,var val br2)
begin
  Boolean res;
  record OPPVc OPPr;
  Boolean found;
  record OPVc OPr;
  row OPVc OPrw;
  Integer i,rwcnt;
  record APPayHistVc APPayHistr;
  val totppval,rempuincur,ppval;
  val pufr,puto1,puto2,pubr1,pubr2;
  
  if (ordernr<=0) then begin goto LCalculateOPPrepaymentAvgRate; end;
  found = true;
  OPPr.OrderNr = ordernr;
  while (LoopKey("OrderNr",OPPr,1,found)) begin
    if (OPPr.OrderNr!=ordernr) then begin found = false; end;
    if (found) then begin
      APPayHistr.VEPNr = OPPr.SerNr;
      APPayHistr.FileName = "OPVc";
      if (ReadFirstMain(APPayHistr,2,true)) then begin
        OPr.SerNr = APPayHistr.SerNr;
        if (ReadFirstMain(OPr,1,true)) then begin
          rwcnt = MatRowCnt(OPr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(OPr,i,OPrw);
            if (OPrw.PrepayNr==APPayHistr.VEPNr) then begin
              res = true;
              ppval = OPPr.PPVal;
              if ((totppval+ppval)>totpuincur) then begin
                ppval = totpuincur - totppval;
              end;
              fr = fr + ppval*OPrw.FrRateBankVal;
              to1 = to1 + ppval*OPrw.ToRateB1BankVal;
              to2 = to2 + ppval*OPrw.ToRateB2BankVal;
              br1 = br1 + ppval*OPrw.BaseRate1BankVal;
              br2 = br2 + ppval*OPrw.BaseRate2BankVal;
              totppval = totppval + ppval;
//Trace("fr " & fr," to1 " & to1 & " totppval " & totppval & " ppval " & ppval & " totpuincur " & totpuincur);              
//Trace("APPayHistr.Val " & APPayHistr.Val,"");              
            end;
          end;
        end;
      end;
    end;
  end;


  rempuincur = Max(totpuincur-totppval,0);
//Trace("fr " & fr," to1 " & to1 & " totpuincur " & totpuincur);              
  if (rempuincur>0) then begin
    GetFullCurncyRate(PUp.CurncyCode,PUp.TransDate,pufr,puto1,puto2,pubr1,pubr2);
    fr = fr + pufr*rempuincur;
    to1 = to1 + puto1*rempuincur;
    to2 = to2 + puto2*rempuincur;
    br1 = br1 + pubr1*rempuincur;
    br2 = br2 + pubr2*rempuincur;
  end;

  fr = fr/totpuincur;
  to1 = to1/totpuincur;
  to2 = to2/totpuincur;
  br1 = br1/totpuincur;
  br2 = br2/totpuincur;
LCalculateOPPrepaymentAvgRate:;  
  CalculateOPPrepaymentAvgRate = res;
  return;
end;

updating function Integer PasteRowToPU(record POSettingBlock POSetb,record CostAccBlock CAb,record MainStockBlock MSb,record PUVc PUp,record POVc POp,row POVc POrw,Integer rownr,record INVc INr,
                                       val qty,var Integer nrwcnt)
begin
  Integer res;
  row PUVc PUrw;
  val p,t,v1,v2,pv,sv;
  string 255 extra,stockacc,purchacc;
  record PIVc PIr;
  Boolean foundpi;
  val frrate,torate1,torate2,baserate1,baserate2;
  
  ClearRow(PUp,PUrw,1);
  PUrw.StockType = POrw.StockType;
  PUrw.TREO = POrw.TREO;
  PUrw.ArtCode = POrw.ArtCode;
  PUrw.VATCode = POrw.VATCode;
  PUrw.Coefficient = INr.UnitCoefficient;
  if (POp.SetZeroPUQuant!=0) then begin
    PUrw.Quant = 0;
  end else begin
    PUrw.Quant = qty;
  end;
  PUrw.UnitCode = POrw.UnitCode;
  PUrw.Spec = POrw.Spec;
  PUrw.SerialNr = "";
  p = POrw.Price;
  PUrw.PIFactor = POrw.PIFactor;
  PUrw.VEUnit = POrw.VEUnit;
  PUrw.InPrice = INr.InPrice;
  DivPIFactor(PUrw.Quant,PUrw.PIFactor,t);
  PUrw.VEQuant = t;
  if (POrw.PIFactor!=0) then begin
    p = p/POrw.PIFactor;
  end;
  CalcSum(1,p,0,POrw.vRebate,t,0);
  PUrw.UPrice = Round(t,SetRoundModeD(5));//UPrice is 5 only
  extra = "";
  PIr.ItemCode = POrw.ArtCode;
  PIr.Location = POp.Location;
  PIr.VECode = POp.VECode;
  PIr.VEItemCode = POrw.VEArtCode;
  foundpi = ReadFirstMain(PIr,4,true);
  if (foundpi==false) then begin
    if (nonblank(POp.Location)) then begin
      PIr.ItemCode = POrw.ArtCode;
      PIr.Location = "";
      PIr.VECode = POp.VECode;
      PIr.VEItemCode = POrw.VEArtCode;
      foundpi = ReadFirstMain(PIr,4,true);
    end;
  end;
  if (foundpi) then begin
    extra = PIr.PurchaseCost;
    if (nonblank(PIr.OrgCountry)) then begin
      PUrw.CountryOfOrg = PIr.OrgCountry;
    end;
  end;
  if (nonblank(POp.CurncyCode)) then begin
    if (((POp.BaseRate1!=0) and (POp.BaseRate2!=0)) or
       ((POp.ToRateB1!=0) or (POp.ToRateB2!=0))) then begin
      frrate = POp.FrRate;
      torate1 = POp.ToRateB1;
      torate2 = POp.ToRateB2;
      baserate1 = POp.BaseRate1;
      baserate2 = POp.BaseRate2;
    end else begin
      GetFullCurncyRate(PUp.CurncyCode,CurrentDate,frrate,torate1,torate2,baserate1,baserate2);
    end;
    t = MulRateToBase1(POp.CurncyCode,PUrw.UPrice,frrate,torate1,torate2,baserate1,baserate2,SetRoundModeD(5));
    CalcExtra(t,extra,v1);
  end else begin
    CalcExtra(PUrw.UPrice,extra,v1);
  end;
  
  if (nonblank(POrw.CustomsCost)) then begin
    PUrw.CustomsCost = POrw.CustomsCost;
  end else begin  
    PUrw.CustomsCost = v1;
  end;
  if (POrw.ShipCost<>blankval and POrw.ShipCost<>0) then begin
    PUrw.ShipCost = POrw.ShipCost;
  end else begin  
    PUrw.ShipCost = v2;
  end;
  PUrw.RowCost1 = POrw.RowCost1;
  PUrw.RowCost2 = POrw.RowCost2;
  PUrw.RowCost3 = POrw.RowCost3;
  PUrw.RowCost4 = POrw.RowCost4;
  PUrw.RowCost5 = POrw.RowCost5;

  PUrw.Extra = INr.ExtraCost;
  PUrw.CostPrice = blankval;
  PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,PUrw.Extra,PUp.CurncyCode,
                  PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                  PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                  PUrw.CustomsCost,pv,PUrw.Quant,sv,PUrw.VATCode,PUp.ExportFlag);
  PUrw.CostPrice = pv;                                        
  PUrw.Sum = sv;
  PUrw.OrdRow = rownr;
  if (MSb.PONoOnPURowsOnly==1) then begin
    PUrw.PONr = POp.SerNr;
  end;
  PUrw.ChargeNumber = POrw.ChargeNumber;
  PUrw.VEItemCode = POrw.VEArtCode;
  PUrw.VARList = POrw.VARList;
  PUrw.Objects = POrw.Objects;
  if (POSetb.TransAccObjToPU!=0) then begin
    PUrw.Objects = POrw.Objects;
    PUrw.CredAcc = POrw.CostAcc;
  end;
  PUrw.UnitXval = INr.Width;
  PUrw.UnitYval = INr.Height;
  PUrw.UnitZval = INr.Depth;

  PUrw.SuppSerialNr = INr.SuppSerialNr;
  PUrw.MajStoneDet = INr.MajStoneDet;
  PUrw.Colour = INr.Colour;
  PUrw.Clarity = INr.Clarity;
  PUrw.Cert = INr.Cert;
  PUrw.MinStoneDet = INr.MinStoneDet;
  PUrw.Metal = INr.Metal;
  PUrw.RowWeight = INr.RowWeight;
  PUrw.Size = INr.Size;
  PUrw.Length = INr.Length;

  PUrw.WatchBrand = INr.WatchBrand;
  PUrw.StyleName = INr.StyleName;
  PUrw.WatchMetal = INr.WatchMetal;
  PUrw.Movement = INr.Movement;
  PUrw.BrcStr = INr.BrcStr;
  PUrw.Gender = INr.Gender;
  PUrw.Other = INr.Other;
  PUrw.Other2 = INr.Other2;

  PUrw.BasePrice = INr.UPrice1;
  FindPUStockAcc(PUp.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUp.Location,INr,PUrw.StockType,stockacc,purchacc,false);
  PUrw.CostAcc = stockacc;
  if (blank(PUrw.CredAcc)) then begin
    PUrw.CredAcc = purchacc;
  end;
  res = 0;
  MatRowPut(PUp,nrwcnt,PUrw);
  if (PUFromPO_PasteQuant(PUp,POp.SerNr,nrwcnt,200,POp)==0) then begin end;
  nrwcnt = MatRowCnt(PUp);
  PasteRowToPU = res;
  return;
end;

global
updating function Integer PastePOInPU(record POVc POp,record PUVc PUp,Integer maxrows)
BEGIN
  Integer res;
  record POSettingBlock POSetb;
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  record INVc INr;
  record PIVc PIr;
  row PUVc PUrw;
  row POVc POrw;
  Integer i,rwcnt,nrwcnt;
  val t1,remn,p,totqty,v2,t,v1;
  val frrate,torate1,torate2,baserate1,baserate2;
  string 255 extra;
  Boolean DropPOToPULink;
  val fr,to1,to2,br1,br2;
  val pv,sv,totpuincur;
  LongInt ponr;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  string 255 tstr;
  string 20 stockacc,purchacc;
  Boolean testf,foundpi;
  record TaxMatrixVc TMr;
  record SerNrTrackBlock SNrb;
  
  res = -1;
  if (POp.Closed!=0) then begin goto LPastePOInPU; end;  
  if (POp.OrderType!=kOrderTypeNormal) then begin 
    res = 22075;
    goto LPastePOInPU;
  end;
  BlockLoad(POSetb);
  BlockLoad(MSb);
  BlockLoad(CAb);
  BlockLoad(SNrb);
  if (MSb.dontAllowOverreceive!=1) then begin res = -1; end;
  if (MSb.PONoOnPURowsOnly<>1) then begin
    PUp.PONr = POp.SerNr;
  end else begin
    PUp.PONr = -1;
  end;

  PUp.PUClass = POp.POClass;
  PUp.POCOSerNr = POp.POCOSerNr;
  PUp.VECode = POp.VECode;
  PUp.VEName = POp.Addr0;
  PUp.BranchID = POp.BranchID;
  PUp.CurncyCode = POp.CurncyCode;
  PUp.Location = POp.Location;
  PUp.Objects = POp.Objects;
  PUp.LangCode = POp.LangCode;
  PUp.Comment = POp.Comment;
  PUp.VEVATCode = POp.VEVATCode;
  PUp.NoTAXonVAT = POp.NoTAXonVAT;
  PUp.ExtraCostsCalculation = POp.ExtraCostsCalculation;
  PUp.PUFromPORate = POSetb.PUFromPORate;
  switch (PUp.PUFromPORate) begin
    case kPURateFromPurchaseOrder:
      PUp.FrRate = POp.FrRate;
      PUp.ToRateB1 = POp.ToRateB1;
      PUp.ToRateB2 = POp.ToRateB2;
      PUp.BaseRate1 = POp.BaseRate1;
      PUp.BaseRate2 = POp.BaseRate2;
    case kPURateOnGoodsReceiptDate:
      GetFullCurncyRate(PUp.CurncyCode,PUp.TransDate,fr,to1,to2,br1,br2);
      PUp.FrRate = fr;
      PUp.ToRateB1 = to1; 
      PUp.ToRateB2 = to2;
      PUp.BaseRate1 = br1;
      PUp.BaseRate2 = br2;
    case kPURateFromPrepayment:
      rwcnt = MatRowCnt(POp);  
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(POp,i,POrw);
        if (blank(POrw.ArtCode)) and (POrw.Sum!=0) then begin goto LSKIPROWPastePOInPU; end;
        if (nonblank(POrw.ArtCode)) then begin
          if (POrw.Quant==0) then begin goto LSKIPROWPastePOInPU; end;
          remn = POrw.Quant - POrw.Shipd1;
          if (remn>0) then begin
            totpuincur = totpuincur + remn*POrw.Price;
          end;
        end;
      end;
      if (CalculateOPPrepaymentAvgRate(PUp,POp.SerNr,POp.Sum4,fr,to1,to2,br1,br2)) then begin
        PUp.FrRate = fr;
        PUp.ToRateB1 = to1; 
        PUp.ToRateB2 = to2;
        PUp.BaseRate1 = br1;
        PUp.BaseRate2 = br2;
      end else begin
        PUp.FrRate = POp.FrRate;
        PUp.ToRateB1 = POp.ToRateB1;
        PUp.ToRateB2 = POp.ToRateB2;
        PUp.BaseRate1 = POp.BaseRate1;
        PUp.BaseRate2 = POp.BaseRate2;
      end;
  end;
  
  rwcnt = MatRowCnt(POp);  
  PUp.InclVAT = POp.InclVAT;
  nrwcnt = 0;
  totqty = blankval;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    totqty = totqty + POrw.Quant;
  end;
  CalcExtra(POp.Sum1,POp.CostPerUnit,v2);
  v2 = v2/totqty;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (blank(POrw.ArtCode)) then begin goto LSKIPROWPastePOInPU; end;
    if (POrw.Quant==0) then begin goto LSKIPROWPastePOInPU; end;
    remn = POrw.Quant - POrw.Shipd1;
    if (remn<=0) then begin goto LSKIPROWPastePOInPU; end;// SetM4ZeroVal(&remn);
    if (ReadFirstItem(POrw.ArtCode,INr,true,false)==false) then begin goto LSKIPROWPastePOInPU; end;
    if (nrwcnt>=maxrows) then begin
      ponr = PUp.PONr;
      nrwcnt = 0;
      PUSumUp(PUp);
      if (RecordStore(PUp,false)) then begin end;
      CreateRecordLink(PUp,CurrentCompany,POp,CurrentCompany);
      CreateRecordLink(POp,CurrentCompany,PUp,CurrentCompany);
      CreateNewPUFromPO(PUp,POp,ponr);
    end;
    if ((INr.SerNrf==1) and (MSb.NoSerOnPU==0)) then begin
      if (SNrb.BulkSerialNos!=0) then begin
        res = PasteRowToPU(POSetb,CAb,MSb,PUp,POp,POrw,i,INr,POrw.Quant,nrwcnt);
      end else begin
      
        while (remn>0) begin
          if (nrwcnt>=maxrows) then begin
            ponr = PUp.PONr;
 
            nrwcnt = 0;
            PUSumUp(PUp);
            if (RecordStore(PUp,false)) then begin end;
            CreateRecordLink(PUp,CurrentCompany,POp,CurrentCompany);  
            CreateRecordLink(POp,CurrentCompany,PUp,CurrentCompany);  
            CreateNewPUFromPO(PUp,POp,ponr);
          end;
          remn = remn - 1;
          res = PasteRowToPU(POSetb,CAb,MSb,PUp,POp,POrw,i,INr,1.00,nrwcnt);
        end;
      end;
    end else begin
      ClearRow(PUp,PUrw,1);
      PUrw.StockType = POrw.StockType;
      PUrw.TREO = POrw.TREO;
      PUrw.VATCode = POrw.VATCode;
      PUrw.ArtCode = POrw.ArtCode;
      PUrw.Objects = POrw.Objects;
      PUrw.Coefficient = INr.UnitCoefficient;
      PUrw.BasePrice = INr.UPrice1;
      PUrw.InPrice = INr.InPrice;
      if (POp.SetZeroPUQuant!=0) then begin
        PUrw.Quant = 0;
      end else begin
        PUrw.Quant = remn;
      end;
      PUrw.UnitCode = POrw.UnitCode;
      PUrw.Spec = POrw.Spec;
      PUrw.SerialNr = "";
      PUrw.PIFactor = POrw.PIFactor;
      p = POrw.Price;
/*      
      if (nonblank(POrw.VEUnit)) then begin
        if (POrw.PIFactor!=0) then begin
          p = p/POrw.PIFactor;
        end;
        CalcSum(1,p,0,POrw.vRebate,p,0);
      end else begin    
        CalcSum(1,p,POrw.PriceFactor,POrw.vRebate,p,0);
      end;
*/      

//either above lines or the ones below , both have issues

//the below code is fine when u do 
//Qty 1, Price 2000, Sum 1999  (then discount is calculated 0.1)
//if you find the below ones not working and above ones working, please write such case here

      if (POrw.PIFactor==0) then begin
        p = Round(POrw.Sum/POrw.Quant,SetRoundModeD(5));
      end else begin
//        p = Round((POrw.Sum*POrw.PIFactor)/POrw.Quant,SetRoundModeD(5)); //??
        p = Round(POrw.Sum/POrw.Quant,SetRoundModeD(5));
      end;
      
//      if (nonblank(POrw.VEArtCode)) then begin // sometime people dont put supplier item code on Supplier items      
      t = p;
      PUrw.UPrice = ROund(t,SetRoundModeD(5)); //only 5 in DB
/*
calculated above and CalcSum2 does not take into account Discount Calculation
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
      CalcSum2(1,p,0,POrw.vRebate,t,0);
      PUrw.UPrice = ROund(t,SetRoundModeD(5)); //only 5 in DB
*/
      PUrw.VEUnit = POrw.VEUnit;      
      DivPIFactor(PUrw.Quant,PUrw.PIFactor,t);
      PUrw.VEQuant = t;
      PUrw.Extra = ValToString(Round(INr.ExtraCost,SetRoundModeD(5)),M45Val,"","",0);
      PUrw.CostPrice = blankval;
      PUrw.OrdRow = i;
      if (MSb.PONoOnPURowsOnly==1) then begin
        PUrw.PONr = POp.SerNr;
      end;
        extra = "";

        PIr.ItemCode = POrw.ArtCode;
        PIr.Location = POp.Location;
        PIr.VECode = POp.VECode;
        PIr.VEItemCode = POrw.VEArtCode;
        foundpi = ReadFirstMain(PIr,4,true);
        if (foundpi==false) then begin
          if (nonblank(POp.Location)) then begin
            PIr.ItemCode = POrw.ArtCode;
            PIr.Location = "";
            PIr.VECode = POp.VECode;
            PIr.VEItemCode = POrw.VEArtCode;
            foundpi = ReadFirstMain(PIr,4,true);
          end;
        end;
        if (foundpi) then begin
          extra = PIr.PurchaseCost;
          if (nonblank(PIr.OrgCountry)) then begin
            PUrw.CountryOfOrg = PIr.OrgCountry;
          end;
        end;
        if (nonblank(POp.CurncyCode)) then begin
          if (((POp.BaseRate1!=0) and (POp.BaseRate2!=0)) or
             ((POp.ToRateB1!=0) or (POp.ToRateB2!=0))) then begin
            frrate = POp.FrRate;
            torate1 = POp.ToRateB1;
            torate2 = POp.ToRateB2;
            baserate1 = POp.BaseRate1;
            baserate2 = POp.BaseRate2;
          end else begin
            GetFullCurncyRate(PUp.CurncyCode,CurrentDate,frrate,torate1,torate2,baserate1,baserate2);
          end;
          t = MulRateToBase1(POp.CurncyCode,PUrw.UPrice,frrate,torate1,torate2,baserate1,baserate2,SetRoundModeD(5));
          CalcExtra(t,extra,v1);
        end else begin
          CalcExtra(PUrw.UPrice,extra,v1);
        end;
        v1 = Round(v1,SetRoundModeD(5));
        v2 = Round(v2,SetRoundModeD(5));
  
        if (nonblank(POrw.CustomsCost)) then begin
          PUrw.CustomsCost = POrw.CustomsCost;
        end else begin  
          PUrw.CustomsCost = v1;
        end;
        if (POrw.ShipCost<>blankval and POrw.ShipCost<>0) then begin
          PUrw.ShipCost = POrw.ShipCost;
        end else begin  
          PUrw.ShipCost = v2;
        end;
        PUrw.RowCost1 = POrw.RowCost1;
        PUrw.RowCost2 = POrw.RowCost2;
        PUrw.RowCost3 = POrw.RowCost3;
        PUrw.RowCost4 = POrw.RowCost4;
        PUrw.RowCost5 = POrw.RowCost5;
        
        PUrw.Extra = INr.ExtraCost;
        PUrw.CostPrice = blankval;
        PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,PUrw.Extra,PUp.CurncyCode,
                        PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                        PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                        PUrw.CustomsCost,pv,PUrw.Quant,sv,PUrw.VATCode,PUp.ExportFlag);
      PUrw.CostPrice = pv;                                        
      PUrw.Sum = sv;
      PUrw.VEItemCode = POrw.VEArtCode;
      PUrw.VARList = POrw.VARList;
      if (POSetb.TransAccObjToPU!=0) then begin
        PUrw.Objects = POrw.Objects;
        PUrw.CredAcc = POrw.CostAcc;
      end;
      PUrw.UnitXval = INr.Width;
      PUrw.UnitYval = INr.Height;
      PUrw.UnitZval = INr.Depth;

      PUrw.SuppSerialNr = INr.SuppSerialNr;
      PUrw.MajStoneDet = INr.MajStoneDet;
      PUrw.Colour = INr.Colour;
      PUrw.Clarity = INr.Clarity;
      PUrw.Cert = INr.Cert;
      PUrw.MinStoneDet = INr.MinStoneDet;
      PUrw.Metal = INr.Metal;
      PUrw.RowWeight = INr.RowWeight;
      PUrw.Size = INr.Size;
      PUrw.Length = INr.Length;

      PUrw.WatchBrand = INr.WatchBrand;
      PUrw.StyleName = INr.StyleName;
      PUrw.WatchMetal = INr.WatchMetal;
      PUrw.Movement = INr.Movement;
      PUrw.BrcStr = INr.BrcStr;
      PUrw.Gender = INr.Gender;
      PUrw.Other = INr.Other;
      PUrw.Other2 = INr.Other2;

      FindPUStockAcc(PUp.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUp.Location,INr,PUrw.StockType,stockacc,purchacc,false);
      PUrw.CostAcc = stockacc;
      if (blank(PUrw.CredAcc)) then begin
        PUrw.CredAcc = purchacc;
      end;
      res = 0;
      PUrw.TaxTemplateCode = POrw.TaxTemplateCode;
      UnpackRowFieldMatrix(POrw,"TaxMatrix",TMr);
      PackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
      MatRowPut(PUp,nrwcnt,PUrw);
      RowCalculateTaxMatrix_PUVc(PUp,nrwcnt,PUrw,0);
      MatRowPut(PUp,nrwcnt,PUrw);     
      if (PUFromPO_PasteQuant(PUp,POp.SerNr,nrwcnt,200,POp)==0) then begin end;
      nrwcnt = MatRowCnt(PUp);
    end;
LSKIPROWPastePOInPU:;
  end;
  PUSumUp(PUp);
LPastePOInPU:;
  PastePOInPU = res; 
  RETURN;
END;

global
procedure GetPurchaseControlAcc(string pucreditacc,Integer ItemGroupAccounts,string artcode,record AccBlock ARb,string veacccost,var string res,string vecode)
BEGIN
  record INVc INr;
  record CUVc VEp;
  integer ctype;
  
  res = pucreditacc;
  if (nonblank(res)) then begin
    goto LGetPurchaseControlAcc;
  end;
  VEp.Code = vecode;
  if ReadFirstMain(VEp,1,true) then begin
    if (VEp.ExportFlag==0) then begin
      ctype = 0;
    end;
    if ((VEp.ExportFlag==1) or (VEp.ExportFlag==3)) then begin
     ctype = 1;
    end;
    if (VEp.ExportFlag==2) or (VEp.ExportFlag==4) then begin
      ctype = 2;
    end;  
  end;
  if (ItemGroupAccounts!=0) then begin
    INr.Code = artcode;
    if (ReadFirstMain(INr,1,true)) then begin
      GetITPurchAcc(INr.Group,res,ctype);      
      if (nonblank(res)) then begin
        goto LGetPurchaseControlAcc;
      end;
    end;
  end;
  switch (ctype) begin
    case 1:
      res = ARb.EUPurchAcc;
    case 2:
      res = ARb.ExpPurchAcc;
    otherwise
      res = ARb.PurchAcc;
  end;  
  if (nonblank(res)) then begin
    goto LGetPurchaseControlAcc;
  end;
  res = veacccost;
  if (nonblank(res)) then begin
    goto LGetPurchaseControlAcc;
  end;  
LGetPurchaseControlAcc:;  
  RETURN;
END;

function Integer PastePURowsToVI(record CYBlock CYb,record POVc POr,var record VIVc VIp,
                                 record VITBlock VITb,Integer TransferItems,record CostAccBlock CAb,
                                 record AccBlock ARb,record BaseCurBlock BCb,record APAccBlock APb,record MainStockBlock MSb,
                                 Integer ExportFlag,Boolean itempricef,Boolean customsf,Boolean freightf,
                                 Boolean cost1f,Boolean cost2f,Boolean cost3f,Boolean cost4f,Boolean cost5f)
begin
  Integer res,vatcnt;
  record PUVc PUr;
  row PUVc PUrw;
  Boolean found,testf,vifound;
  Integer vicnt,virow;
  Integer i,rwcnt;
  val puqinvd,q,purowsum,net,sum,t;
  row VIVc VIrw;
  record POVc rPOr;
  row POVc POrw;
  record CUVc VEr;
  record INVc INr;
  string 255 tstr,viitgroup;
  record SMVc VATr;
  vector val vrecqty;
  
  res = 24152;
  VIp.PayVal = blankval;
  vicnt = MatRowCnt(VIp);
  found = true;
  PUr.PONr = POr.SerNr;
  PUr.SerNr = 9999999999;
  while (LoopBackKey("PONr",PUr,2,found)) begin 
    if (PUr.PONr!=POr.SerNr) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (PUr.OKFlag==0) then begin testf = false; end;
      if (found and testf) then begin
        res = 0;
        
        if (itempricef==false) then begin goto LPastePURowsToVISKIPROWS; end;
        
        rwcnt = MatRowCnt(PUr);
        for (i=0;i<rwcnt;i=i+1) begin  
          MatRowGet(PUr,i,PUrw);
          ClearRow(VIp,VIrw,1);
          vifound = PUQtyInvoiced(PUr.SerNr,i,PUr.PONr,puqinvd);
          PUrw.Quant = PUrw.Quant - puqinvd;
          q = PUrw.Quant;
          if ((PUrw.PONr>0 or PUr.PONr>0) and (PUrw.OrdRow>=0)) then begin
            VIrw.PONr = PUrw.PONr;
            VIrw.OrdRow = PUrw.OrdRow;
            if (vifound==false) then begin
              rPOr.SerNr = PUrw.PONr;
              if (rPOr.SerNr<=0) then begin
                rPOr.SerNr = PUr.PONr;
              end;
              if (ReadFirstMain(rPOr,1,true)) then begin 
                if (PUrw.OrdRow>=0) then begin
                  MatRowGet(rPOr,PUrw.OrdRow,POrw);
                  if (q>(POrw.Shipd2-POrw.Invd)) then begin//needs to take Ret Goods into account
//                    q = POrw.Quant - POrw.Invd;
                    q = POrw.Shipd2 - POrw.Invd;
                  end;
                end;
              end;
            end;
            if (q>0) then begin 
              VIrw.Item = PUrw.ArtCode;
              VIrw.qty = q;
              VIrw.PUNr = PUr.SerNr;
              VIrw.PURow = i;
              VIrw.Objects = PUrw.Objects;
              VIrw.SerialNr = PUrw.SerialNr;
            end else begin
              goto LPastePURowsToVISKIPROW;
            end;
          end else begin
            if (vifound==false) then begin
              if (PUrw.OrdRow>=0) then begin
                MatRowGet(POr,PUrw.OrdRow,POrw);
                if (q>(POrw.Quant-POrw.Invd)) then begin
                  if (MSb.dontAllowOverreceive==0) then begin
                    if (q>(POrw.Shipd1-POrw.Invd-vrecqty[PUrw.OrdRow])) then begin
                      q = POrw.Shipd1-POrw.Invd-vrecqty[PUrw.OrdRow];
                    end;
                  end else begin
                    q = POrw.Quant - POrw.Invd;
                  end;  
                end;
              end;
            end;
            if (q>0) then begin 
              VIrw.OrdRow = -2; // Row comes from Order, but is not connected to a specific row 
              if (TransferItems==2) or (PUrw.StockType==kStockTypeConsigment) then begin
                VIrw.Item = PUrw.ArtCode;
                VIrw.qty = q;
                VIrw.OrdRow = PUrw.OrdRow;
                VIrw.PUNr = PUr.SerNr;
                VIrw.PURow = i;
                VIrw.Objects = PUrw.Objects;
                VIrw.SerialNr = PUrw.SerialNr;
              end else begin
                VIrw.qty = q;
                virow = VIRowExists(CYb,VIp,VIrw.AccNumber,VIrw.VATCode,VIrw.TaxTemplateCode,PUrw.Sum,q);
                if (virow==-1) then begin
                  if (nonblank(VIrw.AccNumber)) then begin
                    MatRowPut(VIp,vicnt,VIrw);
                    VIrw.PUNr = PUr.SerNr;
                    vicnt = vicnt + 1;
                  end;
                end else begin
                  goto LPastePURowsToVISKIPROW;
                end;
              end;
            end;      
          end;
          vrecqty[PUrw.OrdRow] = vrecqty[PUrw.OrdRow] + PUrw.Quant;
          if (PUrw.Quant==0) then begin goto LPastePURowsZeroQty; end;
          VIrw.VATCode = PUrw.VATCode;
          VIrw.StockType = PUrw.StockType;
          if (blank(VIrw.VATCode)) then begin
            VIrw.VATCode = VEr.VEVATCode;
            VIrw.TaxTemplateCode = VEr.VETaxTemplateCode;
          end;
          if (blank(VIrw.VATCode)) then begin
            GetItemVATCode(PUrw.ArtCode,VEr.ExportFlag,tstr,false);
            VIrw.VATCode = tstr;
          end;  
          GetPurchaseControlAcc(PUrw.CredAcc,CAb.ItemGroupAccounts,PUrw.ArtCode,ARb,VEr.AccCost,tstr,PUr.VECode);
          VIrw.AccNumber = tstr;
          if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
          VIrw.Comment = tstr;    
          purowsum = PUrw.Quant*PUrw.UPrice;
          if (PUrw.PONr>0) or (PUr.PONr>0) then begin
            purowsum = PUrw.Quant*PUrw.UPrice;
          end;
          sum = FindVAT(VIrw.VATCode,purowsum,PUr.InclVAT,PUr.NoTAXonVAT);
          if (PUr.InclVAT!=0) then begin
            sum = purowsum - sum;
          end else begin
            sum = purowsum;
          end;  
          VIrw.Sum = Round(sum,DefaultRoundMode);
          net = net + VIrw.Sum;
          
          if (nonblank(VIrw.Item)) then begin
            if (blank(viitgroup)) then begin
              if (ReadFirstItem(VIrw.Item,INr,true,true)) then begin
                viitgroup = INr.Group;
              end;
            end;    
          end;
          if (VIrw.Sum!=0) then begin
            MatRowPut(VIp,vicnt,VIrw);
            vicnt = vicnt + 1;         
          end;
LPastePURowsToVISKIPROW:;    
        end;
//        PUAddFreightRow(PUr,VIp,ARb,APb,BCb,vicnt);

LPastePURowsToVISKIPROWS:;
        SetupVATBase(VATr,vatcnt);
        if (customsf) then begin
          AddExtraCostRow(ARB,BCb,VIp,"customs",PUr.CustomsCost,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (freightf) then begin  
          AddExtraCostRow(ARB,BCb,VIp,"freight",PUr.ShipCost,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (cost1f) then begin
          AddExtraCostRow(ARB,BCb,VIp,"pucost1",PUr.Cost1,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (cost2f) then begin
          AddExtraCostRow(ARB,BCb,VIp,"pucost2",PUr.Cost2,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (cost3f) then begin
          AddExtraCostRow(ARB,BCb,VIp,"pucost3",PUr.Cost3,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (cost4f) then begin
          AddExtraCostRow(ARB,BCb,VIp,"pucost4",PUr.Cost4,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
        if (cost5f) then begin
          AddExtraCostRow(ARB,BCb,VIp,"pucost5",PUr.Cost5,PUr.InclVAT,ExportFlag,PUr.ExportFlag,PUr.CurncyCode,VATr,vatcnt);
        end;
LPastePURowsZeroQty:;
        VIDDefault(-1,"PayVal",VIp);
        VICalcVals(VIp);
        VISumup(VIp,t);
        if (t!=0) then begin
          ClearRow(VIp,VIrw,1);
          VIrw.AccNumber = ARb.RndAcc;
          if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
          VIrw.Comment = tstr;
          VIrw.Sum = -t;
          VIrw.VATCode = "";
          VIrw.TaxTemplateCode = "";
          MatRowPut(VIp,MatRowCnt(VIp),VIrw);
          VICalcVals(VIp);
          VISumup(VIp,t);
        end;
        VIp.PayVal = Round(VIp.PayVal,DefaultRoundMode);
        if (VITb.autoVATflag!=0) then begin
          if (nonblank(VITb.autoVATVal)) then begin
            if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) then begin
              MulM4ProcVal(StringToVal(VITb.autoVATVal,M4Rate),VIp.PayVal,t);
              RoundVATSum(VIp.CurncyCode,VIp.PayDeal,"VIVc",t);      
              VIp.VATVal = t;
            end;
          end;
        end;  

      end;
    end;
  end;  
  PastePURowsToVI = res;
  return;
end;

procedure DownpaymentPerVATCode(record VIVc theVIp,record PODownPayBlock DPb,val downp,var Integer srw)
begin
  record VIVc VIr;
  record POVc POr; 
  row VIVc VIrw;
  row VIVc theVIrw;
  row VIVc newVIrw;
  Boolean TrHs,testf,subvatf;
  Integer di,drwcnt;
  Integer i,rwcnt;
  val t,qty,sum;  
  val totd,v;
  string 255 tstr;
  LongInt ordrow;
  record RoundBlock Roundb;
  record TaxMatrixVc TMr;
  val vatv,t1;
    
  BlockLoad(Roundb);
  POr.SerNr = VIr.POSerNr;
  ReadFirstMain(POr,1,true);
  if (POr.InclVAT==0) then begin
    subvatf = true;
  end else begin
    subvatf = false;
  end;
  t = downp;
  if (DPb.CalcMode==0) then begin
    switch (Roundb.VATCalcWay) begin
      case 1: subvatf = false;
    end;
  end;
  if (t<=0) then begin
    goto LDownpaymentPerVATCode;
  end;

  rwcnt = MatRowCnt(theVIp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(theVIp,i,theVIrw);
    TrHs = true;
    qty = theVIrw.qty;
    sum = theVIrw.Sum;
    if (theVIrw.stp!=kInvoiceRowTypeNormal) then begin
      TrHs = false;
    end;
    if (ordrow==theVIrw.OrdRow) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      for (di=i+1;di<rwcnt;di=di+1) begin
        MatRowGet(theVIp,di,VIrw);
        if (VIrw.OrdRow==theVIrw.OrdRow) then begin
          qty = qty + VIrw.qty;
          sum = sum + VIrw.Sum;
        end;
      end;
    end;
    ordrow = theVIrw.OrdRow;
    ResetLoop(VIr);
    VIr.POSerNr = theVIp.POSerNr;
    while (LoopKey("POSerNr",VIr,1,TrHs)) begin
      if (VIr.POSerNr!=theVIp.POSerNr) then begin TrHs = false; end;
      if (TrHs) then begin
        testf = true;
        if (VIr.InvType!=kInvoiceTypeDownpayment) then begin testf = false; end;
        if (VIr.OKFlag==0) then begin testf = false; end;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          drwcnt = MatRowCnt(VIr);
          for (di=0;di<drwcnt;di=di+1) begin
            MatRowGet(VIr,di,VIrw);
            if (VIrw.Sum<0) then begin
              goto LSkiDpRow;
            end;
            switch (VIrw.stp) begin
              case kInvoiceRowTypeDownpayment:
                if (VIrw.OrdRow==ordrow) then begin 
                  v = VIrw.Sum;
                  if (POr.InclVAT==0) then begin
                    if (DPb.CalcMode==0) then begin
                      switch (Roundb.VATCalcWay) begin
                        case 1:
                          if (v>sum) then begin
                            v = sum;
                          end;
                        otherwise
                          if (POr.InclVAT!=0) then begin
                            if (UseTaxTemplatesforTaxCalc==false) then begin
                              MulVATIV(theVIrw.VATCode,sum,vatv,t1,POr.InclVAT,theVIp.NoTAXonVAT);
                              if (v>(sum-vatv)) then begin
                                v = sum - vatv;
                              end;
                            end;
                          end else begin
                            if (v>sum) then begin
                              v = sum;
                            end;
                          end;
                      end;
                    end else begin
                      if (UseTaxTemplatesforTaxCalc==false) then begin
                        if (POr.InclVAT!=0) then begin
                          MulVATIV(theVIrw.VATCode,sum,vatv,t1,POr.InclVAT,theVIp.NoTAXonVAT);
                          if (v>(sum-vatv)) then begin
                            if (v>(sum-vatv)) then begin
                              v = sum - vatv;
                            end;
                          end;
                        end else begin
                          if (v>sum) then begin
                            v = sum;
                          end;
                        end;
                      end;
                    end;
                  end else begin
                    if (v>sum) then begin
                      v = sum;
                    end;
                  end;
                  if (v>t) then begin
                    v = t;
                    if (subvatf) then begin
                      UnpackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
                      FindSalesExVat(TMr,VIrw.VATCode,v,1,0,v);
                    end;
                  end;        
                  ClearRow(theVIp,newVIrw,kInvoiceRowTypeDownpayment);
                  newVIrw.Item = VIr.SerNr;
                  newVIrw.Comment = DPb.TextA;
                  newVIrw.Comment = newVIrw.Comment & " ";
                  newVIrw.Comment = newVIrw.Comment & theVIp.POSerNr;
                  newVIrw.Sum =  newVIrw.Sum - v;
                  if (blank(tstr)) then begin
                    GetItemSalesAcc(DPb.ArtCode,theVIp.ExportFlag,tstr);
                  end;
                  newVIrw.AccNumber = tstr;
                  newVIrw.VATCode = VIrw.VATCode;
                  newVIrw.OrdRow = VIrw.OrdRow;
                  newVIrw.TaxTemplateCode = VIrw.TaxTemplateCode;
//                  newVIrw.vRebate = theVIrw.vRebate;
                  newVIrw.qty = qty;
//                  newVIrw.Price = (newVIrw.Sum/(100-newVIrw.vRebate))*100;
//                  newVIrw.Price = Round(newVIrw.Price/newVIrw.qty,SetRoundModeD(2));
                  UnpackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
                  PackRowFieldMatrix(newVIrw,"TaxMatrix",TMr);
                  RowCalculateTaxMatrix_VIVc(theVIp,srw,newVIrw,0);
                  MatRowPut(theVIp,srw,newVIrw);
                  srw = srw + 1;
                end;
              end;
LSkiDpRow:;;
          end;
        end;
      end;
    end;  
  end;    
LDownpaymentPerVATCode:;   
  return;
end;

procedure AddDownpaymentRows(record POVc POp,var record VIVc VIp)
begin
  val t;
  record PODownPayBlock DPb;
  Boolean subvatf;
  string 255 taxtemplatecode,VATCode;
  record TaxMatrixVc TMr;
  row VIVc VIrw;
  Integer srw;
  
  BlockLoad(DPb);
  t = POp.DownPaySent - POp.DownPayRedcd;
  if (t>0) then begin
    if (DPb.DetailsOnVI==0) then begin
      subvatf = true;
      if (DPb.CalcMode==1) then begin
        if (t>VIp.PayVal) then begin
          t = VIp.PayVal;
          subvatf = false;
        end;
      end else begin
        if (t>VIp.PayVal) then begin
          t = VIp.PayVal;
          subvatf = false;
        end;        
      end;
      if (UseTaxTemplatesforTaxCalc) then begin
        taxtemplatecode = "";
        GetItemTaxTemplateCode(DPb.ArtCode,VIp.ExportFlag,taxtemplatecode,false);
        if (blank(taxtemplatecode)) then begin taxtemplatecode = VIp.VETaxTemplateCode; end;
        taxtemplatecode = FillupTaxMatrix(0,VIp.BranchID,VIp.VECode,"","",taxtemplatecode,TMr);
        if (nonblank(taxtemplatecode)) then begin
          if (POp.InclVAT==0) then begin
            subvatf = true;
          end else begin
            subvatf = false;
          end;      
          if (subvatf) then begin
            FindSalesExVat(TMr,"",t,1,0,t);//no vat like in InvDownPaySum
          end;
        end;
      end else begin
        VATCode = DPb.VATCode;
        if (blank(VATCode)) then begin
          GetItemVATCode(DPb.ArtCode,VIp.ExportFlag,VATCode,true);
        end;
        if (blank(VATCode)) then begin VATCode = VIp.VEVatCode; end;
        if (nonblank(VATCode)) then begin
          if (POp.InclVAT==0) then begin
            subvatf = true;
          end else begin
            subvatf = false;
          end;      
          if (subvatf) then begin
            RecordClear(TMr);
            FindSalesExVat(TMr,VATCode,t,1,0,t);//no vat like in InvDownPaySum
          end;
        end;
      end;
      if (t>0) then begin
        t = -t;
        ClearRow(VIp,VIrw,kInvoiceRowTypeDownpayment);
        VIrw.Comment = DPb.TextA;
        VIrw.Comment = VIrw.Comment & " ";
        VIrw.Comment = VIrw.Comment & POp.SerNr;
        VIrw.Sum = t;
        GetItemSalesAcc(DPb.ArtCode,VIp.ExportFlag,VIrw.AccNumber);
        VIrw.VATCode = VATCode;        
        VIrw.TaxTemplateCode = taxtemplatecode;        
        PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
        RowCalculateTaxMatrix_VIVc(VIp,MatRowCnt(VIp),VIrw,0);
        MatRowPut(VIp,MatRowCnt(VIp),VIrw);
      end;
    end else begin
      srw = MatRowCnt(VIp);
      DownpaymentPerVATCode(VIp,DPb,t,srw);
    end;
  end;
    
  return;
end;

global
updating function Integer PastePOInVI(var record POVc POp,var record VIVc VIp,string vecode,
                                      Boolean itempricef,Boolean customsf,Boolean freightf,
                                      Boolean cost1f,Boolean cost2f,Boolean cost3f,Boolean cost4f,Boolean cost5f)
begin
  Integer i,rwcnt,vatcnt;
  Integer j,virwcnt;
  row VIVc VIrw;
  row POVc POrw;
  Integer nrwcnt;
  record INVc INr;
  val t1,totqty,totveqty,costperunit,recvdv;
  val p,shp,pr,totvatv;
  Integer line;
  record CUVc VEr;
  record APAccBlock APb;
  record AccBlock ARb;
  record CostAccBlock CAb;
  record VITBlock VITb;
  Integer res,ExportFlag;
  Boolean itemfoundf,othersupf;
  val from,to1,to2,base1,base2,tmp;
  record SMVc VATr;
  string 255 tstr;  
  record AcceptSetBlock AcceptSet;
  string 20 viitgroup;
  string 20 lvecode,crncy;
  record PRVc PRr;
  record BaseCurBlock BCb;
  Integer vt,TransferItems;
  record POSettingBlock POSb;
  record TaxMatrixVc TMr;
  record CYBlock CYb;
  Boolean testf,addedaccf;
  record MainStockBlock MSb;

  BlockLoad(VITb);
  BlockLoad(BCb);
  BlockLoad(POSb);
  BlockLoad(CYb);
  BlockLoad(MSb);
  TransferItems = VITb.TransferItems;
  //if any row ordertype is dropship
  rwcnt = MatRowCnt(POp);
  if (POp.OrderType==kOrderTypeDropShip) then begin
    TransferItems = 2;
//per ship note?
  end else begin
    for (i=0;i<rwcnt;i=i+1) begin  
      MatRowGet(POp,i,POrw);
      if (POrw.OrderType==kOrderTypeDropShip) then begin
        TransferItems = 2;
        i = rwcnt;
      end;
    end;
  end;
  
  SetupVATBase(VATr,vatcnt);
  if (itempricef) then begin
    if (nonblank(POp.InvoiceToCode)) then begin
      VIp.OrgVE = POp.VECode;
      lvecode = POp.InvoiceToCode;
    end else begin
      lvecode = POp.VECode;
    end;
  end else begin
    lvecode = POp.VECode;
  end;
  if (itempricef==false) and (nonblank(vecode)) then begin
    lvecode = vecode;
    othersupf = true;
  end;
  VEr.Code = lvecode;
  if (ReadFirstMain(VEr,1,true)==false) then begin 
    res = 1434;
    goto LPastePOInVI; 
  end;
  if (IsStandardProduct==false) then begin
    if (TransferItems!=2) then begin 
      if (blank(VEr.AccCost)) then begin 
        res = 1434;  
        goto LPastePOInVI; 
      end;
    end;
  end;
//  if (POp.Closed!=0) then goto LPastePOInVI;// the same as OR
  res = 0;
  VIp.OrderType = POp.OrderType;
  VIp.ExportFlag = POp.ExportFlag;
  VIp.POSerNr = POp.SerNr;
  VIp.InvDate = CurrentDate;
  VIp.TransDate = CurrentDate;
  VIp.VECode = lvecode;
  VIVc_PasteVECode(VIp,0,false,false,tstr);
  ExportFlag = POp.ExportFlag;
  VIp.NoTAXonVAT = POp.NoTAXonVAT;
  VIp.BranchID = POp.BranchID;
  if (othersupf) then begin
    ExportFlag = VEr.ExportFlag;
    VIp.ExportFlag = ExportFlag;
    VIp.VEName = VEr.Name;
    VIp.PayDeal = VEr.VEPayDeal;
    VIp.Objects = VEr.VEObjects;
    VIp.VEFactoring = VEr.VEFactoring;
    crncy = VEr.VECurncyCode;
    GetFullCurncyRate(crncy,POp.TransDate,from,to1,to2,base1,base2);
    VIp.CurncyCode = crncy;
    VIp.FrRate = from;
    VIp.ToRateB1 = to1;
    VIp.ToRateB2 = to2;
    VIp.BaseRate1 = base1;
    VIp.BaseRate2 = base2;

    VIp.VATFrRate = from;
    VIp.VATToRateB1 = to1;
    VIp.VATToRateB2 = to2;
    VIp.VATBaseRate1 = base1;
    VIp.VATBaseRate2 = base2;
  end else begin
    if (blank(POp.InvoiceToCode)) then begin
      VIp.VEName = POp.Addr0;
    end;
    VIp.CurncyCode = POp.CurncyCode;
    VIp.PayDeal = POp.PayDeal;
    VIp.Objects = POp.Objects;
    VIp.VEFactoring = POp.VEFactoring;

    VIp.FrRate = POp.FrRate;
    VIp.ToRateB1 = POp.ToRateB1;
    VIp.ToRateB2 = POp.ToRateB2;
    VIp.BaseRate1 = POp.BaseRate1;
    VIp.BaseRate2 = POp.BaseRate2;

    VIp.VATFrRate = POp.FrRate;
    VIp.VATToRateB1 = POp.ToRateB1;
    VIp.VATToRateB2 = POp.ToRateB2;
    VIp.VATBaseRate1 = POp.BaseRate1;
    VIp.VATBaseRate2 = POp.BaseRate2;

    switch (VITb.VIFromPORate) begin
      case kVIRateFromPurchaseOrder:
//        above;
      case kVIRateOnPurchaseInvoiceDate:
        GetFullCurncyRate(VIp.CurncyCode,VIp.TransDate,from,to1,to2,base1,base2);
        VIp.FrRate = from;
        VIp.ToRateB1 = to1; 
        VIp.ToRateB2 = to2;
        VIp.BaseRate1 = base1;
        VIp.BaseRate2 = base2;

        VIp.VATFrRate = from;
        VIp.VATToRateB1 = to1; 
        VIp.VATToRateB2 = to2;
        VIp.VATBaseRate1 = base1;
        VIp.VATBaseRate2 = base2;
      case kVIRateFromPrepaymentandPurchaseInvoice:
/*      
        if (GetOPPrepaymentRate(VIp.CurncyCode,POp.SerNr,from,to1,to2,base1,base2)) then begin
          VIp.FrRate = from;
          VIp.ToRateB1 = to1; 
          VIp.ToRateB2 = to2;
          VIp.BaseRate1 = base1;
          VIp.BaseRate2 = base2;
        end else begin
          VIp.FrRate = POp.FrRate;
          VIp.ToRateB1 = POp.ToRateB1;
          VIp.ToRateB2 = POp.ToRateB2;
          VIp.BaseRate1 = POp.BaseRate1;
          VIp.BaseRate2 = POp.BaseRate2;
        end;
*/        
        GetFullCurncyRate(VIp.CurncyCode,VIp.InvDate,VIp.FrRate,VIp.ToRateB1,VIp.ToRateB2,VIp.BaseRate1,VIp.BaseRate2);
        GetFullCurncyRate(VIp.CurncyCode,VIp.InvDate,VIp.VATFrRate,VIp.VATToRateB1,VIp.VATToRateB2,VIp.VATBaseRate1,VIp.VATBaseRate2);
    end;
  end;
  // already in VIVc_PasteVECode, works also for factoring
  //VIp.VATNr = VEr.VATNr;
  //VIp.SortCode = VEr.SortCode;
  VIp.LangCode = POp.LangCode;
  BlockLoad(APb);
  BlockLoad(ARB);
  BlockLoad(CAb);
  VIp.POCQStatNr = POp.POCQStatNr;
  /*
  VIp.BankAcc = VEr.IBANCode;
  if (blank(VIp.BankAcc)) then begin
    VIp.BankAcc = VEr.BankAccount;
  end;
  VIp.BankCode = VEr.AccOperator;
  */
  GetAPAcc(VEr.Code,tstr);
  VIp.APAcc = tstr;
  VIp.VEVatCode = VEr.VEVATCode;
  VIp.VETaxTemplateCode = VEr.VETaxTemplateCode;
  VIp.POCOSerNr = POp.POCOSerNr;
  VIp.Region = POp.Region;
  if ((APb.UpdBaseRate!=0) or (APb.UpdForeginRate!=0)) then begin
    GetFullCurncyRate(VIp.CurncyCode,VIp.TransDate,from,to1,to2,base1,base2);
    if (APb.UpdBaseRate!=0) then begin
      VIp.BaseRate1 = base1;
      VIp.BaseRate2 = base2;
    end;
    if (APb.UpdForeginRate!=0) then begin
      VIp.FrRate = from;
      VIp.ToRateB1 = to1;
      VIp.ToRateB2 = to2;
    end;
  end;
  VIp.PayVal = POp.Sum4;
  VICalcEReb(VIp);
  if (VITb.VIBasedOnPU!=0) and (POp.OrderType!=kOrderTypeDropShip) then begin //any po order rowtype is dropship
    res = PastePURowsToVI(CYb,POp,VIp,VITb,TransferItems,CAb,ARb,BCb,APb,MSb,ExportFlag,itempricef,customsf,freightf,cost1f,cost2f,cost3f,cost4f,cost5f);
    goto LPastePOInVI;
  end;

  nrwcnt = 0;
  if (VITb.FullQtyTrans==0) then begin 
    VIp.PayVal = blankval;
  end;
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(POp,i,POrw);
    totveqty = totveqty + POrw.VEQuant;
    totqty = totqty + POrw.Quant;
  end;  
  CalcExtra(POp.Sum1,POp.CostPerUnit,costperunit);
  costperunit = costperunit/totqty;      
  if (itempricef) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(POp,i,POrw);
      if (blank(POrw.ArtCode)) then begin goto L44PastePOInVI; end;
      if (POrw.StockType==kStockTypeConsigment) then begin
        res = 20579;
        goto LPastePOInVI; 
      end;
      if (VITb.FullQtyTrans==0) then begin
        if (POp.InvBeforePU==0) then begin
          if ((POrw.Shipd2==0) and (POrw.Invd==0)) then begin goto L44PastePOInVI; end;
        end;  
      end;
      virwcnt = MatRowCnt(VIp);
      line = -1;
      for (j=0;j<virwcnt;j=j+1) begin
        MatRowGet(VIp,j,VIrw);
        testf = false;
        switch (TransferItems) begin
          case 0:
            if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
              if (POrw.VATCode==VIrw.VATCode) then begin
                testf = true;
              end;
            end else begin
              if (POrw.TaxTemplateCode==VIrw.TaxTemplateCode) then begin
                testf = true;
              end;
            end;
            if (testf) then begin
              line = j;
              goto L33PastePOInVI;
            end;        
          case 1:
            if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
              if ((POrw.VATCode==VIrw.VATCode) and (POrw.ArtCode==VIrw.Item)) then begin
                if (blank(POrw.PRCode)) then begin 
                  if (POp.PRCode==VIrw.PRCode) then begin 
                    testf = true;
                  end;
                end else begin
                  if (POrw.PRCode==VIrw.PRCode) then begin 
                    testf = true;
                  end;
                end;
              end;
            end else begin
              if ((POrw.TaxTemplateCode==VIrw.TaxTemplateCode) and (POrw.ArtCode==VIrw.Item)) then begin
                if (blank(POrw.PRCode)) then begin 
                  if (POp.PRCode==VIrw.PRCode) then begin 
                    testf = true;
                  end;
                end else begin
                  if (POrw.PRCode==VIrw.PRCode) then begin 
                    testf = true;
                  end;
                end;
              end;
            end;
            if (testf) then begin
              line = j;
              goto L33PastePOInVI;
            end;
          case 2:
        end;
      end;
L33PastePOInVI:;
      INr.Code = POrw.ArtCode;
      itemfoundf = ReadFirstMain(INr,1,true);
      if ((itemfoundf==true) and blank(viitgroup)) then begin
        viitgroup = INr.Group;
      end;
      if (line==-1) then begin
        virwcnt = virwcnt + 1;
        line = virwcnt - 1;
        ClearRow(VIp,VIrw,1);
      end;
      if (blank(VIrw.AccNumber)) then begin
        VIrw.AccNumber = VEr.AccCost;
        if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
        VIrw.Comment = tstr;
        VIrw.VATCode = POrw.VATCode;
        VIrw.TaxTemplateCode = POrw.TaxTemplateCode;
        UnpackRowFieldMatrix(POrw,"TaxMatrix",TMr);
        PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
        VIrw.Sum = blankval;
        VIrw.OrdRow = -2; // Row comes from Order, but is not connected to a specific row 
        if (TransferItems!=0) then begin
          VIrw.OrdRow = i;
          VIrw.Item = POrw.ArtCode;
          if (blank(POrw.PRCode)) then begin
            VIrw.PRCode = POp.PRCode;
          end else begin
            VIrw.PRCode = POrw.PRCode;
          end;
          VIrw.Objects = POrw.Objects;
          GetPurchaseControlAcc("",CAb.ItemGroupAccounts,POrw.ArtCode,ARb,VEr.AccCost,tstr,lvecode);
          VIrw.AccNumber = tstr;
          if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
          VIrw.Comment = tstr;
          //this is according to Stephen's mail, the only question is about item's cost account if TransferItems==2 below
        end;
        if (TransferItems==2) then begin
          VIrw.OrderType = POrw.OrderType;
          if (nonblank(POrw.CostAcc)) then begin
            VIrw.AccNumber = POrw.CostAcc;
            if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
            VIrw.Comment = tstr;
            VIrw.SerialNr = POSerialNrFromPU(POp.SerNr,i);
          end;  
        end;              
      end;
      if (VITb.FullQtyTrans==0) then begin
        shp = POrw.Shipd2;
// Why?? This feels very strange, this means that you invoice the plain item EVERY time you invoice, even second invoice (for a part goods receipt)
//      if (INr.ItemType==0) then begin shp = POrw.Quant; end;
        p = blankval;
        if ((POp.InvBeforePU!=0) and (POp.PUFlag==0)) then begin
          p = POrw.Quant;
          if (POrw.Invd!=0) then begin
            p = p - POrw.Invd;            
          end;  
        end else begin
          if (shp!=0 or POrw.Invd!=0) then begin
            p = shp - POrw.Invd;
          end;
        end;
        if (p==0) then begin
          virwcnt = virwcnt - 1;
          goto L44PastePOInVI;
        end;
        
        if (shp!=0 or POrw.Invd!=0) then begin
          if (POp.InvBeforePU!=0) then begin          
          end else begin
            p = shp - POrw.Invd;
          end;
          if (p==0) then begin
            virwcnt = virwcnt - 1;
            goto L44PastePOInVI;
          end;
        end;
        VIrw.qty = VIrw.qty + p;
        if (POrw.VEQuant!=0) then begin
          t1 = 1;
          VIrw.qty = VIrw.qty*t1;
          t1 = POrw.VEQuant/POrw.Quant;
          p = p*t1;
        end;
/*       
      if (POp.InclVAT!=0) then begin    
        pr = FindVAT(VIrw.VATCode,POrw.Price,POp.InclVAT);       
        totvatv = totvatv + pr;
        pr = POrw.Price - pr;     
      end else begin
        pr = POrw.Price;
      end;
      CalcSum(p,pr,POrw.PriceFactor,POrw.vRebate,t1,0);      
done in the end, round off      
*/
//        t1 = (VIrw.qty * POrw.Sum / POrw.Quant);// VIrw.qty is summuing up qtys from diffrent rows if consolidate items to account
        if (POp.InvBeforePU==0) then begin
          recvdv = ((POrw.Shipd2 - POrw.Invd) * POrw.Sum / POrw.Quant);
        end else begin
//          t1 = POrw.Quant * POrw.Price;
          recvdv = POrw.Sum;
        end;
        VIrw.Sum = VIrw.Sum + recvdv;
      end else begin
        p = POrw.Quant - POrw.Invd;
        if (p==0) then begin
          MessageBox(1547,"");
        end;
        VIrw.Sum = VIrw.Sum + POrw.Sum;
        VIrw.qty = VIrw.qty + POrw.Quant;
      end;
      VIrw.StockType = POrw.StockType;
      VIrw.PrepayNr = -1;
      VIrw.PrepayAmount = blankval;
      totqty = costperunit*VIrw.qty;
      VIrw.Sum = VIrw.Sum + totqty;
      GetPIPurchseCost(POrw.ArtCode,lvecode,POrw.VEArtCode,totqty);
      totqty = totqty*VIrw.qty;
      VIrw.Sum = VIrw.Sum + totqty;       
      if (VITb.FullQtyTrans!=0) then begin
        VIp.PayVal = VIp.PayVal + totqty;
        if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
          AddVATBase(VATr,VIrw.VATCode,totqty,blankval,vatcnt,POp.InclVAT,VIp.NoTAXonVAT);
        end;
      end;    
      if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
        if (POp.InclVAT!=0) then begin
          if (VITb.FullQtyTrans==2) then begin
            MulVATIV(VIrw.VATCode,recvdv,tmp,t1,POp.InclVAT,POp.NoTAXonVAT);
            VIrw.Sum = VIrw.Sum - tmp - t1;
          end else begin
            MulVATIV(VIrw.VATCode,recvdv,tmp,t1,POp.InclVAT,POp.NoTAXonVAT);
            VIrw.Sum = VIrw.Sum - tmp - t1;
            AddVATBase(VATr,VIrw.VATCode,recvdv,blankval,vatcnt,POp.InclVAT,VIp.NoTAXonVAT);
          end;
        end;
      end else begin
        if (TransferItems==2) then begin
          VIrw.TaxTemplateCode = POrw.TaxTemplateCode;
          UnpackRowFieldMatrix(POrw,"TaxMatrix",TMr);
          PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
          MatRowPut(VIp,line,VIrw);
          RowCalculateTaxMatrix_VIVc(VIp,line,VIrw,0);
          MatRowPut(VIp,line,VIrw);
        end;
      end;
      MatRowPut(VIp,line,VIrw);
L44PastePOInVI:;
    end;
  end;
  addedaccf = MatRowCnt(VIp)!=0;
  if (customsf) then begin
    AddExtraCostRow(ARB,BCb,VIp,"customs",POp.CustomsCost,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (freightf) then begin  
    AddExtraCostRow(ARB,BCb,VIp,"freight",POp.ShipCost,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (cost1f) then begin
    AddExtraCostRow(ARB,BCb,VIp,"pucost1",POp.Cost1,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (cost2f) then begin
    AddExtraCostRow(ARB,BCb,VIp,"pucost2",POp.Cost2,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (cost3f) then begin
    AddExtraCostRow(ARB,BCb,VIp,"pucost3",POp.Cost3,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (cost4f) then begin
    AddExtraCostRow(ARB,BCb,VIp,"pucost4",POp.Cost4,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;
  if (cost5f) then begin
    AddExtraCostRow(ARB,BCb,VIp,"pucost5",POp.Cost5,POp.InclVAT,ExportFlag,POp.ExportFlag,POp.CurncyCode,VATr,vatcnt);
  end;

  if (VITb.FullQtyTrans==0) then begin
    VIp.PayVal = blankval;
    virwcnt = MatRowCnt(VIp);
    for (i=0;i<virwcnt;i=i+1) begin
      MatRowGet(VIp,i,VIrw);
      if (itempricef) then begin
        if (POp.InclVAT==0) then begin
          AddVATBase(VATr,VIrw.VATCode,VIrw.Sum,blankval,vatcnt,POp.InclVAT,VIp.NoTAXonVAT);
        end;
      end;
      VIp.PayVal = VIp.PayVal + VIrw.Sum;
    end;
  end;
  if (rwcnt>0) then begin
    MatRowGet(VIp,0,VIrw);
    vt = VATType(VIrw.VATCode);
  end;
  
  if (POp.InclVAT==0) then begin
    if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
      CalcVATBaseVAT(VATr,POp.InclVAT,VIp.NoTAXonVAT,vatcnt,totvatv,t1);
      VIp.TAX1Sum = t1;
      if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) and (vt!=kVATTypeReversed) then begin
        VIp.PayVal = VIp.PayVal + totvatv + VIp.TAX1Sum;
      end;
    end;
  end else begin
    if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
      CalcVATBaseVAT(VATr,POp.InclVAT,VIp.NoTAXonVAT,vatcnt,totvatv,t1);
      VIp.TAX1Sum = t1;
      if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) then begin
        VIp.PayVal = VIp.PayVal + totvatv + VIp.TAX1Sum;
      end;  
    end;
  end;
  if (POp.InclVAT!=0) then begin
    p = VIp.VATVal;    
    if (blank(p)) then begin
      p = VIp.CalcVATVal;
    end;    
    if (p!=POp.Sum3) then begin
//        VIp.VATVal = POp.Sum3;//this cannot be corect
//        VIp.PayVal = POp.Sum4;//this cannot be corect
    end;
    VIp.VATVal = p;
  end;

  VICalcEReb(VIp);
  VICalcVals(VIp);
  if (addedaccf==false) then begin
    VIp.PayVal = VIp.PayVal + VIp.CalcVATVal + VIp.TAX1Sum;
  end;
  if (CYb.UseTaxTemplatesforTaxCalc!=0) then begin
    UnpackFieldMatrix(VIp,"TaxMatrix",TMr);
    VIp.PayVal = VIp.PayVal + CalculateTotalVATFromTaxMatrix(TMr,POp.InclVAT);
  end;
  VISumup(VIp,p);
  if (p!=0) then begin
    ClearRow(VIp,VIrw,1);
    line = virwcnt;
    VIrw.AccNumber = ARb.RndAcc;
    if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
    VIrw.Comment = tstr;
    VIrw.Sum = -p;
    VIrw.VATCode = "";
    MatRowPut(VIp,line,VIrw);
  end;
LPastePOInVI:;
  if (res==0) then begin
    if (MatRowCnt(VIp)==0) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(POp,i,POrw);
        switch (POrw.stp) begin
          case 1:
            if (POp.InvBeforePU!=0) then begin
            end else begin
              if ((POrw.Quant - POrw.Shipd2)>0) then begin
                res = 24152;
              end;
              if (res<=0) then begin
                if ((POrw.Quant - POrw.Invd)<=0) then begin
                  res = 24153;
                end;
              end;
            end;
        end;
      end;
    end;
  end;
  AddDownpaymentRows(POp,VIp);
  VIDDefault(-1,"PayVal",VIp);
  PastePOInVI = res;
  return;
end;

global
updating function Integer CreateVIFromPO(LongInt PONr,record RcVc RepSpec,var record VIVc VIp)
begin
  Integer res;
  record POVc POr;
  record SRBlock SRRec;
  LongInt newnr;
  
  POr.SerNr = PONr;
  if (ReadFirstMain(POr,0,true)) then begin end;  
  RecordNew(VIp);
  res = PastePOInVI(POr,VIp,RepSpec.f1,RepSpec.flags[0]!=0,RepSpec.flags[6]!=0,RepSpec.flags[7]!=0,RepSpec.flags[1]!=0,RepSpec.flags[2]!=0,RepSpec.flags[3]!=0,RepSpec.flags[4]!=0,RepSpec.flags[5]!=0);
  if (res!=0) then begin
    goto LCreateVIFromPO;
  end;
  if (VIp.SerNr==-1) then begin
    BlockLoad(SRRec);
    newnr = GetCurUserLastNr("VIVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastVINr;      
    end;    
    VIp.SerNr = NextSerNr("VIVc",VIp.TransDate,newnr,false,"");
    if (VIp.SerNr==-1) then begin goto LCreateVIFromPO; end;
  end;
  if ((MatRowCnt(VIp)>0) and (VIp.SerNr!=-1)) then begin
    if (RecordStore(VIp,false)) then begin 
      CreateRecordLink(VIp,CurrentCompany,POr,CurrentCompany);  
      CreateRecordLink(POr,CurrentCompany,VIp,CurrentCompany);  
    end;
  end else begin
    res = -1;
  end;
LCreateVIFromPO:;
  CreateVIFromPO = res;
  return;
end;

procedure CreateNewDropSHFromPO(var record DropSHVc DropSHp,record POVc POp,record ORVc ORr)
begin
  record SRBlock SRb;
  LongInt newnr;
  val fr,to1,to2,br1,br2;

  RecordNew(DropSHp);
  DropSHp.OrderNr = POp.OrdNr;
  DropSHp.POOrderNr = POp.SerNr;
  if (DropSHp.SerNr==-1) then begin
    BlockLoad(SRb);
    newnr = GetCurUserLastNr("DropSHVc");
    if (newnr==-1) then begin
      newnr = SRb.LastDropSHNr;      
    end;    
    DropSHp.SerNr = NextSerNr("DropSHVc",DropSHp.ShipDate,newnr,false,"");
  end;
  DropSHp.CustCode = ORr.CustCode;
  DropSHp.Addr0 = ORr.ShipAddr0;
  DropSHp.Addr1 = ORr.ShipAddr1;
  DropSHp.Addr2 = ORr.ShipAddr2;
  DropSHp.Addr3 = ORr.ShipAddr3;
  DropSHp.DelAddr3 = ORr.DelAddr3;
  DropSHp.DelAddr4 = ORr.DelAddr4;
  DropSHp.DelAddrCode = ORr.DelAddrCode;
  DropSHp.ShipMode = ORr.ShipMode;
  DropSHp.Sorting = ORr.Sorting;
  DropSHp.Objects = POp.Objects;
  DropSHp.LangCode = POp.LangCode;
  DropSHp.Comment = POp.Comment;
  DropSHp.CurncyCode = POp.CurncyCode;
  DropSHp.FrRate = POp.FrRate;
  DropSHp.ToRateB1 = POp.ToRateB1;
  DropSHp.ToRateB2 = POp.ToRateB2;
  DropSHp.BaseRate1 = POp.BaseRate1;
  DropSHp.BaseRate2 = POp.BaseRate2;
  return;
end;

global
procedure FindDropShipCosAcc(record AccBlock Accb,record INVc INr,string custcode,Integer StockType,var string cosacc)
begin
  record CostAccBlock CAb;
  string 255 tstr;
  
  BlockLoad(CAb);
  if (CAb.NoNLCostOnShip!=0) then begin
    cosacc = Accb.DropShipCOSAccrualAcc;
  end else begin
    cosacc = Accb.StockCostAcc;
    GetCOSAcc(cosacc,custcode,"",Accb,INr,CAb.ItemGroupAccounts,true,0,cosacc,tstr);
  end;
  return;
end;

procedure FindPurchaseAccruals(record AccBlock Accb,record INVc INr,Integer StockType,var string purchacc)
begin
  purchacc = Accb.PurchAcc;
  return;
end;

procedure PastePORowinDropSH(record AccBlock Accb,record CostAccBlock CAb,var record DropSHVc DropSHp,record POVc POr,row POVc POrw,Integer porow,record INVc INr,val remn)
begin
  row DropSHVc DropSHrw;
  string 255 cosacc,purchacc;
  
  ClearRow(DropSHp,DropSHrw,1);
  DropSHrw.StockType = POrw.StockType;
  DropSHrw.VATCode = POrw.VATCode;
  DropSHrw.ArtCode = POrw.ArtCode;
  DropSHrw.Objects = POrw.Objects;
  DropSHrw.BasePrice = INr.UPrice1;
  DropSHrw.InPrice = INr.InPrice;
  DropSHrw.CostPrice = POrw.Price;
  DropSHrw.Ordered = remn;
  DropSHrw.Ship = remn;
  DropSHrw.Spec = POrw.Spec;
  DropSHrw.SerialNr = "";      
  DropSHrw.POOrdRow = porow;
  DropSHrw.OrdRow = POrw.OrdRow;
  DropSHrw.PurAccrualsAcc = POrw.CostAcc;
/*    
    if (nonblank(POp.CurncyCode)) then begin
      if (((POp.BaseRate1!=0) and (POp.BaseRate2!=0)) or
         ((POp.ToRateB1!=0) or (POp.ToRateB2!=0))) then begin
        frrate = POp.FrRate;
        torate1 = POp.ToRateB1;
        torate2 = POp.ToRateB2;
        baserate1 = POp.BaseRate1;
        baserate2 = POp.BaseRate2;
      end else begin
        GetFullCurncyRate(PUp.CurncyCode,CurrentDate,frrate,torate1,torate2,baserate1,baserate2);
      end;
      t = MulRateToBase1(POp.CurncyCode,PUrw.UPrice,frrate,torate1,torate2,baserate1,baserate2,SetRoundModeD(5));
      CalcExtra(t,extra,v1);
    end else begin
      CalcExtra(PUrw.UPrice,extra,v1);
    end;
    v1 = Round(v1,SetRoundModeD(5));
    v2 = Round(v2,SetRoundModeD(5));

    if (nonblank(POrw.CustomsCost)) then begin
      PUrw.CustomsCost = POrw.CustomsCost;
    end else begin  
      PUrw.CustomsCost = v1;
    end;
    if (POrw.ShipCost<>blankval and POrw.ShipCost<>0) then begin
      PUrw.ShipCost = POrw.ShipCost;
    end else begin  
      PUrw.ShipCost = v2;
    end;
    PUrw.RowCost1 = POrw.RowCost1;
    PUrw.RowCost2 = POrw.RowCost2;
    PUrw.RowCost3 = POrw.RowCost3;
    PUrw.RowCost4 = POrw.RowCost4;
    PUrw.RowCost5 = POrw.RowCost5;
    
    PUrw.Extra = INr.ExtraCost;
    PUrw.CostPrice = blankval;
    PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,PUrw.Extra,PUp.CurncyCode,
                    PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                    PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,pv,PUrw.Quant,sv,PUrw.VATCode,PUp.ExportFlag);
  PUrw.CostPrice = pv;                                        
  PUrw.Sum = sv;
*/  

  DropSHrw.Objects = POrw.Objects;
  DropSHrw.SuppSerialNr = INr.SuppSerialNr;
  DropSHrw.MajStoneDet = INr.MajStoneDet;
  DropSHrw.Colour = INr.Colour;
  DropSHrw.Clarity = INr.Clarity;
  DropSHrw.Cert = INr.Cert;
  DropSHrw.MinStoneDet = INr.MinStoneDet;
  DropSHrw.Metal = INr.Metal;
  DropSHrw.RowWeight = INr.RowWeight;
  DropSHrw.Size = INr.Size;
  DropSHrw.Length = INr.Length;

  DropSHrw.WatchBrand = INr.WatchBrand;
  DropSHrw.StyleName = INr.StyleName;
  DropSHrw.WatchMetal = INr.WatchMetal;
  DropSHrw.Movement = INr.Movement;
  DropSHrw.BrcStr = INr.BrcStr;
  DropSHrw.Gender = INr.Gender;
  DropSHrw.Other = INr.Other;
  DropSHrw.Other2 = INr.Other2;

  FindDropShipCosAcc(Accb,INr,DropSHp.CustCode,DropSHrw.StockType,DropSHrw.COSAcc);
  if (blank(DropSHrw.PurAccrualsAcc)) then begin
    FindPurchaseAccruals(Accb,INr,DropSHrw.StockType,purchacc);
    DropSHrw.PurAccrualsAcc = purchacc;
  end;
  MatRowPut(DropSHp,MatRowCnt(DropSHp),DropSHrw);
  return;
end;

global
updating function Integer PastePOInDropSH(record POVc POp,var record DropSHVc DropSHp,Integer maxrows)
begin
  Integer res;
  record CostAccBlock CAb;
  record AccBlock Accb;
  record INVc INr;
  row POVc POrw;
  row ORVc ORrw;
  Integer i,rwcnt,nrwcnt;
  val t1,remn,p,totqty,v2,t,v1;
  val pv,sv;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  string 255 tstr;
  string 20 costkacc,purchaccracc;
  record ORVc ORr;
  
  res = -1;
  if (POp.Closed!=0) then begin goto LPastePOInDropSH; end; 
  res = 22075;
/*JJDS   
  if (POp.OrderType!=kOrderTypeDropShip) then begin 
    res = 22075;
    goto LPastePOInDropSH;
  end;
*/  
  BlockLoad(CAb);
  BlockLoad(Accb);
  
  DropSHp.OrderNr = POp.OrdNr;
  DropSHp.POOrderNr = POp.SerNr;
  ORr.SerNr = DropSHp.OrderNr;
  ReadFirstMain(ORr,1,true);
  
  DropSHp.CustCode = ORr.CustCode;
  DropSHp.Addr0 = ORr.Addr0;
  DropSHp.Addr1 = ORr.ShipAddr1;
  if (blank(DropSHp.Addr1))  then begin
    DropSHp.Addr1 = ORr.Addr1;
  end;
  DropSHp.Addr2 = ORr.ShipAddr2;
  if (blank(DropSHp.Addr2))  then begin
    DropSHp.Addr2 = ORr.Addr2;
  end;
  DropSHp.Addr3 = ORr.ShipAddr3;
  if (blank(DropSHp.Addr3))  then begin
    DropSHp.Addr3 = ORr.Addr3;
  end;
  DropSHp.DelAddr3 = ORr.DelAddr3;
  if (blank(DropSHp.DelAddr3))  then begin
    DropSHp.DelAddr3 = ORr.InvAddr3;
  end;
  DropSHp.DelAddr4 = ORr.DelAddr4;
  if (blank(DropSHp.DelAddr4))  then begin
    DropSHp.DelAddr4 = ORr.InvAddr4;
  end;
  DropSHp.DelAddrCode = ORr.DelAddrCode;
  DropSHp.ShipMode = ORr.ShipMode;
  DropSHp.Sorting = ORr.Sorting;
  DropSHp.Objects = POp.Objects;
  DropSHp.LangCode = POp.LangCode;
  DropSHp.Comment = POp.Comment;
  
  DropSHp.CurncyCode = POp.CurncyCode;
  DropSHp.FrRate = POp.FrRate;
  DropSHp.ToRateB1 = POp.ToRateB1;
  DropSHp.ToRateB2 = POp.ToRateB2;
  DropSHp.BaseRate1 = POp.BaseRate1;
  DropSHp.BaseRate2 = POp.BaseRate2;

  rwcnt = MatRowCnt(POp);  
//  DropSHp.InclVAT = POp.InclVAT;
  nrwcnt = 0;
  totqty = blankval;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (POrw.OrderType==kOrderTypeDropShip) then begin
      res = 0;
      totqty = totqty + POrw.Quant;
    end;
  end;
  CalcExtra(POp.Sum1,POp.CostPerUnit,v2);
  v2 = v2/totqty;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (blank(POrw.ArtCode)) then begin goto LSKIPROWPastePOInDropSH; end;
    if (POrw.Quant==0) then begin goto LSKIPROWPastePOInDropSH; end;
    if (POrw.OrderType!=kOrderTypeDropShip) then begin 
      if (POrw.OrderType!=kOrderTypeDefault) then begin
        goto LSKIPROWPastePOInDropSH; 
      end else begin
        if (POp.OrderType!=kOrderTypeDropShip) then begin
          goto LSKIPROWPastePOInDropSH; 
        end;
      end;
    end;
    if (POrw.OrdRow>=0) then begin
      MatRowGet(ORr,POrw.OrdRow,ORrw);
    end;
    remn = POrw.Quant - POrw.Shipd1;
    if (remn<=0) then begin goto LSKIPROWPastePOInDropSH; end;// SetM4ZeroVal(&remn);
    if (ReadFirstItem(POrw.ArtCode,INr,true,false)==false) then begin goto LSKIPROWPastePOInDropSH; end;
    if (nrwcnt>=maxrows) then begin
      nrwcnt = 0;
      DropSHSumUp(DropSHp);
      if (RecordStore(DropSHp,false)) then begin end;
      CreateRecordLink(DropSHp,CurrentCompany,POp,CurrentCompany);
      CreateRecordLink(POp,CurrentCompany,DropSHp,CurrentCompany);
      CreateNewDropSHFromPO(DropSHp,POp,ORr);
    end;
    if (INr.SerNrf==1) then begin
      while (remn>0) begin
        if (nrwcnt>=maxrows) then begin
          nrwcnt = 0;
          DropSHSumUp(DropSHp);
          if (RecordStore(DropSHp,false)) then begin end;
          CreateRecordLink(DropSHp,CurrentCompany,POp,CurrentCompany);  
          CreateRecordLink(POp,CurrentCompany,DropSHp,CurrentCompany);  
          CreateNewDropSHFromPO(DropSHp,POp,ORr);
        end;
        PastePORowinDropSH(Accb,CAb,DropSHp,POp,POrw,i,INr,1);      
        remn = remn - 1;
        nrwcnt = MatRowCnt(DropSHp);
      end;
    end else begin
      PastePORowinDropSH(Accb,CAb,DropSHp,POp,POrw,i,INr,remn);
      nrwcnt = MatRowCnt(DropSHp);
    end;
LSKIPROWPastePOInDropSH:;
  end;
  DropSHSumUp(DropSHp);
  res = 0;
  if (MatRowCnt(DropSHp)==0) then begin 
    res = -1;
  end;
LPastePOInDropSH:;
  PastePOInDropSH = res; 
  return;
end;

procedure POCalcOneRow(record SysFormatBlock SysFormatRec,record POVc POr,Integer rownr,roundmode roundoff,val totvalp,val calcvalp,var val rowcalcvalp,var val restp)
BEGIN    
  row POVc POrw;
  val temp,rv,q;
  string 255 tstr;
  record INVc INr;
  
  MatRowGet(POr,rownr,POrw);
//  DivPIFactor(POrw.Quant,POrw.PIFactor,q); //why extra cost should be per supplier unit not ours ? 
  q = POrw.Quant;
  switch (POr.ExtraCostsCalculation) begin 
    case 1:
      if (ReadFirstItem(POrw.ArtCode,INr,false,false)) then begin
        temp = q*INr.Weight;
      end;
    otherwise
      temp = q*POrw.Price;
  end;

  temp = temp*calcvalp;
  temp = temp/totvalp;
  rowcalcvalp = temp/q;
  temp = rowcalcvalp*q;
/*  M4ValRound(rowcalcvalp,roundoff,rowcalcvalp);*/
  rowcalcvalp = Round(rowcalcvalp,SetRoundModeD(5));
  if (rowcalcvalp==0) then begin rowcalcvalp = blankval; end;
  /*if this is not here then
  put qty 106, price 1500 shpcost(in header) 10 and will be 9.999 after recalculating
  M4ToStr just cuts 6th and rest digits*/
  tstr = ValToString(rowcalcvalp,M45Val,SysFormatRec.thousSep,SysFormatRec.decimalPt,0);
  rowcalcvalp = StringToVal(tstr,M45Val);
  rv = rowcalcvalp*q;
/*  SubM4Val(&temp,&rv,&rv);*/
  restp = rv + restp;
  RETURN;
END;

procedure POUnsortByVal(record POVc POr,record POVc PO2r,Integer column,array integer roworder)
BEGIN
  row POVc POrw;
  row POVc PO2rw;
  LongInt rownt;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PO2r);
  if (rwcnt<1) then begin goto LPOUnsortByVal; end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PO2r,i,PO2rw);
    MatRowGet(POr,roworder[i],POrw);
    if ((PO2rw.stp==3) or (PO2rw.ovst!=0)) then begin
      goto LSKIPPOROW3;
    end;
    if ((POrw.stp==3) or (POrw.ovst!=0)) then begin
      goto LSKIPPOROW3;
    end;
    POrw.Quant = PO2rw.Quant;
    switch (column) begin
      case 6: POrw.ShipCost = PO2rw.ShipCost; 
      case 7: POrw.CustomsCost = PO2rw.CustomsCost; 
      case 1: POrw.RowCost1 = PO2rw.RowCost1; 
      case 2: POrw.RowCost2 = PO2rw.RowCost2; 
      case 3: POrw.RowCost3 = PO2rw.RowCost3; 
      case 4: POrw.RowCost4 = PO2rw.RowCost4; 
      case 5: POrw.RowCost5 = PO2rw.RowCost5; 
    end;
    MatRowPut(POr,roworder[i],POrw);
LSKIPPOROW3:
  end;
LPOUnsortByVal:;
  RETURN;
END;

procedure POSortByVal(record POVc POr,record POVc PO2r,Integer column,var array integer roworder)
BEGIN
  row POVc POrw;
  val highest,rv,q;
  LongInt rownr;
  LongInt temp;
  Integer cnt;
  Integer rwcnt,i;
  
  rwcnt = MatRowCnt(POr);
  if (rwcnt<1) then begin goto LPOSortByVal; end;
L22POSortByVal:;
  highest = blankval;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POr,i,POrw);
    if ((POrw.stp==3) or (POrw.ovst!=0)) then begin
      goto LSKIPPOROW4;
    end;
    if (POrw.Quant!=blankval) then begin
//      DivPIFactor(POrw.Quant,POrw.PIFactor,q); //why extra cost should be per supplier unit not ours ? 
      q = POrw.Quant;
      switch(column) begin
        case 6: /* Calculate Shipment Cost */
          rv = q*POrw.ShipCost; 
        case 7: /* Calculate Customs Cost */
          rv = StringToVal(POrw.CustomsCost,M45Val);
          rv = q*rv;
        case 1: /* Calculate Extra Costs */
          rv = q*POrw.RowCost1; 
        case 2: /* Calculate Extra Costs */
          rv = q*POrw.RowCost2; 
        case 3: /* Calculate Extra Costs */
          rv = q*POrw.RowCost3; 
        case 4: /* Calculate Extra Costs */
          rv = q*POrw.RowCost4; 
        case 5: /* Calculate Extra Costs */
          rv = q*POrw.RowCost5; 
      end;
      if ((rv>highest) or (highest==blankval)) then begin
        rownr = i;
        highest = rv;
      end;
    end;
LSKIPPOROW4:;    
  end;
  if (rownr==-1) then begin goto LPOSortByVal; end;
  if (cnt>=rwcnt) then begin goto LPOSortByVal; end;
  MatRowGet(POr,rownr,POrw);
  if ((POrw.stp!=3) and (POrw.ovst==0)) then begin
//    temp = PUrw.OrdRow;
//    PUrw.OrdRow = rownr;
    roworder[cnt] = rownr;
    MatRowPut(PO2r,cnt,POrw);
    POrw.Quant = blankval;
 //   POrw.OrdRow = temp;
    MatRowPut(POr,rownr,POrw);
  end;
  cnt = cnt + 1;
  if (cnt>=rwcnt) then begin goto LPOSortByVal; end;
  rownr = -1;
  goto L22POSortByVal;
LPOSortByVal:;
  RETURN;
END;

procedure POCalcOneRow2(record SysFormatBlock SysFormatRec,record POVc POr,Integer rownr,Integer roundoff,Integer column,val realtotp,var val calctotp)
BEGIN
  val rowtot,add,cost,comp,totnotthisrow;
  val diff,rowdiff,q;
  Boolean inc;
  row POVc POrw;

  MatRowGet(POr,rownr,POrw);
  if (POrw.Quant==0) then begin goto LPOCalcOneRow2; end;
  if (realtotp>calctotp) then begin
    diff = realtotp - calctotp;
    switch (column) begin
      case 6: add = 0.001; 
      case 7: add = 0.00001;
      case 1: add = 0.001; 
      case 2: add = 0.001; 
      case 3: add = 0.001; 
      case 4: add = 0.001; 
      case 5: add = 0.001;
    end;    
    inc = true;
  end else begin
    diff = calctotp - realtotp;
    switch (column) begin
      case 6: add = -0.001; 
      case 7: add = -0.00001; 
      case 1: add = -0.001; 
      case 2: add = -0.001; 
      case 3: add = -0.001; 
      case 4: add = -0.001; 
      case 5: add = -0.001; 
    end;    
    inc = false;
  end;
  switch (column) begin
    case 6: cost = POrw.ShipCost; 
    case 7: cost = StringToVal(POrw.CustomsCost,M45Val); 
    case 1: cost = POrw.RowCost1; 
    case 2: cost = POrw.RowCost2; 
    case 3: cost = POrw.RowCost3; 
    case 4: cost = POrw.RowCost4; 
    case 5: cost = POrw.RowCost5; 
  end;
  comp = blankval;
  while (realtotp==comp) begin
//    DivPIFactor(POrw.Quant,POrw.PIFactor,q); //why extra cost should be per supplier unit not ours ? 
    q = POrw.Quant;
    rowtot = q*cost;
    rowtot = Round(rowtot,SetRoundModeD(roundoff));
    totnotthisrow = calctotp - rowtot;
    comp = cost + add;
    comp = q*comp;
    comp = Round(comp,SetRoundModeD(roundoff));
    comp = comp + totnotthisrow;
    if (inc==true) then begin
      rowdiff = comp - realtotp;
      if (comp>realtotp) then begin 
          goto L88POCalcOneRow2;
      end;
    end else begin
      rowdiff = realtotp - comp;
      if (comp<realtotp) then begin
          goto L88POCalcOneRow2;
      end;
    end;
    calctotp = comp;
    cost = cost + add;
  end;
L88POCalcOneRow2:;
  switch (column) begin
    case 6: POrw.ShipCost = cost; 
    case 7: POrw.CustomsCost = ValToString(cost,M45Val,SysFormatRec.thousSep,SysFormatRec.decimalPt,0);
    case 1: POrw.RowCost1 = cost; 
    case 2: POrw.RowCost2 = cost; 
    case 3: POrw.RowCost3 = cost; 
    case 4: POrw.RowCost4 = cost; 
    case 5: POrw.RowCost5 = cost; 
  end;
LPOCalcOneRow2:;
  return;
END;

global
procedure POSetShipCost(var record POVc POr,Integer column)
BEGIN
  record POVc locPOr;
  row POVc POrw;
  Integer i,rwcnt;
  val totval,rv,rest,q;
  val calcval,rowcalcval;
  record SysFormatBlock SFb;
  array integer roworder;
  record INVc INr;
  
  BlockLoad(SFb);
  switch( column) begin
    case 1: calcval = POr.Cost1; // Calculate Extra Costs 
    case 2: calcval = POr.Cost2; // Calculate Extra Costs 
    case 3: calcval = POr.Cost3; // Calculate Extra Costs 
    case 4: calcval = POr.Cost4; // Calculate Extra Costs 
    case 5: calcval = POr.Cost5; // Calculate Extra Costs 
    case 6: calcval = POr.ShipCost;    // Calculate Shipment Cost 
    case 7: calcval = POr.CustomsCost; // Calculate Customs Cost 
    otherwise goto LPOSetShipCost;
  end;
  rwcnt = MatRowCnt(POr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POr,i,POrw);
    if ((POrw.stp!=3) and (POrw.ovst==0) and (nonblank(POrw.ArtCode)) and !(column==7 and POrw.TREO==kTREO)) then begin
//      DivPIFactor(POrw.Quant,POrw.PIFactor,q); //why extra cost should be per supplier unit not ours ? 
      q = POrw.Quant;
      rv = blankval;
      switch (POr.ExtraCostsCalculation) begin 
        case 1:
          if (ReadFirstItem(POrw.ArtCode,INr,false,false)) then begin
            rv = q*INr.Weight;
          end;
        otherwise
          rv = q*POrw.Price;
      end;
      totval = totval + rv;
    end;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POr,i,POrw);
    if ((POrw.stp==3) or (POrw.ovst!=0) or (blank(POrw.ArtCode)) or (column==7 and POrw.TREO==kTREO)) then begin
      goto LSKIPPOROW;
    end;
    POCalcOneRow(SFb,POr,i,DefaultCurRoundOff,totval,calcval,rowcalcval,rest);
    switch (column) begin
      case 1: POrw.RowCost1 = rowcalcval; 
      case 2: POrw.RowCost2 = rowcalcval; 
      case 3: POrw.RowCost3 = rowcalcval; 
      case 4: POrw.RowCost4 = rowcalcval; 
      case 5: POrw.RowCost5 = rowcalcval; 
      case 6: POrw.ShipCost = rowcalcval; 
      case 7: POrw.CustomsCost = ValToString(rowcalcval,M45Val,SFb.thousSep,SFb.decimalPt,0);
    end;
    MatRowPut(POr,i,POrw);
LSKIPPOROW:;
  end;
//!!!  PUSortByVal(POr,locPOr,column,roworder);
  rwcnt = MatRowCnt(locPOr);
  for (i=0;i<rwcnt;i=i+1) begin
    if (rest==calcval) then begin goto L88POSetShipCost; end;
    MatRowGet(locPOr,i,POrw);
    if ((POrw.stp==3) or (POrw.ovst!=0) or (blank(POrw.ArtCode))) then begin
      goto LSKIPPOROW2;
    end;
    if (rest!=0) then begin
      POCalcOneRow2(SFb,locPOr,i,5,column,calcval,rest);
    end;
    MatRowPut(locPOr,i,POrw);
LSKIPPOROW2:;
  end;
L88POSetShipCost:;
//!!!  PUUnsortByVal(POr,locPOr,column,roworder);
LPOSetShipCost:;
  RETURN;
END;

global
procedure PODClassOnOpenWindowRemote(var record POVc POr,var Integer AcceptanceStatusFlag)
begin
  record AcceptanceRulesVc Acptr;
  record ActVc Actr;
  
  if (HasApprovals) then begin
    AcceptanceStatusFlag = POApprovalStatus(POr,Acptr);
  end;
  return;
end;