external function val FindVAT(string,val,Integer,Integer);
external function roundmode SetRoundModeD(Integer);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function Integer TypeOfCurncy(var string,var Integer);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function Integer ARIInstallNr(LongInt,Date);
external function roundmode DefaultRoundMode();
external procedure CreateSwedishChecksum(var string,var string);
external updating procedure UpdateLiqInfoFromIP(LongInt,val,string,val,LongInt,LongInt,Boolean);
external updating procedure UpdateCreditNotesWithLowerNumbers(record IVVc);
external updating procedure IVUpdateCostPrice(record IVVc);
external updating procedure IVVcCreateSoldGiftCert(record IVVc);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt DateDiff(Date,Date);
external updating procedure IVUpdateStock(record IVVc,Boolean);
external procedure PUCalcPerc(val,string,var val);
external function Boolean GetPD(var record PDVc);
external procedure PastePDInInv(var record IVVc,string,Boolean);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external function Integer DateGetIntMonth(Date);
external function string 255 CreateInternationalCreditorReference(string);

procedure GetIVPrepaidInBase(record IVVc IVp,Integer rownr,var val totsump,var val prepaybasevp)
BEGIN
  record ARPayHistVc ARPayHistr;
  row IVVc IVrwp;
  val thesum,realbases,bases,curv;
  LongInt prepaynr;
  Boolean foundf;

  MatRowGet(IVp,rownr,IVrwp);
  thesum = IVrwp.Sum;
  ARPayHistr.CUPNr = IVrwp.CUPNr;
  ARPayHistr.FileName = "IPVc";
  foundf = true;
  while (LoopMain(ARPayHistr,2,foundf)) begin
    if ((ARPayHistr.CUPNr!=IVrwp.CUPNr) or (ARPayHistr.FileName!="IPVc")) then begin foundf = false; end;
    if (foundf) then begin
      if ((totsump>ARPayHistr.Val) and (thesum>ARPayHistr.Val)) then begin
        totsump = totsump - ARPayHistr.Val;
        thesum = thesum - ARPayHistr.Val;
        curv = curv + ARPayHistr.Val;
        bases = bases + MulRateToBase1(IVp.CurncyCode,ARPayHistr.Val,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
        realbases = realbases + ARPayHistr.BookVal;
      end else begin
        totsump = totsump - IVrwp.Sum;
        curv = curv + ARPayHistr.Val;
        bases = bases + MulRateToBase1(IVp.CurncyCode,thesum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
        realbases = realbases + ARPayHistr.BookVal;
        foundf = false;
      end;
    end;
  end;
  thesum = IVrwp.Sum/curv;
  thesum = thesum*realbases;
  prepaybasevp = prepaybasevp + thesum;
  RETURN;
END;

global
updating procedure ArtStatUp2(string ac,string cc,string branchid,string class,Date dp,val qp,val sp,val gpp,val pp,Boolean negf,val icssp,val icsgpsp,val icspp,val inclp)
BEGIN
  record ICSVc ICSr;
  record INVc INr;
  Boolean foundin,found;
  val q,s,gp,p,incl;
  record STVc STr;

  q = qp;
  s = sp;
  gp = gpp;
  p = pp;
  incl = inclp;
  p = Round(p,DefaultRoundMode);
  if (negf==true) then begin
    q = -q;
    s = -s;
    gp = -gp;
    p = -p;
    incl = -incl;
  end;
  foundin = false;
/*  
  foundin = ReadFirstItemInclClosed(ac,INr,false,false);
  if (foundin) then begin
    if (ac!=INr.Code) then begin
//      STr.Variety = right(ac,len(ac)-len(INr.Code));
    end;
  end;
  if (foundin==false) then begin
    INr.Code = ac;
  end;
*/
  STr.ArtCode = ac;
  STr.BranchID = branchid;
  STr.Class = class;
  AddBalance(STr,dp,"salesexclvat",s,"grossprofit",gp,"",blankval,"quant",q,"salesinclvat",incl,"",blankval);
  q = qp;
  s = icssp;
  gp = icsgpsp;
  p = icspp;
  p = Round(p,DefaultRoundMode);
  if (negf==true) then begin
    q = -q;
    s = -s;
    gp = -gp;
    p = -p;
  end;  
  ICSr.ArtCode = ac;
  ICSr.CustCode = cc;
  ICSr.BranchID = branchid;
  ICSr.Class = class;
  AddBalance(ICSr,dp,"salesexclvat",s,"grossprofit",gp,"price",p,"quant",q,"salesinclvat",incl,"",blankval);

LArtStatUp:;
  RETURN;
END;

global
updating procedure ArtStatUp(string ac,string cc,string branchid,string class,Date dp,val qp,val sp,val gpp,val pp,Boolean negf,val icssp,val icsgpsp,val icspp)
begin
  ArtStatUp2(ac,cc,branchid,class,dp,qp,sp,gpp,pp,negf,icssp,icsgpsp,icspp,0);
end;

global
updating procedure CustStatUp(string FileName,LongInt TransNr,string cc,string orgcust,string branchid,string class,string curncy,Date dp,val exlp,val inclp,val payp,val gpp,val basebalp,val sumpp,Boolean negf)
BEGIN
  record CSVc CSr;
  record CSVc orgCSr;  
  record CUVc CUr;
  record CUVc orgCUr;  
  Boolean found;
  val exl,incl,pay,gp,basebal;
  val sump;
  Boolean factoring;
  Boolean found2;
  Date ldp;


//Trace("payp " & payp,"");

  ldp = dp;
  if (cc!=orgcust) then begin factoring = true; end;
  if (blankdate(ldp)) then begin goto LCustStatUp; end;
  if (GetYear(ldp)<1980) then begin
    ldp = AddYear(ldp,-GetYear(ldp)+1980);
  end;
  CUr.Code = cc;
  found = ReadFirstMain(CUr,1,true);
  if (found==false) then begin
    CUr.Code = cc;
  end;
  if (factoring) then begin
    orgCUr.Code = orgcust;
    found2 = ReadFirstMain(orgCUr,1,true);
    if (found2==false) then begin
      orgCUr.Code = orgcust;
    end;
  end;
  exl = exlp;
  incl = inclp;
  pay = payp;
  gp = gpp;
  basebal = basebalp;
  sump = sumpp;
  sump = Round(sump,DefaultRoundMode);
  if (negf==true) then begin
    exl = -exl;
    incl = -incl;
    pay = -pay;
    gp = -gp;
    basebal = -basebal;
    sump = -sump;
  end;
/*  
if (cc=="200011") then begin
LogText(0," CustStatUp " & chr(9) & " FileName " & chr(9) & FileName & chr(9) & " TransNr " & chr(9) & TransNr & chr(9) & " cc " & chr(9) & cc & chr(9) & " exl " & chr(9) & exl & chr(9) & " incl " & chr(9) & incl & chr(9) & " pay " & chr(9) & pay & chr(9) & " basebal " & chr(9) & basebal & chr(9) & " sump " & chr(9) & sump);
end;
*/
  CSr.CustCode = cc;
  CSr.BranchID = branchid;
  CSr.Class = class;
  CSr.CurncyCode = curncy;
  orgCSr.CustCode = orgcust;
  orgCSr.BranchID = branchid;
  orgCSr.Class = class;
  orgCSr.CurncyCode = curncy;
  if (factoring) then begin//KARL salesexclvat is for cur and salesinclvat for orgcust??
    AddBalance(CSr,ldp,"salesexclvat",exl,"",blankval,"grossprofit",gp,"",blankval,"",blankval,"",blankval);
    AddBalance(orgCSr,ldp,"",blankval,"salesinclvat",incl,"",blankval,"paidvalue",pay,"balance",basebal,"priceexcldiscount",sump);
  end else begin
    AddBalance(CSr,ldp,"salesexclvat",exl,"salesinclvat",incl,"grossprofit",gp,"paidvalue",pay,"balance",basebal,"priceexcldiscount",sump);
  end;
LCustStatUp:;
  RETURN;
END;

updating function Boolean ArtStatUpXS(record IVVc IVp,var val gpsp,Date dp,Boolean negf)
BEGIN
  record XSVc XSr;
  row XSVc XSrw;
  Integer rwcnt,i;
  val basesum;
  Boolean res;
  val price;
  Integer typeofcur,oldstyle;

  XSr.FileName = "IVVc";
  XSr.SerNr = IVp.SerNr;
  if (ReadFirstMain(XSr,2,true)) then begin
    rwcnt = MatRowCnt(XSr);
    for (i=0; i<rwcnt;i=i+1) begin
      MatRowGet(XSr,i,XSrw);
      switch (XSrw.FromFileName) begin
        case "TBIVVc":
          if (nonblank(XSrw.CurncyCode)) then begin
            typeofcur = TypeOfCurncy(XSrw.CurncyCode,oldstyle);   
            switch (typeofcur) begin
              case 0://Foreign
                basesum = MulRateToBase1(XSrw.CurncyCode,XSrw.Sum,XSrw.FrRate,XSrw.ToRateB1,XSrw.ToRateB2,XSrw.BaseRate1,XSrw.BaseRate2,DefaultCurRoundOff);
              case 1://Base Curncy 1 
                basesum = XSrw.Sum;
              case 2://Base Curncy 2
                basesum = MulRateToBase1(XSrw.CurncyCode,XSrw.Sum,XSrw.FrRate,XSrw.ToRateB1,XSrw.ToRateB2,XSrw.BaseRate1,XSrw.BaseRate2,DefaultCurRoundOff);
              case 3:
                basesum = XSrw.Sum;
            end;
          end else begin
            basesum = XSrw.Sum;
          end;
        otherwise
          basesum = MulRateToBase1(IVp.CurncyCode,XSrw.Sum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
      end;
      gpsp = gpsp + XSrw.GP;
      ArtStatUp(XSrw.Item,IVp.CustCode,IVp.BranchID,"",dp,XSrw.Qty,basesum,XSrw.GP,price,negf,basesum,XSrw.GP,price);
      res = true;
      res = true;
    end;
  end;
  ArtStatUpXS = res;
  RETURN;
END;

global
updating procedure ArtStats(record IVVc IVp,Boolean negflag,Boolean importcreditnoteupdatef)
BEGIN
  record IVVc IV2r;
  row IVVc IVrw;
  Integer i;
  Integer rwcnt;
  Boolean negf;
  val t,t2,ts,tsum;
  val bv;
  val pri,temp;
  string 255 cust;
  Boolean cashcredit;
  Boolean sumpriceflag;
  val sumprice2,basesum2,bv2,gps2;
  val icsbasesum,icsgps,icsprice;
  val prepayv,tpr,prepaybasev;
  val totsum;
  LongInt lastcupno;
  val b1cashv;
  val fr,to1,to2,b1,b2;
  record CUVc CUr;
  record TaxMatrixVc TMr;
  record BaseCurBlock BCb;
  val sumincustcur,sum4incustcur,paidincustcur,sumpriceincustcur,tempincustcur,bvincustcur,cashvincustcur;
  val suminbase1,sum4inbase1,paidinbase1,gpsinbase1,sumpriceinbase1,suminbaseinclvat1;

  BlockLoad(BCb);
  CUr.Code = IVp.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
  end;
  fr = IVp.FrRate;
  to1 = IVp.ToRateB1;
  to2 = IVp.ToRateB2;
  b1 = IVp.BaseRate1;
  b2 = IVp.BaseRate2;
  
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin    
    if (IVp.CredInv==-1) then begin
      fr = IVp.FrRate;
      to1 = IVp.ToRateB1;
      to2 = IVp.ToRateB2;
      b1 = IVp.BaseRate1;
      b2 = IVp.BaseRate2;
    end else begin 
      if (importcreditnoteupdatef==false) then begin
        IV2r.SerNr = IVp.CredInv;
        if (ReadFirstMain(IV2r,1,true)) then begin 
        end;
      end;
      fr = IV2r.FrRate;
      to1 = IV2r.ToRateB1;
      to2 = IV2r.ToRateB2;
      b1 = IV2r.BaseRate1;
      b2 = IV2r.BaseRate2;
    end;  
  end;   
  if (ImportingTextBackup) then begin
    UpdateCreditNotesWithLowerNumbers(IVp);
  end;
  
  negf = negflag;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin negf = true; end;
  if (IVp.Invalid!=0) then begin
    if (negf) then begin
      negf = false; 
    end else begin
      negf = true;
    end;
  end;
  if (importcreditnoteupdatef) then begin
    negf = false;
  end;
  if (blankdate(IVp.TransDate)) then begin goto LArtStats; end;
  if (ArtStatUpXS(IVp,gpsinbase1,IVp.TransDate,negf)) then begin
    goto L88ArtStats;
  end;
  negf = negflag;
  if (importcreditnoteupdatef) then begin
    negf = !negf;
  end;
  totsum = IVp.Sum4;
  rwcnt = MatRowCnt(IVp);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.ovst!=0) then begin goto LSKIPRow; end;
    icsbasesum = blankval;
    icsgps = blankval;
    icsprice = blankval;
    temp = blankval;
    tempincustcur = blankval;
    suminbase1 = blankval;
    if (IVrw.stp==kInvoiceRowTypeDownpayment) then begin sumpriceflag = true; end;
    if (IVrw.stp==kInvoiceRowTypeGiftVoucherPayment) then begin 
      b1cashv = b1cashv + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff); 
      cashvincustcur = cashvincustcur + IVrw.Sum;
    end;
    if (IVrw.stp==kInvoiceRowTypeCashPayment) then begin 
      b1cashv = b1cashv + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff); 
      cashvincustcur = cashvincustcur + IVrw.Sum;
    end;
    if (IVrw.stp==kInvoiceRowTypeCreditCardPayment) then begin 
      b1cashv = b1cashv + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff); 
      cashvincustcur = cashvincustcur + IVrw.Sum;
    end;
    if (IVrw.stp==kInvoiceRowTypeChequePayment) then begin 
      b1cashv = b1cashv + MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff); 
      cashvincustcur = cashvincustcur + IVrw.Sum;
    end;
    if ((IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==kInvoiceRowTypeCorrection)) then begin
      t = MulRateToBase1(IVp.CurncyCode,IVrw.Sum,fr,to1,to2,b1,b2,DefaultCurRoundOff);
      UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
      FindSalesExVat(TMr,IVrw.VATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,suminbase1);
      if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
        switch (IVrw.stp) begin
          case kInvoiceRowTypeCorrection:
            gpsinbase1 = gpsinbase1 - IVrw.rowGP;
          otherwise
            gpsinbase1 = gpsinbase1 + IVrw.rowGP;
        end;
      end else begin
        gpsinbase1 = gpsinbase1 + IVrw.rowGP;
      end;  
      temp = IVrw.Quant*IVrw.Price;
      if (temp==0) then begin
        temp = IVrw.Sum;
      end;
      FindSalesExVat(TMr,IVrw.VATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,tempincustcur);      

      t = MulRateToBase1(IVp.CurncyCode,temp,fr,to1,to2,b1,b2,DefaultCurRoundOff);
      FindSalesExVat(TMr,IVrw.VATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,temp);      
      icsprice = temp;
      icsbasesum = suminbase1;
      icsgps = IVrw.rowGP;
      if (IVp.DiscSum!=0) then begin
        ts = IVrw.Quant*IVrw.Price;
        ts = ts*IVp.DiscPerc;
        ts = ts/100;
        sumprice2 = sumprice2 + ts;        
        icsprice = ts;
        ts = IVrw.rowGP*IVp.DiscPerc;
        ts = ts/100;
        gps2 = gps2 + ts;     
        icsgps = ts;
        tsum = IVrw.Sum;
        ts = tsum*IVp.DiscPerc;
        ts = ts/100;
        tsum = tsum - ts;
        ts = MulRateToBase1(IVp.CurncyCode,tsum,fr,to1,to2,b1,b2,DefaultCurRoundOff);
        UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
        FindSalesExVat(TMr,IVrw.VATCode,ts,IVp.InclVAT,IVp.NoTAXonVAT,icsbasesum);
      end;
      if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (negflag) then begin
          switch (IVrw.stp) begin
            case kInvoiceRowTypeCorrection: 
              negf = true; 
              sumpriceinbase1 = sumpriceinbase1 + temp;
              sumpriceincustcur = sumpriceincustcur + tempincustcur;
           otherwise
              negf = false; 
              sumpriceinbase1 = sumpriceinbase1 - temp;
              sumpriceincustcur = sumpriceincustcur - tempincustcur;
           end;   
        end else begin
          switch (IVrw.stp) begin
            case kInvoiceRowTypeCorrection: 
              sumpriceinbase1 = sumpriceinbase1 - temp;
              sumpriceincustcur = sumpriceincustcur - tempincustcur;
              negf = false; 
           otherwise
              sumpriceinbase1 = sumpriceinbase1 + temp;
              sumpriceincustcur = sumpriceincustcur + tempincustcur;
              negf = true; 
           end;   
        end;
        if (importcreditnoteupdatef) then begin
          negf = !negf;
        end;
      end else begin
        sumpriceinbase1 = sumpriceinbase1 + temp;
        sumpriceincustcur = sumpriceincustcur + tempincustcur;
      end;
//customer and Item/customer statistics have to be decresed beacause half of amount goes to DiscAccount from Discount Matrix
//it works almost like discount
      t = FindVAT(IVrw.VATCode,suminbase1,IVp.InclVAT,IVp.NoTAXonVAT);
      suminbaseinclvat1 = suminbase1 + t; 
      ArtStatUp2(IVrw.ArtCode,IVp.CustCode,IVp.BranchID,"",IVp.TransDate,IVrw.Quant,suminbase1,IVrw.rowGP,temp,negf,icsbasesum,icsgps,icsprice,suminbaseinclvat1);
LSKIPRow:;      
    end;
    if ((IVrw.stp==kInvoiceRowTypePrepayment) and (IVrw.CUPNr!=lastcupno)) then begin
      prepayv = prepayv + IVrw.Sum;    
//      GetIVPrepaidInBase(IVp,i,totsum,prepaybasev);this is not working anymore, ARPayHistVc doesn't exist when invoice stored
      if (IVrw.BasePrice==0) then begin//this happens with old data
        prepaybasev = prepaybasev + MulRateToBase1(IVp.CurncyCode,IVrw.Sum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
      end else begin
        prepaybasev = prepaybasev + IVrw.BasePrice;
      end;
      lastcupno = IVrw.CUPNr;
    end;  
  end;
  if (importcreditnoteupdatef==false) then begin
    if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin    
      if (rwcnt>0) then begin
        MatRowGet(IVp,0,IVrw);
        if (IVrw.stp==kInvoiceRowTypeCredit) then begin
          IV2r.SerNr = IVrw.OrdRow;
          if (ReadFirstMain(IV2r,1,true)) then begin
            if (IV2r.InvType==kInvoiceTypeCash or IV2r.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin
              cashcredit = true;
            end;
          end;
        end;
      end;
    end;
  end;
  if (IVp.FrPrice!=0) then begin
    pri = 0;
    t = MulRateToBase1(IVp.CurncyCode,IVp.FrPrice,fr,to1,to2,b1,b2,DefaultCurRoundOff);
    RecordClear(TMr);
    FindSalesExVat(TMr,IVp.FrVATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,suminbase1);
    t = 1;
    icsprice = pri;
    icsbasesum = suminbase1;
    icsgps = IVp.FrGP;   
    if (IVp.DiscSum!=0) then begin  
      icsgps = IVp.FrGP;
      ts = IVp.FrGP*IVp.DiscPerc;
      ts = ts/100;
      gps2 = gps2 + ts;
      icsgps = icsgps - ts;
      tsum = IVp.FrPrice;
      ts = IVp.FrPrice*IVp.DiscPerc;
      ts = ts/100;
      tsum = tsum - ts;
      ts = MulRateToBase1(IVp.CurncyCode,tsum,fr,to1,to2,b1,b2,DefaultCurRoundOff);
      FindSalesExVat(TMr,IVp.FrVATCode,ts,IVp.InclVAT,IVp.NoTAXonVAT,icsbasesum);
    end;
    t = FindVAT(IVrw.VATCode,suminbase1,IVp.InclVAT,IVp.NoTAXonVAT);
    suminbaseinclvat1 = suminbase1 + t; 
    ArtStatUp2(IVp.FrItem,IVp.CustCode,IVp.BranchID,"",IVp.TransDate,1,suminbase1,IVp.FrGP,pri,negf,icsbasesum,icsgps,icsprice,suminbaseinclvat1);
    gpsinbase1 = gpsinbase1 + IVp.FrGP;
  end;
L88ArtStats:;
  t = 0;
  t2 = IVp.Sum1;
  if (IVp.InclVAT>0) then begin
    t2 = IVp.Sum4 - IVp.Sum3 - IVp.TAX1Sum - IVp.TAX2Sum;
  end;
  if (IVp.DiscSum!=0) then begin
    ts = t2;
    ts = ts*IVp.DiscPerc;
    ts = ts/100;
    basesum2 = MulRateToBase1(IVp.CurncyCode,ts,fr,to1,to2,b1,b2,DefaultCurRoundOff);
    bv2 = MulRateToBase1(IVp.CurncyCode,IVp.DiscSum,fr,to1,to2,b1,b2,DefaultCurRoundOff);
  end;
  sumincustcur = t2;
  suminbase1 = MulRateToBase1(IVp.CurncyCode,t2,fr,to1,to2,b1,b2,DefaultCurRoundOff);
  bv = MulRateToBase1(IVp.CurncyCode,IVp.Sum4,fr,to1,to2,b1,b2,DefaultCurRoundOff);
  bv = bv - b1cashv;
  if (prepayv==IVp.Sum4) then begin
    bv = prepaybasev;
  end;
  bvincustcur = IVp.Sum4 - cashvincustcur;

  if ((IVp.InvType==kInvoiceTypeCash or IVp.InvType==kInvoiceTypeCashInvoiceReceiptPRT) or (cashcredit==true)) then begin    
    t = IVp.Sum4;
    t = t - prepayv;
    bv = prepayv;
    bv2 = blankval;
    paidincustcur = -t;
  end else begin
    t = b1cashv;
//    if (IVp.RetnValue>0) then begin
    if (IVp.RetnValue>0) and (t!=0) then begin//normal Invoices which are negative should be not substracting
      t = t - IVp.RetnValue;
      bv = bv + MulRateToBase1(IVp.CurncyCode,IVp.RetnValue,fr,to1,to2,b1,b2,DefaultCurRoundOff);
      bvincustcur = bvincustcur + IVp.RetnValue;
    end;
    paidincustcur = -t;
  end;
  paidinbase1 = MulRateToBase1(IVp.CurncyCode,paidincustcur,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  if (nonblank(IVp.OrgCust)) then begin
    cust = IVp.OrgCust;
  end else begin
    cust = IVp.CustCode;
  end;
  if (sumpriceflag==true) then begin
    sumpriceinbase1 = suminbase1;
    sumpriceincustcur = sumincustcur;
  end;
  sum4incustcur = IVp.Sum4;
  /*
DiscSum not supoerted any more  and destroys old data
  if (IVp.DiscSum!=0) then begin
     if (sumpriceflag==true) then begin
       sumprice2 = basesum2;
     end;
     suminbase1 = suminbase1 - basesum2;
     sum4incustcur = sum4incustcur - IVp.DiscSum;
     if (t!=0) then begin
       t = t - IVp.DiscSum;
     end;
     gpsinbase1 = gpsinbase1 - gps2;
     bv = bv - bv2;
     sumpriceinbase1 = sumpriceinbase1 - sumprice2;
  end;
  */
  sum4inbase1 = MulRateToBase1(IVp.CurncyCode,sum4incustcur,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  negf = negflag;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
    negf = true;
    if (IVp.Invalid!=0) or (IVp.OKFlag==0) then begin
      negf = false; 
    end;
  end;  
  if (importcreditnoteupdatef) then begin
    negf = !negf;
  end;

  if (prepayv!=0) then begin
    if (prepayv!=IVp.Sum4) then begin
      t2 = MulRateToBase1(IVp.CurncyCode,prepayv,fr,to1,to2,b1,b2,DefaultCurRoundOff);
      bv = bv - (t2 - prepaybasev);
    end;
  end;  
  CustStatUp("IVVc",IVp.SerNr,cust,IVp.CustCode,IVp.BranchID,"","",IVp.TransDate,suminbase1,sum4inbase1,paidinbase1,gpsinbase1,bv,sumpriceinbase1,negf);
  if (nonblank(IVp.CurncyCode)) and (IVp.CurncyCode!=BCb.BaseCur1) then begin
    CustStatUp("IVVc",IVp.SerNr,cust,IVp.CustCode,IVp.BranchID,"",IVp.CurncyCode,IVp.TransDate,sumincustcur,sum4incustcur,paidincustcur,blankval,bv,sumpriceincustcur,negf);
  end;
LArtStats:;
  RETURN;
END;

function string 255 CalcFinRef(record IVVc IVr,var Boolean groupf,var Boolean checksumf)
begin
  string 255 res,invnr,custnr,tstr;
  record CalcRefBlock CRb;
  Boolean rfref;
  Integer i,l;
  
  BlockLoad(CRb);
  invnr = IVr.SerNr;
  custnr = IVr.CustCode;
  
  switch (CRb.RefNoFormat) begin
    case 0:
LCase0:;
      res = invnr & custnr;
      if (CRb.Fillf) then begin
        M4PadString(res,19,"0",true,res);
      end;
    case 1:
      if (CRb.Fillf) then begin
        l = 14 - (len(invnr) + len(custnr));
        for (i = 0; i<l; i = i +1) begin
          invnr = "0" & invnr;
        end;
      end;
      res = custnr & invnr;
    case 2:
      if (CRb.Fillf) then begin
        l = 14 - len(invnr);
        for (i = 0; i<l; i = i +1) begin
          invnr = "0" & invnr;
        end;
      end;
      res = invnr;
    case 3:
      custnr = CRb.CustomNo;
      goto LCase0;
  end;
  
  switch (CRb.RFRefUse) begin
    case 0: rfref = false;
    case 1: rfref = true;
    case 2: rfref = IVr.ExportFlag!=0;
  end;

  if (rfref) then begin
    groupf = false;
    checksumf = false;
    res = CreateInternationalCreditorReference(res);
  end else begin
    groupf = true;
    checksumf = true;
  end;
  CalcFinRef = res;
  return;
end;

procedure RefBG2(record IVVc ivrp,var string res,Boolean group)
BEGIN
  string 255 a,b;
  string 255 addlen;
  Integer i,s1,sm;
  record FactoringBlock fact;
  Boolean locgr,checksumf;
  record CUVc CUr;
  Integer bankfact;
  
  locgr = group;
  checksumf = true;
  CUr.Code = ivrp.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  BlockLoad(fact);
  bankfact = fact.Bank;
  if (CUr.NoFactoringFlag!=0) then begin
    bankfact = 0;
  end;
  switch (bankfact) begin
    case kFactoringFormatNordeaBankFIN: // Merita factoring 
      a = ivrp.SerNr;
      res = "000000000";
      res = Left(res,9-len(a));
      res = res & a;
      if (len(fact.User)==4) then begin
        a = "000020";
      end else begin
        a = "0000000000";
        a = Left(a,10-len(fact.User));
      end;
      a = a & fact.User;
      a = a & res;
/*      
    case kFactoringFormatOsuusPankkiFIN: // OP factoring 
      a = ivrp.SerNr;
      b = "000000000";
      b = Left(b,9-len(a));
      b = b & a;      
      a = "0000000";
      a = Left(a,7-len(fact.User));
      a = a & fact.User;
      a = a & "001";
      a = a & b;
*/      
    case kFactoringFormatOsuusPankkiFIN: // OP factoring 
      a = ivrp.SerNr;
      b = "00000000000";
      b = Left(b,11-len(a));
      b = b & a;      
      a = "00000000";
      a = Left(a,8-len(fact.User));
      a = a & fact.User;
      a = a & b;
    case kFactoringFormatSampoFIN: // Sampo factoring 
      a = ivrp.SerNr;
      res = "000000000";
      res = Left(res,9-len(a));
      res = res & a;
      
      a = fact.User & "1";
      //b = "0000000000";
      //b = Left(b,10-len(a));
      b = a & b;
      
      res = b & res;
      a = Left(res, 20);
    case kFactoringFormatHandelsbankenFIN: // Handelsbanken factoring 
      res = "7000";
      res = res & fact.User;
      a = ivrp.SerNr;
      M4PadString(a,10,"0",true,a);
      res = res & a;      
      a = res;
    case kFactoringFormatFinvoiceFIN:
      a = ivrp.SerNr;
      res = "000000000";
      res = Left(res,9-len(a));
      res = res & a;
      if (len(fact.User)==4) then begin
        a = "000020";
      end else begin
        a = "0000000000";
        a = Left(a,10-len(fact.User));
      end;
      a = a & fact.User;
      a = a & res;
    otherwise //0 = Ingen factoring, 2 = Gjensidige, 3 = Factoring Finans, 5 = Norbanken 
      if (HasLocalization("SWE")==false) then begin
        if (HasLocalization("FIN")) then begin
          res = CalcFinRef(ivrp,locgr,checksumf);
          a = res;
        end else begin
          if (len(ivrp.CustCode)>8) then begin
            goto LRefBG2;
          end;
          res = ivrp.SerNr;
          a = "00000000";
          a = Left(a,8-len(ivrp.CustCode));
          a = a & ivrp.CustCode;
          res = res & a;
          a = res;
        end;
      end else begin
        a = ivrp.SerNr;
        b = "0000000000";
        b = Left(b,10-len(a));
        b = b & a;      
        res = "1111"; // New setting in 3.6 
        a = "0000";
        a = Left(a,4-len(res));
        a = a & res;
        a = a & b;
        a = a & "6"; // Length of String hardcoded to 16 
        CreateSwedishChecksum(a,b);
        locgr = false;
        goto LRefBG2;
      end;
  end;
  if (checksumf) then begin
    for (i = len(a); i>=1; i=i-1) begin
      switch (Mod((len(a)-i),3)) begin
        case 0: sm = 7;
        case 1: sm = 3;
        otherwise sm = 1;
      end;
      s1 = s1 + sm*(asc(Mid(a,i-1,1))-48);
    end;
    sm = Mod(10-Mod(s1,10),10);
    a = a & chr(sm+48);
  end;
LRefBG2:;
  res = "";
  for (i=1; i<=len(a); i=i+1) begin
    if (locgr) then begin
      if ( (Mod((len(a)-i),5)==4) and (i!=1)) then begin
        res = res & " ";
      end;
    end;
    res = res & Mid(a,i-1,1);
  end;
  return;
end;

global
procedure SetFinRef(record IVVc IVp)
BEGIN
  string 255 tstr;
  
  RefBG2(IVp,tstr,true);
  IVp.CalcFinRef = tstr;
  RETURN;
END;

updating procedure ARPaySub1(record IVVc IVp,record ARVc ARp,Boolean arnilf,Boolean invalidf)
BEGIN
  record ARPayVc ARPayr;
  record ARPayHistVc ARPayHistr;
  record ARPayVc oldARPayr;
  record CUVc CUr;
  row IVVc IVrw;
  Integer i,rwcnt;
  Boolean delf,found;
  val rowsum,basesum,valinbase1,rs,coff;
  
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
      rowsum = IVrw.Sum;
      basesum = IVrw.BasePrice;
      if (arnilf==false) then begin
        if (ARp.RVal<0) then begin
          rowsum = -IVrw.Sum;
          basesum = -IVrw.BasePrice;
        end;
      end;
      if (rowsum!=0) then begin
        delf = false;
        ARPayr.CUPNr = IVrw.CUPNr;
        found = ReadFirstMain(ARPayr,1,true);
        RecordCopy(oldARPayr,ARPayr);
        if (found) then begin
          if (rowsum<ARPayr.RVal) then begin
            coff = rowsum/ARPayr.RVal;
            rs = ARPayr.VATVal*coff;
            ARPayr.VATVal = ARPayr.VATVal - rs;
            rs = ARPayr.VATBookVal*coff;
            ARPayr.VATBookVal = ARPayr.VATBookVal - rs;

            rs = ARPayr.TAX1Sum*coff;
            ARPayr.TAX1Sum = ARPayr.TAX1Sum - rs;
            rs = ARPayr.TAX1SumBook*coff;
            ARPayr.TAX1SumBook = ARPayr.TAX1SumBook - rs;
          end else begin
            ARPayr.VATVal = ARPayr.VATVal - IVrw.Price;
            ARPayr.VATBookVal = ARPayr.VATBookVal - MulRateToBase1(IVp.CurncyCode,IVrw.Price,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            ARPayr.TAX1Sum = ARPayr.TAX1Sum - IVrw.TAX1Reb;
            ARPayr.TAX1SumBook = ARPayr.TAX1SumBook - MulRateToBase1(IVp.CurncyCode,IVrw.TAX1Reb,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          end;
        end else begin
          ARPayr.CUPNr = IVrw.CUPNr;
          ARPayHistr.CUPNr = IVrw.CUPNr;
          ARPayHistr.FileName = "IPVc";
          if (ReadFirstMain(ARPayHistr,2,true)) then begin
            ARPayr.OrderNr = ARPayHistr.OrderNr;
            ARPayr.VATVal = ARPayHistr.VATVal;
            ARPayr.VATBookVal = ARPayHistr.VATBookVal;
            ARPayr.TAX1Sum = ARPayHistr.TAX1Sum;
            ARPayr.TAX1SumBook = ARPayHistr.TAX1SumBook;
          end;
          ARPayr.CustCode = IVp.CustCode;
          ARPayr.VATCode = IVrw.VATCode;
          CUr.Code = IVp.CustCode;
          if (ReadFirstMain(CUr,1,true)) then begin
            ARPayr.CustName = CUr.Name;
          end;
          ARPayr.CurncyCode = IVp.CurncyCode;
          ARPayr.RVal = 0;
          ARPayr.BookRVal = 0;
          if (invalidf) then begin
            ARPayr.PayDate = ARPayHistr.TransDate;
          end else begin
            ARPayr.PayDate = IVp.InvDate;
          end;
          if (rowsum<0) then begin
            ARPayr.VATVal = IVrw.Price;
            ARPayr.VATBookVal = MulRateToBase1(IVp.CurncyCode,IVrw.Price,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            ARPayr.TAX1Sum = IVrw.TAX1Reb;
            ARPayr.TAX1SumBook = MulRateToBase1(IVp.CurncyCode,IVrw.TAX1Reb,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          end else begin
            ARPayr.VATVal = -IVrw.Price;
            ARPayr.VATBookVal = -MulRateToBase1(IVp.CurncyCode,IVrw.Price,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            ARPayr.TAX1Sum = -IVrw.TAX1Reb;
            ARPayr.TAX1SumBook = -MulRateToBase1(IVp.CurncyCode,IVrw.TAX1Reb,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          end;
        end;
        if (basesum==0) or (arnilf==false) then begin //we need to use invoice rate 
          valinbase1 = basesum;
          if (valinbase1==0) then begin
//rather original rate or prepayment right ?           
            valinbase1 = MulRateToBase1(IVp.CurncyCode,rowsum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          end;
          if (valinbase1==0) then begin
            valinbase1 = MulRateToBase1(IVp.CurncyCode,rowsum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          end;
        end else begin
          valinbase1 = basesum;
        end;
        if (invalidf) then begin
        end;
        ARPayr.RVal = ARPayr.RVal - rowsum;
        ARPayr.BookRVal = ARPayr.BookRVal - valinbase1;
        if (arnilf==false) then begin
          valinbase1 = MulRateToBase1(IVp.CurncyCode,rowsum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          ARp.RVal = ARp.RVal - rowsum;
          ARp.BookRVal = ARp.BookRVal - valinbase1;
/*//JJ->prepayment bug either this or we need to use invoice rate not prepayment rate or we miss rate gain/loss*/
        end;
        if (ARPayr.RVal==0) then begin delf = true; end;
        if (delf==false) then begin
          if (found) then begin
            if (RecordUpdate(oldARPayr,ARPayr,false)==0) then begin end;
          end else begin
            if (RecordStore(ARPayr,false)) then begin end;
          end;
        end else begin
          if (found==true) then begin
            RecordDelete(oldARPayr);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

updating procedure ARPayHistSub2(record IVVc IVp)
BEGIN
  record BaseCurBlock BCb;
  record ARPayHistVc ARPayHistr;
  record ARPayHistVc ARPayHist2r;
  row IVVc IVrw,IVrw2;
  string 255 curcode;
  Integer i,j,rwcnt;
  val rs,vattot,bookrs;
  val rowsum,rowvat,tax1sum;
  Boolean found;
  vector Boolean vprepf;
  
  BlockLoad(BCb);
  if (nonblank(BCb.StdBaseCur)) then begin
    curcode = BCb.StdBaseCur;
  end else begin
    curcode = BCb.BaseCur1;
  end;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    tax1sum = blankval;
    vattot = blankval;
    rs = blankval;
    bookrs = blankval;
    if (IVrw.stp==kInvoiceRowTypePrepayment and vprepf[IVrw.CUPNr]==false) then begin
      vprepf[IVrw.CUPNr] = true;
      for (j=i;j<rwcnt;j=j+1) begin
        MatRowGet(IVp,j,IVrw2);
        if (IVrw2.stp==kInvoiceRowTypePrepayment) then begin
          if (IVrw.CUPNr==IVrw2.CUPNr) then begin
            rowsum = IVrw2.Sum;
            rowvat = IVrw2.Price;
            rs = rs + rowsum;
            vattot = vattot + rowvat;
            tax1sum = tax1sum + IVrw2.TAX1Reb;
            bookrs = bookrs + IVrw2.BasePrice;
          end;
        end;
      end;
      ARPayHist2r.CUPNr = IVrw.CUPNr;
      ARPayHist2r.FileName = "IPVc";
      found = ReadFirstMain(ARPayHist2r,2,true);
      if (found==false) then begin
        ARPayHist2r.CUPNr = IVrw.CUPNr;
        ARPayHist2r.FileName = "CLInVc";
        found = ReadFirstMain(ARPayHist2r,2,true);
      end;

      ARPayHistr.CUPNr = IVrw.CUPNr;
      ARPayHistr.OrderNr = IVp.OrderNr;
      ARPayHistr.FileName = "IVVc";
      ARPayHistr.SerNr = IVp.SerNr;
      ARPayHistr.TransDate = IVp.TransDate;
      ARPayHistr.CustCode = IVp.CustCode;
      ARPayHistr.CurncyCode = IVp.CurncyCode;
      ARPayHistr.BankCurncy = "";
      ARPayHistr.Val = rs;
      ARPayHistr.VATVal = vattot;
      ARPayHistr.TAX1Sum = tax1sum;
      ARPayHistr.OrderNr = ARPayHist2r.OrderNr;      
      ARPayHistr.ARAcc = IVrw.SalesAcc;
      if (BCb.BaseCur1==IVp.CurncyCode) then begin
        ARPayHistr.BookVal = rs;
        ARPayHistr.VATBookVal = vattot;
      end else begin
        if (IVrw.BasePrice==0) then begin
          ARPayHistr.BookVal = MulRateToBase1(IVp.CurncyCode,rs,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          ARPayHistr.VATBookVal = MulRateToBase1(IVp.CurncyCode,vattot,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
          ARPayHistr.TAX1SumBook = MulRateToBase1(IVp.CurncyCode,tax1sum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
        end else begin
          ARPayHistr.BookVal = bookrs;
          rs = ARPayHistr.VATVal/ARPayHistr.Val;
          ARPayHistr.VATBookVal = (ARPayHistr.BookVal*ARPayHistr.VATVal)/ARPayHistr.Val;
          rs = ARPayHistr.TAX1Sum/ARPayHistr.Val;
          ARPayHistr.TAX1SumBook = (ARPayHistr.BookVal*ARPayHistr.TAX1Sum)/ARPayHistr.Val;
        end;
      end;
      if (RecordStore(ARPayHistr,false)) then begin end;
    end;
  end;
  RETURN;
END;

global
updating procedure ARInstallmentHistAdd(record ARInstallVc oldARIr,record ARInstallVc ARIr,Integer act)
begin
  record ARInstallHistVc ARIHr;
  record ARInstallHistVc oldARIHr;
  
  switch (act) begin
    case Rs_update:
      ARIHr.InvoiceNr = oldARIr.InvoiceNr;
      ARIHr.DueDate = oldARIr.DueDate;
      if (ReadFirstMain(ARIHr,0,true)) then begin
        RecordCopy(oldARIHr,ARIHr);
        ARIHr.InvoiceNr = ARIr.InvoiceNr;
        ARIHr.RVal = ARIr.RVal;
        ARIHr.DueDate = ARIr.DueDate;
        ARIHr.CustCode = ARIr.CustCode;
        ARIHr.ARCurncyCode = ARIr.ARCurncyCode;
        ARIHr.BookRVal = ARIr.BookRVal;
        ARIHr.InstallNr = ARIr.InstallNr;
        RecordUpdate(oldARIHr,ARIHr,false);
      end;
    case Rs_delete:
      ARIHr.InvoiceNr = ARIr.InvoiceNr;
      ARIHr.DueDate = ARIr.DueDate;
      if (ReadFirstMain(ARIHr,0,true)) then begin
        RecordDelete(ARIHr);
      end;
    otherwise
      ARIHr.InvoiceNr = ARIr.InvoiceNr;
      ARIHr.RVal = ARIr.RVal;
      ARIHr.DueDate = ARIr.DueDate;
      ARIHr.CustCode = ARIr.CustCode;
      ARIHr.ARCurncyCode = ARIr.ARCurncyCode;
      ARIHr.BookRVal = ARIr.BookRVal;
      ARIHr.InstallNr = ARIr.InstallNr;
      RecordStore(ARIHr,false);
  end;
  return;
end;

updating procedure IVCalcInstallment(record IVVc IVp,val sump,record PDVc PDr,var LongInt pdaysp,Boolean createsupp,Boolean storeinstf)
BEGIN
  record InstallmentVc Intr;
  row InstallmentVc Insrw;
  record ARInstallVc ARIr;
  record ARInstallVc oldARIr;
  Integer rwcnt,i;
  date tdr,tdp,lasttdr;
  val sum,t;
  Boolean found,delf,firstf;
  record IVVc origIVr;
  string 20 linstcode;
  record PDVc crPDr;
  record JobVc Jobr;  
  val totsumcur,totsumb1;
  
  linstcode = PDr.Installment;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
    origIVr.SerNr = IVp.CredInv;
    if (ReadFirstMain(origIVr,1,true)) then begin 
      crPDr.Code = origIVr.PayDeal;
      if (GetPD(crPDr)) then begin    
        linstcode = crPDr.Installment;
      end;
    end;
  end;
  pdaysp = 0;
  if (sump==0) then begin
    delf = true;
  end else begin
    delf = false;
  end;
  lasttdr = IVp.InvDate;
  Intr.Code = linstcode;
  if (ReadFirstMain(Intr,1,true)) then begin
    firstf = true;
    rwcnt = MatRowCnt(Intr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Intr,i,Insrw);
      switch (Insrw.Type) begin
        case 0: 
          if (firstf) then begin
            tdr = AddDay(IVp.InvDate,PDr.pdays);
            firstf = false;
          end else begin
            tdr = lasttdr;
          end;
        case 1: 
          tdr = lasttdr;
        case 2:
          if (firstf) then begin
            tdr = tdp;
            if (IVp.JobNr>0) then begin
              Jobr.SerNr = IVp.JobNr;
              if (ReadFirstMain(Jobr,1,true)) then begin
                tdr = Jobr.TransDate;
              end;
            end;
          end else begin
            tdr = lasttdr;
          end;
      end;
      if (Insrw.Months!=-1) then begin
        tdr = AddMonth(tdr,Insrw.Months);
      end;
      if (Insrw.Days!=-1) then begin
        tdr = AddDay(tdr,Insrw.Days);
      end;
      if (tdr<IVp.InvDate) then begin
        tdr = lasttdr;
      end;
      lasttdr = tdr;
      if (createsupp) then begin
        if (IVp.CredInv!=-1) then begin
          ARIr.InvoiceNr = IVp.CredInv;
        end else begin
          ARIr.InvoiceNr = IVp.SerNr;
        end;
        ARIr.DueDate = tdr;
        found = ReadFirstMain(ARIr,2,true);
        RecordCopy(oldARIr,ARIr);
        if (found) then begin
        end else begin
          ARIr.InvoiceNr = IVp.SerNr;
          ARIr.DueDate = tdr;
          ARIr.CustCode = IVp.CustCode;
          ARIr.ARCurncyCode = IVp.CurncyCode;
          ARIr.RVal = 0;
          ARIr.BookRVal = 0;
          ARIr.InstallNr = ARIInstallNr(ARIr.InvoiceNr,ARIr.DueDate);
        end;
        if (found and storeinstf) then begin
          if (i==(rwcnt-1)) then begin
            ARIr.RVal = Round(sump - totsumcur,SetRoundModeD(2));
            sum = MulRateToBase1(IVp.CurncyCode,sump,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            ARIr.BookRVal = Round(sum - totsumb1,SetRoundModeD(2));
          end else begin
            PUCalcPerc(sump,Insrw.Prc,t);
            ARIr.RVal = ARIr.RVal + Round(t,SetRoundModeD(2));
            sum = MulRateToBase1(IVp.CurncyCode,sump,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            PUCalcPerc(sum,Insrw.Prc,t);
            ARIr.BookRVal = ARIr.BookRVal + Round(t,SetRoundModeD(2));
          end;
        end else begin
          if (i==(rwcnt-1)) then begin
            ARIr.RVal = Round(sump - totsumcur,SetRoundModeD(2));
            sum = MulRateToBase1(IVp.CurncyCode,sump,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            ARIr.BookRVal = Round(sum - totsumb1,SetRoundModeD(2));
          end else begin
            PUCalcPerc(sump,Insrw.Prc,t);
            ARIr.RVal = Round(t,SetRoundModeD(2));
            sum = MulRateToBase1(IVp.CurncyCode,sump,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
            PUCalcPerc(sum,Insrw.Prc,t);
            ARIr.BookRVal = Round(t,SetRoundModeD(2));
          end;
        end;
        totsumcur = totsumcur + ARIr.RVal;
        totsumb1 = totsumb1 + ARIr.BookRVal;
        if (storeinstf) then begin
          if (delf==false) then begin
            if (found) then begin
              if (RecordUpdate(oldARIr,ARIr,false)==0) then begin
              end;
              ARInstallmentHistAdd(oldARIr,ARIr,Rs_update);
            end else begin
              ARIr.InstallNr = ARIInstallNr(ARIr.InvoiceNr,ARIr.DueDate);
              if (RecordStore(ARIr,false)) then begin
              end;
              ARInstallmentHistAdd(oldARIr,ARIr,Rs_insert);
            end;
          end else begin
            if (found==true) then begin
              RecordDelete(oldARIr);
              ARInstallmentHistAdd(oldARIr,ARIr,Rs_delete);
            end;
          end;
        end else begin
          ARInstallmentHistAdd(oldARIr,ARIr,Rs_insert);
        end;
      end;
    end;
    if (createsupp==false) then begin
      pdaysp = DateDiff(tdr,tdp);
    end;
  end;
  RETURN;
END;

global
updating procedure ARInstallmentAdd(record IVVc IVp,val sump,Boolean storeinstf)
BEGIN
  record PDVc PDr;
  LongInt l;

  PDr.Code = IVp.PayDeal;
  if (GetPD(PDr)) then begin
    l = PDr.pdays;
    IVCalcInstallment(IVp,sump,PDr,l,true,storeinstf);
    PDr.pdays = l;
  end;
  RETURN;
END;

procedure ARPaymentRowSub(record IVVc IVp,var record ARVc ARp)
BEGIN
/*update SubCashRows_IVVc*/
  row IVVc IVrw;
  Integer i,rwcnt;
  Boolean cashf;
  Integer sign;
  
  sign = 1;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
    sign = -1;
  end;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if ((IVrw.stp==kInvoiceRowTypeGiftVoucherPayment) or (IVrw.stp==kInvoiceRowTypeCashPayment) or (IVrw.stp==kInvoiceRowTypeCreditCardPayment) or (IVrw.stp==kInvoiceRowTypeLoyaltyPointsPayment) or (IVrw.stp==kInvoiceRowTypeChequePayment)) then begin
      ARp.RVal = ARp.RVal - sign*IVrw.Sum;
      ARp.BookRVal = ARp.BookRVal - sign*IVrw.Sum;
      cashf = true;
    end;
  end;
  if ((IVp.RetnValue>0 and IVp.Sum4>0) or (IVp.RetnValue<0 and IVp.Sum4<0)) then begin
    ARp.RVal = ARp.RVal + sign*IVp.RetnValue;
  end;
  if (cashf) then begin
/*
nonsense ?     
    if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
      if (ARp.RVal<0) then begin
        ARp.RVal = blankval;
      end;
      if (ARp.BookRVal<0) then begin
        ARp.BookRVal = blankval;
      end;
    end;
*/      
  end;
  RETURN;
END;

global
updating procedure ARAdd1(record IVVc IVp,LongInt InvNr,val PV,Date dtp,Date rdtp,Date rdtp2,Boolean iiflag,Boolean trflg,Boolean invalidf)
BEGIN
  record ARVc ARr;
  record ARVc oldARr;
  Boolean found,delf;
  val valinbase1,arpv;

  arpv = PV;
  if (arpv!=0) then begin
    delf = false;
    ARr.InvoiceNr = InvNr;
    found = ReadFirstMain(ARr,1,true);
    RecordCopy(oldARr,ARr);
    if (found) then begin
    end else begin
      ARr.InvoiceNr = InvNr;
      ARr.CustCode = IVp.CustCode;
      ARr.CustName = IVp.Addr0;
      ARr.ARCurncyCode = IVp.CurncyCode;
      ARr.OfficialSerNr = IVp.OfficialSerNr;
      ARr.RVal = 0;
      ARr.BookRVal = 0;
      ARr.InvDate = IVp.InvDate;
    end;
    if (iiflag==false) then begin
      if (nonblankdate(dtp))  then begin
        ARr.DueDate = dtp;
        ARr.ARRebDate = dtp;
      end;
      if (nonblankdate(rdtp)) then begin
        ARr.ARRebDate = rdtp;
      end;
      if (nonblankdate(rdtp2)) then begin
        ARr.ARRebDate2 = rdtp2;
      end;
    end else begin
    end;
/*    not used
    if (IVp.DiscSum!=0) then begin
//amount which hoes to discaccoutn cannot be in open invoives beacause is booked in another account
      if (arpv<0) then begin
        arpv= arpv + IVp.DiscSum;
      end else begin
        arpv= arpv - IVp.DiscSum;
      end;
    end;
*/    
    valinbase1 = MulRateToBase1(IVp.CurncyCode,arpv,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
    ARr.RVal = ARr.RVal + arpv;
    ARr.BookRVal = ARr.BookRVal + valinbase1;
    ARPaySub1(IVp,ARr,false,invalidf);
    ARPayHistSub2(IVp);
    ARPaymentRowSub(IVp,ARr);
    if (trflg) then begin
      if (IVp.InstallmentInv==1) then begin
        ARInstallmentAdd(IVp,ARr.RVal,true);
      end;
    end;
    if (ARr.RVal==0) then begin delf = true; end;
    if (ARr.RVal<0) then begin 
      if (IVp.InvType!=kInvoiceTypeCredit and IVp.InvType!=kInvoiceTypeCreditSpecialSales) then begin
        ARr.DueDate = "";
        ARr.ARRebDate = "";
        ARr.ARRebDate2 = "";
      end;
    end;    
    if (delf==false) then begin
      if (found) then begin
        if (RecordUpdate(oldARr,ARr,false)==0) then begin
        end;
      end else begin
        if (RecordStore(ARr,false)) then begin
        end;
      end;
    end else begin
      if (found==true) then begin
        RecordDelete(oldARr);
      end;
    end;
  end;
  RETURN;
END;

updating procedure CredInvAR(LongInt origivnr)
BEGIN
  record IVVc IVr;
  record IPrsVc IPrsr;
  Boolean TrHs;
  val t,t2;
  Date RebDate;
  
  IPrsr.IVNr = origivnr;
  IPrsr.TransType = kIPrsTransTypeInvoice;
  TrHs = true;
  while (LoopKey("IVKey",IPrsr,2,TrHs)) begin
    if (IPrsr.IVNr!=origivnr) then begin
      TrHs = false;
    end;
    if (IPrsr.TransType!=kIPrsTransTypeInvoice) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      IVr.SerNr = IPrsr.TransNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        if (IVr.CredInv>IVr.SerNr) then begin
          t = -IVr.Sum4;
          t2 = -IVr.Sum3;
          ARAdd1(IVr,IVr.CredInv,t,IVr.InvDate,RebDate,RebDate,true,false,false);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating procedure InvOK(record IVVc IVp,Boolean trflg,Boolean updateliqinfof)
BEGIN
  record IIBlock IIRec;
  record IVVc lIVr;
  val t,t2;
  Date RebDate,RebDate2;
  record ARVc ARr;
  record AccBlock ARAccRec;
  
  if (IVp.InvType==kInvoiceTypePrepayment) then begin goto LInvOK; end;
  if (blank(IVp.CalcFinRef)) then begin
    SetFinRef(IVp);
  end;
  if (blankdate(IVp.PayDate)) then begin
    PastePDInInv(IVp,"",false);
  end;
  if (trflg) then begin
    BlockLoad(IIRec);
    IVp.OKFlag = 1;
    if (blankdate(IVp.InvDate)) then begin IVp.InvDate = CurrentDate; end;
    if (blank(IVp.IntCode)) then begin
      IVp.IntCode = IIRec.IntRate;//why on OK
    end;
//    CreateLinkToDealers
  end;
  
//  if (IVp.ARonTR==false) then
  switch (IVp.InvType) begin
    case kInvoiceTypeCashInvoiceReceiptPRT:  
      ARPaySub1(IVp,ARr,true,false);
      ARPayHistSub2(IVp);
      IVVcCreateSoldGiftCert(IVp);
    case kInvoiceTypeCash:  
      ARPaySub1(IVp,ARr,true,false);
      ARPayHistSub2(IVp);
      IVVcCreateSoldGiftCert(IVp);
    case kInvoiceTypeCreditSpecialSales: 
      goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
LkInvoiceTypeCredit:;
      t = -IVp.Sum4;
      t2 = -IVp.Sum3;
      if (IVp.CredInv!=-1) then begin
        if (Importing) then begin
          if (IVp.CredInv>IVp.SerNr) then begin
            goto L77InvOK;//do nothing now, it will be updated when importing credited invoice
          end;
        end;
        lIVr.SerNr = IVp.CredInv;
        if (ReadFirstMain(lIVr,1,true)==false) then begin
          goto L77InvOK;
        end;
        if (lIVr.InvType!=kInvoiceTypeCash and lIVr.InvType!=kInvoiceTypeCashInvoiceReceiptPRT) then begin
          ARAdd1(IVp,IVp.CredInv,t,IVp.InvDate,RebDate,RebDate,true,trflg,false);
        end;
      end else begin
        ARAdd1(IVp,IVp.SerNr,t,IVp.PayDate,RebDate,RebDate,false,trflg,false);
      end;
      if (updateliqinfof) then begin
        switch (IVp.InvType) begin
          case kInvoiceTypeCredit:
            UpdateLiqInfoFromIP(IVp.CredInv,IVp.Sum4,IVp.CurncyCode,IVp.BaseSum4,IVp.SerNr,-1,false);
          case kInvoiceTypeCreditSpecialSales:
            UpdateLiqInfoFromIP(IVp.CredInv,IVp.Sum4,IVp.CurncyCode,IVp.BaseSum4,IVp.SerNr,-1,false);
        end;
      end;
    otherwise
      if (IVp.pdrdays==-1) then begin
        RebDate = IVp.PayDate;
      end else begin
        BlockLoad(ARAccRec);
        if (ARAccRec.DueDateBasedOnServDelDate==0) then begin
          RebDate = AddDay(IVp.InvDate,IVp.pdrdays);
        end else begin
          RebDate = AddDay(IVp.ServiceDelDate,IVp.pdrdays);
        end;
        RebDate2 = AddDay(IVp.InvDate,IVp.pdrdays2);
      end;
      if (IVp.Sum4!=0) then begin
        ARAdd1(IVp,IVp.SerNr,IVp.Sum4,IVp.PayDate,RebDate,RebDate2,false,trflg,false);
      end;
      if (Importing) then begin
        CredInvAR(IVp.SerNr);
      end;        
      IVVcCreateSoldGiftCert(IVp);
  end;
L77InvOK:;
  if (trflg) then begin
    IVUpdateStock(IVp,false);
    IVUpdateCostPrice(IVp);
  end;
LInvOK:;
  RETURN;
END;
