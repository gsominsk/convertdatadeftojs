external function val CalculateTotalVATFromTaxMatrix(record TaxMatrixVc,Integer);
external procedure AddRowTaxMatrixToSumTaxMatrix(record TaxMatrixVc,var record TaxMatrixVc,Integer);
external function Boolean UseTaxTemplatesforTaxCalc();
external procedure GetLCPrices(val,string,var string,var string);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure SetupVATBase(var record SMVc,var Integer);
external updating function Boolean NPTSIVCashDClassOnEnterKey(Integer,string,Integer,Integer);
external procedure RestAccDUpdatePrices(var record RestAccVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean IVCashDClasstouchscreenitemEFAfter(Integer,Integer,Boolean);
external function Boolean RestAccDClasstouchscreenitemEFAfter(Integer ,Boolean);
external procedure PUCalcPerc(val,string,var val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function roundmode DefaultRoundMode();
external function Boolean TimeInRange(Time,Time,Time);
external function Boolean ReadRestOpenHours(string,var record RestOpenHoursVc);
external function roundmode SetRoundModeD(Integer);
external function Boolean RestAccVc_PasteCUCode(var record RestAccVc);
external procedure RestAccPriceLookupPasteItem(string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function string 20 GetMenuCode(string);
external function Boolean RestAccVc_PasteArtCode(var record RestAccVc,Integer,record LocalMachineBlock,string,Integer,val,var string);
external procedure RestAccSumup(var record RestAccVc,string);
external procedure RestAccPasteItem(string);
external procedure IVCashPasteItem(string);
external procedure ExtractObj(string,var Integer,var string);

global
procedure ButtonPasteSpecItem()
begin
  record RcVc RepSpec;
  record RestAccVc RestAccr;
  record IVCashVc IVCashr;
  Integer wn,mwn,pos;
  string 255 filename,tstr,artcode,modifierartcode;

  tstr = PushButtonTag;
  ExtractObj(tstr,pos,artcode);
  ExtractObj(tstr,pos,modifierartcode);
  wn = CurWindow;
  mwn = MotherWindow(wn);
  GetWindowRecord(wn,RepSpec);
  if (nonblank(artcode)) then begin
    filename = GetWindowFileName(mwn);
    switch (filename) begin
      case "RestAccVc": GetWindowRecord(mwn,RestAccr);
      case "IVCashVc": GetWindowRecord(mwn,IVCashr);
    end;
    SelectWindow(mwn);
    switch (filename) begin
      case "RestAccVc": 
        PutWindowString(mwn,"touchscreenitem",artcode);
        PutWindowString(mwn,"touchscreenitemqty",1.00);
        PutWindowString(mwn,"touchscreenitemModifier","0");
        RestAccDClasstouchscreenitemEFAfter(mwn,true);

        PutWindowString(mwn,"touchscreenitem",modifierartcode);
        PutWindowString(mwn,"touchscreenitemqty",1.00);
        PutWindowString(mwn,"touchscreenitemModifier","1");
        RestAccDClasstouchscreenitemEFAfter(mwn,true);
        PutWindowString(mwn,"touchscreenitemModifier","0");
      case "IVCashVc": 
        if (TouchScreenInterface) then begin
          PutWindowString(mwn,"touchscreenitem",artcode);
          PutWindowString(mwn,"touchscreenitemqty",1.00);
          DeselectWindow(mwn,false);
          IVCashDClasstouchscreenitemEFAfter(mwn,wn,true);
        end else begin
          IVCashPasteItem(artcode);
        end;
      case "SoftFVc": 
        RestAccPriceLookupPasteItem(artcode);
    end;    
    CloseWindow(wn);
  end;
  return;
end;

global
updating procedure SelectModifiers2WClassPaste()
begin
  Integer wn,mwn;
  record ModifiersVc Modifiersr;
  row ModifiersVc Modifiersrw;
  Integer i,rwcnt;
  vector Integer vgroupitemscnt;
  LongInt lastgroup;
  record RcVc RepSpec;
  string 255 filename;
  record RestAccVc RestAccr;
  record IVCashVc IVCashr;
  Integer selectedrow;
  
  wn = CurWindow;
  GetWindowRecord(wn,RepSpec);
  mwn = MotherWindow(wn);
  if (mwn<=0) then begin 
    goto LSelectModifiers2WClassPaste;
  end;
  filename = GetWindowFileName(mwn);
  switch (filename) begin
    case "RestAccVc": GetWindowRecord(mwn,RestAccr);
    case "IVCashVc": GetWindowRecord(mwn,IVCashr);
  end;  
  Modifiersr.Code = RepSpec.f1;
  if (ReadFirstMain(Modifiersr,1,true)) then begin
    SelectWindow(mwn);
    if (nonblank(Modifiersr.ArtCode)) then begin
      switch (filename) begin
        case "RestAccVc": 
          PutWindowString(mwn,"touchscreenitem",Modifiersr.ArtCode);
          PutWindowString(mwn,"touchscreenitemqty",1.00);
          PutWindowString(mwn,"touchscreenitemModifier","0");
          RestAccDClasstouchscreenitemEFAfter(mwn,true);
        case "IVCashVc": 
          PutWindowString(mwn,"ivcashcommand",Modifiersr.ArtCode);
          NPTSIVCashDClassOnEnterKey(mwn,"ivcashcommand",0,-1);
      end;
    end;
    rwcnt = MatRowCnt(Modifiersr);
    for (i=0;i<rwcnt;i=i+1) begin      
      MatRowGet(Modifiersr,i,Modifiersrw);
      selectedrow = GetWindowInteger(wn,"SelectModifiers2WClass" & Modifiersrw.Group);      
      if (selectedrow==i) then begin
        switch (filename) begin
          case "RestAccVc": 
            PutWindowString(mwn,"touchscreenitem",Modifiersrw.Item);
            PutWindowString(mwn,"touchscreenitemqty",1.00);
            PutWindowString(mwn,"touchscreenitemModifier","1");
            RestAccDClasstouchscreenitemEFAfter(mwn,true);
            PutWindowString(mwn,"touchscreenitemModifier","0");
          case "IVCashVc": 
            PutWindowString(mwn,"ivcashcommand",Modifiersrw.Item);
            NPTSIVCashDClassOnEnterKey(mwn,"ivcashcommand",0,-1);
          case "SoftFVc": 
        end;    
      end;
    end;
  end;

LSelectModifiers2WClassPaste:;  
  CloseWindow(wn);
  return;
end;

global
function string 40 ItemButtonsTClassSpecPasteName(Integer wn,string defpsname)
begin
  record ItemButtonsBlock ItemButtonsRec;
  row ItemButtonsBlock ItemButtonsrw;
  string 255 psname;
  Integer rownr;
  
  GetWindowRecord(wn,ItemButtonsRec);
  rownr = WindowActiveRow(wn);
  psname = defpsname;
  MatRowGet(ItemButtonsRec,rownr,ItemButtonsrw);
  if (defpsname=="INSClass") then begin
    switch (ItemButtonsrw.ButtonType) begin
      case 0: psname = "ForSaleINSClass";
      case 1: psname = "ModifiersSClass";
      case 2: 
        MessageBox(20158,"");
        psname = "";
    end;
  end;
  ItemButtonsTClassSpecPasteName = psname;
  return;
end;


function Integer MatchBiggestItem(array string items,Integer size,var record RestAccVc RestAccr)
begin
  row RestAccVc RestAccrw;
  val res,maxprice;
  Integer rw,rwcnt,i,rownr;
  
  maxprice = -1;
  rownr = -1;
  rwcnt = MatRowCnt(RestAccr);
  for (i=0; i<size; i=i+1) begin
    for (rw=0; rw<rwcnt; rw=rw+1) begin
      MatRowGet(RestAccr,rw,RestAccrw);
      if (RestAccrw.stp==1) then begin
        if (RestAccrw.ArtCode==items[i] and RestAccrw.Quant>0) then begin
          if (maxprice<RestAccrw.Price) then begin
            maxprice = RestAccrw.Price;
            rownr = rw;
          end;
        end;
      end;
    end;
  end;
  if (rownr>-1) then begin
    MatRowGet(RestAccr,rownr,RestAccrw);
    RestAccrw.Quant = RestAccrw.Quant-1;
    MatRowPut(RestAccr,rownr,RestAccrw);
  end;
  MatchBiggestItem = rownr;
  return;
end;

procedure GroupRestAccRows(record RestAccVc RestAccr,record BarMenuVc BarMenur,array Integer rows,var Integer size)
begin
  row RestAccVc RestAccrw;
  val price;
  Integer rw;
  Integer i,rwcnt;
  record LocalMachineBlock LMb;
  string 255 inwarning;

  BlockLoad(LMb);
  rwcnt = MatRowCnt(RestAccr);
  ClearRow(RestAccr,RestAccrw,2);
  MatRowPut(RestAccr,rwcnt,RestAccrw);
  for (i = 0; i < size; i = i +1) begin
    MatRowGet(RestAccr,rows[i],RestAccrw);
    if (RestAccrw.stp==1) then begin
      RestAccrw.Quant = -1;
      price = price + RestAccrw.Price;
    end;
//    MatRowPut(RestAccr,MatRowCnt(RestAccr),RestAccrw);
  end;
  
  RestAccrw.ArtCode = BarMenur.DiscountItem;
  rwcnt = MatRowCnt(RestAccr);
  MatRowPut(RestAccr,rwcnt,RestAccrw);
  RestAccVc_PasteArtCode(RestAccr,rwcnt,LMb,"",0,1.00,inwarning);
  MatRowGet(RestAccr,rwcnt,RestAccrw);
  RestAccrw.Quant = -1;
  RestAccrw.Price = price;
  MatRowPut(RestAccr,rwcnt,RestAccrw);
  
  RestAccrw.ArtCode = BarMenur.SalesItem;
  rwcnt = MatRowCnt(RestAccr);
  MatRowPut(RestAccr,rwcnt,RestAccrw);
  RestAccVc_PasteArtCode(RestAccr,rwcnt,LMb,"",0,1.00,inwarning);
  MatRowGet(RestAccr,rwcnt,RestAccrw);
  RestAccrw.Quant = 1;
  RestAccrw.Price = BarMenur.Amount;
  MatRowPut(RestAccr,rwcnt,RestAccrw);
  return;
end;

procedure RestAccGroupRec(var record RestAccVc RestAccr,var record RestAccVc tRestAccr,var record BarMenuVc BarMenur)
begin 
  record BarMenuVc tBarMenur;
  record RestAccVc tRestAccr2;
  row BarMenuVc BarMenurw;
  array string 20 items;
  array Integer rows;
  array Integer qties;
  Integer size2;
  Integer size;
  string 20 menugr;
  string 20 itemcode;
  Integer rw;
  Integer i,rwcnt;
  Integer rownr;
  boolean TrHs;
  Integer wn;
  
  TrHs = true;
  RecordCopy(tRestAccr2,tRestAccr);
  While (TrHs) begin
    RecordCopy(tBarMenur,BarMenur);
    rwcnt = MatRowCnt(tBarMenur);
    size2 = 0;
    while (rwcnt>0) begin
      menugr = "";
      size = 0;
      for (rw = 0; rw< rwcnt; rw = rw +1) begin
        MatRowGet(tBarMenur,rw,BarMenurw);
        if (menugr=="") then begin
          menugr = BarMenurw.RowGroup;
        end;
        if (menugr==BarMenurw.RowGroup) then begin
          items[size] = BarMenurw.ArtCode;
          size = size + 1;
          MatRowDelete(tBarmenur,rw);
          rw = rw -1;
          rwcnt = rwcnt -1;
        end;
      end;
      rownr = MatchBiggestItem(items,size,tRestAccr);
      if (rownr==-1) then begin
        RecordCopy(tRestAccr,tRestAccr2);
        goto LExit;
      end;
      rows[size2] = rownr;
      size2 = size2 +1;
      rwcnt = MatRowCnt(tBarMenur);
    end;
    if size2 > 0 then begin
      GroupRestAccRows(RestAccr,tBarMenur,rows,size2);
      RecordCopy(tRestAccr2,tRestAccr);
    end;
  end;
LExit:;
  return;
end;

procedure RestAccGroupItems(var record RestAccVc RestAccr,record ItemButtonsBlock ItemButtonsRec)
begin
  record RestAccVc tRestAccr;
  record BarMenuVc BarMenur;
  row ItemButtonsBlock ItemButtonsrw;
  array string 20 menucodes;
  Integer size;
  Integer rw;
  Integer i,rwcnt;
  Integer wn;
  
  size = 0;
  rwcnt = MatRowCnt(ItemButtonsRec);
  for (rw = 0; rw <rwcnt; rw =rw +1) begin
    MatRowGet(ItemButtonsRec,rw,ItemButtonsrw);
    if (ItemButtonsrw.ButtonType==2) then begin
      menucodes[size] = GetMenuCode(ItemButtonsrw.ArtCode);
      size = size + 1;
    end;
  end;
  RecordCopy(tRestAccr,RestAccr);
  while (LoopKey("Sorting",BarMenur,1,true)) begin
    for (i = 0; i < size; i = i +1) begin
      if (menucodes[i]==BarMenur.Code) then begin
        RestAccGroupRec(RestAccr,tRestAccr,BarMenur);
      end;
    end;
  end;
  return;
end;

global 
procedure RestAccGroupItemsDsm()
begin
  record ItemButtonsBlock ItemButtonsRec;
  record RestAccVc RestAccr;
  integer wn;
  
  wn = curwindow;
  BlockLoad(ItemButtonsRec);
  GetWindowRecord(wn,RestAccr);
  RestAccGroupItems(RestAccr,ItemButtonsRec);
  RestAccSumup(RestAccr,"");
  PutWindowRecord(wn,RestAccr);
  return;
end;

global
procedure SelectModifiersClassCancel()
begin
  Integer wn;
  
  wn = CurWindow;
  CloseWindow(wn);
  return;
end;

global
procedure RestBarMenuItem(integer menunr,integer itemnr)
begin
  record BarMenuVc BarMenur;
  row BarMenuVc BarMenurw;
  string 10 menus;
  
  menus = menunr;
  BarMenur.Code = GetMenuCode(menus);
  if (ReadFirstMain(BarMenur,1,true)) then begin
    MatRowGet(BarMenur,itemnr-1,BarMenurw);
    RestAccPasteItem(BarMenurw.ArtCode);
  end;
  return;
end;

// Not the most beautiful code in the world.....
global
procedure RestBarMenu1Item1()
begin
  RestBarMenuItem(1,1);
  return;
end;

global
procedure RestBarMenu1Item2()
begin
  RestBarMenuItem(1,2);
  return;
end;

global
procedure RestBarMenu1Item3()
begin
  RestBarMenuItem(1,3);
  return;
end;

global
procedure RestBarMenu1Item4()
begin
  RestBarMenuItem(1,4);
  return;
end;

global
procedure RestBarMenu1Item5()
begin
  RestBarMenuItem(1,5);
  return;
end;

global
procedure RestBarMenu1Item6()
begin
  RestBarMenuItem(1,6);
  return;
end;

global
procedure RestBarMenu1Item7()
begin
  RestBarMenuItem(1,7);
  return;
end;

global
procedure RestBarMenu1Item8()
begin
  RestBarMenuItem(1,8);
  return;
end;

global
procedure RestBarMenu1Item9()
begin
  RestBarMenuItem(1,9);
  return;
end;

global
procedure RestBarMenu1Item10()
begin
  RestBarMenuItem(1,10);
  return;
end;

global
procedure RestBarMenu1Item11()
begin
  RestBarMenuItem(1,11);
  return;
end;

global
procedure RestBarMenu1Item12()
begin
  RestBarMenuItem(1,12);
  return;
end;

global
procedure RestBarMenu1Item13()
begin
  RestBarMenuItem(1,13);
  return;
end;

global
procedure RestBarMenu1Item14()
begin
  RestBarMenuItem(1,14);
  return;
end;

global
procedure RestBarMenu1Item15()
begin
  RestBarMenuItem(1,15);
  return;
end;

global
procedure RestBarMenu1Item16()
begin
  RestBarMenuItem(1,16);
  return;
end;

global
procedure RestBarMenu2Item1()
begin
  RestBarMenuItem(2,1);
  return;
end;

global
procedure RestBarMenu2Item2()
begin
  RestBarMenuItem(2,2);
  return;
end;

global
procedure RestBarMenu2Item3()
begin
  RestBarMenuItem(2,3);
  return;
end;

global
procedure RestBarMenu2Item4()
begin
  RestBarMenuItem(2,4);
  return;
end;

global
procedure RestBarMenu2Item5()
begin
  RestBarMenuItem(2,5);
  return;
end;

global
procedure RestBarMenu2Item6()
begin
  RestBarMenuItem(2,6);
  return;
end;

global
procedure RestBarMenu2Item7()
begin
  RestBarMenuItem(2,7);
  return;
end;

global
procedure RestBarMenu2Item8()
begin
  RestBarMenuItem(2,8);
  return;
end;

global
procedure RestBarMenu2Item9()
begin
  RestBarMenuItem(2,9);
  return;
end;

global
procedure RestBarMenu2Item10()
begin
  RestBarMenuItem(2,10);
  return;
end;

global
procedure RestBarMenu2Item11()
begin
  RestBarMenuItem(2,11);
  return;
end;

global
procedure RestBarMenu2Item12()
begin
  RestBarMenuItem(2,12);
  return;
end;

global
procedure RestBarMenu2Item13()
begin
  RestBarMenuItem(2,13);
  return;
end;

global
procedure RestBarMenu2Item14()
begin
  RestBarMenuItem(2,14);
  return;
end;

global
procedure RestBarMenu2Item15()
begin
  RestBarMenuItem(2,15);
  return;
end;

global
procedure RestBarMenu2Item16()
begin
  RestBarMenuItem(2,16);
  return;
end;

global
procedure RestBarMenu3Item1()
begin
  RestBarMenuItem(3,1);
  return;
end;

global
procedure RestBarMenu3Item2()
begin
  RestBarMenuItem(3,2);
  return;
end;

global
procedure RestBarMenu3Item3()
begin
  RestBarMenuItem(3,3);
  return;
end;

global
procedure RestBarMenu3Item4()
begin
  RestBarMenuItem(3,4);
  return;
end;

global
procedure RestBarMenu3Item5()
begin
  RestBarMenuItem(3,5);
  return;
end;

global
procedure RestBarMenu3Item6()
begin
  RestBarMenuItem(3,6);
  return;
end;

global
procedure RestBarMenu3Item7()
begin
  RestBarMenuItem(3,7);
  return;
end;

global
procedure RestBarMenu3Item8()
begin
  RestBarMenuItem(3,8);
  return;
end;

global
procedure RestBarMenu3Item9()
begin
  RestBarMenuItem(3,9);
  return;
end;

global
procedure RestBarMenu3Item10()
begin
  RestBarMenuItem(3,10);
  return;
end;

global
procedure RestBarMenu3Item11()
begin
  RestBarMenuItem(3,11);
  return;
end;

global
procedure RestBarMenu3Item12()
begin
  RestBarMenuItem(3,12);
  return;
end;

global
procedure RestBarMenu3Item13()
begin
  RestBarMenuItem(3,13);
  return;
end;

global
procedure RestBarMenu3Item14()
begin
  RestBarMenuItem(3,14);
  return;
end;

global
procedure RestBarMenu3Item15()
begin
  RestBarMenuItem(3,15);
  return;
end;

global
procedure RestBarMenu3Item16()
begin
  RestBarMenuItem(3,16);
  return;
end;

global
procedure RestBarMenu4Item1()
begin
  RestBarMenuItem(4,1);
  return;
end;

global
procedure RestBarMenu4Item2()
begin
  RestBarMenuItem(4,2);
  return;
end;

global
procedure RestBarMenu4Item3()
begin
  RestBarMenuItem(4,3);
  return;
end;

global
procedure RestBarMenu4Item4()
begin
  RestBarMenuItem(4,4);
  return;
end;

global
procedure RestBarMenu4Item5()
begin
  RestBarMenuItem(4,5);
  return;
end;

global
procedure RestBarMenu4Item6()
begin
  RestBarMenuItem(4,6);
  return;
end;

global
procedure RestBarMenu4Item7()
begin
  RestBarMenuItem(4,7);
  return;
end;

global
procedure RestBarMenu4Item8()
begin
  RestBarMenuItem(4,8);
  return;
end;

global
procedure RestBarMenu4Item9()
begin
  RestBarMenuItem(4,9);
  return;
end;

global
procedure RestBarMenu4Item10()
begin
  RestBarMenuItem(4,10);
  return;
end;

global
procedure RestBarMenu4Item11()
begin
  RestBarMenuItem(4,11);
  return;
end;

global
procedure RestBarMenu4Item12()
begin
  RestBarMenuItem(4,12);
  return;
end;

global
procedure RestBarMenu4Item13()
begin
  RestBarMenuItem(4,13);
  return;
end;

global
procedure RestBarMenu4Item14()
begin
  RestBarMenuItem(4,14);
  return;
end;

global
procedure RestBarMenu4Item15()
begin
  RestBarMenuItem(4,15);
  return;
end;

global
procedure RestBarMenu4Item16()
begin
  RestBarMenuItem(4,16);
  return;
end;

global
procedure RestPMOtherPayRemote_RestAcc(var record RestAccVc RestAccp,string pmcode,Integer rowstp)
begin
  row RestAccVc RestAccrw;
  string 255 tstr;
  record DefCashBlock DefCashRec;
  val fr,to1,to2,br1,br2;
  Integer rownr;

  BlockLoad(DefCashRec);
  ClearRow(RestAccp,RestAccrw,rowstp); 
  tstr = RestAccrw.CurncyCode;
  GetFullCurncyRate(tstr,RestAccp.TransDate,fr,to1,to2,br1,br2);
  RestAccrw.CurncyCode = tstr;
  RestAccrw.FrRate = fr;
  RestAccrw.ToRateB1 = to1; 
  RestAccrw.ToRateB2 = to2;
  RestAccrw.BaseRate1 = br1;
  RestAccrw.BaseRate2 = br2;      
  RestAccrw.PayMode = pmcode;      
  if (blank(pmcode)) then begin
    RestAccrw.PayMode = DefCashRec.DefCashPayMode;      
  end;
  rownr = MatRowCnt(RestAccp);
  MatRowPut(RestAccp,rownr,RestAccrw);
  return;
end;

global
procedure RestAccVc_PasteLoyaltyCardNr(var record RestAccVc RestAccr)
begin 
  record LoyaltyCardVc LoyaltyCardr;
  string 255 warning;
  string 5 PLCode,RebCode;
  boolean pricechange;
  boolean testf;
  string 20 oldcust;
  record LocalMachineBlock lmr;
  integer err;

  BlockLoad(lmr);
  pricechange = false;
  LoyaltyCardr.SerNr = RestAccr.LoyaltyCardNr;
  if (ReadFirstMain(LoyaltyCardr,1,true)) then begin 
    testf = true;
    if (LoyaltyCardr.ExpiryDate<RestAccr.TransDate) and nonblank(LoyaltyCardr.ExpiryDate) then begin
      testf = false;
    end;
    if (LoyaltyCardr.StartDate>RestAccr.TransDate)   then begin
      testf = false;
    end;
    if (testf) then begin 
      oldcust = RestAccr.CUCode;
      RestAccr.CUCode = LoyaltyCardr.CustCode;
      if (RestAccr.CUCode!=oldcust) then begin 
        if (RestAccVc_PasteCUCode(RestAccr)) then begin
        end;
      end;
      RestAccr.LoyaltyCardNr = LoyaltyCardr.SerNr;
      RestAccr.LCMLevel = LoyaltyCardr.LCMLevel;
      RestAccr.Points = 0;      
      //if (LoyaltyCardr.PointsBalance<>0) then begin
        GetLCPrices(LoyaltyCardr.PointsBalance,LoyaltyCardr.LCMLevel,PLCode,RebCode);
        if (nonblank(PLCode) and (RestAccr.PriceList<>PLCode)) then begin 
          RestAccr.PriceList = PLCode;
          pricechange = true;
        end;
        if (nonblank(RebCode) and (RestAccr.RebCode<>RebCode)) then begin 
          RestAccr.RebCode = RebCode;
          pricechange = true;
        end;
        if (MatRowCnt(RestAccr)>0) then begin 
         RestAccDUpdatePrices(RestAccr);
        end;  
      //end;  
    end else begin
      RestAccr.LCMLevel = "";
      RestAccr.Points = 0;
    end;
  end else begin 
    RestAccr.LCMLevel = "";
    RestAccr.Points = 0;
  end;
  return;
end;

global
procedure CalculateRestAccVcPoints(var record RestAccVc RestAccr)
begin 
  record LoyaltyPointsVc LPr;
  row LoyaltyPointsVc LPrw;
  Integer li,lrwcnt;
  val t,sum;
  record LocLoyaltyPointsVc LLPr;
  row LocLoyaltyPointsVc LLPrw;
  Boolean found,testf,calculatedf;
  row RestAccVc RestAccrw;
  Integer i,rwcnt;
  record INVc INr;
  roundmode rnd;

  RestAccr.Points = blankval;
  if (nonblank(RestAccr.LoyaltyCardNr)) then begin
    rnd = DefaultValRoundoff;
    rnd.decimals = 0;
    rnd.mode = kRoundingModeTruncate;

    LLPr.Location = RestAccr.Location;
    LLPr.LCMLevel = RestAccr.LCMLevel;
    found = ReadFirstMain(LLPr,2,true);
    if (found==false) then begin
      LLPr.Location = RestAccr.Location;
      found = ReadFirstMain(LLPr,1,true);
    end;
    rwcnt = MatRowCnt(RestAccr);
    t = RestAccr.Sum4;
    if (found) then begin
      if (LLPr.MinAmount>0) then begin
        if (t<LLPr.MinAmount) then begin
          goto LCalculateRestAccVcPoints;
        end;
      end;
      lrwcnt = MatRowCnt(LLPr);
      if (lrwcnt==0) then begin
        RestAccr.Points = (LLPr.Points/LLPr.Amount) * Round(t,rnd);
      end else begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(RestAccr,i,RestAccrw);
          if (RestAccrw.stp==kInvoiceRowTypeNormal) or (RestAccrw.stp==kInvoiceRowTypeStructuredItemComponent) or (RestAccrw.stp==kInvoiceRowTypeVoid) then begin
            sum = RestAccrw.Sum;
            if (RestAccrw.stp==kInvoiceRowTypeVoid) then begin
              sum = -sum;
            end;
            calculatedf = false;
            for (li=0;li<lrwcnt;li=li+1) begin
              MatRowGet(LLPr,li,LLPrw);
              rnd = DefaultValRoundoff;
              rnd.decimals = LLPrw.RndTo;
              rnd.mode = kRoundingModeTruncate;
              testf = false;
              switch (LLPrw.CodeType) begin
                case 0:
                  if (ReadFirstItem(RestAccrw.ArtCode,INr,true,true)) then begin 
                    if (INr.Group==LLPrw.ITCode) then begin
                      testf = true;
                    end;  
                  end;
                case 1:
                  if (RestAccrw.ArtCode==LLPrw.ITCode) then begin
                    testf = true;
                  end;  
              end;
              if (testf) then begin
                t = sum;
                RestAccr.Points = RestAccr.Points + (LLPrw.Points/LLPrw.Amount) * Round(t,rnd);
                li = lrwcnt;
                calculatedf = true;
              end;
            end;
            if (calculatedf==false) then begin
              t = sum;
              RestAccr.Points = RestAccr.Points + (LLPr.Points/LLPr.Amount) * Round(t,rnd);
            end;
          end;
        end;
      end;
    end else begin
      LPr.LCMLevel = RestAccr.LCMLevel;
      found = ReadFirstMain(LPr,1,true);
      if (found==false) then begin
        LPr.LCMLevel = "";
        found = ReadFirstMain(LPr,1,true);
      end;
      if (found) then begin
        if (LPr.MinAmount>0) then begin
          if (t<LPr.MinAmount) then begin
            goto LCalculateRestAccVcPoints;
          end;
        end;
        lrwcnt = MatRowCnt(LPr);
        if (lrwcnt==0) then begin    
          RestAccr.Points = (LPr.Points/LPr.Amount) * Round(t,SetRoundModeD(0));
        end else begin
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(RestAccr,i,RestAccrw);
            if (RestAccrw.stp==kInvoiceRowTypeNormal) or (RestAccrw.stp==kInvoiceRowTypeStructuredItemComponent) or (RestAccrw.stp==kInvoiceRowTypeVoid) then begin
              sum = RestAccrw.Sum;
              if (RestAccrw.stp==kInvoiceRowTypeVoid) then begin
                sum = -sum;
              end;
              calculatedf = false;
              for (li=0;li<lrwcnt;li=li+1) begin
                MatRowGet(LPr,li,LPrw);
                rnd = DefaultValRoundoff;
                rnd.decimals = LLPrw.RndTo;
                rnd.mode = kRoundingModeTruncate;
                testf = false;
                switch (LPrw.CodeType) begin
                  case 0:
                    if (ReadFirstItem(RestAccrw.ArtCode,INr,true,true)) then begin 
                      if (INr.Group==LPrw.ITCode) then begin
                        testf = true;
                      end;  
                    end;
                  case 1:
                    if (RestAccrw.ArtCode==LPrw.ITCode) then begin
                      testf = true;
                    end;  
                end;
                if (testf) then begin
                  t = sum;
                  RestAccr.Points = RestAccr.Points + (LPrw.Points/LPrw.Amount) * Round(t,rnd);
                  calculatedf = true;
                  li = lrwcnt;
                end;
              end;
              if (calculatedf==false) then begin
                t = sum;
                RestAccr.Points = RestAccr.Points + (LPr.Points/LPr.Amount) * Round(t,rnd);
              end;
            end;
          end;        
        end;
      end;
    end;
  end;  
LCalculateRestAccVcPoints:;  
  return;
end; 

function val HappyHourQty(val qty)
begin
  val res,hhq;
  
  res = qty;
  while (res>=2) begin
    res = res - 2;
    hhq = hhq + 1;
  end;
  if (res==1) then begin hhq = hhq + 1; end;
  HappyHourQty = hhq;
  return;
end;

global
procedure RestAccSumup_TaxTemplate(var record RestAccVc RestAccp,string fieldnamechanged)
begin
  val sum,rs,diff;
  Integer i,rwcnt;
  row RestAccVc RestAccrw;
  val qty,tax1sum;
  Boolean happyf;
  record RestOpenHoursVc ROHr;
  record SMVc VATr;
  Integer vatcnt;
  roundmode roundlines,rndtotal,rndvat;
  record BaseCurBlock BCb;
  record TaxMatrixVc TMr;
  row TaxMatrixVc TMrw;
  record TaxMatrixVc sumTMr;
  
  BlockLoad(BCb);
  ReadRestOpenHours(RestAccp.MachineName,ROHr);
  if ((nonblanktime(ROHr.HHMonStart)) and (nonblanktime(ROHr.HHMonEnd))) then begin
    if (TimeInRange(RestAccp.TransTime,ROHr.HHMonStart,ROHr.HHMonEnd)) then begin
      happyf = true;
    end;
  end;  
  UnpackFieldMatrix(RestAccp,"TaxMatrix",sumTMr);
  RecordClear(sumTMr);
  RestAccp.TendValue = blankval;
  rwcnt = MatRowCnt(RestAccp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    if (RestAccrw.ovst==0) then begin
    switch (RestAccrw.stp) begin
      case kInvoiceRowTypeNormal:
        if (happyf==false) then begin
          rs = RestAccrw.Sum;
        end else begin
          rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
        end;
        rs = Round(rs,DefaultRoundMode);
        sum = sum + rs;
        UnpackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
        AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,RestAccp.InclVAT);
      case 3:
        if (happyf==false) then begin
          rs = -RestAccrw.Sum;
        end else begin
          rs = -HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
        end;
        rs = Round(rs,DefaultRoundMode);
        sum = sum + rs;
        UnpackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
        AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,RestAccp.InclVAT);
//        AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
      case kInvoiceRowTypeGiftVoucherPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeLoyaltyPointsPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeCashPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeChequePayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeCreditCardPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
    end;
    end;
  end;
  RestAccp.Sum3 = CalculateTotalVATFromTaxMatrix(sumTMr,RestAccp.InclVAT);
  PackFieldMatrix(RestAccp,"TaxMatrix",sumTMr);

  GetCurncyRoundoff(BCb.BaseCur1,"","RestAccVc",rndtotal,roundlines,rndvat);
  RestAccp.Sum3 = Round(RestAccp.Sum3,rndvat);
  RestAccp.Sum1 = Round(sum,rndtotal);
  if (RestAccp.InclVAT==kBasePriceNotInclVAT) then begin
    sum = sum + RestAccp.Sum3;
  end;
  RestAccp.Sum4 = Round(sum+RestAccp.ServCharge,rndtotal);
  PUCalcPerc(RestAccp.Sum1,RestAccp.Discount,rs);
  RestAccp.Sum4 = RestAccp.Sum4 - rs;
  RestAccp.Sum1 = Round(RestAccp.Sum1,rndtotal);
  RestAccp.Sum4 = Round(RestAccp.Sum4,rndtotal);
  RestAccp.Sum0 = sum + RestAccp.ServCharge - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      RestAccp.TipValue = blankval; 
    case "TipValue":
      RestAccp.RetValue = blankval; 
    otherwise
      RestAccp.RetValue = blankval; 
      RestAccp.TipValue = blankval; 
  end;
  RestAccp.RemValue = blankval;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.CashValue;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid2;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid3;
  diff = RestAccp.TendValue - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.RetValue>diff) then begin
          RestAccp.RetValue = diff;
          RestAccp.TipValue = blankval;
        end else begin
          RestAccp.TipValue = diff - RestAccp.RetValue;
        end;
      end;
    case "TipValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.TipValue>diff) then begin
          RestAccp.TipValue = diff;
          RestAccp.RetValue = blankval;
        end else begin
          RestAccp.RetValue = diff - RestAccp.TipValue;
        end;
      end;
    otherwise
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
      end else begin
        RestAccp.RetValue = diff;
      end;
      RestAccp.RetValue = RestAccp.RetValue - RestAccp.TipValue;
  end;
  return;
end;

global
procedure RestAccSumup(var record RestAccVc RestAccp,string fieldnamechanged)
begin
  val sum,rs,diff;
  Integer i,rwcnt;
  row RestAccVc RestAccrw;
  val qty,tax1sum;
  Boolean happyf;
  record RestOpenHoursVc ROHr;
  record SMVc VATr;
  Integer vatcnt;
  roundmode roundlines,rndtotal,rndvat;
  record BaseCurBlock BCb;
  
  if (UseTaxTemplatesforTaxCalc) then begin
    RestAccSumup_TaxTemplate(RestAccp,fieldnamechanged);
    goto LRestAccSumup;
  end;
  BlockLoad(BCb);
  ReadRestOpenHours(RestAccp.MachineName,ROHr);
  if ((nonblanktime(ROHr.HHMonStart)) and (nonblanktime(ROHr.HHMonEnd))) then begin
    if (TimeInRange(RestAccp.TransTime,ROHr.HHMonStart,ROHr.HHMonEnd)) then begin
      happyf = true;
    end;
  end;  
  SetupVATBase(VATr,vatcnt);
  RestAccp.TendValue = blankval;
  rwcnt = MatRowCnt(RestAccp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    if (RestAccrw.ovst==0) then begin
    switch (RestAccrw.stp) begin
      case kInvoiceRowTypeNormal:
        if (happyf==false) then begin
          rs = RestAccrw.Sum;
        end else begin
          rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
        end;
        rs = Round(rs,DefaultRoundMode);
        sum = sum + rs;
        AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,RestAccp.InclVAT,0);
      case 3:
        if (happyf==false) then begin
          rs = -RestAccrw.Sum;
        end else begin
          rs = -HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
        end;
        rs = Round(rs,DefaultRoundMode);
        sum = sum + rs;
        AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,RestAccp.InclVAT,0);
      case kInvoiceRowTypeGiftVoucherPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeLoyaltyPointsPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeCashPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeChequePayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      case kInvoiceRowTypeCreditCardPayment:
        RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
    end;
    end;
  end;
  CalcVATBaseVAT(VATr,RestAccp.InclVAT,0,vatcnt,RestAccp.Sum3,tax1sum);
  GetCurncyRoundoff(BCb.BaseCur1,"","RestAccVc",rndtotal,roundlines,rndvat);  
//  RestAccp.ServCharge = GetServiceCharge(RestAccp,LMb,true); moved to item paste to get rid of one server msg
  RestAccp.Sum3 = Round(RestAccp.Sum3,rndvat);
  RestAccp.Sum1 = Round(sum,rndtotal);
  if (RestAccp.InclVAT==kBasePriceNotInclVAT) then begin
    sum = sum + RestAccp.Sum3;
  end;
  RestAccp.Sum4 = Round(sum+RestAccp.ServCharge,rndtotal);
  PUCalcPerc(RestAccp.Sum1,RestAccp.Discount,rs);
  RestAccp.Sum4 = RestAccp.Sum4 - rs;
  RestAccp.Sum1 = Round(RestAccp.Sum1,rndtotal);
  RestAccp.Sum4 = Round(RestAccp.Sum4,rndtotal);
  RestAccp.Sum0 = sum + RestAccp.ServCharge - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      RestAccp.TipValue = blankval; 
    case "TipValue":
      RestAccp.RetValue = blankval; 
    otherwise
      RestAccp.RetValue = blankval; 
      RestAccp.TipValue = blankval; 
  end;
  RestAccp.RemValue = blankval;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.CashValue;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid2;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid3;
  diff = RestAccp.TendValue - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.RetValue>diff) then begin
          RestAccp.RetValue = diff;
          RestAccp.TipValue = blankval;
        end else begin
          RestAccp.TipValue = diff - RestAccp.RetValue;
        end;
      end;
    case "TipValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.TipValue>diff) then begin
          RestAccp.TipValue = diff;
          RestAccp.RetValue = blankval;
        end else begin
          RestAccp.RetValue = diff - RestAccp.TipValue;
        end;
      end;
    otherwise
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
      end else begin
        RestAccp.RetValue = diff;
      end;
      RestAccp.RetValue = RestAccp.RetValue - RestAccp.TipValue;
  end;

LRestAccSumup:;
  RestAccp.TendValue = RestAccp.TendValue - RestAccp.TipValue;
  RestAccp.RetValue = RestAccp.TendValue - RestAccp.Sum4;
  RestAccp.TendValue = Round(RestAccp.TendValue,rndtotal);
  RestAccp.RemValue = Round(RestAccp.RemValue,rndtotal);
  RestAccp.RetValue = Round(RestAccp.RetValue,rndtotal);
  if (RestAccp.RemValue==0) then begin RestAccp.RemValue = BlankVal; end;
  if (RestAccp.RetValue==0) then begin RestAccp.RetValue = BlankVal; end;
  CalculateRestAccVcPoints(RestAccp);
  return;
end;

/*
lobal
procedure RestAccSumup(var record RestAccVc RestAccp,string fieldnamechanged)
begin
  val sum,rs,diff;
  Integer i,rwcnt;
  row RestAccVc RestAccrw;
  val qty,tax1sum;
  Boolean happyf;
  record RestOpenHoursVc ROHr;
  record SMVc VATr;
  Integer vatcnt;
  roundmode roundlines,rndtotal,rndvat;
  record BaseCurBlock BCb;
  vector Boolean vsumupvoidedrowf;
  
  BlockLoad(BCb);
  ReadRestOpenHours(RestAccp.MachineName,ROHr);
  if ((nonblanktime(ROHr.HHMonStart)) and (nonblanktime(ROHr.HHMonEnd))) then begin
    if (TimeInRange(RestAccp.TransTime,ROHr.HHMonStart,ROHr.HHMonEnd)) then begin
      happyf = true;
    end;
  end;  
  SetupVATBase(VATr,vatcnt);
  RestAccp.TendValue = blankval;
  rwcnt = MatRowCnt(RestAccp);

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    switch (RestAccrw.stp) begin
      case kInvoiceRowTypeVoid:
        if (RestAccrw.ovst!=0) then begin
          vsumupvoidedrowf[RestAccrw.VoidedRowNr] = true;
        end;
    end;
  end;

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    if (RestAccrw.ovst==0) then begin
      switch (RestAccrw.stp) begin
        case kInvoiceRowTypeNormal:
          if (happyf==false) then begin
            rs = RestAccrw.Sum;
          end else begin
            rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case kInvoiceRowTypeVoid:
          if (happyf==false) then begin
            rs = RestAccrw.Sum;
          end else begin
            rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case 3:
          if (happyf==false) then begin
            rs = -RestAccrw.Sum;
          end else begin
            rs = -HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case kInvoiceRowTypeGiftVoucherPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeLoyaltyPointsPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeCashPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeChequePayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeCreditCardPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      end;
    end else begin
      switch (RestAccrw.stp) begin
        case kInvoiceRowTypeNormal:
          if (vsumupvoidedrowf[i]) then begin
            if (happyf==false) then begin
              rs = RestAccrw.Sum;
            end else begin
              rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
            end;
            rs = Round(rs,DefaultRoundMode);
            sum = sum + rs;
            RestAccp.TendValue = RestAccp.TendValue - rs;
            AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
          end;
      end;
    end;
  end;
  CalcVATBaseVAT(VATr,1,0,vatcnt,RestAccp.Sum3,tax1sum);
  GetCurncyRoundoff(BCb.BaseCur1,"","RestAccVc",rndtotal,roundlines,rndvat);
  
=======
  switch (fieldnamechanged) begin
    case "RetValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.RetValue>diff) then begin
          RestAccp.RetValue = diff;
          RestAccp.TipValue = blankval;
        end else begin
          RestAccp.TipValue = diff - RestAccp.RetValue;
        end;
      end;
    case "TipValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.TipValue>diff) then begin
          RestAccp.TipValue = diff;
          RestAccp.RetValue = blankval;
        end else begin
          RestAccp.RetValue = diff - RestAccp.TipValue;
        end;
      end;
    otherwise
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
      end else begin
        RestAccp.RetValue = diff;
      end;
      RestAccp.RetValue = RestAccp.RetValue - RestAccp.TipValue;
  end;

  RestAccp.TendValue = RestAccp.TendValue - RestAccp.TipValue;
  RestAccp.RetValue = RestAccp.TendValue - RestAccp.Sum4;
  RestAccp.TendValue = Round(RestAccp.TendValue,rndtotal);
  RestAccp.RemValue = Round(RestAccp.RemValue,rndtotal);
  RestAccp.RetValue = Round(RestAccp.RetValue,rndtotal);
  if (RestAccp.RemValue==0) then begin RestAccp.RemValue = BlankVal; end;
  if (RestAccp.RetValue==0) then begin RestAccp.RetValue = BlankVal; end;
  CalculateRestAccVcPoints(RestAccp);
  return;
end;

/*
lobal
procedure RestAccSumup(var record RestAccVc RestAccp,string fieldnamechanged)
begin
  val sum,rs,diff;
  Integer i,rwcnt;
  row RestAccVc RestAccrw;
  val qty,tax1sum;
  Boolean happyf;
  record RestOpenHoursVc ROHr;
  record SMVc VATr;
  Integer vatcnt;
  roundmode roundlines,rndtotal,rndvat;
  record BaseCurBlock BCb;
  vector Boolean vsumupvoidedrowf;
  
  BlockLoad(BCb);
  ReadRestOpenHours(RestAccp.MachineName,ROHr);
  if ((nonblanktime(ROHr.HHMonStart)) and (nonblanktime(ROHr.HHMonEnd))) then begin
    if (TimeInRange(RestAccp.TransTime,ROHr.HHMonStart,ROHr.HHMonEnd)) then begin
      happyf = true;
    end;
  end;  
  SetupVATBase(VATr,vatcnt);
  RestAccp.TendValue = blankval;
  rwcnt = MatRowCnt(RestAccp);

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    switch (RestAccrw.stp) begin
      case kInvoiceRowTypeVoid:
        if (RestAccrw.ovst!=0) then begin
          vsumupvoidedrowf[RestAccrw.VoidedRowNr] = true;
        end;
    end;
  end;

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RestAccp,i,RestAccrw);
    if (RestAccrw.ovst==0) then begin
      switch (RestAccrw.stp) begin
        case kInvoiceRowTypeNormal:
          if (happyf==false) then begin
            rs = RestAccrw.Sum;
          end else begin
            rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case kInvoiceRowTypeVoid:
          if (happyf==false) then begin
            rs = RestAccrw.Sum;
          end else begin
            rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case 3:
          if (happyf==false) then begin
            rs = -RestAccrw.Sum;
          end else begin
            rs = -HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
          end;
          rs = Round(rs,DefaultRoundMode);
          sum = sum + rs;
          AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
        case kInvoiceRowTypeGiftVoucherPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeLoyaltyPointsPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeCashPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeChequePayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
        case kInvoiceRowTypeCreditCardPayment:
          RestAccp.TendValue = RestAccp.TendValue + MulRateToBase1(RestAccrw.CurncyCode,RestAccrw.Sum,RestAccrw.FrRate,RestAccrw.ToRateB1,RestAccrw.ToRateB2,RestAccrw.BaseRate1,RestAccrw.BaseRate2,DefaultCurRoundOff);
      end;
    end else begin
      switch (RestAccrw.stp) begin
        case kInvoiceRowTypeNormal:
          if (vsumupvoidedrowf[i]) then begin
            if (happyf==false) then begin
              rs = RestAccrw.Sum;
            end else begin
              rs = HappyHourQty(RestAccrw.Quant)*RestAccrw.Price;
            end;
            rs = Round(rs,DefaultRoundMode);
            sum = sum + rs;
            RestAccp.TendValue = RestAccp.TendValue - rs;
            AddVATBase(VATr,RestAccrw.VATCode,rs,0.00,vatcnt,1,0);
          end;
      end;
    end;
  end;
  CalcVATBaseVAT(VATr,1,0,vatcnt,RestAccp.Sum3,tax1sum);
  GetCurncyRoundoff(BCb.BaseCur1,"","RestAccVc",rndtotal,roundlines,rndvat);
  
>>>>>>> .merge-right.r14840
//  RestAccp.ServCharge = GetServiceCharge(RestAccp,LMb,true); moved to item paste to get rid of one server msg
  RestAccp.Sum3 = Round(RestAccp.Sum3,rndvat);
  RestAccp.Sum1 = Round(sum,rndtotal);
  RestAccp.Sum4 = Round(sum+RestAccp.ServCharge,rndtotal);
  PUCalcPerc(RestAccp.Sum1,RestAccp.Discount,rs);
  RestAccp.Sum4 = RestAccp.Sum4 - rs;
  RestAccp.Sum1 = Round(RestAccp.Sum1,rndtotal);
  RestAccp.Sum4 = Round(RestAccp.Sum4,rndtotal);
  RestAccp.Sum0 = sum + RestAccp.ServCharge - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      RestAccp.TipValue = blankval; 
    case "TipValue":
      RestAccp.RetValue = blankval; 
    otherwise
      RestAccp.RetValue = blankval; 
      RestAccp.TipValue = blankval; 
  end;
  RestAccp.RemValue = blankval;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.CashValue;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid2;
  RestAccp.TendValue = RestAccp.TendValue + RestAccp.Paid3;
  diff = RestAccp.TendValue - RestAccp.Sum4;

  switch (fieldnamechanged) begin
    case "RetValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.RetValue>diff) then begin
          RestAccp.RetValue = diff;
          RestAccp.TipValue = blankval;
        end else begin
          RestAccp.TipValue = diff - RestAccp.RetValue;
        end;
      end;
    case "TipValue":
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
        RestAccp.RetValue = blankval;
        RestAccp.TipValue = blankval;
      end else begin
        if (RestAccp.TipValue>diff) then begin
          RestAccp.TipValue = diff;
          RestAccp.RetValue = blankval;
        end else begin
          RestAccp.RetValue = diff - RestAccp.TipValue;
        end;
      end;
    otherwise
      if (diff<0) then begin
        RestAccp.RemValue = -diff;
      end else begin
        RestAccp.RetValue = diff;
      end;
      RestAccp.RetValue = RestAccp.RetValue - RestAccp.TipValue;
  end;

  RestAccp.TendValue = RestAccp.TendValue - RestAccp.TipValue;
  RestAccp.RetValue = RestAccp.TendValue - RestAccp.Sum4;
  RestAccp.TendValue = Round(RestAccp.TendValue,rndtotal);
  RestAccp.RemValue = Round(RestAccp.RemValue,rndtotal);
  RestAccp.RetValue = Round(RestAccp.RetValue,rndtotal);
  if (RestAccp.RemValue==0) then begin RestAccp.RemValue = BlankVal; end;
  if (RestAccp.RetValue==0) then begin RestAccp.RetValue = BlankVal; end;
  CalculateRestAccVcPoints(RestAccp);
  return;
end;

*/