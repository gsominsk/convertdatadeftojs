external function roundmode SetRoundModeD(Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt MonthDiff(Date,Date);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function LongInt DateDiff(Date,Date);

global
function val GetIntRate(string type,Date thedat)
begin
  record CredManRateVc CredManRater;
  val res;
  
  CredManRater.Type = type;
  CredManRater.Date = thedat;
  if (ReadLastMain(CredManRater,2,false)) then begin
    res = CredManRater.IntRate;
  end;
  GetIntRate = res;
  return;
end;

global
function val GetCredManRate(Integer typ,string type,val intrate,Date ondat)
begin
  val res;
  
  if (typ==0) then begin
    res = intrate;
  end else begin
    res = GetIntRate(type,ondat);
  end;
  GetCredManRate = res;
  return;
end;

global
procedure CalcCredManCurrentPeriod(record CredManVc CredManr,Integer paymentnr,var Date sdp,var Date edp,var Date invd)
begin
    if (nonblankdate(CredManr.FirstIntDate)) then begin
      sdp = AddDay(AddMonth(CredManr.FirstIntDate,paymentnr),1);
    end else begin
      sdp = AddDay(AddMonth(CredManr.startDate,paymentnr),1);
    end;
      edp = AddDay(AddMonth(sdp,1),-1);
  if (nonblankdate(CredManr.FirstInvDate)) then begin
    invd = AddMonth(CredManr.FirstInvDate,paymentnr); //  - 1
  end else begin
    invd = AddDay(edp,1);
    invd = edp;
  end;
  return;
end;

// PlanTypes:
// 0 = Calculcated Interest
// 1 = Issued Interest
// 2 = Issued Instalment
// 3 = Issued Deposit
// 4 = Issued Fee
// 5 = Paid Interest
// 6 = Paid Instalment
// 7 = Paid Deposit
// 8 = Paid Fee
function Integer GetActualPlanType(Integer chargemethod,Integer paidflag,string artcode)
begin
  record CredManSetBlock CMSb;
  Integer res;
  
  res = 0;
  BlockLoad(CMSb);
  if (artcode==CMSb.InstalmentItem) then begin
    if (paidflag!=1) then begin
      if (chargemethod==1) then begin
        res = 10;
      end else begin
        res = 18;
      end;
    end else begin
      res = 14;
    end;
  end else begin
    if (artcode==CMSb.RateItem) then begin
      if (paidflag!=1) then begin	
        if (chargemethod==1) then begin
          res = 9;
        end else begin
          res = 17;
        end;
      end else begin
        res = 13;
      end;
    end else begin
      if (artcode==CMSb.DepositItem) then begin
        if (paidflag!=1) then begin
          if (chargemethod==1) then begin
            res = 11;
          end else begin
            res = 19;
          end;
        end else begin
          res = 15;
        end;
      end else begin
        if (paidflag!=1) then begin
          if (chargemethod==1) then begin
            res = 12;
          end else begin
            res = 20;
          end;
        end else begin
          res = 16;
        end;
      end;
    end;
  end;
  GetActualPlanType = res;
  return;
end;

global
function val GetPlanTypeVal(Integer plantype,val v)
begin
  val res;
  
  switch (plantype) begin
    case 5: res = -v;
    case 6: res = -v;
    case 7: res = -v;
    case 8: res = -v;
    case 9: res = -v;
    case 10: res = -v;
    case 11: res = -v;
    case 12: res = -v;
    case 13: res = -v;
    case 14: res = -v;
    case 15: res = -v;
    case 16: res = -v;
    otherwise res = v;
  end;
  GetPlanTypeVal = res;
  return;
end;

global
function string 255 GetPlanTypeText(Integer plantype)
begin
  string 255 res;
  
  switch (plantype) begin
    case 0: res = "Should not happen";
    case 1: res = "Planned Interest";
    case 2: res = "Planned Instalment";
    case 3: res = "Planned Deposit";
    case 4: res = "Planned Fee";
    case 5: res = "Suggested Interest";
    case 6: res = "Suggested Instalment";
    case 7: res = "Suggested Deposit";
    case 8: res = "Suggested Fee";
    case 9: res = "Invoiced Interest";
    case 10: res = "Invoiced Instalment";
    case 11: res = "Invoiced Deposit";
    case 12: res = "Invoiced Fee";
    case 13: res = "Paid Interest";
    case 14: res = "Paid Instalment";
    case 15: res = "Paid Deposit";
    case 16: res = "Paid Fee";
    case 17: res = "Added Interest";
    case 18: res = "Added Instalment";
    case 19: res = "Added Deposit";
    case 20: res = "Added Fee";
  end;
  GetPlanTypeText = res;
  return;
end;

function Boolean AddActualsForToday(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date frdat,Date todat,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,var val realinstpaid,var val realintpaid,var val mfee,var val extrainttopay,Boolean printf)
begin
  record CredManEventVc CredManEventr;
  row CredManEventVc CredManEventrw;
  row CredManPayPlanVc CredManPayPlanrw;
  string 200 keystr;
  Boolean foundf;
  Integer evt,i,rwcnt;
  Boolean res;
  
  res = false;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  CredManEventr.TransDate = frdat;
  foundf = true;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    if (CredManEventr.TransDate>todat) then begin
      foundf = false;
    end;
    if (foundf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        evt = GetActualPlanType(CredManr.ChargeMethod,CredManEventr.PaidFlag,CredManEventrw.ArtCode);
        CredManPayPlanrw.ArtCode = "";
        CredManPayPlanrw.TransDate = CredManEventr.TransDate;
        CredManPayPlanrw.PlanType = evt;
        CredManPayPlanrw.Sum = CredManEventrw.Sum;
        CredManPayPlanrw.AcumulatedInt = acumint;
        CredManPayPlanrw.Bal = calcbal;
        CredManPayPlanrw.IssuedNr = CredManEventr.SerNr;
        switch (evt) begin
          case 0:
            Trace("Should not happen"," case 0");
          case 1:
            CredManPayPlanrw.Bal = CredManPayPlanrw.Bal + CredManEventrw.Sum;
            CredManPayPlanrw.AcumulatedInt = CredManPayPlanrw.AcumulatedInt - CredManEventrw.Sum;
            if (CredManPayPlanrw.AcumulatedInt<0) then begin
              CredManPayPlanrw.AcumulatedInt = 0;
            end;
          case 2:
//            if (CredManr.ChargeMethod==1) then begin
              CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
//            end;
          case 3:
//            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
          case 4:
            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
          case 5:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 6:
            if (CredManr.ChargeMethod==0) then begin
              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
            end;
          case 7:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 8:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 9:
            CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
            realintpaid = realintpaid + CredManPayPlanrw.Sum;
            extrainttopay = 0;
          case 10:
            if (CredManr.ChargeMethod==1) then begin
              CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
            end;
          case 11:
//            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
          case 12:
            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
          case 13:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 14:
            if (CredManr.ChargeMethod==0) then begin
              CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
//              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
            end;
          case 15:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 16:
            CredManPayPlanrw.Bal = calcbal - CredManPayPlanrw.Sum;
          case 17:
            CredManPayPlanrw.Bal = CredManPayPlanrw.Bal + CredManEventrw.Sum;
            CredManPayPlanrw.AcumulatedInt = 0;
          case 18:
//            if (CredManr.ChargeMethod==1) then begin
              CredManPayPlanrw.Bal = CredManPayPlanrw.Bal - CredManEventrw.Sum;
              realinstpaid = realinstpaid + CredManPayPlanrw.Sum;
//            end;
          case 19:
//            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
          case 20:
            CredManPayPlanrw.Bal = calcbal + CredManPayPlanrw.Sum;
            mfee = mfee + CredManPayPlanrw.Sum;
        end;
        MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
        acumint = CredManPayPlanrw.AcumulatedInt;
        calcbal = CredManPayPlanrw.Bal;
      end;
      res = true;
    end;
  end;
  AddActualsForToday = res;
  return;
end;

procedure AddSuggestedInstalment(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val installment,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = round(installment,SetRoundModeD(CredManSetb.InstalmentRoundOff));
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = CredManSetb.InstalmentItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 6;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = acumint;
    CredManPayPlanrw.Bal = calcbal - v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

procedure AddSuggestedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val interest,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = round(interest,SetRoundModeD(CredManSetb.RateRoundOff));
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = CredManSetb.RateItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 5;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = acumint;
    CredManPayPlanrw.Bal = calcbal - v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

procedure AddCalculatedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,val interest,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = interest;
  CredManPayPlanrw.ArtCode = "";
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 0;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint + v;
  CredManPayPlanrw.Bal = calcbal;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

procedure AddIssuedInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val extrainttopay,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = round(acumint,SetRoundModeD(CredManSetb.RateRoundOff));
  if (v>0) then begin
    extrainttopay = v;
    CredManPayPlanrw.ArtCode = CredManSetb.RateItem;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = 1;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.AcumulatedInt = 0;
    CredManPayPlanrw.Bal = calcbal + v;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;
  return;
end;

procedure AddPlannedFees(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val mfee,var val calcbal,var val acumint,Boolean printf,Boolean inclmonthly)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  row CredManVc CredManrw;
  Integer i,rwcnt;
  val v;
  Boolean addf;
  
  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    v = CredManrw.Sum - CredManrw.InvoicedSum;
    addf = false;
    if (CredManrw.ChargeType==1 and inclmonthly) then begin
      addf = true;
    end;
    if (CredManrw.ChargeType==0 and CredManrw.InvoicedOn==-1 and CredManrw.Sum>CredManrw.InvoicedSum) then begin
      addf = true;
      CredManrw.InvoicedSum = CredManrw.Sum;
      MatRowPut(CredManr,i,CredManrw);
    end;
    if (addf) then begin
      CredManPayPlanrw.ArtCode = CredManrw.ArtCode;
      CredManPayPlanrw.TransDate = transdate;
      CredManPayPlanrw.PlanType = 4;
      CredManPayPlanrw.Sum = v;
      CredManPayPlanrw.AcumulatedInt = acumint;
      CredManPayPlanrw.Bal = calcbal + v;
      mfee = mfee + v;
      MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
      acumint = CredManPayPlanrw.AcumulatedInt;
      calcbal = CredManPayPlanrw.Bal;
    end;
  end;
  return;
end;

procedure AddIssuedDeposit(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = round(CredManr.DepositSum,SetRoundModeD(CredManSetb.DepositRoundOff));
  CredManPayPlanrw.ArtCode = "";
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 3;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint;
  CredManPayPlanrw.Bal = calcbal + v;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

procedure AddPaidDeposit(record CredManVc CredManr,record CredManSetBlock CredManSetb,Date transdate,var record CredManPayPlanVc CredManPayPlanr,var val calcbal,var val acumint,Boolean printf)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = round(CredManr.DepositSum,SetRoundModeD(CredManSetb.DepositRoundOff));
  CredManPayPlanrw.ArtCode = CredManSetb.DepositItem;
  CredManPayPlanrw.TransDate = transdate;
  CredManPayPlanrw.PlanType = 7;
  CredManPayPlanrw.Sum = v;
  CredManPayPlanrw.AcumulatedInt = acumint;
  CredManPayPlanrw.Bal = calcbal - v;
  MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
  acumint = CredManPayPlanrw.AcumulatedInt;
  calcbal = CredManPayPlanrw.Bal;
  return;
end;

function Date CredManLastActual(record CredManVc CredManr)
begin
  record CredManEventVc CredManEventr;
  string 200 keystr;
  Date res;
  
  res = CredManr.startDate;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  CredManEventr.TransDate = AddYear(CredManr.endDate,10);
  if (ReadLastKey(keystr,CredManEventr,1,false)) begin
    res = CredManEventr.TransDate;
  end;
  CredManLastActual = res;
  return;
end;

global
procedure BuildCredManPayPlan(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean suggestedonsameday)
begin
  record CredManVc CredManr;
  Date thedat;
  Integer i,days;
  Integer months;
  val hundred,twelve,rate,therate,monthtot,calcbal,acumint;
  val sofar;
  val instal,inter,opentot,totsum,instalment,interest,extrainttopay;
  val realinstpaid,realintpaid,mfee;
  Date freeuntil,frdat,todat,invdat,lastactual;
  Boolean printf;
  Integer paymentnr,ratedays;
  
  RecordNew(CredManPayPlanr);
  RecordCopy(CredManr,inCredManr);
  printf = true;
  acumint = 0;
  realinstpaid = 0;
  realintpaid = 0;
  mfee = 0;
  extrainttopay = 0;
  hundred = 100;
  twelve = 12;
  if (nonblankdate(CredManr.FirstIntDate)) then begin
    thedat = AddDay(CredManr.FirstIntDate,1);
  end else begin
    thedat = AddDay(CredManr.startDate,1);
  end;
  months = CredManr.InstalmentMonths;
  days = DateDiff(CredManr.endDate,thedat) + 1;
  if (withactuals) then begin
    lastactual = CredManLastActual(CredManr);
  end else begin
    lastactual = CredManr.startDate;
  end;
  if (CredManr.FreeDays>0) then begin
    freeuntil = AddDay(AddDay(thedat,-1),CredManr.FreeDays);
  end else begin
    freeuntil = AddDay(thedat,-1);
  end;
  totsum = CredManr.InvSum4;
  switch (CredManr.InstalmentType) begin
    case 0:
      calcbal = totsum;
    case 1:
      calcbal = totsum;
      instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
    case 2:
      calcbal = totsum;
      instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
  end;
  for (i=0;i<days;i=i+1) begin
    CalcCredManCurrentPeriod(CredManr,paymentnr,frdat,todat,invdat);
    ratedays = DateDiff(todat,frdat) + 1;
//    if (thedat>freeuntil) then begin
      therate = GetCredManRate(CredManr.RateType,CredManr.Type,CredManr.IntRate,thedat);
      rate = therate / twelve / hundred;
      switch (CredManr.InstalmentType) begin
        case 0:
          if (i==0) then begin
            if (withactuals) then begin
              if (AddActualsForToday(CredManr,CredManSetb,CredManr.startDate,thedat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)==false) then begin
                if (CredManr.DepositSum>0) then begin
//                  AddIssuedDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
                  AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
                end;
              end;
            end else begin
              if (CredManr.DepositSum>0) then begin
//                AddIssuedDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
                AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
              end;
            end;
            AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,false);
            totsum = calcbal;
            monthtot = calcbal * rate / ratedays;
            AddCalculatedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,monthtot,calcbal,acumint,printf);
          end else begin
            monthtot = calcbal * rate / ratedays;
            AddCalculatedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,monthtot,calcbal,acumint,printf);
            if (CredManr.ChargeMethod==1) then begin
              if (thedat==invdat) then begin
//                AddCalculatedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,monthtot,calcbal,acumint,printf);
                AddIssuedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,extrainttopay,calcbal,acumint,printf);
//                if ((thedat>lastactual) or (thedat==lastactual and suggestedonsameday)) then begin
                if (thedat>lastactual) then begin
                  AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,true);
                end;
              end;
            end;
            if (withactuals) then begin
              if (AddActualsForToday(CredManr,CredManSetb,thedat,thedat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)) then begin
              end;
            end;
            if (CredManr.ChargeMethod==0) then begin
              if (thedat==invdat) then begin
//                AddCalculatedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,monthtot,calcbal,acumint,printf);
                AddIssuedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,extrainttopay,calcbal,acumint,printf);
//                if ((thedat>lastactual) or (thedat==lastactual and suggestedonsameday)) then begin
                if (thedat>lastactual) then begin
                  AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,true);
                end;
              end;
            end;
            if (thedat!=invdat) then begin
//              monthtot = calcbal * rate / ratedays;
//              AddCalculatedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,monthtot,calcbal,acumint,printf);
            end;
          end;
        case 1:
          if (i==0) then begin
            if (withactuals) then begin
              if (AddActualsForToday(CredManr,CredManSetb,CredManr.startDate,thedat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)==false) then begin
                if (CredManr.DepositSum>0) then begin
                  AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
                end;
              end;
            end else begin
              if (CredManr.DepositSum>0) then begin
                AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
              end;
            end;
            AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,false);
            totsum = calcbal;
            instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
          end;
          monthtot = totsum * rate / ratedays;
        case 2:
          if (i==0) then begin
            if (withactuals) then begin
              if (AddActualsForToday(CredManr,CredManSetb,CredManr.startDate,thedat,CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)==false) then begin
                if (CredManr.DepositSum>0) then begin
                  AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
                end;
              end;
            end else begin
              if (CredManr.DepositSum>0) then begin
                AddPaidDeposit(CredManr,CredManSetb,thedat,CredManPayPlanr,calcbal,acumint,printf);
              end;
            end;
            AddPlannedFees(CredManr,CredManSetb,thedat,CredManPayPlanr,mfee,calcbal,acumint,printf,false);
            totsum = calcbal;
            instal = Round(totsum / months,SetRoundModeD(CredManSetb.InstalmentRoundOff));
          end;
          rate = 1/(1+rate);
          monthtot = ((1-rate)*totsum)/(rate*(1-power(rate,months)));
          inter = monthtot - instal;
          monthtot = inter / ratedays;
      end;
//    end;
    if (thedat==invdat) then begin
      rate = 1/(1+rate);
      monthtot = ((1-rate)*totsum)/(rate*(1-power(rate,months-paymentnr)));
      monthtot = monthtot - realinstpaid - realintpaid + mfee;
      interest = acumint + extrainttopay;
      instalment = monthtot - interest;
/*
StartFormat(15);
OutString(0,0,"calcbal " & calcbal,false);
OutString(100,0,"acumint " & acumint,false);
OutString(200,0,"instalment " & instalment,false);
OutString(300,0,"interest " & interest,false);
OutString(400,0,"monthtot " & monthtot,false);
EndFormat;
*/

      if ((thedat>lastactual and monthtot>0) or (thedat==lastactual and monthtot>0 and suggestedonsameday)) then begin
        AddSuggestedInstalment(CredManr,CredManSetb,thedat,CredManPayPlanr,instalment,calcbal,acumint,printf);
        AddSuggestedInterest(CredManr,CredManSetb,thedat,CredManPayPlanr,interest,calcbal,acumint,printf);
      end;
      paymentnr = paymentnr + 1;
      extrainttopay = 0;
      realinstpaid = 0;
      realintpaid = 0;
      mfee = 0;
      totsum = calcbal;
    end;
    thedat = AddDay(thedat,1);
    if (calcbal<0) Then begin
      i = days;
    end;
  end;
  if (withactuals) then begin
    if (AddActualsForToday(CredManr,CredManSetb,thedat,AddYear(thedat,10),CredManPayPlanr,calcbal,acumint,realinstpaid,realintpaid,mfee,extrainttopay,printf)) then begin
    end;
  end;
  return;
end;

// Only used with combination: Get Unpaid Instalment Sum
global
function val GetCredManStatus(record CredManVc CredManr,Integer paidflag,Integer type)
begin
  record CredManEventVc CredManEventr;
  row CredManEventVc CredManEventrw;
  Integer rwcnt,i;
  Boolean foundf;
  string 200 keystr;
  val res;
  
  res = 0;
  CredManEventr.PaidFlag = paidflag;
  keystr = "CredManPaidFlag:";
  keystr = keystr & CredManr.SerNr;
  foundf = true;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    if ((CredManEventr.CredManNr!=CredManr.SerNr) or (CredManEventr.PaidFlag!=paidflag)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        if (CredManEventrw.ChargeType==type) then begin
          res = res + CredManEventrw.Sum;
        end;
      end;
    end;
  end;
  GetCredManStatus = res;
  return;
end;

function val AddCredManEventToCurBal(Integer paidf,val curbal,Integer typ,val sum)
begin
  val res;
  
  if (typ!=2) then begin
    switch (paidf) begin
      case 0: res = curbal + sum;
      case 1: res = curbal - sum;
      case -1: res = curbal;
    end;
  end else begin
    switch (paidf) begin
      case 0: res = curbal;
      case 1: res = curbal - sum;
      case -1: res = curbal;
    end;
  end;
  AddCredManEventToCurBal = res;
  return;
end;

updating procedure SetAndUpdateCredManBalance(record CredManVc CredManr,var record CredManEventVc thisCredManEventr,Boolean insertthis)
begin
  record CredManEventVc CredManEventr;
  record CredManEventVc oldCredManEventr;
  row CredManEventVc CredManEventrw;
  Boolean foundf,testf,addedf;
  string 200 keystr;
  val curbal;
  Integer i,rwcnt;
  
  curbal = CredManr.InvSum4;
  addedf = false;
  foundf = true;
  keystr = "CredManTransDate:";
  keystr = keystr & CredManr.SerNr;
  while (LoopKey(keystr,CredManEventr,1,foundf)) begin
    testf = foundf;
    if (insertthis and addedf==false) then begin
      if (thisCredManEventr.TransDate<CredManEventr.TransDate) then begin
        rwcnt = MatRowCnt(thisCredManEventr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(thisCredManEventr,i,CredManEventrw);
          curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
        end;
        thisCredManEventr.CredManBal = curbal;
        addedf = true;
      end else begin
        if (thisCredManEventr.TransDate==CredManEventr.TransDate) then begin
          if (thisCredManEventr.PaidFlag<CredManEventr.PaidFlag) then begin
            rwcnt = MatRowCnt(thisCredManEventr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(thisCredManEventr,i,CredManEventrw);
              curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
            end;
            thisCredManEventr.CredManBal = curbal;
            addedf = true;
          end else begin
            if (thisCredManEventr.PaidFlag==CredManEventr.PaidFlag and thisCredManEventr.SerNr<CredManEventr.SerNr) then begin
              rwcnt = MatRowCnt(thisCredManEventr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(thisCredManEventr,i,CredManEventrw);
                curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
              end;
              thisCredManEventr.CredManBal = curbal;
              addedf = true;
            end;
          end;
        end;
      end;
    end else begin
      if (thisCredManEventr.SerNr==CredManEventr.SerNr) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      rwcnt = MatRowCnt(CredManEventr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CredManEventr,i,CredManEventrw);
        curbal = AddCredManEventToCurBal(CredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
      end;
      if (CredManEventr.CredManBal!=curbal) then begin
        RecordCopy(oldCredManEventr,CredManEventr);
        CredManEventr.CredManBal = curbal;
        if (RecordUpdate(oldCredManEventr,CredManEventr,false)==0) then begin
        end;
      end;
    end;
  end;
  if (addedf==false) then begin
    rwcnt = MatRowCnt(thisCredManEventr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(thisCredManEventr,i,CredManEventrw);
      curbal = AddCredManEventToCurBal(thisCredManEventr.PaidFlag,curbal,CredManEventrw.ChargeType,CredManEventrw.Sum);
    end;
    thisCredManEventr.CredManBal = curbal;
  end;
  return;
end;

updating procedure DeleteCredManEvent(record CredManVc CredManr,record CredManEventVc CredManEventr)
begin
  SetAndUpdateCredManBalance(CredManr,CredManEventr,false);
  RecordDelete(CredManEventr);
  return;
end;

global
updating function Boolean RemoveCredManEvent(record CredManVc CredManr,string filnam,LongInt sernr)
begin
  record CredManEventVc CredManEventr;
  Boolean foundf;
  Boolean res;
  
  res = false;
  CredManEventr.CredManNr = CredManr.SerNr;
  CredManEventr.FileName = filnam;
  CredManEventr.RecordNr = sernr;
  foundf = true;
  while (LoopKey("FindOriginalRecord",CredManEventr,3,foundf)) begin
    if ((CredManEventr.CredManNr!=CredManr.SerNr) or (CredManEventr.FileName!=filnam) or (CredManEventr.RecordNr!=sernr)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      DeleteCredManEvent(CredManr,CredManEventr);
      StepBack(CredManEventr);
      res = true;
    end;
  end;
  RemoveCredManEvent = res;
  return;
end;

global
procedure CredManEventSumup(var record CredManEventVc CredManEventr)
begin
  row CredManEventVc CredManEventrw;
  Integer i,rwcnt;
  
  CredManEventr.InvSum = BlankVal;
  CredManEventr.PaidSum = BlankVal;
  rwcnt = MatRowCnt(CredManEventr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManEventr,i,CredManEventrw);
    switch (CredManEventr.PaidFlag) begin
      case -1: CredManEventr.InvSum = CredManEventr.InvSum + CredManEventrw.Sum;
      case 0: CredManEventr.InvSum = CredManEventr.InvSum + CredManEventrw.Sum;
      case 1: CredManEventr.PaidSum = CredManEventr.PaidSum + CredManEventrw.Sum;
    end;
  end;
  CredManEventr.TotSum = CredManEventr.InvSum + CredManEventr.PaidSum;
  return;
end;

global
updating procedure StoreCredManEvent(record CredManVc CredManr,var record CredManEventVc CredManEventr)
begin
  CredManEventr.SerNr = NextSerNr("CredManEventVc",CredManEventr.TransDate,-1,false,"");
  CredManEventSumup(CredManEventr);
  SetAndUpdateCredManBalance(CredManr,CredManEventr,true);
  if (RecordInsert(CredManEventr,true)) then begin
  end;
  return;
end;

global
function Integer GetCurrentMonth(record CredManVc CredManr)
begin
  Date thedat;
  Integer res;
  
  thedat = CredManr.InvUntil;
  if (nonblankdate(thedat)) then begin
    thedat = AddDay(thedat,1);
  end else begin
    thedat = CredManr.startDate;
  end;
  res = MonthDiff(CredManr.startDate,thedat);
  GetCurrentMonth = res;
  return;
end;

// Must match above calculations.... shame to have two similar functions...
global
procedure CalcCredManSums(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,
                          var val planinst,var val planint,var val planfee,var val plandep,
                          var val suginst,var val sugint,var val sugfee,var val sugdep,
                          var val invdinst,var val invdint,var val invdfee,var val invddep,
                          var val paidinst,var val paidint,var val paidfee,var val paiddep,
                          var val addinst,var val addint,var val addfee,var val adddep,
                          var val lastpaid,var Date lastpaiddate,var val curbal,var val cursuginst,
                          var LongInt contractage)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  LongInt i,rwcnt;
  Date lastevent;
  Boolean addtosug;
  Date bldat;
  
  planinst = 0; planint = 0; planfee = 0; plandep = 0;
  suginst = 0; sugint = 0; sugfee = 0; sugdep = 0;
  invdinst = 0; invdint = 0; invdfee = 0; invddep = 0;
  paidinst = 0; paidint = 0; paidfee = 0; paiddep = 0;
  addinst = 0; addint = 0; addfee = 0; adddep = 0;
  lastpaid = 0; lastpaiddate = bldat; cursuginst = 0;
  contractage = 0; 
  addtosug = true;
  curbal = CredManr.InvSum4 - CredManr.DepositSum;
  lastevent = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    switch (CredManPayPlanrw.PlanType) begin
      case 0:
        if (cursuginst>0) then begin
          addtosug = false;
        end;
      case 1: planint = planint + CredManPayPlanrw.Sum;
      case 2: planinst = planinst + CredManPayPlanrw.Sum;
      case 3: plandep = plandep + CredManPayPlanrw.Sum;
      case 4: planfee = planfee + CredManPayPlanrw.Sum;
      case 5:
        sugint = sugint + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 6:
        suginst = suginst + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 7:
        sugdep = sugdep + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 8:
        sugfee = sugfee + CredManPayPlanrw.Sum;
        if (addtosug) then begin
          cursuginst = cursuginst + CredManPayPlanrw.Sum;
        end;
      case 9: invdint = invdint + CredManPayPlanrw.Sum;
      case 10: invdinst = invdinst + CredManPayPlanrw.Sum;
      case 11: invddep = invddep + CredManPayPlanrw.Sum;
      case 12: invdfee = invdfee + CredManPayPlanrw.Sum;
      case 13:
        paidint = paidint + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 14:
        paidinst = paidinst + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 15:
        paiddep = paiddep + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 16:
        paidfee = paidfee + CredManPayPlanrw.Sum;
        lastpaiddate = CredManPayPlanrw.TransDate;
        curbal = curbal - CredManPayPlanrw.Sum;
        if (lastevent!=CredManPayPlanrw.TransDate) then begin
          lastpaid = CredManPayPlanrw.Sum;
        end else begin
          lastpaid = lastpaid + CredManPayPlanrw.Sum;
        end;
      case 17:
        addint = addint + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
        contractage = contractage + 1;
      case 18:
        addinst = addinst + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
      case 19:
        adddep = adddep + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
      case 20:
        addfee = addfee + CredManPayPlanrw.Sum;
        curbal = curbal + CredManPayPlanrw.Sum;
    end;
    if (CredManPayPlanrw.PlanType!=0) then begin
      lastevent = CredManPayPlanrw.TransDate;
    end;
/*
StartFormat(15);
OutString(0,0,"XXX",false);
OutString(100,0,CredManPayPlanrw.TransDate,false);
OutString(200,0,CredManPayPlanrw.PlanType,false);
OutString(300,0,addtosug,false);
OutString(400,0,cursuginst,false);
EndFormat;
*/
  end;
  return;
end;

global
procedure CredManSumup(var record CredManVc CredManr)
begin
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSetBlock CredManSetb;
  row CredManVc CredManrw;
  val planinst,planint,planfee,plandep;
  val suginst,sugint,sugfee,sugdep;
  val invdinst,invdint,invdfee,invddep;
  val paidinst,paidint,paidfee,paiddep;
  val addinst,addint,addfee,adddep;
  val lastpaid,curbal,cursuginst;
  Date lastpaiddate;
  LongInt contractage;
  val rate,twelve,hundred;
  Integer i,rwcnt;

  hundred = 100;
  twelve = 12;
  BlockLoad(CredManSetb);
  CredManr.endDate = AddMonth(CredManr.FirstInvDate,CredManr.InstalmentMonths - 1);
  BuildCredManPayPlan(CredManr,CredManPayPlanr,CredManSetb,true,false);
  CalcCredManSums(CredManr,CredManPayPlanr,CredManSetb,planinst,planint,planfee,plandep,suginst,sugint,sugfee,sugdep,
                  invdinst,invdint,invdfee,invddep,paidinst,paidint,paidfee,paiddep,addinst,addint,addfee,adddep,
                  lastpaid,lastpaiddate,curbal,cursuginst,contractage);
//  CredManr.TotalInterest = totint;
//  CredManr.TotalSumExclDep = totinst + totint + totfee;
//  CredManr.TotalSum = CredManr.TotalSumExclDep + totdep;
  rate = CredManr.IntRate / twelve / hundred;
  rate = 1/(1+rate);
  CredManr.MonthlySum = ((1-rate)*(CredManr.InvSum4 - CredManr.DepositSum))/(rate*(1-power(rate,CredManr.InstalmentMonths)));
  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if (CredManrw.ChargeType==1) then begin
      CredManr.MonthlySum = CredManr.MonthlySum + CredManrw.Sum;
    end;
  end;
  CredManr.MonthlySum = Round(CredManr.MonthlySum,SetRoundModeD(2));
  CredManr.BaseTotalSum = MulRateToBase1(CredManr.CurncyCode,CredManr.TotalSum,CredManr.FrRate,CredManr.ToRateB1,CredManr.ToRateB2,CredManr.BaseRate1,CredManr.BaseRate2,DefaultCurRoundOff);
  return;
end;

