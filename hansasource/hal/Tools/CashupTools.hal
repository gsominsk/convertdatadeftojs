external procedure PrintSMRecord(record SMVc,Integer);
external function roundmode SetRoundModeD(Integer);
external procedure AddVATVat(var record SMVc,string,val,Integer);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external procedure MulVATIVExecute(string,val,var val,var val,Integer,Integer,roundmode);
external function val CalculateTotalVATFromTaxMatrix3(record TaxMatrixVc,Integer,Boolean,Boolean);
external function Boolean UseTaxTemplatesforTaxCalc();
external procedure IVCashToIV_FromPOS(record IVCashVc,var record IVVc);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external procedure SetupVATBase(var record SMVc,var Integer);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external function Boolean DateTimeInsidePeriod(Date,Time,Date,Time,Date,Time);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function val FormulaDiscountCalcSum(val,val,val,string);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function string 5 AddVATCodeToVATAccRows(string);
external procedure ConvertSalesAcc(var string,Integer);
external procedure GetItemSalesAcc(string,Integer,var string);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean GetPMRow(string,var row PMBlock);
external function Boolean GetAccName(string,var string,Integer);
external procedure GetVATCodeSalesVatAcc(string,var string);
external procedure AddSMRow(record SMVc,Date,string,string,string,string,val,Boolean,Boolean ,var val);
external procedure AddRowTaxMatrixToSumTaxMatrix(record TaxMatrixVc,var record TaxMatrixVc,Integer);
external updating procedure IVVcGenTrans(LongInt,LongInt);

enum begin
  kCashupReportCleanCash_SameAsInCashupReportFile = 1
end;

global
procedure InsertAtPos(Integer pos,string vcname,string thecode,LongInt serno,Date dat,Time tim,Integer typ,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  Integer i;

  for (i=acnt;i>pos;i=i-1) begin
    avcn[i] = avcn[i-1];
    acod[i] = acod[i-1];
    aser[i] = aser[i-1];
    adat[i] = adat[i-1];
    atim[i] = atim[i-1];
    atyp[i] = atyp[i-1];
  end;
  avcn[pos] = vcname;
  acod[pos] = thecode;
  aser[pos] = serno;
  adat[pos] = dat;
  atim[pos] = tim;
  atyp[pos] = typ;
  acnt = acnt + 1;
  return;
end;

global
procedure AddCashupToArray(string vcname,string thecode,LongInt serno,Date dat,Time tim,Integer typ,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  Integer i;

  for (i=0;i<acnt;i=i+1) begin
    if ((dat<adat[i]) or ((dat==adat[i]) and (tim<atim[i]))) then begin
      InsertAtPos(i,vcname,thecode,serno,dat,tim,typ,avcn,acod,aser,adat,atim,atyp,acnt);
      goto LAddCashupToArray;
    end;
  end;
  avcn[acnt] = vcname;
  acod[acnt] = thecode;
  aser[acnt] = serno;
  adat[acnt] = dat;
  atim[acnt] = tim;
  atyp[acnt] = typ;
  acnt = acnt + 1;
LAddCashupToArray:;
  return;
end;

global
procedure AddCashupToIVArray(Boolean cashinf,string defcode,string thecode,string crncy,val v,val b1v,val tip,var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt)
begin
  Integer i;
  string 200 locdefcode,lcrncy;
  record BaseCurBlock BCb;
  Boolean lcashinf;
  
  if (v==0) then begin
    goto LAddCashupToIVArray;
  end;
  lcashinf = cashinf;
  if (v<0) then begin lcashinf = false; end;
  lcrncy = crncy;
  if (blank(lcrncy)) then begin
    BlockLoad(BCb);
    lcrncy = BCb.BaseCur1;
  end;
  if (nonblank(thecode)) then begin
    locdefcode = thecode;
  end else begin
    locdefcode = defcode;
  end;
 
  for (i=0;i<acnt;i=i+1) begin
    if (locdefcode==aivcode[i]) and (lcrncy==aivcrncy[i]) then begin
      if (lcashinf==false) then begin
        aivoutval[i] = aivoutval[i] - v;
        aivb1outval[i] = aivb1outval[i] - b1v;
      end else begin
        aivval[i] = aivval[i] + v;
        aivb1val[i] = aivb1val[i] + b1v;
      end;
      aivnr[i] = aivnr[i] + 1;
      atipsum[i] = tip;
      goto LAddCashupToIVArray;
    end;
  end;
  aivcode[acnt] = locdefcode;
  aivcrncy[acnt] = lcrncy;
  atipsum[acnt] = tip;
  if (lcashinf==false) then begin
    aivoutval[acnt] = -v;
    aivb1outval[acnt] = -b1v;
    aivval[acnt] = BlankVal;
    aivb1val[acnt] = BlankVal;
  end else begin
    aivval[acnt] = v;
    aivb1val[acnt] = b1v;
    aivoutval[acnt] = BlankVal;
    aivb1outval[acnt] = BlankVal;
  end;
  aivnr[acnt] = 1;
  acnt = acnt + 1;
LAddCashupToIVArray:;
  return;
end;

global
procedure FindTimeOfLastPOSBalance(var Date dfr,var Time tfr,string machine,string drawer,var val Bal,var val accsales)
begin
  record POSBalanceVc POSBalancer;
  Boolean foundf,testf;
  val blval;
  date bldat;
  time bltim;
  
  POSBalancer.MachineName = machine;
  POSBalancer.Drawer = drawer;
  POSBalancer.TransDate = dfr;
  POSBalancer.TransTime = tfr;
  foundf = true;
  while (LoopBackKey("MachineName",POSBalancer,4,foundf))  begin
    if (POSBalancer.MachineName!=machine) then begin
      foundf = false;
    end;
    if (POSBalancer.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (POSBalancer.TransDate>dfr) then begin
      foundf = false;
    end;
    testf = foundf;
    if (POSBalancer.NLTransDone==0) then begin
      testf = false;
    end;
    if (testf) then begin
      dfr = POSBalancer.TransDate;
      tfr = POSBalancer.TransTime;
      bal = POSBalancer.Bal;
      accsales = POSBalancer.AccSales;
      goto LFindTimeOfLastPOSBalance;
    end;
  end;
  
  dfr = bldat;
  tfr = bltim;
  bal = blval;
  accsales = blval;  
LFindTimeOfLastPOSBalance:;
  return;
end;

global
function Boolean FindTimeOfLastPOSEvent(var Date dfr,var Time tfr,string machine,string drawer)
begin
  Boolean res;
  record POSEventVc POSEventr;
  Boolean foundf,testf;

  POSEventr.MachineName = machine;
  POSEventr.Drawer = drawer;
  POSEventr.TransDate = dfr;
  POSEventr.TransTime = tfr;
  foundf = true;
  while (LoopBackKey("MachineName",POSEventr,4,foundf))  begin
    if (POSEventr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (POSEventr.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (POSEventr.TransDate>dfr) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      dfr = POSEventr.TransDate;
      tfr = POSEventr.TransTime;
      foundf = false;
      res = true;
    end;
  end;
  FindTimeOfLastPOSEvent = res;
  return;
end;

global
function Boolean POSBalanceExistsAfterThis(Date dfr,Time tfr,string machine,string drawer)
begin
  record POSBalanceVc POSBalancer;
  Boolean foundf,testf,res;

  res = false;
  POSBalancer.MachineName = machine;
  POSBalancer.Drawer = drawer;
  POSBalancer.TransDate = dfr;
  POSBalancer.TransTime = tfr;
  foundf = true;
//  while (LoopBackKey("MachineName",POSBalancer,4,foundf))  begin //After or Before ? 
  while (LoopKey("MachineName",POSBalancer,4,foundf))  begin
    if (POSBalancer.MachineName!=machine) then begin
      foundf = false;
    end;
    if (POSBalancer.Drawer!=drawer) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      if (POSBalancer.TransDate>dfr) then begin
        res = true;
        foundf = false;
      end else begin
        if (POSBalancer.TransDate==dfr) then begin
          if (POSBalancer.TransTime>tfr) then begin
            res = true;
            foundf = false;
          end;
        end;
      end;
    end;
  end;
  POSBalanceExistsAfterThis = res;
  return;
end;

global
procedure FillUpAllCashBal(Date dfr,Date dto,Time tfr,Time tto,string machine,string drawer,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  record CashierBalVc CashierBalr;
  Boolean foundf,testf;

  CashierBalr.MachineName = machine;
  CashierBalr.Drawer = drawer;
  CashierBalr.TransDate = dfr;
  CashierBalr.TransTime = tfr;
  foundf = true;
  while (LoopKey("Cashup",CashierBalr,4,foundf)) begin
    if (CashierBalr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (CashierBalr.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (CashierBalr.TransDate>dto) then begin
      foundf = false;
    end;
    if (nonblanktime(tto)) then begin
      if (CashierBalr.TransDate==dto) then begin
        if (CashierBalr.TransTime>tto) then begin
          foundf = false;
        end;
      end;
    end;
    testf = foundf;
    if (CashierBalr.OKFlag==0) then begin
      testf = false;
    end;
    if (testf) then begin
      AddCashupToArray("CashierBalVc",CashierBalr.UserCode,-1,CashierBalr.TransDate,CashierBalr.TransTime,-1,avcn,acod,aser,adat,atim,atyp,acnt);
    end;
  end;
  return;
end;

global
procedure FillUpAllPOSEvents(Date dfr,Date dto,Time tfr,Time tto,string machine,string drawer,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  record POSEventVc POSEventr;
  Boolean foundf,testf;

  POSEventr.MachineName = machine;
  POSEventr.Drawer = drawer;
  POSEventr.TransDate = dfr;
  POSEventr.TransTime = tfr;
  foundf = true;
  while (LoopKey("MachineName",POSEventr,4,foundf)) begin
    if (POSEventr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (POSEventr.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (POSEventr.TransDate>dto) then begin
      foundf = false;
    end;
    if (nonblanktime(tto)) then begin
      if (POSEventr.TransDate==dto) then begin
        if (POSEventr.TransTime>tto) then begin
          foundf = false;
        end;
      end;
    end;
    testf = foundf;
    if (testf) then begin
      AddCashupToArray("POSEventVc","",POSEventr.SerNr,POSEventr.TransDate,POSEventr.TransTime,POSEventr.Event,avcn,acod,aser,adat,atim,atyp,acnt);
    end;
  end;
  return;
end;

global
procedure FillUpAllPOSBalance(Date dfr,Date dto,Time tfr,Time tto,string machine,string drawer,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  record POSBalanceVc POSBalancer;
  Boolean foundf,testf,firstf;

  firstf = false;
  POSBalancer.MachineName = machine;
  POSBalancer.Drawer = drawer;
  POSBalancer.TransDate = dfr;
  POSBalancer.TransTime = tfr;
  foundf = true;
  while (LoopKey("MachineName",POSBalancer,4,foundf)) begin
    if (POSBalancer.MachineName!=machine) then begin
      foundf = false;
    end;
    if (POSBalancer.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (POSBalancer.TransDate>dto) then begin
      foundf = false;
    end;
    if (nonblanktime(tto)) then begin
      if (POSBalancer.TransDate==dto) then begin
        if (POSBalancer.TransTime>tto) then begin
          foundf = false;
        end;
      end;
    end;
    testf = foundf;
    if ((testf) and (firstf==false)) then begin
      AddCashupToArray("POSBalanceVc","",POSBalancer.SerNr,POSBalancer.TransDate,POSBalancer.TransTime,-1,avcn,acod,aser,adat,atim,atyp,acnt);
    end;
    firstf = false;
  end;
  return;
end;

global
procedure FillUpAllCashEvents(Date dfr,Date dto,Time tfr,Time tto,string machine,string drawer,var array string avcn,var array string acod,var array LongInt aser,var array Date adat,var array Time atim,var array Integer atyp,var Integer acnt)
begin
  record CashVc Cashr;
  Boolean foundf,testf;

  Cashr.MachineName = machine;
  Cashr.Drawer = drawer;
  Cashr.TransDate = dfr;
  Cashr.TransTime = tfr;
  foundf = true;
  while (LoopKey("MachineName",Cashr,4,foundf)) begin
    if (Cashr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (Cashr.Drawer!=drawer) then begin
      foundf = false;
    end;
    if (Cashr.TransDate>dto) then begin
      foundf = false;
    end;
    if (nonblanktime(tto)) then begin
      if (Cashr.TransDate==dto) then begin
        if (Cashr.TransTime>tto) then begin
          foundf = false;
        end;
      end;
    end;
    testf = foundf;
    if (Cashr.OKFlag==0) then begin
      testf = false;
    end;
    if (testf) then begin
      AddCashupToArray("CashVc","",Cashr.SerNr,Cashr.TransDate,Cashr.TransTime,-1,avcn,acod,aser,adat,atim,atyp,acnt);
    end;
  end;
  return;
end;

procedure AddToITARray(string artcode,val sumexclvat,val tvat,val tvatinclconsump,val qty,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt)
begin
  Integer i2;

  for(i2=0;i2<aitcnt;i2=i2+1) begin
    if (artcode==aitcode[i2]) then begin     
      aitqty[i2] = aitqty[i2] + qty;
      aitvat[i2] = aitvat[i2] + tvat;
      aitsum[i2] = aitsum[i2] + sumexclvat - tvatinclconsump;
      goto LAddToITARray;
    end;
  end;  
  aitcode[aitcnt] = artcode;
  aitqty[aitcnt] = qty;
  aitvat[aitcnt] = tvat;
  aitsum[aitcnt] = sumexclvat - tvatinclconsump;
  aitcnt = aitcnt + 1;
LAddToITARray:;        
  return;
end;

function string 10 GetRestAccDiscountAcc(record CashierDefBlock CDb,string artcode)
begin
  record INVc INr;
  record ITVc ITr;
  string 10 res;
  record AccBlock ARb;
  
  res = CDb.RestAccDiscountAcc;
  INr.Code = artcode;
  if ReadFirstMain(INr,1,true) then begin
    if nonblank(INr.Group) then begin
      ITr.Code = INr.Group;
      if ReadFirstMain(ITr,1,true) then begin
        if nonblank(ITr.DiscountAcc) then begin
          res = ITr.DiscountAcc;
        end;
      end;
    end;
  end;
  if (blank(res)) then begin
    BlockLoad(ARb);
    res = ARb.DiscountAcc;
  end;
  GetRestAccDiscountAcc = res;
  return;
end;

global
procedure AddupPOSLine(Boolean salesf,string filename,Integer itemstat,string artcode,string insalesacc,string ivvatcode,string ivtaxtemcode,record TaxMatrixVc TMr,string headobj,string lineobj,Integer incvat,Integer NoTAXonVAT,
                       val sum,val price,val qty,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,
                       var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var val maxsum,Boolean addtoit,var record SMVc SMr)
begin
  Integer rwcnt,i,i2;
  row SMVc SMrw;
  record INVc INr;
  record ITVc ITr;
  record RestITVc RestITr;
  string 20 vatcode;
  record AccBlock ARAccRec;
  val tvat,t1,tvat2,t12;
  val sumexclvat;
  string 255 objects,objstr,tstr;
  string 40 salesacc;
  val smsum,tvatinclconsump;
  Boolean testf,UseTaxTemplatesforTaxCalcf;  
  row TaxMatrixVc TMrw;
  record CashierDefBlock CDb;
  record RoundBlock RoundRec;
  roundmode rndnone;

  UseTaxTemplatesforTaxCalcf = UseTaxTemplatesforTaxCalc;
  if (ReadFirstItemInclClosed(artcode,INr,false,true) and (maxsum!=0)) then begin
//  if (ReadFirstItemInclClosed(artcode,INr,false,true)) then begin //why do we need maxsum? sometimes we have negative values for items and they are skipped in posting to NL
    BlockLoad(CDb);
    BlockLoad(ARAccRec);
    BlockLoad(RoundRec); 
    objects = headobj;
    if (nonblank(objects)) then begin
      if (nonblank(lineobj)) then begin
        objects = objects & ",";
      end;
    end;
    objects = objects & lineobj;
    vatcode = INr.VATCode;
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
      if (blank(vatcode)) then begin
        vatcode = ITr.VATCodeDom;
      end;
    end;
    switch (filename) begin
      case "unknown":
        RestITr.Code = INr.Group;
        if (ReadFirstMain(RestITr,1,true)) then begin
          if (nonblank(objects)) then begin
            objects = objects & ",";
          end;
          objects = objects & RestITr.Object;
        end;
    end;
    if (blank(vatcode)) then begin 
      vatcode = ARAccRec.VATCodeDom;
    end;

    vatcode = ivvatcode;
    sumexclvat = sum;
    tvat = 0;
    if (UseTaxTemplatesforTaxCalcf) then begin
      tvat = CalculateTotalVATFromTaxMatrix3(TMr,incvat,true,HasLocalization("HRV")==false);
      if (HasLocalization("HRV")) then begin
        tvatinclconsump = CalculateTotalVATFromTaxMatrix3(TMr,incvat,true,true);
      end;
    end else begin
      if (RoundRec.VATCalcWay==1) then begin 
        MulVATIV(vatcode,sumexclvat,tvat,t1,incvat,NoTAXonVAT);
      end else begin
        MulVATIVExecute(vatcode,sumexclvat,tvat,t1,incvat,NoTAXonVAT,rndnone);
      end;      
    end;
    if (incvat!=0) then begin
      sumexclvat = sumexclvat - tvat;
    end;
    if (incvat!=0) then begin
      maxsum = maxsum - sumexclvat;
    end else begin
      maxsum = maxsum - (sumexclvat+tvat);
    end;
    if (addtoit) then begin
      for (i2=0;i2<avatcnt;i2=i2+1) begin
        if (vatcode==avatcode[i2]) then begin
          avatsum[i2] = avatsum[i2] + tvat;
          i2 = avatcnt;
        end;
      end;
      switch (itemstat) begin
        case 0:
          for (i2=0;i2<aitcnt;i2=i2+1) begin
            testf = true;
            if (ITr.Code!=aitcode[i2]) then begin testf = false; end;
            if (testf) then begin     
              aitqty[i2] = aitqty[i2] + qty;
              aitvat[i2] = aitvat[i2] + tvat;
              aitsum[i2] = aitsum[i2] + sumexclvat;
              if (incvat!=0) then begin
//                aitsum[i2] = aitsum[i2] - tvat;
              end;              
              i2 = aitcnt;
            end;
          end;        
        case 1:
          if (incvat!=0) then begin
            AddToITARray(artcode,sumexclvat,tvat,blankval,qty,aitcode,aitsum,aitvat,aitqty,aitcnt);
          end else begin
            AddToITARray(artcode,sumexclvat,tvat,blankval,qty,aitcode,aitsum,aitvat,aitqty,aitcnt);
          end;
      end;
      if (incvat!=0) then begin
        totsum = totsum + sumexclvat;
      end else begin
        totsum = totsum + sumexclvat;
      end;
      totvat = totvat + tvat;
    end;
    if (salesf) then begin
      salesacc = insalesacc;
      if (blank(salesacc)) then begin
        GetItemSalesAcc(INr.Code,0,salesacc);
      end;
      if (blank(salesacc)) then begin
        salesacc = ARAccRec.DomSalesAcc;
      end;
      ConvertSalesAcc(salesacc,0);
      if (GetAccName(salesacc,tstr,60)) then begin end;
      objstr = objects;
      switch (filename) begin
        case "RestAccVc":
          if (CDb.RestAccBookedDiscount!=0) then begin
            MulVATIV(vatcode,qty*price,tvat2,t12,incvat,NoTAXonVAT);
            AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,qty*price-tvat2,true,false,smsum);
            salesacc = GetRestAccDiscountAcc(CDb,artcode);
            MulVATIV(vatcode,qty*price-sum,tvat2,t12,incvat,NoTAXonVAT);
            AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,qty*price-sum-tvat2,true,true,smsum);
          end else begin
            AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,sumexclvat,true,false,smsum);
          end;
        otherwise
          AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,sumexclvat,true,false,smsum);
      end;
      if (UseTaxTemplatesforTaxCalcf) then begin
        rwcnt = MatRowCnt(TMr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(TMr,i,TMrw);
          GetVATCodeSalesVatAcc(TMrw.VATCode,salesacc);
          if (GetAccName(salesacc,tstr,60)==false) then begin end;
          objstr = "";
          AddSMRow(SMr,SMr.TransDate,salesacc,objstr,AddVATCodeToVATAccRows(vatcode),tstr,TMrw.VATSum,true,false,smsum);
        end;
      end else begin
        GetVATCodeSalesVatAcc(vatcode,salesacc);
        if (GetAccName(salesacc,tstr,60)==false) then begin end;
        objstr = headobj;
        AddSMRow(SMr,SMr.TransDate,salesacc,objstr,AddVATCodeToVATAccRows(vatcode),tstr,tvat,true,false,smsum);
      end;
    end;
  end;
  return;
end;

/*
what is maxsum for ? what if we have negative rows ? 
procedure AddupPOSLine(string filename,Integer itemstat,string artcode,string insalesacc,string ivvatcode,string ivtaxtemcode,record TaxMatrixVc TMr,string headobj,string lineobj,Integer incvat,Integer NoTAXonVAT,
                       val sum,val price,val qty,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,
                       var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var val maxsum,Boolean addtoit,var record SMVc SMr)
begin
  Integer rwcnt,i,i2;
  row SMVc SMrw;
  record INVc INr;
  record ITVc ITr;
  record RestITVc RestITr;
  string 20 vatcode;
  record AccBlock ARAccRec;
  val tvat,t1,tvat2,t12;
  val sumincvat;
  string 255 objects,objstr,tstr;
  string 40 salesacc;
  val smsum;
  Boolean testf,UseTaxTemplatesforTaxCalcf;  
  row TaxMatrixVc TMrw;
  record CashierDefBlock CDb;

  UseTaxTemplatesforTaxCalcf = UseTaxTemplatesforTaxCalc;
  if (ReadFirstItemInclClosed(artcode,INr,false,true) and (maxsum!=0)) then begin
    BlockLoad(CDb);
    BlockLoad(ARAccRec);
    objects = headobj;
    if (nonblank(objects)) then begin
      if (nonblank(lineobj)) then begin
        objects = objects & ",";
      end;
    end;
    objects = objects & lineobj;
    vatcode = INr.VATCode;
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
      if (blank(vatcode)) then begin
        vatcode = ITr.VATCodeDom;
      end;
    end;
    switch (filename) begin
      case "unknown":
        RestITr.Code = INr.Group;
        if (ReadFirstMain(RestITr,1,true)) then begin
          if (nonblank(objects)) then begin
            objects = objects & ",";
          end;
          objects = objects & RestITr.Object;
        end;
    end;
    if (blank(vatcode)) then begin 
      vatcode = ARAccRec.VATCodeDom;
    end;

    vatcode = ivvatcode;
    sumincvat = sum;
    tvat = 0;
    if (UseTaxTemplatesforTaxCalcf) then begin
      tvat = CalculateTotalVATFromTaxMatrix(TMr,incvat);
    end else begin
      MulVATIV(vatcode,sumincvat,tvat,t1,incvat,NoTAXonVAT);
    end;
    if (incvat==0) then begin
      sumincvat = sumincvat + tvat;
    end;
    if (maxsum>0) then begin
      if (sumincvat>maxsum) then begin
        sumincvat = maxsum;
        if (UseTaxTemplatesforTaxCalcf) then begin
          tvat = CalculateTotalVATFromTaxMatrix(TMr,incvat);
        end else begin
          MulVATIV(vatcode,sumincvat,tvat,t1,1,0);
        end;
      end;
      maxsum = maxsum - sumincvat;
    end else begin
      if (sumincvat<maxsum) then begin
        sumincvat = maxsum;
        if (UseTaxTemplatesforTaxCalcf) then begin
          tvat = CalculateTotalVATFromTaxMatrix(TMr,incvat);
        end else begin
          MulVATIV(vatcode,sumincvat,tvat,t1,1,0);
        end;
      end;
      maxsum = maxsum + sumincvat;
    end;

    if (addtoit) then begin
      for (i2=0;i2<avatcnt;i2=i2+1) begin
        if (vatcode == avatcode[i2]) then begin
          avatsum[i2] = avatsum[i2] + tvat;
          i2 = avatcnt;
        end;
      end;
      switch (itemstat) begin
        case 0:
          for (i2=0;i2<aitcnt;i2=i2+1) begin
            testf = true;
            if (ITr.Code!=aitcode[i2]) then begin testf = false; end;
            if (testf) then begin     
              aitqty[i2] = aitqty[i2] + qty;
              aitvat[i2] = aitvat[i2] + tvat;
              aitsum[i2] = aitsum[i2] + sumincvat;
              i2 = aitcnt;
            end;
          end;        
        case 1:
          AddToITARray(artcode,sumincvat,tvat,qty,aitcode,aitsum,aitvat,aitqty,aitcnt);
      end;
      totsum = totsum + sumincvat;
      totvat = totvat + tvat;
    end;
    salesacc = insalesacc;
    if (blank(salesacc)) then begin
      GetItemSalesAcc(INr.Code,0,salesacc);
    end;
    if (blank(salesacc)) then begin
      salesacc = ARAccRec.DomSalesAcc;
    end;
    ConvertSalesAcc(salesacc,0);

    if (GetAccName(salesacc,tstr,60)) then begin end;
    objstr = objects;
    switch (filename) begin
      case "RestAccVc":
        if (CDb.RestAccBookedDiscount!=0) then begin
          MulVATIV(vatcode,qty*price,tvat2,t12,incvat,NoTAXonVAT);
          AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,qty*price-tvat2,true,false,smsum);
          salesacc = GetRestAccDiscountAcc(CDb,artcode);
          MulVATIV(vatcode,qty*price-sum,tvat2,t12,incvat,NoTAXonVAT);
          AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,qty*price-sum-tvat2,true,true,smsum);
        end else begin
          AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,sumincvat-tvat,true,false,smsum);
        end;
      otherwise
        AddSMRow(SMr,SMr.TransDate,salesacc,objstr,vatcode,tstr,sumincvat-tvat,true,false,smsum);
    end;

    if (UseTaxTemplatesforTaxCalcf) then begin
      rwcnt = MatRowCnt(TMr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(TMr,i,TMrw);
        GetVATCodeSalesVatAcc(TMrw.VATCode,salesacc);
        if (GetAccName(salesacc,tstr,60)==false) then begin end;
        objstr = "";
        AddSMRow(SMr,SMr.TransDate,salesacc,objstr,AddVATCodeToVATAccRows(vatcode),tstr,TMrw.VATSum,true,false,smsum);
      end;
    end else begin
      GetVATCodeSalesVatAcc(vatcode,salesacc);
      if (GetAccName(salesacc,tstr,60)==false) then begin end;
      objstr = headobj;
      AddSMRow(SMr,SMr.TransDate,salesacc,objstr,AddVATCodeToVATAccRows(vatcode),tstr,tvat,true,false,smsum);
    end;
  end;
  return;
end;
*/

global
procedure AddPMPOSToSM2(Boolean dcf,string defcode,string thecode,string debugcomment,string objects,val sum,var record SMVc SMr)
begin
  row PMBlock PMrw;
  string 200 locdefcode;
  string 255 tstr;
  val smsum;

  if (sum!=0) then begin
    if (nonblank(thecode)) then begin
      locdefcode = thecode;
    end else begin
      locdefcode = defcode;
    end;
    if (GetPMRow(locdefcode,PMrw)==false) then begin 
      locdefcode = defcode;
      if (GetPMRow(locdefcode,PMrw)==false) then begin 
      end;
    end;
    if (GetAccName(PMrw.AccNr,tstr,60)==false) then begin end;
    tstr = debugcomment;
    AddSMRow(SMr,SMr.TransDate,PMrw.AccNr,objects,"",tstr,sum,true,dcf,smsum);
  end;
  return;
end;

global
procedure AddPMPOSToSM(string defcode,string thecode,string debugcomment,string objects,val sum,var record SMVc SMr)
begin
  AddPMPOSToSM2(true,defcode,thecode,debugcomment,objects,sum,SMr);
  return;
end;


procedure AddPMIPToSM(string defcode,string thecode,string debugcomment,string objects,val sum,var record SMVc SMr)
begin
  row PMBlock PMrw;
  string 200 locdefcode;
  string 255 tstr;
  val smsum;

  if (sum!=0) then begin
    if (nonblank(thecode)) then begin
      locdefcode = thecode;
    end else begin
      locdefcode = defcode;
    end;
    if (GetPMRow(locdefcode,PMrw)) then begin end;
    if (GetAccName(PMrw.AccNr,tstr,60)==false) then begin end;
    tstr = debugcomment;
    AddSMRow(SMr,SMr.TransDate,PMrw.AccNr,"","",tstr,sum,true,false,smsum);
  end;
  return;
end;

procedure AddPMPOSToSMSales(string defcode,string thecode,string salesacc,string debugcomment,string objects,val sum,var record SMVc SMr)
begin
  row PMBlock PMrw;
  string 200 locdefcode,acc;
  string 255 tstr;
  val smsum;

  if (sum!=0) then begin
    if (nonblank(thecode)) then begin
      locdefcode = thecode;
    end else begin
      locdefcode = defcode;
    end;
    acc = salesacc;
    if (blank(acc)) then begin
      if (GetPMRow(locdefcode,PMrw)) then begin end;
      acc = PMrw.AccNr;
    end;
    if (GetAccName(acc,tstr,60)==false) then begin end;
    tstr = debugcomment;
    AddSMRow(SMr,SMr.TransDate,acc,objects,"",tstr,sum,true,false,smsum);
  end;
  return;
end;

procedure AddAccountPOSToSM(string accstr,string debugcomment,string objects,val sum,var record SMVc SMr)
begin
  string 200 locdefcode;
  string 255 tstr;
  val smsum;

  if (sum!=0) then begin
    if (GetAccName(accstr,tstr,60)==false) then begin end;
    tstr = debugcomment;
    AddSMRow(SMr,SMr.TransDate,accstr,objects,"",tstr,sum,true,true,smsum);
  end;
  return;
end;

procedure PrepareAddIVCashTransRowNew(Boolean addtoit,Integer itemstat,record IVCashVc IVCashr,row IVCashVc IVCashrw,string object,
                                      var array string asalesacc,var array string asalesobj,var array val asalessum,var array val asalesrowsum,var array val asalesqty,
                                      var array string asalesvatcode,var array string asalestaxtemplatecode,var array integer asalesstp,var array val asalestax2,var array val asalestax2reb,
                                      array record TaxMatrixVc aTMr,
                                      var integer asalescnt,
                                      var array string aitemgroup,var array string aitemgroupvatcode,var array val aitemgroupqty,var array val aitemgroupsum,var Integer aitemgroupcnt)
begin
  string 255 objstr;
  string 10 revacc;
  string 20 ivraccno;
  record AccBlock ARAccb;
  integer i;
  val salesum,rowsum;
  integer stp;
  boolean testf;
  record TaxMatrixVc TMr;
  record INVc INr;

  BlockLoad(ARAccb);
  if (IVCashrw.ovst!=0) then begin
    goto LPrepareAddIVCashTransRowNewItemGroup;
  end;
  if (ARAccb.BookedDiscount!=0) then begin
    salesum = IVCashrw.Quant*IVCashrw.Price;
    if (blank(IVCashrw.Price)) then begin
      salesum = IVCashrw.Sum;
    end;
  end else begin
    salesum = IVCashrw.Sum;
  end;
  rowsum = IVCashrw.Sum;
  if (IVCashrw.stp==kInvoiceRowTypeCredit) then begin
    goto LPrepareAddIVCashTransRowNewItemGroup;
  end;
  if (IVCashrw.stp==kInvoiceRowTypeCorrection) then begin
    salesum = -salesum;
    rowsum = -rowsum;
  end;
  if (ARAccb.SkipObjectsOnIVFromHeader==0) then begin
    objstr = object;
  end;
  if (IVCashrw.stp==kInvoiceRowTypeNormal or (IVCashrw.stp==kInvoiceRowTypeStructuredItemComponent) or IVCashrw.stp==kInvoiceRowTypeLoan or IVCashrw.stp==kInvoiceRowTypeLoanInterest) or (IVCashrw.stp==kInvoiceRowTypeCorrection) or (IVCashrw.stp==kInvoiceRowTypeRetention) or (IVCashrw.stp==kInvoiceRowTypeMultiBuyDiscount) then begin
    if (nonblank(IVCashrw.Objects)) then begin
      if (nonblank(objstr)) then begin
        objstr = objstr & ",";
      end;  
      objstr = objstr & IVCashrw.Objects;
    end;
  end;
  switch (IVCashrw.stp) begin
    case kInvoiceRowTypeMultiBuyDiscount:
      revacc = ARAccb.DiscountAcc;
    otherwise
      revacc = IVCashrw.SalesAcc;
  end;
  if ((IVCashrw.stp==kInvoiceRowTypeLoan) or (IVCashrw.stp==kInvoiceRowTypeLoanInterest) or (IVCashrw.stp==kInvoiceRowTypeGiftVoucherSold)) then begin 
    if (blank(IVCashrw.SalesAcc)) then begin
      goto LPrepareAddIVCashTransRowNewItemGroup;
    end;
  end else begin
    if (blank(revacc)) then begin
      GetItemSalesAcc(IVCashrw.ArtCode,0,revacc);
    end;
    if (blank(revacc)) then begin
      revacc = ARAccb.DomSalesAcc;
    end;
  end;
  stp = IVCashrw.stp;
  if (stp==kInvoiceRowTypeCorrection) then begin
    stp = 1;
  end;
  ConvertSalesAcc(revacc,0);
  ivraccno = revacc;
  UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
  for (i=0;i<asalescnt;i=i+1) begin
    testf = false;
    if (UseTaxTemplatesforTaxCalc) then begin
      if ((asalesacc[i]==ivraccno) and (asalesobj[i]==objstr) and (asalestaxtemplatecode[i]==IVCashrw.TaxTemplateCode)
          and (asalesstp[i]==stp)) then begin
        testf = true;
      end;
    end else begin
      if ((asalesacc[i]==ivraccno) and (asalesobj[i]==objstr) and (asalesvatcode[i]==IVCashrw.VATCode)
          and (asalesstp[i]==stp)) then begin
        testf = true;
      end;
    end;
    if (testf) then begin
      asalessum[i] = asalessum[i] + salesum;
      asalesrowsum[i] = asalesrowsum[i] + rowsum;
      asalesqty[i] = asalesqty[i] + IVCashrw.Quant;
      AddRowTaxMatrixToSumTaxMatrix(TMr,aTMr[i],IVCashr.InclVAT);
      goto LPrepareAddIVCashTransRowNewSales;
    end;
  end;
  asalessum[asalescnt] = salesum;
  asalesrowsum[asalescnt] = rowsum;
  asalesqty[asalescnt] = IVCashrw.Quant;
  asalesacc[asalescnt] = ivraccno;
  asalesobj[asalescnt] = objstr;
  asalesvatcode[asalescnt] = IVCashrw.VATCode;
  asalestaxtemplatecode[asalescnt] = IVCashrw.TaxTemplateCode;
  asalesstp[asalescnt] = stp;
  asalestax2[asalescnt] = IVCashrw.TAX2Prc;
  asalestax2reb[asalescnt] = IVCashrw.TAX2Reb;
  aTMr[asalescnt] = TMr;
  asalescnt = asalescnt + 1;
LPrepareAddIVCashTransRowNewSales:;
  if (addtoit) then begin
    if (itemstat==0) then begin
      if (IVCashrw.stp==kInvoiceRowTypeNormal or (IVCashrw.stp==kInvoiceRowTypeStructuredItemComponent) or IVCashrw.stp==kInvoiceRowTypeLoan or IVCashrw.stp==kInvoiceRowTypeLoanInterest) or (IVCashrw.stp==kInvoiceRowTypeCorrection) or (IVCashrw.stp==kInvoiceRowTypeRetention) or (IVCashrw.stp==kInvoiceRowTypeMultiBuyDiscount) then begin
        ReadFirstItemInclClosed(IVCashrw.ArtCode,INr,false,true);
        for (i=0;i<aitemgroupcnt;i=i+1) begin
          testf = false;
          if (aitemgroup[i]==INr.Group) and (aitemgroupvatcode[i]==IVCashrw.VATCode) then begin testf = true; end;
          if (testf) then begin
            aitemgroupsum[i] = aitemgroupsum[i] + rowsum;
            aitemgroupqty[i] = aitemgroupqty[i] + IVCashrw.Quant;
            goto LPrepareAddIVCashTransRowNewItemGroup;
          end;
        end;
        aitemgroup[aitemgroupcnt] = INr.Group;
        aitemgroupvatcode[aitemgroupcnt] = IVCashrw.VATCode;
        aitemgroupsum[aitemgroupcnt] = rowsum;
        aitemgroupqty[aitemgroupcnt] = IVCashrw.Quant;
        aitemgroupcnt = aitemgroupcnt + 1;
      end;
    end;
  end;
LPrepareAddIVCashTransRowNewItemGroup:;

  return;
end;

procedure IVCashCalcTotalVatPerLine(string vatcode,record IVCashVc IVCashr,var val tvat,val salessum,var val t1)
begin
  row IVCashVc IVCashrw;
  integer i,rwcnt,ivrwstp;
  boolean testf;
  record DefCashBlock DCb;
  roundmode roundlines,rndtotal,rndvat,rndnone;
  val totsum,vatv;

  BlockLoad(DCb);
  MulVATIV(vatcode,salessum,vatv,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);  
  tvat = 0;
  totsum = 0;
  GetCurncyRoundoff(IVCashr.CurncyCode,DCb.DefCashPayMode,"IVCashVc",rndtotal,roundlines,rndvat);
  rwcnt = MatRowCnt(IVCashr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    ivrwstp = IVCashrw.stp;
    testf = false;
    if ((ivrwstp==kInvoiceRowTypeNormal) or (ivrwstp==kInvoiceRowTypeStructuredItemComponent) or (ivrwstp==kInvoiceRowTypeInterest) or 
    (ivrwstp==kInvoiceRowTypeDownpayment) or (ivrwstp==kInvoiceRowTypeLoan) or (ivrwstp==kInvoiceRowTypeLoanInterest) or 
    (ivrwstp==kInvoiceRowTypeCorrection) or (ivrwstp==kInvoiceRowTypeGiftVoucherSold) or (ivrwstp==kInvoiceRowTypeRetention) or 
    (ivrwstp==kInvoiceRowTypeMultiBuyDiscount)) then begin
      testf = true;
    end;
    if (testf and vatcode==IVCashrw.VATCode) then begin 
      MulVATIV(IVCashrw.VATCode,IVCashrw.Sum,vatv,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
      vatv = Round(vatv,rndvat);
      tvat = tvat + vatv;
    end;
  end;
  return;
end;

procedure AddIVCashTransRowsNew(Boolean addtoit,Integer itemstat,var record SMVc gSMp,record IVCashVc IVCashr,var integer vatcnt,
                               array string asalesacc,array string asalesobj,array val asalessum,array val asalesrowsum,
                               array val asalesqty,array string asalesvatcode,var array string asalestaxtemplatecode,
                               array integer asalesstp,array val asalestax2,array val asalestax2reb,
                               array record TaxMatrixVc aTMr,integer asalescnt,
                               var array string aitemgroup,var array string aitemgroupvatcode,var array val aitemgroupqty,var array val aitemgroupsum,var Integer aitemgroupcnt,
                               var val totsum,var val totvat,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt)
begin
  record TaxMatrixVc TMr;
  row TaxMatrixVc TMrw;
  record AccBlock ARAccb;
  record RoundBlock RoundRec;
  record VATCodeBlock VATCodeRec;
  row VATCodeBlock VATCoderw;
  string 255 objstr;
  boolean UseTaxTemplatesforTaxCalcf,testf;
  string 255 tstr;
  string 2 vatcod,taxtemplatecode;
  string 10 revacc;
  string 20 ivraccno;
  integer i,rwcnt,i2,i3,rwcnt2,vcrwcnt;
  integer ivrwstp;
  val t,salessum,quant,rowsum;
  val smsum;
  val tvat,t1;
  record SMVc VATr;
  row SMVc VATrw;
  roundmode rndnone;
  vector val vitemgroupsum;

  UseTaxTemplatesforTaxCalcf = UseTaxTemplatesforTaxCalc;
  BlockLoad(ARAccb);
  BlockLoad(VATCodeRec);
  BlockLoad(RoundRec);  
  SetupVATBase(VATr,vcrwcnt);  
  for (i=0;i<asalescnt;i=i+1) begin
    RecordCopy(TMr,aTMr[i]);
    salessum = asalessum[i];
    rowsum = asalesrowsum[i];
    quant = asalesqty[i];
    revacc = asalesacc[i];
    objstr = asalesobj[i];
    ivraccno = revacc;
    if (GetAccName(ivraccno,tstr,60)==false) then begin
      goto LAddIVCashTransRowsNew;
    end;
    vatcod = asalesvatcode[i];
    if (blank(vatcod)) then begin
      vatcod = ARAccb.VATCodeDom;
    end;
    taxtemplatecode = asalestaxtemplatecode[i];
    if (blank(taxtemplatecode)) then begin
      taxtemplatecode = ARAccb.TaxTemplateCode;
    end;
    if (blank(vatcod)) then begin
      if (UseTaxTemplatesforTaxCalcf) then begin
      end else begin
        rwcnt = MatRowCnt(VATCodeRec);
        if (rwcnt>0) then begin
          MatRowGet(VATCodeRec,0,VATCoderw);
          vatcod = VATCoderw.VATCode;
        end;  
      end;
    end;
    if (blank(taxtemplatecode)) then begin
      rwcnt = MatRowCnt(VATCodeRec);
      if (rwcnt>0) then begin
        MatRowGet(VATCodeRec,0,VATCoderw);
        taxtemplatecode = VATCoderw.VATCode;
      end;  
    end;
    ivrwstp = asalesstp[i];
    if ((ivrwstp==kInvoiceRowTypeNormal) or (ivrwstp==kInvoiceRowTypeStructuredItemComponent) or (ivrwstp==kInvoiceRowTypeInterest) or (ivrwstp==kInvoiceRowTypeDownpayment) or (ivrwstp==kInvoiceRowTypeLoan) or (ivrwstp==kInvoiceRowTypeLoanInterest) or (ivrwstp==kInvoiceRowTypeCorrection) or (ivrwstp==kInvoiceRowTypeGiftVoucherSold) or (ivrwstp==kInvoiceRowTypeRetention) or (ivrwstp==kInvoiceRowTypeMultiBuyDiscount)) then begin
      if (UseTaxTemplatesforTaxCalcf==false) then begin
        switch (IVCashr.InclVAT) begin
           case 2:
             switch (IVCashr.NoTAXonVAT) begin
               case 2:
                 MulVATIV(vatcod,asalessum[i],tvat,t1,IVCashr.InclVAT,0);
               otherwise
                 MulVATIV(vatcod,asalessum[i],tvat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
             end;
           otherwise
              if (RoundRec.VATCalcWay==1) then begin 
                IVCashCalcTotalVatPerLine(vatcod,IVCashr,tvat,asalessum[i],t1);
              end else begin
                MulVATIV(vatcod,asalessum[i],tvat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
              end;
        end;
        if (IVCashr.InclVAT>0) then begin
          AddSMRow(gSMp,gSMp.TransDate,revacc,objstr,AddVATCodeToVATAccRows(vatcod),tstr,salessum-tvat,true,false,smsum);
        end else begin
          AddSMRow(gSMp,gSMp.TransDate,revacc,objstr,AddVATCodeToVATAccRows(vatcod),tstr,salessum,true,false,smsum);
        end;
        switch (RoundRec.VATCalcWay) begin
          case 0:
            AddVATBase(VATr,vatcod,salessum,blankval,vcrwcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
          case 1:
            AddVATBase(VATr,vatcod,salessum,blankval,vcrwcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
            AddVATVat(VATr,vatcod,tvat,vcrwcnt);
        end;
      end else begin
        AddSMRow(gSMp,gSMp.TransDate,revacc,objstr,AddVATCodeToVATAccRows(vatcod),tstr,salessum,true,false,smsum);
        rwcnt2 = MatRowCnt(TMr);
        for (i2=0;i2<rwcnt2;i2=i2+1) begin
          MatRowGet(TMr,i2,TMrw);
          GetVATCodeSalesVatAcc(TMrw.VATCode,revacc);
          if (GetAccName(revacc,tstr,60)==false) then begin end;
          objstr = "";
          AddSMRow(gSMp,gSMp.TransDate,revacc,objstr,AddVATCodeToVATAccRows(TMrw.VATCode),tstr,TMrw.VATSum,true,false,smsum);
        end;
      end;
    end;
LAddIVCashTransRowsNewRow:;    
  end; 
  vcrwcnt = MatRowCnt(VATCodeRec);
  for (i=0;i<vcrwcnt;i=i+1) begin
    MatRowGet(VATCodeRec,i,VATCoderw);
    MatRowGet(VATr,i,VATrw);
    if (VATrw.DebVal!=0) then begin 
      if (nonblank(VATCoderw.VATCode)) then begin
        switch (RoundRec.VATCalcWay) begin
          case 0:    
            MulVATIV(VATCoderw.VATCode,VATrw.DebVal,tvat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
          case 1:
            tvat = VATrw.CredVal;
            t1 = VATrw.CurCredVal;
        end;       
        if (tvat!=0) then begin
          if (GetAccName(VATCoderw.SalesVATAcc,tstr,60)==false) then begin 
          end;
          AddSMRow(gSMp,gSMp.TransDate,VATCoderw.SalesVATAcc,objstr,AddVATCodeToVATAccRows(VATCoderw.VATCode),tstr,tvat,true,false,smsum);
        end;       
      end;
    end;
  end;
  if (itemstat==0) then begin
    RecordClear(TMr);
    SetupVATBase(VATr,vcrwcnt);
    for (i=0;i<aitemgroupcnt;i=i+1) begin
      AddVATBase(VATr,aitemgroupvatcode[i],aitemgroupsum[i],blankval,vcrwcnt,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
      vitemgroupsum[aitemgroupvatcode[i]] = vitemgroupsum[aitemgroupvatcode[i]] + aitemgroupsum[i];
    end;
    vcrwcnt = MatRowCnt(VATCodeRec);
    for (i3=0;i3<vcrwcnt;i3=i3+1) begin
      MatRowGet(VATCodeRec,i3,VATCoderw);
      MatRowGet(VATr,i3,VATrw);
      if (VATrw.DebVal!=0) then begin 
        if (nonblank(VATCoderw.VATCode)) then begin
          switch (RoundRec.VATCalcWay) begin
            case 0:    
              MulVATIV(VATCoderw.VATCode,VATrw.DebVal,tvat,t1,IVCashr.InclVAT,IVCashr.NoTAXonVAT);
            case 1:
              tvat = VATrw.CredVal2;
              t1 = VATrw.CurCredVal;
          end;
          if (tvat!=0 or VATrw.DebVal!=0) then begin
            if (addtoit) then begin
              switch (itemstat) begin
                case 0:
                  for (i=0;i<aitemgroupcnt;i=i+1) begin
                    for (i2=0;i2<aitcnt;i2=i2+1) begin
                      testf = true;
                      if (aitemgroup[i]!=aitcode[i2]) then begin testf = false; end;
                      if (testf) then begin 
                        t = (tvat*aitemgroupsum[i])/vitemgroupsum[aitemgroupvatcode[i]];
                        t = Round(t,SetRoundModeD(2));                            
                        aitqty[i2] = aitqty[i2] + aitemgroupqty[i];
                        aitvat[i2] = aitvat[i2] + t;
                        aitsum[i2] = aitsum[i2] + aitemgroupsum[i];
                        if (IVCashr.InclVAT!=0) then begin
                          aitsum[i2] = aitsum[i2] - t;
                        end;                      
                        totsum = totsum + aitemgroupsum[i];
                        if (IVCashr.InclVAT!=0) then begin
                          totsum = totsum - t;
                        end;
                        totvat = totvat + t;
                        i2 = aitcnt;
                      end;
                    end;        
                  end;        
                case 1:
                   //other place
              end;
            end;

          end;       
        end;
      end;
    end;
  end;
LAddIVCashTransRowsNew:;
  return;
end;

procedure AttToIVCashSpecArrays(record AccBlock Accb,Integer itemstat,record IVCashVc IVCashr,string defmode,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var val maxsum,Boolean addtoit,var record SMVc SMr)
begin
  Integer rwcnt,i,lasti,vatcnt;
  row IVCashVc IVCashrw;
  val s,smsum,ivtotsum,ivvatsum;
  record TaxMatrixVc TMr;
  row TaxMatrixVc TMrw;
  row SMVc SMrw;
  string 40 salesacc;
  Array string 2 asalesvatcode;
  Array string 10 asalestaxtemplatecode;
  Array record TaxMatrixVc aTMr;
  Array string 10 asalesacc;
  Array string 10 asalesperiodcode;
  Array string 255 asalesobj;
  Array val asalessum;
  Array val asalesrowsum;
  Array val asalesqty;
  Array Integer asalesstp;  
  Array val asalestax2;
  Array val asalestax2reb;
  Integer asalescnt;
  boolean UseTaxTemplatesforTaxCalcf,RetValueAddedf,creditf;
  Array string 10 aitemgroup;
  Array string 10 aitemgroupvatcode;
  Array val aitemgroupqty;
  Array val aitemgroupsum;
  Integer aitemgroupcnt;
  roundmode rndtotal,roundlines,rndvat;
  record DefCashBlock DCb;
  record SMVc dummySMr;
  transaction Integer gCashupReportMode;
  
  UseTaxTemplatesforTaxCalcf = UseTaxTemplatesforTaxCalc;
/*  
  if (UseTaxTemplatesforTaxCalcf) then begin  
//SMr is TOTAL Transaction , for VAT u should have made another record SMVc VATr  
    SetupVATBase(SMr,vatcnt);
    for (i=0;i<vatcnt;i=i+1) begin
      MatRowGet(SMr,i,SMrw);
      GetVATCodeSalesVatAcc(SMrw.VATCode,salesacc);
      SMrw.AccNumber = salesacc;
      MatRowPut(SMr,i,SMrw);
    end;
  end;
*/  
  rwcnt = MatRowCnt(IVCashr);
  for(i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    if (IVCashr.InvType==kPOSInvoiceTypeCredit) then begin
      IVCashrw.Sum = -IVCashrw.Sum;
    end;
    switch (IVCashrw.stp) begin
      case kInvoiceRowTypeGiftVoucherSold:
        s = IVCashrw.Sum;
        AddPMPOSToSMSales(IVCashrw.PayMode,IVCashrw.PayMode,IVCashrw.SalesAcc,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        AddToITARray("GV-SOLD",IVCashrw.Sum,blankval,blankval,1,aitcode,aitsum,aitvat,aitqty,aitcnt);
        ivtotsum = ivtotsum + IVCashrw.Sum;
      case kInvoiceRowTypeCashPayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVCashr.CurncyCode,IVCashr.RetValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeCreditCardPayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVCashr.CurncyCode,IVCashr.RetValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeChequePayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVCashr.CurncyCode,IVCashr.RetValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeLoyaltyPointsPayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVCashr.CurncyCode,IVCashr.RetValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeGiftVoucherPayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVCashr.CurncyCode,IVCashr.RetValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeOnAccountPayment:
        s = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
        if (nonblank(IVCashrw.SalesAcc)) then begin
          AddSMRow(SMr,SMr.TransDate,IVCashrw.SalesAcc,IVCashr.Objects,"","IVCash " & IVCashr.SerNr & IVCashrw.Spec,s,true,false,smsum);
        end else begin
          AddPMPOSToSM2(false,IVCashrw.PayMode,IVCashrw.PayMode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
        end;
      case kInvoiceRowTypeMultiBuyDiscount:
        UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
        AddupPOSLine(true,"IVCashVc",itemstat,IVCashrw.ArtCode,IVCashrw.SalesAcc,IVCashrw.VATCode,IVCashrw.TaxTemplateCode,TMr,IVCashr.Objects,IVCashrw.Objects,IVCashr.InclVAT,IVCashr.NoTAXonVAT,IVCashrw.Sum,IVCashrw.Price,IVCashrw.Quant,aitcode,aitsum,aitvat,aitqty,aitcnt,ivtotsum,ivvatsum,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
        if (nonblank(IVCashrw.ArtCode)) then begin
          lasti = i;
        end;
      otherwise
        if (UseTaxTemplatesforTaxCalcf==false) then begin
          if (itemstat!=0 or (addtoit and gCashupReportMode==kCashupReportCleanCash_SameAsInCashupReportFile)) then begin  //addtoit cannot be here, is doubling sales numbers
            AddupPOSLine(true,"IVCashVc",itemstat,IVCashrw.ArtCode,IVCashrw.SalesAcc,IVCashrw.VATCode,IVCashrw.TaxTemplateCode,TMr,IVCashr.Objects,IVCashrw.Objects,IVCashr.InclVAT,IVCashr.NoTAXonVAT,IVCashrw.Sum,IVCashrw.Price,IVCashrw.Quant,aitcode,aitsum,aitvat,aitqty,aitcnt,ivtotsum,ivvatsum,avatcode,avatsum,avatcnt,maxsum,addtoit,dummySMr);
            if (nonblank(IVCashrw.ArtCode)) then begin
              lasti = i;
            end;
          end else begin
            PrepareAddIVCashTransRowNew(addtoit,itemstat,IVCashr,IVCashrw,IVCashr.Objects,
                                        asalesacc,asalesobj,asalessum,asalesrowsum,asalesqty,
                                        asalesvatcode,asalestaxtemplatecode,asalesstp,asalestax2,asalestax2reb,
                                        aTMr,asalescnt,
                                        aitemgroup,aitemgroupvatcode,aitemgroupqty,aitemgroupsum,aitemgroupcnt);
          end;
        end else begin
          UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
          AddupPOSLine(true,"IVCashVc",itemstat,IVCashrw.ArtCode,IVCashrw.SalesAcc,IVCashrw.VATCode,IVCashrw.TaxTemplateCode,TMr,IVCashr.Objects,IVCashrw.Objects,IVCashr.InclVAT,IVCashr.NoTAXonVAT,IVCashrw.Sum,IVCashrw.Price,IVCashrw.Quant,aitcode,aitsum,aitvat,aitqty,aitcnt,ivtotsum,ivvatsum,avatcode,avatsum,avatcnt,maxsum,addtoit,dummySMr);
          if (nonblank(IVCashrw.ArtCode)) then begin
            lasti = i;
          end;
        end;
    end;
  end;
  // These lines cause the last item to be added to the vat calculation twice....
  //without those lines no sales is booked
  if (UseTaxTemplatesforTaxCalcf==false) then begin
    AddIVCashTransRowsNew(addtoit,itemstat,SMr,IVCashr,vatcnt,
                          asalesacc,asalesobj,asalessum,asalesrowsum,
                          asalesqty,asalesvatcode,asalestaxtemplatecode,
                          asalesstp,asalestax2,asalestax2reb,
                          aTMr,asalescnt,
                          aitemgroup,aitemgroupvatcode,aitemgroupqty,aitemgroupsum,aitemgroupcnt,
                          ivtotsum,ivvatsum,aitcode,aitsum,aitvat,aitqty,aitcnt);
  end else begin
/*
jjtmp  
    if (lasti>-1) then begin
      MatRowGet(IVCashr,lasti,IVCashrw);
      UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
      AddupPOSLine(true,"IVCashVc",itemstat,IVCashrw.ArtCode,IVCashrw.SalesAcc,IVCashrw.VATCode,IVCashrw.TaxTemplateCode,TMr,IVCashr.Objects,IVCashrw.Objects,IVCashr.InclVAT,IVCashr.NoTAXonVAT,IVCashr.Sum0,0,0,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,ivvatsum,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
    end;
*/    
  end;
  if (IVCashr.RetValue<0) then begin
    s = IVCashr.CashValue;
  end else begin
    s = IVCashr.CashValue-IVCashr.RetValue;
  end;
  s = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  if (nonblank(Accb.CashBackAcc)) then begin
    AddAccountPOSToSM(Accb.CashBackAcc,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
  end else begin
    if (RetValueAddedf==false) then begin
  //    AddPMPOSToSM(defmode,defmode,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
    end;
//we decided not to post change if CashBackAcc not defined
  end;

  BlockLoad(DCb);
  GetCurncyRoundoff(IVCashr.CurncyCode,DCb.DefCashPayMode,"IVCashVc",rndtotal,roundlines,rndvat);
  totsum = totsum + Round(ivtotsum,rndtotal);
  totvat = totvat + Round(ivvatsum,rndtotal);

  s = MulRateToBase1(IVCashr.CurncyCode,IVCashr.RecValue,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  AddPMPOSToSM(defmode,IVCashr.PayDeal,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
  s = MulRateToBase1(IVCashr.CurncyCode,IVCashr.RecValue2,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
  AddPMPOSToSM(defmode,IVCashr.PayDeal2,"IVCash " & IVCashr.SerNr & IVCashrw.Spec,IVCashr.Objects,s,SMr);
  return;
end;

procedure AddIVCashtoCleanCashSummary(record IVCashVc IVCashr,val sum,var vector val vstatussum)
begin
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  string 255 what;
  val swreb,sworeb,s;
  record GeneralOptionBlock GOb;
  Boolean rebatef,negativef;
  
  BlockLoad(GOb);
  if (nonblank(IVCashr.OfficialSerNr)) then begin
    if (nonblank(IVCashr.OfficialSerNr2)) then begin
      what = "registeredcopy"; 
    end else begin
      what = "registeredorig"; 
    end;
  end else begin
    what = "notregistered"; 
  end;
  vstatussum[what & "_count"] = vstatussum[what & "_count"] + 1; 
  vstatussum[what & "_sum"] = vstatussum[what & "_sum"] + sum; 
  rwcnt = MatRowCnt(IVCashr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVCashr,i,IVCashrw);
    if (IVCashrw.Sum<0) then begin
      negativef = true;
      s = -MulRateToBase1(IVCashr.CurncyCode,IVCashrw.Sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
      vstatussum["negativeinvoicesum"] = vstatussum["negativeinvoicesum"] + s; 
    end else begin
//      CalcSum(IVCashrw.Quant,IVCashrw.Price,IVCashrw.PriceFactor,0.00,sworeb,GOb.UseDiscount);  
      sworeb = FormulaDiscountCalcSum(IVCashrw.Quant,IVCashrw.Price,IVCashrw.PriceFactor,0.00);  
      swreb = FormulaDiscountCalcSum(IVCashrw.Quant,IVCashrw.Price,IVCashrw.PriceFactor,IVCashrw.vRebate);  
      if (swreb!=sworeb) then begin
        s = sworeb - swreb;
        s = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
        rebatef = true;
        vstatussum["rebateinvoicesum"] = vstatussum["rebateinvoicesum"] + s; 
      end;
    end;
  end;
  if (IVCashr.OKFlag!=0) then begin
    vstatussum["registeredorig_count"] = vstatussum["registeredorig_count"] + 1;
  end else begin
//    vstatussum["registeredorig_count"] = vstatussum["registeredorig_count"] + 1;
  end;
  if (negativef) then begin
    vstatussum["negativeinvoicecount"] = vstatussum["negativeinvoicecount"] + 1; 
  end;
  if (rebatef) then begin
    vstatussum["rebateinvoicecount"] = vstatussum["rebateinvoicecount"] + 1; 
  end;
  return;
end;

global
updating procedure TransferIVCashVctoIVVc(record IVCashVc IVCashr)
begin
  record IVVc IVr;
  record IVCashVc oldIVCashr;
  
  if (IsMaintenance==false) then begin
    goto LTransferIVCashVctoIVVc;
  end;
  if (ReadFirstMain(IVCashr,1,true)==false) then begin
    goto LTransferIVCashVctoIVVc;
  end;
  RecordCopy(oldIVCashr,IVCashr);
  IVCashToIV_FromPOS(IVCashr,IVr);
  IVr.OKFlag = 1;
  if (RecordStore(IVr,false)) then begin
    IVVcGenTrans(IVr.SerNr,IVr.SerNr);
    IVCashr.IVNr = IVr.SerNr;
    RecordUpdate(oldIVCashr,IVCashr,false);
  end;
LTransferIVCashVctoIVVc:;  
  return;
end;

global
procedure FillUpAllIVCash(Integer itemstat,Date dfr,Date dto,Time tfr,Time tto,Date startdat,Time starttime,Date enddat,Time endtime,string machine,string drawer,string paymode,
                          var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt,Integer detail,
                          var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,Boolean addtoit,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var record SMVc SMr,
                          var vector val vstatussum)
begin
  record IVCashVc IVCashr;
  record DefCashBlock DCb;
  Boolean foundf,testf,RetValueAddedf;
  val s,sb1,maxsum,sum,changev,PaymentValue,RetValue,rv,sign;
  row IVCashVc IVCashrw;
  Integer i,rwcnt;
  transaction Integer gCashupReportMode;
  record BaseCurBlock BCb;
  record AccBlock Accb;
  string 255 RetValuePayMode;

  BlockLoad(DCb);
  BlockLoad(BCb);
  BlockLoad(Accb);
  foundf = true;
  IVCashr.LocalMachineCode = machine;
  IVCashr.DrawerCode = drawer;
  IVCashr.TransDate = dfr;
  IVCashr.TransTime = tfr;
  while (LoopKey("Cashup",IVCashr,4,foundf)) begin
    if (IVCashr.LocalMachineCode!=machine) then begin
      foundf = false;
    end;
    if (IVCashr.DrawerCode!=drawer) then begin
      foundf = false;
    end;
    if (IVCashr.TransDate>enddat) then begin
      foundf = false;
    end;
    if (nonblankdate(dto)) then begin
      if (IVCashr.TransDate>dto) then begin
        foundf = false;
      end;
      if (IVCashr.TransDate==dto) then begin
        if (nonblanktime(tto)) then begin
          if (IVCashr.TransTime>=tto) then begin
            foundf = false;
          end;
        end;
      end;
    end;
    testf = foundf;
    if (IVCashr.Invalid!=0) then begin
      testf = false;
    end;
    if (IVCashr.OKFlag==0) then begin
      testf = false;
    end;
    if (IVCashr.Invalid!=0) then begin testf = false; end;  
    if (IVCashr.TransferToSL!=0) then begin
      if (IVCashr.IVNr>0) then begin
        testf = false;
      end;
      if (testf) then begin
        qupdating.TransferIVCashVctoIVVc(IVCashr);
      end;
    end else begin
      sign = 1.00;
      if (IVCashr.InvType==kPOSInvoiceTypeCredit) then begin
        sign = -1.00;
      end;
      if (testf) then begin
        if (detail!=0) and (detail!=2) then begin
          changev = blankval;
          s = blankval;
          sb1 = blankval;
          if (nonblank(paymode)) then begin
            testf = false;
            s = blankval;
            if (IVCashr.PayDeal==paymode) then begin
              if (IVCashr.RecValue!=0) then begin 
                s = IVCashr.RecValue;
                testf = true; 
              end;
            end;
            if (IVCashr.PayDeal2==paymode) then begin
              if (IVCashr.RecValue2!=0) then begin 
                s = IVCashr.RecValue2;
                testf = true; 
              end;
            end;
            if (DCb.DefCashPayMode==paymode) then begin
              if (IVCashr.RetValue<0) then begin
                s = IVCashr.CashValue - IVCashr.RetValue;
              end else begin
                s = IVCashr.CashValue - IVCashr.RetValue;
              end;
              testf = true;
            end;
            rwcnt = MatRowCnt(IVCashr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(IVCashr,i,IVCashrw);
              switch (IVCashrw.stp) begin
                case kInvoiceRowTypeGiftVoucherPayment: 
                  if (IVCashrw.PayMode==paymode) then begin
                    s = s + sign*IVCashrw.Sum;
                  end;
                case kInvoiceRowTypeChequePayment: 
                  if (IVCashrw.PayMode==paymode) then begin
                    s = s + sign*IVCashrw.Sum;
                  end;
                case kInvoiceRowTypeCashPayment:
                  if (IVCashrw.PayMode==paymode) then begin
                    if (IVCashrw.CurncyCode==BCb.BaseCur1) then begin
                      s = s + sign*IVCashrw.Sum;
                    end else begin
                      s = s + sign*IVCashrw.Sum;
                    end;
                  end;            
                case kInvoiceRowTypeLoyaltyPointsPayment:
                  if (IVCashrw.PayMode==paymode) then begin
                    if (IVCashrw.CurncyCode==BCb.BaseCur1) then begin
                      s = s + sign*IVCashrw.Sum;
                    end else begin
                      s = s + sign*IVCashrw.Sum;
                    end;
                  end;            
                case kInvoiceRowTypeCreditCardPayment:
                  if (IVCashrw.PayMode==paymode) then begin
                    s = s + sign*IVCashrw.Sum;
                  end;            
              end;
            end;       
            if (s!=0) then begin testf = true; end;
          end;
        end;
      end;
      if (testf) then begin
        PaymentValue = blankval;
        RetValue = blankval;
        if (IVCashr.TransferToSL!=0) then begin
          
        end else begin      
          sum = blankval;
          if (detail!=0) and (detail!=2) then begin
            if (nonblank(paymode)) then begin
            end else begin
              if (IVCashr.RetValue<0) then begin // Can never happen, but perhaps one day
                s = IVCashr.TendValue;
                if (s==0) then begin
                  s = IVCashr.CashValue;
                end;
              end else begin
                if (IVCashr.TendValue!=0) then begin
                  s = IVCashr.TendValue - IVCashr.RetValue;
                end else begin
                  s = IVCashr.CashValue - IVCashr.RetValue;
                end;
              end;
              s = s + IVCashr.RecValue;
              s = s + IVCashr.RecValue2;
            end;
            if (s!=0) then begin
              sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
              rwcnt = MatRowCnt(IVCashr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(IVCashr,i,IVCashrw);
                switch (IVCashrw.stp) begin
                  case kInvoiceRowTypeGiftVoucherPayment:
                    sb1 = MulRateToBase1(IVCashr.CurncyCode,sign*IVCashrw.Sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
                  case kInvoiceRowTypeChequePayment:
                    sb1 = MulRateToBase1(IVCashr.CurncyCode,sign*IVCashrw.Sum,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
                  case kInvoiceRowTypeLoyaltyPointsPayment:
                    sb1 = MulRateToBase1(IVCashrw.CurncyCode,sign*IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  case kInvoiceRowTypeCashPayment:
                    sb1 = MulRateToBase1(IVCashrw.CurncyCode,sign*IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  case kInvoiceRowTypeCreditCardPayment:
                    sb1 = MulRateToBase1(IVCashrw.CurncyCode,sign*IVCashrw.Sum,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                end;
              end;  
              sum = sum + s;
              aivcode[acnt] = IVCashr.SerNr;
              if (s<0) then begin
                aivoutval[acnt] = aivoutval[acnt] - s;
                aivb1outval[acnt] = aivb1outval[acnt] - sb1;
                aivval[acnt] = BlankVal;
                aivb1val[acnt] = BlankVal;
              end else begin
                aivval[acnt] = aivval[acnt] + s;
                aivb1val[acnt] = aivb1val[acnt] + sb1;
                aivoutval[acnt] = BlankVal;
                aivb1outval[acnt] = BlankVal;
              end;
              atipsum[acnt] = BlankVal;
              if (changev!=0) then begin
                aivoutval[acnt] = aivoutval[acnt] - changev;
                aivb1outval[acnt] = aivb1outval[acnt] - MulRateToBase1(IVCashr.CurncyCode,changev,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);;
              end;
              
              acnt = acnt + 1;
            end;
            maxsum = s;
          end else begin
            RetValueAddedf = false;
            s = blankval;
            sb1 = blankval;
            maxsum = blankval;
            rwcnt = MatRowCnt(IVCashr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(IVCashr,i,IVCashrw);
              switch (IVCashrw.stp) begin
                case kInvoiceRowTypeGiftVoucherPayment:
                  s = sign*IVCashrw.Sum;
                  sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
                  maxsum = maxsum + s;
                  sum = sum + s;
                  AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashr.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  PaymentValue = PaymentValue + sb1;
                case kInvoiceRowTypeChequePayment:
                  s = sign*IVCashrw.Sum;
                  sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
                  maxsum = maxsum + s;
                  sum = sum + s;
                  AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashr.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  PaymentValue = PaymentValue + sb1;
                case kInvoiceRowTypeLoyaltyPointsPayment:
                  s = sign*IVCashrw.Sum;
                  sb1 = MulRateToBase1(IVCashrw.CurncyCode,s,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  maxsum = maxsum + s;
                  sum = sum + s;
                  AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  PaymentValue = PaymentValue + sb1;
                  if (RetValueAddedf==false) then begin
                    if (IVCashrw.CurncyCode==BCb.BaseCur1) or blank(IVCashrw.CurncyCode) then begin
                      AddCashupToIVArray(false,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,-IVCashr.RetValue,-IVCashr.RetValue,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                      RetValueAddedf = true;
                      maxsum = maxsum -IVCashr.RetValue;
                      sum = sum -IVCashr.RetValue;
                    end;
                  end;
                case kInvoiceRowTypeCashPayment:
                  s = sign*IVCashrw.Sum;
                  sb1 = MulRateToBase1(IVCashrw.CurncyCode,s,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  maxsum = maxsum + s;
                  sum = sum + s;
                  AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  PaymentValue = PaymentValue + sb1;
                  
                  rv = MulRateToBase1(IVCashrw.CurncyCode,IVCashrw.BasePrice,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  AddCashupToIVArray(false,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,-IVCashrw.BasePrice,-rv,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  RetValue = RetValue + IVCashrw.BasePrice;
                  if (RetValueAddedf==false) then begin
                    if (IVCashrw.CurncyCode==BCb.BaseCur1) or blank(IVCashrw.CurncyCode) then begin
                      AddCashupToIVArray(false,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,-IVCashr.RetValue,-IVCashr.RetValue,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                      RetValueAddedf = true;
                      RetValuePayMode = IVCashrw.PayMode;
                      maxsum = maxsum -IVCashr.RetValue;
                      sum = sum -IVCashr.RetValue;
                    end;
                  end;
                case kInvoiceRowTypeCreditCardPayment:
                  s = sign*IVCashrw.Sum;
                  sb1 = MulRateToBase1(IVCashrw.CurncyCode,s,IVCashrw.FrRate,IVCashrw.ToRateB1,IVCashrw.ToRateB2,IVCashrw.BaseRate1,IVCashrw.BaseRate2,DefaultCurRoundOff);
                  maxsum = maxsum + s;
                  sum = sum + s;
                  AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashrw.PayMode,IVCashrw.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                  PaymentValue = PaymentValue + sb1;
              end;
            end;  
            if (RetValueAddedf) then begin
              AddCashupToIVArray(false,DCb.DefCashPayMode,RetValuePayMode,BCb.BaseCur1,RetValue,RetValue,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
              maxsum = maxsum + RetValue;
              sum = sum + RetValue;
            end;

            if (IVCashr.RecValue!=0) then begin
              s = IVCashr.RecValue;
              sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
              sum = sum + s;
              maxsum = maxsum + s;
              AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashr.PayDeal,IVCashr.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
            end;
            if (IVCashr.RecValue2!=0) then begin
              s = IVCashr.RecValue2;
              sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
              sum = sum + s;
              maxsum = maxsum + s;
              AddCashupToIVArray(true,DCb.DefCashPayMode,IVCashr.PayDeal2,IVCashr.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
            end;
            s = blankval;
            sb1 = blankval;
            if (RetValueAddedf==false) then begin
              if (IVCashr.RetValue<0) then begin
                if (IVCashr.TendValue!=0) then begin
                  s = IVCashr.TendValue - s;
                end else begin
                  s = IVCashr.CashValue - s;
                end;
              end else begin
                if (IVCashr.TendValue!=0) then begin
                  s = IVCashr.TendValue - IVCashr.RetValue - IVCashr.RecValue - IVCashr.RecValue2 - PaymentValue;
                end else begin
                  s = IVCashr.CashValue - IVCashr.RetValue;
                end;          
              end;
              RetValueAddedf = true;
            end;
            if (s!=0) then begin
//              sb1 = MulRateToBase1(IVCashr.CurncyCode,s,IVCashr.FrRate,IVCashr.ToRateB1,IVCashr.ToRateB2,IVCashr.BaseRate1,IVCashr.BaseRate2,DefaultCurRoundOff);
              sb1 = s;
              sum = sum + s;
              maxsum = maxsum + s;
              AddCashupToIVArray(true,DCb.DefCashPayMode,DCb.DefCashPayMode,IVCashr.CurncyCode,s,sb1,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);            
            end;          
          end;
          if (sum!=0) then begin
            switch (gCashupReportMode) begin
              case kCashupReportCleanCash_SameAsInCashupReportFile:
                if (addtoit) then begin
                  AddIVCashtoCleanCashSummary(IVCashr,sum,vstatussum);
                end;
            end;
          end;
          AttToIVCashSpecArrays(Accb,itemstat,IVCashr,DCb.DefCashPayMode,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
        end;
      end;
    end;
  end;
  return;
end;

procedure AttToSLIVSpecArrays(record AccBlock Accb,Integer itemstat,record IVVc IVr,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var val maxsum,Boolean addtoit,record SMVc SMr)
begin
  Integer rwcnt,i,lasti;
  row IVVc IVrw;
  val s;
  record TaxMatrixVc TMr;
  Boolean RetValueAddedf;

  rwcnt = MatRowCnt(IVr);
  for(i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypeCashPayment:
        s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,"",s,SMr);
        if (blank(Accb.CashBackAcc)) then begin
          if (RetValueAddedf==false) then begin
            s = -MulRateToBase1(IVr.CurncyCode,IVr.RetnValue,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
            AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,IVr.Objects,s,SMr);
            RetValueAddedf = true;
          end;
        end;
      case kInvoiceRowTypeCreditCardPayment:
        s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,"",s,SMr);
      case kInvoiceRowTypeChequePayment:
        s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,"",s,SMr);
      case kInvoiceRowTypeLoyaltyPointsPayment:
        s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,"",s,SMr);
      case kInvoiceRowTypeGiftVoucherPayment:
        s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
        AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,"",s,SMr);
      otherwise
        UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
        AddupPOSLine(false,"IVVc",itemstat,IVrw.ArtCode,IVrw.SalesAcc,IVrw.VATCode,IVrw.TaxTemplateCode,TMr,IVr.Objects,IVrw.Objects,IVr.InclVAT,IVr.NoTAXonVAT,IVrw.Sum,IVrw.Price,IVrw.Quant,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
        if (nonblank(IVrw.ArtCode)) then begin
          lasti = i;
        end;
//SL INvoice already created transaction for sales and vat
    end;
  end;
  if (lasti>-1) then begin
    MatRowGet(IVr,lasti,IVrw);
    UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
    AddupPOSLine(false,"IVVc",itemstat,IVrw.ArtCode,IVrw.SalesAcc,IVrw.VATCode,IVrw.TaxTemplateCode,TMr,IVr.Objects,IVrw.Objects,IVr.InclVAT,IVr.NoTAXonVAT,IVr.Sum0,0,0,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
  end;
//SL INvoice already created transaction for sales and vat
  return;
end;

procedure AddIVtoCleanCashSummary(record IVVc IVr,val sum,var vector val vstatussum)
begin
  row IVVc IVrw;
  Integer i,rwcnt;
  string 255 what;
  val swreb,sworeb,s;
  record GeneralOptionBlock GOb;
  Boolean rebatef,negativef;
  record SMVc nVATr;
  Integer nvatcnt;
  record SMVc dVATr;
  Integer dvatcnt;
  val vat,tax1sum;
  
  BlockLoad(GOb);
  SetupVATBase(nVATr,nvatcnt);          
  SetupVATBase(dVATr,dvatcnt);          
  if (nonblank(IVr.OfficialSerNr)) then begin
    if (nonblank(IVr.OfficialSerNr2)) then begin
      what = "registeredcopy"; 
    end else begin
      what = "registeredorig"; 
    end;
  end else begin
    what = "notregistered"; 
  end;
  vstatussum[what & "_count"] = vstatussum[what & "_count"] + 1; 
  vstatussum[what & "_sum"] = vstatussum[what & "_sum"] + sum; 
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) then begin
      if (IVrw.Sum<0) then begin
        negativef = true;
        s = -MulRateToBase1(IVr.CurncyCode,IVrw.Sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
        vstatussum["negativeinvoicesum"] = vstatussum["negativeinvoicesum"] + s; 
        AddVATBase(nVATr,IVrw.VATCode,IVrw.Sum,blankval,nvatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
      end else begin
//        CalcSum(IVrw.Quant,IVrw.Price,IVrw.PriceFactor,0.00,sworeb,GOb.UseDiscount);  
        sworeb = FormulaDiscountCalcSum(IVrw.Quant,IVrw.Price,IVrw.PriceFactor,0.00);  
        swreb = FormulaDiscountCalcSum(IVrw.Quant,IVrw.Price,IVrw.PriceFactor,IVrw.vRebate);  
        if (swreb!=sworeb) then begin
          s = sworeb - swreb;
          s = MulRateToBase1(IVr.CurncyCode,s,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
          rebatef = true;
          vstatussum["rebateinvoicesum"] = vstatussum["rebateinvoicesum"] + s; 
          AddVATBase(dVATr,IVrw.VATCode,s,blankval,dvatcnt,IVr.InclVAT,IVr.NoTAXonVAT);
        end;
      end;
    end;
  end;
  if (negativef) then begin
    CalcVATBaseVAT(nVATr,IVr.InclVAT,IVr.NoTAXonVAT,nvatcnt,vat,tax1sum);
    vstatussum["negativeinvoicesum"] = vstatussum["negativeinvoicesum"] - vat; 
    vstatussum["negativeinvoicecount"] = vstatussum["negativeinvoicecount"] + 1; 
  end;
  if (rebatef) then begin
    CalcVATBaseVAT(dVATr,IVr.InclVAT,IVr.NoTAXonVAT,nvatcnt,vat,tax1sum);
    vstatussum["rebateinvoicesum"] = vstatussum["rebateinvoicesum"] + vat; 
    vstatussum["rebateinvoicecount"] = vstatussum["rebateinvoicecount"] + 1; 
  end;
  return;
end;

procedure AddIVPosSum(record IVVc IVr,val sum,string defmode,string themode,var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt,Integer detail,var val maxsum,var record SMVc SMr,
                      Date startdate,Time starttim,Date enddate,Time endtim,var vector val vstatussum)
begin
  val s;
  transaction Integer gCashupReportMode;
  
  if (sum!=0) then begin
    if (detail!=0) and (detail!=2) then begin
      s = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
      if (s<0) then begin
        aivoutval[acnt] = aivoutval[acnt] - s;
        aivb1outval[acnt] = aivb1outval[acnt] - s;
      end else begin
        aivval[acnt] = aivval[acnt] + s;
        aivb1val[acnt] = aivb1val[acnt] + s;
      end;
      acnt = acnt + 1;
    end else begin
      s = MulRateToBase1(IVr.CurncyCode,sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
      AddCashupToIVArray(true,defmode,themode,IVr.CurncyCode,s,s,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
    end;
    switch (gCashupReportMode) begin
      case kCashupReportCleanCash_SameAsInCashupReportFile:
        if (DateInRange(IVr.TransDate,startdate,enddate)) then begin
          AddIVtoCleanCashSummary(IVr,s,vstatussum);
        end;
    end;
    AddPMPOSToSM(defmode,themode,"IVVc " & IVr.SerNr,"",s,SMr);
    maxsum = maxsum + s;
  end;
  return;
end;

global
procedure FillUpAllSLIV(Integer itemstat,Date dfr,Date dto,Time tfr,Time tto,Date startdat,Time starttim,Date enddat,Time endtim,string machine,string drawer,string paymode,
                        var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt,Integer detail,
                        var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,Boolean addtoit,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var record SMVc SMr,
                        var vector val vstatussum)
begin
  record IVVc IVr;
  record DefCashBlock DefCashRec;
  Boolean foundf,testf;
  Boolean alliscash,addedf;
  Integer rwcnt,i;
  row IVVc IVrw;
  val s,maxsum;
  val vopen;
  string 20 pmmodtocompare;
  record CashierDefBlock CDb;
  Boolean subchangef,RetnValueAddedf;
  record BaseCurBlock BCb;
  record AccBlock Accb;

  BlockLoad(CDb);
  BlockLoad(BCb);
  BlockLoad(DefCashRec);
  BlockLoad(Accb);
  subchangef = true;
  foundf = true;
  IVr.MachineName = machine;
  IVr.DrawerCode = drawer;
  IVr.TransDate = dfr;
  IVr.TransTime = tfr;
  while (LoopKey("Cashup",IVr,4,foundf)) begin
    if (IVr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (IVr.DrawerCode!=drawer) then begin
      foundf = false;
    end;
    if (IVr.TransDate>enddat) then begin
      foundf = false;
    end;
    if (nonblankdate(dto)) then begin
      if (IVr.TransDate>dto) then begin
        foundf = false;
      end;
      if (IVr.TransDate==dto) then begin
        if (nonblanktime(tto)) then begin
          if (IVr.TransTime>=tto) then begin
            foundf = false;
          end;
        end;
      end;
    end;
    testf = foundf;
    if (IVr.Invalid!=0) then begin
      testf = false;
    end;
    if (IVr.OKFlag==0) then begin
      testf = false;
    end;
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      switch (IVrw.stp) begin
        case kInvoiceRowTypeDebtorsTransfer:
          testf = false;
          i = rwcnt;
      end;
    end;
    if (testf) then begin
      addedf = false;
      if (IVr.InvType==kInvoiceTypeCash or IVr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin
        alliscash = true;
      end else begin
        alliscash = false;
      end;
      if (detail!=0) and (detail!=2) then begin
        aivcode[acnt] = IVr.SerNr;
        aivoutval[acnt] = BlankVal;
        aivb1outval[acnt] = BlankVal;
        aivval[acnt] = BlankVal;
        aivnr[acnt] = BlankVal;
        atipsum[acnt] = BlankVal;
      end;
      RetnValueAddedf = false;
      maxsum = 0;
      vopen = IVr.Sum4;
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        testf = false;
        s = 0;
        switch (IVrw.stp) begin
          case kInvoiceRowTypeCashPayment: testf = true;
          case kInvoiceRowTypeChequePayment: testf = true;
          case kInvoiceRowTypeLoyaltyPointsPayment: testf = true;
          case kInvoiceRowTypeCreditCardPayment: testf = true;
        end;
        if (testf) then begin
//          s = IVrw.Sum; //change_1  , we do line below instead
          s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
          if (nonblank(IVrw.PayMode)) then begin
            pmmodtocompare = IVrw.PayMode;
          end else begin
            pmmodtocompare = DefCashRec.DefGCSPayMode;
          end;
          if (pmmodtocompare==paymode) or (blank(paymode)) then begin
            vopen = vopen - s;
          end;
        end;
      end;
      if (IVr.Sum4>0) then begin
        if (vopen<=0) then begin alliscash = true; end;
      end else begin
        if (vopen>=0) then begin alliscash = true; end;
      end;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        s = 0;
        switch (IVrw.stp) begin
          case kInvoiceRowTypeGiftVoucherSold:
            s = -IVrw.Sum;
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (nonblank(IVrw.PayMode)) then begin
              pmmodtocompare = IVrw.PayMode;
            end else begin
              pmmodtocompare = DefCashRec.DefGCSPayMode;
            end;
            addedf = true;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,pmmodtocompare,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
            end;
          case kInvoiceRowTypeGiftVoucherPayment:
            s = IVrw.Sum;
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (nonblank(IVrw.PayMode)) then begin
              pmmodtocompare = IVrw.PayMode;
            end else begin
              pmmodtocompare = DefCashRec.DefGCRPayMode;
            end;
            addedf = true;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,pmmodtocompare,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
            end;
          case kInvoiceRowTypeCashPayment:
            if (nonblank(IVrw.PayMode)) then begin
              pmmodtocompare = IVrw.PayMode;
            end else begin
              pmmodtocompare = DefCashRec.DefCashPayMode;
            end;
            addedf = true;

            s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
              if (RetnValueAddedf==false) then begin
//                if (IVrw.CurncyCode==BCb.BaseCur1) or blank(IVrw.CurncyCode) then begin //change_1
                if (true) then begin
                  if (alliscash) then begin
                    s = -MulRateToBase1(IVr.CurncyCode,IVr.RetnValue,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
                    AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
//                    AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,IVr.Objects,s,SMr);
//                    vopen = vopen - IVr.RetnValue; //done above
                    RetnValueAddedf = true;
                  end;
                end;
              end;
            end;
          case kInvoiceRowTypeChequePayment:
            if (nonblank(IVrw.PayMode)) then begin
              pmmodtocompare = IVrw.PayMode;
            end else begin
              pmmodtocompare = DefCashRec.DefCashPayMode;
            end;
            addedf = true;

            s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
              if (RetnValueAddedf==false) then begin
                if (IVrw.CurncyCode==BCb.BaseCur1) or blank(IVrw.CurncyCode) then begin
                  if (alliscash) then begin
                    s = -MulRateToBase1(IVr.CurncyCode,IVr.RetValue,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
//                    AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
                    AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,IVr.Objects,s,SMr);
                    vopen = vopen - IVr.RetnValue;
                    RetnValueAddedf = true;
                  end;
                end;
              end;
            end;
          case kInvoiceRowTypeLoyaltyPointsPayment:
            addedf = true;
            s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
              if (RetnValueAddedf==false) then begin
                if (IVrw.CurncyCode==BCb.BaseCur1) or blank(IVrw.CurncyCode) then begin
                  if (alliscash) then begin
                    s = -MulRateToBase1(IVr.CurncyCode,IVr.RetValue,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
//                    AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
                    AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,IVr.Objects,s,SMr);
                    vopen = vopen - IVr.RetnValue;
                    RetnValueAddedf = true;
                  end;
                end;
              end;
            end;
          case kInvoiceRowTypeCreditCardPayment:
/*          
            if (IVr.RetnValue<0) then begin // Can happen, cash is used and then rest is left as open invoice
              s = IVrw.Sum;
            end else begin
//              s = IVrw.Sum-IVr.RetnValue;//credit card get entire ampunt from bank acc
              s = IVrw.Sum;
            end;
*/            
            s = MulRateToBase1(IVrw.CurncyCode,IVrw.Sum,IVrw.FrRate,IVrw.ToRateB1,IVrw.ToRateB2,IVrw.BaseRate1,IVrw.BaseRate2,DefaultCurRoundOff);
            if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
              s = -s;
            end;
            if (nonblank(IVrw.PayMode)) then begin
              pmmodtocompare = IVrw.PayMode;
            end else begin
              pmmodtocompare = DefCashRec.DefCCPayMode;
            end;
            addedf = true;
            if (pmmodtocompare==paymode) or (blank(paymode)) then begin
              AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,pmmodtocompare,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
              if (RetnValueAddedf==false) then begin
                if (IVrw.CurncyCode==BCb.BaseCur1) or blank(IVrw.CurncyCode) then begin
                  if (alliscash) then begin
                    s = -MulRateToBase1(IVr.CurncyCode,IVr.RetValue,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
//                    AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,IVrw.PayMode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
                    AddPMPOSToSM(IVrw.PayMode,IVrw.PayMode,"IV " & IVr.SerNr & IVrw.Spec,IVr.Objects,s,SMr);
                    vopen = vopen - IVr.RetnValue;
                    RetnValueAddedf = true;
                  end;
                end;
              end;
            end;
        end;
        if ((blank(paymode)) or (paymode==pmmodtocompare)) then begin
//moved code to rows        
//          AddIVPosSum(IVr,s,DefCashRec.DefCashPayMode,pmmodtocompare,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
        end;
      end;
      if ((alliscash) and (addedf==false)) then begin
        if ((blank(paymode)) or (paymode==IVr.PayDeal)) then begin
          AddIVPosSum(IVr,IVr.Sum4,DefCashRec.DefCashPayMode,IVr.PayDeal,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
          vopen = 0;
        end;
      end;
      if (vopen!=0) then begin
        if (CDb.InclOpenInvCashup!=0) then begin
          if ((blank(paymode)) or (paymode==IVr.PayDeal)) then begin
            if (RetnValueAddedf==false) then begin
              AddIVPosSum(IVr,vopen,DefCashRec.DefCashPayMode,IVr.PayDeal,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt,detail,maxsum,SMr,startdat,starttim,enddat,endtim,vstatussum);
            end;
          end;
        end;
      end;
      if (detail!=0) and (detail!=2) then begin
//        acnt = acnt + 1;
      end;
      AttToSLIVSpecArrays(Accb,itemstat,IVr,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,maxsum,addtoit,SMr);
    end;
  end;
  return;
end;

procedure AddIPPosSum(record IPVc IPr,val sum,string defmode,string themode,var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt,Integer detail,var val maxsum,var record SMVc SMr)
begin
  val s;
  
  if (sum!=0) then begin
    if (detail!=0) and (detail!=2) then begin
      s = sum;
      if (s<0) then begin
        aivoutval[acnt] = aivoutval[acnt] - s;
      end else begin
        aivval[acnt] = aivval[acnt] + s;
      end;
      acnt = acnt + 1;
    end else begin
      s = sum;
      AddCashupToIVArray(true,defmode,themode,"",s,s,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
    end;
    AddPMPOSToSM(defmode,themode,"IPVc " & IPr.SerNr,"",s,SMr);
    maxsum = maxsum + s;
  end;
  return;
end;

global
procedure FillUpAllSLIP(Integer itemstat,Date dfr,Date dto,Time tfr,Time tto,Date enddat,string machine,string drawer,string paymode,
                        var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer acnt,Integer detail,
                        var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,Boolean addtoit,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var record SMVc SMr)
begin
  record IPVc IPr;
  row IPVc IPrw;
  Integer i,rw;
  record DefCashBlock DefCashRec;
  Boolean foundf,testf;
  Boolean alliscash,addedf;
  Integer iprwcnt,ipi;
  record IVVc IVr;
  row IVVc IVrw;
  val s,maxsum;
  val vopen;
  string 20 pmmodtocompare,ippaymode;
  record CashierDefBlock CDb;
  vector val ippaymodev;
  Array string 2 ippaymodea;
  Integer ipp,ippcnt;

  BlockLoad(CDb);
  BlockLoad(DefCashRec);
  foundf = true;
  IPr.MachineName = machine;
  IPr.DrawerCode = drawer;
  IPr.TransDate = dfr;
  IPr.RegTime = tfr;
  while (LoopKey("Cashup",IPr,4,foundf)) begin
    if (IPr.MachineName!=machine) then begin
      foundf = false;
    end;
    if (IPr.DrawerCode!=drawer) then begin
      foundf = false;
    end;
    if (IPr.TransDate>enddat) then begin
      foundf = false;
    end;
    if (nonblankdate(dto)) then begin
      if (IPr.TransDate>dto) then begin
        foundf = false;
      end;
      if (IPr.TransDate==dto) then begin
        if (nonblanktime(tto)) then begin
          if (IPr.RegTime>=tto) then begin
            foundf = false;
          end;
        end;
      end;
    end;
    testf = foundf;
    if (IPr.Invalid!=0) then begin
      testf = false;
    end;
    if (IPr.OKFlag==0) then begin
      testf = false;
    end;
    if (testf) then begin
      for (ipp=0;ipp<ippcnt;ipp=ipp+1) begin
        ippaymodev[ippaymodea[ipp]] = blankval;
        ippaymodea[ipp] = "";
      end;
      ippcnt = 0;
      iprwcnt = MatRowCnt(IPr);
      for (ipi=0;ipi<iprwcnt;ipi=ipi+1) begin
        MatRowGet(IPr,ipi,IPrw);
        switch (IPrw.stp) begin
          case 1:
            if (IPrw.InvoiceNr>0) then begin
              IVr.SerNr = IPrw.InvoiceNr;
              if (ReadFirstMain(IVr,1,true)) then begin
                addedf = false;
                if (IVr.InvType==kInvoiceTypeCash or IVr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin
                  alliscash = true;
                end else begin
                  alliscash = false;
                end;
                if (detail!=0) and (detail!=2) and (addedf==false) then begin
//                  aivcode[acnt] = IPr.SerNr & " (" & IVr.SerNr & ")";
                  aivcode[acnt] = IPr.SerNr;
                  aivoutval[acnt] = BlankVal;
                  aivb1outval[acnt] = BlankVal;
                  aivval[acnt] = BlankVal;
                  atipsum[acnt] = BlankVal;
                  addedf = true;
                end;
                ippaymode = IPrw.PayMode;
                if (blank(ippaymode)) then begin
                  ippaymode = IPr.PayMode;
                end;
                AddCashupToIVArray(true,ippaymode,ippaymode,"",IPrw.InvVal,IPrw.InvVal,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
                if (detail!=0) and (detail!=2) then begin
                  aivcode[acnt-1] = IPr.SerNr;
                end;
              end;  
            end;
        end;
      end;  
      for (ipi=0;ipi<iprwcnt;ipi=ipi+1) begin
        MatRowGet(IPr,ipi,IPrw);
        switch (IPrw.stp) begin
          case 1:
            if (IPrw.InvoiceNr<0) then begin
              ippaymode = IPrw.PayMode;
              if (blank(ippaymode)) then begin
                ippaymode = IPr.PayMode;
              end;
              AddCashupToIVArray(true,ippaymode,ippaymode,"",IPrw.InvVal,IPrw.InvVal,0,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,acnt);
              if (detail!=0) and (detail!=2) then begin
                aivcode[acnt-1] = IPr.SerNr;
              end;
              maxsum = maxsum + IPrw.InvVal;
            end;
        end;
      end;
    end;
  end;
  return;
end;
