external function Boolean TreatServiceError(LongInt,string,string);
external procedure UTCTimeToDate(LongInt,var Date,var Time);
external function string 50 TimeToString(time,string,boolean);
external function Boolean CheckEmailStr(string);
external updating procedure ImportAutoupdateRecords(string);
external function LongInt TimeToMinutes(Time);
external function LongInt DateTimeDiff(date,time,date,time);
forward procedure FindUnusedPort(var LongInt,var LongInt,var LongInt);
external function Boolean ParseHTTPHeader(area,string,var Integer,var string,var string);
external procedure DoUpdateBrowses(string);
forward updating procedure DoDownloadVersion(record HansaVersionVc,Boolean);
forward procedure PauseASPIdleTasks();
external procedure LoadFileToInspectInArea(string,var area,var Boolean);
forward updating procedure StartStopSystemCopies(var record RemoteCloudServerVc,LongInt,Boolean,Boolean);
forward updating procedure UpdateRemoteCloudServer(var record RemoteCloudServerVc);
external function string 255 removenextlistitem(var string,string);
forward procedure GetOneNodeHostingConfig(record CloudNodeVc);
forward function Boolean RunOneLineOutCommand(string,var string);
forward updating function Integer MoveNodeToNewHostStageFour(record CloudNodeVc,record HostingConfigurationVc);
forward updating function Integer StopHost(record CloudNodeVc,Boolean,var string);
external procedure OpenASPConfigHostFirewallWClassOnClient(Integer,string,record RcVc);
forward function Boolean SyncRCSDataWithOneCN(record CloudNodeVc,Boolean,Boolean);
forward procedure StartImportOnRCS(uuid,string);
forward procedure StartImportOnRCS2(uuid,string,Boolean);
external function Boolean ProgramTypeShouldUseStandardServer(Integer);
external function Date DateFromString(string,string);
forward updating procedure UpdateServersOnVersion(string,LongInt);
external function string 255 GeneratePassword2(Integer);
forward function Boolean IsCloneUpToDate(record LocalCloudServerVc);
forward procedure FastCheckSyncOneCN(record CloudNodeVc);
external procedure StopRemoteCloudServers2_Reply(array uuid,LongInt);
forward updating procedure SaveNewAndUpdatedRCSs(record CloudNodeVc,array record LocalCloudServerVc);
forward procedure FastSyncLCSDataAtCN(array record RemoteCloudServerVc,var array record LocalCloudServerVc);
external function Boolean GetNextCustNr(var string);
forward procedure FastCheckCN(string);
forward function Boolean GetKeyForHostingConfiguration(record HostingConfigurationVc,var record Attach2Vc);
forward function Integer RunScriptInBackground(string,area,area);
forward updating procedure UpdateToVersion_WTF(record HansaVersionVc);
external function LongInt DateTimeDiffInSeconds(date,time,date,time);
external procedure HTTPHeaderLine(string,var string,var string,string);
forward updating procedure ResetCloudArchiveOnCN();
forward updating procedure ResetCloudArchiveOnCC();
external function string 255 FileSizeToString(Val);
forward function Boolean AmazonDescribeAddresses(record HostingConfigurationVc,string,var array string);
forward function Boolean AmazonGetInstancePublicIP(record HostingConfigurationVc,string,var string);
external procedure AddHeaderForSignature(var array string,var vector string,string,string);
external procedure SignAWSRequest(string,string,string,string,string,string,string,string,var array string,var vector string,var area);
external inner function Boolean UploadFileToS3Bucket(string,string,string,string,string,string,string,string);

external outer procedure LaunchHost(record HostingConfigurationVc,record RcVc,Integer);
external outer function Integer TerminateHost(record CloudNodeVc,Boolean,var string);
external outer function string 255 NodeLog(record CloudNodeVc);
external outer procedure DoFileListReload(uuid);
external outer procedure SetCloudControllerStatusOnClient(date,time,string,string,LongInt);
external outer function Boolean TestServerNotResponding(string,longint);
external outer function Boolean IsTestBuildVersion(string);
external outer function Boolean ReadUserKey(var LongInt,var string,var string);
//external outer procedure ActivateUsers(string,vector string);
external outer procedure ActivateUsers(string,array string,array string);
external outer procedure DeactivateUsers(string,array string);


forward updating procedure SaveCloudNodeReachable(record CloudNodeVc,Boolean);

function string 255 CompressedFileName(string filename)
begin
  string 255 res;

  switch (ProgramPlatform) begin
    case kPlatformMac:      res = filename & ".bz2";
    case kPlatformLinux32:  res = filename & ".bz2";
    case kPlatformLinux64:  res = filename & ".bz2";
    otherwise
      res = filename;
  end;

  CompressedFileName = res;
  return;
end;

global
function string 255 RCSName(record RemoteCloudServerVc RCSr)
begin
  string 255 tstr;

  tstr = RCSr.Name;
  if (blank(tstr)) then begin
    tstr = RCSr.UUID;
  end;
  RCSName = tstr;
  return;
end;

function string 255 LCSName(record LocalCloudServerVc LCSr)
begin
  string 255 tstr;

  tstr = LCSr.Name;
  if (blank(tstr)) then begin
    tstr = LCSr.UUID;
  end;
  LCSName = tstr;
  return;
end;

global
procedure SyncRCSDataWithOneCN2(record CloudNodeVc CNr,Boolean forcef,Boolean synchronousf)
begin
  SyncRCSDataWithOneCN(CNr,forcef,synchronousf);
  return;
end;

function Boolean SaveNodeReachableOnRCS()
begin
  SaveNodeReachableOnRCS = false;
end;

global
function Boolean GetRCSOnMainThread(var record RemoteCloudServerVc RCSr)
begin
  if (ReadFirstMain(RCSr,1,true)==false) then begin
    GetRCSOnMainThread = false;
  end else begin
    GetRCSOnMainThread = true;
  end;
end;

global
function Boolean IsCloudController()
begin
  record CloudSettingsBlock CSb;
  BlockLoad(CSb);
  if (CSb.ServerIsCloudController==kServerTypeCloudController) then begin
    IsCloudController = true;
  end else begin
    IsCloudController = false;
  end;
end;

global
procedure SetCloudControllerStatus(LongInt status,string message)
begin
  if (IsCloudController) then begin
    allclientsremoteasync.SetCloudControllerStatusOnClient(CurrentDate,CurrentTime,CurrentUser,message,status);
  end;
end;

global
function Boolean IsCloudNode()
begin
  record CloudSettingsBlock CSb;
  BlockLoad(CSb);
  if (CSb.ServerIsCloudController==kServerTypeCloudNode) then begin
    IsCloudNode = true;
  end else begin
    IsCloudNode = false;
  end;
end;

global
function Boolean IsCloudExporter()
begin
  record CloudSettingsBlock CSb;
  BlockLoad(CSb);
  if (CSb.ServerIsCloudController==kServerTypeCloudExporter) then begin
    IsCloudExporter = true;
  end else begin
    IsCloudExporter = false;
  end;
end;

global
updating procedure StoreASPActionLog(Integer actiontype,Date td,Time tt,UUID serverid,string controller,string usercode,string stdid)
begin
  record ASPActionLogVc AALr;

  RecordNew(AALr);
  AALr.UUID = MakeUUID;
  AALr.TransDate = td;
  AALr.TransTime = tt;
  AALr.ServerUUID = serverid;
  AALr.Controller = controller;
  AALr.UserCode = usercode;
  AALr.StandardID = stdid;
  AALr.ActionType = actiontype;
  RecordStore(AALr,false);

  return;
end;

procedure AddLineToArea(string line,area req)
begin
  AddTextToArea(line,req);
  AddTextToArea(chr(10),req);
  return;
end;

function Val MIN(Val a,Val b)
begin
  if (a<b) then begin
    MIN = a;
  end else begin
    MIN = b;
  end;
  return;
end;

function Val MAX(Val a,Val b)
begin
  if (a>b) then begin
    MAX = a;
  end else begin
    MAX = b;
  end;
  return;
end;

global
procedure MarkUpdateClientBrowses(string vcname)
begin
  string 255 gtag;

  gtag = "%UCB_" & vcname;
  SetGlobalBoolean(gtag,true);
end;

global
procedure UpdateClientBrowsesIfNeeded(string vcname)
begin
  string 255 gtag;

  gtag = "%UCB_" & vcname;
  if (GetGlobalBoolean(gtag)==true) then begin
    allclientsremoteasync.DoUpdateBrowses(vcname);
    SetGlobalBoolean(gtag,false);
  end;
end;

global
procedure UpdateClientBrowses(string vcname)
begin
  string 255 gtag;

  gtag = "%UCB_" & vcname;
  SetGlobalBoolean(gtag,false);
  allclientsremoteasync.DoUpdateBrowses(vcname);
end;

global
function Integer CloudNodeStatus(record CloudNodeVc CNr)
begin
  Integer res;

  if (CNr.Closed!=0) then begin
    res = kCloudNodeStatusClosed;
    goto LCloudNodeStatus;
  end;

  switch (CNr.CurrentState) begin
    case kCloudNodeStateCreating:     res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateStopping:     res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateStopped:      res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateStarting:     res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateMoving:       res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateTerminating:  res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
    case kCloudNodeStateModifying:    res = kCloudNodeStatusUnreachable; goto LCloudNodeStatus;
  end;

  if (CNr.ReachableFlag==0) then begin
    res = kCloudNodeStatusUnreachable;
    goto LCloudNodeStatus;
  end;

  if (CNr.VersionBuild!=VersionBuild) then begin
    res = kCloudNodeStatusDifferentVersion;
    goto LCloudNodeStatus;
  end;

  res = kCloudNodeStatusReachable;

LCloudNodeStatus:;
  CloudNodeStatus = res;
  return;
end;

function Boolean ShouldDownloadVersion(string vercode)
begin
  string 255 verdlstr;
  Boolean res;

  if (nonblank(vercode)) then begin
    verdlstr = "ShouldDownload:" & vercode;
    res = GetGlobalBoolean(verdlstr);
  end;

  ShouldDownloadVersion = res;
  return;
end;

procedure SetShouldDownloadVersion(string vercode,Boolean dlf)
begin
  string 255 verdlstr;

  if (nonblank(vercode)) then begin
    verdlstr = "ShouldDownload:" & vercode;
    SetGlobalBoolean(verdlstr,dlf);
  end;
end;

function Boolean IsDownloadingVersion(string vercode)
begin
  string 255 verdlstr;
  Boolean res;

  if (nonblank(vercode)) then begin
    verdlstr = "IsDownloading:" & vercode;
    res = GetGlobalBoolean(verdlstr);
  end;

  IsDownloadingVersion = res;
  return;
end;

procedure SetDownloadingVersion(string vercode,Boolean dlf)
begin
  string 255 verdlstr;

  if (nonblank(vercode)) then begin
    verdlstr = "IsDownloading:" & vercode;
    SetGlobalBoolean(verdlstr,dlf);
  end;
end;

function string 255 StateName(LongInt state)
begin
  string 255 res;

  switch (state) begin
    case kHansaVersionStateUnknown: res = "unknown";
    case kHansaVersionStateNormal: res = "normal";
    case kHansaVersionStateOld: res = "old";
    case kHansaVersionStateUnavailable: res = "unavailable";
//    case kHansaVersionStateChecking: res = "checking";
    case kHansaVersionStateUpdating: res = "updating";
    case kHansaVersionStateNotDownloaded: res = "not downloaded";
    case kHansaVersionStateInstalling: res = "installing";
    case kHansaVersionStateDeprecated: res = "deprecated";
    case kHansaVersionStateError: res = "error";
  end;

  StateName = res;
  return;
end;

global
updating procedure StoreASPEvent(LongInt evtype,string comment,string usercode,uuid svruuid,string controller)
begin
  record ASPEventsVc AEr;

  AEr.TransDate = CurrentDate;
  AEr.TransTime = CurrentTime;
  AEr.Comment = comment;
  AEr.EventType = evtype;
  AEr.UserCode = usercode;
  AEr.ServerUUID = svruuid;
  AEr.Controller = controller;
  RecordStore(AEr,false);

  return;
end;

updating
procedure SetHansaVersionState(var record HansaVersionVc HVr,LongInt state)
begin
  record HansaVersionVc HV2r;
  record HansaVersionVc OldHV2r;

  RecordCopy(HV2r,HVr);

  if (ReadFirstMain(HV2r,1,true)) then begin
    if (HV2r.CurrentState<>state) then begin
      RecordCopy(OldHV2r,HV2r);
      HV2r.CurrentState = state;
      RecordUpdate(OldHV2r,HV2r,true);
      //LogText(0,"SetHansaVersionState(" & HV2r.Code & "," & StateName(state) & ") updated");
    end else begin
      //LogText(0,"SetHansaVersionState(" & HV2r.Code & "," & StateName(state) & ") already has state");
    end;
  end else begin
    RecordCopy(HV2r,HVr);
    HV2r.CurrentState = state;
    if (RecordStore(HV2r,false)==false) then begin
      //LogText(0,"SetHansaVersionState(" & HV2r.Code & "," & StateName(state) & ") failed");
    end else begin
      //LogText(0,"SetHansaVersionState(" & HV2r.Code & "," & StateName(state) & ") new");
    end;
  end;

  HVr.CurrentState = state;
end;

function string 255 StatusName(LongInt status)
begin
  StatusName = StringFromSet(367,status);
end;

function string 255 WantedStatusName(LongInt status)
begin
  WantedStatusName = StringFromSet(329,status);
end;

function string 255 SubStatusName(LongInt status)
begin
  SubStatusName = StringFromSet(553,status);
end;

function string 255 WantedSubStatusName(LongInt status)
begin
  WantedSubStatusName = StringFromSet(552,status);
end;

procedure CopyRCSRowsToLCS(record RemoteCloudServerVc RCSr,record LocalCloudServerVc LCSr)
begin
  Integer i,rwcnt;
  row RemoteCloudServerVc RCSrw;
  row LocalCloudServerVc LCSrw;
  
  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowDelete(LCSr,0);
  end;
  rwcnt = MatRowCnt(RCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RCSr,i,RCSrw);
    ClearRow(LCSr,LCSrw,1);
    LCSrw.Item = RCSrw.Item;
    LCSrw.ItemName = RCSrw.ItemName;
    LCSrw.Desc = RCSrw.Desc;
    LCSrw.Data = RCSrw.Data;
    LCSrw.When = RCSrw.When;
    LCSrw.Disabled = RCSrw.Disabled;
    MatRowInsert(LCSr,i,LCSrw);
  end;
end;

procedure CopyLCSRowsToRCS(record LocalCloudServerVc LCSr,record RemoteCloudServerVc RCSr)
begin
  Integer i,rwcnt;
  row RemoteCloudServerVc RCSrw;
  row LocalCloudServerVc LCSrw;
  
  rwcnt = MatRowCnt(RCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowDelete(RCSr,0);
  end;
  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LCSr,i,LCSrw);
    ClearRow(RCSr,RCSrw,1);
    RCSrw.Item = LCSrw.Item;
    RCSrw.ItemName = LCSrw.ItemName;
    RCSrw.Desc = LCSrw.Desc;
    RCSrw.Data = LCSrw.Data;
    RCSrw.When = LCSrw.When;
    RCSrw.Disabled = LCSrw.Disabled;
    MatRowInsert(RCSr,i,RCSrw);
  end;
end;

procedure CopyRCSControlledDataToLCS(record RemoteCloudServerVc RCSr,record LocalCloudServerVc LCSr)
begin
  if (RCSr.MigrationFlag==0) then begin
    LCSr.Name = RCSr.Name;
  end;
  //LCSr.HansaVersion = RCSr.HansaVersion;
  LCSr.DataFolder = RCSr.DataFolder;
  LCSr.BindIP = RCSr.BindIP;
  LCSr.Port = RCSr.Port;     //shouldn't this be controlled by the cloudnode?

  LCSr.WantedStatus = RCSr.WantedStatus;
  //LCSr.CurrentStatus = RCSr.CurrentStatus;
  //LCSr.NextAttemptDate = RCSr.NextAttemptDate;
  //LCSr.NextAttemptTime = RCSr.NextAttemptTime;
  //LCSr.StatusText = RCSr.StatusText;
  LCSr.HTTPPort = RCSr.HTTPPort;
  LCSr.HTTPSPort = RCSr.HTTPSPort;
  if (RCSr.MigrationFlag==0) then begin
    LCSr.CUCode = RCSr.CUCode;
  end;
  LCSr.Closed = RCSr.Closed;
  //LCSr.CreatedDate = RCSr.CreatedDate; // correct?
  //LCSr.CreatedTime = RCSr.CreatedTime; // correct?
  LCSr.ExtraParameters = RCSr.ExtraParameters;
  LCSr.Comment = RCSr.Comment;
  LCSr.MaintPort = RCSr.MaintPort;
  LCSr.MassiveCacheMB = RCSr.MassiveCacheMB;
  LCSr.LogLevel = RCSr.LogLevel;
  LCSr.ServerName = RCSr.ServerName;
  LCSr.CoreDump = RCSr.CoreDump;
  //LCSr.LastStartDate = RCSr.LastStartDate;
  //LCSr.LastStartTime = RCSr.LastStartTime;
  //LCSr.QuickRestarts = RCSr.QuickRestarts;
  LCSr.UUIDLock = RCSr.UUIDLock;
  LCSr.DisableHobcheck = RCSr.DisableHobcheck;
  LCSr.HalcustUpdateRule = RCSr.HalcustUpdateRule;
  LCSr.HalpatchUpdateRule = RCSr.HalpatchUpdateRule;
  LCSr.NewHansaVersion = RCSr.NewHansaVersion;
  LCSr.WantedSubStatus = RCSr.WantedSubStatus;
  //LCSr.CurrentSubStatus = RCSr.CurrentSubStatus;
  LCSr.BackupFolder = RCSr.BackupFolder;
  LCSr.ExecutableType = RCSr.ExecutableType;
  LCSr.BackupTime = RCSr.BackupTime;
  LCSr.PublicHostName = RCSr.PublicHostName;
  LCSr.FastCheckFlag = RCSr.FastCheckFlag;
  LCSr.WantedStatusParams = RCSr.WantedStatusParams;
  LCSr.CloneFlag = RCSr.CloneFlag;
  LCSr.WebClientStartPort = RCSr.WebClientStartPort;
  LCSr.WebClientEndPort = RCSr.WebClientEndPort;
  LCSr.ProgramType = RCSr.ProgramType;
  LCSr.DisableCloudBackupFlag = RCSr.DisableCloudBackupFlag;
  LCSr.Classification = RCSr.Classification;
  LCSr.OnDemandFlag = RCSr.OnDemandFlag;
  LCSr.Localizations = RCSr.Localizations;
  LCSr.BackupOnStopFlag = RCSr.BackupOnStopFlag;
  LCSr.CountryLocalizations = RCSr.CountryLocalizations;
  //LCSr.ClosedOnNodeFlag = RCSr.ClosedOnNodeFlag;
  if (RCSr.MigrationFlag==0) then begin
//    LCSr.Contract = RCSr.Contract; //getting this info from backup
    LCSr.OrgNr = RCSr.OrgNr;
    LCSr.OrgNr2 = RCSr.OrgNr2;
    LCSr.VATNr = RCSr.VATNr;
  end;
  //LCSr.OldHansaVersion = RCSr.OldHansaVersion;
  LCSr.WatchpointExceptions = RCSr.WatchpointExceptions;
  LCSr.ExceptionComment = RCSr.ExceptionComment;
  LCSr.EncryptionKey = RCSr.EncryptionKey;
  //LCSr.JournalPresentFlag = RCSr.JournalPresentFlag;
  //LCSr.MigrationFlag = RCSr.MigrationFlag;
  //LCSr.HMCUCode = RCSr.HMCUCode;
  //LCSr.HMRegInCountry = RCSr.HMRegInCountry;
  //LCSr.LastStopDate = RCSr.LastStopDate;
  //LCSr.LastStopTime = RCSr.LastStopTime;

  CopyRCSRowsToLCS(RCSr,LCSr);
  return;
end;

procedure CopyLCSControlledDatatoRCS(record LocalCloudServerVc LCSr,record RemoteCloudServerVc RCSr)
begin
  if (RCSr.MigrationFlag==1) then begin
    RCSr.Name = LCSr.Name;
  end;
  RCSr.HansaVersion = LCSr.HansaVersion;
  //RCSr.DataFolder = LCSr.DataFolder;
  //RCSr.BindIP = LCSr.BindIP;
  //RCSr.Port = LCSr.Port;
  //RCSr.WantedStatus = LCSr.WantedStatus;
  RCSr.CurrentStatus = LCSr.CurrentStatus;
  RCSr.NextAttemptDate = LCSr.NextAttemptDate;
  RCSr.NextAttemptTime = LCSr.NextAttemptTime;
  RCSr.StatusText = LCSr.StatusText;
  //RCSr.HTTPPort = LCSr.HTTPPort;
  //RCSr.HTTPSPort = LCSr.HTTPSPort;
  if (RCSr.MigrationFlag==1) then begin
    RCSr.CUCode = LCSr.CUCode;
  end;
  //RCSr.ExtraParameters = LCSr.ExtraParameters;
  //RCSr.Comment = LCSr.Comment;
  //RCSr.MaintPort = LCSr.MaintPort;
  //RCSr.MassiveCacheMB = LCSr.MassiveCacheMB;
  //RCSr.LogLevel = LCSr.LogLevel;
  //RCSr.ServerName = LCSr.ServerName;
  //RCSr.CoreDump = LCSr.CoreDump;
  //RCSr.Closed = LCSr.Closed;
  RCSr.CreatedDate = LCSr.CreatedDate;
  RCSr.CreatedTime = LCSr.CreatedTime;
  RCSr.LastStartDate = LCSr.LastStartDate;
  RCSr.LastStartTime = LCSr.LastStartTime;
  RCSr.QuickRestarts = LCSr.QuickRestarts;
  //RCSr.UUIDLock = LCSr.UUIDLock;
  //RCSr.DisableHobcheck = LCSr.DisableHobcheck;
  //RCSr.HalcustUpdateRule = LCSr.HalcustUpdateRule;
  //RCSr.HalpatchUpdateRule = LCSr.HalpatchUpdateRule;
  //RCSr.NewHansaVersion = LCSr.NewHansaVersion;
  //RCSr.WantedSubStatus = LCSr.WantedSubStatus;
  RCSr.CurrentSubStatus = LCSr.CurrentSubStatus;
  //RCSr.BackupFolder = LCSr.BackupFolder;
  //RCSr.ExecutableType = LCSr.ExecutableType;
  //RCSr.BackupTime = LCSr.BackupTime;
  //RCSr.PublicHostName = LCSr.PublicHostName;
  //RCSr.FastCheckFlag = LCSr.FastCheckFlag;
  //RCSr.WantedStatusParams = LCSr.WantedStatusParams;
  //RCSr.CloneFlag = LCSr.CloneFlag;
  //RCSr.WebClientStartPort = LCSr.WebClientStartPort;
  //RCSr.WebClientEndPort = LCSr.WebClientEndPort;
  //RCSr.ProgramType = LCSr.ProgramType;
  //RCSr.DisableCloudBackupFlag = LCSr.DisableCloudBackupFlag;
  //RCSr.Classification = LCSr.Classification;
  //RCSr.OnDemandFlag = LCSr.OnDemandFlag;
  //RCSr.Localizations = LCSr.Localizations;
  //RCSr.BackupOnStopFlag = LCSr.BackupOnStopFlag;
  //RCSr.CountryLocalizations = LCSr.CountryLocalizations;
  RCSr.ClosedOnNodeFlag = LCSr.ClosedOnNodeFlag;
  RCSr.Contract = LCSr.Contract;
  if (RCSr.MigrationFlag==1) then begin
    RCSr.OrgNr = LCSr.OrgNr;
    RCSr.OrgNr2 = LCSr.OrgNr2;
    RCSr.VATNr = LCSr.VATNr;
  end;
  RCSr.OldHansaVersion = LCSr.OldHansaVersion;
  //RCSr.WatchpointExceptions = LCSr.WatchpointExceptions;
  //RCSr.ExceptionComment = LCSr.ExceptionComment;
  //RCSr.EncryptionKey = LCSr.EncryptionKey;
  RCSr.JournalPresentFlag = LCSr.JournalPresentFlag;
  RCSr.MigrationFlag = LCSr.MigrationFlag; //KSZ:: moved to bottom so that we can unset the migration flag
  RCSr.HMCUCode = LCSr.HMCUCode;
  RCSr.HMRegInCountry = LCSr.HMRegInCountry;
  RCSr.LastStopDate = LCSr.LastStopDate;
  RCSr.LastStopTime = LCSr.LastStopTime;

  return;
end;

global
procedure CopyLCSDatatoRCS(record LocalCloudServerVc LCSr,record RemoteCloudServerVc RCSr)
begin
  RCSr.Name = LCSr.Name;
  RCSr.HansaVersion = LCSr.HansaVersion;
  RCSr.DataFolder = LCSr.DataFolder;
  RCSr.BindIP = LCSr.BindIP;
  RCSr.Port = LCSr.Port;
  RCSr.WantedStatus = LCSr.WantedStatus;
  RCSr.CurrentStatus = LCSr.CurrentStatus;
  RCSr.NextAttemptDate = LCSr.NextAttemptDate;
  RCSr.NextAttemptTime = LCSr.NextAttemptTime;
  RCSr.StatusText = LCSr.StatusText;
  RCSr.HTTPPort = LCSr.HTTPPort;
  RCSr.HTTPSPort = LCSr.HTTPSPort;
  RCSr.CUCode = LCSr.CUCode;
  RCSr.ExtraParameters = LCSr.ExtraParameters;
  RCSr.Comment = LCSr.Comment;
  RCSr.MaintPort = LCSr.MaintPort;
  RCSr.MassiveCacheMB = LCSr.MassiveCacheMB;
  RCSr.LogLevel = LCSr.LogLevel;
  RCSr.ServerName = LCSr.ServerName;
  RCSr.CoreDump = LCSr.CoreDump;
  RCSr.Closed = LCSr.Closed;
  RCSr.CreatedDate = LCSr.CreatedDate;
  RCSr.CreatedTime = LCSr.CreatedTime;
  RCSr.LastStartDate = LCSr.LastStartDate;
  RCSr.LastStartTime = LCSr.LastStartTime;
  RCSr.QuickRestarts = LCSr.QuickRestarts;
  RCSr.UUIDLock = LCSr.UUIDLock;
  RCSr.DisableHobcheck = LCSr.DisableHobcheck;
  RCSr.HalcustUpdateRule = LCSr.HalcustUpdateRule;
  RCSr.HalpatchUpdateRule = LCSr.HalpatchUpdateRule;
  RCSr.NewHansaVersion = LCSr.NewHansaVersion;
  RCSr.WantedSubStatus = LCSr.WantedSubStatus;
  RCSr.CurrentSubStatus = LCSr.CurrentSubStatus;
  RCSr.BackupFolder = LCSr.BackupFolder;
  RCSr.ExecutableType = LCSr.ExecutableType;
  RCSr.BackupTime = LCSr.BackupTime;
  RCSr.PublicHostName = LCSr.PublicHostName;
  RCSr.FastCheckFlag = LCSr.FastCheckFlag;
  RCSr.WantedStatusParams = LCSr.WantedStatusParams;
  RCSr.CloneFlag = LCSr.CloneFlag;
  if (SaveNodeReachableOnRCS) then begin
    RCSr.NodeReachableFlag = 1; // If we got here it should be reachable...
  end;
  RCSr.WebClientStartPort = LCSr.WebClientStartPort;
  RCSr.WebClientEndPort = LCSr.WebClientEndPort;
  RCSr.ProgramType = LCSr.ProgramType;
  RCSr.DisableCloudBackupFlag = LCSr.DisableCloudBackupFlag;
  RCSr.Classification = LCSr.Classification;
  RCSr.OnDemandFlag = LCSr.OnDemandFlag;
  RCSr.Localizations = LCSr.Localizations;
  RCSr.BackupOnStopFlag = LCSr.BackupOnStopFlag;
  RCSr.CountryLocalizations = LCSr.CountryLocalizations;
  RCSr.MigrationFlag = LCSr.MigrationFlag;
  RCSr.ClosedOnNodeFlag = LCSr.ClosedOnNodeFlag;
  RCSr.Contract = LCSr.Contract;
  RCSr.OrgNr = LCSr.OrgNr;
  RCSr.OrgNr2 = LCSr.OrgNr2;
  RCSr.VATNr = LCSr.VATNr;
  RCSr.OldHansaVersion = LCSr.OldHansaVersion;
  RCSr.WatchpointExceptions = LCSr.WatchpointExceptions;
  RCSr.ExceptionComment = LCSr.ExceptionComment;
  RCSr.EncryptionKey = LCSr.EncryptionKey;
  RCSr.JournalPresentFlag = LCSr.JournalPresentFlag;
  RCSr.HMCUCode = LCSr.HMCUCode;
  RCSr.HMRegInCountry = LCSr.HMRegInCountry;
  RCSr.LastStopDate = LCSr.LastStopDate;
  RCSr.LastStopTime = LCSr.LastStopTime;

  return;
end;

global
procedure CopyRCSDatatoLCS(record RemoteCloudServerVc RCSr,record LocalCloudServerVc LCSr)
begin
  LCSr.Name = RCSr.Name;
  LCSr.HansaVersion = RCSr.HansaVersion;
  LCSr.DataFolder = RCSr.DataFolder;
  LCSr.BindIP = RCSr.BindIP;
  LCSr.Port = RCSr.Port;
  LCSr.WantedStatus = RCSr.WantedStatus;
  //LCSr.CurrentStatus = RCSr.CurrentStatus;
  LCSr.NextAttemptDate = RCSr.NextAttemptDate;
  LCSr.NextAttemptTime = RCSr.NextAttemptTime;
  LCSr.StatusText = RCSr.StatusText;
  LCSr.HTTPPort = RCSr.HTTPPort;
  LCSr.HTTPSPort = RCSr.HTTPSPort;
  LCSr.CUCode = RCSr.CUCode;
  LCSr.ExtraParameters = RCSr.ExtraParameters;
  LCSr.Comment = RCSr.Comment;
  LCSr.MaintPort = RCSr.MaintPort;
  LCSr.MassiveCacheMB = RCSr.MassiveCacheMB;
  LCSr.LogLevel = RCSr.LogLevel;
  LCSr.ServerName = RCSr.ServerName;
  LCSr.CoreDump = RCSr.CoreDump;
  LCSr.Closed = RCSr.Closed;
  LCSr.CreatedDate = RCSr.CreatedDate;
  LCSr.CreatedTime = RCSr.CreatedTime;
  LCSr.LastStartDate = RCSr.LastStartDate;
  LCSr.LastStartTime = RCSr.LastStartTime;
  LCSr.QuickRestarts = RCSr.QuickRestarts;
  LCSr.UUIDLock = RCSr.UUIDLock;
  LCSr.DisableHobcheck = RCSr.DisableHobcheck;
  LCSr.HalcustUpdateRule = RCSr.HalcustUpdateRule;
  LCSr.HalpatchUpdateRule = RCSr.HalpatchUpdateRule;
  LCSr.NewHansaVersion = RCSr.NewHansaVersion;
  LCSr.WantedSubStatus = RCSr.WantedSubStatus;
  //LCSr.CurrentSubStatus = RCSr.CurrentSubStatus;
  LCSr.BackupFolder = RCSr.BackupFolder;
  LCSr.ExecutableType = RCSr.ExecutableType;
  LCSr.BackupTime = RCSr.BackupTime;
  LCSr.PublicHostName = RCSr.PublicHostName;
  LCSr.FastCheckFlag = RCSr.FastCheckFlag;
  LCSr.WantedStatusParams = RCSr.WantedStatusParams;
  LCSr.CloneFlag = RCSr.CloneFlag;
  LCSr.WebClientStartPort = RCSr.WebClientStartPort;
  LCSr.WebClientEndPort = RCSr.WebClientEndPort;
  LCSr.ProgramType = RCSr.ProgramType;
  LCSr.DisableCloudBackupFlag = RCSr.DisableCloudBackupFlag;
  LCSr.Classification = RCSr.Classification;
  LCSr.OnDemandFlag = RCSr.OnDemandFlag;
  LCSr.Localizations = RCSr.Localizations;
  LCSr.BackupOnStopFlag = RCSr.BackupOnStopFlag;
  LCSr.CountryLocalizations = RCSr.CountryLocalizations;
  LCSr.MigrationFlag = RCSr.MigrationFlag;
  LCSr.ClosedOnNodeFlag = RCSr.ClosedOnNodeFlag;
  LCSr.Contract = RCSr.Contract;
  LCSr.OrgNr = RCSr.OrgNr;
  LCSr.OrgNr2 = RCSr.OrgNr2;
  LCSr.VATNr = RCSr.VATNr;
  LCSr.OldHansaVersion = RCSr.OldHansaVersion;
  LCSr.WatchpointExceptions = RCSr.WatchpointExceptions;
  LCSr.ExceptionComment = RCSr.ExceptionComment;
  LCSr.EncryptionKey = RCSr.EncryptionKey;
  LCSr.JournalPresentFlag = RCSr.JournalPresentFlag;
  LCSr.HMCUCode = RCSr.HMCUCode;
  LCSr.HMRegInCountry = RCSr.HMRegInCountry;
  LCSr.LastStopDate = RCSr.LastStopDate;
  LCSr.LastStopTime = RCSr.LastStopTime;

  CopyRCSRowsToLCS(RCSr,LCSr);
  return;
end;

global
function string 255 NodeURL(record CloudNodeVc CNr)
begin
  string 255 res;
  
  res = CNr.HostName & ":" & CNr.SSLPort;
  
  NodeURL = res;
end;

global
function string 255 ReadNodeURL(var record CloudNodeVc CNr)
begin
  string 255 res;

  if (ReadFirstMain(CNr,1,true)) then begin
    if (CNr.Closed==0) then begin // We don't talk to closed CN:s
      res = NodeURL(CNr);
    end;
  end;

  ReadNodeURL = res;
  return;
end;

global
function string 255 RcsNodeURL(record RemoteCloudServerVc RCSr)
begin
  record CloudNodeVc CNr;
  string 255 res;

  CNr.Code = RCSr.Controller;
  
  if (ReadFirstMain(CNr,1,true)) then begin
    if (CNr.Closed==0) then begin // We don't talk to closed CN:s
      res = NodeURL(CNr);
    end;
  end;

  RcsNodeURL = res;
  return;
end;

global
function string 255 ServersFolder()
begin
  record CloudSettingsBlock CSb;
  string 255 res;
  
  BlockLoad(CSb);
  
  if (CSb.ServersFolder<>"") then begin
    res = CSb.ServersFolder;
    if (right(res,1)<>"/") then begin
      res = res & "/";
    end;
  end else begin
    res = "/Servers/";
  end;
  
  ServersFolder = res;
  return;
end;

global
function string 255 VersionsFolder()
begin
  record CloudSettingsBlock CSb;
  string 255 res,tstr;
  
  BlockLoad(CSb);
  
  if (CSb.VersionsFolder<>"") then begin
    res = CSb.VersionsFolder;
    if (right(res,1)<>"/") then begin
      res = res & "/";
    end;
  end else begin
    res = ServersFolder & "/Versions/";
  end;
  
  if ((left(res,1)!="/") and (left(res,1)!="\\") and (mid(res,1,2)!=":\\")) then begin
    tstr = ProgramFolder & "/" & res;
    res = tstr;
  end;

  VersionsFolder = res;
  return;
end;

global
function Boolean CheckVersion(record HansaVersionVc HVr)
begin
  Boolean res;
  Boolean foundexef;

  res = false;
  if (HVr.Closed!=0) then begin
    LogText(0,"CheckVersion(\"" & HVr.Code & "\") failed, version is closed");
    goto LCheckVersion;
  end;

  if (HVr.CurrentState==kHansaVersionStateError) then begin
    LogText(0,"CheckVersion(\"" & HVr.Code & "\") failed, version is in error state");
    goto LCheckVersion;
  end;

  if (HVr.CurrentState==kHansaVersionStateNotDownloaded) then begin
    LogText(0,"CheckVersion(\"" & HVr.Code & "\") failed, version is not downloaded");
    goto LCheckVersion;
  end;

  if (blank(HVr.Code)) then begin
    LogText(0,"CheckVersion(\"" & HVr.Code & "\") failed, version code is blank");
    goto LCheckVersion;
  end;

  if (DirExists(HVr.ProgramFolder)==false) then begin
    if (HVr.CurrentState!=kHansaVersionStateInstalling) then begin
      LogText(0,"CheckVersion failed, " & HVr.ProgramFolder & " does not exist");
    end;
    goto LCheckVersion;
  end;

  if (DirExists(HVr.ProgramFolder & "/hob")==false) then begin
    LogText(0,"CheckVersion failed, " & HVr.ProgramFolder & "/hob does not exist");
    goto LCheckVersion;
  end;

  if (FileExists(HVr.ProgramFolder & "/hob/startup.hob")==false) then begin
    LogText(0,"CheckVersion failed, " & HVr.ProgramFolder & "/hob/startup.hob does not exist");
    goto LCheckVersion;
  end;

  if (FileExists(HVr.ProgramFolder & "/hansa-server")) then begin foundexef = true; end;
  if (FileExists(HVr.ProgramFolder & "/hansa-server64")) then begin foundexef = true; end;
  if (FileExists(HVr.ProgramFolder & "/hansa-debug-server")) then begin foundexef = true; end;
  if (FileExists(HVr.ProgramFolder & "/hansa-debug-server64")) then begin foundexef = true; end;
  if (FileExists(HVr.ProgramFolder & "/hansa-debug-optimized-server")) then begin foundexef = true; end;
  if (FileExists(HVr.ProgramFolder & "/hansa-debug-optimized-server64")) then begin foundexef = true; end;

  if (foundexef==false) then begin
    LogText(0,"CheckVersion failed, " & HVr.ProgramFolder & " does not have any valid server executables");
    goto LCheckVersion;
  end;

  res = true;

LCheckVersion:;
  CheckVersion = res;
  return;
end;

global
function Boolean GetVersion(string vercode,var record HansaVersionVc HVr)
begin
  Boolean res;

  res = false;
  HVr.Code = vercode;

  if (blank(vercode)) then begin
    goto LGetVersion;
  end;

  if (ReadFirstMain(HVr,1,true)==false) then begin
//    LogText(0,"GetVersion(\"" & vercode & "\") failed, record not found");
    goto LGetVersion;
  end;

  if (HVr.Closed!=0) then begin
    LogText(0,"GetVersion(\"" & vercode & "\") failed, version is closed");
    goto LGetVersion;
  end;

  if (HVr.CurrentState==kHansaVersionStateError) then begin
    LogText(0,"GetVersion(\"" & HVr.Code & "\") failed, version is in error state");
    goto LGetVersion;
  end;

  if (HVr.CurrentState==kHansaVersionStateNotDownloaded) then begin
    if (IsDownloadingVersion(vercode)==false and
        ShouldDownloadVersion(vercode)==false and
        HVr.CurrentState!=kHansaVersionStateInstalling) then begin
      LogText(0,"GetVersion(\"" & vercode & "\") failed, version is not being downloaded");
    end;
    goto LGetVersion;
  end;

  if (HVr.CurrentState==kHansaVersionStateInstalling) then begin
    //LogText(0,"GetVersion(\"" & vercode & "\") failed, version is being installed");
    goto LGetVersion;
  end;

  if (blank(HVr.Code)) then begin
    LogText(0,"GetVersion(\"" & vercode & "\") failed, version code is blank");
    goto LGetVersion;
  end;

  if (CheckVersion(HVr)==false) then begin
    if (IsDownloadingVersion(vercode)==false and
        ShouldDownloadVersion(vercode)==false and
        HVr.CurrentState!=kHansaVersionStateInstalling) then begin
      LogText(0,"GetVersion(\"" & vercode & "\") failed, CheckVersion failed");
    end;
    goto LGetVersion;
  end;

  res = true;

LGetVersion:;
  GetVersion = res;
  return;
end;

global
procedure GetHansaVersionAtCN(var record HansaVersionVc HVr,var Boolean canbeupdatedf)
begin
  record HansaVersionVc HV2r;

  canbeupdatedf = false;
  RecordCopy(HV2r,HVr);

  if (ReadFirstMain(HVr,1,true)) then begin
    if ((HV2r.Name==HVr.Name) and
        (HV2r.Version==HVr.Version) and
        (HV2r.SubVersion==HVr.SubVersion) and
        (HV2r.RunningBuild==HVr.RunningBuild) and
        (HV2r.ProgramType==HVr.ProgramType) and
        (HV2r.ProductCode==HVr.ProductCode)) then begin
      canbeupdatedf = true;
    end;
/*
    if (CheckVersion(HVr)==false) then begin
      canbeupdatedf = false;
    end;
 */
  end;
end;

global
function string 255 DatabaseName(LongInt progtype)
begin
  string 255 res;
  
  switch (progtype) begin
    case typHansaRaama:         res = "RAAMA.HDB";
    case typFirstOffice:        res = "1OFFICE.HDB";
    case typFirstOfficePro:     res = "1OFFICE.HDB";
    case typFirstOfficeSmall:   res = "1OFFICE.HDB";
    case typFirstOfficeASP:     res = "1OFFICE.HDB";
    case typOffice2:            res = "OFFICE2.HDB";
    case typOffice2TB:          res = "OFFICE2.HDB";
    case typFirstContact:       res = "1CONTACT.HDB";
    case typOffLine:            res = "OffLine.HDB";
    otherwise                   res = "HANSA.HDB";
  end;
  
  DatabaseName = res;
  return;
end;

function string 255 JournalFolder(record LocalCloudServerVc LCSr)
begin
  string 255 res;

  if (blank(LCSr.HansaVersion)) then begin
    res = LCSr.DataFolder & "/journal";
  end else begin
    res = LCSr.DataFolder & "/journal";
  end;

  JournalFolder = res;
  return;
end;

function string 255 EnablerActionsFolder(record LocalCloudServerVc LCSr)
begin
  string 255 res;

  if (blank(LCSr.HansaVersion)) then begin
    res = LCSr.DataFolder & "/EnablerActions";
  end else begin
    res = LCSr.DataFolder & "/EnablerActions";
  end;

  EnablerActionsFolder = res;
  return;
end;

function string 255 HDBFile(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 res;

  if (blank(LCSr.HansaVersion)) then begin
    res = LCSr.DataFolder & "/" & DatabaseName(LCSr.ProgramType);
  end else begin
    res = LCSr.DataFolder & "/" & DatabaseName(HVr.ProgramType);
  end;

  HDBFile = res;
  return;
end;

function string 255 ServerExpectRestartFile(record LocalCloudServerVc LCSr)
begin
  string 255 res;
  res = LCSr.DataFolder & "/tmp/server_expect_restart.dat";
  ServerExpectRestartFile = res;
  return;
end;

function string 255 IntentionalStopFile(record LocalCloudServerVc LCSr)
begin
  string 255 res;
  res = LCSr.DataFolder & "/tmp/next_stop_intentional.dat";
  IntentionalStopFile = res;
  return;
end;

function string 255 PidFile(record LocalCloudServerVc LCSr)
begin
  string 255 res;
  
  res = LCSr.DataFolder & "/hansa.pid";
  
  PIDFile = res;
  return;
end;

global
function string 255 ReadStringFromFile(string filename)
begin
  string 255 res;
  area a;

  AddFileToArea(filename,a,false);
  res = Trim(GetStringFromArea(a,0,GetAreaLength(a)));
  ReadStringFromFile = res;
  
  return;
end;

global
function LongInt ReadLongFromFile(string filename)
begin
  LongInt res;
  area a;

  ReadLongFromFile = StringToLongInt(ReadStringFromFile(filename));
  
  return;
end;

global
function LongInt ServerPid(record LocalCloudServerVc LCSr)
begin
  string 255 pidfilename;
  Boolean pidfile_existsf,pid_is_runningf;
  LongInt svpid;

  pidfilename = PidFile(LCSr);
  pidfile_existsf = FileExists(pidfilename);

  if (pidfile_existsf) then begin
    svpid = ReadLongFromFile(pidfilename);
    pid_is_runningf = PidIsRunning(svpid);
  end;

  if (pid_is_runningf) then begin
    ServerPid = svpid;
  end else begin
    ServerPid = -1;
  end;
end;

procedure DebugTrace(string text)
begin
  LogText(0,text);
end;

procedure UpdateLCSEnablers(record LocalCloudServerVc LCSr,Integer when)
begin
  row LocalCloudServerVc LCSrw;
  Integer i,rwcnt;
  string 255 filename;
  area a;
  
  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LCSr,i,LCSrw);
    if (LCSrw.Item==kManagedServerItemEnabler) then begin
      filename = LCSr.DataFolder & "/" & LCSrw.ItemName;
      Delete_File(filename);
      if (((LCSrw.When==when) or (LCSrw.When==kManagedServerWhenAlways)) and LCSrw.Disabled==0) then begin
        if (blank(LCSrw.Data)) then begin
          CreateFile(filename);
          CloseFile;
        end else begin
          SetAreaZeroSize(a);
          AddTextToArea(LCSrw.Data,a);
          WriteAreaToFile(a,filename,0);
        end;
      end;
    end;
  end;

  return;
end;

function Boolean RCSShouldStartInMaintenance(record RemoteCloudServerVc RCSr,Integer when)
begin
  row RemoteCloudServerVc RCSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(RCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RCSr,i,RCSrw);
    if ((RCSrw.Item==kManagedServerItemStartMaintenance) and (RCSrw.Disabled==0) and
        (RCSrw.When==when)) then begin
      res = true;
    end;
  end;

  RCSShouldStartInMaintenance = res;
  return;
end;

function Boolean RCSShouldTreatSlaveSystems(record RemoteCloudServerVc RCSr,Integer when)
begin
  row RemoteCloudServerVc RCSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(RCSr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(RCSr,i,RCSrw);
    if (RCSrw.Item==kManagedServerItemSlaveSystem) then begin
      if ((RCSrw.When==kManagedServerWhenRunningNormally) and (when==kManagedServerWhenUpdateBegins)) then begin
        res = true;
      end;
    end;
  end;

  RCSShouldTreatSlaveSystems = res;
  return;
end;

function Boolean RCSShouldTreatCrontab(record RemoteCloudServerVc RCSr,Integer when)
begin
  row RemoteCloudServerVc RCSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(RCSr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(RCSr,i,RCSrw);
    if (RCSrw.Item==kManagedServerItemCrontabEntry) then begin
      if ((RCSrw.When==kManagedServerWhenUpdating) and ((when==kManagedServerWhenUpdateBegins) or (when==kManagedServerWhenUpdateEnds))) then begin
        res = true;
      end;
    end;
  end;

  RCSShouldTreatCrontab = res;
  return;
end;

function Boolean RCSShouldTreatSystemCopy(record RemoteCloudServerVc RCSr,Integer when)
begin
  record RemoteCloudServerVc RCS2r;
  row RemoteCloudServerVc RCSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(RCSr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(RCSr,i,RCSrw);
    if (RCSrw.Item==kManagedServerItemSystemCopy) then begin
      if (((RCSrw.When==when) or ((RCSrw.When==kManagedServerWhenUpdating) and (when==kManagedServerWhenUpdateBegins)) or
        ((RCSrw.When==kManagedServerWhenUpdateBegins) and (when==kManagedServerWhenUpdateExports))) and (RCSrw.Disabled==0)) then begin
        RCS2r.UUID = StringToUUID(RCSrw.ItemName);
        if (ReadFirstMain(RCS2r,1,true)) then begin
          if (RCS2r.Closed==0) then begin res = true; end;
        end;
      end;
    end;
  end;

  RCSShouldTreatSystemCopy = res;
  return;
end;

global
procedure PublishHansaMailLivePackagesAtCN(record HansaVersionVc HVr)
begin
  string 255 shfile;
  area a_script;
  LongInt rbuild;

  rbuild = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;

  LogText2(0,"PublishHansaMailLivePackagesAtCN()",kVerbosityDebugDetailed);

  AddLineToArea("#!/bin/bash",a_script);
  AddLineToArea("cd /Translations",a_script);
  AddLineToArea("vfolder=$(dirname $(grep -l \".\\.. ....-..-.. HansaMail\" c990*/.folderalias) 2>/dev/null)",a_script);
  AddLineToArea("if ( [ \"${vfolder}\" != \"\" ] ) then",a_script);
  AddLineToArea("p_cntry=great-britain",a_script);
  AddLineToArea("p_prod=HansaMail",a_script);
  AddLineToArea("p_prodlc=hansamail",a_script);
  AddLineToArea("running_build=" & rbuild,a_script);
  AddLineToArea("p_ccode=gbr",a_script);
  AddLineToArea("/Translations/_svr_publish_packages /Translations/${vfolder} \"(Apr 25 14:59:40 2016) ${p_cntry}/SpecificProducts/${p_prod}/Packages/${p_prodlc}.${p_cntry}.android.client.${running_build}.live.apk\" false false false false",a_script);
  AddLineToArea("/Translations/_svr_publish_packages /Translations/${vfolder} \"(Apr 25 21:25:52 2016) ${p_cntry}/SpecificProducts/${p_prod}/Packages/${p_prodlc}.${p_cntry}.macosx.client.${running_build}.live.dmg\" false false false false",a_script);
  AddLineToArea("/Translations/_svr_publish_packages /Translations/${vfolder} \"(Apr 25 21:26:40 2016) ${p_cntry}/SpecificProducts/${p_prod}/Packages/${p_prodlc}.${p_cntry}.windowsnet.client.${running_build}.live.msi\" false false false false",a_script);
  AddLineToArea("/Translations/_svr_publish_packages /Translations/${vfolder} \"(Apr 25 21:27:00 2016) ${p_cntry}/SpecificProducts/${p_prod}/Packages/${p_prodlc}.${p_cntry}.ios-999999999.client.${running_build}.live.ipa\" false false false false",a_script);
  AddLineToArea("fi",a_script);

  shfile = CreateTempFile("PHML-Script",".sh");
  WriteAreaToFile(a_script,shfile,0);
  RunShellScript("bash " & shfile);
  Delete_File(shfile);
end;

global
procedure PublishHansaMailLivePackages(record LocalCloudServerVc LCSr)
begin
  string 255 url;
  LongInt stat;
  record HansaVersionVc HVr;

  HVr.Code = LCSr.HansaVersion;
  if (ReadFirstMain(HVr,1,true)==true) then begin
    url = "hmt.hansaworld.com:499";
    LogText2(0,"PublishHansaMailLivePackages() calling PublishHansaMailLivePackagesAtCN on " & url,kVerbosityDebugDetailed);
    stat = CallService(url).PublishHansaMailLivePackagesAtCN(HVr);
    if (TreatServiceError(stat,url,"PublishHansaMailLivePackagesAtCN")) then begin
      LogText(0,"ERROR: Failed to publish HansaMail Live packages");
    end;
  end;

  return;
end;

global
function string 255 DetermineNextName(string fname,Boolean folderf)
begin
  string 255 nextname;
  string 255 tstr;
  Integer idx;
  Boolean testf;


  nextname = fname & "-" & DateToString(CurrentDate,"YYYYMMDD");
  tstr = nextname;

LDetermineNextName_Again:;
  if (folderf) then begin
    testf = DirExists(tstr);
  end else begin
    testf = FileExists(tstr);
  end;
  if (testf) then begin
    idx = idx + 1;
    tstr = nextname & "-" & idx;
    goto LDetermineNextName_Again;
  end;

  DetermineNextName = tstr;
  return;
end;

global
updating procedure ChangeVersionOnLocalCloudServer(UUID server_uuid,string new_vercode)
begin
  record LocalCloudServerVc OldLCSr,LCSr;
  record HansaVersionVc HV1r,HV2r;
  Boolean renamedbf;
  string 255 workdir,bkfldr,tstr,dbpath,dbfile;

  LCSr.UUID = server_uuid;
  if (ReadFirstMain(LCSr,1,true)==false) then begin
    LogText(0,"ChangeVersionOnLocalCloudServer(\"" & server_uuid & "\") failed, record not found");
  end else begin
    HV1r.Code = LCSr.HansaVersion;
    ReadFirstMain(HV1r,1,true);
    HV2r.Code = new_vercode;
    ReadFirstMain(HV2r,1,true);
    if (HV1r.Version!=HV2r.Version or HV1r.SubVersion!=HV2r.SubVersion) then begin
      switch (LCSr.CloneFlag) begin
        case 1: renamedbf = true;
        case 2:
        case 3:
        otherwise
      end;
    end;

    if (renamedbf) then begin
      dbpath = HDBFile(LCSr,HV1r);
      if (FileExists(dbpath)) then begin
        workdir = LCSr.DataFolder;
        dbfile = BaseName(dbpath);
        if ((left(workdir,1)!="/") and (left(workdir,1)!="\\") and (mid(workdir,1,2)!=":\\")) then begin
          workdir = ProgramFolder & "/" & workdir;
        end;
        bkfldr = workdir & "/oldver." & LCSr.HansaVersion;  //## should have timestamp
        CreateFolderHierarchy(bkfldr & "/");
        if (FileExists(bkfldr & "/" & dbfile)) then begin
          tstr = DetermineNextName(bkfldr & "/" & dbfile,false);
          RenameFile(bkfldr & "/" & dbfile,tstr);
        end;
        MoveFile(dbfile,DirName(dbpath),bkfldr);
      end;
    end;

    RecordCopy(OldLCSr,LCSr);
    LCSr.OldHansaVersion = LCSr.HansaVersion;
    LCSr.HansaVersion = new_vercode;
    RecordUpdate(OldLCSr,LCSr,true);
//    if (LCSr.Name=="HansaMail Live") then begin
//      PublishHansaMailLivePackages(LCSr);
//    end;
  end;
end;

global
updating function Boolean DoChangeVersionOnRemoteCloudServer(record RemoteCloudServerVc RCSr,string new_vercode)
begin
  Boolean res,testf;
  string 255 url;
  LongInt stat;
  record CloudNodeVc CNr;
  row RemoteCloudServerVc RCSrw;
  record RemoteCloudServerVc RCS2r,OldRCS2r;
  Integer rwcnt,i;

  if (ReadFirstMain(RCSr,1,true)==false) then begin
    LogText(0,"ERROR DoChangeVersionOnRemoteCloudServer RCSr.Name=" & RCSName(RCSr) & ", RCSr.UUID=" & RCSr.UUID & " not found!");
    goto LDoChangeVersionOnRemoteCloudServer;
  end;

  rwcnt = MatRowCnt(RCSr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(RCSr,i,RCSrw);
    testf = false;
//    if (RCSrw.Item==kManagedServerItemSystemCopy) then begin testf = true; end;
//    if (RCSrw.Item==kManagedServerItemSlaveSystem) then begin testf = true; end;
    if (RCSrw.Item==kManagedServerItemReserveSystem) then begin testf = true; end;
    if (RCSrw.Item==kManagedServerItemTestSystem) then begin testf = true; end;
    //if (RCSrw.Item==kManagedServerItemUpdateSystem) then begin testf = true; end;
    if (RCSrw.Item==kManagedServerItemSlaveSystem) then begin testf = true; end;
    if (testf==true) then begin
      RCS2r.UUID = StringToUUID(RCSrw.ItemName);
      if (ReadFirstMain(RCS2r,1,true)) then begin
        if ((RCS2r.Closed==0) and (RCS2r.HansaVersion==RCSr.HansaVersion)) then begin
          CNr.Code = RCS2r.Controller;
          url = ReadNodeURL(CNr);

          if (RCSrw.Item==kManagedServerItemSlaveSystem) then begin
            RecordCopy(OldRCS2r,RCS2r);
            RCS2r.NewHansaVersion = new_vercode;
            RecordUpdate(OldRCS2r,RCS2r,true);
            UpdateRemoteCloudServer(RCS2r);
          end else begin
            stat = CallService(url).ChangeVersionOnLocalCloudServer(RCS2r.UUID,new_vercode);
            if (TreatServiceError(stat,url,"ChangeVersionOnLocalCloudServer")) then begin
              LogText(0,"Failed to change version to " & new_vercode & " on " & RCSName(RCS2r));
            end;
          end;
        end else begin
          LogText(0,"Not changing version on " & RCSName(RCS2r) & " because it is either closed on not on the same version as the mother system");
        end;
      end;
    end;
  end;

  CNr.Code = RCSr.Controller;
  url = ReadNodeURL(CNr);

  stat = CallService(url).ChangeVersionOnLocalCloudServer(RCSr.UUID,new_vercode);
  if (TreatServiceError(stat,url,"ChangeVersionOnLocalCloudServer")) then begin
    LogText(0,"Failed to change version to " & new_vercode & " on " & RCSName(RCSr));
    goto LDoChangeVersionOnRemoteCloudServer;
  end;

  res = true;
  threadasync.SyncRCSDataWithOneCN2(CNr,true,true);

LDoChangeVersionOnRemoteCloudServer:;
  DoChangeVersionOnRemoteCloudServer = res;
  return;
end;

global
updating procedure UpdateServerWantedStatus(var record RemoteCloudServerVc RCSr)
begin
  LongInt old_wantedstatus;
  record RemoteCloudServerVc OldRCSr;
  Boolean startf;

  if (ReadFirstMain(RCSr,1,true)==false) then begin
    LogText(0,"ERROR UpdateServerWantedStatus RCSr.Name=" & RCSName(RCSr) & ", RCSr.UUID=" & RCSr.UUID & " not found!");
    goto LUpdateServerWantedStatus;
  end;
  RecordCopy(OldRCSr,RCSr);

  old_wantedstatus = RCSr.WantedStatus;

  switch (RCSr.CurrentStatus) begin
    case kStatusCreated:
      switch (old_wantedstatus) begin
        case kWantedStatusCreateServer:         RCSr.WantedStatus = kWantedStatusStop; startf = false;
        case kWantedStatusCreateStartedServer:  RCSr.WantedStatus = kWantedStatusImportBackupAndRun;  startf = true;
        case kWantedStatusLaunchReserveSystem:  RCSr.WantedStatus = kWantedStatusRun; startf = true;
        case kWantedStatusLaunchUpdateSystem:   RCSr.WantedStatus = kWantedStatusRun; startf = true;
        case kWantedStatusLaunchTestSystem:     RCSr.WantedStatus = kWantedStatusRun; startf = true;
      end;
      StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,startf,true);
    case kStatusRunningPreparingUpdate:
    case kStatusRunningUpdate:
    case kStatusRunningPreparingTest:
    case kStatusRunningTest:
    case kStatusRunningReserve:
    case kStatusRunningPreparingReserve:
    case kStatusRunning:
      if (old_wantedstatus==kWantedStatusRunUnjournaled) begin
        RCSr.WantedStatus = kWantedStatusRun;
      end;
      if ((RCSr.OnDemandFlag==1) and ((old_wantedstatus==kWantedStatusImportBackupAndRun) or
                                      (old_wantedstatus==kWantedStatusRun) or
                                      (old_wantedstatus==kWantedStatusRunUnjournaled))) then begin
        RCSr.WantedStatus = kWantedStatusOnDemand;
        StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
      end else begin
        if (old_wantedstatus==kWantedStatusImportBackupAndRun) then begin
          RCSr.WantedStatus = kWantedStatusRun;
          StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
        end;
      end;
    case kStatusRunningPendingStop:
      // not sure
    case kStatusStopped:
      switch (old_wantedstatus) begin
        case kWantedStatusChangeVersion:
          if (DoChangeVersionOnRemoteCloudServer(RCSr,RCSr.NewHansaVersion)) then begin
            if (RCSr.OnDemandFlag==0) then begin
              RCSr.WantedStatus = kWantedStatusRun;
            end else begin
              RCSr.WantedStatus = kWantedStatusOnDemand;
            end;
            StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
          end;
        case kWantedStatusRestart:
          if (RCSr.OnDemandFlag==0) then begin
            RCSr.WantedStatus = kWantedStatusRun;
          end else begin
            RCSr.WantedStatus = kWantedStatusOnDemand;
          end;
          StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
        case kWantedStatusStop:
          if (RCSr.OnDemandFlag==1) then begin
            RCSr.WantedStatus = kWantedStatusOnDemand;
          end;
          StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,false,true);
        case kWantedStatusForceStop:
          if (RCSr.OnDemandFlag==1) then begin
            RCSr.WantedStatus = kWantedStatusOnDemand;
          end;
          StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,false,true);
      end;
    case kStatusExportedDatabase:
      if (RCSr.OnDemandFlag==0) then begin
        RCSr.WantedStatus = kWantedStatusStop;
      end else begin
        RCSr.WantedStatus = kWantedStatusOnDemand;
      end;
    case kStatusExportedRegister:
      if (RCSr.OnDemandFlag==0) then begin
        RCSr.WantedStatus = kWantedStatusStop;
      end else begin
        RCSr.WantedStatus = kWantedStatusOnDemand;
      end;
    case kStatusExportedCompany:
      if (RCSr.OnDemandFlag==0) then begin
        RCSr.WantedStatus = kWantedStatusStop;
      end else begin
        RCSr.WantedStatus = kWantedStatusOnDemand;
      end;
    case kStatusImportedBackup:
      switch (old_wantedstatus) begin
        case kWantedStatusImportBackupAndRun:
          RCSr.WantedStatus = kWantedStatusRun;
        case kWantedStatusRun:
          if (RCSr.OnDemandFlag==0) then begin
            RCSr.WantedStatus = kWantedStatusRun;
          end else begin
            RCSr.WantedStatus = kWantedStatusOnDemand;
          end;
        otherwise
          if (RCSr.OnDemandFlag==0) then begin
            RCSr.WantedStatus = kWantedStatusStop;
          end else begin
            RCSr.WantedStatus = kWantedStatusOnDemand;
          end;
      end;
  end;

  if (old_wantedstatus!=RCSr.WantedStatus) then begin
    LogText(0,"UpdateServerWantedStatus: WantedStatus for " & RCSr.UUID & " changed from " & WantedStatusName(old_wantedstatus) & " to " & WantedStatusName(RCSr.WantedStatus));
  end;

  RecordUpdate(OldRCSr,RCSr,true);

LUpdateServerWantedStatus:;
  return;
end;

updating
global procedure SetLocalCloudServerSubStatus(record LocalCloudServerVc LCSr,LongInt substatus)
begin
  record LocalCloudServerVc OldLCSr;

  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentSubStatus = substatus;
    RecordUpdate(OldLCSr,LCSr,true);
  end;
end;

updating
procedure SetRemoteCloudServerSubStatus(record RemoteCloudServerVc RCSr,LongInt substatus)
begin
  string 255 url;
  LongInt stat;
  record LocalCloudServerVc LCSr;

  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin goto LSetRemoteCloudServerSubStatus; end;

  LCSr.UUID = RCSr.UUID;
  stat = CallService(url).SetLocalCloudServerSubStatus(LCSr,substatus);
  if (TreatServiceError(stat,url,"SetLocalCloudServerSubStatus")) then begin
    LogText(0,"Failed to set substatus on remote cloud server " & RCSName(RCSr));
    goto LSetRemoteCloudServerSubStatus;
  end;

LSetRemoteCloudServerSubStatus:;
end;

global
updating procedure StartRemoteCloudServer(record RemoteCloudServerVc RCSr,Boolean maintf)
begin
  record RemoteCloudServerVc OldRCSr;
  record CloudNodeVc CNr;
  Boolean testf;

  testf = true;
  if (RCSr.Closed!=0) then begin testf = false; end;
  if (RCSr.CurrentStatus!=kStatusStopped) then begin testf = false; end;
  if (testf) then begin
    RecordCopy(OldRCSr,RCSr);
    if (maintf==true) then begin
      RCSr.WantedStatus = kWantedStatusMaintenence;
    end else begin
      RCSr.WantedStatus = kWantedStatusRun;
      StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
    end;
    RecordUpdate(OldRCSr,RCSr,true);
    CNr.Code = RCSr.Controller;
    threadasync.SyncRCSDataWithOneCN2(CNr,true,true);
    SetCloudControllerStatus(kJobStatusError,"Starting server " & RCSName(RCSr));
  end else begin
    SetCloudControllerStatus(kJobStatusError,"Ignoring start command for server " & RCSName(RCSr));
  end;
end;

global
updating procedure ClearQuickRestarts(var record LocalCloudServerVc LCSr)
begin
  record LocalCloudServerVc oldLCSr;

  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(oldLCSr,LCSr);
    LCSr.QuickRestarts = 0;
    RecordUpdate(oldLCSr,LCSr,false);
    UpdateClientBrowsesIfNeeded("LocalCloudServerVc");
  end;

  return;
end;

global
procedure DoClearQuickRestartsOnNode(uuid serverid)
begin
  record LocalCloudServerVc LCSr;

  LCSr.UUID = serverid;
  if (ReadFirstMain(LCSr,1,true)) then begin
    qupdating.ClearQuickRestarts(LCSr);
  end;
end;

global
procedure ClearQuickRestartsOnNode(record RemoteCloudServerVc RCSr)
begin
  string 255 url;
  LongInt stat;

  url = RcsNodeURL(RCSr);
  stat = CallService(url).DoClearQuickRestartsOnNode(RCSr.UUID);
  if (TreatServiceError(stat,url,"ClearQuickRestartsOnNode")) then begin
  end;
end;

global
updating procedure StopRemoteCloudServer(record RemoteCloudServerVc RCSr,Boolean forcef)
begin
  record RemoteCloudServerVc OldRCSr;
  Boolean testf;
  record CloudNodeVc CNr;

  testf = true;
  if (RCSr.Closed<>0) then begin testf = false; end;
  if (testf) then begin
    RecordCopy(OldRCSr,RCSr);
    if (forcef) then begin
      RCSr.WantedStatus = kWantedStatusForceStop;
    end else begin
      RCSr.WantedStatus = kWantedStatusStop;
    end;
    RCSr.WantedSubStatus = kWantedSubStatusNone;
    RecordUpdate(OldRCSr,RCSr,true);
    StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,false,true);
    CNr.Code = RCSr.Controller;
    threadasync.SyncRCSDataWithOneCN2(CNr,true,true); // change back
    threadasync.ClearQuickRestartsOnNode(RCSr);
    SetCloudControllerStatus(kJobStatusError,"Stopping cloud server " & RCSName(RCSr));
  end else begin
    SetCloudControllerStatus(kJobStatusError,"Ignoring stop command for server " & RCSName(RCSr));
  end;
  return;
end;

updating procedure StartStopSystemCopies(var record RemoteCloudServerVc RCSr,LongInt when,Boolean startf,Boolean slavesystemsf)
begin
  record RemoteCloudServerVc RCS2r;
  record RemoteCloudServerVc OldRCS2r;
  row RemoteCloudServerVc RCSrw;
  Integer i,rwcnt;
  Boolean all_donef;
  Boolean testf,test2f;

  all_donef = true;
  rwcnt = MatRowCnt(RCSr);
  for (i = 0; i<rwcnt; i = i + 1) begin
    MatRowGet(RCSr,i,RCSrw);
    testf = false;
    if ((RCSrw.Item==kManagedServerItemSystemCopy) and (slavesystemsf==false)) then begin testf = true; end;
    if ((RCSrw.Item==kManagedServerItemSlaveSystem) and (slavesystemsf==true)) then begin testf = true; end;
    if ((RCSrw.Item==kManagedServerItemMotherSystem) and (RCSr.CloneFlag!=0) and (RCSr.CurrentStatus==kStatusCreated) and (startf==true)) then begin testf = true; end;
    if ((RCSrw.Item==kManagedServerItemReserveSystem) and (slavesystemsf==true)) then begin testf = true; end;
    if ((RCSrw.Item==kManagedServerItemTestSystem) and (slavesystemsf==true)) then begin testf = true; end;
    if ((RCSrw.Item==kManagedServerItemUpdateSystem) and (slavesystemsf==true)) then begin testf = true; end;
    if (testf==true) then begin
      test2f = false;
      if ((slavesystemsf==false)) then begin
        if (RCSrw.When==when) then begin test2f = true; end;
        if ((RCSrw.When==kManagedServerWhenUpdateBegins) and (when==kManagedServerWhenUpdateExports)) then begin test2f = true; end;
      end else begin
        if ((RCSrw.When==kManagedServerWhenRunningNormally) and
            ((when==kManagedServerWhenUpdating) or (when==kManagedServerWhenRunningNormally))) then begin test2f = true; end;
      end;
      if (RCSrw.Disabled!=0) then begin test2f = false; end;
      if (test2f) then begin
        RCS2r.UUID = StringToUUID(RCSrw.ItemName);
        if (ReadFirstMain(RCS2r,1,true)) then begin
          if ((RCS2r.Closed==0) and ((RCSrw.Item==kManagedServerItemMotherSystem) and (RCS2r.CloneFlag!=0)) or
              (RCSrw.Item!=kManagedServerItemMotherSystem)) then begin
            if (startf==true) then begin
              if ((RCS2r.WantedStatus!=kWantedStatusRun) and (RCS2r.WantedStatus!=kWantedStatusRunUnjournaled)) then begin
                if ((RCS2r.CloneFlag==0) and (RCSr.HansaVersion!=RCS2r.HansaVersion)) then begin
                  RecordCopy(OldRCS2r,RCS2r);
                  RCS2r.NewHansaVersion = RCSr.HansaVersion;
                  RecordUpdate(OldRCS2r,RCS2r,true);
                  UpdateRemoteCloudServer(RCS2r);
                end else begin
                  StartRemoteCloudServer(RCS2r,false);
                end;
                all_donef = false;
              end else begin
                if ((RCS2r.CurrentStatus!=kStatusRunning) and
                    (RCS2r.CurrentStatus!=kStatusRunningPreparingUpdate) and
                    (RCS2r.CurrentStatus!=kStatusRunningUpdate) and
                    (RCS2r.CurrentStatus!=kStatusRunningPreparingTest) and
                    (RCS2r.CurrentStatus!=kStatusRunningTest) and
                    (RCS2r.CurrentStatus!=kStatusRunningReserve) and
                    (RCS2r.CurrentStatus!=kStatusRunningPreparingReserve) and
                    (RCS2r.CurrentStatus!=kStatusRunningPendingStop)) then begin
                  all_donef = false;
                end;
              end;
            end else begin
              if ((RCSrw.When!=kManagedServerWhenUpdating) or (slavesystemsf==true)) then begin // ugly, but OR should keep runnung
                if ((RCS2r.WantedStatus!=kWantedStatusStop) and (RCS2r.WantedStatus!=kWantedStatusForceStop)) then begin
                  if (RCS2r.CurrentStatus!=kStatusRunningTest) then begin
                    StopRemoteCloudServer(RCS2r,false);
                  end;
                  all_donef = false;
                end else begin
                  if (RCS2r.CurrentStatus!=kStatusStopped) then begin
                    all_donef = false;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;

  if (all_donef) then begin
    if (startf) then begin
      if (slavesystemsf==false) then begin
        if (RCSr.CurrentSubStatus==kSubStatusStartingSystemCopiesBeforeExport) then begin
          SetRemoteCloudServerSubStatus(RCSr,kSubStatusStartingSystemCopiesBeforeExportCompleted);
        end else begin
          SetRemoteCloudServerSubStatus(RCSr,kSubStatusStartingSystemCopiesDuringUpdateCompleted);
        end;
      end;
    end else begin
      if (slavesystemsf==false) then begin
        SetRemoteCloudServerSubStatus(RCSr,kSubStatusStoppingSystemCopiesDuringUpdateCompleted);
      end else begin
        if (RCSr.CurrentSubStatus==kSubStatusStoppingSlaveSystems) then begin
          SetRemoteCloudServerSubStatus(RCSr,kSubStatusStoppingSlaveSystemsCompleted);
        end;
      end;
    end;
  end;
end;

global
updating procedure UpdateServerWantedSubStatus(var record RemoteCloudServerVc RCSr)
begin
  LongInt old_status;
  LongInt old_wantedstatus;
  LongInt old_substatus;
  LongInt old_wantedsubstatus;
  record RemoteCloudServerVc OldRCSr;

  if (ReadFirstMain(RCSr,1,true)==false) then begin
    LogText(0,"ERROR UpdateServerWantedSubStatus RCSr.Name=" & RCSName(RCSr) & ", RCSr.UUID=" & RCSr.UUID & " not found!");
    goto LUpdateServerWantedSubStatus;
  end;
  RecordCopy(OldRCSr,RCSr);

  old_status = RCSr.CurrentStatus;
  old_wantedstatus = RCSr.WantedStatus;
  old_substatus = RCSr.CurrentSubStatus;
  old_wantedsubstatus = RCSr.WantedSubStatus;

  switch (RCSr.CurrentSubStatus) begin
    case kSubStatusBeforeExport:
      if (RCSShouldTreatCrontab(RCSr,kManagedServerWhenUpdateBegins)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusSetCrontabBeforeUpdate;
      end else begin
        if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdateBegins)) then begin
          RCSr.WantedSubStatus = kWantedSubStatusDBCopyBeforeUpdate;
        end else begin
          if (RCSShouldTreatSlaveSystems(RCSr,kManagedServerWhenUpdateBegins)) then begin
            RCSr.WantedSubStatus = kWantedSubStatusStopSlaveSystems;
          end else begin
            RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
          end;
        end;
      end;
    case kSubStatusSetCrontabBeforeUpdateCompleted:
      if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdateBegins)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusDBCopyBeforeUpdate;
      end else begin
        if (RCSShouldTreatSlaveSystems(RCSr,kManagedServerWhenUpdateBegins)) then begin
          RCSr.WantedSubStatus = kWantedSubStatusStopSlaveSystems;
        end else begin
          RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
        end;
      end;
    case kSubStatusDBCopyBeforeUpdateCompleted:
      if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdateBegins)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusSystemCopyBeforeUpdate;
      end else begin
        if (RCSShouldTreatSlaveSystems(RCSr,kManagedServerWhenUpdateBegins)) then begin
          RCSr.WantedSubStatus = kWantedSubStatusStopSlaveSystems;
        end else begin
          RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
        end;
      end;
    case kSubStatusSystemCopyBeforeUpdateCompleted:
      if (RCSShouldTreatSlaveSystems(RCSr,kManagedServerWhenUpdateBegins)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusStopSlaveSystems;
      end else begin
        RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
      end;
    case kSubStatusStoppingSlaveSystemsCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
    case kSubStatusStopForExportCompleted:
      if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdateExports)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusStartSystemCopiesBeforeExport;
      end else begin
        if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdating)) then begin
          RCSr.WantedSubStatus = kWantedSubStatusSystemCopyDuringUpdate;
        end else begin
          RCSr.WantedSubStatus = kWantedSubStatusExport;
        end;
      end;
    case kSubStatusStartingSystemCopiesBeforeExportCompleted:
      if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdating)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusSystemCopyDuringUpdate;
      end else begin
        RCSr.WantedSubStatus = kWantedSubStatusExport;
      end;
    case kSubStatusSystemCopyDuringUpdateCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusStartSystemCopiesDuringUpdate;
    case kSubStatusStartingSystemCopiesDuringUpdateCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusExport;
    case kSubStatusExportingCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusAfterExport;
    case kSubStatusAfterExport:
      RCSr.WantedSubStatus = kWantedSubStatusImport;
    case kSubStatusImportingCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusAfterImport;
    case kSubStatusAfterImport:
      RCSr.HalcustUpdateRule = kHalUpdateRuleNotTested; // One-off setting
      RCSr.HalpatchUpdateRule = kHalUpdateRuleNotTested; // One-off setting
      if (RCSShouldTreatSystemCopy(RCSr,kManagedServerWhenUpdateBegins)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusStopSystemCopiesDuringUpdate;
      end else begin
        if (RCSShouldTreatCrontab(RCsr,kManagedServerWhenUpdateEnds)) then begin
          RCSr.WantedSubStatus = kWantedSubStatusSetCrontabAfterUpdate;
        end else begin
          RCSr.WantedSubStatus = kWantedSubStatusNone;
          if (RCSShouldStartInMaintenance(RCSr,kManagedServerWhenUpdateEnds)) then begin
            RCSr.WantedStatus = kWantedStatusMaintenence;
          end else begin
            RCSr.WantedStatus = kWantedStatusRun;
          end;
        end;
      end;
    case kSubStatusStoppingSystemCopiesDuringUpdateCompleted:
      if (RCSShouldTreatCrontab(RCsr,kManagedServerWhenUpdateEnds)) then begin
        RCSr.WantedSubStatus = kWantedSubStatusSetCrontabAfterUpdate;
      end else begin
        RCSr.WantedSubStatus = kWantedSubStatusNone;
        RCSr.WantedStatus = kWantedStatusRun;
        if (RCSShouldStartInMaintenance(RCSr,kManagedServerWhenUpdateEnds)) then begin
          RCSr.WantedStatus = kWantedStatusMaintenence;
        end else begin
          RCSr.WantedStatus = kWantedStatusRun;
        end;
      end;
    case kSubStatusSetCrontabAfterUpdateCompleted:
      RCSr.WantedSubStatus = kWantedSubStatusNone;
      RCSr.WantedStatus = kWantedStatusRun;
      if (RCSShouldStartInMaintenance(RCSr,kManagedServerWhenUpdateEnds)) then begin
        RCSr.WantedStatus = kWantedStatusMaintenence;
      end else begin
        RCSr.WantedStatus = kWantedStatusRun;
      end;
  end;

  if ((RCSr.WantedStatus==kWantedStatusRun) or (RCSr.WantedStatus==kWantedStatusRunUnjournaled)) then begin
    StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
  end;

  switch (RCSr.CurrentSubStatus) begin
    case kSubStatusStartingSystemCopiesBeforeExport:  StartStopSystemCopies(RCSr,kManagedServerWhenUpdateExports,true,false);
    case kSubStatusStartingSystemCopiesDuringUpdate:  StartStopSystemCopies(RCSr,kManagedServerWhenUpdating,true,false); // must fix + rcsshouldstart...
    case kSubStatusStoppingSystemCopiesDuringUpdate:  StartStopSystemCopies(RCSr,kManagedServerWhenUpdating,false,false);
    case kSubStatusStoppingSlaveSystems:              StartStopSystemCopies(RCSr,kManagedServerWhenUpdating,false,true);
  end;

  if (old_status!=RCSr.CurrentStatus) then begin
    LogText(0,"UpdateServerWantedSubStatus: CurrentStatus for " & RCSr.UUID & " changed from " & StatusName(old_status) & " to " & StatusName(RCSr.CurrentStatus));
  end;
  if (old_wantedstatus!=RCSr.WantedStatus) then begin
    LogText(0,"UpdateServerWantedSubStatus: WantedStatus for " & RCSr.UUID & " changed from " & WantedStatusName(old_wantedstatus) & " to " & WantedStatusName(RCSr.WantedStatus));
  end;
  if (old_substatus!=RCSr.CurrentSubStatus) then begin
    LogText(0,"UpdateServerWantedSubStatus: CurrentSubStatus for " & RCSr.UUID & " changed from " & SubStatusName(old_substatus) & " to " & SubStatusName(RCSr.CurrentSubStatus));
  end;
  if (old_wantedsubstatus!=RCSr.WantedSubStatus) then begin
    LogText(0,"UpdateServerWantedSubStatus: WantedSubStatus for " & RCSr.UUID & " changed from " & WantedSubStatusName(old_wantedsubstatus) & " to " & WantedSubStatusName(RCSr.WantedSubStatus));
  end;

  RecordUpdate(OldRCSr,RCSr,false);
LUpdateServerWantedSubStatus:;
  return;
end;

function string 255 LinuxVersionExe(record HansaVersionVc HVr,record LocalCloudServerVc LCSr)
begin
  string 255 res,tstr;

  switch (LCSr.ExecutableType) begin
    case kExecutableTypeOptimizedDebug:       res = HVr.ProgramFolder & "/hansa-debug-optimized-server";
    case kExecutableTypeDebug:                res = HVr.ProgramFolder & "/hansa-debug-server";
    case kExecutableTypeSlave:                res = HVr.ProgramFolder & "/hansa-slave";
    case kExecutableTypeSlaveDebug:           res = HVr.ProgramFolder & "/hansa-debug-slave";
    case kExecutableTypeSlaveOptimizedDebug:  res = HVr.ProgramFolder & "/hansa-debug-optimized-slave";
    otherwise
      LogText(0,"LinuxVersionExe() - Invalid executable type: " & LCSr.ExecutableType);
  end;

  if (GetGlobalBoolean("En64BitOS") and nonblank(res) and
     (LCSr.ExecutableType!=kExecutableTypeSlave) and
     (LCSr.ExecutableType!=kExecutableTypeSlaveDebug) and
     (LCSr.ExecutableType!=kExecutableTypeSlaveOptimizedDebug)) then begin
    res = res & "64";
  end;

  if (left(res,1)!="/") then begin
    tstr = HVr.ProgramFolder & "/" & res;
    res = tstr;
  end;

  if (HVr.Version<72) then begin
    if (FileExists(res)==false) then begin
      res = HVr.ProgramFolder & "/" & "hansa-server";
    end;
    if (FileExists(res)==false) then begin
      res = HVr.ProgramFolder & "/" & "hansa-debug-server";
    end;
  end;

  LinuxVersionExe = res;
  return;
end;

function string 255 WindowsVersionExe(record HansaVersionVc HVr,record LocalCloudServerVc LCSr)
begin
  string 255 res,tstr;

  switch (LCSr.ExecutableType) begin
    case kExecutableTypeOptimizedDebug:       res = HVr.ProgramFolder & "/hansa-windows-optimized-server";
    case kExecutableTypeDebug:                res = HVr.ProgramFolder & "/hansa-windows-optimized-server";
    case kExecutableTypeSlave:                res = HVr.ProgramFolder & "/hansa-windows-optimized-slave";
    case kExecutableTypeSlaveDebug:           res = HVr.ProgramFolder & "/hansa-windows-optimized-slave";
    case kExecutableTypeSlaveOptimizedDebug:  res = HVr.ProgramFolder & "/hansa-windows-optimized-slave";
    otherwise
      LogText(0,"WindowsVersionExe() - Invalid executable type: " & LCSr.ExecutableType);
  end;

  if (GetGlobalBoolean("En64BitOS") and nonblank(res) and
     (LCSr.ExecutableType!=kExecutableTypeSlave) and
     (LCSr.ExecutableType!=kExecutableTypeSlaveDebug) and
     (LCSr.ExecutableType!=kExecutableTypeSlaveOptimizedDebug)) then begin
    res = res & "64";
  end;

  res = res & ".exe";

  if (mid(res,1,1)!=":") then begin
    tstr = ProgramFolder & "\\" & res;
    res = tstr;
  end;

  WindowsVersionExe = res;
  return;
end;

function string 255 MacOSXVersionExe(record HansaVersionVc HVr,record LocalCloudServerVc LCSr)
begin
  string 255 res,tstr;

  switch (LCSr.ExecutableType) begin
    case kExecutableTypeOptimizedDebug:       res = HVr.ProgramFolder & "/hansa-macosx-optimized-server";
    case kExecutableTypeDebug:                res = HVr.ProgramFolder & "/hansa-macosx-optimized-server";
    case kExecutableTypeSlave:                res = HVr.ProgramFolder & "/hansa-macosx-optimized-slave";
    case kExecutableTypeSlaveDebug:           res = HVr.ProgramFolder & "/hansa-macosx-optimized-slave";
    case kExecutableTypeSlaveOptimizedDebug:  res = HVr.ProgramFolder & "/hansa-macosx-optimized-slave";
    otherwise
      LogText(0,"MacOSXVersionExe() - Invalid executable type: " & LCSr.ExecutableType);
  end;

  if (left(res,1)!="/") then begin
    tstr = ProgramFolder & "/" & res;
    res = tstr;
  end;

  MacOSXVersionExe = res;
  return;
end;

function string 255 VersionExe(record HansaVersionVc HVr,record LocalCloudServerVc LCSr,Boolean forceverf)
begin
  string 255 res,tstr;

  if (blank(LCSr.HansaVersion) and !forceverf) then begin // Use process name as EXE name, EXE and HOBs from workdir
    res = LCSr.DataFolder & "/" & LCSr.ServerName;
    if ((left(res,1)!="/") and (left(res,1)!="\\") and (mid(res,1,2)!=":\\")) then begin
      tstr = ProgramFolder & "/" & res;
      res = tstr;
    end;
  end else begin
    switch (ProgramPlatform) begin
      case kPlatformUnknown:    res = LinuxVersionExe(HVr,LCSr);
      case kPlatformMac:        res = MacOSXVersionExe(HVr,LCSr);
      case kPlatformWindows32:  res = WindowsVersionExe(HVr,LCSr);
      case kPlatformWindows64:  res = WindowsVersionExe(HVr,LCSr);
      case kPlatformLinux32:    res = LinuxVersionExe(HVr,LCSr);
      case kPlatformLinux64:    res = LinuxVersionExe(HVr,LCSr);
      otherwise
        res = LinuxVersionExe(HVr,LCSr);
    end;
  end;

  VersionExe = res;
end;

function Boolean LastLogLineEquals(string logfile,string logstr)
begin
  Boolean testf;
  string 255 tstr;
  LongInt fsz,pos,blocklen;
  area part;

  if (FileExists(logfile)) then begin
    fsz = FileSize(logfile);
    blocklen = MIN(len(logstr)+2,fsz);
    pos = 0;
    if (fsz>blocklen) then begin
      pos = fsz - blocklen;
    end;
    LoadFileToArea(logfile,pos,blocklen,part);
    tstr = Trim(GetStringFromArea(part,0,blocklen));
    if (tstr==logstr) then begin
      testf = true;
    end;
  end;

  LastLogLineEquals = testf;
  return;
end;

function Boolean IsCloneFinished(record LocalCloudServerVc LCSr)
begin
  IsCloneFinished = LastLogLineEquals(LCSr.DataFolder & "/cloning.log","finished with cloning");
end;

function Boolean IsCloneUpToDate(record LocalCloudServerVc LCSr)
begin
  IsCloneUpToDate = LastLogLineEquals(LCSr.DataFolder & "/cloning.log","up to date");
end;

updating procedure UpdateServerStatus(var record LocalCloudServerVc LCSr,var record HansaVersionVc HVr)
begin
  LongInt svpid,newport;
  record LocalCloudServerVc OldLCSr;
  string 255 dbname,errmsg,hallogfile,oldhallogfile;
  Boolean hal_logfilef,hdb_existsf,hdb_lockedf,ok_versionf,pidfile_existsf,pid_is_runningf;
  Boolean ok_exef,ok_datafolderf;
  Boolean tcp_port_avail,http_port_avail,https_port_avail;
  Boolean slavesystemf,clonesystemf;
  string 255 tstr,port_conflicts;

  RecordCopy(OldLCSr,LCSr);

  if (LCSr.CurrentStatus==kStatusMoving) then begin
    if (LCSr.WantedStatus==kWantedStatusStop) then begin
      LCSr.CurrentStatus = kStatusStopped;
    end;
    goto LUpdateServerStatus;
  end;
  if (LCSr.WantedStatus==kWantedStatusMoveServer) then begin
    LCSr.CurrentSubStatus = kSubStatusNone;
    if (LCSr.CurrentStatus!=kStatusStopped) then begin
      LCSr.CurrentStatus = kStatusConfigInError;
      LCSr.StatusText = "Server must be stopped";
      goto LUpdateServerStatus;
    end;
    LCSr.CurrentStatus = kStatusMoving;
    goto LUpdateServerStatus;
  end;

  if (LCSr.ExecutableType==kExecutableTypeSlave or LCSr.ExecutableType==kExecutableTypeSlaveDebug or LCSr.ExecutableType==kExecutableTypeSlaveOptimizedDebug) then begin
    slavesystemf = true;
  end;
  if (LCSr.CloneFlag!=0) then begin
    clonesystemf = true;
  end;

  if (blank(LCSr.DataFolder)) then begin
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "No data folder specified";
    goto LUpdateServerStatus;
  end;

  if ((clonesystemf==false) and (slavesystemf==false) and (blank(LCSr.Port) or (LCSr.Port==0))) then begin
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "No port specified";
    goto LUpdateServerStatus;
  end;

  ok_datafolderf = DirExists(LCSr.DataFolder);

  hallogfile = LCSr.DataFolder & "/hal.log";
  oldhallogfile = hallogfile & ".old";
  hal_logfilef = FileExists(hallogfile);
  if (hal_logfilef and LCSr.CurrentStatus==kStatusConfigInError and
      ((LCSr.WantedStatus==kWantedStatusStop) or (LCSr.WantedStatus==kWantedStatusForceStop) or (LCSr.WantedStatus==kWantedStatusRestart))) then begin
    Delete_File(oldhallogfile);
    RenameFile(hallogfile,oldhallogfile);
    hal_logfilef = false;
  end;

  if (blank(LCSr.HansaVersion)) then begin
    ok_versionf = true; // Use process name as EXE name, EXE and HOBs from workdir
  end else begin
    ok_versionf = GetVersion(LCSr.HansaVersion,HVr);
    if (ok_versionf==false and HVr.CurrentState==kHansaVersionStateNotDownloaded) then begin
      if (IsDownloadingVersion(HVr.Code)==false or ShouldDownloadVersion(HVr.Code)==false) then begin
        DoDownloadVersion(HVr,false);
      end;
      goto LUpdateServerStatus;
    end;
  end;

  dbname = HDBFile(LCSr,HVr);

  hdb_existsf = FileExists(dbname);
  if (hdb_existsf) then begin
    hdb_lockedf = FileIsLocked(dbname);
  end;

  pidfile_existsf = FileExists(PidFile(LCSr));

  if (pidfile_existsf) then begin
    svpid = ReadLongFromFile(PidFile(LCSr));
    pid_is_runningf = PidIsRunning(svpid);
  end;

  if ((LCSr.WantedStatus==kWantedStatusStop) or (LCSr.WantedStatus==kWantedStatusForceStop)) then begin
    switch (LCSr.CurrentStatus) begin
      case kStatusUpdatingVersion:
        LCSr.CurrentStatus = kStatusStopped;
        LCSr.CurrentSubStatus = kSubStatusNone;
        LCSr.StatusText = "";
        goto LUpdateServerStatus;
    end;
  end;

  if ((LCSr.CurrentStatus!=kStatusUpdatingVersion) and (LCSr.CurrentStatus!=kStatusExportingDatabase) and (LCSr.CurrentStatus!=kStatusExportingRegister) and (LCSr.CurrentStatus!=kStatusExportingCompany)) then begin
    tcp_port_avail = true;
    http_port_avail = true;
    https_port_avail = true;
    if ((clonesystemf==false) and (slavesystemf==false)) then begin
      if (LCSr.Port>0) then begin
        if (TCPPortAvailable(LCSr.Port,LCSr.BindIP)==false) then begin
          tcp_port_avail = false;
          port_conflicts = LCSr.Port;
        end;
      end else begin
        tcp_port_avail = false;
      end;
      if (LCSr.HTTPPort>0) then begin
        if (TCPPortAvailable(LCSr.HTTPPort,LCSr.BindIP)==false) then begin
          http_port_avail = false;
          if (nonblank(port_conflicts)) then begin port_conflicts = port_conflicts & ", "; end;
          port_conflicts = port_conflicts & LCSr.HTTPPort;
        end;
      end;
      if (LCSr.HTTPSPort>0) then begin
        if (TCPPortAvailable(LCSr.HTTPSPort,LCSr.BindIP)==false) then begin
          https_port_avail = false;
          if (nonblank(port_conflicts)) then begin port_conflicts = port_conflicts & ", "; end;
          port_conflicts = port_conflicts & LCSr.HTTPSPort;
        end;
      end;
    end;
  end;

  if ((LCSr.WantedStatus==kWantedStatusCreateServer) or
      (LCSr.WantedStatus==kWantedStatusCreateStartedServer) or
      (LCSr.WantedStatus==kWantedStatusLaunchReserveSystem) or
      (LCSr.WantedStatus==kWantedStatusLaunchUpdateSystem) or
      (LCSr.WantedStatus==kWantedStatusLaunchTestSystem)) then begin
    if (ok_versionf==false) then begin
      LCSr.CurrentStatus = kStatusCreating;
      LCSr.StatusText = "Version not yet available at node";
      goto LUpdateServerStatus;
    end;
    if (ok_datafolderf==false) then begin
      LCSr.CurrentStatus = kStatusCreating;
      LCSr.StatusText = "Data folder missing";
      goto LUpdateServerStatus;
    end;
    LCSr.CurrentStatus = kStatusCreated;
    LCSr.StatusText = "";
    goto LUpdateServerStatus;
  end;

  tstr = VersionExe(HVr,LCSr,false);
  if (FileExists(tstr)==false) then begin
    if (nonblank(HVr.Code) and
        IsDownloadingVersion(HVr.Code)==false and
        ShouldDownloadVersion(HVr.Code)==false and
        HVr.CurrentState!=kHansaVersionStateInstalling) then begin
      LogText(0,"UpdateServerStatus: Version EXE missing (" & LCSr.UUID & ")");
      errmsg = "Version EXE missing: ";
      if (nonblank(tstr)) then begin
        errmsg = errmsg & tstr;
      end else begin
        errmsg = errmsg & "unknown type";
      end;
      LCSr.CurrentStatus = kStatusConfigInError;
      LCSr.CurrentSubStatus = kSubStatusNone;
    end else begin
      errmsg = "Version " & HVr.Code & " is being downloaded";
    end;
    LCSr.StatusText = errmsg;
    goto LUpdateServerStatus;
  end;

  if (ok_versionf==false) then begin
    LogText(0,"UpdateServerStatus: Version missing (" & LCSr.UUID & ")");
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "Version missing";
    goto LUpdateServerStatus;
  end;

  if (hal_logfilef) then begin
    LogText(0,"UpdateServerStatus: Fatal halcust/halpatch errors (" & LCSr.UUID & ")");
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "Fatal halcust/halpatch errors";
    goto LUpdateServerStatus;
  end;

  if (LCSr.CurrentStatus==kStatusUpdatingVersion) then begin
    if (LCSr.WantedSubStatus==kWantedSubStatusStopForExport) then begin
      if (pid_is_runningf) then begin
        LCSr.CurrentSubStatus = kSubStatusStopForExport;
        goto LUpdateServerStatus;
      end;
      if (hdb_lockedf) then begin
        LCSr.CurrentStatus = kStatusConfigInError;
        LCSr.CurrentSubStatus = kSubStatusNone;
        LCSr.StatusText = "Server HDB is locked but process is not running";
        goto LUpdateServerStatus;
      end;
      LCSr.CurrentSubStatus = kSubStatusStopForExportCompleted;
      goto LUpdateServerStatus;
    end;
    if (((LCSr.CurrentSubStatus==kSubStatusAfterImport) or
        (LCSr.CurrentSubStatus==kSubStatusStoppingSystemCopiesDuringUpdateCompleted) or
        (LCSr.CurrentSubStatus==kSubStatusSetCrontabAfterUpdateCompleted) or
        (LCSr.CurrentSubStatus==kSubStatusDBCopyBeforeUpdateCompleted)) and LCSr.WantedSubStatus==kWantedSubStatusNone) then begin  //must be wrong
      if (pid_is_runningf or (hdb_existsf==false and (LCSr.CloneFlag==0)) or hdb_lockedf) then begin
        LCSr.CurrentStatus = kStatusConfigInError;
        LCSr.CurrentSubStatus = kSubStatusNone;
        LCSr.StatusText = "Unknown error";
        if (hdb_lockedf) then begin
          LCSr.StatusText = "Server HDB is locked at the end of update";
        end;
        if (pid_is_runningf) then begin
          LCSr.StatusText = "Server is running at the end of update, expected it to be stopped";
        end;
        if (hdb_existsf==false and (LCSr.CloneFlag==0)) then begin
          LCSr.StatusText = "Server have no HDB at the end of update";
        end;
      end else begin
        LCSr.CurrentStatus = kStatusStopped;
        LCSr.CurrentSubStatus = kSubStatusNone;
      end;
    end;
    goto LUpdateServerStatus;
  end;

  if ((LCSr.CurrentStatus==kStatusConfigInError) and (LCSr.WantedStatus==kWantedStatusUpdateVersion)) then begin
    goto LUpdateServerStatus;
  end;

  if (((hdb_existsf==false) and (LCSr.CloneFlag==0)) and LCSr.WantedStatus==kWantedStatusUpdateVersion) then begin
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "HDB missing, version update can not start";
    goto LUpdateServerStatus;
  end;

  if ((hdb_lockedf==false) and (pid_is_runningf==false)) then begin
    if ((LCSr.WantedStatus!=kWantedStatusOnDemand) and
        (LCSr.WantedStatus!=kWantedStatusStop) and
        (LCSr.WantedStatus!=kWantedStatusForceStop) and
        (LCSr.WantedStatus!=kWantedStatusImportBackup) and
        (LCSr.WantedStatus!=kWantedStatusExportDatabase) and
        (LCSr.WantedStatus!=kWantedStatusImportBackupAndRun) and
        (LCSr.WantedStatus!=kWantedStatusExportCompany) and
        (LCSr.WantedStatus!=kWantedStatusResetToBackup) and
        (LCSr.WantedStatus!=kWantedStatusExportRegister)) then begin
      if ((LCSr.CurrentStatus!=kStatusUpdatingVersion) and
          (LCSr.CurrentStatus!=kStatusImportingBackup) and
          (LCSr.CurrentStatus!=kStatusImportedBackup) and
          (LCSr.CurrentStatus!=kStatusExportingDatabase) and
          (LCSr.CurrentStatus!=kStatusExportedDatabase) and
          (LCSr.CurrentStatus!=kStatusExportingRegister) and
          (LCSr.CurrentStatus!=kStatusExportedRegister) and
          (LCSr.CurrentStatus!=kStatusExportingCompany) and
          (LCSr.CurrentStatus!=kStatusExportedCompany) and
          (LCSr.CurrentStatus!=kStatusStopped) and
          (LCSr.CurrentStatus!=kStatusConfigInError)) then begin
        if (DateTimeDiffInSeconds(LCSr.LastStartDate,LCSr.LastStartTime,CurrentDate,CurrentTime)>2) then begin
          LCSr.QuickRestarts = LCSr.QuickRestarts + 1;
          LCSr.CurrentStatus = kStatusStopped;
        end;
      end;

      if (clonesystemf or slavesystemf) then begin
        if (LCSr.QuickRestarts>120) then begin
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "Server stopped within 5 minutes more than 120 times, check mother system";
          goto LUpdateServerStatus;
        end;
      end else begin
        if (LCSr.QuickRestarts>5) then begin
          LogText(0,"UpdateServerStatus: Server stopped more than 5 times within 5 minutes (" & LCSr.UUID & ")");
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "Server stopped within 5 minutes more than 5 times";
          goto LUpdateServerStatus;
        end;
      end;
      if (LCSr.CurrentStatus==kStatusStopped) then begin
        if (LCSr.WantedStatus==kWantedStatusUpdateVersion and LCSr.WantedSubStatus==kWantedSubStatusStopForExport) then begin
          LCSr.CurrentStatus = kStatusUpdatingVersion;
          LCSr.CurrentSubStatus = kSubStatusStopForExportCompleted;
        end;
        goto LUpdateServerStatus;
      end;
    end;

    if (LCSr.CurrentStatus==kStatusStarting) then begin
      if ((hdb_lockedf==false) or (pid_is_runningf==false)) then begin
        if (DateTimeDiffInSeconds(LCSr.LastStartDate,LCSr.LastStartTime,CurrentDate,CurrentTime)<5) then begin // give it 5s to start up
          goto LUpdateServerStatus;
        end;
      end;
    end;

    if (LCSr.WantedStatus==kWantedStatusUpdateVersion) then begin
      if (slavesystemf) then begin
        LCSr.CurrentStatus = kStatusConfigInError;
        LCSr.CurrentSubStatus = kSubStatusNone;
        LCSr.StatusText = "Version update requires the server to be running";
      end else begin // check kStatusConfigInError?
        LCSr.CurrentStatus = kStatusUpdatingVersion;
        LCSr.CurrentSubStatus = kSubStatusBeforeExport;
      end;
      LCSr.QuickRestarts = 0;
      goto LUpdateServerStatus;
    end;

    if ((LCSr.WantedStatus!=kWantedStatusExportDatabase) and
        (LCSr.WantedStatus!=kWantedStatusImportBackup) and
        (LCSr.WantedStatus!=kWantedStatusExportRegister) and
        (LCSr.WantedStatus!=kWantedStatusExportCompany) and
        (LCSr.WantedStatus!=kWantedStatusImportBackupAndRun) and
        (LCSr.WantedStatus!=kWantedStatusResetToBackup) and
        (LCSr.CurrentStatus!=kStatusConfigInError)) then begin
      if ((tcp_port_avail==false) and (clonesystemf==false) and (slavesystemf==false)) then begin
        LCSr.CurrentStatus = kStatusConfigInError;
        LCSr.CurrentSubStatus = kSubStatusNone;
        LCSr.StatusText = "TCP port " & LCSr.Port & " not available on interface " & LCSr.BindIP;
        goto LUpdateServerStatus;
      end;

      if ((clonesystemf==false) and (slavesystemf==false)) then begin
        if (http_port_avail==false) then begin
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "HTTP port " & LCSr.HTTPPort & " not available";
          goto LUpdateServerStatus;
        end;
    
        if (https_port_avail==false) then begin
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "HTTPS port " & LCSr.HTTPSPort & " not available";
          goto LUpdateServerStatus;
        end;
      end;
    end;

    switch (LCSr.WantedStatus) begin
      case kWantedStatusExportCompany:
        if (LCSr.CurrentStatus==kStatusExportingCompany) then begin
          LCSr.CurrentStatus = kStatusExportedCompany;
        end;
      case kWantedStatusExportCompany:
        if (LCSr.CurrentStatus==kStatusExportingCompany) then begin
          LCSr.CurrentStatus = kStatusExportedCompany;
        end;
      case kWantedStatusExportRegister:
        if (LCSr.CurrentStatus==kStatusExportingRegister) then begin
          LCSr.CurrentStatus = kStatusExportedRegister;
        end;
      case kWantedStatusExportDatabase:
        if (LCSr.CurrentStatus==kStatusExportingDatabase) then begin
          LCSr.CurrentStatus = kStatusExportedDatabase;
        end;
      case kWantedStatusImportBackup:
        if (LCSr.CurrentStatus==kStatusImportingBackup) then begin
          LCSr.CurrentStatus = kStatusImportedBackup;
        end;
      case kWantedStatusImportBackupAndRun:
        if (LCSr.CurrentStatus==kStatusImportingBackup) then begin
          LCSr.CurrentStatus = kStatusImportedBackup;
        end;
      case kWantedStatusResetToBackup:
        if (LCSr.CurrentStatus==kStatusImportingBackup) then begin
          LCSr.CurrentStatus = kStatusImportedBackup;
        end;
      otherwise
        LCSr.CurrentStatus = kStatusStopped;
    end;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "";
    goto LUpdateServerStatus;
  end;

  if (pidfile_existsf==false and 
     (LCSr.CurrentStatus!=kStatusExportingDatabase) and
     (LCSr.CurrentStatus!=kStatusExportingCompany) and
     (LCSr.CurrentStatus!=kStatusExportingRegister) and
     (LCSr.CurrentStatus!=kStatusImportingBackup) and
     (LCSr.CurrentStatus!=kStatusStopped) and
     (LCSr.CurrentStatus!=kStatusStarting) and
     (LCSr.CurrentStatus!=kStatusConfigInError)) then begin
    LogText(0,"UpdateServerStatus: pidfile missing (" & LCSr.UUID & ")");
    LCSr.CurrentStatus = kStatusConfigInError;
    LCSr.CurrentSubStatus = kSubStatusNone;
    LCSr.StatusText = "Pidfile missing";
    goto LUpdateServerStatus;
  end;
  
  if ((pid_is_runningf==false) and (hdb_lockedf==true)) then begin
    if (LCSr.CurrentStatus!=kStatusConfigInError) then begin
      LogText(0,"UpdateServerStatus: pid missing, but HDB locked");
      LCSr.CurrentStatus = kStatusConfigInError;
      LCSr.CurrentSubStatus = kSubStatusNone;
      LCSr.StatusText = "Process ID missing, but HDB locked";
    end;
    goto LUpdateServerStatus;
  end else begin
    if (LCSr.CurrentStatus==kStatusImportingBackup) then begin
      goto LUpdateServerStatus;
    end;
    if (LCSr.CurrentStatus==kStatusExportingDatabase) then begin
      goto LUpdateServerStatus;
    end;
    if (LCSr.CurrentStatus==kStatusExportingCompany) then begin
      goto LUpdateServerStatus;
    end;
    if (LCSr.CurrentStatus==kStatusExportingRegister) then begin
      goto LUpdateServerStatus;
    end;
  end;

  if ((pid_is_runningf==false) and (LCSr.CurrentStatus==kStatusConfigInError)) then begin
    goto LUpdateServerStatus;
  end;


  switch (LCSr.WantedStatus) begin
/* This should not be needed*/
    case kWantedStatusUpdateVersion:
      if (LCSr.CurrentStatus!=kStatusConfigInError) then begin
        LCSr.CurrentStatus = kStatusUpdatingVersion;
        LCSr.CurrentSubStatus = kSubStatusBeforeExport;
        LCSr.QuickRestarts = 0;
      end;
/**/
    case kWantedStatusMaintenence:
      LCSr.CurrentStatus = kStatusMaintenance;
    otherwise
      switch (LCSr.CloneFlag) begin
        case 1:
          if (IsCloneUpToDate(LCSr)==true) then begin
            LCSr.CurrentStatus = kStatusRunningReserve;
          end else begin
            LCSr.CurrentStatus = kStatusRunningPreparingReserve;
          end;
        case 2:
          if (IsCloneFinished(LCSr)==true) then begin
            LCSr.CurrentStatus = kStatusRunningTest;
          end else begin
            LCSr.CurrentStatus = kStatusRunningPreparingTest;
          end;
        case 3:
          if (IsCloneUpToDate(LCSr)==true) then begin
            LCSr.CurrentStatus = kStatusRunningUpdate;
          end else begin
            LCSr.CurrentStatus = kStatusRunningPreparingUpdate;
          end;
        otherwise
          if (OldLCSr.CurrentStatus!=kStatusRunning) then begin
            if (DirExists(JournalFolder(LCSr))==true) then begin
              LCSr.JournalPresentFlag = 1;
            end else begin
              LCSr.JournalPresentFlag = 0;
            end;
          end;
          LCSr.CurrentStatus = kStatusRunning;
      end;
      if (FileExists(IntentionalStopFile(LCSr))) then begin
        LCSr.CurrentStatus = kStatusRunningPendingStop;
      end;
      LCSr.CurrentSubStatus = kSubStatusNone;
  end;
  if (DateTimeDiff(CurrentDate,CurrentTime,LCSr.LastStartDate,LCSr.LastStartTime)>=2) then begin
    LCSr.QuickRestarts = 0;
  end;

LUpdateServerStatus:;
  if (LCSr.CurrentStatus!=kStatusConfigInError and
      LCSr.CurrentStatus!=kStatusCreating and
      LCSr.CurrentStatus!=kStatusUpdatingVersion) then begin
    LCSr.StatusText = "";
  end;

  if (((LCSr.CurrentStatus==kStatusConfigInError) or
      (LCSr.CurrentStatus==kStatusStarting) or
      (LCSr.CurrentStatus==kStatusUpdatingVersion)) and
      ((LCSr.WantedStatus==kWantedStatusStop) or (LCSr.WantedStatus==kWantedStatusForceStop) or (LCSr.WantedStatus==kWantedStatusRestart))) then begin
    LCSr.CurrentStatus = kStatusStopped;
    LCSr.CurrentSubStatus = kSubStatusNone;
  end;
  if (OldLCSr.CurrentStatus!=LCSr.CurrentStatus) then begin
    if (LCSr.CurrentStatus==kStatusStopped) then begin
      LCSr.LastStopDate = CurrentDate;
      LCSr.LastStopTime = CurrentTime;
    end;
  end;
  RecordUpdate(OldLCSr,LCSr,false);
  
  return;
end;

procedure DoStopExternalProcess(LongInt pid,Boolean forcef)
begin
  if (forcef) then begin
    ForceStopExternalProcess(pid);
  end else begin
    StopExternalProcess(pid);
  end;

  return;
end;

procedure StopServerIfNeeded(record LocalCloudServerVc LCSr,Boolean forcef)
begin
  LongInt pid;

  switch (LCSr.CurrentStatus) begin
    case kStatusConfigInError:
      // nothing
    case kStatusStopped:
      // nothing
    case kStatusRunningPreparingReserve:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningReserve:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningPreparingUpdate:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningUpdate:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningPreparingTest:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningTest:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunningPendingStop:
      if (LCSr.BackupOnStopFlag==1) then begin
        CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
        CreateFile(EnablerActionsFolder(LCSr) & "/EnBackupOnStop");
        CloseFile;
      end;
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusRunning:
      if (LCSr.BackupOnStopFlag==1) then begin
        CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
        CreateFile(EnablerActionsFolder(LCSr) & "/EnBackupOnStop");
        CloseFile;
      end;
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
    case kStatusStopping:
      StopAlert("Should check if force stop needed");
      // if too many force stops have been made, place "config in error"
    case kStatusStarting:
      //StopAlert("Should check if force stop needed");
      // if too many force stops have been made, place "config in error"
      // should wait a bit to begin with to let it start normally first
    case kStatusImportingBackup:
//      LogText(0,"Stopping server " & LCSr.UUID & " during initial import");
//      StopExternalProcess(ReadLongFromFile(PidFile(LCSr)));
    case kStatusMaintenance:
      pid = ReadLongFromFile(PidFile(LCSr));
      if (pid>0) then begin
        DoStopExternalProcess(pid,forcef);
      end;
  end;
  return;
end;


procedure MoveServerIfNeeded(record LocalCloudServerVc LCSr)
begin
  switch (LCSr.CurrentStatus) begin
    case kStatusNone:
      // nothing..
    case kStatusStopped:
      // nothing
    case kStatusRunning:
      // nothing
    case kStatusStopping:
      // nothing
    case kStatusStarting:
      // nothing
    case kStatusImportingBackup:
      // nothing
    case kStatusMoving:
      // nothing
    case kStatusCreated:
      // nothing
    case kStatusMaintenance:
      // nothing
    case kStatusRunningPendingStop:
      // nothing
  end;
  return;
end;

procedure CreateServerIfNeeded(record LocalCloudServerVc LCSr)
begin
  switch (LCSr.CurrentStatus) begin
    case kStatusCreating:
      CreateFolderHierarchy(LCSr.DataFolder);
    case kStatusConfigInError:
      // nothing
    case kStatusStopped:
      // nothing
    case kStatusRunning:
      // nothing
    case kStatusStopping:
      // nothing
    case kStatusStarting:
      // nothing
    case kStatusImportingBackup:
      // nothing
    case kStatusMaintenance:
      // nothing
    case kStatusRunningPendingStop:
      // nothing
  end;
  return;
end;

function string 255 VersionHOB(record HansaVersionVc HVr,record LocalCloudServerVc LCSr,Boolean forceverf)
begin
  string 255 res,tstr;

  if (blank(LCSr.HansaVersion) and !forceverf) then begin // Use process name as EXE name, EXE and HOBs from workdir
    res = LCSr.DataFolder & "/hob/";
  end else begin
    res = HVr.ProgramFolder & "/hob/";
  end;

  if ((left(res,1)!="/") and (left(res,1)!="\\") and (mid(res,1,2)!=":\\")) then begin
    tstr = ProgramFolder & "/" & res;
    res = tstr;
  end;

  VersionHOB = res;
end;

updating procedure DoStartServer(record LocalCloudServerVc LCSr,record HansaVersionVc HVr,Integer when)
begin
  string 255 exefil;
  string 255 workdir;
  string 255 hobflr;
  string 255 arglist;
  LongInt procflags;
  record LocalCloudServerVc OldLCSr;
  Integer i,rwcnt;
  row LocalCloudServerVc LCSrw;
  LongInt pos,pos2;
  string 255 tstr,server,fldr,user;
  Boolean clonef,clonedonef,hdb_existsf;
  Integer idx;
  string 255 hdbbakname,dbname;

  if (HVr.CurrentState==kHansaVersionStateNotDownloaded or
      HVr.CurrentState==kHansaVersionStateInstalling or
      ShouldDownloadVersion(HVr.Code) or
      IsDownloadingVersion(HVr.Code)) then begin
    goto LDoStartServer;
  end;

  LogText2(0,"DoStartServer LCSr.Name=" & LCSName(LCSr),kVerbosityDebug);

  procflags = 0;
  exefil = VersionExe(HVr,LCSr,false);
  hobflr = VersionHOB(HVr,LCSr,false);
  workdir = LCSr.DataFolder;
  
  dbname = HDBFile(LCSr,HVr);
  hdb_existsf = FileExists(dbname);
  if (hdb_existsf) then begin
    if (FileIsLocked(dbname)) then begin
      LogText2(0,"DoStartServer: Skipping start of '" & LCSName(LCSr) & "' because HDB is locked",kVerbosityDebug);
      goto LDoStartServer;
    end;
  end;

  // /Versions/54071217/HW/hansa-server --workdir /Servers/TEST --hobfolder /Versions/54071217/HW/hob/
  
  arglist = "--workdir \"" & workdir & "\"";
  arglist = arglist &  " --hobfolder \"" & hobflr & "\"";

  if ((HVr.Version>=81) and DirExists(workdir & "/halcust")==false and DirExists(workdir & "/halpatch")==false) then begin
    arglist = arglist &  " --ignore-linkcheck";
  end;

  if ((LCSr.WantedStatus!=kWantedStatusImportBackup) and
      (LCSr.WantedStatus!=kWantedStatusImportBackupAndRun) and
      (LCSr.WantedStatus!=kWantedStatusResetToBackup)) then begin
    if (LCSr.DisableHobcheck>0) then begin
      arglist = arglist &  " --disable-hobcheck";
    end;

    if (LCSr.WantedStatus==kWantedStatusMaintenence) then begin
      if (LCSr.MaintPort>0) then begin
        arglist = arglist & " --port " & LCSr.MaintPort;
      end;
    end else begin
      if (LCSr.Port>0) then begin
        arglist = arglist & " --port " & LCSr.Port;
      end;
    end;
    if (LCSr.HTTPPort>0) then begin
      arglist = arglist & " --httpport=" & LCSr.HTTPPort;
    end;
    
    if (LCSr.HTTPSPort>0) then begin
      arglist = arglist & " --httpsport=" & LCSr.HTTPSPort;
    end;
    
    if (LCSr.UUIDLock>0) then begin
      arglist = arglist & " --server-uuid=" & LCSr.UUID;
    end;
    
    if (LCSr.MassiveCacheMB>0) then begin
      arglist = arglist & " --db-cache=" & LCSr.MassiveCacheMB & "M";
    end;

    if (nonblank(LCSr.BackupFolder)) then begin
      arglist = arglist & " --timed-backup-dir=" & LCSr.BackupFolder;
    end;

    if (nonblank(LCSr.BackupTime)) then begin
      arglist = arglist & " --timed-backup-time=" & LCSr.BackupTime;
    end;

    if (nonblank(LCSr.PublicHostName)) then begin
      arglist = arglist & " --public-host-name=" & LCSr.PublicHostName;
    end;

    if ((LCSr.WebClientStartPort>0) and (LCSr.WebClientEndPort>0)) then begin
      arglist = arglist & " --webclientportrange " & LCSr.WebClientStartPort & " " & LCSr.WebClientEndPort;
    end;

    switch (LCSr.LogLevel) begin
      case 0: arglist = arglist & " --verbosity=debug-detailed";
      case 1: arglist = arglist & " --verbosity=debug";
      case 2: arglist = arglist & " --verbosity=verbose";
      case 3: arglist = arglist & " --verbosity=silent";
      otherwise
    end;
    
    if (LCSr.ExtraParameters<>"") then begin
      arglist = arglist & " " & LCSr.ExtraParameters;
    end;

    rwcnt = MatRowCnt(LCSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LCSr,i,LCSrw);
      if ((LCSrw.Item==kManagedServerItemParameters) and (LCSrw.Disabled==0) and
          ((LCSrw.When==when) or (LCSrw.When==kManagedServerWhenAlways) or ((LCSr.CloneFlag!=0) and (LCSrw.When==kManagedServerWhenUpdateImports)))) then begin
        arglist = arglist & " " & LCSrw.Data & " ";
      end;
      if (((LCSrw.Item==kManagedServerItemReserveSystem) or (LCSrw.Item==kManagedServerItemTestSystem) or (LCSrw.Item==kManagedServerItemUpdateSystem)) and
          (LCSrw.Disabled==0) and (clonef==false) and ((LCSrw.When==when) or (LCSrw.When==kManagedServerWhenAlways))) then begin
        clonef = true;
        arglist = arglist & " --enable-cloning " & LCSrw.Data & " ";
      end;
      if ((LCSrw.Item==kManagedServerItemMotherSystem) and (LCSrw.Disabled==0) and (LCSr.CloneFlag!=0) and
          ((LCSrw.When==when) or (LCSrw.When==kManagedServerWhenAlways))) then begin
        pos = 0;
        clonedonef = IsCloneFinished(LCSr);

        if ((LCSr.CloneFlag==1) or (LCSr.CloneFlag==3)) then begin
          arglist = arglist & " --clone ";
        end;

        if (LCSr.CloneFlag==2) then begin
          if (clonedonef==true) then begin goto LDoStartServer_SkipClone; end;

//          tstr = DetermineNextName(HDBFile(LCSr,HVr),false);
//          RenameFile(HDBFile(LCSr,HVr),tstr); // Maybe not only for test systems?
//          tstr = DetermineNextName(LCSr.DataFolder & "/cloning.log",false);
//          RenameFile(LCSr.DataFolder & "/cloning.log",tstr); // Maybe not only for test systems?

          arglist = arglist & " --finish-clone-when-up-to-date --clone ";
        end;
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        GetNextSubstring(tstr,pos2,"@",user);
        GetNextSubstring(tstr,pos2,"@",server);
        if (blank(server)) then begin
          server = user;
          user = "";
        end else begin
          user = user & "@";
        end;
        arglist = arglist & server & " ";
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        arglist = arglist & tstr & " ";
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        arglist = arglist & tstr & " ";
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        if (tstr!="0" and nonblank(tstr)) then begin
          GetNextSubstring(LCSrw.Data,pos,",",fldr);
          arglist = arglist & " --clone-attach " & user & server & " " & fldr & " ";
        end else begin
          GetNextSubstring(LCSrw.Data,pos,",",fldr); // Not used
        end;
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        if (tstr!="0" and nonblank(tstr)) then begin
          arglist = arglist & " --clone-other-files ";
        end;
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        if (tstr!="3" and nonblank(tstr)) then begin
          arglist = arglist & " --clone-halcust " & user & server & " " & fldr & " ";
          if (tstr=="1") then begin
            arglist = arglist & " --clone-halcust-folder=" & "newver." & LCSr.HansaVersion & "/halcust/ ";
          end;
        end;
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        if (tstr!="3" and nonblank(tstr)) then begin
          if (tstr=="1") then begin
            arglist = arglist & " --clone-halpatch-folder=" & "newver." & LCSr.HansaVersion & "/halpatch/ ";
          end;
        end;
        GetNextSubstring(LCSrw.Data,pos,",",tstr);
        if (tstr!="0" and tstr!="-1" and nonblank(tstr)) then begin
          arglist = arglist & " --db-cache=" & tstr & "M";
        end;
      end;
    end;

    if (LCSr.CloneFlag==0) then begin
      arglist = arglist & " --stop-cloning ";
    end;

LDoStartServer_SkipClone:;
    if (when==kManagedServerWhenExportingDatabase) then begin
      arglist = arglist & " --backup ";
    end;

    if (LCSr.CoreDump<>0) then begin
      procflags = procflags + kExtProcDumpCore;
    end;
  end;
  
  //arglist = arglist & " --with-controller";

  if ((LCSr.WantedStatus==kWantedStatusImportBackup) or
      (LCSr.WantedStatus==kWantedStatusImportBackupAndRun) or
      (LCSr.WantedStatus==kWantedStatusResetToBackup)) then begin
    if (LCSr.MassiveCacheMB>0) then begin
      arglist = arglist & " --db-cache=" & LCSr.MassiveCacheMB & "M";
    end;

    rwcnt = MatRowCnt(LCSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LCSr,i,LCSrw);
      if ((LCSrw.Item==kManagedServerItemParameters) and (LCSrw.Disabled==0) and
          ((LCSrw.When==when) or (LCSrw.When==kManagedServerWhenAlways))) then begin
        arglist = arglist & " " & LCSrw.Data & " ";
      end;
    end;

    switch (LCSr.LogLevel) begin
      case 0: arglist = arglist & " --verbosity=debug-detailed";
      case 1: arglist = arglist & " --verbosity=debug";
      case 2: arglist = arglist & " --verbosity=verbose";
      case 3: arglist = arglist & " --verbosity=silent";
      otherwise
    end;
    arglist = arglist & " --exit-after-import TBSETUP.TXT ";
  end;
  
  UpdateLCSEnablers(LCSr,when);

  if ((when==kManagedServerWhenExportingCompany) or
      (when==kManagedServerWhenExportingRegister) or
      (when==kManagedServerWhenUpdateImports)) then begin
    arglist = arglist & " " & LCSr.WantedStatusParams;
  end;

  if (LCSr.WantedStatus==kWantedStatusResetToBackup) then begin
    tstr = DetermineNextName(HDBFile(LCSr,HVr),false);
    LogText2(0,"Renaming " & HDBFile(LCSr,HVr) & " to " & tstr,kVerbosityDebugDetailed);
    RenameFile(HDBFile(LCSr,HVr),tstr);
    tstr = DetermineNextName(JournalFolder(LCSr),true);
    LogText2(0,"Renaming " & JournalFolder(LCSr) & " to " & tstr,kVerbosityDebugDetailed);
    MoveFile("/",JournalFolder(LCSr),tstr);
  end;

  if (LCSr.WantedStatus==kWantedStatusRunUnjournaled) then begin
    arglist = arglist & " --stop-journaling --i-know-this-is-dangerous";
  end;

  LogText2(0,"DoStartServer(): Starting " & exefil & " " & arglist & " ::: in folder " & workdir,kVerbosityDebug);
  StartExternalProcess(exefil,arglist,workdir,LCSr.ServerName,procflags);

  if ((LCSr.WantedStatus==kWantedStatusImportBackup) or
      (LCSr.WantedStatus==kWantedStatusImportBackupAndRun) or
      (LCSr.WantedStatus==kWantedStatusResetToBackup)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentStatus = kStatusImportingBackup;
    LCSr.LastStartDate = CurrentDate;
    LCSr.LastStartTime = CurrentTime;
    RecordUpdate(OldLCSr,LCSr,false);
    goto LDoStartServer;
  end;

  if ((LCSr.WantedStatus==kWantedStatusExportCompany)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentStatus = kStatusExportingCompany;
    LCSr.LastStartDate = CurrentDate;
    LCSr.LastStartTime = CurrentTime;
    RecordUpdate(OldLCSr,LCSr,false);
    goto LDoStartServer;
  end;

  if ((LCSr.WantedStatus==kWantedStatusExportRegister)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentStatus = kStatusExportingRegister;
    LCSr.LastStartDate = CurrentDate;
    LCSr.LastStartTime = CurrentTime;
    RecordUpdate(OldLCSr,LCSr,false);
    goto LDoStartServer;
  end;

  if ((LCSr.WantedStatus==kWantedStatusExportDatabase)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentStatus = kStatusExportingDatabase;
    LCSr.LastStartDate = CurrentDate;
    LCSr.LastStartTime = CurrentTime;
    RecordUpdate(OldLCSr,LCSr,false);
    goto LDoStartServer;
  end;

  if ((LCSr.CurrentStatus<>kStatusUpdatingVersion)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.CurrentStatus = kStatusStarting;
    LCSr.LastStartDate = CurrentDate;
    LCSr.LastStartTime = CurrentTime;
    RecordUpdate(OldLCSr,LCSr,false);
    goto LDoStartServer;
  end;

LDoStartServer:;
  return;
end;

updating procedure DoStopForExportIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  LongInt svpid;
  string 255 pidfilename;
  Boolean pidfile_existsf,pid_is_runningf;

  pidfilename = PidFile(LCSr);
  pidfile_existsf = FileExists(pidfilename);

  if (pidfile_existsf) then begin
    svpid = ReadLongFromFile(pidfilename);
    pid_is_runningf = PidIsRunning(svpid);
  end;

  if (pid_is_runningf) then begin
    StopExternalProcess(ReadLongFromFile(pidfilename));
  end;
return;
end;


updating procedure DoUpdateExportIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 exefil,workdir,hobflr;
  string 255 arglist,tstr;
  LongInt procflags;
  string 255 tbname,bktbname,bkfldr;
  record LocalCloudServerVc OldLCSr;
  Integer i,rwcnt;
  row LocalCloudServerVc LCSrw;
  string 255 pid_file;
  LongInt lpid;
  Boolean backupfoundf;

  if (LCSr.CurrentSubStatus==kSubStatusExportingCompleted) then begin
    goto LDoUpdateExportIfNeeded;
  end;

  if (LCSr.CurrentSubStatus==kSubStatusExporting) then begin
    backupfoundf = FileExists(LCSr.DataFolder & "/LCSUPDATE.TXT");
    ReadFirstMain(HVr,1,true);
    if (HVr.Version<72) then begin
      if (!backupfoundf and (HVr.Version>0) and (HVr.Version<71)) then begin
        tstr = "/TB";
        tstr = tstr & DateToString(CurrentDate,"YYMMDD");
        tstr = tstr & ".TXT";
        backupfoundf = FileExists(LCSr.DataFolder & tstr);
        if (!backupfoundf) then begin
          tstr = "/Backup/TB";
          tstr = tstr & DateToString(CurrentDate,"YYMMDD");
          tstr = tstr & ".TXT";
          backupfoundf = FileExists(LCSr.DataFolder & tstr);
        end;
      end;
    end;

    pid_file = PidFile(LCSr);
    //## move to own function, check progress exported during backup instead
    if (backupfoundf==true) then begin
      if (FileExists(pid_file)==false) then begin
        if (nonblank(tstr)) then begin
          CopyFile(LCSr.DataFolder & tstr,LCSr.DataFolder & "/LCSUPDATE.TXT");
        end;
        LCSr.CurrentSubStatus = kSubStatusExportingCompleted;
      end else begin
        lpid = ReadLongFromFile(pid_file);
        if (PidIsRunning(lpid)==false) then begin
// Check core files, check if export was successful
          if (nonblank(tstr)) then begin
            CopyFile(tstr,LCSr.DataFolder & "/LCSUPDATE.TXT");
          end;
          Delete_File(pid_file);
          if (LCSr.ExecutableType==kExecutableTypeSlave or LCSr.ExecutableType==kExecutableTypeSlaveDebug or LCSr.ExecutableType==kExecutableTypeSlaveOptimizedDebug) then begin // ugly, need to fix slave deleting pidfile on exit
            LCSr.CurrentSubStatus = kSubStatusExportingCompleted;
          end else begin
            LCSr.CurrentStatus = kStatusConfigInError;
            LCSr.CurrentSubStatus = kSubStatusNone;
            LCSr.StatusText = "Export failed, check log";
          end;
        end;
      end;
    end;
    goto LDoUpdateExportIfNeeded;
  end;
  
  procflags = 0;
  exefil = VersionExe(HVr,LCSr,false);
  hobflr = VersionHOB(HVr,LCSr,false);
  workdir = LCSr.DataFolder;
  if ((left(workdir,1)!="/") and (left(workdir,1)!="\\") and (mid(workdir,1,2)!=":\\")) then begin
    workdir = ProgramFolder & "/" & workdir;
  end;
  bkfldr = workdir & "/oldver." & LCSr.HansaVersion;  //## should have timestamp
  tbname = workdir & "/LCSUPDATE.TXT";
  bktbname = bkfldr & "/LCSUPDATE.TXT";

  CreateFolderHierarchy(bkfldr & "/");
  Delete_File(bktbname);
  RenameFile(tbname,bktbname);

  arglist = "--workdir \"" & workdir & "\"";
  arglist = arglist &  " --hobfolder \"" & hobflr & "\"";
  arglist = arglist &  " --disable-sip";
  arglist = arglist &  " --backup ";
  arglist = arglist &  " --backup-file=" & tbname;

  if ((HVr.Version<54) and (left(HVr.Code,3)=="HW_")) then begin
    // Override for old versions that doesn't work well with exe/hob in other folder than HDB
    CopyFile(exefil,LCSr.DataFolder & "/" & BaseName(exefil));
    CreateFolderHierarchy(LCSr.DataFolder & "/hob/");
    CopyFolder(hobflr,LCSr.DataFolder & "/hob/");
    exefil = LCSr.DataFolder & "/" & BaseName(exefil);
    arglist = "--workdir \"" & workdir & "\"";
    arglist = arglist &  " --backup ";
    arglist = arglist &  " --backup-file=" & tbname;
  end;

  switch (LCSr.LogLevel) begin
    case 0: arglist = arglist & " --verbosity=debug-detailed";
    case 1: arglist = arglist & " --verbosity=debug";
    case 2: arglist = arglist & " --verbosity=verbose";
    case 3: arglist = arglist & " --verbosity=silent";
    otherwise
  end;
  
  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LCSr,i,LCSrw);
    if ((LCSrw.Item==kManagedServerItemParameters) and (LCSrw.Disabled==0) and
        (LCSrw.When==kManagedServerWhenUpdateExports)) then begin
      arglist = arglist & " " & LCSrw.Data & " ";
    end;
  end;
  
  if (LCSr.CoreDump<>0) then begin
    procflags = procflags + kExtProcDumpCore;
  end;

  UpdateLCSEnablers(LCSr,kManagedServerWhenUpdateExports);

  LogText2(0,"DoUpdateExportIfNeeded(): Starting " & exefil & " " & arglist & " ::: in folder " & workdir,kVerbosityDebug);
  StartExternalProcess(exefil,arglist,workdir,LCSr.ServerName,procflags);
  
  RecordCopy(OldLCSr,LCSr);
  LCSr.CurrentSubStatus = kSubStatusExporting;
  RecordUpdate(OldLCSr,LCSr,false);

LDoUpdateExportIfNeeded:;
  return;
end;

updating procedure DoUpdateAfterExportIfNeeded(var record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 curname,bakname,newname,workdir,bkfldr,newfldr;
  record LocalCloudServerVc OldLCSr;
  record InternetEnablerBlock IEb;
  record CYBlock CYb;
  Boolean foundf;
  
  if (LCSr.CurrentSubStatus==kSubStatusAfterExport) then begin
    goto LDoUpdateAfterExportIfNeeded;
  end;

  workdir = LCSr.DataFolder;

  bkfldr = workdir & "/oldver." & LCSr.HansaVersion;  //## should have timestamp
  newfldr = workdir & "/newver." & LCSr.NewHansaVersion;
  curname = workdir & "/" & DatabaseName(HVr.ProgramType);
  bakname = bkfldr & "/" & DatabaseName(HVr.ProgramType);

  CreateFolderHierarchy(bkfldr & "/");
  Delete_File(bakname);
  RenameFile(curname,bakname);

  curname = workdir & "/journal";
  bakname = bkfldr & "/journal";
  DeleteFolder(bakname);
  RenameFile(curname,bakname);
  
  curname = workdir & "/halcust";
  bakname = bkfldr & "/halcust";
  newname = newfldr & "/halcust";
  switch (LCSr.HalcustUpdateRule) begin
    case kHalUpdateRuleUseUpdated:
      if (DirExists(bakname)) then begin
        DeleteFolder(bakname);
      end;
      RenameFile(curname,bakname);
      if (DirExists(newname)) then begin
        CopyFolder(newname,curname);
      end else begin
        //error? or pre-checks only?
      end;
    case kHalUpdateRuleDoNotUse:
      if (DirExists(bakname)) then begin
        DeleteFolder(bakname);
      end;
      RenameFile(curname,bakname);
  end;
  
  curname = workdir & "/halpatch";
  bakname = bkfldr & "/halpatch";
  newname = newfldr & "/halpatch";
  switch (LCSr.HalpatchUpdateRule) begin
    case kHalUpdateRuleUseUpdated:
      if (DirExists(bakname)) then begin
        DeleteFolder(bakname);
      end;
      RenameFile(curname,bakname);
      if (DirExists(newname)) then begin
        CopyFolder(newname,curname);
      end else begin
        //error? or pre-checks only?
      end;
    case kHalUpdateRuleDoNotUse:
      if (DirExists(bakname)) then begin
        DeleteFolder(bakname);
      end;
      RenameFile(curname,bakname);
  end;

  //RecordCopy(OldLCSr,LCSr);

  if (LCSr.MigrationFlag==1) then begin
    if (FileExists(workdir & "/TBSETUP.TXT")) then begin
      ReadCompanyInfoBlocksFromTB(workdir & "/TBSETUP.TXT",IEb,CYb);
      foundf = true;
    end else begin
      if (FileExists(workdir & "/LCSUPDATE.TXT")) then begin
        ReadCompanyInfoBlocksFromTB(workdir & "/LCSUPDATE.TXT",IEb,CYb);
        foundf = true;
      end;
    end;
    if (foundf) then begin
      LCSr.CUCode = IEb.CustomerCode;
      LCSr.Contract = IEb.Contract;
      LCSr.Name = CYb.CompName;
      LCSr.OrgNr = CYb.OrgNr;
      LCSr.VATNr = CYb.VATNr;
      LCSr.OrgNr2 = CYb.OrgNr2;
      if (LCSr.ServerName=="hansa-migratedserver" and nonblank(LCSr.CUCode)) then begin
        LCSr.ServerName = "hansa-migratedserver-" & LCSr.CUCode;
      end;
      LCSr.MigrationFlag = 0;
    end;
  end;

  LCSr.CurrentSubStatus = kSubStatusAfterExport;
  //RecordUpdate(OldLCSr,LCSr,false);
  
LDoUpdateAfterExportIfNeeded:;
  return;
end;


updating procedure DoUpdateImportIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 exefil,workdir,hobflr;
  string 255 arglist;
  LongInt procflags;
  record LocalCloudServerVc OldLCSr;
  record HansaVersionVc HV2r;
  Integer i,rwcnt;
  row LocalCloudServerVc LCSrw;

  if (LCSr.CurrentSubStatus==kSubStatusImportingCompleted) then begin
    goto LDoUpdateImportIfNeeded;
  end;

  if (LCSr.CurrentSubStatus==kSubStatusImporting) then begin
    //## move to own function, check progress exported during backup instead
    if (FileExists(LCSr.DataFolder & "/LCSUPDATE.TXT")==true) then begin
      if (FileExists(PidFile(LCSr))==false) then begin
        LCSr.CurrentSubStatus = kSubStatusImportingCompleted;
      end;
    end;
    goto LDoUpdateImportIfNeeded;
  end;

  if (GetVersion(LCSr.NewHansaVersion,HV2r)==false) then begin
    LogText(0,"Update paused because version " & LCSr.NewHansaVersion & " isn't available.");
    goto LDoUpdateImportIfNeeded;
  end;

  procflags = 0;
  exefil = VersionExe(HV2r,LCSr,true);
  hobflr = VersionHOB(HV2r,LCSr,true);
  workdir = LCSr.DataFolder;
  
  arglist = "--workdir \"" & workdir & "\"";
  arglist = arglist & " --hobfolder \"" & hobflr & "\"";
  arglist = arglist & " --exit-after-import";
  arglist = arglist & " --disable-sip";

  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LCSr,i,LCSrw);
    if ((LCSrw.Item==kManagedServerItemParameters) and (LCSrw.Disabled==0) and
        (LCSrw.When==kManagedServerWhenUpdateImports)) then begin
      arglist = arglist & " " & LCSrw.Data & " ";
    end;
  end;

  if (LCSr.CoreDump<>0) then begin
    procflags = procflags + kExtProcDumpCore;
  end;

  arglist = arglist & " " & LCSr.WantedStatusParams;

  arglist = arglist & " LCSUPDATE.TXT";

  UpdateLCSEnablers(LCSr,kManagedServerWhenUpdateImports);
//  LogText(0,"DoUpdateImportIfNeeded(): Starting " & exefil & " " & arglist & " ::: in folder " & workdir);
  StartExternalProcess(exefil,arglist,workdir,LCSr.ServerName,procflags);
  
  RecordCopy(OldLCSr,LCSr);
  LCSr.CurrentSubStatus = kSubStatusImporting;
  RecordUpdate(OldLCSr,LCSr,false);

LDoUpdateImportIfNeeded:;
  return;
end;

updating procedure DoUpdateAfterImportIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 curname,bakname,newname,workdir,bkfldr,newfldr;
//  record LocalCloudServerVc OldLCSr;
  record HansaVersionVc HV2r;

  if (LCSr.CurrentSubStatus==kSubStatusAfterImport) then begin
    goto LDoUpdateAfterImportIfNeeded;
  end;
  
  if (GetVersion(LCSr.NewHansaVersion,HV2r)==false) then begin
    goto LDoUpdateAfterImportIfNeeded;
  end;

  workdir = LCSr.DataFolder;
  bkfldr = workdir & "/oldver." & LCSr.HansaVersion;  //## should have timestamp
  newfldr = workdir & "/newver." & LCSr.NewHansaVersion;
  curname = workdir & "/updateclients";
  bakname = bkfldr & "/updateclients";
  newname = newfldr & "/updateclients";

  CreateFolderHierarchy(bkfldr & "/");
  if (DirExists(bakname)) then begin
    DeleteFolder(bakname);
  end;
  RenameFile(curname,bakname);
  if (DirExists(newname)) then begin
    CopyFolder(newname,curname);
  end;

  LCSr.OldHansaVersion = LCSr.HansaVersion;
  LCSr.HansaVersion = LCSr.NewHansaVersion;
  LCSr.NewHansaVersion = "";
  LCSr.CurrentSubStatus = kSubStatusAfterImport;

LDoUpdateAfterImportIfNeeded:;
  return;
end;


updating procedure DoUpdateSystemCopyIfNeeded(var record LocalCloudServerVc LCSr,record HansaVersionVc HVr,LongInt when)
begin
  Integer i,rwcnt;
  record LocalCloudServerVc OldLCS2r;
  record LocalCloudServerVc LCS2r;
  row LocalCloudServerVc LCSrw;
  string 255 script,hdbcopyscript,rmscript,syncscript;
  string 255 lockfile,donefile,dbname;
  LongInt lpid;
  Boolean foundf,completedf;

  dbname = DatabaseName(HVr.ProgramType);

  if (LCSr.CurrentSubStatus==kSubStatusSystemCopyBeforeUpdateCompleted) then begin
    goto LDoUpdateAfterSystemCopyIfNeeded;
  end;
  if (LCSr.CurrentSubStatus==kSubStatusSystemCopyDuringUpdateCompleted) then begin
    goto LDoUpdateAfterSystemCopyIfNeeded;
  end;

  completedf = true;

  switch (when) begin
    case kManagedServerWhenUpdateBegins:  lockfile = LCSr.DataFolder & "/CCSystemCopyUB";
    case kManagedServerWhenUpdating:      lockfile = LCSr.DataFolder & "/CCSystemCopyU";
  end;
  donefile = lockfile & "Completed";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      completedf = false;
      goto LDoUpdateAfterSystemCopyIfNeeded;
    end else begin
      Delete_File(lockfile);
      if (FileExists(donefile)) then begin
        Delete_File(donefile);
        switch (when) begin
          case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSystemCopyBeforeUpdateCompleted;
          case kManagedServerWhenUpdating:      LCSr.CurrentSubStatus = kSubStatusSystemCopyDuringUpdateCompleted;
        end;
      end else begin
        if (lpid>=1) then begin
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "System copy before update failed";
          completedf = false;
        end;
      end;
      goto LDoUpdateAfterSystemCopyIfNeeded;
    end;
  end;

  if (FileExists(donefile)) then begin Delete_File(donefile); end;

  script = "touch " & lockfile & "; ionice -c 3 bash -c '( echo -n $$ >>" & lockfile & ";";

  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    foundf = false;
    MatRowGet(LCSr,i,LCSrw);
    if ((LCSrw.Item==kManagedServerItemSystemCopy) and (LCSrw.Disabled==0)) then begin
      LCS2r.UUID = StringToUUID(LCSrw.ItemName);
      if (ReadFirstMain(LCS2r,1,true)) then begin foundf = true; end;
    end;

    if (foundf==false) then begin goto LDoUpdateAfterSystemCopyIfNeeded_Next; end;

    rmscript = "";
    syncscript = "";
    hdbcopyscript = "";

    if (when==kManagedServerWhenUpdateBegins) then begin
      syncscript = "rsync -avx --delete";
      syncscript = syncscript & " --exclude=\"LCSUPDATE*\" ";
      syncscript = syncscript & " --exclude=\"*.HDB*\" ";
      syncscript = syncscript & " --exclude=\"core*\" ";
      syncscript = syncscript & " --exclude=\"Attach\" ";
      syncscript = syncscript & " --exclude=\"Backup\" ";
      syncscript = syncscript & " --exclude=\"tmp\" ";
      syncscript = syncscript & " --exclude=\"*.pid\" ";
      syncscript = syncscript & " --exclude=\"*.log*\" ";
      syncscript = syncscript & " --exclude=\"*.tmp*\" ";
      syncscript = syncscript & " --exclude=\"journal*\" ";
      syncscript = syncscript & " --exclude=\"old_logs\" ";
      syncscript = syncscript & " --exclude=\"HM20??????\" ";
      syncscript = syncscript & " --exclude=\"EnablerActions\" ";
      syncscript = syncscript & " --exclude=\"TB*TXT*\" ";
      syncscript = syncscript & " --exclude=\"webclients\" ";
      syncscript = syncscript & " --exclude=\"hob*\" ";
      syncscript = syncscript & " --exclude=\"CC*\" ";
      syncscript = syncscript & " --exclude=\"oldver*\" ";
      syncscript = syncscript & " --exclude=\"newver*\" ";
      syncscript = syncscript & " --exclude=\"HREXPORTS*\" ";
      syncscript = syncscript & " --exclude=\"TRADEBOOKS*\" ";
      syncscript = syncscript & " --exclude=\"halcust?*\" ";
      syncscript = syncscript & " --exclude=\"halpatch?*\" ";
      syncscript = syncscript & " --exclude=\"hansa-*\" ";
      syncscript = syncscript & " --exclude=\"nohup.out*\" ";
      syncscript = syncscript & " --exclude=\"*.zip*\" ";
      syncscript = syncscript & " --exclude=\"*.tgz*\" ";
      syncscript = syncscript & " --exclude=\"*.gz\" ";
      syncscript = syncscript & " --exclude=\"downloadupdateclients*\" ";
      syncscript = syncscript & " --exclude=\"amain*\" ";
      syncscript = syncscript & " --exclude=\"appcatalog*\" ";
      syncscript = syncscript & " --exclude=\"webclient?*\" ";
      syncscript = syncscript & " --exclude=\"BI\" ";
      syncscript = syncscript & LCSr.DataFolder & "/ ";
      syncscript = syncscript & LCS2r.DataFolder & "/ ";
      syncscript = syncscript & ";";
      switch (LCSrw.When) begin
        case kManagedServerWhenUpdateBegins:
          rmscript = "rm -rf ";
          rmscript = rmscript & LCS2r.DataFolder & "/*.log ";
          rmscript = rmscript & LCS2r.DataFolder & "/downloadupdateclients ";
          rmscript = rmscript & LCS2r.DataFolder & "/journal ";
          rmscript = rmscript & LCS2r.DataFolder & "/webclients ";
          rmscript = rmscript & ";";
          hdbcopyscript = "mv -f " & LCSr.DataFolder & "/" & dbname & ".COPY " & LCS2r.DataFolder & "/" & dbname & " ;";
        case kManagedServerWhenUpdating:
          rmscript = "rm -rf ";
          rmscript = rmscript & LCS2r.DataFolder & "/" & dbname & ".OLD ";
          rmscript = rmscript & LCS2r.DataFolder & "/journal.old ";
          rmscript = rmscript & LCS2r.DataFolder & "/*.log ";
          rmscript = rmscript & LCS2r.DataFolder & "/downloadupdateclients ";
          rmscript = rmscript & LCS2r.DataFolder & "/webclients ";
          rmscript = rmscript & ";";
          rmscript = rmscript & "mv -f " & LCS2r.DataFolder & "/" & dbname & " " & LCS2r.DataFolder & "/" & dbname & ".OLD ;";
          rmscript = rmscript & "mv -f " & LCS2r.DataFolder & "/journal " & LCS2r.DataFolder & "/journal.old ;";
      end;

      RecordCopy(OldLCS2r,LCS2r);
      LCS2r.HansaVersion = LCSr.HansaVersion;
      RecordUpdate(OldLCS2r,LCS2r,true);
    end;

    if (when==kManagedServerWhenUpdating) then begin
      switch (LCSrw.When) begin
        case kManagedServerWhenUpdateBegins:
        case kManagedServerWhenUpdating:
          hdbcopyscript = "cp -f " & LCSr.DataFolder & "/" & dbname & " " & LCS2r.DataFolder & "/" & dbname & " ;";
      end;

      RecordCopy(OldLCS2r,LCS2r);
      LCS2r.HansaVersion = LCSr.HansaVersion;
      RecordUpdate(OldLCS2r,LCS2r,true);
    end;

    if (when==kManagedServerWhenUpdateEnds) then begin
      RecordCopy(OldLCS2r,LCS2r);
      LCS2r.OldHansaVersion = LCS2r.HansaVersion;
      LCS2r.HansaVersion = LCSr.NewHansaVersion;
      RecordUpdate(OldLCS2r,LCS2r,true);
    end;

    if (nonblank(rmscript) or nonblank(syncscript) or nonblank(hdbcopyscript)) then begin
      completedf = false;
    end;

    script = script & rmscript;
    script = script & syncscript;
    script = script & hdbcopyscript;

LDoUpdateAfterSystemCopyIfNeeded_Next:;
  end;

  script = script & "touch " & donefile & ";";
  script = script & " )' &";

  if (completedf==false) then begin
    RunShellScript(script);
    if (FileExists(lockfile)) then begin
      switch (when) begin
        case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSystemCopyBeforeUpdate;
        case kManagedServerWhenUpdating:      LCSr.CurrentSubStatus = kSubStatusSystemCopyDuringUpdate;
      end;
    end else begin
      LogText(0,"System Copy script failed to start");
      LCSr.CurrentStatus = kStatusConfigInError;
      LCSr.CurrentSubStatus = kSubStatusNone;
      LCSr.StatusText = "System copy script failed to start";
    end;
  end else begin
    switch (when) begin
      case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSystemCopyBeforeUpdateCompleted;
      case kManagedServerWhenUpdating:      LCSr.CurrentSubStatus = kSubStatusSystemCopyDuringUpdateCompleted;
    end;
  end;
LDoUpdateAfterSystemCopyIfNeeded:;
end;

updating procedure DoUpdateSetCrontabIfNeeded(var record LocalCloudServerVc LCSr,record HansaVersionVc HVr,LongInt when)
begin
  Integer i,rwcnt;
  row LocalCloudServerVc LCSrw;
  string 255 script;
  string 255 lockfile,donefile;
  LongInt lpid;
  Boolean completedf,enablef;

  if (LCSr.CurrentSubStatus==kSubStatusSetCrontabBeforeUpdateCompleted) then begin
    goto LDoUpdateSetCrontabIfNeeded;
  end;
  if (LCSr.CurrentSubStatus==kSubStatusSetCrontabAfterUpdateCompleted) then begin
    goto LDoUpdateSetCrontabIfNeeded;
  end;

  completedf = true;

  switch (when) begin
    case kManagedServerWhenUpdateBegins: lockfile = LCSr.DataFolder & "/CCSetCrontabUB";
    case kManagedServerWhenUpdateEnds:   lockfile = LCSr.DataFolder & "/CCSetCrontabUE";
  end;
  donefile = lockfile & "Completed";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      goto LDoUpdateSetCrontabIfNeeded;
    end else begin
      Delete_File(lockfile);
      if (FileExists(donefile)) then begin
        Delete_File(donefile);
        switch (when) begin
          case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSetCrontabBeforeUpdateCompleted;
          case kManagedServerWhenUpdateEnds:    LCSr.CurrentSubStatus = kSubStatusSetCrontabAfterUpdateCompleted;
        end;
      end else begin
        if (lpid>=1) then begin
          LCSr.CurrentStatus = kStatusConfigInError;
          LCSr.CurrentSubStatus = kSubStatusNone;
          LCSr.StatusText = "Set crontab failed";
        end;
      end;
      goto LDoUpdateSetCrontabIfNeeded;
    end;
  end;

  if (FileExists(donefile)) then begin Delete_File(donefile); end;

  script = "touch " & lockfile & "; bash -c '( echo -n $$ >>" & lockfile & ";";
  script = script & "crontab -l |sed \"";

  rwcnt = MatRowCnt(LCSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LCSr,i,LCSrw);
    if ((LCSrw.Item==kManagedServerItemCrontabEntry) and (nonblank(LCSrw.Data)) and
        (LCSrw.When==kManagedServerWhenUpdating)) then begin
      enablef = false;
      if (when==kManagedServerWhenUpdateEnds) then begin enablef = true; end;
      if (((LCSrw.Disabled==0) and (enablef==false)) or
          ((LCSrw.Disabled!=0) and (enablef==true))) then begin
        script = script & "s/^#CCDISABLED#\\(.*\\/" & LCSrw.Data & "\\)/\\1/ ;";
      end else begin
        script = script & "s/^#CCDISABLED#\\(.*\\/" & LCSrw.Data & "\\)/\\1/ ;";
        script = script & "s/\\(.*\\/" & LCSrw.Data & "\\)/#CCDISABLED#\\1/ ;";
      end;
      completedf = false;
    end;
  end;

  script = script & "\" |crontab - ;";
  script = script & "touch " & donefile & ";";
  script = script & " )' &";

  if (completedf==false) then begin
    RunShellScript(script);
    if (FileExists(lockfile)) then begin
      switch (when) begin
        case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSetCrontabBeforeUpdate;
        case kManagedServerWhenUpdateEnds:    LCSr.CurrentSubStatus = kSubStatusSetCrontabAfterUpdate;
      end;
    end else begin
      LogText(0,"Crontab script failed to start");
      LCSr.CurrentStatus = kStatusConfigInError;
      LCSr.CurrentSubStatus = kSubStatusNone;
      LCSr.StatusText = "Crontab script failed to start";
    end;
  end else begin
    switch (when) begin
      case kManagedServerWhenUpdateBegins:  LCSr.CurrentSubStatus = kSubStatusSetCrontabBeforeUpdateCompleted;
      case kManagedServerWhenUpdateEnds:    LCSr.CurrentSubStatus = kSubStatusSetCrontabAfterUpdateCompleted;
    end;
  end;

LDoUpdateSetCrontabIfNeeded:;
end;


updating procedure DoUpdateDBCopyBeforeUpdateIfNeeded(var record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 dbname,dbcopyname;

  if (LCSr.CurrentSubStatus==kSubStatusDBCopyBeforeUpdateCompleted) then begin
    goto LDoUpdateDBCopyBeforeUpdateIfNeeded;
  end;

  if (LCSr.CurrentSubStatus==kSubStatusDBCopyBeforeUpdate) then begin
    if (FileExists(EnablerActionsFolder(LCSr) & "/EnDoDBCopy")==false) then begin
      LCSr.CurrentSubStatus = kSubStatusDBCopyBeforeUpdateCompleted;
    end;
    goto LDoUpdateDBCopyBeforeUpdateIfNeeded;
  end;

  if (LCSr.CurrentSubStatus!=kSubStatusDBCopyBeforeUpdate) then begin
    dbname = DatabaseName(HVr.ProgramType);
    dbcopyname = dbname & ".COPY";
    if (FileExists(dbcopyname)==false) then begin
      CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
      CreateFile(EnablerActionsFolder(LCSr) & "/EnDoDBCopy");
      CloseFile;
      LCSr.CurrentSubStatus = kSubStatusDBCopyBeforeUpdate;
    end else begin
      LCSr.CurrentSubStatus = kSubStatusDBCopyBeforeUpdateCompleted;
    end;
  end;

LDoUpdateDBCopyBeforeUpdateIfNeeded:;
end;


updating procedure DoCloudServerVersionUpdate(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  record LocalCloudServerVc OldLCSr;

  RecordCopy(OldLCSr,LCSr);

  switch (LCSr.WantedSubStatus) begin
    case kWantedSubStatusBeforeExport:
      //nothing
    case kWantedSubStatusSetCrontabBeforeUpdate:
      DoUpdateSetCrontabIfNeeded(LCSr,HVr,kManagedServerWhenUpdateBegins);
    case kWantedSubStatusDBCopyBeforeUpdate:
      DoUpdateDBCopyBeforeUpdateIfNeeded(LCSr,HVr);
    case kWantedSubStatusSystemCopyBeforeUpdate:
      DoUpdateSystemCopyIfNeeded(LCSr,HVr,kManagedServerWhenUpdateBegins);
    case kWantedSubStatusStopForExport:
      DoStopForExportIfNeeded(LCSr,HVr);
    case kWantedSubStatusStopSlaveSystems:
      if (LCSr.CurrentSubStatus!=kSubStatusStoppingSlaveSystemsCompleted) then begin
        LCSr.CurrentSubStatus = kSubStatusStoppingSlaveSystems;
      end;
    case kWantedSubStatusStartSystemCopiesBeforeExport:
      if (LCSr.CurrentSubStatus!=kSubStatusStartingSystemCopiesBeforeExportCompleted) then begin
        LCSr.CurrentSubStatus = kSubStatusStartingSystemCopiesBeforeExport;
      end;
    case kWantedSubStatusSystemCopyDuringUpdate:
      DoUpdateSystemCopyIfNeeded(LCSr,HVr,kManagedServerWhenUpdating);
    case kWantedSubStatusStartSystemCopiesDuringUpdate:
      if (LCSr.CurrentSubStatus!=kSubStatusStartingSystemCopiesDuringUpdateCompleted) then begin
        LCSr.CurrentSubStatus = kSubStatusStartingSystemCopiesDuringUpdate;
      end;
    case kWantedSubStatusExport:
      DoUpdateExportIfNeeded(LCSr,HVr);
    case kWantedSubStatusAfterExport:
      DoUpdateAfterExportIfNeeded(LCSr,HVr);
    case kWantedSubStatusImport:
      DoUpdateImportIfNeeded(LCSr,HVr);
    case kWantedSubStatusAfterImport:
      DoUpdateAfterImportIfNeeded(LCSr,HVr);
    case kWantedSubStatusStopSystemCopiesDuringUpdate:
      if (LCSr.CurrentSubStatus!=kSubStatusStoppingSystemCopiesDuringUpdateCompleted) then begin
        LCSr.CurrentSubStatus = kSubStatusStoppingSystemCopiesDuringUpdate;
      end;
    case kWantedSubStatusSetCrontabAfterUpdate:
      DoUpdateSetCrontabIfNeeded(LCSr,HVr,kManagedServerWhenUpdateEnds);
  end;

  RecordUpdate(OldLCSr,LCSr,false);

  return;
end;


updating procedure StartServerIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  LongInt when;

  LogText2(0,"StartServerIfNeeded LCSr.Name=" & LCSName(LCSr) & ", LCSr.CurrentStatus=" & StatusName(LCSr.CurrentStatus),kVerbosityDebugDetailed);

  switch (LCSr.CurrentStatus) begin
    case kStatusConfigInError:
      // nothing
    case kStatusCreated:
      when = kManagedServerWhenRunningNormally;
      if (LCSr.WantedStatus==kWantedStatusImportBackup) then begin
        when = kManagedServerWhenRunningNormally; // TODO: add option for importing
      end;
      if (LCSr.WantedStatus==kWantedStatusImportBackupAndRun) then begin
        when = kManagedServerWhenRunningNormally; // TODO: add option for importing
      end;
      if (LCSr.WantedStatus==kWantedStatusResetToBackup) then begin
        when = kManagedServerWhenRunningNormally; // TODO: add option for importing
      end;
      DoStartServer(LCSr,HVr,when);
    case kStatusStopped:
      when = kManagedServerWhenRunningNormally;
      if (LCSr.WantedStatus==kWantedStatusExportDatabase) then begin
        when = kManagedServerWhenExportingDatabase;
      end;
      if (LCSr.WantedStatus==kWantedStatusExportCompany) then begin
        when = kManagedServerWhenExportingCompany;
      end;
      if (LCSr.WantedStatus==kWantedStatusExportRegister) then begin
        when = kManagedServerWhenExportingRegister;
      end;
      DoStartServer(LCSr,HVr,when);
    case kStatusRunning:
      // nothing
    case kStatusStopping:
      StopAlert("Should check if force stop needed to speed up start");
      // if too many force stops have been made, place "config in error"
    case kStatusStarting:
    case kStatusImportingBackup:
      // nothing
    case kStatusMaintenance:
      // nothing
    case kStatusRunningPendingStop:
      // nothing
  end;
  return;
end;

updating procedure UpdateVersionIfNeeded(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  record LocalCloudServerVc OldLCSr;

  switch (LCSr.CurrentStatus) begin
    case kStatusConfigInError:
    case kStatusStopped:
    case kStatusRunning:
    case kStatusStopping:
    case kStatusStarting:
    case kStatusImportingBackup:
    case kStatusUpdatingVersion:
      DoCloudServerVersionUpdate(LCSr,HVr);
    case kStatusMaintenance:
    case kStatusRunningPendingStop:
  end;

  return;
end;

global
updating procedure ImportKnownSessions(string known_sessions,var array string usrarr,var array string datearr,var array string timearr,var array string evtarr,var array string argarr)
begin
  Boolean moref;
  Boolean oldwrwi;
  Integer obv;

  obv = SetBackupVerbosity(kBackupVerbositySilent);
  oldwrwi = SetWebRequestsWhileImporting(true);
  OpenFile(known_sessions);
  moref = !TestEOF;
  while (moref) begin
    usrarr[usrarr.length] = ImportField;
    datearr[datearr.length] = ImportField;
    timearr[timearr.length] = ImportField;
    evtarr[evtarr.length] = ImportField;
    argarr[argarr.length] = ImportField;
    moref = NextImportLine(true);
  end;
  CloseFile;
  SetWebRequestsWhileImporting(oldwrwi);
  ResetBackupVerbosity(obv);
  return;
end;

function Boolean IsMinutesPastCurrentTime(date dt,time tm,Integer mins)
begin
  Boolean res;
  time tm2;

  tm2 = AddMinutes(tm,mins);
  if (AddDay(dt,1)==CurrentDate) then begin
    if (tm2<tm) then begin
      if (tm2<CurrentTime) then begin
        res = true;
      end;
    end else begin
      res = true;
    end;
  end else begin
    if (dt!=CurrentDate) then begin
      res = true;
    end else begin
      if (tm2>tm) then begin
        if (tm2<CurrentTime) then begin
          res = true;
        end;
      end;
    end;
  end;
  IsMinutesPastCurrentTime = res;
  return;
end;

global
procedure ActiveServerUsers(record LocalCloudServerVc LCSr,Boolean keepstartupf,var LongInt res)
begin
  LongInt l,lcnt;
  string 255 known_sessions,tstr;
  date last_entry_date;
  time last_entry_time,t2;
  array string 255 userarr,userarr2;
  Integer i;
  Boolean foundf;
  string 255 pidfilename;
  Boolean pidfile_existsf,pid_is_runningf;
  LongInt svpid;
  Boolean useconnectionsf;
  array string 255 usrarr,datearr,timearr,evtarr,argarr,tagsarr;
  vector Boolean foundusersvec,foundconnectionsvec;

  //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " keepstartupf=" & keepstartupf);
  res = 0;
  if (ReadFirstMain(LCSr,1,true)==false) then begin
    goto LActiveServerUsers;
  end;

  if ((LCSr.CurrentStatus!=kStatusRunning) and
      (LCSr.CurrentStatus!=kStatusMaintenance) and
      (LCSr.CurrentStatus!=kStatusRunningPendingStop) and
      (LCSr.CurrentStatus!=kStatusRunningTest) and
      (LCSr.CurrentStatus!=kStatusConfigInError)) then begin
    goto LActiveServerUsers;
  end;

  pidfilename = PidFile(LCSr);
  pidfile_existsf = FileExists(pidfilename);

  if (pidfile_existsf) then begin
    svpid = ReadLongFromFile(pidfilename);
    if (svpid>0) then begin
      pid_is_runningf = PidIsRunning(svpid);
    end;
  end;

  if (pid_is_runningf==false) then begin
    LogText(0,"ActiveServerUsers: ERROR " & LCSr.UUID & " isn't running");
    goto LActiveServerUsers;
  end;

  known_sessions = LCSr.DataFolder & "/known_sessions.dat";

  if (FileExists(known_sessions)==false) then begin
    if (keepstartupf) then begin
      //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " being allowed to start up");
      res = 1; // Let it start once
    end;
    goto LActiveServerUsers;
  end;

  qupdating.ImportKnownSessions(known_sessions,usrarr,datearr,timearr,evtarr,argarr);

  lcnt = usrarr.length;
  last_entry_date = DateFromString(datearr[lcnt-1],"YYYY-MM-DD");
  last_entry_time = StringToTime(timearr[lcnt-1]);
  t2 = AddMinutes(last_entry_time,5);

  if (lcnt<=1) then begin
    if (lcnt==1) then begin
      if (IsMinutesPastCurrentTime(last_entry_date,last_entry_time,5)==false) then begin
        if (keepstartupf) then begin
          LogText(0,"ActiveServerUsers: " & LCSr.UUID & " waiting 5 minutes for first connection");
          res = 1; // Give it 5 minutes to the first connection
        end;
      end;
    end;
    goto LActiveServerUsers;
  end;

  if (AddDay(last_entry_date,3)<CurrentDate) then begin
    if (keepstartupf) then begin
      LogText(0,"ActiveServerUsers: " & LCSr.UUID & " got no connections since " & last_entry_date & ", stopping server");
      res = 0; // Stopping after 2-3 days even if there are active users
      goto LActiveServerUsers;
    end;
  end;

  //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " have " & lcnt & " entries in known_sessions.dat");
  for (l=0;l<lcnt;l=l+1) begin
    tstr = evtarr[l];
    //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " evtarr[" & l & "]==" & evtarr[l] & ", argarr[" & l & "]==" & argarr[l]);
    switch (tstr) begin
      case "startup":
      case "login":
        if (useconnectionsf==false) then begin
          tstr = usrarr[l];
          if (foundusersvec[tstr]==false) then begin
            foundusersvec[tstr] = true;
            res = res + 1;
          end;
        end;
      case "logout":
        if (useconnectionsf==false) then begin
          tstr = usrarr[l];
          if (foundusersvec[tstr]==true) then begin
            foundusersvec[tstr] = false;
            res = res - 1;
          end;
        end;
      case "connect":
        tstr = argarr[l];
        if (nonblank(tstr)) then begin
          useconnectionsf = true;
          if (foundconnectionsvec[tstr]==false) then begin
            foundconnectionsvec[tstr] = true;
            res = res + 1;
            //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " got connect (" & res & ")");
          end;
        end;
      case "disconnect":
        tstr = argarr[l];
        if (nonblank(tstr)) then begin
          useconnectionsf = true;
          if (foundconnectionsvec[tstr]==true) then begin
            res = res - 1;
            foundconnectionsvec[tstr] = false;
            //LogText(0,"ActiveServerUsers: " & LCSr.UUID & " got disconnect (" & res & ")");
          end;
        end else begin
          LogText(0,"ActiveServerUsers: " & LCSr.UUID & " ERROR got disconnect with blank argument");
        end;
    end;
  end;

  if (res<0) then begin
    LogText(0,"ActiveServerUsers: " & LCSr.UUID & "ERROR counted to less than zero connections on server");
    res = 0;
  end;

  if (res==0) then begin
    if (!IsMinutesPastCurrentTime(last_entry_date,last_entry_time,5)) then begin
      if (keepstartupf) then begin
        LogText(0,"ActiveServerUsers: " & LCSr.UUID & " waiting 5 minutes for next connection (last was " & last_entry_date & " " & last_entry_time & ")");
        res = 1; // Give it 5 minutes to the next connection
      end;
    end else begin
      LogText(0,"ActiveServerUsers: " & LCSr.UUID & " no active connections for more than 5 minutes, stopping");
    end;
  end else begin
    LogText(0,"ActiveServerUsers: " & LCSr.UUID & " has " & res & " active connections");
  end;

LActiveServerUsers:;
  if (res<0) then begin
    res = 0;
  end;
  return;
end;

global
procedure LastServerActivityDate(record LocalCloudServerVc LCSr,var Date res)
begin
  string 255 known_sessions,tstr;
  array string 255 userarr,userarr2;
  array string 255 usrarr,datearr,timearr,evtarr,argarr,tagsarr;
  Integer lcnt;

  res = "";//set date to blank;
  if (ReadFirstMain(LCSr,1,true)==false) then begin
    goto LLastServerActivityDate;
  end;

  known_sessions = LCSr.DataFolder & "/known_sessions.dat";

  if (FileExists(known_sessions)==false) then begin
    goto LLastServerActivityDate;
  end;

  qupdating.ImportKnownSessions(known_sessions,usrarr,datearr,timearr,evtarr,argarr);

  lcnt = usrarr.length;
  res = DateFromString(datearr[lcnt-1],"YYYY-MM-DD");

LLastServerActivityDate:;
  return;
end;

global
procedure LastServerListActivityDate(array record RemoteCloudServerVc aRCSr,var array Date Actarr)
begin
  Integer lcnt,i;
  record LocalCloudServerVc LCSr;
  record RemoteCloudServerVc RCSr;
  Date res;

  for (i=0;i<aRCSr.length;i=i+1) begin
    RCSr = aRCSr[i];
    LCSr.UUID = RCSr.UUID;
    LastServerActivityDate(LCSr,res);
    Actarr[i] = res;
  end;

  return;
end;

global
function Date GetLastServerActivityDate(record RemoteCloudServerVc RCSr)
begin
  string 255 url;
  record LocalCloudServerVc LCSr;
  Integer stat;
  Date res;

  url = RcsNodeURL(RCSr);

  LCSr.UUID = RCSr.UUID;
  stat = CallService(url).LastServerActivityDate(LCSr,res);

  GetLastServerActivityDate = res;
  return;
end;

global
procedure GetLastServerListActivityDate(array record RemoteCloudServerVc aRCSr,var array Date Actarr)
begin
  string 255 url;
  Integer stat;
  record RemoteCloudServerVc RCSr;

  if (aRCSr.length>0) then begin
    RCSr = aRCSr[0];
    url = RcsNodeURL(RCSr);
    stat = CallService(url).LastServerListActivityDate(aRCSr,Actarr);
  end;

  return;
end;

global
procedure RemoteCloudServersData(array record RemoteCloudServerVc aRCSr,var array Date Actarr,var array val aRCSDBSize,var array Integer aRCShals)
begin
  Integer lcnt,i;
  record LocalCloudServerVc LCSr;
  record RemoteCloudServerVc RCSr;
  Date res;

  for (i=0;i<aRCSr.length;i=i+1) begin
    RCSr = aRCSr[i];
    LCSr.UUID = RCSr.UUID;
    LastServerActivityDate(LCSr,res);
    Actarr[i] = res;
    aRCSDBSize[i] = FileSize2(LCSr.DataFolder & "/" & DatabaseName(LCSr.ProgramType));
    aRCShals[i] = 0;
    if (DirExists(LCSr.DataFolder & "/" & "halcust") or DirExists(LCSr.DataFolder & "/" & "halpatch")) then begin
      aRCShals[i] = 1;
    end;
  end;

  return;
end;

global
procedure GetRemoteCloudServersData(array record RemoteCloudServerVc aRCSr,var array Date Actarr,var array val aRCSDBSize,var array Integer aRCShals)
begin
  string 255 url;
  Integer stat;
  record RemoteCloudServerVc RCSr;

  if (aRCSr.length>0) then begin
    RCSr = aRCSr[0];
    url = RcsNodeURL(RCSr);
    stat = CallService(url).RemoteCloudServersData(aRCSr,Actarr,aRCSDBSize,aRCShals);
  end;

  return;
end;

updating procedure StopServerIfIdle(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  LongInt l;

  switch (LCSr.CurrentStatus) begin
    case kStatusConfigInError:
      // nothing
    case kStatusStopped:
      if (FileExists(ServerExpectRestartFile(LCSr))) then begin
        StartServerIfNeeded(LCSr,HVr);
      end;
    case kStatusRunningPendingStop:
      ActiveServerUsers(LCSr,true,l);
      if (l<=0) then begin
        CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
        CreateFile(EnablerActionsFolder(LCSr) & "EnBackupOnStop");
        CloseFile;
      end;
      StopExternalProcess(ReadLongFromFile(PidFile(LCSr)));
    case kStatusRunning:
      ActiveServerUsers(LCSr,true,l);
      if (l<=0) then begin
        //LogText(0,"Stopping LCSr.Name=" & LCSName(LCSr) & " because nobody is logged in");
        if (LCSr.BackupOnStopFlag==1) then begin
          CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
          CreateFile(EnablerActionsFolder(LCSr) & "/EnBackupOnStop");
          CloseFile;
        end;
        StopExternalProcess(ReadLongFromFile(PidFile(LCSr)));
      end;
    case kStatusStopping:
      // StopAlert("Should check if force stop needed");
      // if too many force stops have been made, place "config in error"
    case kStatusStarting:
      // StopAlert("Should check if force stop needed");
      // if too many force stops have been made, place "config in error"
      // should wait a bit to begin with to let it start normally first
    case kStatusImportingBackup:
      // StopAlert("Should check if force stop needed");
      // if too many force stops have been made, place "config in error"
    case kStatusMaintenance:
  end;
  return;
end;

global
updating procedure SaveNewAndUpdatedRCSs_WTF(record CloudNodeVc CNr,array record LocalCloudServerVc lcsarr)
begin
  SaveNewAndUpdatedRCSs(CNr,lcsarr);
end;

global
procedure FastSyncLCSDataAtCN_WTF(array record RemoteCloudServerVc rcsarr,var array record LocalCloudServerVc lcsarr)
begin
  FastSyncLCSDataAtCN(rcsarr,lcsarr)
end;

/*
global
procedure ServerStatusChangedStep2(record CloudNodeVc CNr,record LocalCloudServerVc LCSr,record RemoteCloudServerVc RCSr)
begin
  array record LocalCloudServerVc lcsarr;
  array record RemoteCloudServerVc rcsarr;
  string 255 url;
  LongInt stat;

  if (ReadFirstMain(RCSr,1,true)) then begin
    rcsarr[0] = RCSr;
    url = NodeURL(CNr);

    stat = CallService(url).FastSyncLCSDataAtCN_WTF(rcsarr,lcsarr);
    if (TreatServiceError(stat,url,"FastSyncLCSDataAtCN")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to [superfast] synchronize " & rcsarr.length & " CC cloud server records with node " & CNr.Code);
      goto LServerStatusChangedStep2;
    end;
    queued.SaveCloudNodeReachable(CNr,true);

    if (lcsarr.length>0) then begin
      LogText(0,"[SuperFast] Synchronizing " & rcsarr.length & " CC and " & lcsarr.length & " CN cloud server records with node " & CNr.Code);
      qupdating.SaveNewAndUpdatedRCSs_WTF(CNr,lcsarr);
      LogText(0,"ServerStatusChanged 5 LCSr.Name=" & LCSName(LCSr));
    end;
  end;
LServerStatusChangedStep2:;
end;
*/
global
procedure ServerStatusChanged(record LocalCloudServerVc LCSr,string cncode)
begin
//deprecated
end;

global
procedure ServerStatusesChanged(array record LocalCloudServerVc lcsarr,string cncode)
begin
  record CloudNodeVc CNr;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LServerStatusesChanged; end;

  if (nonblank(cncode)) then begin
    CNr.Code = cncode;
    if (ReadFirstMain(CNr,1,true)==false) then begin goto LServerStatusesChanged; end;

    LogText(0,"[SuperFast] Saving " & lcsarr.length & " updated LCSs for node " & cncode);
    queued.SaveNewAndUpdatedRCSs_WTF(CNr,lcsarr);
  end else begin
    LogText(0,"ERROR: ServerStatusesChanged got blank node!");
  end;

LServerStatusesChanged:;
  return;
end;

global
updating procedure DoPollOneLCS(var record LocalCloudServerVc LCSr,var Boolean ccsyncf)
begin
  LongInt old_status,old_wantedstatus,old_substatus,old_wantedsubstatus;
  record HansaVersionVc HVr;

  ccsyncf = false;
  if (ReadFirstMain(LCSr,1,true)==false) then begin
    goto LDoPollOneLCS;
  end;

  //LogText2(0,"DoPollOneLCS LCSr.Name=" & LCSName(LCSr),kVerbosityDebugDetailed);

  if (LCSr.Closed!=0) then begin
    goto LDoPollOneLCS;
    //StopServerIfNeeded(LCSr);
  end;

  if ((LCSr.Closed==0) and (LCSr.MovedAwayFlag==0)) then begin
    old_status = LCSr.CurrentStatus;
    old_wantedstatus = LCSr.WantedStatus;
    old_substatus = LCSr.CurrentSubStatus;
    old_wantedsubstatus = LCSr.WantedSubStatus;

    UpdateServerStatus(LCSr,HVr);

    if (old_status!=LCSr.CurrentStatus) then begin
      ccsyncf = true;
      if (old_status==kStatusConfigInError and ((LCSr.WantedStatus==kWantedStatusCreateStartedServer) or (LCSr.WantedStatus==kWantedStatusCreateServer))) then begin
      end else begin
        LogText(0,"DoPollOneLCS(1): CurrentStatus for " & LCSr.UUID & " changed from " & StatusName(old_status) & " to " & StatusName(LCSr.CurrentStatus));
        if (LCSr.CurrentStatus==kStatusConfigInError) then begin
          LogText(0,"DoPollOneLCS(1): StatusText = " & LCSr.StatusText);
        end;
      end;
    end;
    if (old_wantedstatus!=LCSr.WantedStatus) then begin
      LogText(0,"DoPollOneLCS(1): WantedStatus for " & LCSr.UUID & " changed from " & WantedStatusName(old_wantedstatus) & " to " & WantedStatusName(LCSr.WantedStatus));
    end;
    if (old_substatus!=LCSr.CurrentSubStatus) then begin
      ccsyncf = true;
      LogText(0,"DoPollOneLCS(1): CurrentSubStatus for " & LCSr.UUID & " changed from " & SubStatusName(old_substatus) & " to " & SubStatusName(LCSr.CurrentSubStatus));
    end;
    if (old_wantedsubstatus!=LCSr.WantedSubStatus) then begin
      LogText(0,"DoPollOneLCS(1): WantedSubStatus for " & LCSr.UUID & " changed from " & WantedSubStatusName(old_wantedsubstatus) & " to " & WantedSubStatusName(LCSr.WantedSubStatus));
    end;
    old_status = LCSr.CurrentStatus;
    old_wantedstatus = LCSr.WantedStatus;
    old_substatus = LCSr.CurrentSubStatus;
    old_wantedsubstatus = LCSr.WantedSubStatus;

    switch (LCSr.WantedStatus) begin
      case kWantedStatusStop:                 StopServerIfNeeded(LCSr,false);
      case kWantedStatusForceStop:            StopServerIfNeeded(LCSr,true);
      case kWantedStatusRestart:              StopServerIfNeeded(LCSr,false);
      case kWantedStatusRun:                  StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusRunUnjournaled:       StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusOnDemand:             StopServerIfIdle(LCSr,HVr);
      case kWantedStatusMaintenence:          StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusManual:               // nothing
      case kWantedStatusImportBackup:         StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusImportBackupAndRun:   StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusUpdateVersion:        UpdateVersionIfNeeded(LCSr,HVr);
      case kWantedStatusMoveServer:           MoveServerIfNeeded(LCSr);
      case kWantedStatusCreateServer:         CreateServerIfNeeded(LCSr);
      case kWantedStatusCreateStartedServer:  CreateServerIfNeeded(LCSr);
      case kWantedStatusExportDatabase:       StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusExportCompany:        StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusExportRegister:       StartServerIfNeeded(LCSr,HVr);
      case kWantedStatusLaunchReserveSystem:  CreateServerIfNeeded(LCSr);
      case kWantedStatusLaunchTestSystem:     CreateServerIfNeeded(LCSr);
      case kWantedStatusLaunchUpdateSystem:   CreateServerIfNeeded(LCSr);
      case kWantedStatusResetToBackup:        StartServerIfNeeded(LCSr,HVr);
    end;

    if (old_status!=LCSr.CurrentStatus) then begin
      ccsyncf = true;
      LogText(0,"DoPollOneLCS(2): CurrentStatus for " & LCSr.UUID & " changed from " & StatusName(old_status) & " to " & StatusName(LCSr.CurrentStatus));
    end;
    if (old_wantedstatus!=LCSr.WantedStatus) then begin
      LogText(0,"DoPollOneLCS(2): WantedStatus for " & LCSr.UUID & " changed from " & WantedStatusName(old_wantedstatus) & " to " & WantedStatusName(LCSr.WantedStatus));
    end;
    if (old_substatus!=LCSr.CurrentSubStatus) then begin
      ccsyncf = true;
      LogText(0,"DoPollOneLCS(2): CurrentSubStatus for " & LCSr.UUID & " changed from " & SubStatusName(old_substatus) & " to " & SubStatusName(LCSr.CurrentSubStatus));
    end;
    if (old_wantedsubstatus!=LCSr.WantedSubStatus) then begin
      LogText(0,"DoPollOneLCS(2): WantedSubStatus for " & LCSr.UUID & " changed from " & WantedSubStatusName(old_wantedsubstatus) & " to " & WantedSubStatusName(LCSr.WantedSubStatus));
    end;
  end;
LDoPollOneLCS:;
  return;
end;

global
procedure CallServerStatusesChanged(array record LocalCloudServerVc lcsarr,Boolean ccsyncf)
begin
  record CloudSettingsBlock CSb;
  string 255 cncode,url;
  LongInt stat;

  if (ccsyncf and !IsCloudController) then begin
    BlockLoad(CSb);
    cncode = CSb.NodeCode;
    url = Trim(CSb.CCAddr) & ":" & CSb.CCHTTPSPort;
    stat = CallService(url).ServerStatusesChanged(lcsarr,cncode);
  end;
end;

global
updating procedure MigrationCreateContactDo(string custid,string email,string compname,string country)
begin
  record CUVc CUr;

  CUr.Code = custid;
  if (ReadFirstMain(CUr,1,true)) then begin
    LogText(0,"Failed to store customer record:: Customer with code " & custid & " already exists::Cust name::" & compname);
  end else begin
    RecordNew(CUr);
    CUr.Code = custid;
    CUr.Name = compname;
    CUr.eMail = email;
    CUr.CountryCode = country;
    RecordStore(CUr,true);
  end;

  return;
end;

global
procedure MigrationCreateContact(string custid,string email,string compname,string country)
begin

  queued.MigrationCreateContactDo(custid,email,compname,country);

  return;
end;


//KSZ::maybe in the future it should be CUr instead of each field separately
global
procedure CallMigrationCreateContact2(string custid,string email,string compname,string country)
begin
  record CloudSettingsBlock CSb;
  string 255 cncode,url;
  LongInt stat;

  if (!IsCloudController) then begin
    BlockLoad(CSb);
    cncode = CSb.NodeCode;
    url = Trim(CSb.CCAddr) & ":" & CSb.CCHTTPSPort;
    stat = CallService(url).MigrationCreateContact(custid,email,compname,country);
  end;
end;

global
procedure CallMigrationCreateContact(string custid,string email,string compname)
begin

  CallMigrationCreateContact2(custid,email,compname,"");

  return;
end;

global
procedure ASPFastPollServersTask(string arg)
begin
  record LocalCloudServerVc LCSr,LCS2r;
  record RemoteCloudServerVc RCSr,RCS2r;
  record CloudNodeVc CNr;
  Boolean foundf;
  array string 255 nodes,rcss;
  vector Boolean found_nodes;
  LongInt i;
  Integer trycount;
  array record LocalCloudServerVc lcsarr;
  Boolean ccsyncf;

//LASPFastPollServersTask_Again:;
  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPFastPollServersTask; end;


  if (IsCloudController==false) then begin
    ClearArray(lcsarr);
    ccsyncf = false;
    LCSr.FastCheckFlag = 1;
    foundf = true;
    while (LoopKey("FastCheckFlag",LCSr,1,foundf)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPFastPollServersTask; end;
      if (LCSr.FastCheckFlag==0) then begin foundf = false; end;
      if (foundf) then begin
        LogText2(0,"ASPFastPollServersTask 1 LCSr.Name=" & LCSName(LCSr) & "LCSr.FastCheckFlag=" & LCSr.FastCheckFlag,kVerbosityDebugDetailed);
        RecordCopy(LCS2r,LCSr);
        qupdating.DoPollOneLCS(LCS2r,ccsyncf);
        if (ccsyncf) then begin
          lcsarr[lcsarr.length] = LCS2r;
        end;
      end;
    end;

    CallServerStatusesChanged(lcsarr,ccsyncf);
  end;


  RCSr.FastCheckFlag = 1;
  foundf = true;
  while (LoopKey("FastCheckFlag",RCSr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPFastPollServersTask; end;
    if (RCSr.FastCheckFlag==0) then begin foundf = false; end;
    if (foundf) then begin
      RecordCopy(RCS2r,RCSr);
      if ((RCSr.CurrentStatus==kStatusUpdatingVersion) and
          (RCSr.WantedStatus!=kWantedStatusStop) and
          (RCSr.WantedStatus!=kWantedStatusForceStop) and
          (RCSr.WantedStatus!=kWantedStatusRestart)) then begin
        qupdating.UpdateServerWantedSubStatus(RCS2r);
      end;
      qupdating.UpdateServerWantedStatus(RCS2r);
      if (nonblank(RCS2r.Controller)) then begin
        if (found_nodes[RCS2r.Controller]==false) then begin
          if (RCS2r.CurrentStatus==kStatusConfigInError and RCS2r.WantedStatus==kWantedStatusRun) then begin goto LASPFastPollServersTask_Skip1; end;
          if (RCS2r.WantedStatus==kWantedStatusManual) then begin goto LASPFastPollServersTask_Skip1; end;
          found_nodes[RCS2r.Controller] = true;
          nodes[nodes.length] = RCS2r.Controller;
          rcss[rcss.length] = RCS2r.Name;
LASPFastPollServersTask_Skip1:;
        end;
      end;
    end;
  end;

  if (nodes.length>0) then begin
    LogText(0,"Fast synchronizing cloud servers with nodes");
  end;

  for (i = 0; i<nodes.length; i = i + 1) begin
    CNr.Code = nodes[i];
    if (ReadFirstMain(CNr,1,true)==false) then begin
      LogText(0,"The Remote Cloud Server '" & rcss[i] & "' is on a non-existing node (" & nodes[i] & "), consider closing it");
      SetCloudControllerStatus(kJobStatusWarning,"The Remote Cloud Server '" & rcss[i] & "' is on a non-existing node (" & nodes[i] & "), consider closing it");
      FastCheckSyncOneCN(CNr);
    end;
  end;
/*
  if ((nodes.length>0) and IsCloudController and trycount<3) then begin
    trycount = trycount + 1;
    ClearArray(nodes);
    ClearVector(found_nodes);
    UpdateClientBrowsesIfNeeded("RemoteCloudServerVc");
    ResetLoop(RCSr);
    goto LASPFastPollServersTask_Again;
  end;
*/

  if (IsCloudController) then begin
    UpdateClientBrowsesIfNeeded("RemoteCloudServerVc");
  end;

  if (nodes.length>0) then begin
    LogText(0,"Finished, fast synchronized cloud servers with " & nodes.length & " nodes");
  end;

LASPFastPollServersTask:;
  return;
end;

global
procedure ASPPollServersTask(string arg)
begin
  record LocalCloudServerVc LCSr,LCS2r;
  record RemoteCloudServerVc RCSr,RCS2r;
  LongInt i;
  Boolean ccsyncf;
  array record LocalCloudServerVc lcsarr;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPPollServersTask; end;

  if (IsCloudController==false) then begin
    i = 0;
    while (LoopMain(LCSr,0,true)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPPollServersTask; end;
      if (LCSr.FastCheckFlag==0 and LCSr.Closed==0) then begin
        i = i + 1;
        RecordCopy(LCS2r,LCSr);
        qupdating.DoPollOneLCS(LCS2r,ccsyncf);
        if (ccsyncf) then begin
          lcsarr[lcsarr.length] = LCS2r;
        end;
      end;
    end;
    CallServerStatusesChanged(lcsarr,ccsyncf);
    LogText(0,"ASPPollServersTask(): Checked " & i & " LCSs, " & "Current company=" & CurrentCompany & ", ViewSz=" & CountRecords("LocalCloudServerVc"));
  end;

  while (LoopMain(RCSr,0,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPPollServersTask; end;
    if (RCSr.Closed==0) then begin
      RecordCopy(RCS2r,RCSr);
      if ((RCSr.CurrentStatus==kStatusUpdatingVersion) and (RCSr.WantedStatus!=kWantedStatusStop) and (RCSr.WantedStatus!=kWantedStatusForceStop)) then begin
        qupdating.UpdateServerWantedSubStatus(RCS2r);
      end;
      qupdating.UpdateServerWantedStatus(RCS2r);
    end;
  end;
  
  if (IsCloudController) then begin
    UpdateClientBrowsesIfNeeded("RemoteCloudServerVc");
  end;

LASPPollServersTask:;
  return;
end;

function LongInt FindUnusedPort(LongInt firstport,LongInt lastport)
begin
  record LocalCloudServerVc LCSr;
  LongInt res;
  
  res = firstport - 1;
  
LFindUnusedPort_Again:;
  res = res + 1;

  if (res>lastport) then begin
    res = -1;
    goto LFindUnusedPort;
  end;

  LCSr.Port = res;
  if (ReadFirstKey("Port",LCSr,1,true)) then begin goto LFindUnusedPort_Again; end;

  LCSr.HTTPPort = res;
  if (ReadFirstKey("HTTPPort",LCSr,1,true)) then begin goto LFindUnusedPort_Again; end;

  LCSr.HTTPSPort = res;
  if (ReadFirstKey("HTTPSPort",LCSr,1,true)) then begin goto LFindUnusedPort_Again; end;

  LCSr.MaintPort = res;
  if (ReadFirstKey("MaintPort",LCSr,1,true)) then begin goto LFindUnusedPort_Again; end;

  if (TCPPortAvailable(res,"")==false) then begin goto LFindUnusedPort_Again; end;

LFindUnusedPort:;
  FindUnusedPort = res;
  return;
  end;
  
global
procedure FindUnusedPorts(var LongInt port,var LongInt httpport,var LongInt httpsport)
begin
  LongInt lastport;
  if (port==-1) then begin
    port = 10000;
  end;
  lastport = 50000;

  port = FindUnusedPort(port,lastport);
  if (port==-1) then begin goto LFindUnusedPorts; end;
  httpport = FindUnusedPort(port+1,lastport);
  if (httpport==-1) then begin goto LFindUnusedPorts; end;
  httpsport = FindUnusedPort(httpport+1,lastport);
  if (httpsport==-1) then begin goto LFindUnusedPorts; end;
  
LFindUnusedPorts:;
  return; 
end;

global
function LongInt FindUnusedPortOnCC2(string controller,LongInt firstport,LongInt lastport,Boolean ignorercsf,uuid rcsuuid)
begin
  record RemoteCloudServerVc RCSr;
  LongInt res;

  res = firstport - 1;

LFindUnusedPortOnCC2_Again:;
  res = res + 1;

  if (res>lastport) then begin
    res = -1;
    goto LFindUnusedPortOnCC2;
  end;

  RCSr.Controller = controller;
  RCSr.Port = res;
  if (ReadFirstKey("Port",RCSr,2,true)) then begin
    if (ignorercsf==false or (rcsuuid!=RCSr.UUID)) then begin goto LFindUnusedPortOnCC2_Again; end;
  end;

  RCSr.Controller = controller;
  RCSr.HTTPPort = res;
  if (ReadFirstKey("HTTPPort",RCSr,2,true)) then begin
    if (ignorercsf==false or (rcsuuid!=RCSr.UUID)) then begin goto LFindUnusedPortOnCC2_Again; end;
  end;

  RCSr.Controller = controller;
  RCSr.HTTPSPort = res;
  if (ReadFirstKey("HTTPSPort",RCSr,2,true)) then begin
    if (ignorercsf==false or (rcsuuid!=RCSr.UUID)) then begin goto LFindUnusedPortOnCC2_Again; end;
  end;

  RCSr.Controller = controller;
  RCSr.MaintPort = res;
  if (ReadFirstKey("MaintPort",RCSr,2,true)) then begin
    if (ignorercsf==false or (rcsuuid!=RCSr.UUID)) then begin goto LFindUnusedPortOnCC2_Again; end;
  end;

LFindUnusedPortOnCC2:;
  FindUnusedPortOnCC2 = res;
  return;
end;

global
function LongInt FindUnusedPortOnCC(string controller,LongInt firstport,LongInt lastport)
begin
  uuid uuidt;
  FindUnusedPortOnCC = FindUnusedPortOnCC2(controller,firstport,lastport,false,uuidt);
  return;
end;

procedure FindUnusedPortsOnCC(string controller,var LongInt port,var LongInt httpport,var LongInt httpsport)
begin
  LongInt firstport,lastport;

  firstport = 10000;
  lastport = 50000;

  port = FindUnusedPortOnCC(controller,firstport,lastport);
  if (port==-1) then begin goto LFindUnusedPortsOnCC; end;

  httpport = FindUnusedPortOnCC(controller,port+1,lastport);
  if (httpport==-1) then begin goto LFindUnusedPortsOnCC; end;

  httpsport = FindUnusedPortOnCC(controller,httpport+1,lastport);
  if (httpsport==-1) then begin goto LFindUnusedPortsOnCC; end;

LFindUnusedPortsOnCC:;
  return;
end;

function
string 255 FindCloudNodeAddress(string code,Boolean withuserf)
begin
  record CloudNodeVc CNr;
  
  FindCloudNodeAddress = "";
  CNr.Code = code;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    LogText(0,"FindCloudNodeAddress(\"" & code & "\") failed, record not found");
    goto LFindCloudNodeAddress;
  end;
  if (withuserf) then begin
    FindCloudNodeAddress = CNr.AdminUser & "@" & CNr.HostName;
  end else begin
    FindCloudNodeAddress = CNr.HostName;
  end;
  
LFindCloudNodeAddress:;
  return;
end;

global
updating procedure ReceiveVersion(string remotearchive,record HansaVersionVc HVr)
begin
record HansaVersionVc OldHVr;
string 255 infolder;
string 255 tmpfolder;

  if (FileExists(remotearchive)) then begin
    LogText(0,"Extracting version " & HVr.Code & " to " & VersionsFolder & HVr.Code);
  end else begin
    LogText(0,"Failed to extract version " & HVr.Code & " because the archive file " & remotearchive & " doesn't exist");
    goto LReceiveVersion;
  end;

  tmpfolder = "tmp/" & HVr.Code;
  DeleteFolder(tmpfolder);
  CreateFolderHierarchy(tmpfolder);
  RestoreArchive(tmpfolder,remotearchive);
  OldHVr.Code = HVr.Code;
  HVr.ProgramFolder = VersionsFolder & HVr.Code;

  DeleteFolder(HVr.ProgramFolder);
  if (DirExists(HVr.ProgramFolder)) then begin
    LogText(0,"Failed to delete folder " & HVr.ProgramFolder);
    goto LReceiveVersion;
  end;
  CopyFolder(tmpfolder,HVr.ProgramFolder);
  if (DirExists(HVr.ProgramFolder)==false) then begin
    LogText(0,"Failed to copy folder " & tmpfolder & " to " & HVr.ProgramFolder);
    goto LReceiveVersion;
  end;
  DeleteFolder(tmpfolder);

  if (ReadFirstMain(OldHVr,1,true)) then begin
    RecordUpdate(OldHVr,HVr,true);
  end else begin
    RecordInsert(HVr,false);
  end;

  LogText(0,"Version " & HVr.Code & " successfully extracted to folder " & HVr.ProgramFolder);

LReceiveVersion:;
end;

global
procedure ReceiveFilePart(var string remotearchive,string prefix,string suffix,area part)
begin
  if (remotearchive=="") then begin
    remotearchive = CreateTempFile(prefix,suffix);
    LogText(0,"Inbound file transfer of " & prefix & suffix & " starting, writing to temporary file " & remotearchive);
  end;
  
  AppendAreaToFile(remotearchive,part);
end;

updating function Boolean SendVersionToNode(record HansaVersionVc HVr,string archive,record CloudNodeVc CNr)
begin
  LongInt stat,pos,blocklen;
  Val fsz;
  string 255 url,remotearchive;
  area part;
  Boolean res;

  LogText(0,"Sending version " & HVr.Code & " in folder " & HVr.ProgramFolder & " to node " & CNr.Code);
  url = NodeURL(CNr);
  
  fsz = FileSize2(archive);
  pos = 0;
  
  while (pos<fsz) begin
    blocklen = MIN(fsz - pos,5000000); // 5MB at a time...
    LoadFileToArea(archive,pos,blocklen,part);
    
    stat = CallService(url).ReceiveFilePart(remotearchive,"version",".ha",part);
    if (TreatServiceError(stat,url,"ReceiveFilePart")) then begin
      goto LSendVersionToNode;
    end;
    
    pos = pos + blocklen;
  end;
  LogText(0,"Version " & HVr.Code & " successfully sent to node " & CNr.Code);

  stat = CallService(url).ReceiveVersion(remotearchive,HVr);
  if (stat!=kCallServiceCommError) then begin
    if (TreatServiceError(stat,url,"ReceiveVersion")) then begin
      goto LSendVersionToNode;
    end;
  end;
  LogText(0,"Version " & HVr.Code & " successfully unpacked on node " & CNr.Code);

res = true;

LSendVersionToNode:;
  if (res==false) then begin
    LogText(0,"Version " & HVr.Code & " could not be sent to node " & CNr.Code);
  end;
  SendVersionToNode = true;
  return;
end;

updating function Boolean SendVersionToNodeIfNeeded(record CloudNodeVc CNr,record HansaVersionVc HVr)
begin
  string 255 url,archive;
  Boolean canbeupdatedf;
  LongInt stat;
  LongInt retries;
  record HansaVersionVc HV2r;

  RecordCopy(HV2r,HVr);
  url = NodeURL(CNr);

  stat = CallService(url).GetHansaVersionAtCN(HV2r,canbeupdatedf);
  TreatServiceError(stat,url,"GetHansaVersionAtCN");

  if (canbeupdatedf==false) then begin
    LogText(0,"Creating version archive for " & HVr.Code & " to send to " & CNr.Code);
    archive = CreateTempFile("version",".ha");
    BeginArchiveToFile(archive);
    AddArchiveDir(".",HVr.ProgramFolder); // BaseName(HVr.ProgramFolder)
    EndArchive;
    SendVersionToNode(HVr,archive,CNr);
    Delete_File(archive);
  end;

LRetryGetHansaVersionAtCN:;
  RecordCopy(HV2r,HVr);
  stat = CallService(url).GetHansaVersionAtCN(HV2r,canbeupdatedf);
  if (stat==kCallServiceCommError) then begin
    if (retries<15) then begin
      Sleep(5);
      retries = retries + 1;
      goto LRetryGetHansaVersionAtCN;
    end;
  end else begin
    TreatServiceError(stat,url,"GetHansaVersionAtCN");
  end;

  if (canbeupdatedf==false) then begin
    StopAlert("Version " & HVr.Code & " does not exist on node " & CNr.Code & " and failed to be pushed");
  end;

  SendVersionToNodeIfNeeded = canbeupdatedf;
end;

function Boolean OnDemandServerNeedsStarting(record RemoteCloudServerVc RCSr)
begin
  Boolean res;

  if ((RCSr.CurrentStatus!=kStatusRunning) and
      (RCSr.CurrentStatus!=kStatusRunningPendingStop)) then begin
    if ((RCSr.WantedStatus==kWantedStatusOnDemand) or (RCSr.WantedStatus==kWantedStatusStop) or (RCSr.WantedStatus==kWantedStatusForceStop)) then begin
      res = true;
    end;
  end;

  OnDemandServerNeedsStarting = res;
end;

global
updating function DoStartOnDemandServer(record RemoteCloudServerVc RCSr)
begin
  record RemoteCloudServerVc OldRCSr;

  if (OnDemandServerNeedsStarting(RCSr)) then begin
    ReadFirstMain(RCSr,1,true);
    RecordCopy(OldRCSr,RCSr);
    RCSr.WantedStatus = kWantedStatusRun;
    RecordUpdate(OldRCSr,RCSr,true);
  end;
end;

global
updating function UpdateRCSStatus(record RemoteCloudServerVc RCSr,Integer status)
begin
  record RemoteCloudServerVc OldRCSr;

  if (ReadFirstMain(RCSr,1,true)) then begin
    RecordCopy(OldRCSr,RCSr);
    RCSr.CurrentStatus = status;
    RecordUpdate(OldRCSr,RCSr,true);
  end;
end;

global
function Boolean FindLocalServerAddrAndPort(string serverid,var string addr,var LongInt port)
begin
  Boolean res;
  record LocalCloudServerVc LCSr;
  
  res = false;  
  port = -1;
  addr = "";
  
  LCSr.UUID = StringToUUID(serverid);
  if (ReadFirstMain(LCSr,1,true)==false) then begin
    LogText(0,"FindLocalServerAddrAndPort(\"" & serverid & "\") failed, record not found");
    goto LFindLocalServerAddrAndPort;
  end;
  
  port = LCSr.Port;
  addr = ServerIPAddress; //returns 0.0.0.0 when processing cloud service request
  LogText(0,"ServerIPAddress: " & ServerIPAddress);
  res = true;
  
LFindLocalServerAddrAndPort:;
  FindLocalServerAddrAndPort = res;
  return;
end;

global
updating procedure SaveNewAndUpdatedLCSs(array record RemoteCloudServerVc rcsarr)
begin
  record LocalCloudServerVc LCSr;
  record LocalCloudServerVc OldLCSr;
  record RemoteCloudServerVc RCSr;
  record HansaVersionVc HVr;
  Integer i;
  Boolean ccsyncf;
  array record LocalCloudServerVc lcsarr;
  LongInt starttick;

  starttick = GetCurTick;

  for (i = 0; i<rcsarr.length; i = i + 1) begin
    RCSr = rcsarr[i];
    LCSr.UUID = RCSr.UUID;
    if (ReadFirstMain(LCSr,1,true)) then begin
      if (LCSr.MovedAwayFlag==0) then begin
        RecordCopy(OldLCSr,LCSr);
        CopyRCSControlledDataToLCS(RCSr,LCSr);
        LCSr.ClosedOnNodeFlag = LCSr.Closed;
        RecordUpdate(OldLCSr,LCSr,true);
        DoPollOneLCS(LCSr,ccsyncf);
        if (ccsyncf) then begin
          lcsarr[lcsarr.length] = LCSr;
        end;
      end;
    end else begin
      RecordClear(LCSr);
      CopyRCSDataToLCS(RCSr,LCSr);
      LCSr.UUID = RCSr.UUID;
      LCSr.ClosedOnNodeFlag = LCSr.Closed;
//      LogText(0,"Inserting LCS " & LCSName(LCSr) & " with wanted status " & LCSr.WantedStatus);
      RecordInsert(LCSr,false);
      DoPollOneLCS(LCSr,ccsyncf);
      if (ccsyncf) then begin
        lcsarr[lcsarr.length] = LCSr;
      end;
    end;

    if (nonblank(LCSr.HansaVersion) and (LCSr.Closed==0) and (LCSr.MovedAwayFlag==0)) then begin
      if (GetVersion(LCSr.HansaVersion,HVr)==false) then begin
        HVr.Code = LCSr.HansaVersion;
        DoDownloadVersion(HVr,false);
      end;
    end;
    if (nonblank(LCSr.NewHansaVersion) and (LCSr.Closed==0) and (LCSr.MovedAwayFlag==0)) then begin
      if (GetVersion(LCSr.NewHansaVersion,HVr)==false) then begin
        HVr.Code = LCSr.NewHansaVersion;
        DoDownloadVersion(HVr,false);
      end;
    end;
    if (nonblank(LCSr.OldHansaVersion) and (LCSr.Closed==0) and (LCSr.MovedAwayFlag==0)) then begin
      if (GetVersion(LCSr.OldHansaVersion,HVr)==false) then begin
        HVr.Code = LCSr.OldHansaVersion;
        DoDownloadVersion(HVr,false);
      end;
    end;
  end;

  CallServerStatusesChanged(lcsarr,ccsyncf);

  LogText(0,"SaveNewAndUpdatedLCSs took " & GetCurTick - starttick & "ms to process " & rcsarr.length & " records");
end;

global
procedure SyncRCSsAtCN(array record RemoteCloudServerVc rcsarr)
begin
  Integer i;
  array record RemoteCloudServerVc rcsarr2;
  record LocalCloudServerVc CurLCSr,NewLCSr;
  record RemoteCloudServerVc RCSr;

  for (i = 0; i<rcsarr.length; i = i + 1) begin
    RCSr = rcsarr[i];
    CurLCSr.UUID = RCSr.UUID;
    if (ReadFirstMain(CurLCSr,1,true)) then begin
      if (CurLCSr.MovedAwayFlag==0) then begin
        RecordCopy(NewLCSr,CurLCSr);
        CopyRCSControlledDataToLCS(RCSr,NewLCSr);
        NewLCSr.ClosedOnNodeFlag = NewLCSr.Closed;
        if (ComparePosts(NewLCSr,CurLCSr)==false) then begin
          rcsarr2[rcsarr2.length] = RCSr;
        end;
      end;
    end else begin
      rcsarr2[rcsarr2.length] = RCSr;
    end;
  end;
  
  LogText2(0,"SyncRCSsAtCN got " & rcsarr.length & " and found " & rcsarr2.length & " that needs updating",kVerbosityDebugDetailed);
  
  if (rcsarr2.length>0) then begin 
    LogText(0,"SyncRCSsAtCN updating " & rcsarr2.length & " records from controller");
    queued.SaveNewAndUpdatedLCSs(rcsarr2);
  end;
  
LSyncRCSsAtCN:;
  return;
end;

global
procedure GetOneLCS(var record LocalCloudServerVc LCSr,var Boolean foundf)
begin
  foundf = ReadFirstMain(LCSr,1,true);
end;

global
function Boolean FindServerAddrAndPort(string serverid,var string addr,var LongInt port,var Integer status)
begin
  Boolean res,testf,foundf;
  record RemoteCloudServerVc RCSr;
  record LocalCloudServerVc LCSr;
  record CloudNodeVc CNr;
  string 255 cnurl;
  array record RemoteCloudServerVc rcsarr;
  LongInt stat,starttick,serverstatus;

  starttick = GetCurTick;

  status = 2; // not found
  res = false;
  port = -1;
  addr = "";

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin
    status = 1; // try again if uuid in client is non-blank
    port = 30000; // so old clients don't give up
    addr = "0.0.0.0";  // so old clients don't give up
    goto LFindServerAddrAndPort;
  end;

  RCSr.UUID = StringToUUID(serverid);

  if (ReadFirstMain(RCSr,1,true)==false) then begin
    RCSr.UUID = StringToUUID(serverid);
    if (qupdating.GetRCSOnMainThread(RCSr)==false) then begin
      LogText(0,"FindServerAddrAndPort(\"" & serverid & "\") failed, record not found");
      qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, record not found","",StringToUUID(serverid),"");
      if (nonblank(serverid)) then begin
        status = 1; // try again if uuid in client is non-blank
        port = 30000; // so old clients don't give up
        addr = "0.0.0.0";  // so old clients don't give up
      end;
    end else begin
      LogText(0,"FindServerAddrAndPort(\"" & serverid & "\") failed, RCS exists on main thread but not on processing thread");
      status = 1;
    end;
    goto LFindServerAddrAndPort;
  end;
  
  CNr.Code = RCSr.Controller;
  
  if (ReadFirstMain(CNr,1,true)==false) then begin
    LogText(0,"FindServerAddrAndPort(\"" & serverid & "\") failed, node record " & CNr.Code & " not found");
    qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, node record not found","",StringToUUID(serverid),RCSr.Controller);
    goto LFindServerAddrAndPort;
  end;

  port = RCSr.Port;
  addr = CNr.HostName;
  res = true;
  cnurl = ReadNodeUrl(CNr);

  if (OnDemandServerNeedsStarting(RCSr)) then begin
    queued.DoStartOnDemandServer(RCSr);

    RCSr.WantedStatus = kWantedStatusRun;
    rcsarr[rcsarr.length] = RCSr;
    stat = CallService(cnurl).SyncRCSsAtCN(rcsarr);

    if (TreatServiceError(stat,cnurl,"SyncRCSsAtCN")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to synchronize " & RCSr.UUID & " with node " & CNr.Code);
      qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, node not responding (1)","",RCSr.UUID,CNr.Code);
      status = 1; // try again
      goto LFindServerAddrAndPort;
    end;
  end;

  LCSr.UUID = RCSr.UUID;
  stat = CallService(cnurl).GetOneLCS(LCSr,foundf);
  if (TreatServiceError(stat,cnurl,"GetOneLCS")) then begin
    queued.SaveCloudNodeReachable(CNr,false);
    LogText(0,"Failed to get status for " & LCSr.UUID & " from node " & CNr.Code);
    qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, node not responding (2)","",RCSr.UUID,CNr.Code);
    status = 1; // try again
    goto LFindServerAddrAndPort;
  end;
  serverstatus = LCSr.CurrentStatus;

  while ((GetCurTick-starttick)<(8 * kTicksPerSecond)) begin
    switch (serverstatus) begin
      case kStatusRunningPendingStop:
        status = 0; // should be ok
        goto LFindServerAddrAndPort;
      case kStatusRunning:
        if (TestServerNotResponding(addr,port)) then begin
          LogText(0,"FindServerAddrAndPort(\"" & serverid & "\") got running but not yet responding");
          MilliSleep(200);
          status = 1; // starting up...
        end else begin
          status = 0; // good to go
          goto LFindServerAddrAndPort;
        end;
      otherwise
        status = 1; // starting up...
        LCSr.UUID = RCSr.UUID;
        stat = CallService(cnurl).GetOneLCS(LCSr,foundf);
        if (TreatServiceError(stat,cnurl,"GetOneLCS")) then begin
          queued.SaveCloudNodeReachable(CNr,false);
          LogText(0,"Failed to get status for " & LCSr.UUID & " from node " & CNr.Code);
          qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, node not responding (3)","",RCSr.UUID,CNr.Code);
          status = 1; // try again
          goto LFindServerAddrAndPort;
        end;
        if (serverstatus<>LCSr.CurrentStatus) then begin
          serverstatus = LCSr.CurrentStatus;
          queued.UpdateRCSStatus(RCSr,serverstatus);
        end else begin
          MilliSleep(200);
        end;
    end;
  end;

LFindServerAddrAndPort:;
  LogText(0,"FindServerAddrAndPort(\"" & serverid & "\") got addr=" & addr & ", port=" & port & ", status=" & status);
  FindServerAddrAndPort = res;
  
  return;
end;

global
procedure FindServersWithId(string ident,Boolean testallf,var array record RemoteCloudServerVc RCSarr)
begin
  LongInt cnt;
  Boolean emailf;
  record CUVc CUr,mainCUr;
  record ContactRelVc ContactRelr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc RCS2r;
  record RemoteCloudServerVc RCS3r;
  record RemoteCloudServerVc RCS4r;
  record RemoteCloudServerVc RCS5r;
  Boolean foundf,found2f,found3f;

  ClearArray(RCSarr);

  if (blank(ident)) then begin
    LogText(0,"Warning: FindServersWithId called with blank identification");
    goto LFindServersWithId;
  end else begin
    LogText(0,"FindServersWithId called with identification """ & ident & """");
  end;

  emailf = CheckEmailStr(ident);

  cnt = 0;
  if (emailf==false) then begin
    LogText2(0,"FindServersWithId: CheckEmailStr==false",kVerbosityDebugDetailed);
    foundf = true;
    RCSr.CUCode = ident;
    while (LoopKey("CUCode",RCSr,1,foundf)) begin
      if (RCSr.CUCode!=ident) then begin foundf = false; end;
      if (foundf) then begin
        LogText2(0,"FindServersWithId: Ident recognized as customer for server " & RCSName(RCSr),kVerbosityDebugDetailed);
        RCSarr[RCSarr.length] = RCSr;
        cnt = cnt + 1;
      end;
    end;
    if (cnt==0) then begin
      LogText2(0,"FindServersWithId: Found no servers with ident used as a customer code",kVerbosityDebugDetailed);
    end;
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

  cnt = 0;
  if (emailf) then begin
    foundf = true;
    CUr.eMail = ident;
    while (LoopKey("eMail",CUr,1,foundf)) begin
      if (CUr.eMail!=ident) then begin foundf = false; end;
      if (foundf) then begin
        found2f = true;
        ResetLoop(RCS2r);
        RCS2r.CUCode = CUr.Code;
        while (LoopKey("CUCode",RCS2r,1,found2f)) begin
          if (RCS2r.CUCode!=CUr.Code) then begin found2f = false; end;
          if (found2f) then begin
            LogText2(0,"FindServersWithId: Ident recognized as e-mail address for server " & RCS2r.Name,kVerbosityDebugDetailed);
            RCSarr[RCSarr.length] = RCS2r;
            cnt = cnt + 1;
          end else begin
            ResetLoop(ContactRelr);
            ContactRelr.ContactCode = CUr.Code;
            if (ReadFirstKey("ContactCode",ContactRelr,1,true)) then begin
              mainCUr.Code = ContactRelr.CustCode;
              if (ReadFirstMain(mainCUr,1,true)) then begin
                found3f = true;
                ResetLoop(RCS3r);
                RCS3r.CUCode = mainCUr.Code;
                while (LoopKey("CUCode",RCS3r,1,found3f)) begin
                  if (RCS3r.CUCode!=mainCUr.Code) then begin found3f = false; end;
                  if (found3f) then begin
                    LogText2(0,"FindServersWithId: Ident recognized as e-mail (2) address for server " & RCS3r.Name,kVerbosityDebugDetailed);
                    RCSarr[RCSarr.length] = RCS3r;
                    cnt = cnt + 1;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used an e-mail address",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

  cnt = 0;
  foundf = true;
  RecordClear(CUr);
  ResetLoop(CUr);
  CUr.VATNr = ident;
  foundf = ReadFirstKey("VATNr",CUr,1,true);
  if (foundf) then begin
    LogText2(0,"FindServersWithId: Ident recognized as VAT nr with ident " & ident,kVerbosityDebugDetailed);
    found2f = true;
    RCS4r.CUCode = CUr.Code;
    while (LoopKey("CUCode",RCS4r,1,found2f)) begin
      if (RCS4r.CUCode!=CUr.Code) then begin found2f = false; end;
      if (found2f) then begin
        LogText2(0,"FindServersWithId: Ident recognized as VAT nr for server " & RCS4r.Name,kVerbosityDebugDetailed);
        RCSarr[RCSarr.length] = RCS4r;
        cnt = cnt + 1;
      end;
    end;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used as VAT nr.",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

  cnt = 0;
  foundf = true;
  RecordClear(CUr);
  ResetLoop(CUr);
  CUr.RegNr1 = ident;
  foundf = ReadFirstKey("RegNr1",CUr,1,true);
  if (foundf) then begin
    LogText2(0,"FindServersWithId: Ident recognized as Reg nr with ident " & ident,kVerbosityDebugDetailed);
    found2f = true;
    ResetLoop(RCS2r);
    RCS2r.CUCode = CUr.Code;
    while (LoopKey("CUCode",RCS2r,1,found2f)) begin
      if (RCS2r.CUCode!=CUr.Code) then begin found2f = false; end;
      if (found2f) then begin
        LogText2(0,"FindServersWithId: Ident recognized as Reg nr for server " & RCS2r.Name,kVerbosityDebugDetailed);
        RCSarr[RCSarr.length] = RCS2r;
        cnt = cnt + 1;
      end;
    end;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used as Reg nr.",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

/*
  cnt = 0;
  foundf = true;
  RecordClear(CUr);
  ResetLoop(CUr);
  CUr.RegNr2 = ident;
  foundf = ReadFirstKey("RegNr2",CUr,1,true);
  if (foundf) then begin
    LogText2(0,"FindServersWithId: Ident recognized as Reg nr 2 with ident " & ident,kVerbosityDebugDetailed);
    found2f = true;
    ResetLoop(RCS2r);
    RCS2r.CUCode = CUr.Code;
    while (LoopKey("CUCode",RCS2r,1,found2f)) begin
      if (RCS2r.CUCode!=CUr.Code) then begin found2f = false; end;
      if (found2f) then begin
        LogText2(0,"FindServersWithId: Ident recognized as Reg nr 2 for server " & RCS2r.Name,kVerbosityDebugDetailed);
        RCSarr[RCSarr.length] = RCS2r;
        cnt = cnt + 1;
      end;
    end;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used as Reg nr. 2",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;
*/

  cnt = 0;
  RecordClear(RCSr);
  ResetLoop(RCSr);
  RCSr.UUID = StringToUUID(ident);
  if (ReadFirstMain(RCSr,1,true)) begin
    LogText2(0,"FindServersWithId: Ident recognized as UUID for server " & RCSName(RCSr),kVerbosityDebugDetailed);
    RCSarr[RCSarr.length] = RCSr;
    cnt = cnt + 1;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used as UUID",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

  cnt = 0;
  foundf = true;
  RecordClear(CUr);
  ResetLoop(CUr);
  CUr.Name = ident;
//  foundf = ReadFirstKey("Name",CUr,1,true);
//  if (foundf) then begin
  foundf = true;
  while (LoopKey("Name",CUr,1,foundf)) begin
    if (left(CUr.Name,len(ident))!=ident) then begin
      foundf = false;
    end else begin
      LogText2(0,"FindServersWithId: Ident recognized as Name with ident " & ident,kVerbosityDebugDetailed);
      found2f = true;
      ResetLoop(RCS2r);
      RCS2r.CUCode = CUr.Code;
      while (LoopKey("CUCode",RCS2r,1,found2f)) begin
        if (RCS2r.CUCode!=CUr.Code) then begin found2f = false; end;
        if (found2f) then begin
          LogText2(0,"FindServersWithId: Ident recognized as Name for server " & RCS2r.Name,kVerbosityDebugDetailed);
          RCSarr[RCSarr.length] = RCS2r;
          cnt = cnt + 1;
        end;
      end;
    end;
  end;
  if (cnt==0) then begin
    LogText2(0,"FindServersWithId: Found no servers with ident used as Name",kVerbosityDebugDetailed);
  end;
  if (testallf==false and cnt>0) then begin goto LFindServersWithId; end;

LFindServersWithId:;
  return;
end;

global
procedure FindServersWithId_Extended(string ident,Boolean testallf,var array record RemoteCloudServerVc RCSarr)
begin
  record RemoteCloudServerVc RCSr;

  if (len(ident)>=4) then begin
    while (LoopMain(RCSr,1,true)) begin
      if (InString(RCSr.Name,ident)>0) then begin
        LogText2(0,"FindServersWithId_Extended: Ident recognized as customer for server " & RCSName(RCSr),kVerbosityDebugDetailed);
        RCSarr[RCSarr.length] = RCSr;
      end;
    end;
  end;

  if (testallf or RCSarr.length==0) then begin
    FindServersWithId(ident,testallf,RCSarr);
  end;

  return;
end;

global
function Boolean FindServerAddrAndPortWithId2(string ident,var string addr,var LongInt port,var Integer status,var string name,var uuid serverid,var string curstatus,var string cursubstatus,var string buildno)
begin
  Boolean res,dummy;
  record RemoteCloudServerVc RCSr;
  record CloudNodeVc CNr;
  array record RemoteCloudServerVc RCSarr;
  record HansaVersionVc HVr;

  status = 2; // not found
  res = false;
  port = -1;
  addr = "";

  if (blank(ident)) then begin
    status = 1; // comm err, should be own status but to be compatible with older 8.0:s we'll pretend that the server is starting, which will cause a retry
    LogText(0,"FindServerAddrAndPortWithId2 called with blank identification");
    goto LFindServerAddrAndPortWithId;
  end;

  FindServersWithId(ident,false,RCSarr);

  if (RCSarr.length>0) then begin
    RCSr = RCSarr[0]; // only first hit for now
    CNr.Code = RCSr.Controller;
    if (ReadFirstMain(CNr,1,true)==false) then begin
      LogText(0,"FindServerAddrAndPortWithId2(\"" & ident & "\") failed, node record " & CNr.Code & " not found");
      qupdating.StoreASPEvent(kASPEventTypeFindServerError,"FindServerAddrAndPort failed, node record not found","",RCSr.UUID,RCSr.Controller);
      goto LFindServerAddrAndPortWithId;
    end;

    port = RCSr.Port;
    addr = CNr.HostName;
    name = RCSr.Name;
    serverid = RCSr.UUID;
    HVr.Code = RCSr.HansaVersion;
    if (ReadFirstMain(HVr,1,true)) then begin
      buildno = ValToString(((HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild),M4Val,"",".",1);
    end;
    LogText(0,"FindServerAddrAndPortWithId2(\"" & ident & "\") got addr=" & addr & ", port=" & port);
    res = true;

    qupdating.DoStartOnDemandServer(RCSr);
    threadasync.SyncRCSDataWithOneCN2(CNr,true,true); // not sure if threadasync here would give us the RCS updated on the line above
    if (qupdating.GetRCSOnMainThread(RCSr)==false) then begin
      LogText(0,"FindServerAddrAndPortWithId2(\"" & ident & "\") FATAL RCS not found");
    end;

    switch (RCSr.CurrentStatus) begin
      case kStatusRunningPendingStop:
        status = 0; // should be ok
      case kStatusRunning:
        status = 0; // good to go
      otherwise
        status = 1; // starting up...
        curstatus = RCSr.CurrentStatus;//for upgrade from webpage we need to get the actual task that server is performing
        cursubstatus = RCSr.CurrentSubStatus;
    end;
  end;

LFindServerAddrAndPortWithId:;
  FindServerAddrAndPortWithId2 = res;
  LogText2(0,"FindServerAddrAndPortWithId2(\"" & ident & "\") got addr=" & addr & ", port=" & port & ", res=" & res & ", status=" & status,kVerbosityDebug);
  return;
end;

global
function Boolean FindServerAddrAndPortWithId(string ident,var string addr,var LongInt port,var Integer status,var string name,var uuid serverid)
begin
  string 255 curstatus,cursubstatus,buildno;
  Boolean res;

  res = FindServerAddrAndPortWithId2(ident,addr,port,status,name,serverid,curstatus,cursubstatus,buildno);

  FindServerAddrAndPortWithId = res;
  return;
end;

global
function Boolean FindCloudServerAddr(record RemoteCloudServerVc RCSr,var string addr)
begin
  Boolean res;
  record CloudNodeVc CNr;

  res = false;
  addr = "";

  if (blank(RCSr.PublicHostName)) then begin
    CNr.Code = RCSr.Controller;
    if (ReadFirstMain(CNr,1,true)==false) then begin
      goto LFindCloudServerAddr;
    end;
    //Possibly CallService().FindLocalServerAddrAndPort()
    addr = CNr.HostName;
  end else begin
    addr = RCSr.PublicHostName;
  end;

  res = true;

LFindCloudServerAddr:;
  FindCloudServerAddr = res;

  return;
end;

global
updating procedure CreateRemoteServer(uuid serverid,record CloudNodeVc CNr,record HansaVersionVc HVr,record CUVc CUr,var string errorstr,var LongInt port,var LongInt http_port,var LongInt https_port,string country_localizations)
begin
  record RemoteCloudServerVc RCSr,RCS2r;
  string 255 datafolder;
  Integer btime;
  LongInt stat;

  FindUnusedPortsOnCC(CNr.Code,port,http_port,https_port); // Checking on CC to prevent conflict with unsynced RCSr:s
  stat = CallService(NodeURL(CNr)).FindUnusedPorts(port,http_port,https_port); // Checking on CN to ensure port is available on the machine
  // TODO: handle errors

  datafolder = ServersFolder & "Auto/" & serverid;
  RCSr.ServerName = "hansa-autoserver-" & CUr.Code;
  RCSr.UUID = serverid;
  RCSr.CUCode = CUr.Code;
  RCSr.Name = CUr.Name;
  RCSr.HansaVersion = HVr.Code;
  RCSr.DataFolder = datafolder;
  RCSr.Port = port;
  RCSr.HTTPPort = http_port;
  RCSr.HTTPSPort = https_port;
  RCSr.WantedStatus = kWantedStatusCreateStartedServer;
  RCSr.CurrentStatus = kStatusCreating;
  RCSr.OnDemandFlag = 1;
  RCSr.BackupOnStopFlag = 1;
  RCSr.UUIDLock = 1;
  RCSr.Controller = CNr.Code;
  RCSr.NewController = CNr.Code;
  btime = Random(1,24);
  RCSr.BackupTime = right("0" & btime-1 & ":00",5);
  RCSr.BackupFolder = "Backup";
  RCSr.LogLevel = 2;
  RCSr.HalcustUpdateRule = 3;
  RCSr.HalpatchUpdateRule = 3;
  RCSr.CountryLocalizations = country_localizations;

  if (RecordInsert(RCSr,false)==false) then begin
    errorstr = "failed to save server record";
    LogText(0,"CreateRemoteServer error: " & errorstr);
  end;

  return;
end;

global
updating procedure CreateLocalServer(var record LocalCloudServerVc LCSr,record HansaVersionVc HVr,record CUVc CUr,var string errorstr,area a_setuptb,var string res)
begin
/*
  string 255 datafolder;
  uuid serverid;
  
  if (ReadFirstMain(HVr,1,true)==false) then begin
    errorstr = "Version " & HVr.Code & " does not exist on node";
    LogText(0,errorstr);
    goto LCreateLocalServer;
  end;
  
  serverid = MakeUUID;
  datafolder = ServersFolder & "Auto/" & serverid;
  
  if (DirExists(datafolder)) then begin
    errorstr = "datafolder: " & datafolder & " already exists";
    LogText(0,errorstr);
    goto LCreateLocalServer;
  end;
  
  LCSr.UUID = serverid;
  LCSr.CUCode = CUr.Code;
  LCSr.Name = CUr.Name;
  LCSr.HansaVersion = HVr.Code;
  LCSr.DataFolder = datafolder;
  // RecordField(BindIP,M4Str,20,0);
  LCSr.Port = FindUnusedPort;
  LCSr.WantedStatus = kWantedStatusRun;
  LCSr.CurrentStatus = kStatusImportingBackup;
  LCSr.CurrentSubStatus = kSubStatusNone;
  LCSr.UUIDLock = 1;
  LCSr.DisableHobcheck = 1;
  
  if (RecordStore(LCSr,false)==false) then begin
    errorstr = "failed to save server record";
    LogText(0,errorstr);
    goto LCreateLocalServer;
  end;
  
  CreateFolder(datafolder);
  
  if (DirExists(datafolder)==false) then begin
    errorstr = "failed to create datafolder: " & datafolder;
    LogText(0,errorstr);
    goto LCreateLocalServer;
  end;
  
  // WriteAreaToFile(a_setuptb,datafolder & "/TBSETUP.TXT",0);
  
  WriteAreaToFile(a_setuptb,datafolder & "/cloudserversetup.ha",0);
  RestoreArchive(datafolder,datafolder & "/cloudserversetup.ha");
  
  DoStartServer(LCSr,HVr,kManagedServerWhenUpdating);
  
  res = serverid;
  
LCreateLocalServer:;
  
  if (errorstr<>"") then begin
    LogText(0,"CreateLocalServer error: " & errorstr);
  end;
  */
  return;
end;

global
updating procedure StoreSetupTB(uuid serverid,area a_setuptb)
begin
  string 255 datafolder;
  
/* DEBUG CODE
Delete_file("/tmp/setuptbarea.dat");
WriteAreaToFile(a_setuptb,"/tmp/setuptbarea.dat",0);
 */
  datafolder = ServersFolder & "Auto/" & serverid;
  CreateFolderHierarchy(datafolder);
  WriteAreaToFile(a_setuptb,datafolder & "/cloudserversetup.ha",0);
  LogText2(0,"StoreSetupTB: unarchiving to " & datafolder,kVerbosityDebugDetailed);
  RestoreArchive(datafolder,datafolder & "/cloudserversetup.ha");
  Delete_File(datafolder & "/cloudserversetup.ha");
end;

global
function Boolean FindProductHansaVersion(Integer version,Integer asubversion,Integer prot_version,Integer running_build,string product_version,Integer program_type,string product_code,Boolean fuzzf,var string errorstr,var record HansaVersionVc HVr,Boolean testuserf)
begin
  Boolean res,foundverf,latestf;
  string 255 pcode;
  Integer ptyp;
  record CloudSettingsBlock CSb;
  string 255 keyname;
  Integer keysegs;
  record HansaVersionVc HV2r;
  Integer subversion;

  if (prot_version>asubversion) then begin
    subversion = prot_version;
  end else begin
    subversion = asubversion;
  end;

  res = true;

  if (InString(product_version," Development Version ")) then begin
    latestf = true;
  end;

  LogText2(0,"FindProductHansaVersion version=" & version & ", subversion=" & subversion & ", runningbuild=" & running_build & ", product_version=" & product_version & ", program_type=" & program_type & ", product_code=" & product_code & ", latestf=" & latestf & ", fuzzf=" & fuzzf,kVerbositySilent);

  BlockLoad(CSb);
  if (ProgramTypeShouldUseStandardServer(program_type)) then begin
    ptyp = typStdAccountsServer;
    pcode = "StandardServer";
    LogText2(0,"FindProductHansaVersion Using product code StandardServer",kVerbosityDebugDetailed);
  end else begin
    ptyp = typStandardERP;
    pcode = "StandardERP";
    LogText2(0,"FindProductHansaVersion Using product code StandardERP",kVerbosityDebugDetailed);
  end;

  HVr.Version = version;
  HVr.SubVersion = subversion;
  HVr.ProgramType = ptyp;
  HVr.ProductCode = pcode;
  HVr.RunningBuild = running_build;

  if (latestf) then begin
    LogText(0,"FindProductHansaVersion Using Development Version: " & product_version);
    if (ReadLastKey("TestBuilds",HVr,4,true)==false) then begin
      errorstr = "version " & version & "," & subversion & " programtype " & ptyp & " productcode " & pcode & " not available";
      res = false;
      LogText2(0,"FindProductHansaVersion Version not found",kVerbosityDebugDetailed);
    end else begin
      LogText2(0,"FindProductHansaVersion Version " & HVr.Code & " found",kVerbosityDebugDetailed);
    end;
    goto LFindProductHansaVersion;
  end;

  if (fuzzf) then begin
    keyname = "DbVersion2";
    keysegs = 3;
  end else begin
    keyname = "DbVersion3";
    keysegs = 4;
  end;

  if (fuzzf /*or testuserf*/) then begin
    if (ReadLastKey("DbVersion",HVr,3,true)==false) then begin
      errorstr = "version " & version & "," & subversion & " programtype " & ptyp & " productcode " & pcode & " not available";
      res = false;
      LogText2(0,"FindProductHansaVersion Version not found",kVerbosityDebugDetailed);
    end;

    if (res==false and not testuserf) then begin
      LogText2(0,"FindProductHansaVersion Attempting fuzzy search 1",kVerbosityDebugDetailed);
      RecordCopy(HV2r,HVr);
      HV2r.Version = version;
      HV2r.SubVersion = subversion;
      HV2r.ProductCode = product_code;
      if (ReadLastKey("AllDbVersions",HV2r,3,true)==true) then begin
        RecordCopy(HVr,HV2r);
        res = true;
        LogText2(0,"FindProductHansaVersion Version found: " & HVr.Code,kVerbosityDebugDetailed);
      end;
    end;

    if (res==false and not testuserf) then begin
      LogText2(0,"FindProductHansaVersion Attempting fuzzy search 2",kVerbosityDebugDetailed);
      RecordCopy(HV2r,HVr);
      HV2r.Version = version;
      HV2r.SubVersion = subversion;
      if (ReadLastKey("AllDbVersions",HV2r,2,true)==true) then begin
        RecordCopy(HVr,HV2r);
        res = true;
        LogText2(0,"FindProductHansaVersion Version found: " & HVr.Code,kVerbosityDebugDetailed);
      end;
    end;
    goto LFindProductHansaVersion;
  end;

  res = false;

  RecordCopy(HV2r,HVr);
  switch (ptyp) begin
    case typStdAccountsServer:
      HV2r.Code = CSb.StandardAccVersion;
    case typStandardERP:
      HV2r.Code = CSb.StandardERPVersion;
  end;

  if (ReadFirstMain(HV2r,1,true)) then begin
    RecordCopy(HVr,HV2r);
    res = true;
    goto LFindProductHansaVersion;
  end;

  RecordCopy(HV2r,HVr);
  if (ReadFirstKey("DbVersion3",HV2r,4,true)) then begin
    RecordCopy(HVr,HV2r);
    res = true;
    goto LFindProductHansaVersion;
  end;

LogText2(0,"FindProductHansaVersion HVr.Version=" & HVr.Version & ", HVr.SubVersion=" & HVr.SubVersion & ", HVr.RunningBuild=" & HVr.RunningBuild & ", HVr.ProgramType=" & HVr.ProgramType,kVerbosityDebugDetailed);

  errorstr = "Version=" & version & subversion & right("000" & running_build,4) & ", programtype=" & ptyp & " not found";
  LogText2(0,"ERROR: FindProductHansaVersion Version=" & version & subversion & right("000" & running_build,4) & ", programtype=" & ptyp & " not found",kVerbosityDebugDetailed);

LFindProductHansaVersion:;
  LogText2(0,"FindProductHansaVersion res=" & res,kVerbosityDebugDetailed);
  FindProductHansaVersion = res;
  return;
end;

global
function Boolean IsTestUser(string emailaddr)
begin
  Boolean res;

  if (right(emailaddr,14)=="hansaworld.com") then begin
    res = true;
  end;

  IsTestUser = res;
  return;
end;

function Boolean CountAsRunningRCS(record RemoteCloudServerVc RCSr)
begin
  Boolean res;

  if (RCSr.Closed!=0) then begin goto LCountAsRunningRCS; end;

  switch (RCSr.CurrentStatus) begin
    case kStatusRunning:                  res = true;
    case kStatusStopping:                 res = true;
    case kStatusStarting:                 res = true;
    case kStatusImportingBackup:          res = true;
    case kStatusUpdatingVersion:          res = true;
    case kStatusCreated:                  res = true;
    case kStatusCreating:                 res = true;
    case kStatusMaintenance:              res = true;
    case kStatusExportingDatabase:        res = true;
    case kStatusExportedDatabase:         res = true;
    case kStatusImportedBackup:           res = true;
    case kStatusExportingRegister:        res = true;
    case kStatusExportedRegister:         res = true;
    case kStatusExportingCompany:         res = true;
    case kStatusExportedCompany:          res = true;
    case kStatusRunningTest:              res = true;
    case kStatusRunningReserve:           res = true;
    case kStatusRunningPreparingTest:     res = true;
    case kStatusRunningUpdate:            res = true;
    case kStatusRunningPreparingUpdate:   res = true;
    case kStatusRunningPendingStop:       res = true;
    case kStatusRunningPreparingReserve:  res = true;
  end;

LCountAsRunningRCS:;
  CountAsRunningRCS = res;
  return;
end;

function Integer ServerCntOnCN(record CloudNodeVc CNr)
begin
  Integer res;
  record RemoteCloudServerVc RCSr;
  Boolean foundf;

  RCSr.Controller = CNr.Code;
  foundf = true;
  while (LoopKey("Controller",RCSr,1,foundf)) begin
    if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
    if (foundf) then begin
      if (CountAsRunningRCS(RCSr)) then begin
        res = res + 1;
      end;
    end;
  end;

LServerCntOnCN:;
  ServerCntOnCN = res;
  return;
end;

function Boolean GetExistingNodeForNewAutoServer(string emailaddr,var record CloudNodeVc CNr,Boolean migrationf,record HansaVersionVc HVr)
begin
  Boolean res,foundf;
  record CloudNodeVc CN2r;
  string 255 idxname;

  if (migrationf==true) then begin
    idxname = "ActiveMigrServers";
  end else begin
    if (IsTestUser(emailaddr) or IsTestBuildVersion(HVr.Code)) then begin
      idxname = "ActiveTestAutoServers";
    end else begin
      idxname = "ActiveAutoServers";
    end;
  end;

  foundf = true;
  while (LoopKey(idxname,CN2r,1,foundf)) begin
    if (CN2r.MaxCapacity>ServerCntOnCN(CN2r)) then begin
      res = true;
      RecordCopy(CNr,CN2r);
      goto LGetExistingNodeForNewAutoServer;
    end;
  end;

LGetExistingNodeForNewAutoServer:;
  GetExistingNodeForNewAutoServer = res;
  return;
end;

global
updating procedure TakeHostFromPool(record CloudNodeVc CNr,Integer nt)
begin
  record CloudNodeVc OldCNr;

  if (ReadFirstMain(CNr,1,true)==false) then begin goto LTakeHostFromPool; end;

  RecordCopy(OldCNr,CNr);
  CNr.HostPoolType = kHostPoolTypeNone;
  CNr.NodeType = nt;
  RecordUpdate(OldCNr,CNr,true);

LTakeHostFromPool:;
  return;
end;

function Boolean GetNodeFromHostPool(Integer hptype,var record CloudNodeVc CNr,Integer nt)
begin
  Boolean res,foundf;

  foundf = true;
  CNr.HostPoolType = hptype;
  while (LoopKey("HostPoolType",CNr,1,foundf)) begin
    if (CNr.HostPoolType!=hptype) then begin foundf = false; end;
    if (foundf==true) then begin
      qupdating.TakeHostFromPool(CNr,nt);
      res = true;
      goto LGetNodeFromHostPool;
    end;
  end;

LGetNodeFromHostPool:;
  GetNodeFromHostPool = res;
  return;
end;

global
function Boolean AssignNodeForNewAutoServer(string emailaddr,var record CloudNodeVc CNr,Boolean migrationf,record HansaVersionVc HVr)
begin
  LongInt cns,cnno;
  string 255 idxname;
  Boolean res;
  Boolean foundf;
  Integer nt;

  if (migrationf==true) then begin
    nt = kCloudNodeTypeMigrationCloud;
  end else begin
    if (IsTestUser(emailaddr) or IsTestBuildVersion(HVr.Code)) then begin
      nt = kCloudNodeTypeStandardCloudTest;
      LogText(0,"AssignNodeForNewAutoServer is attempting to allocate node for testing");
    end else begin
      nt = kCloudNodeTypeStandardCloud;
    end;
  end;

  res = GetExistingNodeForNewAutoServer(emailaddr,CNr,migrationf,HVr);
  if (res) then begin goto LAssignNodeForNewAutoServer; end;

  res = GetNodeFromHostPool(kHostPoolTypeShared,CNr,nt);
  if (res) then begin goto LAssignNodeForNewAutoServer; end;

  goto LAssignNodeForNewAutoServer;

LAssignNodeForNewAutoServer_Random:; // Old method (random) not used any longer
  cns = RecordsInIndex("CloudNodeVc",idxname);
  if (cns==0) then begin goto LAssignNodeForNewAutoServer; end;
  cnno = Random(1,cns);

  LogText2(0,"AssignNodeForNewAutoServer cns=" & cns & ", cnno=" & cnno,kVerbosityDebugDetailed);

  if (ReadLogicalKey(CNr,idxname,cnno)==false) then begin
    LogText(0,"ERROR: Failed to find available node for autoserver");
    goto LAssignNodeForNewAutoServer;
  end;
  res = true;

LAssignNodeForNewAutoServer:;
  AssignNodeForNewAutoServer = res;
  return;
end;

global
function string 255 CreateServer(Integer version,Integer subversion,Integer prot_version,Integer running_build,record CUVc CUr,var string errorstr,var Area a_setuptb,Integer program_type,string product_code,string product_version,string country_localizations,var Integer status)
begin
  record CloudNodeVc CNr;
  record HansaVersionVc HVr;
  string 255 logprefix;
  LongInt server_port,http_port,https_port;
  LongInt stat;
  uuid serverid;
  Boolean testf;

  logprefix = "CreateServer " & CUr.Name & " ";
  status = 0;

  if (FindProductHansaVersion(version,subversion,prot_version,running_build,product_version,program_type,
                              product_code,false,errorstr,HVr,IsTestUser(CUr.eMail))==false) then begin
    status = 3;
    LogText(0,logprefix & errorstr);
    goto LCreateServer;
  end;

  testf = AssignNodeForNewAutoServer(CUr.eMail,CNr,false,HVr);
  if (testf==false) then begin
    status = 2;
    LogText(0,"CreateServer failed to assign node for new autoserver, e-mail=" & CUr.eMail & ", version=" & HVr.Code);

    goto LCreateServer;
  end;

  serverid = MakeUUID;
  stat = CallService(NodeURL(CNr)).StoreSetupTB(serverid,a_setuptb);
  // TODO: handle errors

  qupdating.CreateRemoteServer(serverid,CNr,HVr,CUr,errorstr,server_port,http_port,https_port,country_localizations);
  SyncRCSDataWithOneCN(CNr,true,true);
//  StartImportOnRCS(serverid,"AUTOSETUP.TXT");
  
  if (errorstr<>"") then begin
    status = 4; // unknown error
    LogText(0,logprefix & "CreateLocalServer failed on node " & CNr.Code & " and error: " & errorstr);
  end;

  CreateServer = serverid;

LCreateServer:;
  LogText(0,logprefix & "done with status=" & status & ", serverid=" & serverid);
end;

global
procedure GetCloudNodeStats(var record CloudMachineStatsVc CMSr)
begin
  Integer is64bit;

  CMSr.ServerDiskFree = GetDiskSpace(ServersFolder,CMSr.ServerDiskTotal);

  GetSystemStatistics(CMSr.SampleSeconds,CMSr.UserCPUTime,CMSr.SystemCPUTime,
                      CMSr.IOWaitCPUTime,CMSr.DiskIORead,CMSr.DiskIOWrite,
                      CMSr.MemTotal,CMSr.MemUsed,CMSr.MemBuffers,CMSr.SwapUsed,CMSr.SwapFree);
  CMSr.HostName = LocalHostName;
  CMSr.VersionBuild = VersionBuild;
  if (GetGlobalBoolean("En64BitOS")) then begin is64bit = 1; end;
  CMSr.Is64BitFlag = is64bit;

  return;
end;

global
updating procedure UpdateNodeHostName(record CloudNodeVc CNr,string hostname)
begin
  record CloudNodeVc OldCNr;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);
  CNr.HostName = hostname; // should be the right thing to do
  RecordUpdate(OldCNr,CNr,true);
end;

function string 255 SignAmazonRequestPath(string server,string apath,string payloadchksum,string region,string service,string accesskeyid,string accesskey,string sessiontoken)
begin
  string 255 res,timestamp,today,credentials_scope,credentials;
  string 255 query,path,arg,item,cquery,canonicalrequest,pathpart;
  string 255 hashedrequest,stringtosign,k1,k2,k3,k4,key,signature;
  date dtoday;
  time tnow;
  array string 255 argkeys;
  vector string 255 argsvec;
  Integer pos,i,off;
  LongInt argpos,valpos;

  UTCTimeToDate(CurrentUnixUTCTime,dtoday,tnow);
  today = DateToString(dtoday,"YYYYMMDD");
  timestamp = today & "T" & TimeToString(tnow,"HHMMSS",false) & "Z";

  credentials_scope = today & "/" & region & "/" & service & "/aws4_request";
  credentials = accesskeyid & "/" & credentials_scope;

  AddHeaderForSignature(argkeys,argsvec,"X-Amz-Date",timestamp);
  AddHeaderForSignature(argkeys,argsvec,"X-Amz-Expires","300");
  AddHeaderForSignature(argkeys,argsvec,"X-Amz-Credential",credentials);
  AddHeaderForSignature(argkeys,argsvec,"X-Amz-Algorithm","AWS4-HMAC-SHA256");
  AddHeaderForSignature(argkeys,argsvec,"X-Amz-SignedHeaders","host");
  if (nonblank(sessiontoken)) then begin
    AddHeaderForSignature(argkeys,argsvec,"X-Amz-Security-Token",sessiontoken);
  end;

  path = apath;
  pos = InString(path,"?");
  if (pos>0) then begin
    query = mid(path,pos,len(path)-pos);
    path = mid(path,0,pos-1);
  end;

  if (Left(path,1)=="/") then begin off = 1; end;
  path = URLEncode(mid(path,off,len(path)-off));
  path = "/" & ReplaceStringWithString(path,"%2F","/");

  while (GetNextSubstring(query,argpos,"&",arg)) begin
    valpos = -1;
    GetNextSubstring(arg,valpos,"=",item);
    argkeys[argkeys.length] = item;
    GetNextSubstring(arg,valpos,"=",item);
    argsvec[argkeys[argkeys.length-1]] = item;
  end;
  SortStringArray(argkeys);
  for (i = 0; i<argkeys.length; i = i + 1) begin
    if (i>0) then begin
      cquery = cquery & "&";
    end;
    cquery = cquery & URLEncode(argkeys[i]) & "=";
    cquery = cquery & URLEncode(argsvec[argkeys[i]]);
  end;

  canonicalrequest = "GET" & chr(10);
  canonicalrequest = canonicalrequest & path & chr(10);
  canonicalrequest = canonicalrequest & cquery & chr(10);
  canonicalrequest = canonicalrequest & LowerCase("host:" & server) & chr(10);
  canonicalrequest = canonicalrequest & chr(10);
  canonicalrequest = canonicalrequest & "host" & chr(10);
  if (blank(payloadchksum)) then begin
    canonicalrequest = canonicalrequest & LowerCase(SHA256StringToHex(""));
  end else begin
    canonicalrequest = canonicalrequest & payloadchksum;
  end;

  hashedrequest = LowerCase(SHA256StringToHex(canonicalrequest));

  stringtosign = "AWS4-HMAC-SHA256" & chr(10);
  stringtosign = stringtosign & timestamp & chr(10);
  stringtosign = stringtosign & credentials_scope & chr(10);
  stringtosign = stringtosign & hashedrequest;

  k1 = "AWS4" & accesskey;
  k2 = HMACSHA256StringBin(k1,today);
  k3 = HMACSHA256StringBin(k2,region);
  k4 = HMACSHA256StringBin(k3,service);
  key = HMACSHA256StringBin(k4,"aws4_request");

  signature = LowerCase(HMACSHA256StringHex(key,stringtosign));
  res = path & "?" & cquery & "&X-Amz-Signature=" & signature;
  SignAmazonRequestPath = res;
  return;
end;

function Boolean GetAmazonSessionToken(string region,string accesskeyid,string accesskey,var string tempaccesskeyid,var string tempaccesskey,var string sessiontoken)
begin
  string 255 service,server,path;
  Boolean res;
  area a_req,a_reply;
  xml x_reply;

  service = "sts";
  server = service & "." & region & ".amazonaws.com";
  path = "?Version=2011-06-15&Action=GetSessionToken&DurationSeconds=3600";
  path = SignAmazonRequestPath(server,path,"",region,service,accesskeyid,accesskey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    sessiontoken = XmlGet(x_reply,"GetSessionTokenResponse/GetSessionTokenResult/Credentials/SessionToken");
    tempaccesskeyid = XmlGet(x_reply,"GetSessionTokenResponse/GetSessionTokenResult/Credentials/AccessKeyId");
    tempaccesskey = XmlGet(x_reply,"GetSessionTokenResponse/GetSessionTokenResult/Credentials/SecretAccessKey");
  end else begin
    LogText(0,"FAILED TO GET STS SESSION TOKEN " & path);
  end;

  GetAmazonSessionToken = res;
  return;
end;

global procedure AmazonLogErrorResponse(string fn, xml x_reply)
begin
  string 255 key1;
  Integer i;

  key1 = "Response/Errors";
  while (XmlNodeExists(x_reply,key1 & "[" & i & "]")) begin
    LogText(0,"ERROR: " & fn & " " & XmlGet(x_reply,key1 & "[" & i & "]/Error/Message"));
    i = i + 1;
  end;

  return;
end;

function string 255 GetAmazonInstanceAddress(record HostingConfigurationVc HCr,record CloudNodeVc CNr)
begin
  string 255 service,region,server,path,address;
  Boolean res;
  area a_req,a_reply;
  xml x_reply;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeInstances";
  path = path & "&Filter.1.Name=instance-id";
  path = path & "&Filter.1.Value.1=" & CNr.AmazonInstanceId;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("GetAmazonInstanceAddress()",x_reply);
    address = XmlGet(x_reply,"DescribeInstancesResponse/reservationSet/item/instancesSet/item/ipAddress");
  end else begin
    LogText(0,"FAILED TO GET EC2 IP ADDRESS " & path);
  end;

  GetAmazonInstanceAddress = address;
  return;
end;

function string 255 SetAmazonInstanceAddress(record HostingConfigurationVc HCr,record CloudNodeVc CNr,string address)
begin
  string 255 service,region,server,path,domain,allocationid,tstr;
  Boolean res;
  area a_req,a_reply;
  xml x_reply;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeAddresses";
  path = path & "&Filter.1.Name=public-ip";
  path = path & "&Filter.1.Value.1=" & address;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("SetAmazonInstanceAddress()",x_reply);
    domain = XmlGet(x_reply,"DescribeAddressesResponse/addressesSet/item/domain");
    switch (domain) begin
      case "standard":
      case "vpc":       allocationid = XmlGet(x_reply,"DescribeAddressesResponse/addressesSet/item/allocationId");
      otherwise
        LogText(0,"FAILED TO DESCRIBE EC2 IP ADDRESS " & path);
        LogText2(0,GetStringFromArea(a_reply,0,GetAreaLength(a_reply)),kVerbositySilent);
    end;
  end else begin
    LogText(0,"FAILED TO DESCRIBE EC2 IP ADDRESS " & path);
    LogText2(0,GetStringFromArea(a_reply,0,GetAreaLength(a_reply)),kVerbosityDebugDetailed);
    goto LSetAmazonInstanceAddress;
  end;

  path = "?Action=AssociateAddress";
  switch (domain) begin
    case "standard":  path = path & "&PublicIp=" & address;
    case "vpc":       path = path & "&AllocationId=" & allocationid;
  end;
  path = path & "&InstanceId=" & CNr.AmazonInstanceId;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("SetAmazonInstanceAddress()",x_reply);
    tstr = XmlGet(x_reply,"AssociateAddressResponse/return");
    if (tstr!="true") then begin
      LogText(0,"FAILED TO ASSOCIATE EC2 IP ADDRESS " & path);
      LogText2(0,GetStringFromArea(a_reply,0,GetAreaLength(a_reply)),kVerbositySilent);
    end;
  end else begin
    LogText(0,"FAILED TO ASSOCIATE EC2 IP ADDRESS " & path);
  end;

LSetAmazonInstanceAddress:;
  SetAmazonInstanceAddress = address;
  return;
end;

function string 255 AmazonLocationToRegion(string location)
begin
  string 255 res;

  switch(location) begin
//case "AWS GovCloud (US)":
    case "Asia Pacific (Mumbai)":     res = "ap-south-1";
    case "Asia Pacific (Seoul)":      res = "ap-northeast-2";
    case "Asia Pacific (Singapore)":  res = "ap-southeast-1";
    case "Asia Pacific (Sydney)":     res = "ap-southeast-2";
    case "Asia Pacific (Tokyo)":      res = "ap-northeast-1";
    case "EU (Frankfurt)":            res = "eu-central-1";
    case "EU (Ireland)":              res = "eu-west-1";
    case "South America (Sao Paulo)": res = "sa-east-1";
    case "US East (N. Virginia)":     res = "us-east-1";
    case "US East (Ohio)":            res = "us-east-2";
    case "US West (N. California)":   res = "us-west-1";
    case "US West (Oregon)":          res = "us-west-2";
  end;

  AmazonLocationToRegion = res;
  return;
end;

global
function string 255 AmazonRegionToLocation(string region)
begin
  string 255 res;

  switch(region) begin
//case "AWS GovCloud (US)":
    case "ap-south-1":      res = "Asia Pacific (Mumbai)";
    case "ap-northeast-2":  res = "Asia Pacific (Seoul)";
    case "ap-southeast-1":  res = "Asia Pacific (Singapore)";
    case "ap-southeast-2":  res = "Asia Pacific (Sydney)";
    case "ap-northeast-1":  res = "Asia Pacific (Tokyo)";
    case "eu-central-1":    res = "EU (Frankfurt)";
    case "eu-west-1":       res = "EU (Ireland)";
    case "sa-east-1":       res = "South America (Sao Paulo)";
    case "us-east-1":       res = "US East (N. Virginia)";
    case "us-east-2":       res = "US East (Ohio)";
    case "us-west-1":       res = "US West (N. California)";
    case "us-west-2":       res = "US West (Oregon)";
  end;

  AmazonRegionToLocation = res;
  return;
end;

procedure GetNextCommaSepField(string instr,var LongInt pos,var string res)
begin
  string 255 tstr;

  GetNextSubstring(instr,pos,",",tstr);
  res = tstr;
  while ((len(tstr)>0) and right(tstr,1)!="\"") begin
    GetNextSubstring(instr,pos,",",tstr);
    res = res & "," & tstr;
  end;
  res = mid(res,1,len(res)-2);

  return;
end;

global
updating function Boolean ClearAmazonEC2PriceList()
begin
  record AmazonEC2PriceListVc AEPLr;
  Boolean res;
  Integer i;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LClearAmazonEC2PriceList; end;

  DBHold;
  while (LoopMain(AEPLr,1,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LClearAmazonEC2PriceList; end;
    RecordDelete(AEPLr);
    StepBack(AEPLr);
    i = i + 1;
    if (i>1000) then begin
      DBFlush;
      goto LClearAmazonEC2PriceList;
    end;
  end;
  DBFlush;
  res = true;

LClearAmazonEC2PriceList:;
  ClearAmazonEC2PriceList = res;
  return;
end;


global
updating procedure StoreAmazonEC2PriceListRec(record AmazonEC2PriceListVc AEPLr)
begin
  record AmazonEC2PriceListVc OldAEPLr,AEPL2r;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LStoreAmazonEC2PriceListRec; end;

  RecordCopy(AEPL2r,AEPLr);
  if (ReadFirstMain(AEPL2r,1,true)) then begin
    RecordCopy(OldAEPLr,AEPL2r);
    RecordUpdate(OldAEPLr,AEPLr,true);
  end else begin
    RecordStore(AEPLr,false);
  end;

LStoreAmazonEC2PriceListRec:;
  return;
end;

procedure UpdateAmazonEC2PriceList()
begin
  string 255 server,path,tstr,t2;
  area a_req,a_reply;
  Boolean res,dataf;
  LongInt lines,i,pos;
  record AmazonEC2PriceListVc AEPLr;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LUpdateAmazonEC2PriceList; end;

  server = "pricing.us-east-1.amazonaws.com";
  path = "/offers/v1.0/aws/AmazonEC2/current/index.csv";

  LogText(0,"Clearing Amazon EC2 price list")
  while (qupdating.ClearAmazonEC2PriceList==false) begin Sleep(1); end;

  LogText(0,"Building Amazon EC2 price list")
/*
  res = SendWebRequest(server,443,-1,true,"GET",path,"","",false,a_req,a_reply,20);
  if (!res) then begin
    LogText(0,"FAILED TO GET EC2 PRICE LIST");
    goto LUpdateAmazonEC2PriceList;
  end;
  lines = CountLinesInArea(a_reply);*/

  if (RunOneLineOutCommand("curl -Sls https://" & server & path & ">tmp/offers.csv",tstr)) then begin
    AddFileToArea("tmp/offers.csv",a_reply,false);
  end else begin
    LogText(0,"FAILED TO GET EC2 PRICE LIST");
    goto LUpdateAmazonEC2PriceList;
  end;

  for (i = 0; i<9999999; i = i + 1) begin
    tstr = GetLineFromArea(a_reply,i);
    if (!dataf) then begin
      if (Left(tstr,5)=="\"SKU\"") then begin dataf = true; end;
    end else begin
      if (tstr=="") then begin
        goto LUpdateAmazonEC2PriceList;
      end;
      RecordClear(AEPLr);
      pos = -1;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.SKU = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.OfferTermCode = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.RateCode = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.TermType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PriceDescription = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.EffectiveDate = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.StartingRange = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.EndingRange = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Unit = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PricePerUnit = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Currency = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.LeaseContractLength = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PurchaseOption = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.OfferingClass = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ProductFamily = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.serviceCode = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Location = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.LocationType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.CurrentGeneration = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceFamily = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.vCPU = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PhysicalProcessor = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ClockSpeed = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Memory = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Storage = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.NetworkPerformance = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ProcessorArchitecture = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.StorageMedia = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.VolumeType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.MaxVolumeSize = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.MaxIOPSvolume = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.MaxIOPSBurstPerformance = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Maxthroughputvolume = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Provisioned = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Tenancy = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.EBSOptimized = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.OperatingSystem = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.LicenseModel = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Group = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.GroupDescription = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.TransferType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.FromLocation = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.FromLocationType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ToLocation = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ToLocationType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.usageType = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.operation = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.DedicatedEBSThroughput = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.EnhancedNetworkingSupported = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.GPU = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacity10xlarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacity2xlarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacity4xlarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacity8xlarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacitylarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacitymedium = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.InstanceCapacityxlarge = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.IntelAVXAvailable = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.IntelAVX2Available = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.IntelTurboAvailable = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PhysicalCores = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.PreInstalledSW = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.ProcessorFeatures = t2;
      GetNextCommaSepField(tstr,pos,t2); AEPLr.Sockets = t2;
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LUpdateAmazonEC2PriceList; end;
      qupdating.StoreAmazonEC2PriceListRec(AEPLr);
    end;
  end;

LUpdateAmazonEC2PriceList:;
  LogText(0,"Added " & i & " price list records");
  return;
end;

global
updating procedure StoreAmazonInstanceListRec(record AmazonInstanceListVc AILr)
begin
  record AmazonInstanceListVc OldAILr,AIL2r;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LStoreAmazonInstanceListRec; end;

  RecordCopy(AIL2r,AILr);
  if (ReadFirstKey("InstanceId",AIL2r,1,true)) then begin
    RecordCopy(OldAILr,AIL2r);
    RecordUpdate(OldAILr,AILr,true);
  end else begin
    RecordStore(AILr,false);
  end;

LStoreAmazonInstanceListRec:;
  return;
end;

global
updating function Boolean ClearAmazonInstanceList()
begin
  record AmazonInstanceListVc AILr;
  Integer i;
  Boolean res;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LClearAmazonInstanceList; end;

  DBHold;
  while (LoopMain(AILr,1,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LClearAmazonInstanceList; end;
    RecordDelete(AILr);
    StepBack(AILr);
    i = i + 1;
    if (i>1000) then begin
      DBFlush;
      goto LClearAmazonInstanceList;
    end;
  end;
  DBFlush;
  res = true;

LClearAmazonInstanceList:;
  ClearAmazonInstanceList = res;
  return;
end;

procedure UpdateAmazonInstanceList()
begin
  string 255 service,region,server,path,tstr,xkey1,xkey2,xkey3;
  Boolean res;
  area a_req,a_reply;
  xml x_reply;
  LongInt cnt,cnt2,i,i2;
  record AmazonInstanceListVc AILr;
  record HostingConfigurationVc HCr;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LUpdateAmazonInstanceList; end;

  LogText(0,"Clearing Amazon instance list")
  while (qupdating.ClearAmazonInstanceList==false) begin Sleep(1); end;

  LogText(0,"Building Amazon instance list")
  while (LoopMain(HCr,1,true)) begin
    if (HCr.Closed==0 and HCr.HostingType==kHostingTypeAmazon and nonblank(HCr.AmazonAccessKeyID) and nonblank(HCr.AmazonSecretAccessKey)) then begin
      SetAreaZeroSize(a_req);
      SetAreaZeroSize(a_reply);

      service = "ec2";
      region = HCr.AmazonRegion;
      server = service & "." & region & ".amazonaws.com";

      path = "?Action=DescribeInstances";
      path = path & "&Filter.1.Name=instance-state-name";
      path = path & "&Filter.1.Value.1=running";
      path = path & "&Filter.1.Name=availability-zone";
      path = path & "&Filter.1.Value.1=" & HCr.AmazonZone;
      path = path & "&Version=2015-10-01";
      path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

      res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
      if (!res) then begin
        LogText(0,"FAILED TO GET EC2 INSTANCE LIST " & path);
        goto LUpdateAmazonInstanceList;
      end;
/*
Delete_file("all_instances-" & HCr.AmazonZone & ".txt");
WriteAreaToFile(a_reply,"all_instances-" & HCr.AmazonZone & ".txt",0);
*/
      x_reply = ParseXmlArea(a_reply);
      AmazonLogErrorResponse("UpdateAmazonInstanceList()",x_reply);
      i = 0;
      xkey1 = "DescribeInstancesResponse/reservationSet/item";
      while (XmlNodeExists(x_reply,xkey1 & "[" & i & "]")) begin
        i2 = 0;
        xkey2 = xkey1 & "[" & i & "]/instancesSet/item";
        while (XmlNodeExists(x_reply,xkey2 & "[" & i2 & "]")) begin
          if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LUpdateAmazonInstanceList; end;
          if (XmlGet(x_reply,xkey2 & "[" & i2 & "]/instanceState/name")=="running") then begin
            RecordClear(AILr);
            AILr.AvailabilityZone = XmlGet(x_reply,xkey2 & "[" & i2 & "]/placement/availabilityZone");
            AILr.InstanceType = XmlGet(x_reply,xkey2 & "[" & i2 & "]/instanceType");
            AILr.Platform = XmlGet(x_reply,xkey2 & "[" & i2 & "]/platform");
            AILr.Tenancy = XmlGet(x_reply,xkey2 & "[" & i2 & "]/placement/tenancy");
            AILr.InstanceId = XmlGet(x_reply,xkey2 & "[" & i2 & "]/instanceId");
            qupdating.StoreAmazonInstanceListRec(AILr);
          end;
          i2 = i2 + 1;
        end;
        i = i + 1;
      end;
    end;
  end;

LUpdateAmazonInstanceList:;
  LogText(0,"Added " & i & " instance list records");
  return;
end;

global
procedure UpdateAmazonCostStats()
begin
  UpdateAmazonInstanceList;
  UpdateAmazonEC2PriceList;
  return;
end;

global
procedure UpdateAmazonCostStatsTask(string args)
begin
  date td;

  LogText(0,"Monthly update of Amazon Cost Statistics")
  UpdateAmazonCostStats;

  td = CurrentDate;
  td.day = 1;
  if (td<CurrentDate) then begin
    AddMonth(td,1);
  end else begin
    if (td==CurrentDate) then begin
      if (CurrentTime>StringToTime("02:00:00")) then begin
        td = AddMonth(td,1);
      end;
    end;
  end;
  RemoveTask("UpdateAmazonCostStatsTask");
  NewTimedTask2("UpdateAmazonCostStatsTask","Update Amazon Cost Statistics","UpdateAmazonCostStatsTask","",td,"02:00:00","","");

  return;
end;

global
procedure EC2CheckElasticIP(record CloudNodeVc CNr)
begin
  record HostingConfigurationVc HCr;
  string 255 cmd,tstr;

  ReadFirstMain(CNr,1,true);

  if (GetGlobalBoolean("EC2CheckElasticIP-" & CNr.Code)==true) then begin
    goto LEC2CheckElasticIP;
  end;
  SetGlobalBoolean("EC2CheckElasticIP-" & CNr.Code,true);

  if (nonblank(CNr.HostingConfig) and nonblank(CNr.AmazonElasticIP) and nonblank(CNr.AmazonInstanceId)) then begin
    HCr.SerNr = CNr.HostingConfig;
    if (ReadFirstMain(HCr,1,true)) then begin
      if (HCr.HostingType==kHostingTypeAmazon and nonblank(HCr.AmazonAccessKeyID) and nonblank(HCr.AmazonSecretAccessKey)) then begin
        tstr = GetAmazonInstanceAddress(HCr,CNr);
        if (nonblank(tstr)) then begin
          if (nonblank(tstr) and (tstr!=CNr.AmazonElasticIP) and nonblank(CNr.AmazonElasticIP)) then begin
            SetAmazonInstanceAddress(HCr,CNr,CNr.AmazonElasticIP);
            SetCloudControllerStatus(kJobStatusRunning,"Changing address of node " & CNr.Code & " to elastic IP " & CNr.AmazonElasticIP);
            LogText(0,"Address of node " & CNr.Code & " changed to elastic IP " & CNr.AmazonElasticIP);
            queued.UpdateNodeHostName(CNr,CNr.AmazonElasticIP);
          end;
        end;
      end;
    end;
  end;

  SetGlobalBoolean("EC2CheckElasticIP-" & CNr.Code,false);
LEC2CheckElasticIP:;
  return;
end;

function string 255 DayShort(date d)
begin
  string 255 res;

  res = UsetStr(2200+GetDateId(d));

  DayShort = res;
  return;
end;

global
updating procedure DoEC2RefreshIP_Update(record CloudNodeVc CN2r)
begin
  record CloudNodeVc CNr;
  record CloudNodeVc OldCNr;

  CNr.Code = CN2r.Code;
  if (ReadFirstMain(CNr,1,true)) then begin
    RecordCopy(OldCNr,CNr);
    CNr.HostName = CN2r.HostName;
    CNr.AmazonElasticIP = CN2r.AmazonElasticIP;
    RecordUpdate(OldCNr,CNr,true);
  end;
end;

global
procedure EC2RefreshIP(record CloudNodeVc CNr)
begin
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr;
  string 255 cmd,tstr;
  array string 255 instancesarr;

  if (GetGlobalBoolean("EC2RefreshIP-" & CNr.Code)==true) then begin
    goto LEC2RefreshIP99;
  end;

  SetGlobalBoolean("EC2RefreshIP-" & CNr.Code,true);

  if (ReadFirstMain(CNr,1,true)) then begin end;
  RecordCopy(OldCNr,CNr);

  switch (CNr.CurrentState) begin
    case kCloudNodeStateStopping:     goto LEC2RefreshIP80;
    case kCloudNodeStateStopped:      goto LEC2RefreshIP80;
    case kCloudNodeStateUnknown:      goto LEC2RefreshIP80;
    case kCloudNodeStateTerminating:  goto LEC2RefreshIP80;
    case kCloudNodeStateModifying:    goto LEC2RefreshIP80;
    case kCloudNodeStateMoving:       goto LEC2RefreshIP80;
  end;

  if (nonblank(CNr.HostingConfig) and blank(CNr.AmazonElasticIP) and nonblank(CNr.AmazonInstanceId)) then begin
    HCr.SerNr = CNr.HostingConfig;
    if (ReadFirstMain(HCr,1,true)) then begin
      if (HCr.HostingType==kHostingTypeAmazon and nonblank(HCr.AmazonAccessKeyID) and nonblank(HCr.AmazonSecretAccessKey)) then begin
        if (AmazonDescribeAddresses(HCr,CNr.HostName,instancesarr)) then begin
          if (instancesarr.length==1) then begin
            CNr.AmazonElasticIP = CNr.HostName;
          end else begin
            if (AmazonGetInstancePublicIP(HCr,CNr.AmazonInstanceId,tstr)) then begin
              if (nonblank(tstr) and (tstr!=CNr.HostName)) then begin
                SetCloudControllerStatus(kJobStatusRunning,"Address change of node " & CNr.Code & " detected, new non-elastic IP is " & tstr);
                LogText(0,"Address change of node " & CNr.Code & " detected, new non-elastic IP is " & tstr);
                CNr.HostName = tstr;
              end;
            end;
          end;
        end;
      end;
    end;
  end;

  qupdating.DoEC2RefreshIP_Update(CNr);

LEC2RefreshIP80:;
  SetGlobalBoolean("EC2RefreshIP-" & CNr.Code,false);
LEC2RefreshIP99:;
  return;
end;

global
procedure GetActiveUsers(var array string active_usersarr,var array string active_keysarr)
begin
  string 255 username,key;
  LongInt keypos;

  while (ReadUserKey(keypos,username,key)) begin
  if (nonblank(key) and nonblank(username)) then begin
    active_usersarr[active_usersarr.length] = username;
    active_keysarr[active_keysarr.length] = key;
  end;
end;

  return;
end;

global
procedure GetClosedUsers(var array string res)
begin
  record UserVc USr;

  while (LoopMain(USr,1,true)) begin
    if (USr.SSHClosed!=0) then begin
      if (nonblank(USr.SSHUsername)) then begin
        res[res.length] = USr.SSHUsername;
      end;
    end;
  end;

  return;
end;

global
updating procedure InitNodeAtCN(string cncode,array record UserVc userarr,string cchost,LongInt ccport,
                                LongInt cchttpport,LongInt cchttpsport,LongInt hostingpartner)
begin
  record CloudSettingsBlock CSb;
  record ModuleBlock Modr;
  record BackupBlock Bbl;

  BlockLoad(Modr);
  Modr.NumberOfUsers = 999;
  Modr.Mailboxes = 999;
  Modr.MultiIntServEnabler = 1;
  Modr.ASPEnabler = 1;
  Modr.BrowseFiltering = 1;
  Modr.UpdWebWhileRep = 1;
  Modr.ReportParaType = kReportParallelityMultiThread;
  Modr.MultiClientImport = 1;
  Modr.ReportSlots = 10;        // default is 2
  Modr.WebRequestThreads = 10;  // default is 3
  Modr.HTTPThreads = 10;        // default is 0, max is 20
  Modr.ServerEnabler = 1;
  BlockStore(Modr);

  BlockLoad(CSb);
  CSb.NodeCode = cncode;
  CSb.CCAddr = trim(cchost);
  CSb.CCPort = ccport;
  CSb.CCHTTPPort = cchttpport;
  CSb.CCHTTPSPort = cchttpsport;
  CSb.HostingPartner = hostingpartner;
  BlockStore(CSb);

  BlockLoad(Bbl);
  Bbl.ContDBCopyf = 1;
  Bbl.ContDBCopyMinDelay = 240; //copy hdb every 4 hours
  BlockStore(Bbl);

  return;
end;

function
string 255 LocalToolFolder()
begin
  if (ProgramPlatform==kPlatformLinux32 or ProgramPlatform==kPlatformLinux64) then begin
    LocalToolFolder = "/usr/local/bin";
  end;
end;

global
procedure GetLocalTool(string tool,var area toolarea)
begin
  string 255 toolpath;

  toolpath = LocalToolFolder & "/" & tool;
  if (FileExists(toolpath)) then begin
    LoadFileToArea(toolpath,0,FileSize2(toolpath),toolarea);
  end;
end;

procedure UpdateLocalTool(string tool)
begin
  record CloudSettingsBlock CSb;
  string 255 cncode,url,toolpath;
  LongInt stat;
  area toolarea;

  if (IsCloudController) then begin goto LUpdateLocalTool; end;

  toolpath = LocalToolFolder & "/" & tool;
  if (FileExists(toolpath)) then begin goto LUpdateLocalTool; end;

  BlockLoad(CSb);
  cncode = CSb.NodeCode;
  url = Trim(CSb.CCAddr) & ":" & CSb.CCHTTPSPort;
  stat = CallService(url).GetLocalTool(tool,toolarea);
  if (TreatServiceError(stat,url,"GetLocalTool")) then begin
    goto LUpdateLocalTool;
  end;

  if (GetAreaLength(toolarea)==0) then begin goto LUpdateLocalTool; end;
  WriteAreaToFile(toolarea,toolpath,0);
  RunShellScript("chmod +x """ & toolpath & """");

LUpdateLocalTool:;
end;

procedure UpdateLocalTools()
begin
  if (ProgramPlatform==kPlatformLinux32 or ProgramPlatform==kPlatformLinux64) then begin
    //CreateFolderHierarchy(LocalToolFolder);
    //UpdateLocalTool("smem");
  end;
end;

global
updating procedure InitNodeAtCN2(string cncode,array record UserVc userarr,string cchost,LongInt ccport,
                                 LongInt cchttpport,LongInt cchttpsport,LongInt hostingpartner,
                                 array string active_usersarr,array string active_keysarr,array string closed_usersarr)
begin
  LogText(0,"Initializing cloud node");
  InitNodeAtCN(cncode,userarr,cchost,ccport,cchttpport,cchttpsport,hostingpartner);

  ActivateUsers(cncode,active_usersarr,active_keysarr);
  DeactivateUsers(cncode,closed_usersarr);
  UpdateLocalTools;

  LogText(0,"Initialized cloud node");
  return;
end;

global
procedure InitNode(record CloudNodeVc CNr)
begin
  string 255 url;
  LongInt stat;
  array record UserVc userarr; //not used
  record CloudSettingsBlock CSb;
  array string 255 closed_usersarr,active_usersarr,active_keysarr;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LInitNode; end;

  if (CNr.VersionBuild<81300008) then begin
    goto LInitNode;
  end;

  switch (CNr.CurrentState) begin
    case kCloudNodeStateCreating:     goto LInitNode;
    case kCloudNodeStateStopping:     goto LInitNode;
    case kCloudNodeStateStopped:      goto LInitNode;
    case kCloudNodeStateStarting:     goto LInitNode;
    case kCloudNodeStateTerminating:  goto LInitNode;
    case kCloudNodeStateMoving:       goto LInitNode;
    case kCloudNodeStateModifying:    goto LInitNode;
  end;

  BlockLoad(CSb);
  LogText(0,"Initializing node " & CNr.Code);
  url = NodeURL(CNr);
  if (CNr.VersionBuild<83090019) then begin
    stat = CallService(url).InitNodeAtCN(CNr.Code,userarr,PublicHostName,ServerTCPPort,ServerHttpPort,ServerHttpsPort,CSb.HostingPartner);
  end else begin
    GetActiveUsers(active_usersarr,active_keysarr);
    GetClosedUsers(closed_usersarr);
    stat = CallService(url).InitNodeAtCN2(CNr.Code,userarr,PublicHostName,ServerTCPPort,ServerHttpPort,ServerHttpsPort,CSb.HostingPartner,active_usersarr,active_keysarr,closed_usersarr);
  end;
  if (TreatServiceError(stat,url,"InitNodeAtCN")) then begin
    LogText(0,"Failed to initialize CN " & CNr.Code);
    goto LInitNode;
  end;

LInitNode:;
  return;
end;

global
procedure InitAllNodes()
begin
  record CloudNodeVc CNr;

  LogText(0,"Initializing all cloud nodes");
  while (LoopMain(CNr,1,true)) begin
    if (CNr.Closed==0) then begin
      InitNode(CNr);
    end;
  end;
end;

global
procedure InitNodeAndGetHostingConfig(record CloudNodeVc CNr)
begin
  InitNode(CNr);
  GetOneNodeHostingConfig(CNr);
end;

global
updating procedure SaveCloudNodeStats(record CloudNodeVc CNr,record CloudMachineStatsVc CMSr,Boolean failf)
begin
  record CloudNodeVc OldCNr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Integer reachablef;
  Boolean foundf;
  Boolean reachability_changedf;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);

  if (failf==false) then begin reachablef = 1; end;
  if (reachablef!=CNr.ReachableFlag) then begin reachability_changedf = true; end;

  CMSr.ServerCode = CNr.Code;
  CMSr.Date = CurrentDate;
  CMSr.Time = CurrentTime;
  CMSr.ReachableFlag = reachablef;
  if ((CNr.FastCheckFlag==0) or (CloudNodeStatus(CNr)==kCloudNodeStatusReachable) or
      (CloudNodeStatus(CNr)==kCloudNodeStatusDifferentVersion) or reachability_changedf) then begin
    RecordStore(CMSr,false);
  end;

  CNr.LastCheckTime = CMSr.Time;
  CNr.LastCheckDate = CMSr.Date;
  CNr.ReachableFlag = reachablef;
  if (reachablef) then begin
    CNr.LastSeenTime = CMSr.Time;
    CNr.LastSeenDate = CMSr.Date;
    CNr.ServerDiskTotal = CMSr.ServerDiskTotal;
    CNr.ServerDiskFree = CMSr.ServerDiskFree;
    CNr.ServerDiskMaxUsed = MAX(CNr.ServerDiskMaxUsed,CNr.ServerDiskTotal-CNr.ServerDiskFree);
    if (CNr.ServerDiskMaxUsed>CNr.ServerDiskTotal) then begin
      CNr.ServerDiskMaxUsed = 0;
    end;
    CNr.VersionBuild = CMsr.VersionBuild;
    CNr.Is64BitFlag = CMsr.Is64BitFlag;
    if (CNr.CurrentState==kCloudNodeStateStarting) then begin
      CNr.CurrentState = kCloudNodeStateNormal;
    end;
  end else begin
    if (CNr.CurrentState!=kCloudNodeStateCreating) then begin
      RecordUpdate(OldCNr,CNr,true);
      ReadFirstMain(CNr,1,true);
      threadasync.EC2CheckElasticIP(CNr);
      //ReadFirstMain(CNr,1,true);
    end;
  end;

  switch (CloudNodeStatus(CNr)) begin
    case kCloudNodeStatusReachable: CNr.FastCheckFlag = 0;
    case kCloudNodeStatusClosed:    CNr.FastCheckFlag = 0;
    case kCloudNodeStatusUnreachable:       
      switch (CNr.CurrentState) begin
        case kCloudNodeStateCreating:     CNr.FastCheckFlag = 1;
        case kCloudNodeStateStopping:     CNr.FastCheckFlag = 0;
        case kCloudNodeStateStopped:      CNr.FastCheckFlag = 0;
        case kCloudNodeStateStarting:     CNr.FastCheckFlag = 1;
        case kCloudNodeStateTerminating:  CNr.FastCheckFlag = 0;
        case kCloudNodeStateMoving:       CNr.FastCheckFlag = 0;
        case kCloudNodeStateModifying:    CNr.FastCheckFlag = 0;
        otherwise CNr.FastCheckFlag = 1;
      end;
    case kCloudNodeStatusDifferentVersion:
      if (VersionBuild>CNr.VersionBuild) then begin
        CNr.FastCheckFlag = 1;
      end else begin
        CNr.FastCheckFlag = 0;
      end;
  end;

  RecordUpdate(OldCNr,CNr,true);

  if (SaveNodeReachableOnRCS) then begin
    RCSr.Controller = CNr.Code;
    foundf = true;
    while (LoopKey("Controller",RCSr,1,foundf)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeStats; end;
      if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
      if (foundf) then begin
        if (RCSr.Closed==0) then begin
          RecordCopy(OldRCSr,RCSr);
          if (reachablef) then begin
            RCSr.NodeReachableFlag = 1;
            RCSr.CurrentStatus = kStatusNone;
          end else begin
            RCSr.NodeReachableFlag = 0;
            RCSr.CurrentStatus = kStatusNodeUnreachable;
          end;
          if (OldRCSr.NodeReachableFlag!=RCSr.NodeReachableFlag) then begin
            RecordUpdate(OldRCSr,RCSr,true);
          end;
        end;
      end;
    end;

    ResetLoop(RCSr);
    RCSr.Controller = "";
    foundf = true;
    while (LoopKey("Controller",RCSr,1,foundf)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeStats; end;
      if (RCSr.Controller!="") then begin foundf = false; end;
      if (foundf) then begin
        if ((RCSr.Closed==0) and (RCSr.NewController==CNr.Code)) then begin
          RecordCopy(OldRCSr,RCSr);
          if (reachablef) then begin
            RCSr.NodeReachableFlag = 1;
            RCSr.CurrentStatus = kStatusNone;
          end else begin
            RCSr.NodeReachableFlag = 0;
            RCSr.CurrentStatus = kStatusNodeUnreachable;
          end;
          if (OldRCSr.NodeReachableFlag!=RCSr.NodeReachableFlag) then begin
            RecordUpdate(OldRCSr,RCSr,true);
          end;
        end;
      end;
    end;
  end;

  if (reachability_changedf and reachablef) then begin
    if (reachablef) then begin
      LogText2(0,"Calling InitNodeAndGetHostingConfig from SaveCloudNodeStats",kVerbosityDebug);
      threadasync.InitNodeAndGetHostingConfig(CNr);
      SetCloudControllerStatus(kJobStatusRunning,"Node " & CNr.Code & " is back online");
    end else begin
      SetCloudControllerStatus(kJobStatusError,"Node " & CNr.Code & " is unreachable");
    end;
  end;

LSaveCloudNodeStats:;
end;

global
procedure DoCheckCloudNode(record CloudNodeVc CNr)
begin
  record CloudMachineStatsVc CMSr;
  string 255 url;
  LongInt stat;
  Boolean failf;

  url = NodeURL(CNr);
  stat = CallService(url).GetCloudNodeStats(CMSr);
  failf = TreatServiceError(stat,url,"GetCloudNodeStats");
  queued.SaveCloudNodeStats(CNr,CMSr,failf);
end;

procedure CheckCloudNode(record CloudNodeVc CNr)
begin
  LongInt now,lastcheck;

  if (CNr.Closed!=0) then begin
    goto LCheckCloudNode;
  end;

  switch (CNr.CurrentState) begin
    case kCloudNodeStateCreating:     if (CNr.HansaPort<=0) then begin goto LCheckCloudNode; end;
    case kCloudNodeStateStopping:     goto LCheckCloudNode;
    case kCloudNodeStateStopped:      goto LCheckCloudNode;
    case kCloudNodeStateTerminating:  goto LCheckCloudNode;
    case kCloudNodeStateMoving:       goto LCheckCloudNode;
    case kCloudNodeStateModifying:    goto LCheckCloudNode;
  end;

  if (CNr.FastCheckFlag!=0) then begin
    goto LCheckCloudNode;
  end;

  now = TimeToMinutes(CurrentTime);
  lastcheck = TimeToMinutes(CNr.LastCheckTime);

  if (CNr.LastCheckDate<CurrentDate) then begin
    lastcheck = lastcheck - (24 * 60);
  end;
  
  if ((now - lastcheck)<5) then begin
    goto LCheckCloudNode;
  end;
  
  DoCheckCloudNode(CNr);

LCheckCloudNode:;
  return;
end;

global
procedure CheckCloudNodes(string args)
begin
  record CloudNodeVc CNr;
  Boolean foundf,testf;

  CNr.Closed = 0;
  foundf = true;
  while (LoopKey("State",CNr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LCheckCloudNodes; end;
    if (CNr.Closed!=0) then begin foundf = false; end;
    testf = foundf;
    if (testf and CNr.FastCheckFlag!=0) then begin testf = false; end;
    if (testf and CNr.ReachableFlag==0) then begin testf = false; end;
    if (foundf) then begin
      CheckCloudNode(CNr);
    end;
  end;

  UpdateClientBrowsesIfNeeded("CloudNodeVc");

LCheckCloudNodes:;
  return;
end;

function Boolean ArchiveRemovedServer(string FromDataFolder)
begin
  string 255 ServerUUIDStr,ServerFolderStr,ArchiveRootFolder,ArchiveToFolder;
  string 255 substr,parastr;
  LongInt pos;
  Boolean res;
  Integer i;
  date d;

  ServerFolderStr = FromDataFolder;
  while (GetNextSubstring(ServerFolderStr,pos,"/",substr)) begin
    ServerUUIDStr = substr;
  end;  
  
  ArchiveRootFolder = ServersFolder & "ToBeArchivedOrDeleted/";
  if (DirExists(ArchiveRootFolder)==false) then begin
    CreateFolder(ArchiveRootFolder);
  end; 
  if (DirExists(ArchiveRootFolder)==false) then begin
    res = false;
    LogText(0,"Failed To create Archive root folder: " & ArchiveRootFolder);
    goto LArchiveRemovedServer;
  end;

  d = CurrentDate;
  ArchiveToFolder = ArchiveRootFolder & ServerUUIDStr & "." & DateToString(d,"YYYYMMDD");
  while (DirExists(ArchiveToFolder)) begin
    i = i + 1;
    ArchiveToFolder = ArchiveRootFolder & ServerUUIDStr & "." & DateToString(d,"YYYYMMDD") & "-" & i;
  end;

  parastr = FromDataFolder & " " & ArchiveToFolder;
   
  res = MoveFile("/",FromDataFolder,ArchiveToFolder);
  MilliSleep(100);
  
  if (DirExists(ArchiveToFolder) and (DirExists(FromDataFolder)==false)) then begin
    res = true;
  end else begin
    res = false;
  end;
  if (res==false) then begin 
    LogText(0,"Failed to move folder : " & FromDataFolder & " to archived folder: " & ArchiveToFolder);
  end else begin
    LogText(0,"Successfully moved folder : " & FromDataFolder & " to archived folder: " & ArchiveToFolder);
  end;

LArchiveRemovedServer:;
  ArchiveRemovedServer = res;
  return;
end;

global
function Boolean DoRemoveServer(record LocalCloudServerVc LCSr)
begin
  Boolean res;

  res = false;
  if (DirExists(LCSr.DataFolder)==false) then begin
    res = true;
    goto LDoRemoveServer;
  end;
    
  if (nonblank(LCSr.DataFolder) and LCSr.Closed!=0) then begin
    res = ArchiveRemovedServer(LCSr.DataFolder);
  end;

LDoRemoveServer:;
  DoRemoveServer = res;
  return;
end;

global
updating procedure DoRemoveLCS(record LocalCloudServerVc LCSr)
begin
  RecordDelete(LCSr);
end;

global
updating procedure DoMarkLCSasMovedAway(uuid lcs_uuid)
begin
  record LocalCloudServerVc LCSr,OldLCSr;
  
  LCSr.UUID = lcs_uuid;
  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(OldLCSr,LCSr);
    LCSr.Closed = 1;
    LCSr.MovedAwayFlag = 1;
    LCSr.CurrentStatus = kStatusStopped;
    LCSr.WantedStatus = kWantedStatusStop;
    RecordUpdate(OldLCSr,LCSr,true);
  end;
end;

global
updating procedure DoCreateMovedRCS(record RemoteCloudServerVc RCSr)
begin
  record LocalCloudServerVc LCSr,OldLCSr;

  LCSr.UUID = RCSr.UUID;
  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(OldLCSr,LCSr);
    CopyRCSDatatoLCS(RCSr,LCSr);
    LCSr.Closed = 0;
    LCSr.MovedAwayFlag = 0;
    LCSr.CurrentStatus = kStatusStopped;
    LCSr.WantedStatus = kWantedStatusStop;
    RecordUpdate(OldLCSr,LCSr,true);
  end else begin
    CopyRCSDatatoLCS(RCSr,LCSr);
    LCSr.Closed = 0;
    LCSr.UUID = RCSr.UUID;
    LCSr.CurrentStatus = kStatusStopped;
    LCSr.WantedStatus = kWantedStatusStop;
    RecordInsert(LCSr,false);
  end;
end;

global
updating procedure ForceDeleteLCS(uuid serverid)
begin
  record LocalCloudServerVc LCSr;
  LCSr.UUID = serverid;
  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordDelete(LCSr);
  end;
end;

global
procedure RemoveLCS(uuid serverid,Boolean fromcontrollerf,var Boolean res)
begin
  record LocalCloudServerVc LCSr;
  Boolean foundf;

  res = false;
  foundf = false;
  LCSr.UUID = serverid;
  if (ReadFirstMain(LCSr,1,true)) then begin foundf = true; end;

  if (foundf==false) then begin
    res = true;
    goto LRemoveLCS;
  end;

  if (blank(LCSr.DataFolder) or (DirExists(LCSr.DataFolder)==false) or (foundf==false)) then begin
    res = true;
    if (fromcontrollerf) then begin
      queued.DoRemoveLCS(LCSr);
    end;
    goto LRemoveLCS;
  end;

  if (LCSr.Closed==0) then begin
    LogText(0,"The CC tried to delete an LCS that isn't closed (" & LCSr.UUID & ")");
    res = false;
    goto LRemoveLCS;
  end;

  if (LCSr.Closed!=0) then begin
    res = ArchiveRemovedServer(LCSr.DataFolder);
  end;

  if (fromcontrollerf) then begin
    queued.DoRemoveLCS(LCSr);
  end;

LRemoveLCS:;
  return;
end;

global
procedure RemoveRCS(record RemoteCloudServerVc RCSr,var Boolean res)
begin
  string 255 url;
  LongInt stat;
  record LocalCloudServerVc LCSr;

  res = false;

  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin
    res = true; // No CN, OK to delete
    goto LRemoveRCS;
  end;

  stat = CallService(url).RemoveLCS(RCSr.UUID,true,res);
  if (TreatServiceError(stat,url,"RemoveLCS")) then begin end;

LRemoveRCS:;
  return;
end;

global
updating function Boolean RemoveServer(record LocalCloudServerVc LCSr)
begin
  Boolean res;
  record LocalCloudServerVc OldLCSr;

  res = false;
  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(OldLCSr,LCSr);
    if (nonblank(LCSr.DataFolder) and LCSr.Closed!=0) then begin
      res = DoRemoveServer(LCSr);
      if (res==true) then begin
        LCSr.CurrentStatus = kStatusDeleted;
        LCSr.CurrentSubStatus = kSubStatusNone;
        RecordUpdate(OldLCSr,LCSr,true);
      end;
    end;
  end;

  RemoveServer = res;
  return;
end;

global
updating procedure StartCloudServers(array uuid recarr)
begin
  record LocalCloudServerVc LCSr;
  record LocalCloudServerVc OldLCSr;
  Integer i;
  Boolean testf;
  
  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    LCSr.UUID = recarr[i];
    if (ReadFirstMain(LCSr,1,true)) then begin
      RecordCopy(OldLCSr,LCSr);
      testf = true;
      if (LCSr.MovedAwayFlag!=0) then begin testf = false; end;
      if (LCSr.Closed!=0) then begin testf = false; end;
      if (LCSr.CurrentStatus!=kStatusStopped) then begin testf = false; end;
      if (testf) then begin
        LCSr.WantedStatus = kWantedStatusRun;
        RecordUpdate(OldLCSr,LCSr,true);
      end;
    end;
    i = i + 1;
  end;
end;

global
updating procedure StopCloudServers(array uuid recarr,Boolean forcef)
begin
  record LocalCloudServerVc LCSr;
  record LocalCloudServerVc OldLCSr;
  Integer i;
  Boolean testf;
  
  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    LCSr.UUID = recarr[i];
    if (ReadFirstMain(LCSr,1,true)) then begin
      RecordCopy(OldLCSr,LCSr);
      testf = true;
      if (LCSr.MovedAwayFlag!=0) then begin testf = false; end;
      if (LCSr.Closed!=0) then begin testf = false; end;
      if (testf) then begin
        if (forcef) then begin
          LCSr.WantedStatus = kWantedStatusForceStop;
        end else begin
          LCSr.WantedStatus = kWantedStatusStop;
        end;
        LCSr.WantedSubStatus = kWantedSubStatusNone;
        RecordUpdate(OldLCSr,LCSr,true);
      end;
    end;
    i = i + 1;
  end;
end;

global
updating procedure RestartCloudServers(array uuid recarr)
begin
  record LocalCloudServerVc LCSr;
  record LocalCloudServerVc OldLCSr;
  Integer i;
  Boolean testf;

  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    LCSr.UUID = recarr[i];
    if (ReadFirstMain(LCSr,1,true)) then begin
      RecordCopy(OldLCSr,LCSr);
      testf = true;
      if (LCSr.MovedAwayFlag!=0) then begin testf = false; end;
      if (LCSr.Closed!=0) then begin testf = false; end;
      if (testf) then begin
        LCSr.WantedStatus = kWantedStatusRestart;
        RecordUpdate(OldLCSr,LCSr,true);
      end;
    end;
    i = i + 1;
  end;
end;

global
updating procedure CloseCloudServers(array uuid recarr)
begin
  record LocalCloudServerVc LCSr;
  record LocalCloudServerVc OldLCSr;
  Integer i;
  Boolean testf;
  
  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    LCSr.UUID = recarr[i];
    if (ReadFirstMain(LCSr,1,true)) then begin
      RecordCopy(OldLCSr,LCSr);
      testf = true;
      if (LCSr.Closed!=0) then begin testf = false; end;
      if (LCSr.CurrentStatus!=kStatusStopped) then begin testf = false; end;
      if (testf) then begin
        LCSr.Closed = 1;
        RecordUpdate(OldLCSr,LCSr,true);
      end;
    end;
    i = i + 1;
  end;
end;

global
updating procedure RemoveCloudServers(array uuid recarr)
begin
  record LocalCloudServerVc LCSr;
  Integer i;
  Boolean testf;
  
  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    LCSr.UUID = recarr[i];
    if (ReadFirstMain(LCSr,1,true)) then begin
      testf = true;
      if (LCSr.Closed==0) then begin testf = false; end;
      if (LCSr.CurrentStatus<>kStatusStopped) then begin testf = false; end;
      if (testf) then begin
        if (RemoveServer(LCSr)==true) then begin
          RecordDelete(LCSr);
        end; 
      end;
    end;
    i = i + 1;
  end;
  UpdateClientBrowsesIfNeeded("LocalCloudServerVc");
end;

global
updating procedure SendVersionToAllNodes(record HansaVersionVc HVr)
begin
  record CloudNodeVc CNr;
  string 255 archive;
  
  archive = CreateTempFile("version",".ha");
  BeginArchiveToFile(archive);
  AddArchiveDir(".",HVr.ProgramFolder); // BaseName(HVr.ProgramFolder)
  EndArchive;

  while (LoopMain(CNr,1,true)) begin
    if (CNr.Closed==0) then begin
      SendVersionToNode(HVr,archive,CNr);
    end;
  end;
  
  Delete_File(archive);
end;


global
procedure GetCloudServerData(var array record LocalCloudServerVc csarr)
begin
  record LocalCloudServerVc LCSr;
  Integer i;
  
  i = 0;
  while (LoopMain(LCSr,1,true)) begin
    csarr[i] = LCSr;
    i = i + 1;
  end;
end;

global
updating procedure SaveNewAndUpdatedRCSs(record CloudNodeVc CNr,array record LocalCloudServerVc lcsarr)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  record LocalCloudServerVc LCSr;
  record CloudNodeVc CN2r;
  Integer i;
  LongInt old_wantedstatus;

  if (ReadFirstMain(CNr,1,true)==false) then begin
    LogText(0,"ERROR: SaveNewAndUpdatedRCSs on non-existing node " & CNr.Code);
    goto LSaveNewAndUpdatedRCSs;
  end;

  for (i = 0; i<lcsarr.length; i = i + 1) begin
    LCSr = lcsarr[i];
    if (LCSr.MovedAwayFlag==0) then begin
      RCSr.UUID = LCSr.UUID;
      if (ReadFirstMain(RCSr,1,true)) then begin
        RecordCopy(OldRCSr,RCSr);
        CopyLCSControlledDataToRCS(LCSr,RCSr);
        if (RCSr.Controller!=CNr.Code) then begin
          queued.StoreASPEvent(kASPEventTypeNodeSyncError,"The Remote Cloud Server (1) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & CNr.Code,"",RCSr.UUID,RCSr.Controller);
LogText(0,"The Remote Cloud Server (1) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & CNr.Code
);
HalCallStack;
          SetCloudControllerStatus(kJobStatusWarning,"The Remote Cloud Server (1) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & CNr.Code);
        end;
if (RCSr.Controller!=OldRCSr.Controller) then begin
          queued.StoreASPEvent(kASPEventTypeNodeSyncError,"The Remote Cloud Server (2) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & OldRCSr.Controller,"",RCSr.UUID,RCSr.Controller);
LogText(0,"The Remote Cloud Server (2) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & OldRCSr.Controller);
HalCallStack;
SetCloudControllerStatus(kJobStatusWarning,"The Remote Cloud Server (2) '" & RCSName(RCSr) & "' changed node from " & RCSr.Controller & " to " & OldRCSr.Controller);
end;
        RCSr.Controller = CNr.Code;
        if (RCSr.Closed!=0) then begin
          RCSr.ClosedOnNodeFlag = 1;
        end;
        RecordUpdate(OldRCSr,RCSr,true);
//        if (OldRCSr.CurrentStatus!=RCSr.CurrentStatus and RCSr.CurrentStatus==kStatusRunning) then begin
//          StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,true,true);
//        end;
        if (OldRCSr.CurrentStatus!=RCSr.CurrentStatus and RCSr.CurrentStatus==kStatusConfigInError) then begin
          queued.StoreASPEvent(kASPEventTypeCloudServerError,RCSr.StatusText,"",RCSr.UUID,RCSr.Controller);
        end;
      end else begin
        RecordClear(RCSr);
        CopyLCSDataToRCS(LCSr,RCSr);
        RCSr.UUID = LCSr.UUID;
        RCSr.Controller = CNr.Code;
        if (RCSr.Closed!=0) then begin
          RCSr.ClosedOnNodeFlag = 1;
        end;
        RecordInsert(RCSr,false);
      end;
      RCSr.UUID = LCSr.UUID;
      if (ReadFirstMain(RCSr,1,true)) then begin
        old_wantedstatus = RCSr.WantedStatus;
        if ((RCSr.CurrentStatus==kStatusUpdatingVersion) and
            (RCSr.WantedStatus!=kWantedStatusStop) and
            (RCSr.WantedStatus!=kWantedStatusForceStop) and
            (RCSr.WantedStatus!=kWantedStatusRestart)) then begin
          UpdateServerWantedSubStatus(RCSr);
        end;
        if (ReadFirstMain(RCSr,1,true)) then begin
          UpdateServerWantedStatus(RCSr);
          if (RCSr.WantedStatus!=old_wantedstatus) then begin
            if (nonblank(RCSr.Controller)) then begin
              CN2r.Code = RCSr.Controller;
              SyncRCSDataWithOneCN(CN2r,true,true);
            end;
          end;
        end;
      end;
    end;
  end;

LSaveNewAndUpdatedRCSs:;
  return;
end;

global
procedure SyncLCSDataAtCN(array record RemoteCloudServerVc rcsarr,var array record LocalCloudServerVc lcsarr)
begin
  record LocalCloudServerVc LCSr;
  Integer i;

  i = 0;
  while (LoopMain(LCSr,1,true)) begin
    if (LCSr.ClosedOnNodeFlag==0) then begin
      lcsarr[i] = LCSr;
      i = i + 1;
    end;
  end;
  
//  LogText(0,"Synchronizing " & rcsarr.length & " CC and " & i & " CN cloud server records with cloud controller");

  if (rcsarr.length>0) then begin
    queued.SaveNewAndUpdatedLCSs(rcsarr);
  end;

  return;
end;

function Integer MaxRecordsInSyncOp()
begin
  MaxRecordsInSyncOp = 3000;
  return;
end;

global
procedure GetLCSsAtCN(var array record LocalCloudServerVc lcsarr,var Integer pos,var Boolean moref)
begin
  record LocalCloudServerVc LCSr;
  Integer i,j;

  moref = false;
  i = 0;
  j = 0;
  while (LoopMain(LCSr,1,true)) begin
    if (i>=pos) then begin
      if (j==MaxRecordsInSyncOp) then begin
        moref = true;
        goto LGetLCSsAtCN;
      end;
      if (LCsr.ClosedOnNodeFlag==0) then begin
        lcsarr[j] = LCSr;
        j = j + 1;
      end;
    end;
    i = i + 1;
  end;

LGetLCSsAtCN:;
  pos = i;
  return;
end;

global
procedure FastSyncLCSDataAtCN(array record RemoteCloudServerVc rcsarr,var array record LocalCloudServerVc lcsarr)
begin
  record LocalCloudServerVc LCSr;
  record RemoteCloudServerVc RCSr;
  LongInt i,j;

  j = 0;
  for (i = 0; i<rcsarr.length; i = i + 1) begin
    RCSr = rcsarr[i];
    LCSr.UUID = RCSr.UUID;
    if (ReadFirstMain(LCSr,1,true)) then begin
      lcsarr[j] = LCSr;
      j = j + 1;
    end;
  end;

  if (rcsarr.length>0) then begin
    queued.SaveNewAndUpdatedLCSs(rcsarr);
  end;

  return;
end;
/*
global
updating procedure SaveUpdatedServerStatuses(record CloudNodeVc CNr,array record LocalCloudServerVc csarr)
begin
  record CloudNodeVc OldCNr;
  record LocalCloudServerVc LCSr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  LongInt i;
  
  for (i = 0; i<csarr.length; i = i + 1) begin
    LCSr = csarr[i];
    if (LCSr.MovedAwayFlag==0) then begin
      RCSr.UUID = LCSr.UUID;
      if (ReadFirstMain(RCSr,1,true)) then begin
        RecordCopy(OldRCSr,RCSr);
        CopyLCSControlledDatatoRCS(LCSr,RCSr);
        if ((RCSr.Controller!=CNr.Code) and (LCSr.Closed==0)) then begin
          RCSr.Controller = CNr.Code;
        end;
        RecordUpdate(OldRCSr,RCSr,true);
      end else begin
        CopyLCSDatatoRCS(LCSr,RCSr);
        RCSr.UUID = LCSr.UUID;
        RCSr.Controller = CNr.Code;
        RecordInsert(RCSr,false);
      end;
    end;
  end;
end;
*/
global
updating procedure SaveCloudNodeReachable(record CloudNodeVc CNr,Boolean reachablef)
begin
  record CloudNodeVc OldCNr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Boolean foundf;
  Boolean updatenodeconfigf;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeReachable; end;

  ReadFirstMain(CNr,1,true);
  if (CNr.Closed!=0) then begin
    goto LSaveCloudNodeReachable;
  end;

  RecordCopy(OldCNr,CNr);

  if (reachablef) then begin
    CNr.ReachableFlag = 1;
    if (OldCNr.ReachableFlag==0) then begin
      updatenodeconfigf = true;
      SetCloudControllerStatus(kJobStatusRunning,"Node " & CNr.Code & " is back online");
    end;
  end else begin
    CNr.ReachableFlag = 0;
    if (OldCNr.ReachableFlag==1) then begin
      if (CNr.CurrentState!=kCloudNodeStateCreating) then begin
        SetCloudControllerStatus(kJobStatusError,"Node " & CNr.Code & " is unreachable");
        threadasync.EC2CheckElasticIP(CNr);
      end;
    end;
  end;

  switch (CloudNodeStatus(CNr)) begin
    case kCloudNodeStatusUnreachable:       CNr.FastCheckFlag = 1;
    case kCloudNodeStatusReachable:         CNr.FastCheckFlag = 0;
    case kCloudNodeStatusClosed:            CNr.FastCheckFlag = 0;
    case kCloudNodeStatusDifferentVersion:
      if (VersionBuild>CNr.VersionBuild) then begin
        CNr.FastCheckFlag = 1;
      end else begin
        CNr.FastCheckFlag = 0;
      end;
  end;

  RecordUpdate(OldCNr,CNr,true);

  if (SaveNodeReachableOnRCS) then begin
    RCSr.Controller = CNr.Code;
    foundf = true;
    while (LoopKey("Controller",RCSr,1,foundf)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeReachable; end;
      if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
      if (foundf) then begin
        if (RCSr.Closed==0) then begin
          RecordCopy(OldRCSr,RCSr);
          if (reachablef) then begin
            RCSr.NodeReachableFlag = 1;
            RCSr.CurrentStatus = kStatusNone;
          end else begin
            RCSr.NodeReachableFlag = 0;
            RCSr.CurrentStatus = kStatusNodeUnreachable;
          end;
          if (OldRCSr.NodeReachableFlag!=RCSr.NodeReachableFlag) then begin
            RecordUpdate(OldRCSr,RCSr,true);
          end;
        end;
      end;
    end;

    ResetLoop(RCSr);
    RCSr.Controller = "";
    foundf = true;
    while (LoopKey("Controller",RCSr,1,foundf)) begin
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeReachable; end;
      if (RCSr.Controller!="") then begin foundf = false; end;
      if (foundf) then begin
        if ((RCSr.Closed==0) and (RCSr.NewController==CNr.Code)) then begin
          RecordCopy(OldRCSr,RCSr);
          if (reachablef) then begin
            RCSr.NodeReachableFlag = 1;
            RCSr.CurrentStatus = kStatusNone;
          end else begin
            RCSr.NodeReachableFlag = 0;
            RCSr.CurrentStatus = kStatusNodeUnreachable;
          end;
          if (OldRCSr.NodeReachableFlag!=RCSr.NodeReachableFlag) then begin
            RecordUpdate(OldRCSr,RCSr,true);
          end;
        end;
      end;
    end;
  end;

  if (updatenodeconfigf==true) then begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSaveCloudNodeReachable; end;
    threadasync.GetOneNodeHostingConfig(CNr);
  end;

LSaveCloudNodeReachable:;
  return;
end;

global
function Boolean SyncRCSDataWithOneCN(record CloudNodeVc CNr,Boolean forcef,Boolean synchronousf)
begin
  string 255 cnurl;
  LongInt stat,i,j;
  array record LocalCloudServerVc lcsarr,lcsarr2;
  array record RemoteCloudServerVc rcsarr,rcsarr2;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc RCS2r;
  Boolean found,moref,testf,res;
  Integer pos;


  cnurl = ReadNodeUrl(CNr);
  found = true;
  RCSr.Controller = CNr.Code;
  while (LoopKey("Controller",RCSr,1,found)) begin
    if (RCSr.Controller!=CNr.Code) then begin found = false; end;
    testf = found;
    if ((forcef==false) and (RCSr.FastCheckFlag!=0)) then begin testf = false; end;
    if ((forcef==false) and (RCSr.ClosedOnNodeFlag!=0) and (RCSr.ClosedOnNodeFlag==RCSr.Closed)) then begin testf = false; end;
    if (testf) then begin
      rcsarr[rcsarr.length] = RCSr;
    end;
  end;

  moref = true;
  while (moref) begin
    ClearArray(lcsarr2);
    stat = CallService(cnurl).GetLCSsAtCN(lcsarr2,pos,moref);
    if (TreatServiceError(stat,cnurl,"GetLCSsAtCN")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to get CN cloud server records from node " & CNr.Code);
      goto LSyncRCSDataWithOneCN;
    end;
    LogText2(0,"Syncronizing " & lcsarr2.length & " CC cloud server records from node " & CNr.Code & ", moref=" & moref,kVerbosityDebug);
    for (j = 0; j<lcsarr2.length; j = j + 1) begin
      lcsarr[lcsarr.length] = lcsarr2[j];
    end;
  end;

  j = 0;
  for (i = 0; i<rcsarr.length; i = i + 1) begin
    rcsarr2[rcsarr2.length] = rcsarr[i];
    j = j + 1;
    if ((j==MaxRecordsInSyncOp) or ((i+1)==rcsarr.length)) then begin
      stat = CallService(cnurl).SyncRCSsAtCN(rcsarr2);
      if (TreatServiceError(stat,cnurl,"SyncRCSsAtCN")) then begin
        queued.SaveCloudNodeReachable(CNr,false);
        LogText(0,"Failed to synchronize " & rcsarr2.length & " CC cloud server records with node " & CNr.Code);
        goto LSyncRCSDataWithOneCN;
      end;
      LogText2(0,"Syncronizing " & rcsarr2.length & " (of " & rcsarr.length & ") CC cloud server records with node " & CNr.Code,kVerbosityDebug);
      j = 0;
      ClearArray(rcsarr2);
    end;
  end;

  if ((lcsarr.length>0) or (rcsarr.length>0)) then begin
    queued.SaveCloudNodeReachable(CNr,true);
  end;

//  if (synchronousf) then begin
    qupdating.SaveNewAndUpdatedRCSs(CNr,lcsarr);
//  end else begin
//    queued.SaveNewAndUpdatedRCSs(CNr,lcsarr);
//  end;

  //UpdateClientBrowsesIfNeeded("RemoteCloudServerVc"); shouldn't be in this function
  //UpdateClientBrowsesIfNeeded("CloudNodeVc"); shouldn't be in this function
  res = true;

LSyncRCSDataWithOneCN:;
  SyncRCSDataWithOneCN = res;
  return;
end;

global
updating procedure DoStoreASPEvent(record ASPEventsVc AEr)
begin
  RecordStore(AEr,true);
  return;
end;

global
updating procedure GetASPEventsAtCN(var array record ASPEventsVc AEr_arr)
begin
  Integer i;
  record ASPEventsVc AEr;

  while (LoopMain(AEr,1,true)) begin
    i = i + 1;
    AEr_arr[AEr_arr.length] = AEr;
    RecordDelete(AEr);
    StepBack(AEr);
    if (i>50) then begin
      goto LGetASPEventsAtCN;
    end;
  end;

LGetASPEventsAtCN:;
  return;
end;

global
procedure SyncASPEventsFromOneCN(record CloudNodeVc CNr)
begin
  string 255 cnurl;
  LongInt stat,i;
  array record ASPEventsVc AEr_arr;
  record ASPEventsVc AEr;

  cnurl = ReadNodeUrl(CNr);
  stat = CallService(cnurl).GetASPEventsAtCN(AEr_arr);
  if (TreatServiceError(stat,cnurl,"GetASPEventsAtCN")) then begin
    queued.SaveCloudNodeReachable(CNr,false);
    LogText(0,"Failed to get ASP events from node " & CNr.Code);
    goto LSyncASPEventsFromOneCN;
  end;

  for (i = 0; i<AEr_arr.length; i = i + 1) begin
    AEr = AEr_arr[i];
    qupdating.DoStoreASPEvent(AEr);
  end;

LSyncASPEventsFromOneCN:;
  return;
end;

global
procedure SyncASPEventsFromAllCNs(string args)
begin
  record CloudNodeVc CNr;
  array string 255 nodes;
  LongInt i;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSyncASPEventsFromAllCNs; end;


  while (LoopMain(CNr,1,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSyncASPEventsFromAllCNs; end;
    if (CNr.Closed==0 and ((CloudNodeStatus(CNr)==kCloudNodeStatusReachable) or
       (CloudNodeStatus(CNr)==kCloudNodeStatusDifferentVersion))) then begin
      nodes[nodes.length] = CNr.Code;
    end;
  end;

  if (nodes.length>0) then begin
    LogText2(0,"Reading ASP events from nodes",kVerbosityDebug);
  end;

  for (i = 0; i<nodes.length; i = i + 1) begin
    CNr.Code = nodes[i];
    SyncASPEventsFromOneCN(CNr);
  end;

  if (nodes.length>0) then begin
    LogText2(0,"Finished, read ASP events from " & nodes.length & " nodes",kVerbosityDebug);
  end;

LSyncASPEventsFromAllCNs:;
  return;
end;

global
procedure SyncRCSDataWithAllCNs(string args)
begin
  record CloudNodeVc CNr;
  array string 255 nodes;
  LongInt i;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSyncRCSDataWithAllCNs; end;


  while (LoopMain(CNr,1,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LSyncRCSDataWithAllCNs; end;
    if (CNr.Closed==0 and ((CloudNodeStatus(CNr)==kCloudNodeStatusReachable) or
       (CloudNodeStatus(CNr)==kCloudNodeStatusDifferentVersion))) then begin
      nodes[nodes.length] = CNr.Code;
    end;
  end;

  if (nodes.length>0) then begin
    LogText(0,"Synchronizing cloud servers with nodes");
  end;

  for (i = 0; i<nodes.length; i = i + 1) begin
    CNr.Code = nodes[i];
    SyncRCSDataWithOneCN(CNr,false,false);
  end;

  if (nodes.length>0) then begin
    LogText(0,"Finished, synchronized cloud servers with " & nodes.length & " nodes");
  end;

LSyncRCSDataWithAllCNs:;
  return;
end;


global
updating procedure UpdateCloudServerToNewVersion(record LocalCloudServerVc LCSr)
begin
  Boolean testf;
  record HansaVersionVc HVr;
  record LocalCloudServerVc LCS2r;
  record LocalCloudServerVc OldLCSr;

  if (GetVersion(LCSr.NewHansaVersion,HVr)==false) then begin
    StopAlert("Cloud server " & LCSr.ServerName & " could not be updated to version " & LCSr.NewHansaVersion & " because the version does not exist");
    goto LUpdateCloudServerToNewVersion;
  end;

  RecordCopy(LCS2r,LCSr);
  if (ReadFirstMain(LCS2r,1,true)) then begin
    RecordCopy(OldLCSr,LCS2r);
    testf = true;
    if (LCS2r.MovedAwayFlag!=0) then begin testf = false; end;
    if (LCS2r.Closed!=0) then begin testf = false; end;
    if ((LCS2r.CurrentStatus!=kStatusStopped) and
        (LCSr.CurrentStatus!=kStatusRunning) and
        (LCSr.CurrentStatus!=kStatusRunningPendingStop) and
        (LCSr.CurrentStatus!=kStatusMaintenance)) then begin
      testf = false;
    end;
    if (testf) then begin
      LCS2r.WantedStatus = kWantedStatusUpdateVersion;
      RecordUpdate(OldLCSr,LCS2r,true);
    end;
  end;

LUpdateCloudServerToNewVersion:;
end;

global
procedure GetLocalCloudServerLog(record RemoteCloudServerVc RCSr,string logfile,var area part,var Boolean partialf)
begin
  record LocalCloudServerVc LCSr;
  Boolean testf;

  LCSr.UUID = RCSr.UUID;
  if (ReadFirstMain(LCSr,1,true)) then begin
    testf = true;
    if (FileExists(LCSr.DataFolder & "/" & logfile)==false) then begin testf = false; end;
    if (testf) then begin
      SetAreaZeroSize(part);
      LoadFileToInspectInArea(LCSr.DataFolder & "/" & logfile,part,partialf);
    end;
  end;
  return;
end;

global
procedure GetRemoteCloudServerLog(var record RemoteCloudServerVc RCSr,string logfile,var area part,var Boolean partialf)
begin
  string 255 url;
  LongInt stat;

  SetAreaZeroSize(part);
  if (ReadFirstMain(RCSr,1,true)) then begin
    url = RcsNodeURL(RCSr);
    if (nonblank(url)) then begin
      stat = CallService(url).GetLocalCloudServerLog(RCSr,logfile,part,partialf);
      if (TreatServiceError(stat,url,"GetLocalCloudServerLog")) then begin
        LogText(0,"Failed to load " & logfile & " for cloud server " & RCSName(RCSr));
        SetCloudControllerStatus(kJobStatusError,"Failed to load " & logfile & " for cloud server " & RCSName(RCSr));
      end;
    end;
  end;
  return;
end;

global
updating procedure ExportRemoteCloudServerDatabase(var record RemoteCloudServerVc RCSr)
begin
  record RemoteCloudServerVc OldRCSr;

  RecordCopy(OldRCSr,RCSr);
  RCSr.WantedStatus = kWantedStatusExportDatabase;
  RecordUpdate(OldRCSr,RCSr,true);
  return;
end;

global
updating procedure UpdateRemoteCloudServer(var record RemoteCloudServerVc RCSr)
begin
  record RemoteCloudServerVc OldRCSr;
  if (ReadFirstMain(RCSr,1,true)) then begin
    RecordCopy(OldRCSr,RCSr);
    RCSr.WantedStatus = kWantedStatusUpdateVersion;
    if (RCSr.CurrentStatus!=kStatusRunning) then begin
      RCSr.WantedSubStatus = kWantedSubStatusStopForExport;
    end;
    RecordUpdate(OldRCSr,RCSr,true);
  end;
  return;
end;

global
updating procedure ExportRemoteCloudServersDatabases(array uuid recarr)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Integer i;
  Boolean testf;

  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if (RCSr.CurrentStatus==kStatusConfigInError) then begin testf = false; end;
      if (testf) then begin
        ExportRemoteCloudServerDatabase(RCSr);
      end;
    end;
    i = i + 1;
  end;
  return;
end;

global
updating procedure ImportRemoteCloudServerBackups(array uuid recarr)
begin
  record RemoteCloudServerVc RCSr;
  Integer i;
  Boolean testf;

  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
  RCSr.UUID = recarr[i];
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (RCSr.Closed!=0) then begin testf = false; end;
    if (RCSr.CurrentStatus==kStatusConfigInError) then begin testf = false; end;
      if (testf) then begin
//        ImportRemoteCloudServerBackup(RCSr); //TODO: ImportRemoteCloudServerBackup
      end;
    end;
    i = i + 1;
  end;
end;

global
procedure GetFileListFromLCS(record RemoteCloudServerVc RCSr,string folder,string extension,var array string filearr,var array val sizearr)
begin
  record LocalCloudServerVc LCSr;
  Boolean testf,test2f;
  Integer i,filecnt;
  string 255 filename;
  string 255 path;

  LCSr.UUID = RCSr.UUID;
  if (ReadFirstMain(LCSr,1,true)) then begin
    testf = true;
    path = LCSr.DataFolder & "/" & folder;
    if (DirExists(path)==false) then begin testf = false; end;
    if (testf) then begin
      if (blank(extension)) then begin
        filecnt = CountDirectoriesInDir(path);
        LogText2(0,"GetFileListFromLCS: found " & filecnt & " directories in " & path,kVerbosityDebugDetailed);
        for (i = 0; i<filecnt; i = i + 1) begin
          filename = GetDirectoryNameInDir(path,i);
          LogText2(0,"GetFileListFromLCS: found directory " & filename & " in " & path,kVerbosityDebugDetailed);
          filearr[filearr.length] = "<DIR> " & filename;
          sizearr[sizearr.length] = -1;
        end;
      end;
      filecnt = CountFilesInDir(path);
      LogText2(0,"GetFileListFromLCS: found " & filecnt & " files in " & path,kVerbosityDebugDetailed);
      for (i = 0; i<filecnt; i = i + 1) begin
        test2f = false;
        filename = GetFileNameInDir(path,i);
        if (nonblank(extension)) then begin
          if (right(filename,len(extension))==extension) then begin
            test2f = true;
          end;
        end else begin
          test2f = true;
        end;
        if (test2f==true) then begin
          filearr[filearr.length] = filename;
          sizearr[sizearr.length] = FileSize2(path & "/" & filename);
        end;
      end;
    end;
  end;
end;

global
procedure GetFileListForRCS(uuid rcsid,string path,string filter,var array string filearr,var array Val sizearr)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,fpath;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (RCSr.Closed!=0) then begin testf = false; end;
    if (testf) then begin
      fpath = path;
      if (fpath=="%backup%") then begin fpath = RCSr.BackupFolder; end;
      url = RcsNodeURL(RCSr);
      if (nonblank(url)) then begin
        stat = CallService(url).GetFileListFromLCS(RCSr,fpath,filter,filearr,sizearr);
        if (TreatServiceError(stat,url,"GetFileListFromLCS")) then begin
          LogText(0,"Failed to list files in " & RCSr.BackupFolder & " for cloud server " & RCSName(RCSr));
        end;
      end;
    end;
  end;
end;

global
procedure DoCopyFile(string from,string to)
begin
  CopyFile(from,to);
end;

global
procedure StartImportOnLCS(record RemoteCloudServerVc RCSr,string folder,string filename,var Boolean test2f)
begin
  record LocalCloudServerVc LCSr;
  Boolean testf;
  Integer i,filecnt;
  string 255 filepath;
  string 255 destfilepath,desttmpfilepath;
  string 255 path;

  LCSr.UUID = RCSr.UUID;
  if (ReadFirstMain(LCSr,1,true)) then begin
    testf = true;
    path = LCSr.DataFolder & "/" & folder;
    desttmpfilepath = path & "/TBSETUP.TXT";
    filepath = path & "/" & filename;
    destfilepath = LCSr.DataFolder & "/TBSETUP.TXT";
    if (DirExists(path)==false) then begin testf = false; end;
    if (FileExists(filepath)==false) then begin testf = false; end;
    if (testf) then begin
      Delete_File(destfilepath);
      Delete_File(desttmpfilepath);
      RenameFile(filepath,desttmpfilepath);
      MoveFile("TBSETUP.TXT",path,LCSr.DataFolder);
      queued.DoCopyFile(destfilepath,filepath);
      test2f = true;
    end;
  end;
end;

global
updating procedure DoStartImportOnRCS(record RemoteCloudServerVc RCSr,Boolean resetf)
begin
  record RemoteCloudServerVc OldRCSr;

  RecordCopy(OldRCSr,RCSr);
  if (resetf) then begin
    RCSr.WantedStatus = kWantedStatusResetToBackup;
  end else begin
    RCSr.WantedStatus = kWantedStatusImportBackup;
  end;
  RecordUpdate(OldRCSr,RCSr,true);
end;

global
procedure SendStartImportOnRCS(uuid rcsid,string filename,Boolean resetf)
begin
  record RemoteCloudServerVc RCSr;
  Integer i;
  Boolean testf,test2f;
  string 255 url;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (RCSr.Closed!=0) then begin testf = false; end;
    if (RCSr.CurrentStatus<>kStatusStopped) then begin testf = false; end;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (nonblank(url)) then begin
        test2f = false;
        stat = CallService(url).StartImportOnLCS(RCSr,RCSr.BackupFolder,filename,test2f);
        if (TreatServiceError(stat,url,"StartImportOnLCS")) then begin
          LogText(0,"Failed start import of " & filename & " for cloud server " & RCSName(RCSr));
        end else begin
          if (test2f==true) then begin
            queued.DoStartImportOnRCS(RCSr,resetf);
          end;
        end;
      end;
    end;
  end;
end;

global
procedure StartImportOnRCS2(uuid rcsid,string filename,Boolean resetf)
begin
  queued.SendStartImportOnRCS(rcsid,filename,resetf);
end;

global
procedure StartImportOnRCS(uuid rcsid,string filename)
begin
  StartImportOnRCS2(rcsid,filename,false);
end;

global
updating procedure ExportRemoteCloudServerCompany(uuid rcsid,LongInt compno,string filename)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Boolean testf;
  string 255 tstr;

  if (!BlankUUID(rcsid)) begin
    RCSr.UUID = rcsid;
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if (RCSr.CurrentStatus==kStatusConfigInError) then begin testf = false; end;
      if (testf) then begin
        RecordCopy(OldRCSr,RCSr);
        RCSr.WantedStatus = kWantedStatusExportCompany;
        tstr = "--backup-company " & compno;
        if (nonblank(filename)) then begin
          tstr = tstr & " --backup-file=" & filename;
        end;
        RCSr.WantedStatusParams = tstr;
        RecordUpdate(OldRCSr,RCSr,true);
      end;
    end;
  end;
end;

global
updating procedure ExportRemoteCloudServerRegister(uuid rcsid,string vcname,LongInt compno,string filename)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  string 255 tstr;
  Boolean testf;

  if (!BlankUUID(rcsid)) begin
    RCSr.UUID = rcsid;
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if (RCSr.CurrentStatus==kStatusConfigInError) then begin testf = false; end;
      if (testf) then begin
        RecordCopy(OldRCSr,RCSr);
        RCSr.WantedStatus = kWantedStatusExportRegister;
        tstr = "--export-register " & compno & " " & vcname;
        if (nonblank(filename)) then begin
          tstr = tstr & " --backup-file=" & filename;
        end;
        RCSr.WantedStatusParams = tstr;
        RecordUpdate(OldRCSr,RCSr,true);
      end;
    end;
  end;
end;

global
updating procedure UpdateRemoteCloudServers(array uuid recarr,string vercode,LongInt dbcache,var string errmsg)
begin
  record HansaVersionVc HVr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Boolean testf,foundf;
  Integer i,j,rwcnt;
  row RemoteCloudServerVc RCSrw;


  HVr.Code = vercode;
  if (ReadFirstMain(HVr,1,true)==false) then begin
    errmsg = "The specified version does not exist.";
    goto LUpdateRemoteCloudServers;
  end;

  if (HVr.Closed!=0) then begin
    errmsg = "The specified version is closed.";
    goto LUpdateRemoteCloudServers;
  end;

  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if (testf) then begin
        RecordCopy(OldRCSr,RCSr);
        RCSr.NewHansaVersion = vercode;
        RCSr.WantedStatus = kWantedStatusUpdateVersion;
        if (dbcache>0) then begin
          RCSr.WantedStatusParams = " --db-cache=" & dbcache & "M";
        end else begin
          RCSr.WantedStatusParams = "";
        end;
        RecordUpdate(OldRCSr,RCSr,true);
        UpdateRemoteCloudServer(RCSr);
      end;
    end;
    i = i + 1;
  end;

LUpdateRemoteCloudServers:;
  return;
end;

global
updating procedure RestartRemoteCloudServer(record RemoteCloudServerVc RCSr)
begin
  Boolean res;
  record RemoteCloudServerVc OldRCSr;
  record CloudNodeVc CNr;

  RecordCopy(OldRCSr,RCSr);
  RCSr.WantedStatus = kWantedStatusRestart;
  RecordUpdate(OldRCSr,RCSr,true);
  CNr.Code = RCSr.Controller;
  res = SyncRCSDataWithOneCN(CNr,true,true);
  if (res==true) then begin
    threadasync.ClearQuickRestartsOnNode(RCSr);
    SetCloudControllerStatus(kJobStatusError,"Restarting cloud server " & RCSName(RCSr));
  end else begin
    SetCloudControllerStatus(kJobStatusError,"Failed restarting cloud server " & RCSName(RCSr));
  end;
end;

global
procedure RestartRemoteCloudServers(array uuid recarr)
begin
  record RemoteCloudServerVc RCSr;
  Integer i;
  Boolean testf;

  i = 0;
  for (i = 0; i<recarr.length; i = i + 1) begin
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if (testf) then begin
        qupdating.RestartRemoteCloudServer(RCSr);
      end else begin
        SetCloudControllerStatus(kJobStatusError,"Ignoring restart command for cloud server " & RCSName(RCSr));
      end;
    end;
  end;
end;

global
updating procedure StartRemoteCloudServers(array uuid recarr,Boolean maintf)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc oRCSr;
  Integer i;

  for (i = 0; i<recarr.length; i = i + 1) begin
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      StartRemoteCloudServer(RCSr,maintf);
    end;
  end;
end;

global
function LongInt CanStopRemoteCloudServer(record RemoteCloudServerVc RCSr)
begin
  record LocalCloudServerVc LCSr;
  LongInt res;
  string 255 url;
  LongInt stat;

  res = 0;

  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin goto LCanStopRemoteCloudServer; end;
  if (RCSr.Closed!=0) then begin goto LCanStopRemoteCloudServer; end;
  if ((RCSr.CurrentStatus!=kStatusRunning) and
      (RCSr.CurrentStatus!=kStatusMaintenance) and
      (RCSr.CurrentStatus!=kStatusRunningPendingStop) and
      (RCSr.CurrentStatus!=kStatusRunningTest)) then begin
    goto LCanStopRemoteCloudServer;
  end;

  LCSr.UUID = RCSr.UUID;
  stat = CallService(url).ActiveServerUsers(LCSr,false,res);
  if (TreatServiceError(stat,url,"ActiveServerUsers")) then begin
    res = -1;
    LogText(0,"Failed counting active server users on " & RCSName(RCSr));
    SetCloudControllerStatus(kJobStatusError,"Failed counting active server users on " & RCSName(RCSr));
  end;

LCanStopRemoteCloudServer:;
  LogText2(0,"CanStopRemoteCloudServer res = " & res,kVerbosityDebugDetailed);
  CanStopRemoteCloudServer = res;
  return;
end;

global
updating procedure StopRemoteCloudServers(array uuid recarr,Boolean forcef)
begin
  record RemoteCloudServerVc RCSr;
  Integer i;

  i = 0;
  while (!BlankUUID(recarr[i])) begin //for
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      StopRemoteCloudServer(RCSr,forcef);
    end;
    i = i + 1;
  end;
  UpdateClientBrowsesIfNeeded("RemoteCloudServerVc");

end;

global
procedure StopRemoteCloudServers2(array uuid recarr)
begin
  record RemoteCloudServerVc RCSr;
  Integer i;
  LongInt usercnt,l;

  usercnt = 0;
  for (i = 0; i<recarr.length; i = i + 1) begin
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      l = CanStopRemoteCloudServer(RCSr);
      if (l==-1) then begin
        SetCloudControllerStatus(kJobStatusError,"Ignoring stop command for server " & RCSName(RCSr));
        goto LStopRemoteCloudServers2;
      end;
      usercnt = usercnt + l;
    end;
  end;

  if (usercnt>0) then begin
    clientremoteasync.StopRemoteCloudServers2_Reply(recarr,usercnt);
  end else begin
    qupdating.StopRemoteCloudServers(recarr,false);
  end;

LStopRemoteCloudServers2:;
end;

global
procedure SoftStopLocalCloudServer(record LocalCloudServerVc LCSr,string user,string message,Integer mins,var Boolean res)
begin
  area a_enact;

  res = false;

  if (ReadFirstMain(LCSr,1,true)==false) then begin
    goto LSoftStopLocalCloudServer;
  end;

  CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
  AddLineToArea(user,a_enact);
  AddLineToArea(message,a_enact);
  AddLineToArea("" & mins,a_enact);
  WriteAreaToFile(a_enact,EnablerActionsFolder(LCSr) & "/EnSendMsg",0);
  res = true;

LSoftStopLocalCloudServer:;
end;

global
function Boolean SoftStopRemoteCloudServer(record RemoteCloudServerVc RCSr,string user,string message,Integer mins)
begin
  record LocalCloudServerVc LCSr;
  Boolean res;
  string 255 url;
  LongInt stat;

  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin goto LSoftStopRemoteCloudServer; end;
  if (RCSr.Closed!=0) then begin goto LSoftStopRemoteCloudServer; end;
  if ((RCSr.CurrentStatus!=kStatusRunning) and
      (RCSr.CurrentStatus!=kStatusConfigInError) and
      (RCSr.CurrentStatus!=kStatusMaintenance) and
      (RCSr.CurrentStatus!=kStatusRunningPendingStop) and
      (RCSr.CurrentStatus!=kStatusRunningTest)) then begin
    SetCloudControllerStatus(kJobStatusError,"Server " & RCSName(RCSr) & " couldn't be stopped because it isn't running");
    goto LSoftStopRemoteCloudServer;
  end;

  LCSr.UUID = RCSr.UUID;
  stat = CallService(url).SoftStopLocalCloudServer(LCSr,user,message,mins,res);
  if (TreatServiceError(stat,url,"SoftStopLocalCloudServer")) then begin
    goto LSoftStopRemoteCloudServer;
  end;

  res = true;

LSoftStopRemoteCloudServer:;
  SoftStopRemoteCloudServer = res;
return;
end;

global
procedure SoftStopRemoteCloudServers(array uuid recarr,string message,Integer mins)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  LongInt usercnt;
  Integer i;
  record UserVc Userr;

  DoGetCurUser(Userr);

  for (i = 0; i<recarr.length; i = i + 1) begin
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = SoftStopRemoteCloudServer(RCSr,Userr.Name,message,mins);
      if (testf==false) then begin
        SetCloudControllerStatus(kJobStatusError,"Server " & RCSName(RCSr) & " couldn't be stopped, failed communicating with node " & RCSr.Controller);
      end else begin
        SetCloudControllerStatus(kJobStatusRunning,"Requesting soft stop of server " & RCSName(RCSr));
      end;
    end;
  end;
end;

global
updating procedure CloseRemoteCloudServers(array uuid recarr)
begin
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  Integer i;
  Boolean testf;
  
  for (i = 0; i<recarr.length; i = i + 1) begin
    RCSr.UUID = recarr[i];
    if (ReadFirstMain(RCSr,1,true)) then begin
      testf = true;
      if (RCSr.Closed!=0) then begin testf = false; end;
      if ((RCSr.CurrentStatus!=kStatusStopped) and
          (RCSr.CurrentStatus!=kStatusConfigInError) and
          (RCSr.CurrentStatus!=kStatusNodeUnreachable)) then begin testf = false; end;
      if (testf) then begin
        RecordCopy(OldRCSr,RCSr);
        RCSr.Closed = 1;
        RecordUpdate(OldRCSr,RCSr,true);
      end;
    end;
  end;
end;

function Boolean IsAvailNewVersionImportFile(string filename)
begin
  Boolean res;
  
  res = false;
  
  if (Right(filename,12)!=".version.txt") then begin goto LIsAvailNewVersionImportFile; end;
  
  res = true;
  
LIsAvailNewVersionImportFile:;
  IsAvailNewVersionImportFile = res;
end;

global
updating function Boolean CloudControllerCreateNewVersionIfNeeded(string vcode,string vname,LongInt vno,LongInt vsubno,LongInt vbuild,LongInt vptyp,string vpcode)
begin
  string 255 vfolder,newvfolder;
  record HansaVersionVc HV2r;
  transaction record HansaVersionVc HVr;
  transaction record HansaVersionVc OldHVr;
  Boolean res;
  area a_req;
  LongInt vrepubcount;
  LongInt old_version_build,new_version_build,next_version_build;
  transaction string 255 version_to_download;
  transaction string 255 server,path,destpath;
  transaction LongInt port;
  transaction Boolean checkonlyf;
  Boolean okverf;

  HVr.Code = vcode;
  if (ReadFirstMain(HVr,1,true)==true) then begin
    if (HVr.Closed!=0) then begin
      res = true;
      goto LCloudControllerCreateNewVersionIfNeeded;
    end;
    RecordCopy(OldHVr,HVr);
  end else begin
    RecordClear(OldHVr);
    RecordClear(HVr);
    HVr.Code = vcode;
    HVr.RePubCount = 0;
  end;

  vfolder = VersionsFolder & vcode;

  HVr.Name = vname;
  HVr.Version = vno;
  HVr.SubVersion = vsubno;
  HVr.RunningBuild = vbuild;
  HVr.ProgramType = vptyp;
  HVr.ProgramFolder = vfolder;
  HVr.ProductCode = vpcode;

  if (nonblank(OldHVr.Code) and (OldHVr.CurrentState!=kHansaVersionStateError)) then begin
    old_version_build = (OldHVr.Version * 1000000) + (OldHVr.SubVersion * 10000) + OldHVr.RunningBuild;
    new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
    next_version_build = (OldHVr.NextVersion * 1000000) + (OldHVr.NextSubVersion * 10000) + OldHVr.NextRunningBuild;
    if ((OldHVr.CurrentState!=kHansaVersionStateUpdating) and (OldHVr.CurrentState!=kHansaVersionStateInstalling)) then begin
      if ((OldHVr.CurrentState!=kHansaVersionStateNotDownloaded) or (right(vcode,6)=="-BUILD")) then begin
        if (IsCloudController and (GetGlobalBoolean("ASPIdleTasksStopped")!=true)) then begin
          if (right(vcode,6)=="-BUILD") then begin
//            LogText(0,"CloudControllerCreateNewVersionIfNeeded vcode=" & vcode & ", next_version_build=" & next_version_build & ", new_version_build=" & new_version_build);
          end;
          if ((next_version_build<new_version_build) or (OldHVr.ForceReplaceVersionf!=0) or (right(vcode,6)=="-BUILD")) then begin
//            if (right(vcode,6)=="-BUILD") then begin
//              LogText(0,"CloudControllerCreateNewVersionIfNeeded 2");
//            end;
            if (right(vcode,6)=="-BUILD") then begin
//              LogText(0,"CloudControllerCreateNewVersionIfNeeded 3");
              HV2r.Code = vcode;
              if (ReadFirstMain(HV2r,1,true)==true) then begin
//                LogText(0,"CloudControllerCreateNewVersionIfNeeded 4");
                RecordCopy(OldHVr,HV2r);
                HV2r.NextVersion = vno;
                HV2r.NextSubVersion = vsubno;
                HV2r.NextRunningBuild = vbuild;
                HV2r.Version = vno;
                HV2r.SubVersion = vsubno;
                HV2r.RunningBuild = vbuild;
                RecordUpdate(OldHVr,HV2r,true);
                RecordCopy(OldHVr,HV2r);
              end;
              if ((next_version_build<new_version_build) or (OldHVr.ForceReplaceVersionf!=0)) then begin
                UpdateServersOnVersion(vcode,kHansaVersionUpdateTypeAll);
              end;
            end;
          end;
        end;
        if ((old_version_build<new_version_build) or (OldHVr.ForceReplaceVersionf!=0)) then begin
          if (DirExists(HVr.ProgramFolder)==true) then begin
            SetHansaVersionState(HVr,kHansaVersionStateOld);
          end else begin
            SetHansaVersionState(HVr,kHansaVersionStateNotDownloaded);
          end;
        end else begin
          if (DirExists(HVr.ProgramFolder)==true) then begin
            SetHansaVersionState(HVr,kHansaVersionStateNormal);
          end else begin
            SetHansaVersionState(HVr,kHansaVersionStateNotDownloaded);
          end;
        end;
      end else begin
        SetHansaVersionState(HVr,kHansaVersionStateNotDownloaded);
      end;
    end;
  end else begin
    SetHansaVersionState(HVr,kHansaVersionStateNotDownloaded);
  end;


  if (nonblank(version_to_download)) then begin
    if (ShouldDownloadVersion(vcode)==false) then begin
      res = true;
      goto LCloudControllerCreateNewVersionIfNeeded;
    end;
  end;

  if (IsDownloadingVersion(vcode)) then begin goto LCloudControllerCreateNewVersionIfNeeded; end;
  if ((checkonlyf==true) and (ShouldDownloadVersion(vcode)==false)) then begin
    res = true;
    goto LCloudControllerCreateNewVersionIfNeeded;
  end;
  server = "downloads.hansaworld.com";
  port = 80;
  path = "/downloads/cloud_packages/" & vcode & ".ha";

  destpath = vfolder & ".download";
  DeleteFolder(destpath);


  if (nonblank(OldHVr.Code)) then begin
    old_version_build = (OldHVr.Version * 1000000) + (OldHVr.SubVersion * 10000) + OldHVr.RunningBuild;
    new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
    okverf = CheckVersion(OldHVr);
    if ((old_version_build<new_version_build) or (OldHVr.ForceReplaceVersionf!=0) or
        (HVr.CurrentState==kHansaVersionStateError) or
        (HVr.CurrentState==kHansaVersionStateNotDownloaded) or (okverf==false)) then begin
      if (IsCloudController) then begin
        if (GetGlobalBoolean("update_after_download")) then begin
          SetCloudControllerStatus(kJobStatusRunning,"Downloading new version for Cloud Controller (" & new_version_build & ")");
        end;
      end;
      LogText(0,"Downloading http://" & server & ":" & port & path);
      vrepubcount = OldHVr.RePubCount;
      vrepubcount = vrepubcount + 1;
      HVr.RePubCount = vrepubcount;
      SetDownloadingVersion(HVr.Code,true);
      if (HVr.CurrentState==kHansaVersionStateNotDownloaded) then begin
        SetHansaVersionState(HVr,kHansaVersionStateInstalling);
      end else begin
        SetHansaVersionState(HVr,kHansaVersionStateUpdating);
      end;
      HttpAsyncDownloadHA(server,port,path,30,destpath,"HttpAsyncDownloadHACallback");
    end else begin
      if (IsCloudController) then begin
        if (GetGlobalBoolean("update_after_download")) then begin
          SetCloudControllerStatus(kJobStatusError,"Cloud Controller update cancelled, no new version is available (latest version is " & new_version_build & ", running version is " & VersionBuild);
        end;
      end else begin
        if (GetGlobalBoolean("update_after_download")) then begin
          if (VersionBuild<new_version_build) then begin
            if (CheckVersion(HVr)==false) then begin
              SetCloudControllerStatus(kJobStatusError,"ERROR: Cloud Controller couldn't be updated to version " & new_version_build & ", it might be corrupt");
              SetHansaVersionState(HVr,kHansaVersionStateError);
            end else begin
              LogText(0,"Updating node from version " & VersionBuild & " to " & HVr.Code & " (" & new_version_build & ")");
              SetCloudControllerStatus(kJobStatusRunning,"Updating Cloud Controller from version " & VersionBuild & " to " & new_version_build);
              UpdateToVersion_WTF(HVr);
              goto LCloudControllerCreateNewVersionIfNeeded;
            end;
          end;
        end;
      end;
      LogText(0,"Skipping " & HVr.Code & " because my version>=available version (" & old_version_build & ">=" & new_version_build & ")");
      SetDownloadingVersion(vcode,false);
      SetShouldDownloadVersion(vcode,false);
    end;
  end else begin
    if (GetGlobalBoolean("update_after_download")) then begin
      SetCloudControllerStatus(kJobStatusRunning,"Downloading new version for Cloud Controller (" & new_version_build & ")");
    end;
    LogText(0,"Downloading http://" & server & ":" & port & path);
    SetDownloadingVersion(HVr.Code,true);
    SetHansaVersionState(HVr,kHansaVersionStateInstalling);
    HttpAsyncDownloadHA(server,port,path,30,destpath,"HttpAsyncDownloadHACallback");
  end;

  res = true;

LCloudControllerCreateNewVersionIfNeeded:;
  UpdateClientBrowsesIfNeeded("HansaVersionVc");
  CloudControllerCreateNewVersionIfNeeded = res;
  return;
end;

global
updating procedure DownloadNewVersionsForCx()
begin
  Integer wn;
  Integer err;
  record HansaVersionVc HVr;
  record HansaVersionVc HV2r;
  Area a_req;
  Area a_reply;
  string 255 server,path;
  LongInt port;
  transaction string 255 version_to_download;
  transaction Boolean checkonlyf;

  if (GetGlobalBoolean("ASPGetHMCustCodeFromBackups")==true) then begin goto LDownloadNewVersionsForCx; end;

  server = "downloads.hansaworld.com";
  port = 80;
  path = "/downloads/cloud_packages/allversions.txt";

  SetShouldDownloadVersion(version_to_download,true);
  if (IsDownloadingVersion(version_to_download) or IsDownloadingVersion("AllVersionsTag")) then begin
    //LogText(0,"Skipping downloading of " & version_to_download & " because a download of that version already is in progress");
    goto LDownloadNewVersionsForCx;
  end;

  if (IsDownloadingVersion("AllVersionsTag")==false) then begin
    while (LoopMain(HVr,1,true)) begin
      if (IsDownloadingVersion(HVr.Code)==false) then begin
        if (HVr.Closed==0) then begin
          //SetHansaVersionState(HVr,kHansaVersionStateChecking);
        end else begin
          SetHansaVersionState(HVr,kHansaVersionStateUnknown);
        end;
      end;
    end;
  end;
  RecordClear(HVr);
  UpdateClientBrowsesIfNeeded("HansaVersionVc");

  SetDownloadingVersion("AllVersionsTag",true);

  LogText2(0,"Downloading list of available versions from http://" & server & ":" & port & path,kVerbosityDebugDetailed);
  SendAsyncWebRequest(server,port,-1,false,"GET",path,"text/xml; charset=""utf-8""","",a_req,"DownloadNewVersionsForCxReply",30);

LDownloadNewVersionsForCx:;
  UpdateClientBrowsesIfNeeded("HansaVersionVc");
  return;
end;

global
updating procedure DownloadNewVersionsForCxReply(Area a_reply,Area a_replyheader,Boolean timeout)
begin
  Integer status;
  string 255 comment,result;
  Integer rown;
  transaction string 255 version_to_download;
  transaction Integer retries;
  record HansaVersionVc HVr;
  transaction Boolean checkonlyf;
  vector Boolean gotversions;
  string 255 vcode,vname,vpcode;
  LongInt vno,vsubno,vbuild,vptyp;
  Boolean oldwrwi,moref;
  Integer obv;

  SetDownloadingVersion("AllVersionsTag",false);
  if (timeout==true) then begin
//    retries = retries + 1;
//    if (retries>5) then begin
      LogText(0,"DownloadNewVersionsForCxReply(allversions.txt) web call timed out");
//    end else begin
//      LogText(0,"DownloadNewVersionsForCxReply(allversions.txt) web call timed out (attempt " & retries & "), retrying");
//      DownloadNewVersionsForCx;
//    end;
    goto LDownloadNewVersionsForCxReply;
  end;

  ParseHTTPHeader(a_replyheader,"",status,comment,result);
  switch (status) begin
    case kHttpStatusNotFound:
      LogText(0,"DownloadNewVersionsForCxReply() web call failed (status=404 not found)");
      goto LDownloadNewVersionsForCxReply;
    case kHttpStatusOK:
      if (blank(version_to_download)) then begin
        LogText(0,"Downloading new and updated versions");
      end;
    otherwise
//      retries = retries + 1;
//      if (retries>5) then begin
        LogText(0,"DownloadNewVersionsForCxReply() web call failed (status=" & status & ")");
//      end else begin
//        LogText(0,"DownloadNewVersionsForCxReply() web call failed (status=" & status & ", attempt " & retries & "), retrying");
//        DownloadNewVersionsForCx;
//      end;
      goto LDownloadNewVersionsForCxReply;
  end;

  LogText2(0,"DownloadNewVersionsForCxReply: creating versions",kVerbosityDebugDetailed);
  WriteAreaToFile(a_reply,"tmp/allversions.txt",0);

  obv = SetBackupVerbosity(kBackupVerbositySilent);
  oldwrwi = SetWebRequestsWhileImporting(true);
  OpenFile("tmp/allversions.txt");
  moref = true;
  while (moref) begin
    vcode = ImportField;
    if (vcode<>"") then begin
      vname = ImportField;
      vno = StringToLongInt(ImportField);
      vsubno = StringToLongInt(ImportField);
      vbuild = StringToLongInt(ImportField);
      vptyp = StringToLongInt(ImportField);
      vpcode = ImportField;
      gotversions[vcode] = true;
      CloudControllerCreateNewVersionIfNeeded(vcode,vname,vno,vsubno,vbuild,vptyp,vpcode);
    end;
    moref = NextImportLine(false);
  end;

  CloseFile;
  SetWebRequestsWhileImporting(oldwrwi);
  ResetBackupVerbosity(obv);
  Delete_File("tmp/allversions.txt");

  LogText2(0,"DownloadNewVersionsForCxReply: done creating versions",kVerbosityDebugDetailed);

  while (LoopMain(HVr,1,true)) begin
    if (gotversions[HVr.Code]==false) then begin
    //if (HVr.CurrentState==kHansaVersionStateChecking) then begin
      if (DirExists(HVr.ProgramFolder)==true) then begin
        SetHansaVersionState(HVr,kHansaVersionStateDeprecated);
      end else begin
        SetHansaVersionState(HVr,kHansaVersionStateUnavailable);
      end;
    end;
  end;

LDownloadNewVersionsForCxReply:;
  UpdateClientBrowsesIfNeeded("HansaVersionVc");
  return;
end;

global
updating procedure CheckHansaVersions(string args)
begin
  transaction Boolean checkonlyf;

  //if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LCheckHansaVersions; end;

  checkonlyf = true;
  DownloadNewVersionsForCx;

LCheckHansaVersions:;
end;

global
updating procedure PeriodicNodeStatsCleanup(string args)
begin
  record CloudMachineStatsVc CMSr;
  date td;
  Boolean foundf;
  Integer months;
  LongInt cnt;
  Date blankd;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LPeriodicNodeStatsCleanup; end;

  LogText(0,"Cleaning cloud node statistics");

  months = 3;
  cnt = 0;
  td = AddMonth(CurrentDate,-months);
  CMSr.Date = blankd;
  foundf = true;

  LogText(0,"Deleting node statistics older than " & months & " months");
  DBHold;
  while (LoopKey("Date",CMSr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LPeriodicNodeStatsCleanup; end;
    if (CMSr.Date>td) then begin foundf = false; end;
    if (foundf) then begin
      RecordDelete(CMSr);
      StepBack(CMSr);
      cnt = cnt + 1;
    end;
  end;
  DBFlush;

  LogText(0,"Finished, deleted " & cnt & " cloud node statistics records");

LPeriodicNodeStatsCleanup:;
  return;
end;

global
updating procedure DoRemoveNodesStats(Boolean allf)
begin
  record CloudMachineStatsVc CMSr;
  record CloudNodeVc CNr;
  Boolean deletef;
  LongInt i;

  if (allf) then begin
    LogText(0,"Deleting all node statistics");
  end else begin
    LogText(0,"Deleting node statistics for closed and deleted nodes");
  end;

  DBHold;
  i = 0;
  while (LoopMain(CMSr,1,true)) begin
    deletef = true;

    if (allf==false) then begin
      CNr.Code = CMSr.ServerCode;
      if (ReadFirstMain(CNr,1,true)) then begin
        if (CNr.Closed==0) then begin deletef = false; end;
      end;
    end;

    if (deletef==true) then begin
      RecordDelete(CMSr);
      StepBack(CMSr);
      i = i + 1;
    end;
  end;
  DBFlush;

  LogText(0,"Done, " & i & " node statistics records deleted");

  return;
end;

global
updating procedure StartRemoveNodesStats(Boolean allf)
begin
  queued.DoRemoveNodesStats(allf);
  return;
end;

global
updating procedure DoDownloadVersion(record HansaVersionVc HVr,Boolean updatef)
begin
  transaction Boolean update_after_download;
  transaction string 255 version_to_download;
  record HansaVersionVc HV2r;
  record HansaVersionVc OldHV2r;

  version_to_download = HVr.Code;
  update_after_download = updatef;

  if (updatef) then begin
    SetCloudControllerStatus(kJobStatusRunning,"Downloading version " & HVr.Code & " for Cloud Controller update");
  end;

  HV2r.Code = HVr.Code;
  if (ReadFirstMain(HV2r,1,true)==true) then begin
    RecordCopy(OldHV2r,HV2r);
    HV2r.ForceReplaceVersionf = HVr.ForceReplaceVersionf;
    RecordUpdate(OldHV2r,HV2r,true);
  end;

  DownloadNewVersionsForCx;
end;

global
updating procedure DoUpdateServersOnVersion(string vercode,LongInt hvut)
begin
  record HansaVersionVc HVr;
  record HansaVersionVc OldHVr;

  HVr.Code = vercode;
  if (ReadFirstMain(HVr,1,true)==true) then begin
    RecordCopy(OldHVr,HVr);
    HVr.UpdateType = hvut;
    HVr.ForceReplaceVersionf = 1;
    RecordUpdate(OldHVr,HVr,true);
    DoDownloadVersion(HVr,false);
  end;
end;

global
updating procedure UpdateServersOnVersion(string vercode,LongInt hvut)
begin
  record RemoteCloudServerVc RCSr,OldRCSr;
  record HansaVersionVc HVr;
  record CloudNodeVc CNr;
  array string 255 cnarr;
  LongInt i,j;
  Boolean testf;
  string 255 url;
  LongInt stat;

  HVr.Code = vercode;
  if (ReadFirstMain(HVr,1,true)) then begin
    i = 0;
    while (LoopMain(RCSr,0,true)) begin
      if (RCSr.Closed==0) then begin
        if ((RCSr.HansaVersion==HVr.Code) or (RCSr.NewHansaVersion==HVr.Code)) then begin
          if (RCSr.WantedStatus==kWantedStatusRun) then begin
            RecordCopy(OldRCSr,RCSr);
            RCSr.WantedStatus = kWantedStatusStop;
            RecordUpdate(OldRCSr,RCSr,true);
          end;
          j = 0;
          testf = false;
          for (j = 0; j<cnarr.length; j = j + 1) begin
            if (cnarr[i]==RCSr.Controller) then begin
              testf = true;
            end;
          end;
          if (testf==false) then begin
            cnarr[i] = RCSr.Controller;
            i = i + 1;
          end;
        end;
      end;
    end;
  end;

  if (i>0) then begin
    LogText(0,"Attempting to refresh all cloud servers on version " & vercode);
  end;

  for (i = 0; i <cnarr.length; i = i + 1) begin
    CNr.Code = cnarr[i];
    url = ReadNodeURL(CNr);
    stat = CallService(url).DoUpdateServersOnVersion(vercode,hvut);
    if (TreatServiceError(stat,url,"DoUpdateServersOnVersion")) then begin
      LogText(0,"Failed to update servers on version on CN " & CNr.Code);
      goto LUpdateServersOnVersion;
    end;
  end;

LUpdateServersOnVersion:;
end;

global
procedure DownloadVersion(record HansaVersionVc HVr)
begin
  queued.DoDownloadVersion(HVr,false);
  return;
end;

updating procedure DeleteCoreFiles()
begin
  Boolean res;
  string 255 filename;
  Integer cnt,i;

  cnt = CountFilesInDir(".");
  for (i = 0; i < cnt; i = i + 1) begin
    filename = GetFileNameInDir(".",i);
    if (left(filename,5)=="core.") then begin
      Delete_File(filename);
    end;
  end;
  return;
end;

global
updating procedure DoUpdateToVersionQueued(record HansaVersionVc HV2r)
begin
  Boolean downloadf,waitf;
  LongInt new_version_build,dbver;
  record HansaVersionVc HVr;

  HVr.Code = HV2r.Code;
  if (ReadFirstMain(HVr,1,true)==false) then begin
    LogText(0,"DoUpdateToVersionQueued failed, version doesn't exist: " & HV2r.Code);
    goto LDoUpdateToVersionQueued;
  end;

  downloadf = false;
  waitf = false;

  switch (HVr.CurrentState) begin
    case kHansaVersionStateUnknown:
      waitf = true;
    case kHansaVersionStateNotDownloaded:
      downloadf = true;
    case kHansaVersionStateOld:
      downloadf = true;
    case kHansaVersionStateUpdating:
      goto LDoUpdateToVersionQueued;
    case kHansaVersionStateInstalling:
      goto LDoUpdateToVersionQueued;
  end;

  if (waitf==true) then begin
    queued.DoUpdateToVersionQueued(HVr);
    goto LDoUpdateToVersionQueued;
  end;

  if (downloadf==true) then begin
    HVr.ForceReplaceVersionf = 1;
    DoDownloadVersion(HVr,true);
    goto LDoUpdateToVersionQueued;
  end;

  if (CheckVersion(HVr)==true) then begin
    new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
    dbver = (HVr.Version * 100) + HVr.SubVersion;
    if (new_version_build>VersionBuild) then begin
      SetCloudControllerStatus(kJobStatusRunning,"Starting Cloud Controller update to version " & HVr.Code);
      LogText(0,"Starting update to version " & HVr.Code);
      Delete_File("EnRetryNodeUpdate");
      DeleteCoreFiles;
      if (dbver!=DbVersion) then begin
        UpdateToVersionInFolder2(HVr.ProgramFolder,false,true);
      end else begin
        UpdateToVersionInFolder2(HVr.ProgramFolder,false,false);
      end;
    end else begin
      SetCloudControllerStatus(kJobStatusError,"Cloud Controller update cancelled, no new version is available (latest version is " & new_version_build & ", running version is " & VersionBuild);
      LogText(0,"Skipping update to " & HVr.Code & " because version " & VersionBuild & ">=" & new_version_build);
      Delete_File("EnRetryNodeUpdate");
      SetGlobalBoolean("ASPIdleTasksStopped",false);
    end;
  end else begin
    LogText(0,"Failed to update to version " & HVr.Code);
    SetGlobalBoolean("ASPIdleTasksStopped",false);
  end;

LDoUpdateToVersionQueued:;
  return;
end;

global
updating procedure DoUpdateToVersion(record HansaVersionVc HVr)
begin
  record HansaVersionVc HV2r;
  Boolean canbeupdatedf;
  record CloudSettingsBlock CSb;
  Date sd;
  Time st;

  BlockLoad(CSb);
  RecordCopy(HV2r,HVr);
  GetHansaVersionAtCN(HV2r,canbeupdatedf);
  if (canbeupdatedf) then begin
    PauseASPIdleTasks;
    CSb.HansaVersion = HVr.Code; //??
    CSb.NewHansaVersion = "";
    BlockStore(CSb);
    LogText(0,"Requesting update to version " & HVr.Code);
    queued.DoUpdateToVersionQueued(HVr);
  end else begin
    LogText(0,"Requesting download of version " & HVr.Code & " for update");
    CSb.NewHansaVersion = HVr.Code;
    BlockStore(CSb);
    HVr.ForceReplaceVersionf = 1;
    DoDownloadVersion(HVr,true);
  end;

  Delete_File("EnRetryNodeUpdate");
  WriteStringToFile(HVr.Code,"EnRetryNodeUpdate",0);

  sd = CurrentDate;
  st = AddMinutes(CurrentTime,15);
  if (st<CurrentTime) then begin sd = AddDay(sd,1); end;

  LogText(0,"Scheduling a restart to retry version update to " & HVr.Code & " in case update isn't done in 15 minutes");
  NewTimedTask("RetryUpdateNodeToVersion","RetryUpdateNodeToVersion","RetryUpdateNodeToVersionTask",HVr.Code,sd,st,"","");

LDoUpdateToVersion:;
  return;
end;

global
updating procedure RetryUpdateNodeToVersionTask(string arg)
begin
  if (blank(arg)) then begin
    goto LRetryUpdateNodeToVersionTask;
  end;

  LogText(0,"Restarting node, then retrying version update to " & arg);
  QuitApplication(0,false);

LRetryUpdateNodeToVersionTask:;
  return;
end;

procedure RetryNodeUpdate()
begin
  string 255 tstr;
  record HansaVersionVc HVr;

  if (FileExists("EnRetryNodeUpdate")) then begin
    tstr = Trim(ReadStringFromFile("EnRetryNodeUpdate"));
    LogText(0,"Attempting version update to " & tstr);
    Delete_File("EnRetryNodeUpdate");
    HVr.Code = tstr;
    if (ReadFirstMain(HVr,1,true)!=true) then begin
      HVr.Code = tstr;
    end;
    queued.DoUpdateToVersion(HVr);
  end;
  return;
end;

global
procedure UpdateToVersion(record HansaVersionVc HVr)
begin
  queued.DoUpdateToVersion(HVr);
  return;
end;

global
updating procedure UpdateToVersion_WTF(record HansaVersionVc HVr)
begin
  queued.UpdateToVersion(HVr);
  return;
end;

global
updating procedure SetCloudNodeState(string cncode,Boolean fastcheckf,Boolean reachablef,Integer state)
begin
  record CloudNodeVc CNr;
  record CloudNodeVc OldCNr;
  Integer fastcheck,reachable;

  if (fastcheckf) then begin
    fastcheck = 1;
  end;
  if (reachablef) then begin
    reachable = 1;
  end;

  CNr.Code = cncode;
  if (ReadFirstMain(CNr,1,true)) then begin
    RecordCopy(OldCNr,CNr);
    if (state!=kCloudNodeStateUnknown) then begin
      CNr.CurrentState = state;
    end;
    CNr.FastCheckFlag = fastcheck;
    CNr.ReachableFlag = reachable;
    RecordUpdate(OldCNr,CNr,true);
  end;
end;

global
procedure UpdateNodeToNewVersion(record CloudNodeVc CNr)
begin
  string 255 url;
  LongInt stat;
  record HansaVersionVc HVr;
  record CloudNodeVc OldCNr;
  Boolean retval;
  string 255 archive;
  LongInt new_version_build;

  HVr.Code = CNr.NewHansaVersion;
  url = NodeURL(CNr);

  if (ReadFirstMain(HVr,1,true)==false) then begin
    LogText(0,"Failed to update CN " & CNr.Code & " to version " & HVr.Code & ", because the version doesn't exist");
    goto LUpdateNodeToNewVersion;
  end;

  if (ReadFirstMain(CNr,1,true)) then begin end;

  new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
  LogText(0,"Updating CN " & CNr.Code & " to version " & HVr.Code & " build " & new_version_build);
  stat = CallService(url).UpdateToVersion(HVr);
  if (TreatServiceError(stat,url,"UpdateToVersion")) then begin
    LogText(0,"Failed to update CN " & CNr.Code & " to version " & HVr.Code");
    goto LUpdateNodeToNewVersion;
  end;

LUpdateNodeToNewVersion:;
  return;
end;

global
updating procedure DownloadVersionOnAllNodes(record HansaVersionVc HVr)
begin
  record CloudNodeVc CNr;
  string 255 url;
  LongInt stat;
  record HansaVersionVc HV2r;
  record HansaVersionVc OldHV2r;

  while (LoopMain(CNr,1,true)) begin
    if (CNr.Closed==0) then begin
      url = NodeURL(CNr);
      stat = CallService(url).DownloadVersion(HVr);
      if (TreatServiceError(stat,url,"DownloadVersion")) then begin
        LogText(0,"Failed to make CN " & CNr.Code & " download version " & HVr.Code");
        goto LDownloadVersionOnAllNodes;
      end;
    end;
  end;

  HV2r.Code = HVr.Code;
  if (ReadFirstMain(HV2r,1,true)==true) then begin
    RecordCopy(OldHV2r,HV2r);
    HV2r.ForceReplaceVersionf = 0;
    RecordUpdate(OldHV2r,HV2r,true);
  end;

LDownloadVersionOnAllNodes:;
  return;
end;

global
updating procedure UpdateAllNodesToVersion(record HansaVersionVc HVr)
begin
  record CloudNodeVc CNr;
  record CloudNodeVc OldCNr;
  record CloudSettingsBlock CSb;
  LongInt new_version_build;

  new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
  LogText(0,"Updating all CN:s to " & HVr.Code & " (" & new_version_build & ")");
  while (LoopMain(CNr,1,true)) begin
    if ((CNr.Closed==0) and (CloudNodeStatus(CNr)!=kCloudNodeStatusUnreachable)) then begin
      RecordCopy(OldCNr,CNr);
      if (new_version_build>CNr.VersionBuild) then begin
        CNr.NewHansaVersion = HVr.Code;
        CNr.FastCheckFlag = 1;
        CNr.CurrentState = kCloudNodeStateUpdating;
        RecordUpdate(OldCNr,CNr,true);
        threadasync.UpdateNodeToNewVersion(CNr);
      end else begin
        LogText(0,"Skipping updating CN " & CNr.Code & " to " & HVr.Code & " because CN version " & CNr.VersionBuild & ">=" & new_version_build);
      end;
    end;
  end;

  BlockLoad(CSb);
  CSb.UpdateNodesFlag = 0;
  BlockStore(CSb);

  return;
end;

global
updating procedure UpdateCloudToVersion(record HansaVersionVc HVr)
begin
  record CloudSettingsBlock CSb;

  BlockLoad(CSb);
  CSb.UpdateNodesFlag = 1;
  BlockStore(CSb);
  queued.DoUpdateToVersion(HVr);

  return;
end;

global
updating procedure HttpAsyncDownloadHACallback(Boolean successf,LongInt httpres,Boolean timeout,string indir)
begin
  string 255 comment,result;
  transaction record HansaVersionVc HVr;
  transaction record HansaVersionVc OldHVr;
  transaction Boolean update_after_download;
  transaction string 255 server,path,destpath;
  transaction LongInt port,hacretries;
  LongInt old_version_build,new_version_build;
  Boolean okverf;

  hacretries = hacretries + 1;
  if (timeout==true) then begin
    LogText(0,"HttpAsyncDownloadHACallback(" & HVr.Code & ") timed out");
    goto LHttpAsyncDownloadHACallback_Retry;
  end;

  switch (httpres) begin
    case kHttpStatusNotFound:
      LogText(0,"HttpAsyncDownloadHACallback(" & HVr.Code & ") failed (httpres=404 not found)");
      goto LHttpAsyncDownloadHACallback_Retry;
    case kHttpStatusOK:
    otherwise
      LogText(0,"HttpAsyncDownloadHACallback(" & HVr.Code & ") failed (httpres=" & httpres & ")");
      goto LHttpAsyncDownloadHACallback_Retry;
  end;

  if (successf==false) then begin
    LogText(0,"HttpAsyncDownloadHACallback(" & HVr.Code & ") failed");
    goto LHttpAsyncDownloadHACallback_Retry;
  end;


  HVr.CurrentState = kHansaVersionStateNormal;
  if (nonblank(OldHVr.Code)) then begin
    old_version_build = (OldHVr.Version * 1000000) + (OldHVr.SubVersion * 10000) + OldHVr.RunningBuild;
    new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
    okverf = CheckVersion(OldHVr);
    if ((old_version_build<new_version_build) or (OldHVr.ForceReplaceVersionf!=0) or (okverf==false)) then begin
      switch (HVr.UpdateType) begin
        case kHansaVersionUpdateTypeAll:
          DeleteFolder(HVr.ProgramFolder);
          CopyFolder(indir & "/newver",HVr.ProgramFolder);
        case kHansaVersionUpdateTypeHOB:
          DeleteFolder(HVr.ProgramFolder & "/hob");
          CopyFolder(indir & "/newver/hob",HVr.ProgramFolder & "/hob");
        case kHansaVersionUpdateTypeAU:
          DeleteFolder(HVr.ProgramFolder & "/updateclients");
          Delete_File(HVr.ProgramFolder & "/hansa-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          CopyFolder(indir & "/newver/updateclients",HVr.ProgramFolder & "/updateclients");
          CopyFile(indir & "/newver/hansa-slave",HVr.ProgramFolder & "/hansa-slave");
          CopyFile(indir & "/newver/hansa-debug-slave",HVr.ProgramFolder & "/hansa-debug-slave");
          CopyFile(indir & "/newver/hansa-debug-optimized-slave",HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          CopyFile(indir & "/newver/hansa-macosx-optimized-slave",HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          CopyFile(indir & "/newver/hansa-windows-optimized-slave.exe",HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
        case kHansaVersionUpdateTypeWC:
          DeleteFolder(HVr.ProgramFolder & "/webclients");
          Delete_File(HVr.ProgramFolder & "/hansa-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          CopyFolder(indir & "/newver/webclients",HVr.ProgramFolder & "/webclients");
          CopyFile(indir & "/newver/hansa-slave",HVr.ProgramFolder & "/hansa-slave");
          CopyFile(indir & "/newver/hansa-debug-slave",HVr.ProgramFolder & "/hansa-debug-slave");
          CopyFile(indir & "/newver/hansa-debug-optimized-slave",HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          CopyFile(indir & "/newver/hansa-macosx-optimized-slave",HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          CopyFile(indir & "/newver/hansa-windows-optimized-slave.exe",HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
        case kHansaVersionUpdateTypeEXE:
          Delete_File(HVr.ProgramFolder & "/hansa-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server");
          CopyFile(indir & "/newver/hansa-slave",HVr.ProgramFolder & "/hansa-slave");
          CopyFile(indir & "/newver/hansa-debug-slave",HVr.ProgramFolder & "/hansa-debug-slave");
          CopyFile(indir & "/newver/hansa-debug-optimized-slave",HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          CopyFile(indir & "/newver/hansa-macosx-optimized-slave",HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          CopyFile(indir & "/newver/hansa-windows-optimized-slave.exe",HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          CopyFile(indir & "/newver/hansa-debug-optimized-server64",HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          CopyFile(indir & "/newver/hansa-debug-optimized-server",HVr.ProgramFolder & "/hansa-debug-optimized-server");
          CopyFile(indir & "/newver/hansa-windows-optimized-server64.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          CopyFile(indir & "/newver/hansa-windows-optimized-server.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          CopyFile(indir & "/newver/hansa-macosx-optimized-server",HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          CopyFile(indir & "/newver/hansa-debug-server64",HVr.ProgramFolder & "/hansa-debug-server64");
          CopyFile(indir & "/newver/hansa-debug-server",HVr.ProgramFolder & "/hansa-debug-server");
        case kHansaVersionUpdateTypeHOBEXE:
          DeleteFolder(HVr.ProgramFolder & "/hob");
          Delete_File(HVr.ProgramFolder & "/hansa-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server");
          CopyFolder(indir & "/newver/hob",HVr.ProgramFolder & "/hob");
          CopyFile(indir & "/newver/hansa-slave",HVr.ProgramFolder & "/hansa-slave");
          CopyFile(indir & "/newver/hansa-debug-slave",HVr.ProgramFolder & "/hansa-debug-slave");
          CopyFile(indir & "/newver/hansa-debug-optimized-slave",HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          CopyFile(indir & "/newver/hansa-macosx-optimized-slave",HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          CopyFile(indir & "/newver/hansa-windows-optimized-slave.exe",HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          CopyFile(indir & "/newver/hansa-debug-optimized-server64",HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          CopyFile(indir & "/newver/hansa-debug-optimized-server",HVr.ProgramFolder & "/hansa-debug-optimized-server");
          CopyFile(indir & "/newver/hansa-windows-optimized-server64.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          CopyFile(indir & "/newver/hansa-windows-optimized-server.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          CopyFile(indir & "/newver/hansa-macosx-optimized-server",HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          CopyFile(indir & "/newver/hansa-debug-server64",HVr.ProgramFolder & "/hansa-debug-server64");
          CopyFile(indir & "/newver/hansa-debug-server",HVr.ProgramFolder & "/hansa-debug-server");
        case kHansaVersionUpdateTypeEXEAU:
          DeleteFolder(HVr.ProgramFolder & "/updateclients");
          Delete_File(HVr.ProgramFolder & "/hansa-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          Delete_File(HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server64");
          Delete_File(HVr.ProgramFolder & "/hansa-debug-server");
          CopyFolder(indir & "/newver/updateclients",HVr.ProgramFolder & "/updateclients");
          CopyFile(indir & "/newver/hansa-slave",HVr.ProgramFolder & "/hansa-slave");
          CopyFile(indir & "/newver/hansa-debug-slave",HVr.ProgramFolder & "/hansa-debug-slave");
          CopyFile(indir & "/newver/hansa-debug-optimized-slave",HVr.ProgramFolder & "/hansa-debug-optimized-slave");
          CopyFile(indir & "/newver/hansa-macosx-optimized-slave",HVr.ProgramFolder & "/hansa-macosx-optimized-slave");
          CopyFile(indir & "/newver/hansa-windows-optimized-slave.exe",HVr.ProgramFolder & "/hansa-windows-optimized-slave.exe");
          CopyFile(indir & "/newver/hansa-debug-optimized-server64",HVr.ProgramFolder & "/hansa-debug-optimized-server64");
          CopyFile(indir & "/newver/hansa-debug-optimized-server",HVr.ProgramFolder & "/hansa-debug-optimized-server");
          CopyFile(indir & "/newver/hansa-windows-optimized-server64.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server64.exe");
          CopyFile(indir & "/newver/hansa-windows-optimized-server.exe",HVr.ProgramFolder & "/hansa-windows-optimized-server.exe");
          CopyFile(indir & "/newver/hansa-macosx-optimized-server",HVr.ProgramFolder & "/hansa-macosx-optimized-server");
          CopyFile(indir & "/newver/hansa-debug-server64",HVr.ProgramFolder & "/hansa-debug-server64");
          CopyFile(indir & "/newver/hansa-debug-server",HVr.ProgramFolder & "/hansa-debug-server");
      end;
      LogText(0,"Updating version (" & StringFromSet(583,HVr.UpdateType) & "), " & OldHVr.Code & " from build " & old_version_build & " to build " & new_version_build);
      if (update_after_download) then begin
        SetCloudControllerStatus(kJobStatusRunning,"Downloaded and unpacked version " & HVr.Code);
      end;
      HVr.ForceReplaceVersionf = 0;
      HVr.UpdateType = kHansaVersionUpdateTypeAll;
      RecordUpdate(OldHVr,HVr,true);
      HVr.Code = OldHVr.Code;
    end;
  end else begin
    RecordDelete(HVr);
    new_version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
    DeleteFolder(HVr.ProgramFolder);
    CopyFolder(indir & "/newver",HVr.ProgramFolder);
    LogText(0,"Saving version " & HVr.Code & " build " & new_version_build);
    RecordStore(HVr,true);
  end;

  okverf = CheckVersion(HVr);
  if (okverf==false) then begin
    SetHansaVersionState(HVr,kHansaVersionStateError);
  end else begin
    if (update_after_download) then begin
      queued.UpdateToVersion(HVr);
    end;
  end;

  SetShouldDownloadVersion(HVr.Code,false);
  SetDownloadingVersion(HVr.Code,false);

  goto LHttpAsyncDownloadHACallback;

LHttpAsyncDownloadHACallback_Retry:;
  if (hacretries<5) then begin
    if (IsCloudController) then begin
      if (GetGlobalBoolean("update_after_download")) then begin
        SetCloudControllerStatus(kJobStatusRunning,"Downloading new version for Cloud Controller (" & new_version_build & "), retrying");
      end;
    end;
    LogText(0,"Downloading http://" & server & ":" & port & path & ", attempt " & hacretries & ", retrying");
    HttpAsyncDownloadHA(server,port,path,30,destpath,"HttpAsyncDownloadHACallback");
  end;

LHttpAsyncDownloadHACallback:;
  DeleteFolder(destpath);
  UpdateClientBrowsesIfNeeded("HansaVersionVc");
  return;
end;

global
procedure ASPRefreshIPCC(string args)
begin
  record CloudNodeVc CNr,CN2r;
  Boolean foundf;

  CNr.Closed = 0;
  CNr.CurrentState = kCloudNodeStateGeneralFailure;
  foundf = true;
  while (LoopKey("State",CNr,2,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPRefreshIPCC; end;
    if (foundf) then begin
      if (CNr.Closed==0) then begin
        EC2RefreshIP(CNr);
      end;
    end;
  end;

  UpdateClientBrowsesIfNeeded("CloudNodeVc");

LASPRefreshIPCC:;
  return;
end;

global
procedure FastCheckCN(string args)
begin
  record CloudMachineStatsVc CMSr;
  record CloudNodeVc CNr;
  Boolean foundf;
  LongInt stat;
  Boolean failf,testf;
  string 255 url;

  CNr.FastCheckFlag = 1;
  foundf = true;
  while (LoopKey("FastCheckFlag",CNr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LFastCheckCN; end;
    if (CNr.FastCheckFlag!=1) then begin foundf = false; end;
    testf = foundf;
    if (testf and CNr.CurrentState==kCloudNodeStateCreating) then begin
      if (CNr.HansaPort<=0) then begin testf = false; end;
    end;
    if (testf and CNr.CurrentState==kCloudNodeStateStopping) then begin testf = false; end;
    if (testf and CNr.CurrentState==kCloudNodeStateStopped) then begin testf = false; end;
    if (testf and CNr.CurrentState==kCloudNodeStateTerminating) then begin testf = false; end;
    if (testf and CNr.CurrentState==kCloudNodeStateMoving) then begin testf = false; end;
    if (testf and CNr.CurrentState==kCloudNodeStateModifying) then begin testf = false; end;
    if (testf) then begin
      url = NodeURL(CNr);
      stat = CallService(url).GetCloudNodeStats(CMSr);
      failf = TreatServiceError(stat,url,"GetCloudNodeStats");
      if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LFastCheckCN; end;
      queued.SaveCloudNodeStats(CNr,CMSr,failf);
    end;
  end;

  UpdateClientBrowsesIfNeeded("CloudNodeVc");

LFastCheckCN:;
  return;
end;

global
procedure FastCheckSyncOneCN(record CloudNodeVc CNr)
begin
  array record LocalCloudServerVc lcsarr;
  array record RemoteCloudServerVc rcsarr;
  record RemoteCloudServerVc RCSr;
  string 255 url;
  LongInt stat;
  Boolean foundf,testf;

  RCSr.FastCheckFlag = 1;
  RCSr.Controller = CNr.Code;
  foundf = true;
  while (LoopKey("FastCheckFlag",RCSr,2,foundf)) begin
    if (RCSr.FastCheckFlag!=1) then begin foundf = false; end;
    if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
    testf = foundf;
    if (testf) then begin
      rcsarr[rcsarr.length] = RCSr;
    end;
  end;

  ResetLoop(RCSr);
  RecordClear(RCSr);
  RCSr.NewController = CNr.Code;
  foundf = true;
  while (LoopKey("NewController",RCSr,1,foundf)) begin
    if (RCSr.NewController!=CNr.Code) then begin foundf = false; end;
    testf = foundf;
    if (testf and (RCSr.WantedStatus!=kWantedStatusCreateServer) and
                  (RCSr.WantedStatus!=kWantedStatusCreateStartedServer) and
                  (RCSr.WantedStatus!=kWantedStatusLaunchReserveSystem) and
                  (RCSr.WantedStatus!=kWantedStatusLaunchUpdateSystem) and
                  (RCSr.WantedStatus!=kWantedStatusLaunchTestSystem)) then begin
      testf = false;
    end;
    if (testf) then begin
      rcsarr[rcsarr.length] = RCSr;
    end;
  end;

  if (rcsarr.length>0) then begin
    //LogText(0,"[Fast] Synchronizing " & rcsarr.length & " CC cloud server records with node " & CNr.Code);
    url = NodeURL(CNr);
    stat = CallService(url).FastSyncLCSDataAtCN_WTF(rcsarr,lcsarr);
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LFastCheckSyncOneCN; end;
    if (TreatServiceError(stat,url,"FastSyncLCSDataAtCN")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to [fast] synchronize " & rcsarr.length & " CC cloud server records with node " & CNr.Code);
      goto LFastCheckSyncOneCN;
    end;
    queued.SaveCloudNodeReachable(CNr,true);

    if (lcsarr.length>0) then begin
      LogText2(0,"[Fast] Synchronizing " & rcsarr.length & " CC and " & lcsarr.length & " CN cloud server records with node " & CNr.Code,kVerbosityDebug);
      qupdating.SaveNewAndUpdatedRCSs(CNr,lcsarr);
    end;
  end else begin
    LogText(0,"[Fast] Synchronizing failed because no RCSr:s was found for node: " & CNr.Code);
  end;

LFastCheckSyncOneCN:;
  return;
end;

global
procedure FastCheckRCS(string args)
begin
  record CloudNodeVc CNr;
  record RemoteCloudServerVc RCSr;
  array record CloudNodeVc cnarr;
  Boolean foundf,skipf,testf;
  string 255 last_controller,controller;
  LongInt i;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LFastCheckRCS; end;

  i = 0;
  RCSr.FastCheckFlag = 1;
  foundf = true;
  while (LoopKey("FastCheckFlag",RCSr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LFastCheckRCS; end;
    if (RCSr.FastCheckFlag!=1) then begin foundf = false; end;
    testf = foundf;
    if (testf and nonblank(RCSr.Controller)) then begin
      CNr.Code = RCSr.Controller;
      if (ReadFirstMain(CNr,1,true)) then begin
        if (CNr.ReachableFlag<>1) then begin testf = false; end;
      end;
    end;
    if (testf and blank(RCSr.Controller)) then begin
      if (blank(RCSr.NewController)) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      controller = RCSr.Controller;
      if (blank(controller)) then begin controller = RCSr.NewController; end;
      if ((controller!=last_controller) or blank(last_controller)) then begin
        CNr.Code = controller;
        if (ReadFirstMain(CNr,1,true)) then begin
          cnarr[i] = CNr;
          i = i + 1;
          skipf = false;
          switch (CNr.CurrentState) begin
            case kCloudNodeStateUnknown: skipf = true;
            case kCloudNodeStateNormal: skipf = false;
            case kCloudNodeStateUpdating: skipf = true;
            case kCloudNodeStateGeneralFailure: skipf = false;
            case kCloudNodeStateUpdateFailure: skipf = false;
            case kCloudNodeStateDifferentVersion: skipf = false;
            case kCloudNodeStateCreating: skipf = true;
            case kCloudNodeStateStopping: skipf = true;
            case kCloudNodeStateStopped: skipf = true;
            case kCloudNodeStateStarting: skipf = true;
            case kCloudNodeStateTerminating: skipf = true;
            case kCloudNodeStateMoving: skipf = true;
            case kCloudNodeStateModifying: skipf = true;
          end;
          if (CNr.ReachableFlag==0) then begin skipf = true; end;
          if (RCSr.CurrentStatus==kStatusConfigInError and RCSr.WantedStatus==kWantedStatusRun) then begin skipf = true; end;
          if (RCSr.WantedStatus==kWantedStatusManual) then begin skipf = true; end;
          if (skipf==false) then begin
            FastCheckSyncOneCN(CNr);
            last_controller = controller;
          end;
        end else begin
          LogText(0,"FastCheckRCS() Node " & CNr.Code & " used by RCSr " & RCSr.Name & ", " & RCSr.UUID & " doesn't exist");
        end;
      end;
    end;
  end;

  UpdateClientBrowsesIfNeeded("LocalCloudServerVc");
  UpdateClientBrowsesIfNeeded("RemoteCloudServerVc");
  UpdateClientBrowsesIfNeeded("CloudNodeVc");

LFastCheckRCS:;
  return;
end;

procedure PauseASPIdleTasks()
begin
  LogText(0,"Stopping periodic ASP tasks");
  if (IsCloudController) then begin
    SetCloudControllerStatus(kJobStatusRunning,"Stopping Cloud Controller background tasks");
  end;
  SetGlobalBoolean("ASPIdleTasksStopped",true);

  return;
end;

procedure CheckSystemArchitecture()
begin
  string 255 script;

  if (WindowsMode) then begin
    script = "cmd /c \"if defined PROCESSOR_ARCHITECTURE (if defined PROCESSOR_ARCHITEW6432 (echo >En64BitOS) else ";
    script = script & "(if \"%PROCESSOR_ARCHITECTURE%\" == \"x86\" (set dummy=) else (echo >En64BitOS))) else ";
    script = script & "(if \"%PROCESSOR_ARCHITECTURE%\" == \"x86\" (set dummy=) else (echo >En64BitOS))\"";
  end else begin
    script = "bash -c '( ";
    script = script & "if ( [ $(getconf LONG_BIT) -eq 64 ] ) ; then touch En64BitOS ; else rm -f En64BitOS ; fi ;";
    script = script & " )' ";
  end;
  RunShellScript(script);

  if (FileExists("En64BitOS")) then begin
    SetGlobalBoolean("En64BitOS",true);
  end else begin
    SetGlobalBoolean("En64BitOS",false);
  end;
end;

global
updating procedure ResetVersionsRegister()
begin
  record HansaVersionVc HVr,OldHVr;

//TODO: Each version that is in "Deprecated" should be deleted and deleted from disk if no LCSr or RCSr are found that use them in Version or New Version fields
  while (LoopMain(HVr,0,true)) begin
    if (HVr.CurrentState==kHansaVersionStateUnavailable) then begin
      RecordDelete(HVr);
      StepBack(HVr);
    end else begin
      if ((HVr.UpdateType<>kHansaVersionUpdateTypeAll) or
          (HVr.CurrentState==kHansaVersionStateInstalling)) then begin
        RecordCopy(OldHVr,HVr);
        HVr.UpdateType = kHansaVersionUpdateTypeAll;
        HVr.CurrentState = kHansaVersionStateNotDownloaded;
        RecordUpdate(OldHVr,HVr,false);
      end;
    end;
  end;
end;

global
function Boolean RunMultilineOutCommand(string command,var area atmp)
begin
  Boolean res;
  string 255 script,tmpfile,outfile,errfile,sucfile,scriptfile,bsfile;
  LongInt endtick,starttick;

  starttick = GetCurTick;

  AddLineToArea(command,atmp);
  scriptfile = CreateTempFile("script",".sh");
  WriteAreaToFile(atmp,scriptfile,0);
  SetAreaZeroSize(atmp);

  tmpfile = CreateTempFile("script",".out");
  outfile = tmpfile & ".out";
  errfile = tmpfile & ".err";
  sucfile = tmpfile & ".suc";

  bsfile = CreateTempFile("scriptstarter",".sh");
  AddLineToArea("#!/bin/bash",atmp);
  AddLineToArea("bash " & scriptfile & " >" & outfile & " && touch " & sucfile & " || touch " & errfile,atmp);
  WriteAreaToFile(atmp,bsfile,0);

  script = "bash " & bsfile;
  RunShellScript(script);
  Delete_File(bsfile);
  Delete_File(scriptfile);

  if (FileExists(sucfile)) then begin
    Delete_File(sucfile);
    res = true;
  end else begin
    if (FileExists(errfile)) then begin
      Delete_File(errfile);
    end;
  end;

  SetAreaZeroSize(atmp);
  AddFileToArea(outfile,atmp,false);
  Delete_File(outfile);
  Delete_File(tmpfile);

  if (ThisIsMainThread) then begin
    endtick = GetCurTick;
    if ((endtick-starttick)>=1000) then begin
      LogText(0,"SLOW SCRIPT " & endtick-starttick & "ms: " & command);
    end;
  end;

  RunMultilineOutCommand = res;
end;

global
function Boolean RunOneLineOutCommand(string command,var string output)
begin
  Boolean res;
  LongInt lcnt;
  area atmp;

  res = RunMultilineOutCommand(command,atmp);

  output = "";
  if (res==true) then begin
    lcnt = CountLinesInArea(atmp);
    if (lcnt>0) then begin
      output = Trim(GetLineFromArea(atmp,0));
    end;
  end;

  RunOneLineOutCommand = res;
end;

global
function Integer RunScriptInBackground(string lockfile,area a_script,area a_script_data)
begin
  Integer res; // 0 = error, 1 = started, 2 = already running
  string 255 donefile,datafile;
  string 255 scriptfile,bootstrap_script;
  LongInt cnt;
  LongInt lpid;
  area a_tmp;

  datafile = lockfile & "Data";
  donefile = lockfile & "Completed";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      res = 2;
      goto LRunScriptInBackground; // Operation already in progress, only 1 at the time allowed
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          Delete_File(datafile);
        end else begin
          // fatal error: not running, not done...
        end;
      end else begin
        // pending start...
      end;
    end;
  end;

  scriptfile = CreateTempFile("bootstrap_script",".sh");

  AddLineToArea("trap \"rm -f $0\" EXIT",a_tmp);
  AddAreaToArea(a_script,a_tmp);
  WriteAreaToFile(a_tmp,scriptfile,0);

  if (GetAreaLength(a_script_data)>0) then begin
    AddLineToArea("",a_script_data);
    WriteAreaToFile(a_script_data,datafile,0);
  end;

  bootstrap_script = "touch " & lockfile & "; chmod a+x " & scriptfile & "; bash -c '( echo -n $$ >>" & lockfile & " ; ";
  bootstrap_script = bootstrap_script & "./" & scriptfile & " ; ";
  bootstrap_script = bootstrap_script & "touch " & donefile & " ; )' &";
  RunShellScript(bootstrap_script);

  cnt = 0;

LRunScriptInBackground_Wait:;
  cnt = cnt + 1;
  lpid = ReadLongFromFile(lockfile);
  if (lpid>=1) then begin
    res = 1;
    goto LRunScriptInBackground;
  end;
  if (cnt>10000000) then begin
    LogText(0,"FATAL Script didn't start properly");
    goto LRunScriptInBackground;
  end;
  goto LRunScriptInBackground_Wait;

LRunScriptInBackground:;
  RunScriptInBackground = res;
  return;
end;

procedure HostingConfigBlockToVc(record HostingConfigBlock HCb,var record HostingConfigurationVc HCr)
begin
  string 255 tstr;

  tstr = StringFromSet(331,HCb.HostingType);
  tstr = tstr & " hosting in " & HCb.AmazonZone;
  HCr.Comment = tstr;

  HCr.AmazonKeyPairID = HCb.AmazonKeyPairID;
  HCr.HostingType = HCb.HostingType;
  HCr.Closed = 0;
  HCr.AmazonAccountNumber = HCb.AmazonAccountNumber;
  HCr.AmazonRegion = HCb.AmazonRegion;
  HCr.AmazonZone = HCb.AmazonZone;
end;


global
updating procedure MatchHostingConfiguration(record CloudNodeVc CN2r,record HostingConfigBlock HCb,var record HostingConfigurationVc HCr)
begin
  record CloudNodeVc CNr,OldCNr;
  record  HostingConfigurationVc HC2r;
  LongInt dbg_cnt;

  RecordCopy(CNr,CN2r);
  dbg_cnt = 0;
  while (LoopMain(HC2r,0,true)) begin
    dbg_cnt = dbg_cnt + 1;
    if (HC2r.Closed==0) then begin
      if (HC2r.HostingType==HCb.HostingType) then begin
        switch (HCb.HostingType) begin
          case kHostingTypeAzure: // Not implemented yet
            goto LMatchHostingConfiguration;
          case kHostingTypeRackspace: // Not implemented yet
            goto LMatchHostingConfiguration;
          case kHostingTypeGoogle: // Not implemented yet
            goto LMatchHostingConfiguration;
          case kHostingTypeAmazon:
            if ((HC2r.AmazonAccountNumber==HCb.AmazonAccountNumber) and
                (HC2r.AmazonKeyPairID==HCb.AmazonKeyPairID) and
                (HC2r.AmazonZone==HCb.AmazonZone)) then begin
                RecordCopy(HCr,HC2r);
                LogText(0,"Hosting Configuration " & HC2r.SerNr & " matched to " & CNr.Code);
               goto LMatchHostingConfiguration;
            end;
          case kHostingTypeUnknown:
            goto LMatchHostingConfiguration;
        end;
      end;
    end;
  end;

  if (dbg_cnt!=CountRecords("HostingConfigurationVc")) then begin
    LogText(0,"ERROR dbg_cnt!=ViewSz(HostingConfigurationVc), dbg_cnt=" & dbg_cnt & ", ViewSz=" & CountRecords("HostingConfigurationVc"));
    goto LMatchHostingConfiguration;
  end;

  RecordClear(HCr);
  HostingConfigBlockToVc(HCb,HCr);
  HCr.SerNr = NextSerNr("HostingConfigurationVc",CurrentDate,-1,false,"");
  LogText(0,"Adding new hosting configuration " & HCr.SerNr & ", AccNo: " & HCb.AmazonAccountNumber & ", Key: " & HCb.AmazonKeyPairID & ", Zone: " & HCb.AmazonZone & " for node " & CNr.Code & ", ViewSz=" & CountRecords("HostingConfigurationVc"));
  RecordStore(HCr,false);

LMatchHostingConfiguration:;
  if (ReadFirstMain(CNr,1,true)) then begin
    RecordCopy(OldCNr,CNr);
    if (nonblank(HCr.SerNr)) then begin
      CNr.HostingConfig = HCr.SerNr;
      CNr.HostingConfigComment = HCr.Comment;
      if (HCb.HostingType==kHostingTypeAmazon) then begin
        CNr.AmazonInstanceType = HCb.AmazonInstanceType;
        CNr.AmazonInstanceId = HCb.AmazonInstanceId;
        CNr.AmazonImageId = HCb.AmazonImageId;
        CNr.AmazonKernelId = HCb.AmazonKernelId;
        CNr.AmazonPrivateIP = HCb.AmazonPrivateIP;
        CNr.AmazonPublicDNS = HCb.AmazonPublicDNS;
        if (HCb.AmazonEC2UserFlag==1) then begin
          CNr.AdminUser = "ec2-user";
        end else begin
          CNr.AdminUser = "root";
        end;
        CNr.Platform = CN2r.Platform;
      end;
    end;
    if (HCb.NodeHTTPPort>0) then begin
      CNr.WebPort = HCb.NodeHTTPPort;
    end;
    if (HCb.NodePort>0) then begin
      CNr.HansaPort = HCb.NodePort;
    end;
    RecordUpdate(OldCNr,CNr,false);
    threadasync.EC2RefreshIP(CNr);
  end;
end;

global
procedure GetHostingConfigAtNode(var record HostingConfigBlock HCb)
begin
  BlockLoad(HCb);
end;

global
procedure GetNodeInfo1(var record HostingConfigBlock HCb,var LongInt platform)
begin
  GetHostingConfigAtNode(HCb);
  platform = ProgramPlatform;
end;

global
procedure GetOneNodeHostingConfig(record CloudNodeVc CNr)
begin
  record HostingConfigurationVc HCr;
  record HostingConfigBlock HCb;
  string 255 url;
  LongInt stat,pos,platform;
  area a_info;

  if (CNr.VersionBuild<73160010) then begin
    goto LGetOneNodeHostingConfig;
  end;

  LogText(0,"Refreshing hosting configuration for node " & CNr.Code);

  url = NodeURL(CNr);
  if (CNr.VersionBuild<80000000) then begin
    stat = CallService(url).GetHostingConfigAtNode(HCb);
    if (TreatServiceError(stat,url,"GetHostingConfigAtNode")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to refresh hosting configuration from node " & CNr.Code);
      goto LGetOneNodeHostingConfig;
    end;
  end else begin
    stat = CallService(url).GetNodeInfo1(HCb,platform);
    if (TreatServiceError(stat,url,"GetNodeInfo1")) then begin
      queued.SaveCloudNodeReachable(CNr,false);
      LogText(0,"Failed to refresh node info (v1) for node " & CNr.Code);
      goto LGetOneNodeHostingConfig;
    end;
    CNr.Platform = platform;
  end;

  if (HCb.HostingType!=kHostingTypeUnknown) then begin
    queued.MatchHostingConfiguration(CNr,HCb,HCr);
  end;
LGetOneNodeHostingConfig:;
end;

global
updating procedure DetectHostingConfiguration()
begin
  record HostingConfigBlock HCb;
  string 255 tstr;

  BlockLoad(HCb);
  HCb.NodePort = ServerTCPPort;
  HCb.NodeHTTPPort = ServerHttpPort;

  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"accountId\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonAccountNumber!=tstr) then begin
      HCb.AmazonAccountNumber = tstr;
    end;
  end;

  if (nonblank(HCb.AmazonAccountNumber)) then begin
    HCb.HostingType = kHostingTypeAmazon;
  end else begin
    if (HCb.HostingType==kHostingTypeAmazon) then begin
      HCb.HostingType = kHostingTypeUnknown;
    end;
    goto LDetectHostingConfiguration_SkipAmazon;
  end;

  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/meta-data/public-keys/|head -1|cut -d= -f2",tstr)==true) then begin
    if (HCb.AmazonKeyPairID!=tstr) then begin
      HCb.AmazonKeyPairID = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"region\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonRegion!=tstr) then begin
      HCb.AmazonRegion = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"availabilityZone\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonZone!=tstr) then begin
      HCb.AmazonZone = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"instanceType\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonInstanceType!=tstr) then begin
      HCb.AmazonInstanceType = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"instanceId\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonInstanceId!=tstr) then begin
      HCb.AmazonInstanceId = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"imageId\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonImageId!=tstr) then begin
      HCb.AmazonImageId = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"kernelId\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonKernelId!=tstr) then begin
      HCb.AmazonKernelId = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/dynamic/instance-identity/document|grep '\"privateIp\"'|cut -d: -f2|sed 's/.*\"\\(.*\\)\".*/\\1/g'",tstr)==true) then begin
    if (HCb.AmazonPrivateIP!=tstr) then begin
      HCb.AmazonPrivateIP = tstr;
    end;
  end;
  if (RunOneLineOutCommand("curl -qfsLm 2 http://169.254.169.254/latest/meta-data/public-hostname/",tstr)==true) then begin
    if (HCb.AmazonPublicDNS!=tstr) then begin
      HCb.AmazonPublicDNS = tstr;
    end;
  end;

  if (RunOneLineOutCommand("id -u ec2-user &>/dev/null || echo no && echo yes",tstr)==true) then begin
    if (tstr=="yes") then begin
      HCb.AmazonEC2UserFlag = 1;
    end else begin
      HCb.AmazonEC2UserFlag = 0;
    end;
  end;

LDetectHostingConfiguration_SkipAmazon:;
  BlockStore(HCb);

LDetectHostingConfiguration:;
end;

global
function string 255 GetArchiveDownloadURL(record ASPArchiveVc AAr)
begin
  record CloudNodeVc CNr;
  record HostingConfigurationVc HCr;
  string 255 res,tempaccesskeyid,tempaccesskey,sessiontoken,server,inpath,path;

  if (!ReadFirstMain(AAr,1,true)) then begin
    LogText(0,"Can't generate download link for archived file because the archive record doesn't exist (" & AAr.UUID & ")");
    goto LGetArchiveDownloadURL;
  end;
  if ((AAr.State==kArchiveFileStateLocal) or (AAr.State==kArchiveFileStateUploadingToLongTerm)) then begin
    // TODO: Kristaps, generate direct download link to .bz2 file here
    goto LGetArchiveDownloadURL;
  end;
  if (AAr.State==kArchiveFileStatePendingArchiving) then begin
    // TODO: Kristaps, generate direct download link to .TXT file here
    goto LGetArchiveDownloadURL;
  end;

  if ((AAr.State==kArchiveFileStateLocalAndLongTerm) or (AAr.State==kArchiveFileStateLongTerm)) then begin
    if (blank(AAr.AmazonRegion)) then begin // TODO: add support for old-style backups that are in hansaworld-cloudarchive bucket
      LogText(0,"Can't generate download link for archived file because the region isn't set (" & AAr.UUID & ")");
      goto LGetArchiveDownloadURL;
    end;
    if (blank(AAr.Controller)) then begin // TODO: add bucket and hosting config to AAr record and use this as fallback
      LogText(0,"Can't generate download link for archived file because the node isn't set (" & AAr.UUID & ")");
      goto LGetArchiveDownloadURL;
    end;
    CNr.Code = AAr.Controller;
    if (!ReadFirstMain(CNr,1,true)) then begin // TODO: fallback on region if node is missing, and use bucket stored on AAr record
      LogText(0,"Can't generate download link for archived file because the node doesn't exist (" & AAr.UUID & ")");
      goto LGetArchiveDownloadURL;
    end;
    HCr.SerNr = CNr.HostingConfig;
    if (!ReadFirstMain(HCr,1,true)) then begin
      LogText(0,"Can't generate download link for archived file because the node's hosting configuration doesn't exist (" & AAr.UUID & ")");
      goto LGetArchiveDownloadURL;
    end;
    if (blank(HCr.AmazonAccessKeyID) or blank(HCr.AmazonSecretAccessKey)) then begin
      LogText(0,"Can't generate download link for archived file because the node's hosting configuration doesn't have credentials (" & AAr.UUID & ")");
      goto LGetArchiveDownloadURL;
    end;

    if (AAr.AmazonRegion=="us-east-1") then begin
      server = HCr.AmazonCloudArchiveBucket & ".s3.amazonaws.com";
    end else begin
      server = HCr.AmazonCloudArchiveBucket & ".s3-" & AAr.AmazonRegion & ".amazonaws.com";
    end;

    inpath = "/" & AAr.ServerUUID & "/" & AAr.UUID & "/" & AAr.FileName;
    GetAmazonSessionToken(AAr.AmazonRegion,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,tempaccesskeyid,tempaccesskey,sessiontoken);
    path = SignAmazonRequestPath(server,inpath,"UNSIGNED-PAYLOAD",AAr.AmazonRegion,"s3",tempaccesskeyid,tempaccesskey,sessiontoken);
    res = "https://" & server & path;
  end;

LGetArchiveDownloadURL:;
  GetArchiveDownloadURL = res;
  return;
end;

global
updating procedure InitASPIdleTasks()
begin
  record ModuleBlock Modr;
  record CloudSettingsBlock CSb;
  record HansaVersionVc HVr;
  LongInt poll_lcs_interval,sync_cn_interval,check_cn_interval,watchpoint_interval,expire_invites_interval;
  LongInt fastcheck_interval,clean_stats_interval,check_versions_interval,autoupdate_interval,cc_status_interval;
  LongInt refreship_interval,archive_lcs_interval,cn_status_interval,update_cn_archive_interval;
  LongInt transfer_to_cloudarchive_interval,download_localizations_interval,clean_versions_interval;
  LongInt clean_cloudarchive_interval,sync_aspevents_interval;
  LongInt pool_interval,hmcu_interval;
  Date td;
/*
record HostingConfigurationVc HCr;
record CloudNodeVc CNr;

CNr.Code = "LVG1612013";
ReadFirstMain(CNr,1,true);
HCr.SerNr = CNr.HostingConfig;
ReadFirstMain(HCr,1,true);
SetAmazonInstanceAddress(HCr,CNr,"52.208.52.136");
*/
  BlockLoad(Modr);
  if (Modr.ASPEnabler) then begin
    BlockLoad(CSb);
    poll_lcs_interval = CSb.PollLocalServersSeconds;
    if (poll_lcs_interval<=0) then begin
      poll_lcs_interval = 5;
    end;
    sync_cn_interval = CSb.PollRemoteServersSeconds;
    if (sync_cn_interval<=0) then begin
      sync_cn_interval = 60;
    end;
    check_cn_interval = sync_cn_interval;
    sync_aspevents_interval = 300; // 5 minutes
    watchpoint_interval = 20;
    expire_invites_interval = 1800; // 30 minutes
    watchpoint_interval = 5;
    fastcheck_interval = 1;
    cc_status_interval = 1;
    cn_status_interval = 1;
    clean_stats_interval = 3600; // 60 minutes
    check_versions_interval = 60; // 1 minute
    autoupdate_interval = 30; // 30 seconds
    refreship_interval = 10;
    archive_lcs_interval = 3600; // 60 minutes
    update_cn_archive_interval = 300; // 5 minutes
    clean_cloudarchive_interval = 3600; // 60 minutes
    transfer_to_cloudarchive_interval = 3600; // 60 minutes
    download_localizations_interval = 60; // 1 minute
    clean_versions_interval = 1800; // 30 minutes
    pool_interval = 60; // 1 minute
    hmcu_interval = 1800; //30 minutes

    if (IsCloudController or IsCloudNode) then begin
      LogText(0,"Setting up periodic ASP Cloud tasks");
      if (IsCloudNode) then begin
        ResetCloudArchiveOnCN;
      end else begin
        ResetCloudArchiveOnCC;
      end;
      DetectHostingConfiguration;
      ResetVersionsRegister;
      SetGlobalBoolean("ASPIdleTasksStopped",false);
      CheckSystemArchitecture;
      NewPeriodicTask("CheckHansaVersions","Check hansa versions state","CheckHansaVersions","",check_versions_interval,"");
      NewPeriodicTask2("ASPFastPollServersTask","Fast Poll Cloud Servers","ASPFastPollServersTask","",fastcheck_interval,"");
      NewPeriodicTask2("ASPPollServersTask","Poll Cloud Servers","ASPPollServersTask","",poll_lcs_interval,"");
    end;

    if (IsCloudController) then begin
      LogText(0,"Running as Cloud Controller");
      NewPeriodicTask2("SyncRCSDataWithAllCNs","Update RCS status from nodes and node LCS records from CC","SyncRCSDataWithAllCNs","",sync_cn_interval,"");
      NewPeriodicTask2("CheckCloudNodes","Poll Cloud Nodes","CheckCloudNodes","",check_cn_interval,"");
      NewPeriodicTask2("FastCheckCN","Short-interval stats collection from Cloud Nodes","FastCheckCN","",fastcheck_interval,"");
      NewPeriodicTask2("FastCheckRCS","Short-interval update RCS status from nodes","FastCheckRCS","",fastcheck_interval,"");
      NewPeriodicTask2("UpdateArchiveFromNodesTask","Update Archive from Cloud Nodes","UpdateArchiveFromNodesTask","",update_cn_archive_interval,"");
      NewPeriodicTask2("TransferToCloudArchiveTask","Transfer Locally Archived Files on Cloud Nodes to Cloud Archive","TransferToCloudArchiveTask","",transfer_to_cloudarchive_interval,"");
      NewPeriodicTask("ASPRemoveExpiredInvitesTask","Delete Expired Invitation","ASPRemoveExpiredInvitesTask","",expire_invites_interval,""); // 30 minutes
      NewPeriodicTask("PeriodicNodeStatsCleanup","Delete old cloud statistics records","PeriodicNodeStatsCleanup","",clean_stats_interval,"");
      NewPeriodicTask("ASPCheckStatusTaskCC","Check Cloud Controller Status","ASPCheckStatusTaskCC","",cc_status_interval,"");
      NewPeriodicTask2("ASPRefreshIPCC","Refresh Node IP Addresses","ASPRefreshIPCC","",refreship_interval,"");
      NewPeriodicTask2("ASPCloudsWatchpoints","Watch Cloud","ASPCloudsWatchpointsIdleTask","",watchpoint_interval,"");
      NewPeriodicTask2("ASPCloudWatchpointSendSMS","Watch Cloud Issues","ASPCloudWatchpointSendSMSIdleTask","",watchpoint_interval,"");
      NewPeriodicTask2("ASPCheckHostPools","Keep pool of available servers filled up","ASPCheckHostPoolsTask","",pool_interval,"");
      NewPeriodicTask2("SyncASPEventsFromAllCNs","Get ASP events from nodes","SyncASPEventsFromAllCNs","",sync_aspevents_interval,"");

      td = CurrentDate;
      td.day = 1;
      if (td<CurrentDate) then begin
        td = AddMonth(td,1);
      end else begin
        if (td==CurrentDate) then begin
          if (CurrentTime>StringToTime("02:00:00")) then begin
            td = AddMonth(td,1);
          end;
        end;
      end;
      NewTimedTask2("UpdateAmazonCostStatsTask","Update Amazon Cost Statistics","UpdateAmazonCostStatsTask","",td,"02:00:00","","");

      threadasync.InitAllNodes;

      // Things to do at startup
      if (CSb.UpdateNodesFlag!=0) then begin
        if (GetVersion(CSb.HansaVersion,HVr)==true) then begin
          queued.UpdateAllNodesToVersion(HVr);
        end else begin
          LogText(0,"Failed updating all CN:s to " & HVr.Code & " (GetVersion()==false)");
        end;
      end;
    end;

    if (IsCloudNode) then begin
      LogText(0,"Running as Cloud Node");
      NewPeriodicTask2("ArchiveLocalCloudServerFiles","Archive Local Cloud Server Files","ArchiveLocalCloudServerFiles","",archive_lcs_interval,"");
      NewPeriodicTask2("CleanCloudArchiveTask","Remove Files That Have Been Long-Term Archived","CleanCloudArchiveTask","",clean_cloudarchive_interval,"");
      NewPeriodicTask2("DownloadLocalizationsForLCSsTask","Download Missing Localizations for all Cloud Servers","DownloadLocalizationsForLCSsTask","",download_localizations_interval,"");
      NewPeriodicTask2("ASPCleanVersionsTask","Delete version folders that are not in use","ASPCleanVersionsTask","",clean_versions_interval,"");
      NewPeriodicTask2("ASPClearTempFileDownloadSessionTask","Clear File Download Sessions","ASPClearTempFileDownloadSessionTask","",transfer_to_cloudarchive_interval,"");
      //NewPeriodicTask2("GetHMCustCodeFromBackupTask","Get HM Cust Code","GetHMCustCodeFromBackupTask","",hmcu_interval,"");
      td = CurrentDate;
      if (CurrentTime>StringToTime("00:05:00")) then begin
        td = AddDay(CurrentDate,1);
      end;
      NewTimedTask2("GetHMCustCodeFromBackupTask","GetHMCustCodeFromBackupTask","GetHMCustCodeFromBackupTask","",td,"00:05:00","","");

      RetryNodeUpdate;
    end;

    if (TestEnablerFile("EnASPAU")) then begin
      LogText(0,"Setting up periodic ASP Autoupdate Server tasks");
      NewPeriodicTask("ImportAutoupdateRecords","Import Autoupdate Records","ImportAutoupdateRecords","",autoupdate_interval,"");
      queued.ImportAutoupdateRecords("");
    end;
  end;

  return;
end;

global
procedure UpdateClosedRCS(record RemoteCloudServerVc RCSr)
begin
  string 255 url;
  array record LocalCloudServerVc lcsarr;
  array record RemoteCloudServerVc rcsarr;
  record CloudNodeVc CNr;
  LongInt stat;

  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin goto LUpdateClosedRCS; end;

  CNr.Code = RCSr.Controller;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    LogText(0,"UpdateClosedRCS(\"" & RCSr.Controller & "\") failed, CN record not found");
    goto LUpdateClosedRCS;
  end;

  rcsarr[0] = RCSr;
  stat = CallService(url).SyncLCSDataAtCN(rcsarr,lcsarr);
  if (TreatServiceError(stat,url,"SyncLCSDataAtCN")) then begin
    queued.SaveCloudNodeReachable(CNr,false);
    LogText(0,"[Close] Failed to synchronize " & rcsarr.length & " CC cloud server records with node " & CNr.Code);
    goto LUpdateClosedRCS;
  end;

  LogText(0,"[Close] Synchronizing " & rcsarr.length & " CC and " & lcsarr.length & " CN cloud server records with node " & CNr.Code);
  qupdating.SaveNewAndUpdatedRCSs(CNr,lcsarr);

LUpdateClosedRCS:;
  return;
end;

global
procedure GetVersionUpdateServerList(string vercode,var array uuid serveridarr,var array string servernamearr,var array string servernodearr,var array string serverstatusarr)
begin
  record RemoteCloudServerVc RCSr;
  record HansaVersionVc HVr;
  LongInt i;

  HVr.Code = vercode;
  if (ReadFirstMain(HVr,1,true)) then begin
    i = 0;
    while (LoopMain(RCSr,0,true)) begin
      if (RCSr.Closed==0) then begin
        if ((RCSr.HansaVersion==HVr.Code) or (RCSr.NewHansaVersion==HVr.Code)) then begin
          serveridarr[i] = RCSr.UUID;
          servernamearr[i] = RCSr.Name;
          servernodearr[i] = RCSr.Controller;
          serverstatusarr[i] = StatusName(RCSr.CurrentStatus);
          i = i + 1;
        end;
      end;
    end;
  end;
end;

global
function Boolean CheckOrRunScript(record CloudNodeVc CNr,Boolean checkf,record RcVc RepSpec,var record RcVc ResRepSpec)
begin
  Boolean res;
  LongInt l,lcnt;
  string 255 tstr,script,tmpfile,outfile,errfile,sucfile,scriptfile,bsfile;
  area atmp;

  lcnt = LineTextCnt2(RepSpec);
  for (l = 0; l<lcnt; l = l + 1) begin
    tstr = LineTextGet2(RepSpec,l);
    AddLineToArea(tstr,atmp);
  end;
  scriptfile = CreateTempFile("script",".sh");
  WriteAreaToFile(atmp,scriptfile,0);
  SetAreaZeroSize(atmp);

  tmpfile = CreateTempFile("script",".out");
  outfile = tmpfile & ".out";
  errfile = tmpfile & ".err";
  sucfile = tmpfile & ".suc";

  bsfile = CreateTempFile("scriptstarter",".sh");
  AddLineToArea("#!/bin/bash",atmp);
  if (checkf==true) then begin
    AddLineToArea("bash -n " & scriptfile & " &>" & outfile & " && touch " & sucfile & " || touch " & errfile,atmp);
  end else begin
    AddLineToArea("bash " & scriptfile & " &>" & outfile & " && touch " & sucfile & " || touch " & errfile,atmp);
  end;
  WriteAreaToFile(atmp,bsfile,0);

  script = "bash " & bsfile;
  RunShellScript(script);
  Delete_File(bsfile);
  Delete_File(scriptfile);

  if (FileExists(sucfile)) then begin
    Delete_File(sucfile);
    res = true;
    if (checkf==false) then begin
      LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"The script executed successfully on node " & CNr.Code & ":");
    end;
  end else begin
    if (checkf==true) then begin
      if (FileExists(errfile)) then begin
        LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"ERROR: Script failed the syntax check:");
        Delete_File(errfile);
      end else begin
        LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"FATAL ERROR: The script could not  be tested.");
      end;
      LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"");
      LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"Output:");
      LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"");
    end else begin
      if (FileExists(errfile)) then begin
        LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"ERROR: When running on " & CNr.Code & ":");
        Delete_File(errfile);
      end else begin
        LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"FATAL ERROR: The node " &  CNr.Code & " could not start the script.");
      end;
      LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"");
    end;
  end;


  SetAreaZeroSize(atmp);
  AddFileToArea(outfile,atmp,false);
  Delete_File(outfile);
  Delete_File(tmpfile);

  lcnt = CountLinesInArea(atmp);
  for (l = 0; l<lcnt; l = l + 1) begin
    tstr = GetLineFromArea(atmp,l);
    LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),tstr);
  end;
  if (checkf==false and l>0) then begin
    LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"");
  end;

  CheckOrRunScript = res;
end;

global
procedure CheckScript(record RcVc RepSpec,var record RcVc ResRepSpec,var Boolean res)
begin
  record CloudNodeVc CNr;
  
  res = CheckOrRunScript(CNr,true,RepSpec,ResRepSpec);
  return;
end;

global
procedure RunScriptOnHost(record CloudNodeVc CNr,record RcVc RepSpec,var record RcVc ResRepSpec,var Boolean res)
begin
  res = CheckOrRunScript(CNr,false,RepSpec,ResRepSpec);
end;

global
procedure RunScriptOnHosts(array string nodearr,record RcVc RepSpec,var record RcVc ResRepSpec,var Boolean res)
begin
  record CloudNodeVc CNr;
  string 255 url;
  LongInt stat;
  Integer i;

  for (i = 0; i<nodearr.length; i = i + 1) begin
    CNr.Code = nodearr[i];
    if (ReadFirstMain(CNr,1,true)) then begin
      if (CNr.Closed==0) then begin
        url = NodeURL(CNr);
        stat = CallService(url).RunScriptOnHost(CNr,RepSpec,ResRepSpec,res);
        if (TreatServiceError(stat,url,"RunScriptOnHost")) then begin
          queued.SaveCloudNodeReachable(CNr,false);
          LineTextPut2(ResRepSpec,LineTextCnt2(ResRepSpec),"Could not contact node " & CNr.Code & ", skipped");
          goto LRunScript;
        end;
      end;
    end;
  end;

LRunScript:;
  return;
end;

function string 255 EC2RegionFromWebString(string webstring)
begin
  switch (webstring) begin
    case "us-east":    EC2RegionFromWebString = "us-east-1";
    case "us-west-2":  EC2RegionFromWebString = "us-west-2";
    case "us-west":    EC2RegionFromWebString = "us-west-1";
    case "eu-ireland": EC2RegionFromWebString = "eu-west-1";
    case "apac-sin":   EC2RegionFromWebString = "ap-southeast-1";
    case "apac-tokyo": EC2RegionFromWebString = "ap-northeast-1";
    case "apac-syd":   EC2RegionFromWebString = "ap-southeast-2";
    case "sa-east-1":  EC2RegionFromWebString = "sa-east-1";
    otherwise          EC2RegionFromWebString = "ERROR unknown region: " & webstring;
  end;
end;

function string 255 WebStringFromEC2Region(string ec2region)
begin
  switch (ec2region) begin
    case "us-east-1":      WebStringFromEC2Region = "us-east";
    case "us-west-2":      WebStringFromEC2Region = "us-west-2";
    case "us-west-1":      WebStringFromEC2Region = "us-west";
    case "eu-west-1":      WebStringFromEC2Region = "eu-ireland";
    case "ap-southeast-1": WebStringFromEC2Region = "apac-sin";
    case "ap-northeast-1": WebStringFromEC2Region = "apac-tokyo";
    case "ap-southeast-2": WebStringFromEC2Region = "apac-syd";
    case "sa-east-1":      WebStringFromEC2Region = "sa-east-1";
    otherwise              WebStringFromEC2Region = "ERROR unknown ec2 region: " & ec2region;
  end;
end;

global
function Boolean GetKeyForHostingConfiguration(record HostingConfigurationVc HCr,var record Attach2Vc AT2r)
begin
  Integer i;
  record RLinkVc RLr;
  Boolean res;

  while (ReadRecordLink(HCr,i,AT2r,RLr)) begin
    switch (HCr.HostingType) begin
      case kHostingTypeSoftLayer:
        if (AT2r.FileName=="softlayer-ssh-key.pem") then begin
          goto LGetKeyForHostingConfiguration_FoundKey;
        end;
      case kHostingTypeAmazon:
        if (AT2r.FileName=="amazon-ec2-key.pem") then begin
          goto LGetKeyForHostingConfiguration_FoundKey;
        end;
    end;
    i = i + 1;
  end;
  goto LGetKeyForHostingConfiguration;

LGetKeyForHostingConfiguration_FoundKey:;
  res = true;

LGetKeyForHostingConfiguration:;
  GetKeyForHostingConfiguration = res;
  return;
end;

global
function Boolean GetKeyForHostingConfigurationToArea(record HostingConfigurationVc HCr,string keyfile,var area a_ec2_key)
begin
  Boolean res;
  record Attach2Vc AT2r;
  LongInt blocklen;

  if (GetKeyForHostingConfiguration(HCr,AT2r)==true) then begin
    blocklen = AttachFileSize(AT2r);
    SetAreaZeroSize(a_ec2_key);
    LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
    res = true;
  end;

  GetKeyForHostingConfigurationToArea = res;
  return;
end;

global
procedure AddCreateLinuxUserToScript(string username,var area a_script)
begin
  //TODO: look up in db
  string 255 key;
  
  switch (username) begin
  case "ludvig":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAKnvK3Idsjd+iwZPdFMO+PwJIxtxZc9hTftpX76OA8mwXWje0rQCXdsKSO1/Nm75q+ndm";
    key = key & "+lzvKCpaHz26ks3I8o8pjqThJKNohVIo5k9bddlj7ScpU47DNu";
    key = key & "+MGTYIjTmyr6Gf70m0XisfdmGRsehS3vq59EsCxNaCt63ZUFtT3vlAAAAFQCozoD3+6E6icz3+wFYSGwEO3PVGQAAAIEAqAVJXq8CsGCHGuhi60wnlHV";
    key = key & "3g6X6KqvQ0neRORXiWLztfzqLtlgDi9ix2HFvUKqBlf36oFyFQcaiUp1sm9HuK0w7kAyJFXroA4J190Cm0mfCgbrcks9JsXztKZFZtG07CBXyPPqpA9a";
    key = key & "X9j34loh/iLIXdpiDZd/";
    key = key & "CYfSg1gwxNVwAAACAVY6N0pwrztUNyOcz0tVsdsDwebFLD4Kvk0SyHPxUm5dkrm08iPRfjqcOnvpQunDeIJwYlaZLK/";
    key = key & "F0D7fH1DGcij4vnLJMIJo0YNqIMLNQ66VaG3Ic/mqdMH5UXbNVSBApgA8iNufnJGyK8kR7njlJjkXWfOhQUhDvb5aXRZewyao= ";
    key = key & "Ludvig@ludvig-a-norins-computer.local";
  case "bror":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAMtpAHHN6nuQNrADy7rOmWqV7ci13KIhleq5LPkcbRTIPZxeii22hYyGHSM1nTzKxjW9KSTASgA4JtU";
    key = key & "+j8tF2fAczjDI/9rTnDdgompKLD7Tsw9x7DxJ/6MZHeJblZ7pe9W6pc6XISaHJJDoHFZTSieNli3V8LEGd90EfhWCsS+1AAAAFQDfERyL";
    key = key & "+cETs0PKwzjEznqf/ID26QAAAIEAjhBA5V+ZlL8nZidCe/dr4P9GZje2SPEztuwu1OPMn8ks827fFFKDW49QDnQHxuu";
    key = key & "+ncyYzqIldBz5RwvJCIlZrBF4qwBokDSR+a4zxqXcDM/1zOl0EpJWBjn4DWOfO6HDlnVvVQq8u5gXOqHgILHPCV7N6akval/";
    key = key & "ebwT8jimZwyEAAACAVULJwW6O3VTQCtJSD6H/97LTOyt6NobQXD4U6tya79n9iN4Q64hwZm29DsGc0UZkzwI";
    key = key & "+QhWpyGafGp4AAA3F8aSQKYNAKgYgCrM8g4zMhqYvThJxNUE66J5qXV2xqiiNHyHR//B7ur0xhRNnwjKBNAAgPZCRBTXa0ZO7fKDKq8Y= ";
    key = key & "puppe@Henris-MacBook-Pro-2.local";
  case "elar":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAL/jDVuSYsSpX7T1bGmoFOL+Itbw0quI01fNsEuqkC1Le0LyC";
    key = key & "+5+4H7IQObMmjwbuKVW8PC5kG4fR9IBetMKF0CizJnKBMpwmkUX13cvc14joy/f07wJgJhUw3BGWAzo+1eISXPZmoeZy6rIb";
    key = key & "+QGWl8JCV5iNCksdcNbjTUE";
    key = key & "+WZxAAAAFQDfmJj2kla8djHbVqYy2uoB7Y1JGwAAAIBW7RFGgKrCdjOf4oi0s4kFVuEtfCsT9AP1sDEX9VqXqDe/";
    key = key & "Na3M7L6O5DC6gBhEyV98T/H4/";
    key = key & "ldYreVoJQJePw9OnROv7qh8Qa0dXjCDSDvxp5cxBriJaznB8V2HWxcHwIfgzxqsl28mO9fY2eza4Z63pJ6EJbzCxN2MWHt";
    key = key & "+TuSXngAAAIEAowjMOXGs4fDu4Ys0sPj8ywzW1hVxb+hBNkWjRZR/AiQ7qZCV9K+fo8M/Krw1NGXExKfy3Yn/";
    key = key & "+HEadCPDBIaHDIUPTmjXfrg/mPKOdgMEzYW9X9JRIz97cbiyltK1B2yF7XMTEgNYpon47Y/Bju829QacPF3KTvm4/E7oYJDdBMA= ";
    key = key & "elar@elar-air.lan";
  case "erik":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAJF2pKt7oVu/7A9CZbpzWNvHay88eb2AwsEV4KD94Ql2nWaPhUHD2zvdM0ytnAdxgS/";
    key = key & "Da3+K4pkM2Ym7usAKXJFi8TrcOHUPd1LaqXBHRMD+v7DFr/";
    key = key & "30k16GtAOdPPuNBwCaKq79Q0j2d8tg7wFlMcIH4ItlnHKJ1xwajZIEzwqvAAAAFQDBch3DAmXB0xva9ht";
    key = key & "+hAgxAG1gFwAAAIBwkqqYU9wes5q5Id7Pn8Cq3nZ21aZ4E92CcbU8Jq666BEtSSPCAUHFRoyb0yCe8GmRnEv/niSo";
    key = key & "+PDQKd2wLkT0M4BBIA5C18hQ8gPMcxFWwk531oYA34UQ/n9h3sNAsFFEnFbC8rPG4viF/LANIrWYOvxUi7F8wIJOFSRoaNvgvwAAAIBmx";
    key = key & "+6Zlh6moBsE5BE46TtUyqGg92q9eTiZaqsCixSm555FwzH8JAfWmVuKAKykq11HhqeKZ7jsuPCExjLn1mXdEn14yIgwyBbil7Um5Bn0ELF075Lv8AC8p";
    key = key & "9WhfPaECYv8C7UmwR/0fbaAK+WnTfXb8/ySx57P3dtHAmqGZTCUpQ== erik@Erik-Elmgrens-Computer.local";
  case "jonas":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAKJLukJ6DXiCrrRBnQKHKk2QNqO7zsyuSJDsuJVcV68KABz+KU2wRJbBlQqA5ktDVw5zaODoS+qdHgp3h8U";
    key = key & "+hHK1SPcB2Yv7r4cvWgjmOiVNqtxrRi4oSINXwVo";
    key = key & "+iJjTPnFcqm0FWA24/52GiTnC4bQhfn7VNE6llrEavqTF6UYDAAAAFQC0l6bMXEdmesYozEkyP+MhYLby9QAAAIEAktDQjXFoyOjlzqq86/";
    key = key & "jwn6XzIOdvpx6u7lSvh1er9cYfMdfa9Krl7TEHUbIZJpbJfRTRgROTLLWIbsYJ/";
    key = key & "Da2XG2j27fPeHUF4xS0UpGNbfR3HqlKatiAGCNvqnkklTF7/MlwxMJa+WjS03U7zp8UKghHeGElw";
    key = key & "+iOGSupccwBRsIAAACAKhsC24rVIUVybfFZST6h5XcVB4euK1DUlx5GiZRrmn6GlePxS/yzj0nA+m5cDc+TSn0j/71tQ4vZgHZEt";
    key = key & "+capaT9Y92vn3q4CXn0IufQ/kM5R5F6qPkCW9K7Hn8PI6wrkMjjQbCyXi6wA6DKYRQOOasjPAn8wasjlaR+0xYQxfA=";
  case "jarek":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBALbwmY7a4W6+N+r/zsq83t2Zf31dwwM0DniTEr";
    key = key & "+CLd8A9romG1BCOkRzZ9IVqpY4HY9NLW36PqmrQQv2+ESG0gDVw3h1C4nij/";
    key = key & "af9SgEZnunYuEGWaRYNhTtAjbjFnsSD5H4SFHKemDeQPj4+7Sy7JbtVHo/LARU9pdX/110dND9AAAAFQC/";
    key = key & "vmoW2ZA4jFZiqJW87PSQq4h0fwAAAIAO6Bj0GfpSJWxjE15zgchNykm0505/IjxM/X9SYMrsvqKKow8+ZZb5HBDJOYrG";
    key = key & "+IQPYUi1ORU3rwU83O7zIiPN/imHWvKbqsSs77NssVk8c5nXupWqC6+QkXmKNxz42wCDswbKWMKycxFM07DPz/";
    key = key & "j5gA27zlaW4gCC51ypZbZ5WwAAAIEAjzXEfKRApd4jJ7AC7eIJljaTl58KECzBEVSQC3VUa6VPr";
    key = key & "+641XZLShBlNIVa7AvagHPtOVaTwJHt6v7+3oEnvkewDTClMFMF6gLZa/ygnWFBMEH1gv3pRJRK7oiIJ+c1ARLud/xwj7AYCxOeMmy/";
    key = key & "FVkaTy12awamVY/yRjX3B6M= jarek@jarek-jamroszczaks-computer-3.local";
  case "kristaps":
    key = "ssh-dss AAAAB3NzaC1kc3MAAACBAL4ebCRraskV8u6v3q1wWDYKNi3alKEEKNnc5IwHvo0z9j1OpmEe8Jn3YpB";
    key = key & "+H7dYFQTQKuqEhszj/vNmxo2PBKIhvJti142KXjg/iXo5OmsaNeVUxGKHJfb5/+IDL+Wl1hWAcMffLCqB1pNCa";
    key = key & "AF8Z+1Lwdvw1NUFwkhbhIkSfJFBAAAAFQDVXuJtplaiN9Tk7PeL28IahZPs+wAAAIB9Kwa4qvZeHCQmOKhAKdD";
    key = key & "YYtMIm3T5xdGKv+qoezG8lEhUZ/gfkVucZ/XjmvB0gNiV4gaZ3pkMwfwDyYxTqFirZ86YmRLQAg6ZbA0gMOOZ0";
    key = key & "CV9b9M7T1WNHhGeDQo69rf5N9nbnIJlsTPhna408mmMnjiHxp4YU/8siJ7v8Q5d1wAAAIEAt2Nh7LnzqVeymiX";
    key = key & "tIXsmzim4I5d/59RZLOqOyPlSy/2J0mJCMMvK9tB37J+KDGmnnfg115KgcqJj8JDTq8VUjR6Av6hM2tjnlgiwM";
    key = key & "DG1YRBbUPxudM49X0EJ+w5HbrRcDDOD2IXpadQm71/V0wdrcFWePoWk33CVqUbIOEfJhg0= kristapszogots";
    key = key & "@Kristapss-MacBook-Pro.local";
  end;

  AddLineToArea("sudo su -",a_script);
  AddLineToArea("/usr/sbin/useradd -G admin -m " & username & " -p '*'",a_script);
  AddLineToArea("mkdir ~" & username & "/.ssh",a_script);
  AddLineToArea("touch ~" & username & "/.ssh/authorized_keys",a_script);
  AddLineToArea("chown " & username & " ~" & username & "/.ssh",a_script);
  AddLineToArea("chown " & username & " ~" & username & "/.ssh/authorized_keys",a_script);
  AddLineToArea("chmod 700 ~" & username & "/.ssh",a_script);
  AddLineToArea("chmod 600 ~" & username & "/.ssh/authorized_keys",a_script);
  AddLineToArea("sed -i\"\" \"s>" & key & ">>\" ~" & username & "/.ssh/authorized_keys",a_script);
  AddLineToArea("echo \"" & key & "\" >>~" & username & "/.ssh/authorized_keys",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("exit",a_script);
end;

global
updating procedure SetupAmazonEC2Node(record CloudNodeVc CNr)
begin
  Integer res;
  string 255 command,tstr;
  LongInt l,lcnt;
  record HostingConfigurationVc HCr;
  record Attach2Vc AT2r;
  area a_ec2_key;
  LongInt blocklen;
  string 255 keyfile;
  area a_script,a_script_data;
  record InternetEnablerBlock IEb;
  record CloudSettingsBlock CSb;

  BlockLoad(IEb);
  BlockLoad(CSb);
  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"SetupAmazonEC2Node() Hosting configuration with SerNr=" & HCr.SerNr & ", " & CNr.HostingConfig & " (" & CNr.HostingConfigComment & ") not found (did somebody delete it?)");
    SetCloudControllerStatus(kJobStatusError,"Can't create node " & CNr.Code & ", hosting configuration with SerNr=" & HCr.SerNr & ", " & CNr.HostingConfig & " (" & CNr.HostingConfigComment & ") not found (did somebody delete it?)");
    goto LSetupAmazonEC2Node;
  end;

  if (GetKeyForHostingConfiguration(HCr,AT2r)==false) then begin
    MessageBox(0,"SetupAmazonEC2Node() Hosting configuration with SerNr=" & HCr.SerNr & ", " & CNr.HostingConfig & " (" & CNr.HostingConfigComment & ") have no key uploaded (did somebody delete it?)");
    SetCloudControllerStatus(kJobStatusError,"Can't create node " & CNr.Code & ", hosting configuration with SerNr=" & HCr.SerNr & ", " & CNr.HostingConfig & " (" & CNr.HostingConfigComment & ") have no key uploaded (did somebody delete it?)");
    goto LSetupAmazonEC2Node;
  end;

  blocklen = AttachFileSize(AT2r);
  SetAreaZeroSize(a_ec2_key);
  LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
  keyfile = "/tmp/CCSetupEC2Node-k.dat";
  WriteAreaToFile(a_ec2_key,keyfile,0);

  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddLineToArea("chmod 600 " & keyfile,a_script);
  AddLineToArea("while ! ssh -i \"" & keyfile & "\" -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no -T -n -q " & CNr.AdminUser & "@" & CNr.HostName & " true &>/dev/null",a_script);
  AddLineToArea("do",a_script);
  AddLineToArea("  sleep 1",a_script);
  AddLineToArea("done",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " 'sudo sed -i\"\" \"s/^Defaults.*requiretty/#Defaults requiretty/\" /etc/sudoers'",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddLineToArea("sudo su",a_script);
  AddLineToArea("yum --assumeyes update",a_script);
  AddLineToArea("yum --assumeyes install elfutils-libs.i686",a_script);
  AddLineToArea("yum --assumeyes install htop",a_script);
  AddLineToArea("yum --assumeyes install jq",a_script);
  AddLineToArea("yum --assumeyes install lsof",a_script);
  AddLineToArea("yum --assumeyes install glibc.i686",a_script);
  AddLineToArea("echo \"%admin  ALL=(ALL)       NOPASSWD: ALL\" >>/etc/sudoers",a_script);
  AddLineToArea("echo \"search hansaworld.com\" >>/etc/resolv.conf",a_script);
  AddLineToArea("echo \"search hansaworld.net\" >>/etc/resolv.conf",a_script);
  AddLineToArea("/usr/sbin/groupadd admin",a_script);
  AddLineToArea("ln -sf /usr/share/zoneinfo/CET /etc/localtime",a_script);
  AddLineToArea("mkdir /Servers",a_script);
  AddLineToArea("sed -i\"\" \"s>^HOSTNAME=.*>HOSTNAME=" & LowerCase(CNr.Code) & ">\" /etc/sysconfig/network",a_script);
  AddLineToArea("hostname " & LowerCase(CNr.Code),a_script);
  AddLineToArea("echo \"export HISTCONTROL=ignoreboth\" >>/etc/bashrc",a_script);
  AddLineToArea("echo \"/dev/xvdh1 /Servers ext4 defaults,noatime 1 1\" >>/etc/fstab",a_script);
  AddLineToArea("cat <<'COREHANDLER_END' >/usr/local/bin/corehandler",a_script);
  AddLineToArea("#!/bin/bash",a_script);
  //AddLineToArea("exe=\\$(echo \\$1|tr ! /)",a_script);
  //AddLineToArea("dir=\\$(dirname \\${exe})",a_script);
  AddLineToArea("dir=\\$(readlink -f /proc/\\$2/cwd)",a_script);
  AddLineToArea("dd of=\\${dir}/core.\\$2",a_script);
  AddLineToArea("COREHANDLER_END",a_script);
  AddLineToArea("chmod a+x /usr/local/bin/corehandler",a_script);
  AddLineToArea("echo \"fs.suid_dumpable = 2\" >>/etc/sysctl.conf",a_script);
  AddLineToArea("echo \"kernel.core_pattern = |/usr/local/bin/corehandler %E %p\" >>/etc/sysctl.conf",a_script);
  AddLineToArea("parted -s /dev/xvdh mklabel gpt",a_script);
  AddLineToArea("parted -s /dev/xvdh mkpart primary 0% 100%",a_script);
  AddLineToArea("mkfs -t ext4 /dev/xvdh1",a_script);
  AddLineToArea("mount /Servers",a_script);
  AddLineToArea("chkconfig sendmail off",a_script);
  AddLineToArea("/etc/init.d/sendmail stop",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("ludvig",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("erik",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("jonas",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("jarek",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("elar",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("bror",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<COMMANDS-END",a_script);
  AddCreateLinuxUserToScript("kristaps",a_script);
  AddLineToArea("COMMANDS-END",a_script);

  AddLineToArea("ssh -ttt -i \"" & keyfile & "\" -ttt -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no " & CNr.AdminUser & "@" & CNr.HostName & " <<'COMMANDS-END'",a_script);
  AddLineToArea("sudo su",a_script);
  AddLineToArea("fallocate -l 6G /swapfile1",a_script);
//  AddLineToArea("dd if=/dev/zero of=/swapfile1 bs=1024 count=6291456",a_script); // 6GB
  AddLineToArea("mkswap /swapfile1",a_script);
  AddLineToArea("chown root:root /swapfile1",a_script);
  AddLineToArea("chmod 0600 /swapfile1",a_script);
  AddLineToArea("swapon /swapfile1",a_script);
  AddLineToArea("echo \"/swapfile1 swap swap defaults 0 0\" >>/etc/fstab",a_script);
  AddLineToArea("if ( [ \"$(uname -m)\" == \"x86_64\" ] ) then",a_script);
  AddLineToArea("  exen=Enterprise64",a_script);
  AddLineToArea("  exen2=hansa-debug-optimized-server64",a_script);
  AddLineToArea("else",a_script);
  AddLineToArea("  exen=Enterprise",a_script);
  AddLineToArea("  exen2=hansa-debug-optimized-server",a_script);
  AddLineToArea("fi",a_script);
  AddLineToArea("cuno=" & IEb.CustomerCode,a_script);
  AddLineToArea("mkdir -p /Servers/CloudNodeInstall",a_script);
  AddLineToArea("curl -sL http://downloads.hansaworld.com/downloads/cloud_packages/cloudnode-bootstrapper.tgz |tar zxf - --strip-components=1 -C /Servers/CloudNodeInstall",a_script);
  AddLineToArea("cd /Servers/CloudNodeInstall",a_script);
  AddLineToArea("mv ${exen} hansa-cloudnodesetup &>/dev/null",a_script);
  AddLineToArea("rm -f Enterprise* &>/dev/null",a_script);
  AddLineToArea("echo $'\\x0d'$'\\n'HostingPartnerBlock$'\\t'$'\\x0d'$'\\n'" & CSb.HostingPartner & "$'\\t'$'\\x0d'$'\\n' >>DBDEF.TXT",a_script);
  AddLineToArea("./hansa-cloudnodesetup --setup-cloudnode=${cuno}" & CSb.RegInCountry & " --ignore-linkcheck &>/dev/null",a_script);
  AddLineToArea("sleep 1",a_script);
  AddLineToArea("while [ -f cloudnode/hansa.pid ]",a_script);
  AddLineToArea("do",a_script);
  AddLineToArea("  sleep 1",a_script);
  AddLineToArea("done",a_script);
  AddLineToArea("kill -9 $(cat hansa.pid)  &>/dev/null",a_script);
  AddLineToArea("rm -rf Attach companylogo.bmp DEFAULT.TXT EnLiveSyncPOS hal.hob Import tmp Backup",a_script);
  AddLineToArea("rm -rf companylogo.pdf Demo EnPC hansa-cloudnodesetup hansa.pid Readme Setup updateclients",a_script);
  AddLineToArea("rm -rf DBDEF.TXT Downloads GBR HANSA.HDB hob webclient &>/dev/null",a_script);
  AddLineToArea("mv -f cloudnode/* . &>/dev/null",a_script);
  AddLineToArea("rm -rf cloudnode &>/dev/null",a_script);
  AddLineToArea("cd /Servers",a_script);
  AddLineToArea("cndir=" & LowerCase(CNr.Code),a_script);
  AddLineToArea("cndir=HTS_CloudNode_${cndir^}",a_script);
  AddLineToArea("mv -f /Servers/CloudNodeInstall /Servers/${cndir}",a_script);
  AddLineToArea("cd /Servers/${cndir}",a_script);
  AddLineToArea("cat >/etc/init.d/hansa-cloudnode <<COMMANDS-INNER-END",a_script);
  AddLineToArea("#!/bin/sh",a_script);
  AddLineToArea("# chkconfig: 2345 95 05",a_script);
  AddLineToArea("cd /Servers/${cndir}",a_script);
  AddLineToArea("case \"\\$1\" in",a_script);
  AddLineToArea("  start )",a_script);
  AddLineToArea("    ./run-cloudnode.sh &>/dev/null",a_script);
  AddLineToArea("    ;;",a_script);
  AddLineToArea("  stop )",a_script);
  AddLineToArea("    ./stop-cloudnode.sh &>/dev/null",a_script);
  AddLineToArea("    ;;",a_script);
  AddLineToArea("esac",a_script);
  AddLineToArea("exit 0",a_script);
  AddLineToArea("COMMANDS-INNER-END",a_script);
  AddLineToArea("chmod a+x /etc/init.d/hansa-cloudnode",a_script);
  AddLineToArea("chkconfig --level 2345 hansa-cloudnode on",a_script);
  AddLineToArea("reboot",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("COMMANDS-END",a_script);
  AddLineToArea("while ! ssh -i \"" & keyfile & "\" -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no -T -n -q " & CNr.AdminUser & "@" & CNr.HostName & " true &>/dev/null",a_script);
  AddLineToArea("do",a_script);
  AddLineToArea("  sleep 1",a_script);
  AddLineToArea("done",a_script);

  res = RunScriptInBackground("/tmp/CCSetupEC2Node",a_script,a_script_data);
  if (res==2) then begin
    SetCloudControllerStatus(kJobStatusError,"Can't setup node " & CNr.Code & ", operation already in progress");
    goto LSetupAmazonEC2Node;
  end;
  SetCloudControllerStatus(kJobStatusRunning,"Cloud Node " & CNr.Code & " is being configured");

LSetupAmazonEC2Node:;
end;

function Integer ExternalProcessState(string lock)
begin
  LongInt lpid;
  Integer res;
  string 255 lockfile,donefile;

  lockfile = "/tmp/" & lock;
  donefile = lockfile & "Completed";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      res = kExternalProcessStateRunning;
    end else begin
      if (lpid>=1) then begin
        if (FileExists(donefile)) then begin
          res = kExternalProcessStateFinished;
        end else begin
          res = kExternalProcessStateStopped;
        end;
      end else begin
        res = kExternalProcessStateStarting;
      end;
    end;
  end else begin
    res = kExternalProcessStateNotStarted;
  end;

  ExternalProcessState = res;
  return;
end;
                
global
updating procedure CreateAmazonEC2NodeWithHostingConfiguration(record HostingConfigurationVc HCr,record Attach2Vc AT2r,record RcVc RepSpec,Integer hptype)
begin
  Integer res;
  string 255 instance_type;
  string 255 node_name;
  string 255 disk_size;
  string 255 ami;
  string 255 aki;
  string 255 key_params;
  LongInt lpid;
  Boolean completedf;
  record CloudNodeVc CNr;
  Boolean use_pvm;
  string 255 root_dev,dev_type;
  area a_script,a_script_data;

  if (ExternalProcessState("CCCreateEC2Node")!=kExternalProcessStateNotStarted) then begin
    goto LCreateAmazonEC2NodeWithHostingConfiguration;
  end;

  instance_type = RepSpec.f2;
  node_name = LowerCase(RepSpec.f1);
  disk_size = RepSpec.long1;

  switch (UpperCase(left(instance_type,2))) begin
    case "T1": use_pvm = true;
    case "C1": use_pvm = true;
    case "M1": use_pvm = true;
    case "M2": use_pvm = true;
  end;

  if (use_pvm==true) then begin
    root_dev = "/dev/sda1";
    // PV EBS-Backed 64-bit, see table at: http://aws.amazon.com/amazon-linux-ami/
    // PV-GRUB aki:s, see tables at: http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html
    aki = " --kernel ";
    switch (HCr.AmazonRegion) begin //
      case "us-east-1": ami = "ami-3c3b632b"; aki = aki & "aki-919dcaf8";       // US East (N. Virginia)
      case "us-east-2":                                                         // US East (Ohio)
      case "us-west-2": ami = "ami-cec066ae"; aki = aki & "aki-fc8f11cc";       // US West (Oregon)
      case "us-west-1": ami = "ami-ceeda6ae"; aki = aki & "aki-880531cd";       // US West (N. California)
      case "eu-west-1": ami = "ami-ac9ad1df"; aki = aki & "aki-52a34525";       // EU (Ireland)
      case "eu-central-1": ami = "ami-8a6098e5"; aki = aki & "aki-184c7a05";    // EU (Frankfurt)
      case "ap-southeast-1": ami = "ami-7755f414"; aki = aki & "aki-503e7402";  // Asia Pacific (Singapore)
      case "ap-northeast-2":                                                    // Asia Pacific (Seoul)
      case "ap-northeast-1": ami = "ami-3910b358"; aki = aki & "aki-176bf516";  // Asia Pacific (Tokyo)
      case "ap-southeast-2": ami = "ami-98714dfb"; aki = aki & "aki-c362fff9";  // Asia Pacific (Sydney)
      case "ap-south-1":                                                        // Asia Pacific (Mumbai)
      case "sa-east-1": ami = "ami-5bbd2137"; aki = aki & "aki-5553f448";       // South America (São Paulo)
      case "cn-north-1": ami = "ami-0614c06b"; aki = aki & "aki-5553f448";      // China (Beijing)
    end;
  end else begin
    root_dev = "/dev/xvda";
    // HVM EBS-Backed SSD 64-bit, see table at: http://aws.amazon.com/amazon-linux-ami/
    // No AKI used for these AMIs
    switch (HCr.AmazonRegion) begin //
      case "us-east-1": ami = "ami-b73b63a0";        // US East (N. Virginia)
      case "us-east-2": ami = "ami-58277d3d";        // US East (Ohio)
      case "us-west-2": ami = "ami-5ec1673e";        // US West (Oregon)
      case "us-west-1": ami = "ami-23e8a343";        // US West (N. California)
      case "eu-west-1": ami = "ami-9398d3e0";        // EU (Ireland)
      case "eu-central-1": ami = "ami-f9619996";     // EU (Frankfurt)
      case "ap-southeast-1": ami = "ami-b953f2da";   // Asia Pacific (Singapore)
      case "ap-northeast-2": ami = "ami-983ce8f6";   // Asia Pacific (Seoul)
      case "ap-northeast-1": ami = "ami-0c11b26d";   // Asia Pacific (Tokyo)
      case "ap-southeast-2": ami = "ami-db704cb8";   // Asia Pacific (Sydney)
      case "ap-south-1": ami = "ami-34b4c05b";       // Asia Pacific (Mumbai)
      case "sa-east-1": ami = "ami-97831ffb";        // South America (São Paulo)
      case "cn-north-1": ami = "ami-7c15c111";       // China (Beijing)
    end;
  end;

  CNr.Code = UpperCase(node_name);
  CNr.HostingConfig = HCr.SerNr;
  CNr.HostingConfigComment = HCr.Comment;
  CNr.CurrentState = kCloudNodeStateCreating;
  CNr.AdminUser = "ec2-user";
  CNr.HostPoolType = hptype;
  RecordStore(CNr,true);
  UpdateClientBrowses("CloudNodeVc");

  if (RepSpec.flags[0]==1) then begin
    dev_type = "gp2";
  end else begin
    dev_type = "standard";
  end;

  key_params = " -O " & HCr.AmazonAccessKeyID & " -W " & HCr.AmazonSecretAccessKey & " --region " & HCr.AmazonRegion;

  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddLineToArea("(",a_script);
  AddLineToArea("echo \"" & CurrentDate & " " & CurrentTime & " " & CurrentUser & " Launching host " & CNr.Code & " in Amazon zone " & HCr.AmazonZone & "\"",a_script);
  AddLineToArea("ec2-create-group " & node_name & key_params & " --description " & node_name,a_script);
  AddLineToArea("ec2-authorize " & node_name & key_params & " -p 22 -P tcp",a_script);
  AddLineToArea("ec2-authorize " & node_name & key_params & " -p 499 -P tcp",a_script);
  AddLineToArea("ec2-authorize " & node_name & key_params & " -p 1081 -P tcp",a_script);
  AddLineToArea("ec2-authorize " & node_name & key_params & " -p 1301 -P tcp",a_script);
  AddLineToArea("instance=$(ec2-run-instances " & ami & aki & " --instance-count 1-1 --instance-type " & instance_type & " --availability-zone " & HCr.AmazonZone & key_params & " --key " & HCr.AmazonKeyPairID & " --block-device-mapping " & root_dev & "=:23:true --block-device-mapping /dev/sdh=:" & disk_size & ":false:" & dev_type & " --group " & node_name & " |grep ^INSTANCE. |cut -f 2)",a_script);
  AddLineToArea("if ( [ \"${instance}\" == \"\" ] ) then ",a_script);
  AddLineToArea("  ec2-delete-group " & key_params & " " & node_name,a_script);
  AddLineToArea("  exit",a_script);
  AddLineToArea("fi",a_script);
  AddLineToArea("while true",a_script);
  AddLineToArea("do ",a_script);
  AddLineToArea("  instance_state=\"$(ec2-describe-instances " & key_params & " ${instance} |grep ^INSTANCE |cut -f6)\"",a_script);
  AddLineToArea("  if ( [ \"${instance_state}\" == \"running\" ] ) then",a_script);
  AddLineToArea("    break",a_script);
  AddLineToArea("  fi",a_script);
  AddLineToArea("  if ( [ \"${instance_state}\" == \"terminated\" ] ) then ",a_script);
  AddLineToArea("    state_reason=\"$(ec2-describe-instances " & key_params & " ${instance} -v |grep message |cut -d'>' -f2 |cut -d'<' -f1)\"",a_script);
  AddLineToArea("    echo \"ERROR: Instance couldn't be launched, reason: ${state_reason}\" >>" & NodeLog(CNr),a_script);
  AddLineToArea("    ec2-delete-group " & key_params & " " & node_name,a_script);
  AddLineToArea("    exit",a_script);
  AddLineToArea("  fi",a_script);
  AddLineToArea(" sleep 1",a_script);
  AddLineToArea("done",a_script);
  AddLineToArea("while [ \"${address}\" == \"\" ]",a_script);
  AddLineToArea("do",a_script);
  AddLineToArea("  address=$(ec2-describe-instances " & key_params & " ${instance} |grep ^INSTANCE |cut -f17)",a_script);
  AddLineToArea("  sleep 1",a_script);
  AddLineToArea("done",a_script);
  AddLineToArea("ec2-create-tags ${instance} -t \"Name=" & node_name & "\" " & key_params,a_script);
  AddLineToArea("echo -n \"" & CNr.Code & ",${instance},${address}," & instance_type & "\" >/tmp/CCCreateEC2NodeCompleted",a_script);
  AddLineToArea(" ) &>>" & NodeLog(CNr),a_script);

  RunScriptInBackground("/tmp/CCCreateEC2Node",a_script,a_script_data);
  if (res==2) then begin
    SetCloudControllerStatus(kJobStatusError,"Can't create node " & CNr.Code & ", operation already in progress");
    goto LCreateAmazonEC2NodeWithHostingConfiguration;
  end;
  SetCloudControllerStatus(0,"Creating node " & CNr.Code & " in hosting configuration " & HCr.SerNr & " (" & HCr.Comment & ")");

LCreateAmazonEC2NodeWithHostingConfiguration:;
end;

updating procedure CreateEC2Host(record HostingConfigurationVc HCr,string name,string instance_type,LongInt disk_size,Integer ssdf)
begin
  record Attach2Vc AT2r;
  record RcVc RepSpec;

  RepSpec.f2 = instance_type;
  RepSpec.f1 = name;
  RepSpec.long1 = disk_size;
  RepSpec.flags[0] = ssdf;

  GetKeyForHostingConfiguration(HCr,AT2r);
  CreateAmazonEC2NodeWithHostingConfiguration(HCr,AT2r,RepSpec,kHostPoolTypeNone);
end;

global
function Boolean GetEC2InstanceTypes(record HostingConfigurationVc HCr,var area a_types)
begin
  Boolean res;
  string 255 cmd,tstr;
  LongInt l,lcnt;

/*
  if (ReadFirstMain(HCr,1,true)==false) then begin
    AddLineToArea("Hosting configuration with SerNr=" & HCr.SerNr & " not found",a_types);
    goto LGetEC2InstanceTypes;
  end;
*/
/*
  cmd = "curl -qfsLm 30 http://aws.amazon.com/ec2/pricing/pricing-on-demand-instances.json|jq '.config.regions[]|select(.region==\"" & WebStringFromEC2Region(HCr.AmazonRegion) & "\").instanceTypes[]|select(.type|(contains(\"Current\") or contains(\"uI\"))).sizes[]|select(.valueColumns[].name==\"linux\").size\' |sed s.\\\"..g |grep -v ^g"; // we filter out GPU instances
*/
  // New version, filters out GPU instances, show previous-gen instances too, still not good though
  cmd = "curl -qfsLm 30 https://raw.githubusercontent.com/garnaat/missingcloud/master/aws.json |jq '.services[\"Elastic Compute Cloud\"].instance_types|keys|to_entries[].value'|sed 's/\\\"//g'|grep -v ^g|grep -v '^g\\\|^t2\\\.\\\|^m[12]\\\.\\\|^c1\\\.'";
  res = RunMultilineOutCommand(cmd,a_types);
  if (res==false) then begin
    AddLineToArea("Failed retrieving the list of instance types.",a_types);
    AddLineToArea("Make sure that the Cloud Controller has 'jq' and 'curl' installed.",a_types);
    for (l = 0; l<lcnt; l = l + 1) begin
      tstr = Trim(GetLineFromArea(a_types,l));
      AddLineToArea(tstr,a_types);
    end;
    goto LGetEC2InstanceTypes;
  end;

LGetEC2InstanceTypes:;
  GetEC2InstanceTypes = res;
end;
global
procedure ConfirmProcessState(Integer state,string lock)
begin
  switch (state) begin
    case kExternalProcessStateFinished:
      Delete_File("/tmp/" & lock);
      Delete_File("/tmp/" & lock & "Data");
      Delete_File("/tmp/" & lock & "Completed");
    case kExternalProcessStateStopped:
      Delete_File("/tmp/" & lock);
      Delete_File("/tmp/" & lock & "Data");
      Delete_File("/tmp/" & lock & "Completed");
//    case kExternalProcessStateNotStarted:
//      Delete_File("/tmp/" & lock & "Data");
//      Delete_File("/tmp/" & lock & "Completed");
  end;
end;

global
updating procedure ASPCheckStatusTaskCC(string arg)
begin
  string 255 lockfile,donefile,tstr,t2,t3,t4,t5,datafile,url;
  string 255 step1donefile,step2donefile,step3donefile,step4donefile,step5donefile;
  LongInt lpid,pos,l;
  Integer i1;
  LongInt stat;
  record CloudNodeVc CNr,OldCNr,CN2r;
  record HostingConfigurationVc HCr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc OldRCSr;
  record ASPArchiveVc AAr,AA2r;
  area a_data;
  Boolean foundf;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPCheckStatusTaskCC; end;

  /* Create Node in Amazon */
  lockfile = "/tmp/CCCreateEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(datafile);
        if (FileExists(donefile)) then begin
          tstr = ReadStringFromFile(donefile);
          Delete_File(donefile);
          if (nonblank(tstr)) then begin
            pos = -1;
            GetNextSubstring(tstr,pos,",",t2); //code
            GetNextSubstring(tstr,pos,",",t3); //instance id
            GetNextSubstring(tstr,pos,",",t4); //address
            GetNextSubstring(tstr,pos,",",t5); //instance type
            CNr.Code = t2;
            if (ReadFirstMain(CNr,1,true)) then begin
              SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & t2 & " successfully created");
              RecordCopy(OldCNr,CNr);
              CNr.AmazonInstanceId = t3;
              CNr.HostName = t4;
              CNr.AmazonInstanceType = t5;
              RecordUpdate(OldCNr,CNr,true);
              SetupAmazonEC2Node(CNr);
              LogText(0,"The Cloud Node " & t2 & " was updated");
            end else begin
              SetCloudControllerStatus(kJobStatusError,"The Cloud Node " & tstr & " was created but not found in the database (did somebody delete it?)");
              LogText(0,"Fatal Error: The Cloud Node " & tstr & " was created but not found in the database (did somebody delete it?)");
            end;
          end else begin
            SetCloudControllerStatus(kJobStatusError,"The Cloud Node " & tstr & " was not created successfully, aborting operation (manual cleanup in AWS console needed)");
            LogText(0,"The Cloud Node " & tstr & " was not created successfully, aborting operation (manual cleanup in AWS console needed)");
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Creating Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Creating Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
//        SetCloudControllerStatus(kJobStatusError,"Cloud Node creation pending...");
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Force restart node in Amazon */
  lockfile = "/tmp/CCForceRestartEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-k.dat");
        SetAreaZeroSize(a_data);
        AddFileToArea(datafile,a_data,false);
        RecordClear(CNr);
        GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
        Delete_File(datafile);
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            queued.DoCheckCloudNode(CNr);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & CNr.Code & " forcefully restarted");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Force restarting Cloud Node " & CNr.Code & " failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Force restarting Cloud Node " & CNr.Code & " failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Setup Node in Amazon */
  lockfile = "/tmp/CCSetupEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-k.dat");
        SetAreaZeroSize(a_data);
        AddFileToArea(datafile,a_data,false);
        RecordClear(CNr);
        GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
        Delete_File(datafile);
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            queued.DoCheckCloudNode(CNr);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & CNr.Code & " successfully configured");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Configuring Cloud Node " & CNr.Code & " failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Configuring Cloud Node " & CNr.Code & " failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;


  /* Start Node in Amazon */
  lockfile = "/tmp/CCStartEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-k.dat");
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            EC2RefreshIP(CNr);
            queued.DoCheckCloudNode(CNr);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & CNr.Code & " started");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Starting Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Starting Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Stop Node in Amazon */
  lockfile = "/tmp/CCStopEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-k.dat");
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStopped;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 0;
            RecordUpdate(OldCNr,CNr,true);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & CNr.Code & " stopped");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Stopping Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Stopping Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Change Node in Amazon */
  lockfile = "/tmp/CCChangeEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

 if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-k.dat");
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            EC2RefreshIP(CNr);
            queued.DoCheckCloudNode(CNr);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & CNr.Code & " modified");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Modifying Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Modifying Cloud Node failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;
  
  /* Change Node IP Address in Amazon */
  lockfile = "/tmp/CCIPChangeEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

 if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            EC2RefreshIP(CNr);
            queued.DoCheckCloudNode(CNr);
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Changing Cloud Node IP failed for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Changing Cloud Node IP failed for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Change Node Firewall Config in Amazon */
  lockfile = "/tmp/CCIPConfFWEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";

 if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            queued.GetOneNodeHostingConfig(CNr);
            RecordCopy(OldCNr,CNr);
            CNr.CurrentState = kCloudNodeStateStarting;
            CNr.ReachableFlag = 0;
            CNr.FastCheckFlag = 1;
            RecordUpdate(OldCNr,CNr,true);
            queued.DoCheckCloudNode(CNr);
          end;
          SetCloudControllerStatus(kJobStatusFinished,"Firewall on Cloud Node " & CNr.Code & " configured");
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Firewall on Cloud Node couldn't be configured for unknown reasons (manual cleanup in AWS console needed)");
          LogText(0,"Firewall on Cloud Node couldn't be configured for unknown reasons (manual cleanup in AWS console needed)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

  /* Move Node in Amazon */
  lockfile = "/tmp/CCMoveEC2Node";
  step1donefile = lockfile & "Completed";
  datafile = lockfile & "Data";
  step2donefile = lockfile & "Step2Completed";
  step3donefile = lockfile & "Step3Completed";
  step4donefile = lockfile & "Step4Completed";
  step5donefile = lockfile & "Step5Completed";

  if (FileExists(lockfile)) then begin
    if (FileExists(datafile)) then begin
      SetAreaZeroSize(a_data);
      AddFileToArea(datafile,a_data,false);
      RecordClear(CNr);
      RecordClear(HCr);
      tstr = Trim(GetLineFromArea(a_data,0));
      l = StringToLongInt(GetLineFromArea(a_data,1));
      i1 = StringToLongInt(GetLineFromArea(a_data,2));
      pos = GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
      pos = GetRecordFromArea(HCr,"HostingConfigurationVc",pos,a_data);
    end;
    if (!FileExists(step2donefile)) then begin
      lpid = ReadLongFromFile(lockfile);
      if (PidIsRunning(lpid)) then begin
        // Still working on it
      end else begin
        if (lpid>=1) then begin
          if (FileExists(step1donefile)) then begin
            // Step 1 in the process is complete
            if (ReadFirstMain(CNr,1,true)) then begin
              RecordCopy(OldCNr,CNr);
              CNr.ReachableFlag = 0;
              CNr.FastCheckFlag = 0;
              CNr.Code = CNr.Code & "_OLD";
              RecordUpdate(OldCNr,CNr,true);
              SetCloudControllerStatus(kJobStatusFinished,"Cloud Node " & OldCNr.Code & " renamed to " & CNr.Code);
              CreateEC2Host(HCr,OldCNr.Code,tstr,l,i1);
              // Step 2 in the process is complete
              CreateFile(step2donefile);
              CloseFile;
            end else begin
              SetCloudControllerStatus(kJobStatusError,"Moving Cloud Node " & CNr.Code & " failed because the node record disappeared.");
            end;
          end;
        end else begin
          // Subprocess didn't start yet
          LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
        end;
      end;
    end;
    if (FileExists(step2donefile) and !FileExists(step3donefile)) then begin
      if (!FileExists("/tmp/CCCreateEC2Node") and !FileExists("/tmp/CCSetupEC2Node")) then begin
        if (ReadFirstMain(CNr,1,true)) then begin
          if (CNr.ReachableFlag==1) then begin
            // Creation finished
            // Step 3 in the process is complete
            CreateFile(step3donefile);
            CloseFile;
            MoveNodeToNewHostStageFour(CNr,HCr);
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Moving Cloud Node " & CNr.Code & " failed because the new node couldn't be created.");
        end;
      end;
    end;
    if (FileExists(step3donefile) and !FileExists(step4donefile)) then begin
      if (!FileExists("/tmp/CCMoveDataEC2Node")) then begin
        // Step 4 in the process is complete
        CreateFile(step4donefile);
        CloseFile;
        CN2r.Code = CNr.Code & "_OLD";
        if (ReadFirstMain(CN2r,1,true)) then begin
          i1 = StopHost(CN2r,false,t2);
          if (i1>0) then begin
            SetCloudControllerStatus(kJobStatusError,"Couldn't stop " & CN2r.Code & ": " & t2);
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Moving Cloud Node " & CNr.Code & " failed because the " & CN2r.Code & " node record disappeared.");
        end;
      end;
    end;
    if (FileExists(step4donefile) and !FileExists(step5donefile)) then begin
      if (!FileExists("/tmp/CCStopEC2Node")) then begin
        CN2r.Code = CNr.Code & "_OLD";
        if (ReadFirstMain(CN2r,1,true)) then begin
          if (ReadFirstMain(CNr,1,true)) then begin
            if (blank(CNr.AmazonElasticIP) and (CNr.HostingConfig==CN2r.HostingConfig)) then begin // too hard, same region/different zone is actually OK
              if (nonblank(CN2r.AmazonElasticIP)) then begin
                RecordCopy(OldCNr,CNr);
                CNr.AmazonElasticIP = CN2r.AmazonElasticIP;
                RecordUpdate(OldCNr,CNr,true);
                RecordCopy(OldCNr,CN2r);
                CN2r.AmazonElasticIP = "";
                RecordUpdate(OldCNr,CN2r,true);
                EC2CheckElasticIP(CNr);
              end;
            end else begin
              if (CNr.HostingConfig!=CN2r.HostingConfig) then begin
                SetCloudControllerStatus(kJobStatusError,"Different hosting configurations detected, " & CNr.Code & " will not have the same IP as " & CN2r.Code & ".");
              end;
            end;
            if ((blank(CNr.AmazonElasticIP) or (CNr.AmazonElasticIP==CNr.HostName)) and (CNr.ReachableFlag==1)) then begin
              CreateFile(step5donefile);
              CloseFile;
            end;
          end else begin
            SetCloudControllerStatus(kJobStatusError,"Moving Cloud Node " & CNr.Code & " failed because the node record disappeared.");
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Moving Cloud Node " & CNr.Code & " failed because the " & CN2r.Code & " node record disappeared.");
        end;
      end;
    end;
    if (FileExists(step5donefile)) then begin
      ReadFirstMain(CNr,1,true);
      RecordCopy(OldCNr,CNr);
//      CNr.CurrentState = kCloudNodeStateStarting;
      RecordUpdate(OldCNr,CNr,true);
      SetCloudControllerStatus(kJobStatusFinished,"The Cloud Node " & CNr.Code & " was successfully moved to a new host");
      Delete_File(lockfile);
      Delete_File(datafile);
      Delete_File(step1donefile);
      Delete_File(step2donefile);
      Delete_File(step3donefile);
      Delete_File(step4donefile);
      Delete_File(step5donefile);
      Delete_File(lockfile & "-ko.dat");
      Delete_File(lockfile & "-kn.dat");
    end;
  end;

  /* Move Node Data in Amazon */
  lockfile = "/tmp/CCMoveDataEC2Node";
  donefile = lockfile & "Completed";
  datafile = lockfile & "Data";
  if (FileExists(lockfile)) then begin
    lpid = ReadLongFromFile(lockfile);
    if (PidIsRunning(lpid)) then begin
      // Still working on it
    end else begin
      if (lpid>=1) then begin
        Delete_File(lockfile);
        Delete_File(lockfile & "-ko.dat");
        Delete_File(lockfile & "-kn.dat");
        if (FileExists(donefile)) then begin
          Delete_File(donefile);
          SetAreaZeroSize(a_data);
          AddFileToArea(datafile,a_data,false);
          Delete_File(datafile);
          RecordClear(CNr);
          pos = GetRecordFromArea(CNr,"CloudNodeVc",0,a_data);
          pos = GetRecordFromArea(CN2r,"CloudNodeVc",0,a_data);
          pos = GetRecordFromArea(HCr,"HostingConfigurationVc",pos,a_data);
          if (ReadFirstMain(CNr,1,true)) then begin
            SetCloudControllerStatus(kJobStatusFinished,"Data on Cloud Node " & CN2r.Code & " moved to " & CNr.Code);
          end else begin
            SetCloudControllerStatus(kJobStatusError,"Moving data on Cloud Node " & CN2r.Code & " to " & CNr.Code & " failed because the target node record disappeared (2).");
          end;
        end else begin
          SetCloudControllerStatus(kJobStatusError,"Moving data on Cloud Node failed for unknown reasons (manual cleanup in AWS console needed) (2)");
          LogText(0,"Moving data on Cloud Node failed for unknown reasons (manual cleanup in AWS console needed) (2)");
        end;
      end else begin
        // Subprocess didn't start yet
        LogText(0,"The operation lock " & lockfile & " was created but had no PID (" & lpid & "), ignoring");
      end;
    end;
  end;

LASPCheckStatusTaskCC:;
  return;
end;

global
updating procedure StoreCloudArchiveRec(record ASPArchiveVc AAr)
begin
  record ASPArchiveVc OldAAr,AA2r;

  RecordCopy(AA2r,AAr);
  if (ReadFirstMain(AA2r,1,true)) then begin
    if (AA2r.State!=AAr.State) then begin
      RecordCopy(OldAAr,AA2r);
      RecordUpdate(OldAAr,AAr,true);
    end;
  end else begin
    AAr.CreatedDate = CurrentDate;
    AAr.CreatedTime = CurrentTime;
    RecordStore(AAr,false);
  end;
  return;
end;

global
updating procedure ResetCloudArchiveOnCN()
begin
  record ASPArchiveVc AAr;
  LongInt i,j;

  LogText(0,"Cleaning cloud archive register");
  i = 0; j = 0;
  while (LoopMain(AAr,1,true)) begin
    switch (AAr.State) begin
      case kArchiveFileStateUploadingToLongTerm:
        if (!FileExists(AAr.FilePath & "/" & AAr.FileName)) then begin
          RecordDelete(AAr);
          StepBack(AAr);
          j = j + 1;
        end else begin
          AAr.UpdatedFlag = 1;
          AAr.State = kArchiveFileStateLocal;
          StoreCloudArchiveRec(AAr);
          i = i + 1;
        end;
      case kArchiveFileStateArchivingingLocally:
        if (!FileExists(AAr.FilePath & "/" & AAr.FileName)) then begin
          if (!FileExists(AAr.FilePath & "/" & AAr.FileName & ".bz2")) then begin
            RecordDelete(AAr);
            StepBack(AAr);
            j = j + 1;
          end else begin
            AAr.UpdatedFlag = 1;
            AAr.FileName = AAr.FileName & ".bz2";
            AAr.State = kArchiveFileStateLocal;
            StoreCloudArchiveRec(AAr);
            i = i + 1;
          end;
        end else begin
          AAr.UpdatedFlag = 1;
          AAr.State = kArchiveFileStatePendingArchiving;
          StoreCloudArchiveRec(AAr);
          i = i + 1;
        end;
    end;
  end;
  if (i>0) then begin
    LogText(0,"Changed " & i & " cloud archive statuses");
  end;
  if (j>0) then begin
    LogText(0,"Deleted " & j & " cloud archive records");
  end;
  return;
end;

global
updating procedure ResetCloudArchiveOnCC()
begin
  record ASPArchiveVc AAr;
  LongInt i;

  LogText(0,"Cleaning cloud archive register");
  i = 0;
  while (LoopMain(AAr,1,true)) begin
    switch (AAr.State) begin
      case kArchiveFileStateUnknown:              RecordDelete(AAr);  StepBack(AAr);  i = i + 1;
      case kArchiveFileStateArchivingingLocally:  RecordDelete(AAr);  StepBack(AAr);  i = i + 1;
      case kArchiveFileStateUploadingToLongTerm:  RecordDelete(AAr);  StepBack(AAr);  i = i + 1;
      case kArchiveFileStateDeleted:              RecordDelete(AAr);  StepBack(AAr);  i = i + 1;
    end;
  end;
  if (i>0) then begin
    LogText(0,"Deleted " & i & " cloud archive records");
  end;
  return;
end;


global
updating function Integer ChangeHostType(record CloudNodeVc CNr,string type,var string msg)
begin
  record RemoteCloudServerVc RCSr;
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr;
  Boolean foundf;
  Integer res;
  string 255 bp;
  area a_script,a_script_data;

  RCSr.Controller = CNr.Code;
  foundf = true;
  while (LoopKey("Controller",RCSr,1,foundf)) begin
    if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
    if (foundf) then begin
      if (RCSr.Closed==0) then begin
        if (RCSr.CurrentStatus!=kStatusStopped) then begin
          res = 1;
          msg = "Stop all servers on the selected node and try again.";
          goto LChangeHostType;
        end;
      end;
    end;
  end;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LChangeHostType;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LChangeHostType;
  end;

  bp = "-O " & HCr.AmazonAccessKeyID & " -W " & HCr.AmazonSecretAccessKey & " --region " & HCr.AmazonRegion & " ";

  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddLineToArea("ec2-stop-instances " & bp & CNr.AmazonInstanceId & " >>" & NodeLog(CNr) & "  2>&1",a_script);
  AddLineToArea("while [ \"$(ec2-describe-instances " & bp & CNr.AmazonInstanceId & " |grep ^INSTANCE |cut -f6)\" != \"stopped\" ] ; do sleep 1 ; done",a_script);
  AddLineToArea("ec2-modify-instance-attribute " & bp & " --instance-type " & type & " " & CNr.AmazonInstanceId & " >>" & NodeLog(CNr) & "  2>&1",a_script);
  AddLineToArea("ec2-start-instances " & bp & CNr.AmazonInstanceId & "  >>" & NodeLog(CNr) & "  2>&1",a_script);
  AddLineToArea("while [ \"$(ec2-describe-instances " & bp & CNr.AmazonInstanceId & " |grep ^INSTANCE |cut -f6)\" != \"running\" ] ; do sleep 1 ; done",a_script);

  res = RunScriptInBackground("/tmp/CCChangeEC2Node",a_script,a_script_data);
  if (res==2) then begin
    res = 4;
    msg = "Can't change node type for " & CNr.Code & ", operation already in progress";
    goto LChangeHostType;
  end;
  SetCloudControllerStatus(kJobStatusRunning,"Cloud Node " & CNr.Code & " is being modified");
  res = 0;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);
  CNr.CurrentState = kCloudNodeStateModifying;
  RecordUpdate(OldCNr,CNr,true);

LChangeHostType:;
  ChangeHostType = res;
end;

global
updating function Integer AssignHostIP(record CloudNodeVc CNr,string address,var string msg)
begin
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr;
  Integer res;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LAssignHostIP;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LAssignHostIP;
  end;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);
  CNr.CurrentState = kCloudNodeStateModifying;
  RecordUpdate(OldCNr,CNr,true);

  SetAmazonInstanceAddress(HCr,CNr,address);
  SetCloudControllerStatus(kJobStatusRunning,"Cloud Node " & CNr.Code & " was assigned an Elastic IP address " & address);
  res = 0;

LAssignHostIP:;
  AssignHostIP = res;
end;

global
function Boolean GetEC2ElasticIPs(record HostingConfigurationVc HCr,var area a_addresses)
begin
  Boolean res;
  string 255 service,region,server,path,key1;
  Integer i;
  area a_req,a_reply;
  xml x_reply;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    AddLineToArea("Hosting configuration with SerNr=" & HCr.SerNr & " not found",a_addresses);
    goto LGetEC2ElasticIPs;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeAddresses";
  path = path & "&Filter.1.Name=instance-id";
  path = path & "&Filter.1.Value.1=";
  if (nonblank(HCr.AmazonVPCId)) then begin
    path = path & "&Filter.1.Name=domain";
    path = path & "&Filter.1.Value.1=vpc";
  end;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("GetEC2ElasticIPs()",x_reply);
    key1 = "DescribeAddressesResponse/addressesSet/item";
    while (XmlNodeExists(x_reply,key1 & "[" & i & "]")) begin
      AddLineToArea(XmlGet(x_reply,key1 & "[" & i & "]/publicIp"),a_addresses);
      i = i + 1;
    end;
  end;

LGetEC2ElasticIPs:;
  GetEC2ElasticIPs = res;
end;

global
function Boolean AmazonGetInstancePublicIP(record HostingConfigurationVc HCr,string instanceid,var string pubip)
begin
  Boolean res;
  string 255 service,region,server,path;
  Integer i;
  area a_req,a_reply;
  xml x_reply;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonGetInstancePublicIP() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonGetInstancePublicIP;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeAddresses";
  path = path & "&Filter.1.Name=instance-id";
  path = path & "&Filter.1.Value.1=" & instanceid;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonGetInstancePublicIP()",x_reply);
    pubip = XmlGet(x_reply,"DescribeAddressesResponse/addressesSet/item/publicIp");
  end;

LAmazonGetInstancePublicIP:;
  AmazonGetInstancePublicIP = res;
end;

global
function Boolean AmazonAllocateElasticIP(record HostingConfigurationVc HCr,var string pubip)
begin
  Boolean res;
  string 255 service,region,server,path;
  Integer i;
  area a_req,a_reply;
  xml x_reply;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonAllocateElasticIP() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonAllocateElasticIP;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=AllocateAddress";
  if (nonblank(HCr.AmazonVPCId)) then begin
    path = path & "&Domain=vpc";
  end;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonAllocateElasticIP()",x_reply);
    pubip = XmlGet(x_reply,"AllocateAddressResponse/item/publicIp");
  end;

LAmazonAllocateElasticIP:;
  AmazonAllocateElasticIP = res;
end;

global
function Boolean AmazonDescribeAddresses(record HostingConfigurationVc HCr,string address,var array string instancesarr)
begin
  Boolean res;
  string 255 service,region,server,path,key1;
  Integer i;
  area a_req,a_reply;
  xml x_reply;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonDescribeAddresses() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonDescribeAddresses;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeAddresses";
  path = path & "&Filter.1.Name=public-ip";
  path = path & "&Filter.1.Value.1=" & address;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,5);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonDescribeAddresses()",x_reply);
    key1 = "DescribeAddressesResponse/addressesSet/item";
    while (XmlNodeExists(x_reply,key1 & "[" & i & "]")) begin
      instancesarr[instancesarr.length] = XmlGet(x_reply,key1 & "[" & i & "]/instanceId");
      i = i + 1;
    end;
  end;

LAmazonDescribeAddresses:;
  AmazonDescribeAddresses = res;
end;

global
function Boolean AmazonFirewallGetOpenPorts(record HostingConfigurationVc HCr,string name,var array string tcparr,var array string udparr)
begin
  Boolean res;
  string 255 service,region,server,path,key1,fromport,toport;
  Integer i;
  area a_req,a_reply;
  xml x_reply;
  vector LongInt tcpranges;
  vector LongInt udpranges;
  array string 255 atags;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonFirewallGetOpenPorts() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonFirewallGetOpenPorts;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeSecurityGroups";
  path = path & "&Filter.1.Name=group-name";
  path = path & "&Filter.1.Value.1=" & LowerCase(name);
  path = path & "&Filter.2.Name=ip-permission.protocol";
  path = path & "&Filter.2.Value.2=??p";
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonFirewallGetOpenPorts()",x_reply);
    key1 = "DescribeSecurityGroupsResponse/securityGroupInfo/item/ipPermissions/item";
    while (XmlNodeExists(x_reply,key1 & "[" & i & "]")) begin
      fromport = XmlGet(x_reply,key1 & "[" & i & "]/fromPort");
      toport = XmlGet(x_reply,key1 & "[" & i & "]/toPort");
      switch (XmlGet(x_reply,key1 & "[" & i & "]/ipProtocol")) begin
        case "tcp":
          if (fromport!=toport) then begin
            tcpranges[fromport] = toport;
          end else begin
            if (tcpranges[fromport]==-1) then begin
              tcpranges[fromport] = toport;
            end;
          end;
        case "udp":
          if (fromport!=toport) then begin
            udpranges[fromport] = toport;
          end else begin
            if (udpranges[fromport]==-1) then begin
              udpranges[fromport] = toport;
            end;
          end;
      end;
      i = i + 1;
    end;
  end;

  GetVectorTags(tcpranges,atags);
  //SortArray(atags,M4Int);
  for (i = 0; i<atags.length; i = i + 1) begin
    if (tcpranges[atags[i]]==StringToLongInt(atags[i])) then begin
      tcparr[tcparr.length] = StringToLongInt(atags[i]);
    end else begin
      tcparr[tcparr.length] = atags[i] & "-" & tcpranges[atags[i]];
    end;
  end;

  ClearArray(atags);
  GetVectorTags(udpranges,atags);
  //SortArray(atags,M4Int);
  for (i = 0; i<atags.length; i = i + 1) begin
    if (udpranges[atags[i]]==StringToLongInt(atags[i])) then begin
      udparr[udparr.length] = StringToLongInt(atags[i]);
    end else begin
      udparr[udparr.length] = atags[i] & "-" & udpranges[atags[i]];
    end;
  end;

LAmazonFirewallGetOpenPorts:;
  AmazonFirewallGetOpenPorts = res;
end;

function Boolean AmazonGetSecurityGroupID(record HostingConfigurationVc HCr,string name,var string groupid)
begin
  Boolean res;
  string 255 service,region,server,path;
  Integer i;
  area a_req,a_reply;
  xml x_reply;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonGetSecurityGroupID() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonGetSecurityGroupID;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=DescribeSecurityGroups";
  path = path & "&Filter.1.Name=group-name";
  path = path & "&Filter.1.Value.1=" & LowerCase(name);
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonGetSecurityGroupID()",x_reply);
    groupid = XmlGet(x_reply,"DescribeSecurityGroupsResponse/securityGroupInfo/item[0]/groupId");
    if (blank(groupid)) then begin res = false; end;
  end;

LAmazonGetSecurityGroupID:;
  AmazonGetSecurityGroupID = res;
end;

procedure AmazonFirewallOpenPorts(record HostingConfigurationVc HCr,string name,vector string tcpvec,vector string udpvec)
begin
  Boolean res;
  string 255 service,region,server,path,groupid,tcplist,udplist;
  Integer i,j;
  area a_req,a_reply;
  xml x_reply;
  vector LongInt tcpranges;
  vector LongInt udpranges;
  array string 255 atags;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonFirewallOpenPorts() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonFirewallOpenPorts;
  end;
  if (AmazonGetSecurityGroupID(HCr,name,groupid)==false) then begin
    LogText(0,"ERROR: AmazonFirewallOpenPorts() Couldn't get security group ID for group " & LowerCase(name));
    goto LAmazonFirewallOpenPorts;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=AuthorizeSecurityGroupIngress";
  path = path & "&GroupId=" & groupid;
  j = 1;
  GetVectorTags(tcpvec,atags);
  for (i = 0; i<atags.length; i = i + 1) begin
    if (nonblank(tcplist)) then begin tcplist = tcplist & ","; end;
    if (atags[i]==tcpvec[atags[i]]) then begin
      tcplist = tcplist & atags[i];
    end else begin
      tcplist = tcplist & atags[i] & "-" & tcpvec[atags[i]];
    end;
    path = path & "&IpPermissions." & j & ".IpProtocol=tcp";
    path = path & "&IpPermissions." & j & ".FromPort=" & atags[i];
    path = path & "&IpPermissions." & j & ".ToPort=" & tcpvec[atags[i]];
    path = path & "&IpPermissions." & j & ".IpRanges.1.CidrIp=0.0.0.0/0";
    j = j + 1;
  end;
  ClearArray(atags);
  GetVectorTags(udpvec,atags);
  for (i = 0; i<atags.length; i = i + 1) begin
    if (nonblank(udplist)) then begin udplist = udplist & ","; end;
    if (atags[i]==udpvec[atags[i]]) then begin
      udplist = udplist & atags[i];
    end else begin
      udplist = udplist & atags[i] & "-" & udpvec[atags[i]];
    end;
    path = path & "&IpPermissions." & j & ".IpProtocol=udp";
    path = path & "&IpPermissions." & j & ".FromPort=" & atags[i];
    path = path & "&IpPermissions." & j & ".ToPort=" & udpvec[atags[i]];
    path = path & "&IpPermissions." & j & ".IpRanges.1.CidrIp=0.0.0.0/0";
    j = j + 1;
  end;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");

  if (nonblank(tcplist)) then begin LogText(0,"Opening TCP ports on node " & name & ": " & tcplist); end;
  if (nonblank(udplist)) then begin LogText(0,"Opening UDP ports on node " & name & ": " & udplist); end;

  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonFirewallOpenPorts()",x_reply);
    if (XmlGet(x_reply,"AuthorizeSecurityGroupIngressResponse/return")!="true") then begin
      LogText(0,"ERROR AmazonFirewallOpenPorts() failed with unknown error");
    end;
  end;

LAmazonFirewallOpenPorts:;
  return;
end;

procedure AmazonFirewallClosePorts(record HostingConfigurationVc HCr,string name,vector string tcpvec,vector string udpvec)
begin
  Boolean res;
  string 255 service,region,server,path,groupid;
  Integer i,j;
  area a_req,a_reply;
  xml x_reply;
  vector LongInt tcpranges;
  vector LongInt udpranges;
  array string 255 atags;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    LogText(0,"ERROR: AmazonFirewallClosePorts() Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    goto LAmazonFirewallClosePorts;
  end;
  if (AmazonGetSecurityGroupID(HCr,name,groupid)==false) then begin
    LogText(0,"ERROR: AmazonFirewallClosePorts() Couldn't get security group ID for group " & LowerCase(name));
    goto LAmazonFirewallClosePorts;
  end;

  service = "ec2";
  region = HCr.AmazonRegion;
  server = service & "." & region & ".amazonaws.com";

  path = "?Action=RevokeSecurityGroupIngress";
  path = path & "&GroupId=" & groupid;
  j = 1;
  GetVectorTags(tcpvec,atags);
  for (i = 0; i<atags.length; i = i + 1) begin
    path = path & "&IpPermissions." & j & ".IpProtocol=tcp";
    path = path & "&IpPermissions." & j & ".FromPort=" & atags[i];
    path = path & "&IpPermissions." & j & ".ToPort=" & tcpvec[atags[i]];
    path = path & "&IpPermissions." & j & ".IpRanges.1.CidrIp=0.0.0.0/0";
    j = j + 1;
  end;
  ClearArray(atags);
  GetVectorTags(udpvec,atags);
  for (i = 0; i<atags.length; i = i + 1) begin
    path = path & "&IpPermissions." & j & ".IpProtocol=udp";
    path = path & "&IpPermissions." & j & ".FromPort=" & atags[i];
    path = path & "&IpPermissions." & j & ".ToPort=" & udpvec[atags[i]];
    path = path & "&IpPermissions." & j & ".IpRanges.1.CidrIp=0.0.0.0/0";
    j = j + 1;
  end;
  path = path & "&Version=2015-10-01";
  path = SignAmazonRequestPath(server,path,"",region,service,HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,"");
  res = SendWebRequest(server,443,-1,true,"GET",path,"text/xml","",false,a_req,a_reply,20);
  if (res) then begin
    x_reply = ParseXmlArea(a_reply);
    AmazonLogErrorResponse("AmazonFirewallClosePorts()",x_reply);
    if (XmlGet(x_reply,"RevokeSecurityGroupIngressResponse/return")!="true") then begin
      LogText(0,"ERROR AmazonFirewallClosePorts() failed with unknown error");
    end;
  end;

LAmazonFirewallClosePorts:;
  return;
end;

global
function Boolean AllocateEC2ElasticIP(record HostingConfigurationVc HCr,string cncode)
begin
  Boolean res;
  string 255 ipaddr;
  record CloudNodeVc CNr;

  if (ReadFirstMain(HCr,1,true)==false) then begin
    goto LAllocateEC2ElasticIP;
  end;

  res = AmazonAllocateElasticIP(HCr,ipaddr);

LAllocateEC2ElasticIP:;
  AllocateEC2ElasticIP = res;
  return;
end;

global
procedure LoadHostFirewallConfiguration(record CloudNodeVc CNr,record RcVc RepSpec)
begin
  Integer res,i;
  Boolean bres;
  string 255 msg,cmd,tcp_ports,udp_ports;
  area a_tmp;
  record HostingConfigurationVc HCr;
  array string 255 tcpportsarr,udpportsarr;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LLoadHostFirewallConfiguration;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LLoadHostFirewallConfiguration;
  end;

  if (blank(HCr.AmazonAccessKeyID)) then begin
    res = 4;
    msg = "This operation requires the Amazon Access Key ID to be specified in Hosting Configuration " & HCr.SerNr & ".";
    goto LLoadHostFirewallConfiguration;
  end;

  if (blank(HCr.AmazonSecretAccessKey)) then begin
    res = 5;
    msg = "This operation requires the Amazon Secret Access Key to be specified in Hosting Configuration " & HCr.SerNr & ".";
    goto LLoadHostFirewallConfiguration;
  end;

  if (blank(HCr.AmazonRegion)) then begin
    res = 6;
    msg = "This operation requires the Amazon Region to be specified in Hosting Configuration " & HCr.SerNr & ".";
    goto LLoadHostFirewallConfiguration;
  end;
  bres = AmazonFirewallGetOpenPorts(HCr,CNr.Code,tcpportsarr,udpportsarr);
  for (i = 0; i<tcpportsarr.length; i = i + 1) begin
    if (i>0) then begin tcp_ports = tcp_ports & ","; end;
    tcp_ports = tcp_ports & tcpportsarr[i];
  end;
  for (i = 0; i<udpportsarr.length; i = i + 1) begin
    if (i>0) then begin udp_ports = udp_ports & ","; end;
    udp_ports = udp_ports & udpportsarr[i];
  end;
  if (bres==false) then begin res = 0; end;
  RepSpec.f2 = tcp_ports;
  RepSpec.f3 = udp_ports;

LLoadHostFirewallConfiguration:;
  clientremoteasync.OpenASPConfigHostFirewallWClassOnClient(res,msg,RepSpec);
  return;
end;

procedure GetPortrangeVectorFromString(string ports,var vector string res)
begin
  LongInt pos1,pos2;
  string 255 tstr,fromport,toport;

  while (GetNextSubstring(ports,pos1,",",tstr)) begin
    pos2 = -1;
    GetNextSubstring(tstr,pos2,"-",fromport);
    GetNextSubstring(tstr,pos2,"-",toport);
    if (blank(toport)) then begin toport = fromport; end;
    if (nonblank(fromport)) then begin
      res[fromport] = toport;
    end;
  end;

  return;
end;

global
updating function Integer ConfigHostFirewall(string cncode,string tcp_ports,string udp_ports,Integer op,var string msg)
begin
  record RemoteCloudServerVc RCSr;
  record HostingConfigurationVc HCr;
  record CloudNodeVc CNr,OldCNr;
  Boolean foundf;
  Integer res;
  string 255 bp;
  area a_script,a_script_data;
  vector string 255 tcpportsvec,udpportsvec;

  CNr.Code = cncode;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    res = 1;
    msg = "The selected node could not be found (was it deleted?).";
    goto LConfigHostFirewall;
  end;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LConfigHostFirewall;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LConfigHostFirewall;
  end;

  GetPortrangeVectorFromString(tcp_ports,tcpportsvec);
  GetPortrangeVectorFromString(udp_ports,udpportsvec);
  if (op==0) then begin
    AmazonFirewallOpenPorts(HCr,CNr.Code,tcpportsvec,udpportsvec);
  end else begin
    AmazonFirewallClosePorts(HCr,CNr.Code,tcpportsvec,udpportsvec);
  end;

LConfigHostFirewall:;
  ConfigHostFirewall = res;
  return;
end;

global
updating function Integer StopHost(record CloudNodeVc CNr,Boolean checkserversf,var string msg)
begin
  record RemoteCloudServerVc RCSr;
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr;
  Boolean foundf;
  Integer res;
  string 255 bp;
  area a_script,a_script_data;

  if (checkserversf) then begin
    RCSr.Controller = CNr.Code;
    foundf = true;
    while (LoopKey("Controller",RCSr,1,foundf)) begin
      if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
      if (foundf) then begin
        if (RCSr.Closed==0) then begin
          if (RCSr.CurrentStatus!=kStatusStopped) then begin
            res = 1;
            msg = "Stop all servers on the selected node and try again.";
            goto LStopHost;
          end;
        end;
      end;
    end;
  end;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LStopHost;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LStopHost;
  end;

  bp = "-O " & HCr.AmazonAccessKeyID & " -W " & HCr.AmazonSecretAccessKey & " --region " & HCr.AmazonRegion & " ";

  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddLineToArea("res=$(ec2-stop-instances " & bp & CNr.AmazonInstanceId & " |cut -f 4)",a_script);
  AddLineToArea("if ( [ \"${res}\" == \"stopping\" ] ) then",a_script);
  AddLineToArea("while [ \"$(ec2-describe-instances " & bp & CNr.AmazonInstanceId & " |grep ^INSTANCE |cut -f6)\" != \"stopped\" ] ; do sleep 1 ; done",a_script);
  AddLineToArea("fi",a_script);

  res = RunScriptInBackground("/tmp/CCStopEC2Node",a_script,a_script_data);
  if (res==2) then begin
    res = 4;
    msg = "Can't stop node " & CNr.Code & ", operation already in progress";
    goto LStopHost;
  end;
  SetCloudControllerStatus(kJobStatusRunning,"Stopping Cloud Node " & CNr.Code);
  res = 0;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);
  CNr.CurrentState = kCloudNodeStateStopping;
  RecordUpdate(OldCNr,CNr,true);

LStopHost:;
  StopHost = res;
end;

global
updating function Integer MoveNodeToNewHost(record CloudNodeVc CNr,string new_hc_sernr,string new_type,LongInt new_disksz,Integer new_ssdf,var string msg)
begin
  record Attach2Vc AT2r;
  record RemoteCloudServerVc RCSr;
  record HostingConfigurationVc HCr,HC2r;
  record CloudNodeVc OldCNr,CN2r;
  Boolean foundf;
  Integer res;
  area a_script,a_script_data;
  string 255 lockfile,datafile,keyfile_old,keyfile_new,data2file;
  area a_ec2_key;
  LongInt blocklen;

  RCSr.Controller = CNr.Code;
  foundf = true;
  while (LoopKey("Controller",RCSr,1,foundf)) begin
    if (RCSr.Controller!=CNr.Code) then begin foundf = false; end;
    if (foundf) then begin
      if (RCSr.Closed==0) then begin
        if (RCSr.CurrentStatus!=kStatusStopped) then begin
          res = 1;
          msg = "Stop all servers on the selected node and try again.";
          goto LMoveNodeToNewHost;
        end;
      end;
    end;
  end;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the selected node could not be found.";
    goto LMoveNodeToNewHost;
  end;

  HC2r.SerNr = new_hc_sernr;
  if (ReadFirstMain(HC2r,1,true)==false) then begin
    res = 2;
    msg = "The hosting configuration for the new host could not be found.";
    goto LMoveNodeToNewHost;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    res = 3;
    msg = "This operation can only be performed on Amazon EC2 hosted nodes.";
    goto LMoveNodeToNewHost;
  end;
  
  CN2r.Code = CNr.Code & "_OLD";
  if (ReadFirstMain(CN2r,1,true)==true) then begin
    res = 4;
    msg = "To perform this operation, delete the node " & CN2r.Code & " and try again.";
    goto LMoveNodeToNewHost;
  end;

  if (GetKeyForHostingConfiguration(HCr,AT2r)==false) then begin
    res = 5;
    msg = "Key missing for hosting configuration " & HCr.SerNr & ", upload the key and try again.";
    goto LMoveNodeToNewHost;
  end;

  lockfile = "/tmp/CCMoveEC2Node";
  datafile = lockfile & "Data";
  keyfile_old = lockfile & "-ko.dat";
  keyfile_new = lockfile & "-kn.dat";

  blocklen = AttachFileSize(AT2r);
  SetAreaZeroSize(a_ec2_key);
  LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
  WriteAreaToFile(a_ec2_key,keyfile_old,0);

  if (GetKeyForHostingConfiguration(HC2r,AT2r)==false) then begin
    res = 6;
    msg = "Key missing for hosting configuration " & HC2r.SerNr & ", upload the key and try again.";
    goto LMoveNodeToNewHost;
  end;

  blocklen = AttachFileSize(AT2r);
  SetAreaZeroSize(a_ec2_key);
  LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
  WriteAreaToFile(a_ec2_key,keyfile_new,0);

  AddLineToArea(new_type,a_script_data);
  AddLineToArea(new_disksz,a_script_data);
  AddLineToArea(new_ssdf,a_script_data);
  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddRecordToArea(HC2r,"HostingConfigurationVc",a_script_data);
  AddLineToArea("ssh -o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no -i " & keyfile_old & " " & CNr.AdminUser & "@" & CNr.HostName & " <<'COMMANDS-END'",a_script);
  AddLineToArea("sudo su",a_script);
  AddLineToArea("cndir=" & LowerCase(CNr.Code),a_script);
  AddLineToArea("cndir=HTS_CloudNode_${cndir^}",a_script);
  AddLineToArea("cd /Servers/${cndir} || cd /Servers/*CloudNode*",a_script);
  AddLineToArea("./stop-hansa.sh",a_script);
  AddLineToArea("kill $(cat hansa.pid) $(cat run-hansa.pid)",a_script);
  AddLineToArea("kill $(lsof |grep /Servers/ |cut -d" " -f 2)",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("COMMANDS-END",a_script);

  res = RunScriptInBackground(lockfile,a_script,a_script_data);
  if (res==2) then begin
    res = 4;
    msg = "Can't move node " & CNr.Code & ", operation already in progress";
    goto LMoveNodeToNewHost;
  end;
  SetCloudControllerStatus(kJobStatusRunning,"Moving Cloud Node " & CNr.Code);
  res = 0;

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);
  CNr.CurrentState = kCloudNodeStateMoving;
  RecordUpdate(OldCNr,CNr,true);

LMoveNodeToNewHost:;
  MoveNodeToNewHost = res;
end;

global
updating function Integer MoveNodeToNewHostStageFour(record CloudNodeVc CNr,record HostingConfigurationVc HC2r)
begin
  record Attach2Vc AT2r;
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr,CN2r;
  Boolean foundf;
  Integer res;
  string 255 sshopt;
  area a_script,a_script_data;
  string 255 lockfile,datafile,keyfile_old,keyfile_new,data2file;
  area a_ec2_key;
  LongInt blocklen;
  string 255 transaddr;

  if (ReadFirstMain(HC2r,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed moving node " & CNr.Code & " because the the hosting configuration for the new host disappeared.");
    goto LMoveNodeToNewHostStageFour;
  end;

  CN2r.Code = CNr.Code & "_OLD";
  if (ReadFirstMain(CN2r,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed moving node " & CNr.Code & " because the the old node " & CN2r.Code & "  disappeared.");
    goto LMoveNodeToNewHostStageFour;
  end;

  HCr.SerNr = CN2r.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed moving node " & CNr.Code & " because the its hosting configuration disappeared.");
    goto LMoveNodeToNewHostStageFour;
  end;

  lockfile = "/tmp/CCMoveDataEC2Node";
  datafile = lockfile & "Data";
  keyfile_old = lockfile & "-ko.dat";
  keyfile_new = lockfile & "-kn.dat";

  if (GetKeyForHostingConfiguration(HC2r,AT2r)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed moving node " & CNr.Code & " because the key for hosting configuration " & HCr.SerNr & " disappeared.");
    goto LMoveNodeToNewHostStageFour;
  end;

  blocklen = AttachFileSize(AT2r);
  SetAreaZeroSize(a_ec2_key);
  LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
  WriteAreaToFile(a_ec2_key,keyfile_new,0);

  if (GetKeyForHostingConfiguration(HCr,AT2r)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed moving node " & CNr.Code & " because the key for hosting configuration " & HC2r.SerNr & " disappeared.");
    goto LMoveNodeToNewHostStageFour;
  end;

  blocklen = AttachFileSize(AT2r);
  SetAreaZeroSize(a_ec2_key);
  LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
  WriteAreaToFile(a_ec2_key,keyfile_old,0);

  sshopt = "-o UserKnownHostsFile=/dev/null -o ServerAliveInterval=60 -o StrictHostKeyChecking=no -o PasswordAuthentication=no -i ";

  transaddr = CN2r.HostName;
  if (HCr.AmazonRegion==HC2r.AmazonRegion) then begin
    if (nonblank(CN2r.AmazonPrivateIP)) then begin transaddr = CN2r.AmazonPrivateIP; end;
  end;

  AddRecordToArea(CNr,"CloudNodeVc",a_script_data);
  AddRecordToArea(CN2r,"CloudNodeVc",a_script_data);
  AddRecordToArea(HC2r,"HostingConfigurationVc",a_script_data);
  AddLineToArea("rsync -a -e \"ssh " & sshopt & keyfile_new & "\" --rsync-path=\"sudo rsync\" " & keyfile_old & " " & CNr.AdminUser & "@" & CNr.HostName & ":" & keyfile_old,a_script);
  AddLineToArea("ssh " & sshopt & keyfile_new & " " & CNr.AdminUser & "@" & CNr.HostName & " <<'COMMANDS-END'",a_script);
  AddLineToArea("sudo su",a_script);
  AddLineToArea("trap \"rm -f " & keyfile_old & "\" EXIT",a_script);
  AddLineToArea("(",a_script);
  AddLineToArea("cndir=" & LowerCase(CNr.Code),a_script);
  AddLineToArea("cndir=HTS_CloudNode_${cndir^}",a_script);
  AddLineToArea("rsync -a -e \"ssh " & sshopt & keyfile_old & "\" --rsync-path=\"sudo rsync\" --exclude=\"${cndir}\" " & CN2r.AdminUser & "@" & transaddr & ":/Servers/ /Servers/",a_script);
  AddLineToArea("rsync -a -e \"ssh " & sshopt & keyfile_old & "\" --rsync-path=\"sudo rsync\" --include=\"*key*\" --exclude='*' " & CN2r.AdminUser & "@" & transaddr & ":/etc/ssh/ /etc/ssh/",a_script);
  AddLineToArea("rsync -a -e \"ssh " & sshopt & keyfile_old & "\" --rsync-path=\"sudo rsync\" --include='id_*' --include=authorized_keys --include=known_hosts --exclude='*' " & CN2r.AdminUser & "@" & transaddr & ":/root/.ssh/ /root/.ssh/",a_script);
  AddLineToArea("ssh -q " & sshopt & keyfile_old & " " & CN2r.AdminUser & "@" & transaddr & " sudo crontab -l |crontab -",a_script);
  AddLineToArea(")",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("exit",a_script);
  AddLineToArea("COMMANDS-END",a_script);

  res = RunScriptInBackground(lockfile,a_script,a_script_data);
  if (res==2) then begin
    SetCloudControllerStatus(kJobStatusError,"Can't move node " & CNr.Code & ", operation already in progress");
    goto LMoveNodeToNewHostStageFour;
  end;
  SetCloudControllerStatus(kJobStatusRunning,"Moving data on Cloud Node " & CNr.Code);
  res = 0;

LMoveNodeToNewHostStageFour:;
  MoveNodeToNewHostStageFour = res;
end;

global
updating procedure RefreshHostConfiguration(record CloudNodeVc CNr)
begin
  string 255 cmd,bp,tstr;
  record HostingConfigurationVc HCr;
  record CloudNodeVc OldCNr;

  SetCloudControllerStatus(kJobStatusRunning,"Refreshing host configuration for node " & CNr.Code);

  ReadFirstMain(CNr,1,true);
  RecordCopy(OldCNr,CNr);

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Couldn't refresh host configuration for node " & CNr.Code & " because the hosting configuration " & CNr.HostingConfig & " could not be found");
    goto LRefreshHostConfiguration;
  end;

  if (HCr.HostingType!=kHostingTypeAmazon) then begin
    SetCloudControllerStatus(kJobStatusError,"Couldn't refresh host configuration for node " & CNr.Code & " because it isn't  an Amazon EC2 host");
    goto LRefreshHostConfiguration;
  end;

  bp = "-O " & HCr.AmazonAccessKeyID & " -W " & HCr.AmazonSecretAccessKey & " --region " & HCr.AmazonRegion & " ";

  cmd = "ec2-describe-addresses " & bp & " " & CNr.HostName & "|cut -f3";
  if (RunOneLineOutCommand(cmd,tstr)==true) then begin
    if (nonblank(tstr)) then begin
      CNr.AmazonInstanceId = tstr;
    end;
  end;

  if (blank(CNr.AmazonInstanceId)) then begin
    cmd = "ec2-describe-instances " & bp & "|grep " & CNr.HostName & "|cut -f2";
    if (RunOneLineOutCommand(cmd,tstr)==true) then begin
      if (nonblank(tstr)) then begin
        CNr.AmazonInstanceId = tstr;
      end;
    end;
  end;

  if (blank(CNr.AmazonInstanceId)) then begin
    SetCloudControllerStatus(kJobStatusError,"Couldn't refresh host configuration for node " & CNr.Code & " because the instance ID couldn't be detected");
    goto LRefreshHostConfiguration;
  end;

  cmd = "ec2-describe-instances " & bp & CNr.AmazonInstanceId & "|grep ^INSTANCE|cut -f10";
  if (RunOneLineOutCommand(cmd,tstr)==true) then begin
    if (nonblank(tstr)) then begin
      CNr.AmazonInstanceType = tstr;
    end;
  end;

  cmd = "ec2-describe-instances " & bp & CNr.AmazonInstanceId & "|grep ^INSTANCE|cut -f13";
  if (RunOneLineOutCommand(cmd,tstr)==true) then begin
    if (nonblank(tstr)) then begin
      CNr.AmazonKernelId = tstr;
    end;
  end;

  cmd = "ec2-describe-instances " & bp & CNr.AmazonInstanceId & "|grep ^INSTANCE|cut -f18";
  if (RunOneLineOutCommand(cmd,tstr)==true) then begin
    if (nonblank(tstr)) then begin
      CNr.AmazonPrivateIP = tstr;
    end;
  end;

  cmd = "ec2-describe-instances " & bp & CNr.AmazonInstanceId & "|grep ^INSTANCE|cut -f4";
  if (RunOneLineOutCommand(cmd,tstr)==true) then begin
    if (nonblank(tstr)) then begin
      CNr.AmazonPublicDNS = tstr;
    end;
  end;
  RecordUpdate(OldCNr,CNr,true);
  SetCloudControllerStatus(kJobStatusFinished,"Host configuration for node " & CNr.Code & " refreshed");

LRefreshHostConfiguration:;
  return;
end;

global
procedure CleanCloudArchiveTask(string args)
begin
  LongInt i;
  record ASPArchiveVc AAr;
  Boolean foundf;
  Date dt,dt2;
  Time tm;

  AAr.State = kArchiveFileStateLocalAndLongTerm;
  i = 0;
  foundf = true;
  while (LoopKey("State",AAr,1,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LCleanCloudArchiveTask; end;
    if (AAr.State!=kArchiveFileStateLocalAndLongTerm) then begin foundf = false; end;
    if (foundf) then begin
      if (FileChangedDate(AAr.FilePath & "/" & AAr.FileName,dt,tm)==true) then begin
        dt2 = AddMonth(CurrentDate,-3);
        if (dt<dt2) then begin
          Delete_File(AAr.FilePath & "/" & AAr.FileName);
          i = i + 1;
        end;
      end;
      if (FileExists(AAr.FilePath & "/" & AAr.FileName)==false) then begin
        AAr.UpdatedFlag = 1;
        AAr.State = kArchiveFileStateLongTerm;
        qupdating.StoreCloudArchiveRec(AAr);
      end;
    end;
  end;
  if (i>0) then begin
    LogText(0,"Deleted " & i & " files that had been moved to long term cloud archive");
  end;

LCleanCloudArchiveTask:;
  return;
end;

global
procedure ArchiveLocalCloudServerFiles(string args)
begin
  record ASPArchiveVc AAr,AA2r;
  record LocalCloudServerVc LCSr;
  record HansaVersionVc HVr;
  string 255 filename,path,backupfolder,newfname;
  Boolean process_lcsf,foundf,testf,have_archiverecf,archivef,successf;
  LongInt filecnt,i,files_to_archive_cnt,files_to_archive_max;
  string 255 today_tb,yesterday_tb;
  Date dt;
  Time tm;
  Boolean locking_backupsf,skip_compressf;

  dt = CurrentDate;
  today_tb = "TB" & DateToString(dt,"YYMMDD") & ".TXT";
  dt = AddDay(dt,-1);
  yesterday_tb = "TB" & DateToString(dt,"YYMMDD") & ".TXT";

  while (LoopMain(LCSr,1,true)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LArchiveLocalCloudServerFiles; end;
    locking_backupsf = true;
    if (blank(LCSr.HansaVersion)) then begin
      locking_backupsf = false;
    end else begin
      GetVersion(LCSr.HansaVersion,HVr);
      if (HVr.Version<80) then begin locking_backupsf = false; end;
    end;

    backupfolder = LCSr.BackupFolder;
    if (blank(backupfolder)) then begin backupfolder = "Backup"; end;
    path = LCSr.DataFolder & "/" & backupfolder;
                
    process_lcsf = true;
    if (process_lcsf and (LCSr.MovedAwayFlag!=0)) then begin process_lcsf = false; end;
    if (process_lcsf and (LCSr.Closed!=0)) then begin process_lcsf = false; end;
    if (process_lcsf and blank(LCSr.DataFolder)) then begin process_lcsf = false; end;
    if (process_lcsf and !DirExists(path)) then begin process_lcsf = false; end;
    if (process_lcsf and (LCSr.DisableCloudBackupFlag!=0)) then begin process_lcsf = false; end;
                
    if (process_lcsf) then begin
      filecnt = CountFilesInDir(path);
      for (i = 0; i<filecnt; i = i + 1) begin
        if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LArchiveLocalCloudServerFiles; end;
        filename = GetFileNameInDir(path,i);
        newfname = CompressedFileName(filename);
                
        archivef = true;
        skip_compressf = false;
        if (archivef and left(filename,1)==".") then begin archivef = false; end;
        if (locking_backupsf==false) then begin
          if (archivef and right(filename,12)==today_tb) then begin archivef = false; end;
          if (archivef and right(filename,12)==yesterday_tb) then begin archivef = false; end;
        end;
        if (archivef and UpperCase(right(filename,4))!=".TXT") then begin archivef = false; end;
        if (archivef and FileIsLocked(path & "/" & filename)) then begin archivef = false; end;
        if (archivef and FileChangedDate(path & "/" & filename,dt,tm)==true) then begin
          if (dt==CurrentDate) then begin
            archivef = true;
            skip_compressf = true;
          end;
        end;
        if (!archivef) then begin goto LArchiveLocalCloudServerFiles_Next; end;
                
        RecordClear(AAr);
        ResetLoop(AA2r);
        RecordClear(AA2r);
        AAr.ServerUUID = LCSr.UUID;
        AAr.ServerName = LCSr.Name;
        AAr.CUCode = LCSr.CUCode;
        AAr.FileName = filename;
        AAr.FilePath = path;
        AAr.FileType = kArchiveFileTypeTextBackup;
        AAr.State = kArchiveFileStateArchivingingLocally;
        AAr.UpdatedFlag = 1;
        RecordCopy(AA2r,AAr);
        have_archiverecf = false;
        archivef = false;
        //?? should it really store the entire paths, should filename & path really not be in an index?
        foundf = true;
        while (LoopKey("ServerUUID",AA2r,2,foundf)) begin
          if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LArchiveLocalCloudServerFiles; end;
          if (AA2r.ServerUUID!=LCSr.UUID) then begin foundf = false; end;
          if (AA2r.FileType!=kArchiveFileTypeTextBackup) then begin foundf = false; end;
          testf = foundf;
          if (testf and (AA2r.FilePath!=path)) then begin testf = false; end;
          if (testf and (AA2r.FileName!=filename) and (AA2r.FileName!=newfname)) then begin testf = false; end;
          if (testf) then begin
            have_archiverecf = true;
            if ((AA2r.State==kArchiveFileStateUnknown) or (AA2r.State==kArchiveFileStatePendingArchiving)) then begin
              archivef = true;
              AAr.UUID = AA2r.UUID;
            end;
            if (AA2r.State==kArchiveFileStateLocal or AA2r.State==kArchiveFileStateLocalAndLongTerm) then begin
              if (AA2r.FileName==newfname) then begin
                archivef = true;
                AAr.UUID = AA2r.UUID;
              end;
            end;
          end;
        end;
        if (!have_archiverecf) then begin archivef = true; end;
                
        if (!archivef) then begin goto LArchiveLocalCloudServerFiles_Next; end;

        if (skip_compressf==false) then begin
          switch (ProgramPlatform) begin
            case kPlatformMac:      RunShellScript("bzip2 -fq -3 \"" & path & "/" & filename & "\"");
            case kPlatformLinux32:  RunShellScript("ionice -c 3 bzip2 -fq -3 \"" & path & "/" & filename & "\"");
            case kPlatformLinux64:  RunShellScript("ionice -c 3 bzip2 -fq -3 \"" & path & "/" & filename & "\"");
            otherwise
              goto LArchiveLocalCloudServerFiles_Next;
          end;
          if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LArchiveLocalCloudServerFiles; end;
          successf = FileExists(path & "/" & newfname);
        end;
        if (successf) then begin
          AAr.FileName = newfname;
          AAr.State = kArchiveFileStateLocal;
        end else begin
          if (skip_compressf) then begin
            if (have_archiverecf and AA2r.State==kArchiveFileStatePendingArchiving) then begin
              goto LArchiveLocalCloudServerFiles_Next;
            end;
            AAr.State = kArchiveFileStatePendingArchiving;
          end else begin
            AAr.State = kArchiveFileStateUnknown;
          end;
        end;
        qupdating.StoreCloudArchiveRec(AAr);
                
LArchiveLocalCloudServerFiles_Next:;
      end;
    end;
  end;

LArchiveLocalCloudServerFiles:;
  return;
end;

global
updating procedure DoCreateVersionRecordOnNode(record HansaVersionVc HVr)
begin
  record HansaVersionVc OldHVr;
  record HansaVersionVc HV2r;

  HV2r.Code = HVr.Code;
  if (ReadFirstMain(HV2r,1,true)) then begin
    RecordCopy(OldHVr,HV2r);
    RecordUpdate(OldHVr,HVr,true);
    LogText(0,"Updating version record " & HVr.Code);
  end else begin
    RecordInsert(HVr,false);
    LogText(0,"Creating version record " & HVr.Code);
  end;
end;

global
updating function Boolean SendVersionRecordToNode(string vercode,string node)
begin
  string 255 url;
  record CloudNodeVc CNr;
  record HansaVersionVc HVr;
  LongInt stat;
  Boolean res;

  HVr.Code = vercode;
  if (ReadFirstMain(HVr,1,true)==false) then begin
    LogText(0,"SendVersionRecordToNode(\"" & vercode & "\") failed, record not found");
    goto LSendVersionRecordToNode;
  end;

  CNr.Code = node;
  url = ReadNodeURL(CNr);
  HVr.CurrentState = kHansaVersionStateDeprecated;

  stat = CallService(url).DoCreateVersionRecordOnNode(HVr);
  if (TreatServiceError(stat,url,"DoCreateVersionRecordOnNode")) then begin
    LogText(0,"Failed send version " & vercode & " to CN " & CNr.Code);
    goto LSendVersionRecordToNode;
  end;
  res = true;

LSendVersionRecordToNode:;
  SendVersionRecordToNode = res;
  return;
end;

global
updating function Boolean ChangeVersionOnRemoteCloudServer(UUID server_uuid,string new_vercode,string message,Integer mins)
begin
  record RemoteCloudServerVc RCSr,OldRCSr;
  record HansaVersionVc HVr;
  Boolean res,testf;
  record UserVc Userr;

  RCSr.UUID = server_uuid;
  if (ReadFirstMain(RCSr,1,true)==false) then begin
    LogText(0,"ChangeVersionOnRemoteCloudServer(\"" & server_uuid & "\") failed, record not found");
    goto LChangeVersionOnRemoteCloudServer;
  end;

  HVr.Code = new_vercode;
  if (ReadFirstMain(HVr,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"Couldn't change version on cloud server " & RCSName(RCSr) & " because the version " & new_vercode & " does not exist");
    LogText(0,"ERROR: Couldn't change version on cloud server " & RCSName(RCSr) & " because the version " & new_vercode & " does not exist");
    goto LChangeVersionOnRemoteCloudServer;
  end;

  if (RCSr.CurrentStatus!=kStatusStopped) then begin
    DoGetCurUser(Userr);
    StartStopSystemCopies(RCSr,kManagedServerWhenRunningNormally,false,true);
    testf = SoftStopRemoteCloudServer(RCSr,Userr.Name,message,mins);
    if (testf==false) then begin
      SetCloudControllerStatus(kJobStatusError,"Couldn't change version on server " & RCSName(RCSr) & ", node communication failure");
      goto LChangeVersionOnRemoteCloudServer;
    end;
    RecordCopy(OldRCSr,RCSr);
    RCSr.WantedStatus = kWantedStatusChangeVersion;
    RCSr.NewHansaVersion = new_vercode;
    RecordUpdate(OldRCSr,RCSr,true);
  end else begin
    if (DoChangeVersionOnRemoteCloudServer(RCSr,new_vercode)==false) then begin
      goto LChangeVersionOnRemoteCloudServer;
    end;
  end;

  res = true;

LChangeVersionOnRemoteCloudServer:;
  ChangeVersionOnRemoteCloudServer = res;
  return;
end;

global
updating procedure DoConfirmArchiveUpdates(array record ASPArchiveVc AAr_arr)
begin
  record ASPArchiveVc AAr,OldAAr,AA2r;
  LongInt i;

  for (i = 0; i<AAr_arr.length; i = i + 1) begin
    AA2r = AAr_arr[i];
    RecordCopy(AAr,AAr_arr[i]);
    if (ReadFirstMain(AAr,1,true)) then begin
      if (AAr.State==AA2r.State) then begin
        if (AAr.State==kArchiveFileStateLongTerm) then begin
          RecordDelete(AAr);
        end else begin
          RecordCopy(OldAAr,AAr);
          AAr.UpdatedFlag = 0;
          RecordUpdate(OldAAr,AAr,true);
        end;
      end;
    end else begin
      AAr.UpdatedFlag = 0;
      RecordStore(AAr,false);
    end;
  end;
  return;
end;

global
procedure ConfirmArchiveUpdates(array record ASPArchiveVc AAr_arr)
begin
  queued.DoConfirmArchiveUpdates(AAr_arr);
  return;
end;

global
procedure SendConfirmArchiveUpdates(record CloudNodeVc CNr,array record ASPArchiveVc AAr_arr)
begin
  string 255 url;
  LongInt stat;
  Boolean failf;
                
  url = NodeURL(CNr);
  stat = CallService(url).ConfirmArchiveUpdates(AAr_arr);
  failf = TreatServiceError(stat,url,"ConfirmArchiveUpdates");
  return;
end;

global
updating procedure SaveArchiveUpdates(record CloudNodeVc CNr,array record ASPArchiveVc AAr_arr)
begin
  record ASPArchiveVc AAr,OldAAr,AA2r;
  LongInt i;

  for (i = 0; i<AAr_arr.length; i = i + 1) begin
    RecordCopy(AAr,AAr_arr[i]);
    if (ReadFirstMain(AAr,1,true)) then begin
      RecordCopy(OldAAr,AAr);
      AA2r = AAr_arr[i];
      AA2r.Controller = CNr.Code;
      AA2r.UpdatedFlag = 0;
      RecordUpdate(OldAAr,AA2r,true);
    end else begin
      AA2r = AAr_arr[i];
      AA2r.Controller = CNr.Code;
      AA2r.UpdatedFlag = 0;
      RecordStore(AA2r,false);
    end;
  end;

  if (AAr_arr.length>0) then begin
    threadasync.SendConfirmArchiveUpdates(CNr,AAr_arr);
    LogText(0,"Updated " & i & " archive records");
  end;
  return;
end;

global
procedure GetCloudNodeArchiveUpdates(var array record ASPArchiveVc AAr_arr)
begin
  record ASPArchiveVc AAr;
  Boolean foundf;
  LongInt i;

  AAr.UpdatedFlag = 1;
  foundf = true;
  i = 0;
  while (LoopKey("UpdatedFlag",AAr,1,foundf)) begin
    if (AAr.UpdatedFlag!=1) then begin foundf = false; end;
    if (foundf) then begin
      AAr_arr[i] = AAr;
      i = i + 1;
      if (i>100) then begin goto LGetCloudNodeArchiveUpdates; end;
    end;
  end;

LGetCloudNodeArchiveUpdates:;
  return;
end;

global
procedure UpdateArchiveFromNode(record CloudNodeVc CNr)
begin
  array record ASPArchiveVc AAr_arr;
  string 255 url;
  LongInt stat;
  Boolean failf;

  url = NodeURL(CNr);
  stat = CallService(url).GetCloudNodeArchiveUpdates(AAr_arr);
  failf = TreatServiceError(stat,url,"GetCloudNodeArchiveUpdates");
  if ((failf==false) and (AAr_arr.length>0)) then begin
    queued.SaveArchiveUpdates(CNr,AAr_arr);
  end;
  return;
end;

global
procedure UpdateArchiveFromNodesTask(string args)
begin
  record CloudNodeVc CNr;
  Boolean foundf,testf;

  CNr.Closed = 0;
  CNr.CurrentState = kCloudNodeStateNormal;
  foundf = true;
  while (LoopKey("State",CNr,2,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LUpdateArchiveFromNodesTask; end;
    if (CNr.CurrentState!=kCloudNodeStateNormal) then begin foundf = false; end;
    if (CNr.Closed!=0) then begin foundf = false; end;
    testf = foundf;
    if (testf and CNr.FastCheckFlag!=0) then begin testf = false; end;
    if (testf and CNr.ReachableFlag==0) then begin testf = false; end;
    if (testf) then begin
      UpdateArchiveFromNode(CNr);
    end;
  end;

LUpdateArchiveFromNodesTask:;
  return;
end;

global
procedure DoStartCloudArchivingOnCN(record HostingConfigurationVc HCr)
begin
  LongInt i;
  record ASPArchiveVc AAr;
  Boolean foundf,res;

  AAr.State = kArchiveFileStateLocal;
  foundf = true;
  i = 0;
  while (LoopKey("State",AAr,1,foundf)) begin
  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LDoStartCloudArchivingOnCN; end;
  if (AAr.State!=kArchiveFileStateLocal) then begin foundf = false; end;
    if (foundf) then begin
      if (!FileExists(AAr.FilePath & "/" & AAr.FileName)) then begin
        AAr.UpdatedFlag = 1;
        AAr.State = kArchiveFileStateDeleted;
        qupdating.StoreCloudArchiveRec(AAr);
      end else begin
        AAr.UpdatedFlag = 1;
        AAr.State = kArchiveFileStateUploadingToLongTerm;
        AAr.AmazonRegion = HCr.AmazonRegion;
        qupdating.StoreCloudArchiveRec(AAr);
        res = UploadFileToS3Bucket(HCr.AmazonAccessKeyID,HCr.AmazonSecretAccessKey,HCr.AmazonRegion,
                                   HCr.AmazonCloudArchiveBucket,AAr.FilePath & "/" & AAr.FileName,
                                   AAr.ServerUUID & "/" & AAr.UUID & "/" & AAr.FileName,AAr.ServerUUID,
                                   AAr.ServerName);
        if (res==true) then begin
          i = i + 1;
          AAr.State = kArchiveFileStateLocalAndLongTerm;
          qupdating.StoreCloudArchiveRec(AAr);
        end else begin
          AAr.State = kArchiveFileStateLocal;
          qupdating.StoreCloudArchiveRec(AAr);
        end;
      end;
    end;
  end;
  
  if (i>0) then begin
    LogText(0,"Sent " & i & " files to cloud archive");
  end;
                

LDoStartCloudArchivingOnCN:;
  ChangeVmLong("cloudarchiving",-1);
  return;
end;

global
procedure StartCloudArchivingOnCN(record HostingConfigurationVc HCr)
begin
  if (IncreaseVmLong("cloudarchiving",1)) then begin
    threadasync.DoStartCloudArchivingOnCN(HCr);
  end;
  return;
end;
                
procedure TransferOneNodeArchiveToCloudArchive(record CloudNodeVc CNr)
begin
  array record ASPArchiveVc AAr_res_arr;
  Boolean failf;
  LongInt i,stat;
  record HostingConfigurationVc HCr;
  string 255 url;

  HCr.SerNr = CNr.HostingConfig;
  if (!ReadFirstMain(HCr,1,true)) then begin
    LogText(0,"Cloud archiving on node " & CNr.Code & " is disabled because the hosting configuration " & CNr.HostingConfig & " is missing");
    goto LTransferOneNodeArchiveToCloudArchive;
  end;
  if (blank(HCr.AmazonAccessKeyID)) then begin
    LogText(0,"Cloud archiving on node " & CNr.Code & " is disabled because the Amazon Access Key ID field is blank in hosting configuration " & CNr.HostingConfig);
    goto LTransferOneNodeArchiveToCloudArchive;
  end;
  if (blank(HCr.AmazonSecretAccessKey)) then begin
    LogText(0,"Cloud archiving on node " & CNr.Code & " is disabled because the Amazon Secret Access Key field is blank in hosting configuration " & CNr.HostingConfig);
    goto LTransferOneNodeArchiveToCloudArchive;
  end;
  if (blank(HCr.AmazonRegion)) then begin
    LogText(0,"Cloud archiving on node " & CNr.Code & " is disabled because the Amazon region field is blank in hosting configuration " & CNr.HostingConfig);
    goto LTransferOneNodeArchiveToCloudArchive;
  end;
  if (blank(HCr.AmazonCloudArchiveBucket)) then begin
    LogText(0,"Cloud archiving on node " & CNr.Code & " is disabled because the Cloud Archive S3 Bucket field is blank in hosting configuration " & CNr.HostingConfig);
    goto LTransferOneNodeArchiveToCloudArchive;
  end;

  url = NodeURL(CNr);
  LogText(0,"Requesting cloud archive transfers on node " & CNr.Code);
  stat = CallService(url).StartCloudArchivingOnCN(HCr);
  if (TreatServiceError(stat,url,"StartCloudArchivingOnCN")) then begin
    LogText(0,"Failed to start cloud archiving on node " & CNr.Code);
  end;

LTransferOneNodeArchiveToCloudArchive:;
  return;
end;

global
procedure TransferToCloudArchiveTask(string arg)
begin
  record CloudNodeVc CNr;
  Boolean foundf,testf;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LTransferToCloudArchiveTask; end;

  LogText2(0,"Transferring files to cloud archive",kVerbosityDebug);

  CNr.Closed = 0;
  CNr.CurrentState = kCloudNodeStateNormal;
  foundf = true;
  while (LoopKey("State",CNr,2,foundf)) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LTransferToCloudArchiveTask; end;
    if (CNr.CurrentState!=kCloudNodeStateNormal) then begin foundf = false; end;
    if (CNr.Closed!=0) then begin foundf = false; end;
    testf = foundf;
    if (testf and CNr.FastCheckFlag!=0) then begin testf = false; end;
    if (testf and CNr.ReachableFlag==0) then begin testf = false; end;
    if (testf) then begin
      TransferOneNodeArchiveToCloudArchive(CNr);
    end;
  end;

  LogText2(0,"Finished transferring files to cloud archive",kVerbosityDebugDetailed);

LTransferToCloudArchiveTask:;
  return;
end;

global
updating procedure StartCloningAtCN(record LocalCloudServerVc LCSr,string passw,area a_ec2_key)
begin
  string 255 enpath;

  if (ReadFirstMain(LCSr,1,true)) then begin
//    Delete_File(LCSr.DataFolder & "/clone-attach-k.dat");
//    if (GetAreaLength(a_ec2_key)>0) then begin
//      WriteAreaToFile(a_ec2_key,LCSr.DataFolder & "/clone-attach-k.dat",0);
//    end;
    enpath = EnablerActionsFolder(LCSr) & "/";
    CreateFolderHierarchy(enpath);
    Delete_File(enpath & ".EnStartCloning");
    WriteStringToFile(passw,enpath & ".EnStartCloning",0);
    RenameFile(enpath & ".EnStartCloning",enpath & "EnStartCloning");
  end else begin
    LogText(0,"Failed to start cloning on cloud server " & LCSr.UUID);
  end;
end;

global
updating procedure AddCloningKeyAtCN(string datafolder,area a_ec2_key)
begin
  CreateFolderHierarchy(datafolder & "/");
  Delete_File(datafolder & "/clone-attach-k.dat");
  if (GetAreaLength(a_ec2_key)>0) then begin
    WriteAreaToFile(a_ec2_key,datafolder & "/clone-attach-k.dat",0);
  end;
end;

updating procedure StartCloning(record RemoteCloudServerVc RCSr,string passw,record RemoteCloudServerVc RCS2r)
begin
  string 255 url;
  LongInt stat;
  record LocalCloudServerVc LCSr;
  record HostingConfigurationVc HCr;
  record CloudNodeVc CNr;
  record Attach2Vc AT2r;
  LongInt blocklen;
  area a_ec2_key;

  url = RcsNodeURL(RCSr);
  if (nonblank(url)) then begin
    CNr.Code = RCSr.Controller;
    ReadFirstMain(CNr,1,true);
    HCr.SerNr = CNr.HostingConfig;
    if (!ReadFirstMain(HCr,1,true)) then begin
      LogText(0,"Cloning of attachments and other files will be disabled for server " & RCSName(RCSr) & " on node " & CNr.Code & " because the hosting configuration " & CNr.HostingConfig & " is missing");
    end else begin
      if (GetKeyForHostingConfiguration(HCr,AT2r)==false) then begin
        LogText(0,"Cloning of attachments and other files will be disabled because the hosting configuration with SerNr=" & HCr.SerNr & ", " & CNr.HostingConfig & " (" & CNr.HostingConfigComment & ") have no key uploaded");
      end else begin
        blocklen = AttachFileSize(AT2r);
        SetAreaZeroSize(a_ec2_key);
        LoadAttachFilePartToArea(AT2r,0,blocklen,a_ec2_key);
      end;
    end;
    LCSr.UUID = RCSr.UUID;
    LogText(0,"Starting cloning of remote cloud server " & RCSName(RCSr));
    stat = CallService(url).StartCloningAtCN(LCSr,passw,a_ec2_key);
    if (TreatServiceError(stat,url,"StartCloningAtCN")) then begin
      LogText(0,"Failed to start cloning of remote cloud server " & RCSName(RCSr));
    end;

    url = RcsNodeURL(RCS2r);
    if (nonblank(url)) then begin
      LogText(0,"Adding key for cloning to remote cloud server " & RCS2r.Name);
      stat = CallService(url).AddCloningKeyAtCN(RCS2r.DataFolder,a_ec2_key);
      if (TreatServiceError(stat,url,"AddCloningKeyAtCN")) then begin
        LogText(0,"Failed add key for cloning to remote cloud server " & RCS2r.Name);
      end;
    end else begin
      LogText(0,"(Node URL missing) Failed add key for cloning to remote cloud server " & RCS2r.Name);
    end;
  end else begin
    LogText(0,"Failed to start cloning of remote cloud server " & RCSName(RCSr) & ", because the node " & RCSr.Controller & " have no address");
  end;
end;

global
updating procedure DoLaunchRemoteCloudServerSystem2(record RcVc RepSpec,Integer system_type,var string msg,var UUID newserverid)
begin
  record CloudNodeVc CNr;
  record RemoteCloudServerVc RCSr;
  record RemoteCloudServerVc RCS2r,OldRCSr;
  row RemoteCloudServerVc RCSrw,RCS2rw,RCS3rw;
  string 255 passw,cloneflags;
  Integer i,rwcnt,stat;
  Boolean newpasswf;


  if (blank(RepSpec.f4)) then begin
    msg = "Name may not be blank.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;
  if (RCSr.Name==RepSpec.f4) then begin
    msg = "The system name must be different from the mother systems name.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;

  if (blank(RepSpec.f3)) then begin
    msg = "Folder may not be blank.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;
  if (left(RepSpec.f3,9)!="/Servers/" and mid(RepSpec.f3,2,9)!="\\Servers\\" and left(RepSpec.f3,8)!="Servers/") then begin
    msg = "Folder must be in Servers subfolder.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;


  RCSr.UUID = RepSpec.RecordUUID;
  if (ReadFirstMain(RCSr,1,true)==false) then begin
    msg = "The selected server does not exist.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;

  if (RCSr.Name==RepSpec.f3 and RCSr.Controller==RepSpec.f2) then begin
    msg = "The system folder must be different from the mother systems folder when launching it on the same node.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;

  if ((RCSr.CurrentStatus!=kStatusStopped) and
      (RCSr.CurrentStatus!=kStatusRunning)) then begin
    msg = "The cloud server must be stopped or running when launching this system.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;

// TODO: Check that ports are available if node is different from master system node
// TODO: Change datafolder if node is different from master system node
  RecordCopy(RCS2r,RCSr);

  newpasswf = true;
  rwcnt = MatRowCnt(RCS2r);
  for (i = rwcnt-1; i>=0; i = i - 1) begin
    MatRowGet(RCS2r,i,RCS3rw);
    if ((RCS3rw.Item==kManagedServerItemTestSystem) or (RCS3rw.Item==kManagedServerItemReserveSystem) or (RCS3rw.Item==kManagedServerItemUpdateSystem)) then begin
      passw = RCS3rw.Data;
      newpasswf = false;
      MatRowDelete(RCS2r,i);
    end else begin
      if (RCS3rw.Item==kManagedServerItemSlaveSystem) then begin
        RCS3rw.Disabled = 1;
        MatRowPut(RCS2r,i,RCS3rw);
      end;
    end;
  end;

  CNr.Code = RepSpec.f2;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    msg = "The cloud node " & RepSpec.f2 & " does not exist.";
    goto LDoLaunchRemoteCloudServerSystem;
  end;

  stat = CallService(NodeURL(CNr)).FindUnusedPorts(RCS2r.Port,RCS2r.HTTPPort,RCS2r.HTTPSPort);

  RCS2r.UUID = MakeUUID;
  RCS2r.CreatedDate = CurrentDate;
  RCS2r.CreatedTime = CurrentTime;
  RCS2r.Controller = CNr.Code;
  RCS2r.NewController = CNr.Code;
  RCS2r.PublicHostName = CNr.HostName;

  switch (system_type) begin
    case 2:
      RCS2r.HansaVersion = RepSpec.f1;
      RCS2r.WantedStatus = kWantedStatusLaunchTestSystem;
      RCS2r.Name = RepSpec.f4;
      RCS2r.DataFolder = RepSpec.f3;
      RCS2r.CloneFlag = 2;
      RCS2r.ServerName = RCS2r.ServerName & "-test";
    case 1:
      RCS2r.HansaVersion = RCSr.HansaVersion;
      RCS2r.WantedStatus = kWantedStatusLaunchReserveSystem;
      RCS2r.Name = RepSpec.f4;
      RCS2r.DataFolder = RepSpec.f3;
      RCS2r.CloneFlag = 1;
      RCS2r.ServerName = RCS2r.ServerName & "-reserve";
    case 3:
      RCS2r.HansaVersion = RepSpec.f1;
      RCS2r.WantedStatus = kWantedStatusLaunchUpdateSystem;
      RCS2r.Name = RepSpec.f4;
      RCS2r.DataFolder = RepSpec.f3;
      RCS2r.CloneFlag = 3;
      RCS2r.ServerName = RCS2r.ServerName & "-update";
  end;
  RCS2r.CurrentStatus = kStatusCreating;
  RCS2rw.Item = kManagedServerItemMotherSystem;
  RCS2rw.ItemName = RCSr.UUID;
  RCS2rw.Desc = RCSr.Name;
  if (newpasswf==true) then begin
    passw = GeneratePassword2(15);
  end;
  RCS2rw.Data = FindCloudNodeAddress(RCSr.Controller,true) & "," & RCSr.Port & "," & passw & "," & RepSpec.flags[0] & "," & RCSr.DataFolder & "," & RepSpec.flags[1] & "," & RCSr.HalcustUpdateRule & "," & RCSr.HalpatchUpdateRule & "," & RepSpec.long1;

  RCS2rw.When = kManagedServerWhenRunningNormally;
  RCS2rw.Disabled = 0;
  MatRowPut(RCS2r,MatRowCnt(RCS2r),RCS2rw);

  RecordCopy(OldRCSr,RCSr);
  switch (system_type) begin
    case 1: RCSrw.Item = kManagedServerItemReserveSystem;
    case 2: RCSrw.Item = kManagedServerItemTestSystem;
    case 3: RCSrw.Item = kManagedServerItemUpdateSystem;
  end;
  RCSrw.ItemName = RCS2r.UUID;
  RCSrw.Desc = RCS2r.Name;
  RCSrw.Data = passw;
  RCSrw.When = kManagedServerWhenRunningNormally;
  RCSrw.Disabled = 0;

  MatRowPut(RCSr,MatRowCnt(RCSr),RCSrw);
  StartCloning(RCSr,passw,RCS2r);

  RecordInsert(RCS2r,false);
  RecordUpdate(OldRCSr,RCSr,true);

  newserverid = RCS2r.UUID;

LDoLaunchRemoteCloudServerSystem:;
  return;
end;

global
updating procedure DoLaunchRemoteCloudServerSystem(record RcVc RepSpec,Integer system_type,var string msg)
begin
  UUID newserverid;

  DoLaunchRemoteCloudServerSystem2(RepSpec,system_type,msg,newserverid);
  return;
end;

procedure DownloadLocalizationsForLCS(record LocalCloudServerVc LCSr,record HansaVersionVc HVr)
begin
  string 255 country,language,hobfile,bpc,datfile;
  LongInt pos,dbver,version_build,vno;

  dbver = HVr.Version*100;
  dbver = dbver + HVr.SubVersion;
  bpc = LowerCase(HVr.ProductCode);
  version_build = (HVr.Version * 1000000) + (HVr.SubVersion * 10000) + HVr.RunningBuild;
  vno = dbver;
  if ((version_build>82211560 and version_build<83000000) or (version_build>83100005)) then begin
    vno = version_build;
  end;
  while (GetNextSubstring(LCSr.Localizations,pos,",",language)) begin
    hobfile = HVr.ProgramFolder & "/hob/cl" & LowerCase(language) & ".hob";
    if (FileExists(hobfile)==false) then begin
      if (DownloadLocalizationForHOB(hobfile,bpc,vno)==true) then begin
        LogText(0,"Starting download of " & language & " localizations for version " & HVr.Code);
      end;
    end;
  end;

  pos = -1;
  while (GetNextSubstring(LCSr.CountryLocalizations,pos,",",country)) begin
    datfile = HVr.ProgramFolder & "/hob/loc" & LowerCase(country) & ".dat";
    if (FileExists(datfile)==false) then begin
      if (DownloadLocalizationForHOB(datfile,bpc,dbver)==true) then begin
        LogText(0,"Starting download of " & country & " localizations for version " & HVr.Code);
      end;
    end;
  end;
end;

global
procedure DownloadLocalizationsForLCSsTask(string arg)
begin
  record LocalCloudServerVc LCSr;
  record HansaVersionVc HVr;
  Boolean testf;

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LDownloadLocalizationsForLCSsTask; end;

  while (LoopMain(LCSr,1,true)) begin
    testf = true;
    if (LCSr.Closed!=0) then begin testf = false; end;
    if (testf and blank(LCSr.HansaVersion)) then begin testf = false; end;
    if (testf and (blank(LCSr.Localizations) and blank(LCSr.CountryLocalizations))) then begin testf = false; end;
    if (testf and IsDownloadingVersion(LCSr.HansaVersion)) then begin testf = false; end;
    if (testf) then begin
      if (GetVersion(LCSr.HansaVersion,HVr)==false) then begin testf = false; end;
    end;
    if (testf) then begin
      DownloadLocalizationsForLCS(LCSr,HVr);
    end;
  end;

LDownloadLocalizationsForLCSsTask:;
  return;
end;

global
updating procedure GetFileSizeOnLCS(string remotefname,var Val fsz)
begin
  fsz = FileSize2(remotefname);
end;

global
updating procedure DoLoadFilePart(string remotefname,LongInt pos,LongInt blocklen,var area part)
begin
  LoadFileToArea(remotefname,pos,blocklen,part);
end;

global
procedure DeleteFileOnLCS(string remotefname)
begin
  LogText(0,"Deleting file " & remotefname);
  Delete_File(remotefname);
end;

global
procedure DeleteFolderOnLCS(string remotefname)
begin
  LogText(0,"Deleting folder " & remotefname);
  DeleteFolder(remotefname);
end;

global
updating procedure CreateFolderOnLCS(string remotefname)
begin
  LogText(0,"Creating folder " & remotefname);
  CreateFolderHierarchy(remotefname);
end;

global
procedure DeleteFileFromRemoteCloudServer(uuid rcsid,string fname,string fpath)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LDeleteFileFromRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Deleting file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Deleting file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).DeleteFileOnLCS(remotefname);
      if (TreatServiceError(stat,url,"DeleteFileOnLCS")) then begin
        LogText(0,"Failed to delete file " & fpath & "/" & fname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LDeleteFileFromRemoteCloudServer;
      end;
    end;
  end;

LDeleteFileFromRemoteCloudServer:;
end;

global
procedure DeleteFolderFromRemoteCloudServer(uuid rcsid,string fname,string fpath)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LDeleteFolderFromRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Deleting folder " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Deleting folder " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).DeleteFolderOnLCS(remotefname);
      if (TreatServiceError(stat,url,"DeleteFolderOnLCS")) then begin
        LogText(0,"Failed to delete folder " & fpath & "/" & fname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LDeleteFolderFromRemoteCloudServer;
      end;
    end;
  end;

LDeleteFolderFromRemoteCloudServer:;
end;

global
updating procedure CreateFolderOnRemoteCloudServer(uuid rcsid,string fpath,string fname)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LCreateFolderFromRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Creating folder " & remotefname & " for server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Creating folder " & remotefname & " for server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).CreateFolderOnLCS(remotefname);
      if (TreatServiceError(stat,url,"CreateFolderOnLCS")) then begin
        LogText(0,"Failed to create folder " & fpath & "/" & fname & " for server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LCreateFolderFromRemoteCloudServer;
      end;
    end;
  end;

LCreateFolderFromRemoteCloudServer:;
end;

global
procedure CheckServerMigrationStatus(string sid,var string servername,var Integer stat)
begin
  record RemoteCloudServerVc RCSr;

  stat = 0;
  RCSr.UUID = StringToUUID(sid);
  if (ReadFirstMain(RCSr,1,true)) then begin
    if (RCSr.MigrationFlag==1) then begin
      stat = 1;
      servername = RCSr.Name;
    end;
  end;

  return;
end;

global
updating procedure DoStoreMigrationServerCustomer(string sid,string email,string name,var Integer stat)
begin
  record RemoteCloudServerVc RCSr,oldRCSr;
  record CUVc CUr;
  string 255 tstr;

  stat = 0;
  RCSr.UUID = StringToUUID(sid);
  if (ReadFirstMain(RCSr,1,true)) then begin
    if (RCSr.MigrationFlag==1) then begin
      RecordNew(CUr);
      GetNextCustNr(tstr);
      CUr.Code = tstr;
      CUr.eMail = email;
      CUr.Name = name;
      if (RecordStore(CUr,false)) then begin
        RecordCopy(oldRCSr,RCSr);
        RCSr.CUCode = tstr;
        if (RecordUpdate(oldRCSr,RCSr,true)==0) then begin
          stat = 1;
        end;
      end;
    end;
  end;

  return;
end;

global
procedure NextHostPoolNodeName(var string node_name)
begin
  Integer node_no;
  record CloudNodeVc CNr;
  record CloudSettingsBlock CSb;
  string 255 node_basename;

  BlockLoad(CSb);
  node_basename = "NODE-" & StringFromSet(10005,CSb.HostingPartner) & "-";

LNextHostPoolNodeName_Next:;
  node_no = node_no + 1;
  CNr.Code = node_basename & node_no;
  if (ReadFirstMain(CNr,1,true)) then begin goto LNextHostPoolNodeName_Next; end;
  node_name = node_basename & node_no;

  return;
end;

global
procedure GetRecordsInIndex(string vc,string idx,var Integer cnt)
begin
  cnt = RecordsInIndex(vc,idx);
  return;
end;

global
procedure TerminateHostsInPool(Integer hptype,string idx,Integer aterminate_cnt)
begin
  record CloudNodeVc CNr;
  Boolean foundf;
  Integer terminate_res,terminate_cnt;
  string 255 msg;

  terminate_cnt = aterminate_cnt;
  foundf = true;
  while (LoopKey(idx,CNr,1,foundf)) begin
    if (CNr.CurrentState==kCloudNodeStateTerminating) then begin
      goto LTerminateHostsInPool;
    end;
  end;

  RecordClear(CNr);
  ResetLoop(CNr);
  LogText(0,"Terminating " & terminate_cnt & " hosts from pool " & StringFromSet(20003,hptype) & " (index " & idx & ")");

  foundf = true;
  while (LoopKey(idx,CNr,1,foundf)) begin
    switch (CNr.CurrentState) begin
      case kCloudNodeStateCreating:     goto LTerminateHostsInPool_SkipNode;
      case kCloudNodeStateStopping:     goto LTerminateHostsInPool_SkipNode;
      case kCloudNodeStateStarting:     goto LTerminateHostsInPool_SkipNode;
      case kCloudNodeStateMoving:       goto LTerminateHostsInPool_SkipNode;
      case kCloudNodeStateModifying:    goto LTerminateHostsInPool_SkipNode;
    end;

    if (blank(CNr.AmazonInstanceId)) then begin goto LTerminateHostsInPool_SkipNode; end;

goto LTerminateHostsInPool; //Temporarily disabled 160829
    terminate_res = TerminateHost(CNr,true,msg);
    if (terminate_res>0) then begin
      if (terminate_res!=8) then begin
        SetCloudControllerStatus(kJobStatusError,"Error while cleaning host pool " & StringFromSet(20003,hptype) & ": " & msg);
      end;
    end else begin
      terminate_cnt = terminate_cnt - 1;
      if (terminate_cnt==0) then begin foundf = false; end;
    end;
LTerminateHostsInPool_SkipNode:;
  end;
LTerminateHostsInPool:;
  return;
end;


procedure TreatHostPool(Integer hptype)
begin
  record RcVc RepSpec;
  record HostingConfigurationVc HCr;
  record Attach2Vc AT2r;
  record ASPHostPoolBlock HPSb;
  Integer cur_pool_sz,pool_sz,disk_sz,ssdflag;
  string 255 instance_type,idx,node_name;
  LongInt hc;
  Integer max_capacity;
  Integer terminate_cnt;

  max_capacity = 1;
  BlockLoad(HPSb);
  switch (hptype) begin
    case kHostPoolTypeShared:
      idx = "ActForAutoAllocShared";
      pool_sz = HPSb.SharedPoolSize;
      instance_type = HPSb.SharedAmazonInstanceType;
      disk_sz = HPSb.SharedDiskSize;
      ssdflag = HPSb.SharedSSDFlag;
      hc = HPSb.SharedHostingConfig;
      max_capacity = HPSb.SharedPoolMaxCapacity;
    case kHostPoolTypeSmall:
      idx = "ActForAutoAllocSmall";
      pool_sz = HPSb.SmallPoolSize;
      instance_type = HPSb.SmallAmazonInstanceType;
      disk_sz = HPSb.SmallDiskSize;
      ssdflag = HPSb.SmallSSDFlag;
      hc = HPSb.SmallHostingConfig;
    case kHostPoolTypeMedium:
      idx = "ActForAutoAllocMed";
      pool_sz = HPSb.MedPoolSize;
      instance_type = HPSb.MedAmazonInstanceType;
      disk_sz = HPSb.MedDiskSize;
      ssdflag = HPSb.MedSSDFlag;
      hc = HPSb.MedHostingConfig;
    case kHostPoolTypeLarge:
      idx = "ActForAutoAllocLarge";
      pool_sz = HPSb.LargePoolSize;
      instance_type = HPSb.LargeAmazonInstanceType;
      disk_sz = HPSb.LargeDiskSize;
      ssdflag = HPSb.LargeSSDFlag;
      hc = HPSb.LargeHostingConfig;
    otherwise
      LogText(0,"ERROR: Unknown host pool type: " & hptype);
      goto LTreatHostPool;
  end;

  HCr.SerNr = hc;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    if (hc!=-1) then begin
      LogText(0,"ERROR: Hosting configuration with SerNr=" & HCr.SerNr & " not found");
    end;
    goto LTreatHostPool;
  end;

  qupdating.GetRecordsInIndex("CloudNodeVc",idx,cur_pool_sz);

  if (pool_sz<cur_pool_sz) then begin
    qupdating.TerminateHostsInPool(hptype,idx,cur_pool_sz-pool_sz);
  end;

  if ((pool_sz>0) and (cur_pool_sz<pool_sz)) then begin
    LogText(0,"Launching " & pool_sz-cur_pool_sz & " hosts to pool " & StringFromSet(20003,hptype));
LTreatHostPool_Next:;
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LTreatHostPool; end;
    qupdating.NextHostPoolNodeName(node_name);

    RepSpec.f1 = node_name;
    RepSpec.f2 = instance_type;
    RepSpec.long1 = disk_sz;
    RepSpec.flags[0] = ssdflag;
    RepSpec.long2 = max_capacity;

    LogText(0,"Launching host " & node_name & " for pool " & StringFromSet(20003,hptype));
    LaunchHost(HCr,RepSpec,hptype);
    cur_pool_sz = cur_pool_sz + 1;
    if (cur_pool_sz<pool_sz) then begin goto LTreatHostPool_Next; end;
  end;

LTreatHostPool:;
  return;
end;

global
procedure ASPCheckHostPoolsTask(string args)
begin

  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPCheckHostPoolsTask; end;

  LogText(0,"Checking host pools");

  TreatHostPool(kHostPoolTypeShared);
  TreatHostPool(kHostPoolTypeSmall);
  TreatHostPool(kHostPoolTypeMedium);
  TreatHostPool(kHostPoolTypeLarge);

LASPCheckHostPoolsTask:;
  return;
end;

function Boolean IsVersionInUse(string vercode)
begin
  Boolean res;
  record LocalCloudServerVc LCSr;
  record CloudSettingsBlock CSb;

  res = true;

  if (ShouldDownloadVersion(vercode)) then begin goto LIsVersionInUse; end;
  if (IsDownloadingVersion(vercode)) then begin goto LIsVersionInUse; end;

  LCSr.HansaVersion = vercode;
  if (ReadFirstKey("HansaVersion",LCSr,1,true)) then begin goto LIsVersionInUse; end;

  LCSr.NewHansaVersion = vercode;
  if (ReadFirstKey("NewHansaVersion",LCSr,1,true)) then begin goto LIsVersionInUse; end;

  LCSr.OldHansaVersion = vercode;
  if (ReadFirstKey("OldHansaVersion",LCSr,1,true)) then begin goto LIsVersionInUse; end;

  BlockLoad(CSb);
  if (CSb.HansaVersion==vercode) then begin goto LIsVersionInUse; end;
  if (CSb.NewHansaVersion==vercode) then begin goto LIsVersionInUse; end;

  res = false;

LIsVersionInUse:;
  IsVersionInUse = res;
  return;
end;

global
procedure ASPCleanVersionsTask(string args)
begin
  LongInt pos;
  LongInt filecnt;
  string 255 foldername;
  LongInt i;


  i = 0;
  LogText(0,"Cleaning out unused versions");
  filecnt = CountDirectoriesInDir(VersionsFolder);
  for (pos = 0; pos<filecnt; pos = pos + 1) begin
    if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LASPCleanVersionsTask; end;
    foldername = GetDirectoryNameInDir(VersionsFolder,pos);
    if (nonblank(foldername) and (foldername!=".") and (foldername!="..") and right(foldername,9)!=".download") then begin
      if (IsVersionInUse(foldername)==false) then begin
        LogText(0,"Removing unused version folder " & VersionsFolder & foldername);
        DeleteFolder(VersionsFolder & foldername);
        i = i + 1;
      end else begin
        LogText2(0,"Keeping version folder " & VersionsFolder & foldername,kVerbosityDebug);
      end;
    end;
  end;

  LogText(0,"Finished, removed " & i & " version folders");

LASPCleanVersionsTask:;
  return;
end;

global
updating procedure ResolveNodeConflict(uuid rcsid,string corrcn,string incorrcn)
begin
  record RemoteCloudServerVc RCSr,OldRCSr;
  record CloudNodeVc CNr,CN2r;
  string 255 url,remotefname;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"The server " & RCSName(RCSr) & " doesn't exist, can't resolve node conflict ");
    goto LResolveNodeConflict;
  end;

  CNr.Code = corrcn;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"The node " & CNr.Code & " doesn't exist, can't resolve node conflict ");
    goto LResolveNodeConflict;
  end;

  CN2r.Code = incorrcn;
  if (ReadFirstMain(CN2r,1,true)==false) then begin
    SetCloudControllerStatus(kJobStatusError,"The node " & CN2r.Code & " doesn't exist, can't resolve node conflict ");
    goto LResolveNodeConflict;
  end;

  url = NodeURL(CN2r);
  if (blank(url)) then begin goto LResolveNodeConflict; end;

  RecordCopy(OldRCSr,RCSr);
  RCSr.Controller = CNr.Code;
  RecordUpdate(OldRCSr,RCSr,true);

  stat = CallService(url).ForceDeleteLCS(rcsid);
  if (TreatServiceError(stat,url,"ForceDeleteLCS")) then begin
    SetCloudControllerStatus(kJobStatusError,"Failed resolving node conflict, " & CN2r.Code & " didn't respond");
    LogText(0,"Failed resolving node conflict, " & CN2r.Code & " didn't respond");
    goto LResolveNodeConflict;
  end;

  SetCloudControllerStatus(kJobStatusRunning,"Resolved node conflict for server " & RCSName(RCSr) & ", removing it from node " & CN2r.Code);
  LogText(0,"Resolved node conflict for server " & RCSName(RCSr) & ", removing it from node " & CN2r.Code);

LResolveNodeConflict:;
  return;
end;

global
procedure CountConnections(uuid server_uuid,var LongInt cnt)
begin
  record RemoteCloudServerVc RCSr;
  record LocalCloudServerVc LCSr;
  string 255 url;
  LongInt stat;
  
  cnt = 0;

  RCSr.UUID = server_uuid;
  if (ReadFirstMain(RCSr,1,true)==false) then begin
    goto LCountConnections;
  end;
  url = RcsNodeURL(RCSr);
  if (blank(url)) then begin goto LCountConnections; end;
  if (RCSr.Closed!=0) then begin goto LCountConnections; end;
  if ((RCSr.CurrentStatus!=kStatusRunning) and
      (RCSr.CurrentStatus!=kStatusMaintenance) and
      (RCSr.CurrentStatus!=kStatusRunningPendingStop) and
      (RCSr.CurrentStatus!=kStatusConfigInError) and
      (RCSr.CurrentStatus!=kStatusRunningTest)) then begin
    SetCloudControllerStatus(kJobStatusError,"Skipping counting connections on " & RCSName(RCSr));
    goto LCountConnections;
  end;
  
  LCSr.UUID = RCSr.UUID;
  stat = CallService(url).ActiveServerUsers(LCSr,false,cnt);
  if (TreatServiceError(stat,url,"ActiveServerUsers")) then begin
    LogText(0,"Failed counting active server users on " & RCSName(RCSr));
    SetCloudControllerStatus(kJobStatusError,"Failed counting connections " & RCSName(RCSr));
  end;
                
LCountConnections:;
  return;
end;

global
procedure ExtractArchiveOnLCS(string remotefname)
begin
  string 255 newname;
  LogText(0,"Unarchiving file " & remotefname);
                
  switch (right(remotefname,3)) begin
    case "bz2":
      newname = left(remotefname,len(remotefname)-4);
      RunShellScript("bunzip2 -f " & remotefname & " && touch " & newname & " &");
    case ".gz":
      newname = left(remotefname,len(remotefname)-4);
      RunShellScript("gunzip " & remotefname & " && touch " & newname & " &");
    case "zip":
      RunShellScript("unzip -qqo " & remotefname & " -d $(dirname " & remotefname & ") &");
    otherwise
      LogText(0,"ERROR: Don't know how to extract " & remotefname);
  end;
end;

global
procedure CreateArchiveOnLCS(string remotefname,Boolean dirf)
begin
  LogText(0,"Creating archive of " & remotefname);

  RunShellScript("cd $(dirname " & remotefname & ") && zip -r3 -qq $(basename " & remotefname & ").zip $(basename " & remotefname & ") &");
end;

global
procedure ExtractArchiveOnRemoteCloudServer(uuid rcsid,string fname,string path)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname,fpath;
  LongInt stat;
  
  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    fpath = path;
    if (fpath=="%backup%") then begin fpath = RCSr.BackupFolder; end;
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LExtractArchiveOnRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Unarchiving file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Unarchiving file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).ExtractArchiveOnLCS(remotefname);
      if (TreatServiceError(stat,url,"DeleteFileOnLCS")) then begin
        LogText(0,"Failed to unarchive file " & fpath & "/" & fname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LExtractArchiveOnRemoteCloudServer;
      end;
    end;
  end;
  
LExtractArchiveOnRemoteCloudServer:;
  return;
end;

global
procedure DuplicateFileOnLCS(string remotefname)
begin
  string 255 newname;
                
  newname = DetermineNextName(remotefname,false);
  LogText(0,"Duplicating file " & remotefname & " to " & BaseName(newname));
  CopyFile(remotefname,newname);
  return;
end;

global
procedure DuplicateFileOnRemoteCloudServer(uuid rcsid,string fname,string fpath)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LDuplicateFileOnRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Duplicating file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Duplicating file " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).DuplicateFileOnLCS(remotefname);
      if (TreatServiceError(stat,url,"DeleteFileOnLCS")) then begin
        LogText(0,"Failed to duplicate file " & fpath & "/" & fname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LDuplicateFileOnRemoteCloudServer;
      end;
    end;
  end;

LDuplicateFileOnRemoteCloudServer:;
  return;
end;

global
procedure GetRecordCountForLCS(UUID lcsid,var area areccnt)
begin
  record LocalCloudServerVc LCSr;
  Integer sleeps;
  string 255 outfile;


  LCSr.UUID = lcsid;
  if (ReadFirstMain(LCSr,1,true)) then begin
    outfile = LCSr.DataFolder & "/RecCntRn.TXT";
    Delete_File(outfile);
    CreateFolderHierarchy(EnablerActionsFolder(LCSr) & "/");
    CreateFile(EnablerActionsFolder(LCSr) & "/EnRecCntRn");
    CloseFile;

    while (FileExists(outfile)==false) begin
      Sleep(1);
      sleeps = sleeps + 1;
      if (sleeps>20) then begin
        goto LGetRecordCountForLCS;
      end;
    end;
    Sleep(1);
    AddFileToArea(outfile,areccnt,false);
    //Delete_File(outfile);
  end;

LGetRecordCountForLCS:;
end;

global
procedure CreateArchiveOnRemoteCloudServer(uuid rcsid,string fname,string path,Boolean dirf)
begin
  record RemoteCloudServerVc RCSr;
  Boolean testf;
  string 255 url,remotefname,fpath;
  LongInt stat;

  RCSr.UUID = rcsid;
  if (ReadFirstMain(RCSr,1,true)) then begin
    fpath = path;
    if (fpath=="%backup%") then begin fpath = RCSr.BackupFolder; end;
    testf = true;
    if (testf) then begin
      url = RcsNodeURL(RCSr);
      if (blank(url)) then begin goto LCreateArchiveOnRemoteCloudServer; end;
      remotefname = RCSr.DataFolder & "/" & fpath & "/" & fname;
      SetCloudControllerStatus(kJobStatusRunning,"Archiving " & remotefname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      LogText(0,"Creating archive file " & remotefname & ".zip from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
      stat = CallService(url).CreateArchiveOnLCS(remotefname,dirf);
      if (TreatServiceError(stat,url,"CreateFileOnLCS")) then begin
        LogText(0,"Failed to archive file " & fpath & "/" & fname & " from server " & RCSName(RCSr) & " on node " & RCSr.Controller);
        goto LCreateArchiveOnRemoteCloudServer;
      end;
    end;
  end;

LCreateArchiveOnRemoteCloudServer:;
  return;
end;

global
updating procedure CNUpdateHMCUCode(record LocalCloudServerVc LCSr,string cucode,Integer regincountry,Longint contract)
begin
  record LocalCloudServerVc oldLCSr;

  if (ReadFirstMain(LCSr,1,true)) then begin
    RecordCopy(oldLCSr,LCSr);
    LCSr.HMCUCode = cucode;
    LCSr.Contract = contract;
    LCSr.HMRegInCountry = regincountry;
    RecordUpdate(oldLCSr,LCSr,true);
  end;

  return;
end;

function Boolean GetLastLCSBackup(record LocalCloudServerVc LCSr,var string backupfile)
begin
  Boolean res;
  string 255 wd,filename;
  Integer cnt,i;

  wd = LCSr.DataFolder;
  if (right(wd,1)!="/") then begin
    wd = wd & "/";
  end;
  wd = wd & "Backup";
  cnt = CountFilesInDir(wd);
  for (i=0;i<cnt;i=i+1) begin
    filename = GetFileNameInDir(wd,i);
    if (right(filename,4)==".TXT" and left(filename,2)=="TB") then begin
      if (filename>backupfile or blank(backupfile)) then begin
        backupfile = wd & "/" & filename;
        res = true;
      end;
    end;
  end;

  if (!res) then begin
    if (FileExists(LCSr.DataFolder & "/TBSETUP.TXT")) then begin
      backupfile = LCSr.DataFolder & "/TBSETUP.TXT";
      res = true;
    end;
  end;

  GetLastLCSBackup = res;
  return;
end;

global
procedure GetHMCustCodeFromBackupTask(string args)
begin
  record LocalCloudServerVc LCSr;
  record InternetEnablerBlock IEb;
  record CYBlock CYb;
  string 255 backupfile;
  Date tt;

  if (TestEnablerFile("EnSkipHMCust")) then begin
    goto LGetHMCustCodeFromBackupTask;
  end;
  if (GetGlobalBoolean("ASPIdleTasksStopped")==true) then begin goto LGetHMCustCodeFromBackupTask; end;

  SetGlobalBoolean("ASPGetHMCustCodeFromBackups",true);

  while (LoopMain(LCSr,1,true)) begin
    if (LCSr.Closed==0) then begin
      //if (blank(LCSr.HMCUCode) or LCSr.Contract==-1) then begin
        if (GetLastLCSBackup(LCSr,backupfile)) then begin
          if (FileExists(backupfile)) then begin
            ReadCompanyInfoBlocksFromTB(backupfile,IEb,CYb);
            if (nonblank(IEb.CustomerCode) and (LCSr.Contract!=IEb.Contract or LCSr.HMCUCode!=IEb.CustomerCode)) then begin
              queued.CNUpdateHMCUCode(LCSr,IEb.CustomerCode,IEb.RegInCountry,IEb.Contract);
            end;
          end;
        end;
      //end;
    end;
  end;

  SetGlobalBoolean("ASPGetHMCustCodeFromBackups",false);


  tt = CurrentDate;
  if (CurrentTime>StringToTime("00:05:00")) then begin
    tt = AddDay(CurrentDate,1);
  end;
  RemoveTask("GetHMCustCodeFromBackupTask");
  NewTimedTask2("GetHMCustCodeFromBackupTask","GetHMCustCodeFromBackupTask","GetHMCustCodeFromBackupTask","",tt,"00:05:00","","");

LGetHMCustCodeFromBackupTask:;
  return;
end;

function Boolean TestPortIsOpen(array string portarr,LongInt portno)
begin
  Boolean res;
  LongInt l,pos;
  string 255 fromport,toport;

  for (l = 0; l<portarr.length; l = l + 1) begin
    pos = -1;
    GetNextSubstring(portarr[l],pos,"-",fromport);
    GetNextSubstring(portarr[l],pos,"-",toport);
    if (blank(toport)) then begin
      if (StringToLongInt(fromport)==portno) then begin
        res = true;
        goto LTestPortIsOpen;
      end;
    end else begin
      if ((portno>=StringToLongInt(fromport)) and (portno<=StringToLongInt(toport))) then begin
        res = true;
        goto LTestPortIsOpen;
      end;
    end;
  end;

LTestPortIsOpen:;
  TestPortIsOpen = res;
  return;
end;

procedure AddToPortVecIfNeeded(LongInt portno,array string tcparr,var vector string tcpvec,var Boolean changef)
begin
  if (portno>0) then begin
    if (TestPortIsOpen(tcparr,portno)==false) then begin
      tcpvec[portno] = portno;
      changef = true;
    end;
  end;
  return;
end;

global
procedure OpenPortsForServer(record RemoteCloudServerVc RCSr)
begin
  record CloudNodeVc CNr;
  record HostingConfigurationVc HCr;
  array string 255 tcparr,udparr;
  vector string 255 tcpvec,udpvec;
  Boolean testf,changef;

  CNr.Code = RCSr.Controller;
  if (ReadFirstMain(CNr,1,true)==false) then begin
    CNr.Code = RCSr.NewController;
    if (ReadFirstMain(CNr,1,true)==false) then begin
      goto LOpenPortsForServer;
    end;
  end;

  HCr.SerNr = CNr.HostingConfig;
  if (ReadFirstMain(HCr,1,true)==false) then begin
    goto LOpenPortsForServer;
  end;

  if (HCr.Closed!=0 or HCr.HostingType!=kHostingTypeAmazon) then begin
    goto LOpenPortsForServer;
  end;
  if (blank(HCr.AmazonAccessKeyID) or blank(HCr.AmazonSecretAccessKey)) then begin
    LogText(0,"ERROR: Couldn't open ports for server " & RCSName(RCSr) & " because the hosting configuration " & HCr.SerNr & " doesn't have the Amazon credentials specified");
    goto LOpenPortsForServer;
  end;

  testf = AmazonFirewallGetOpenPorts(HCr,CNr.Code,tcparr,udparr);
  if (testf==false) then begin
    LogText(0,"ERROR: Couldn't open ports for server " & RCSName(RCSr) & " because current firewall configuration couldn't be read");
// TODO: Schedule retry three times
// TODO: Add error to error LogText
// TODO: Add watchpoint
    goto LOpenPortsForServer;
  end;

  AddToPortVecIfNeeded(RCSr.Port,tcparr,tcpvec,changef);
  AddToPortVecIfNeeded(RCSr.HTTPPort,tcparr,tcpvec,changef);
  AddToPortVecIfNeeded(RCSr.HTTPSPort,tcparr,tcpvec,changef);
  AddToPortVecIfNeeded(RCSr.MaintPort,tcparr,tcpvec,changef);

  if (changef) then begin
    AmazonFirewallOpenPorts(HCr,CNr.Code,tcpvec,udpvec);
  end;

LOpenPortsForServer:;
  return;
end;
