external function roundmode DefaultRoundMode();
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure SpecialRateCalc(val,val,val,var val);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);

external procedure DanTRSumup(var record DanTRVc);

global
procedure DanTRVc_PasteCurncy(var record DanTRVc DanTRp,Integer rownr)
BEGIN
  Integer res;
  row DanTRVc DanTRrr;
  string 20 curncy;
  val frrate,torate1,torate2,baserate1,baserate2;
  Date td;

  MatRowGet(DanTRp,rownr,DanTRrr);
  td = DanTRrr.RowTransDate;
  if (blankdate(td)) then begin
    td = DanTRp.TransDate;
  end;
  curncy = DanTRrr.Curncy;
  GetFullCurncyRate(curncy,td,frrate,torate1,torate2,baserate1,baserate2);
  DanTRrr.Curncy = curncy;
  DanTRrr.FrRate = frrate;
  DanTRrr.ToRateB1 = torate1;
  DanTRrr.ToRateB2 = torate2;
  DanTRrr.BaseRate1 = baserate1;
  DanTRrr.BaseRate2 = baserate2;
  MatRowPut(DanTRp,rownr,DanTRrr);
  DanTRSumup(DanTRp);
  RETURN;
END;

global
procedure DanTRVc_PasteTransDate(var record DanTRVc DanTRp,Integer rownr)
BEGIN
  Integer i,rwcnt;
  row DanTRVc DanTRrw;
  
  if (rownr>=0) then begin
    DanTRVc_PasteCurncy(DanTRp,rownr);
  end else begin
    rwcnt = MatRowCnt(DanTRp);
    for (i=0;i<rwcnt;i=i+1) begin
      DanTRVc_PasteCurncy(DanTRp,i);
    end;
  end;
  RETURN;
END;

global
procedure DANUpdateCurDebValRows(var row DanTRVc DanTRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  if (//(DanTRrp.DebVal==0) and  no check here
      ((DanTRrp.ToRateB1!=0) or (DanTRrp.ToRateB2!=0))) then begin
    sv = MulRateToBase1(DanTRrp.Curncy,DanTRrp.CurDebVal,DanTRrp.FrRate,DanTRrp.ToRateB1,DanTRrp.ToRateB2,DanTRrp.BaseRate1,DanTRrp.BaseRate2,DefaultCurRoundOff);
    DanTRrp.DebVal = sv;
    SpecialRateCalc(sv,DanTRrp.BaseRate1,DanTRrp.BaseRate2,sv);
    sv = Round(sv,DefaultRoundMode);
    DanTRrp.DebVal2 = sv;
  end;
  if ((DanTRrp.DebVal!=0) and 
      ((DanTRrp.ToRateB1==0) and (DanTRrp.ToRateB2==0))) then begin  
    tor1 = blankval;
    tor2 = blankval;
    if (DanTRrp.FrRate==0) then begin // Old Currency Style 
      sv = DanTRrp.DebVal*100;
      tor1 = sv/DanTRrp.CurDebVal;
      tor1 = Round(tor1,DefaultRoundMode);
    end else begin
      GetFullCurncyRate(DanTRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = DanTRrp.DebVal/DanTRrp.CurDebVal;
      sv = sv*DanTRrp.FrRate;
      SpecialRateCalc(sv,DanTRrp.BaseRate1,DanTRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin // Only one is filled at this moment 
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    DanTRrp.ToRateB1 = tor1;
    DanTRrp.ToRateB2 = tor2;
  end;
  if (DanTRrp.CredVal==0) then begin DanTRrp.CredVal = blankval; end;
  if (DanTRrp.DebVal==0) then begin DanTRrp.DebVal = blankval; end;
  RETURN;
END;

procedure DANUpdateCurCredValRows(var row DanTRVc DanTRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  if (//(DanTRrp.CredVal==0) and 
      ((DanTRrp.ToRateB1!=0) or (DanTRrp.ToRateB2!=0))) then begin
    sv = MulRateToBase1(DanTRrp.Curncy,DanTRrp.CurCredVal,DanTRrp.FrRate,DanTRrp.ToRateB1,DanTRrp.ToRateB2,DanTRrp.BaseRate1,DanTRrp.BaseRate2,DefaultCurRoundOff);
    DanTRrp.CredVal = sv;
    SpecialRateCalc(sv,DanTRrp.BaseRate1,DanTRrp.BaseRate2,sv);
    sv = Round(sv,DefaultRoundMode);
    DanTRrp.CredVal2 = sv;
  end;
  if ((DanTRrp.CredVal!=0) and 
      ((DanTRrp.ToRateB1==0) and (DanTRrp.ToRateB2==0))) then begin  
    tor1 = blankval;
    tor2 = blankval;
    if (DanTRrp.FrRate==0) then begin // Old Currency Style 
      sv = DanTRrp.CredVal*100;
      tor1 = sv/DanTRrp.CurCredVal;
      tor1 = Round(tor1,DefaultRoundMode);
    end else begin
      GetFullCurncyRate(DanTRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = DanTRrp.CredVal/DanTRrp.CurCredVal;
      sv = sv*DanTRrp.FrRate;
      SpecialRateCalc(sv,DanTRrp.BaseRate1,DanTRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin // Only one is filled at this moment 
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    DanTRrp.ToRateB1 = tor1;
    DanTRrp.ToRateB2 = tor2;
  end;
  if (DanTRrp.CredVal==0) then begin DanTRrp.CredVal = blankval; end;
  if (DanTRrp.DebVal==0) then begin DanTRrp.DebVal = blankval; end;
  RETURN;
END;

global
procedure DanTRVc_PasteCurDebVal(var record DanTRVc DanTRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  row DanTRVc DanTRrrw;
  val t;

  BlockLoad(CompYear);
  MatRowGet(DanTRp,rownr,DanTRrrw);
  DANUpdateCurDebValRows(DanTRrrw,DanTRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
//    res = Norm2Cont(DanTRrrw.AccNumber,DanTRrrw.DebVal,t);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  MatRowPut(DanTRp,rownr,DanTRrrw);
  DanTRSumup(DanTRp);
  RETURN;
END;

global
procedure DanTRVc_PasteCurCredVal(var record DanTRVc DanTRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  row DanTRVc DanTRrrw;
  val t;

  BlockLoad(CompYear);
  MatRowGet(DanTRp,rownr,DanTRrrw);
  DANUpdateCurCredValRows(DanTRrrw,DanTRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
//    res = Norm2Cont(DanTRrrw.AccNumber,DanTRrrw,DanTRrr.CredVal);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  MatRowPut(DanTRp,rownr,DanTRrrw);
  DanTRSumup(DanTRp);
  RETURN;
END;
