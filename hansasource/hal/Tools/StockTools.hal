external function roundmode GetCostRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external function val DivRateToBase2(string,val,val,val,val,val,val,roundmode);
external procedure GetINPurchaseControlAcc(record INVc,var string,string,string,Integer);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function val FindCostPriceWA(Integer,record INVc,string);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function Boolean TestArtCode(string,string,record INVc);
external procedure ExpandStructure(record INVc,string,string,Integer,var val,var val,Boolean);
external procedure FindBatchBestBeforeDate(string,string,var Date);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure FindStockValue(string,string,var record ItemStatusVc);


global
function Boolean ShouldItemUpdateStock(string incode)
BEGIN
  record INVc INr;
  Boolean res;

  if (nonblank(incode)) then begin
    if (ReadFirstItemInclClosed(incode,INr,false,false)) then begin
      if ((INr.ItemType>0) and (INr.ItemType<3)) then begin res = true; end;
    end;
  end;
  ShouldItemUpdateStock = res;
  RETURN;
END;

global
function Boolean POSOffline_ShouldItemUpdateStock(string item,string location)
begin
  record INVc INr;
  record ArtUpdStockVc ArtUpdStockr;
  row ArtUpdStockVc ArtUpdStockrw;
  Integer i,rwcnt;
  Boolean res;
  record OffLineSetBlock OffLb;
  
  BlockLoad(OffLb);
  res = false;
  if (OffLb.POSSalesUpdStock==0) then begin
    goto LPOSOffline_ShouldItemUpdateStock;
  end;
  if (OffLb.POSSalesUpdStock==1) then begin
    res = true;
    goto LPOSOffline_ShouldItemUpdateStock;
  end;
  ArtUpdStockr.Location = location;
  if (ReadFirstMain(ArtUpdStockr,1,true)) then begin
    if (ArtUpdStockr.AllGroups==1) then begin
      res = true;
    end else begin
      if (ReadFirstItem(item,INr,false,false)) then begin
        if ((INr.ItemType==1) or (INr.ItemType==2)) then begin
          rwcnt = MatRowCnt(ArtUpdStockr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(ArtUpdStockr,i,ArtUpdStockrw);
            switch (ArtUpdStockrw.CodeType) begin
              case 0:
                if (INr.Group==ArtUpdStockrw.ItemGroup) then begin
                  res = true;
                  goto LPOSOffline_ShouldItemUpdateStock;
                end;
              case 1:
                if (SetInSet(INr.Code,ArtUpdStockrw.ItemGroup)) then begin
                  res = true;
                  goto LPOSOffline_ShouldItemUpdateStock;
                end;
            end;
          end;
        end;
      end;
    end;
  end;
LPOSOffline_ShouldItemUpdateStock:;  
  POSOffline_ShouldItemUpdateStock = res;
  RETURN;
END;

global
updating procedure UpdateInstock(string filename,string transnr,string ac,string location,Date transdat,val q,val o,val rsvrqp,val poq,val unokpoq,val q2,val prodord,val word,val wsheet)
BEGIN
  record ItemStatusVc ISr;
  record ItemStatusVc oldISr;
  Boolean found,deltest;
  string 10 loc2;
  Date bldat;
  val waprice;
  record TestItemStatusBlock TestISb;
  record INVc INr;
  Integer keys;
  
  BlockLoad(TestISb);


  if (ac==TestISb.ArtCode) then begin
    LogText(0,"filename " & chr(9) & filename & chr(9)  & " transnr " & chr(9) & transnr & chr(9) & " Instock " & chr(9) & q & chr(9) & " OrddOut " & chr(9) & o & chr(9) & " poq " & chr(9) & poq & chr(9)  & " unokpoq " & chr(9) & unokpoq & chr(9) & " location " & chr(9) & location & chr(9) & "rsvrqp" & chr(9) & rsvrqp & chr(9) & " transdat " & chr(9) & transdat);
  end;

  keys = 2;
  
  loc2 = location;
  ISr.Code = ac;
  if (ReadFirstItem(ac,INr,false,false)) then begin
    if (ac!=INr.Code) then begin
      ISr.Variety = right(ac,len(ac)-len(INr.Code));
      ISr.Code = INr.Code;
      keys = 3;
    end;
  end;
  ISr.Location = loc2;
  found = ReadFirstMain(ISr,keys,true);
  RecordCopy(oldISr,ISr);
  if (found==false) then begin
    ISr.Code = ac;
    if (nonblank(INr.Code)) then begin
      if (ac!=INr.Code) then begin
        ISr.Variety = right(ac,len(ac)-len(INr.Code));
        ISr.Code = INr.Code;
      end;
    end;
    ISr.Location = loc2;
    ISr.Instock = 0;
    ISr.UValue = 0;
    ISr.OrddOut = 0;
    ISr.POQty = 0;
    ISr.RsrvQty = 0;
    ISr.StockRsrvQty = 0;
    ISr.POUnOKQty = 0;
    ISr.InShipment = 0;
    ISr.Instock2 = 0;
    ISr.ProdOrd = 0;
    ISr.NoDataBefore = bldat;
    ISr.WOrd = 0;
    ISr.InWSheet = 0;
    ISr.WeighedAvPrice = 0;
  end;
  if (nonblankdate(ISr.NoDataBefore)) then begin
    if (transdat<ISr.NoDataBefore) then begin
      goto LUpdateInstock;
    end;
  end;
  ISr.Instock = ISr.Instock + q;
  ISr.Instock2 = ISr.Instock2 + q2;
LUpdateInstock:;
  ISr.OrddOut = ISr.OrddOut + o;
  ISr.RsrvQty = ISr.RsrvQty + rsvrqp;
//  ISr.StockRsrvQty = ISr.StockRsrvQty + rsvrqp; // Not in here, I think...
  ISr.POQty = ISr.POQty + poq;
  ISr.POUnOKQty = ISr.POUnOKQty + unokpoq;
  ISr.ProdOrd = ISr.ProdOrd + prodord;
  ISr.WOrd = ISr.WOrd + word;
  ISr.InWSheet = ISr.InWSheet + wsheet;
  ISr.WeighedAvPrice = waprice;
  if ((ISr.Instock==0) and
      (ISr.UValue==0) and
      (ISr.OrddOut==0) and
      (ISr.POQty==0) and
      (ISr.RsrvQty==0) and
      (ISr.StockRsrvQty==0) and
      (ISr.POUnOKQty==0) and
      (ISr.InShipment==0) and 
      (ISr.ProdOrd==0) and
      (ISr.WOrd==0) and
      (ISr.InWSheet==0)) then begin deltest = true; end;
  if (deltest==false) then begin
    if (found==false) then begin
      if (RecordStore(ISr,true)) then begin end;
    end else begin
      if (RecordUpdate(oldISr,ISr,false)==0) then begin end;
    end;
  end else begin
    if (found) then begin
      if (RecordUpdate(oldISr,ISr,false)==0) then begin end;
//      RecordDelete(ISr);
    end;
  end;

//  if (ac==TestISb.ArtCode) then begin
//    LogText(0,"result filename " & chr(9) & filename & chr(9)  & " transnr " & chr(9) & transnr & chr(9) & " ISr.Instock " & chr(9) & ISr.Instock & chr(9) & " ISr.OrddOut " & chr(9) & ISr.OrddOut & chr(9) & " ISr.POQty " & chr(9) & ISr.POQty & chr(9)  & " ISr.POUnOKQty " & chr(9) & ISr.POUnOKQty & chr(9) & " ISr.Location " & chr(9) & ISr.Location & chr(9) & "ISr.RsrvQty" & chr(9) & ISr.RsrvQty & chr(9) & "  " & chr(9) & "  ");
//  end;

/*  
  if (location!=";;;") then begin
    if (ac==TestISb.ArtCode) then begin
      //LogText(0,"filename " & chr(9) & filename & chr(9)  & " transnr " & chr(9) & transnr & chr(9) & " Instock " & chr(9) & q & chr(9) & " OrddOut " & chr(9) & o & chr(9) & " OrdSum " & chr(9) & ISr.OrddOut & chr(9) & " location " & chr(9) & location & chr(9) & " transdat " & chr(9) & transdat);
    end;
  end;
*/  

  if (location!=";;;") then begin
    UpdateInstock(filename,transnr,ac,";;;",transdat,q,o,rsvrqp,poq,unokpoq,q2,prodord,word,wsheet);
  end;
  RETURN;
END;

global
updating procedure StockTakeUpdateInstockRow(string ac,string location,Date transdat,val q,val q2)
BEGIN
/*
  record ItemStatusVc ISr;
  record ItemStatusVc oldISr;
  Boolean found,deltest;
  val t;
  
  ISr.Code = ac;
  ISr.Location = location;
  found = ReadFirstMain(ISr,2,true);
  if (found==false) then begin
    RecordNew(ISr);
    ISr.Code = ac;
    ISr.Location = location;
  end else begin
    RecordCopy(oldISr,ISr);
  end;
  ISr.Instock = -q;
  ISr.Instock2 = -q2;
  ISr.NoDataBefore = transdat;
  if (found==false) then begin
    if (RecordStore(ISr,true)) then begin end;
  end else begin
    if (RecordUpdate(oldISr,ISr,found)==0) then begin end;
  end;
  if (location!=";;;") then begin
    StockTakeUpdateInstockRow(ac,";;;",transdat,q,q2);
  end;
*/
  RETURN;
END;

global
updating procedure StockTakeUpdateInstock(record StockTakeVc StockTakep)
begin
/*
  Integer i,j,rwcnt;
  row StockTakeVc StockTakerw;
  row StockTakeVc StockTake2rw;
  
  if (StockTakep.SetStockValue!=0) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(StockTakep,i,StockTakerw);
//  StockTakeUpdateInstockRow
    end;
  end;
*/  
  return;
end;

global
updating procedure UpdateSerStock(string ac,string location,string sernr,val q,val pricep)
BEGIN
  record SerBalVc oldSerBalr;
  record SerBalVc SerBalr;
  Boolean found;
  val s;
  Date bb;

  if (blank(ac)) then begin goto LUpdateSerStock; end;
  if (blank(sernr)) then begin goto LUpdateSerStock; end;
  SerBalr.Item = ac;
  SerBalr.Serial = sernr;
  SerBalr.Location = location;
  found = ReadFirstMain(SerBalr,3,true);
  RecordCopy(oldSerBalr,SerBalr);
  if (found==false) then begin
    SerBalr.Item = ac;
    SerBalr.Location = location;
    SerBalr.Serial = sernr;
    SerBalr.Quant = 0;
    SerBalr.CostPrice = 0;
    FindBatchBestBeforeDate(SerBalr.Item,SerBalr.Serial,bb);
    SerBalr.NewBestBefore = bb;
  end;
  if (pricep!=0) then begin
    s = (SerBalr.Quant * SerBalr.CostPrice) + (q*pricep);
    SerBalr.CostPrice = s / (SerBalr.Quant + q);
  end;
  SerBalr.Quant = SerBalr.Quant + q;
  if (found==false) then begin
    if (RecordStore(SerBalr,false)) then begin end;//
  end else begin
    if (RecordUpdate(oldSerBalr,SerBalr,found)==0) then begin end;
  end;
LUpdateSerStock:;
  RETURN;
END;

global
updating procedure UpdateSerStockBestBefore(string ac,string sernr,Date bb)
BEGIN
  record SerBalVc oldSerBalr;
  record SerBalVc SerBalr;
  Boolean found;

  if (blank(ac)) then begin goto LUpdateSerStockBestBefore; end;
  if (blank(sernr)) then begin goto LUpdateSerStockBestBefore; end;
  SerBalr.Item = ac;
  SerBalr.Serial = sernr;
  found = ReadFirstKey("ItemSerial",SerBalr,2,true);
  if (SerBalr.NewBestBefore!=bb) then begin
    RecordCopy(oldSerBalr,SerBalr);
    SerBalr.NewBestBefore = bb;
    if (found) then begin
      if (RecordUpdate(oldSerBalr,SerBalr,found)==0) then begin end;
    end;
  end;
LUpdateSerStockBestBefore:;
  RETURN;
END;

global
updating procedure UpdateInternalSerStock(string ac,string location,string sernr,val q,val pricep)
BEGIN
  record IntSerBalVc oldIntSerBalr;
  record IntSerBalVc IntSerBalr;
  Boolean found;

  if (blank(sernr)) then begin goto LUpdateInternalSerStock; end;
  IntSerBalr.Item = ac;
  IntSerBalr.Serial = sernr;
  IntSerBalr.Location = location;
  found = ReadFirstMain(IntSerBalr,3,true);
  RecordCopy(oldIntSerBalr,IntSerBalr);
  if (found==false) then begin
    IntSerBalr.Item = ac;
    IntSerBalr.Location = location;
    IntSerBalr.Serial = sernr;
    IntSerBalr.Quant = 0;
    IntSerBalr.CostPrice = 0;
  end;
  IntSerBalr.Quant = IntSerBalr.Quant + q;
  IntSerBalr.CostPrice = IntSerBalr.CostPrice + pricep;
  if (found==false) then begin
    if (RecordStore(IntSerBalr,true)) then begin end;
  end else begin
    if (RecordUpdate(oldIntSerBalr,IntSerBalr,found)==0) then begin end;
  end;
LUpdateInternalSerStock:;
  RETURN;
END;

//Needed for OffhirerVc.... Or else you can do a Items in on same serial number 
//multiple times

global
function Boolean IntSerialNrAvail2(string item,string ser,string location,val q)
BEGIN
  record IntSerBalVc IntSBr;
  record MainStockBlock MainStockRec;
  Boolean res;
  
  IntSBr.Item = item;
  IntSBr.Serial = ser;
  if (blank(location)) then begin
    BlockLoad(MainStockRec);
    IntSBr.Location = MainStockRec.MainStock;
  end;
  if (ReadFirstKey("ItemSerial",IntSBr,2,true)) then begin
    if (IntSBr.Quant>=q) then begin 
      res = true; 
    end;
  end;
  IntSerialNrAvail2 = res;
  RETURN;
END;

global
function Boolean IntSerialNrAvail(string item,string ser,string location,val q)
BEGIN
  record IntSerBalVc IntSBr;
  record MainStockBlock MainStockRec;
  Boolean res;
  
  IntSBr.Item = item;
  IntSBr.Serial = ser;
  IntSBr.Location = location;
  if (blank(location)) then begin
    BlockLoad(MainStockRec);
    IntSBr.Location = MainStockRec.MainStock;
  end;
  if (ReadFirstMain(IntSBr,3,true)) then begin
    if (IntSBr.Quant>=q) then begin 
      res = true; 
    end;
  end;
  IntSerialNrAvail = res;
  RETURN;
END;

global
procedure SetPOFlags(record POVc POp,Boolean forceinvd)
begin
  Integer puf,inv,orderstockf;
  Integer i,rwcnt;
  row POVc POrw;
  val shipsum,invsum,ordsum;
  record MainStockBlock MSb;
  Integer InvBeforePU;
  
  puf = 1;
  inv = 1;
  orderstockf = 2;
  BlockLoad(MSb);
  InvBeforePU = POp.InvBeforePU;
  rwcnt = MatRowCnt(POp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (InvBeforePU==0) then begin
      if (POrw.Invd!=POrw.Shipd2) then begin orderstockf = 0; end;
    end else begin
      orderstockf = 0;
    end;
    if (POrw.Quant>POrw.Shipd2) then begin puf = 0; end;
    if (POrw.Shipd2>POrw.Invd) then begin inv = 0; end;
    shipsum = shipsum + POrw.Shipd2;
    invsum = invsum + POrw.Invd;
    ordsum = ordsum + POrw.Quant;
  end;  
  if ((shipsum==0) and (invsum==0)) then begin 
    puf = 0; 
    inv = 0; 
  end;
  if (forceinvd) then begin inv = 1; end;
  switch (puf) begin
    case 0: POp.PUFlag = 0;
    case 1: POp.PUFlag = 1;
  end;
  switch (inv) begin
    case 0: POp.PIFlag = 0;
    case 1: POp.PIFlag = 1;
  end;
  if (POp.Closed==1) then begin
    POp.PUFlag = 1;
    POp.PIFlag = 1;
  end;
  if (POp.PUFlag==0) then begin
    POp.OSFlag = 1;
  end else begin
    POp.OSFlag = 0;
  end;
  if (POp.PIFlag==0) then begin
    POp.InvFlag = 0;
  end else begin
    POp.InvFlag = 1;
  end;
  POp.OrderStockFlag = 0;
  if (ordsum>shipsum) then begin POp.OrderStockFlag = 1; end;
  if (ordsum>invsum) then begin POp.OrderStockFlag = 1; end;
  return;
end;
/*
global
function Boolean StringIsDate(string datstr)
BEGIN
  Integer slen,complen;
  Boolean res;
  Date td;
  record SysFormatBlock SFb;
  string 1 dateSep;
  
  BlockLoad(SFb);
  dateSep = SFb.dateSep;
  td = StringToDate(datstr);
  slen = len(datstr);
  if ((slen<4) or (slen>10)) then begin goto LStringIsDate; end;
  if ((GetDay(td)<1) or (GetDay(td)>31)) then begin goto LStringIsDate; end;
  if ((GetMonth(td)<1) or (GetMonth(td)>12)) then begin goto LStringIsDate; end;
  complen = 4; // 9911, minium nr of characters for a date
  if (SFb.century!=0) then begin complen = complen + 2; end;
  if (len(dateSep)>0) then begin complen = complen + 2; end;
  if ((SFb.leadZday!=0) or (GetDay(td)>9)) then begin complen = complen + 1; end;
  if ((SFb.leadZmonth!=0) or (GetMonth(td)>9)) then begin complen = complen + 1; end;
  if (slen!=complen) then begin goto LStringIsDate; end;
  res = true;
LStringIsDate:;
  StringIsDate = res;
  RETURN;
END;
*/
global
updating procedure UpdatePlanned(string artcode,string location,string filename,LongInt sernr,Date tdp,
                                 val qty,Integer rownr,val qty2,val totalcost,Boolean addf)
BEGIN
  record ItemHistVc IHr;
  record INVc INr;
  record ITVc ITr;
  record CostAccBlock CAb;
  Integer primary,queuecostmodel;
  val q,lqty;
  
  if (nonblankdate(tdp)) then begin
    if ((addf) and (qty!=0)) then begin
      BlockLoad(CAb);
      RecordNew(IHr);
      IHr.ArtCode = artcode;
      IHr.Variety = "";
      if (ReadFirstItem(artcode,INr,false,false)) then begin
        if (artcode!=INr.Code) then begin
          IHr.Variety = right(artcode,len(artcode)-len(INr.Code));
          IHr.ArtCode = INr.Code;
        end;
      end;

      IHr.Location = location;
      IHr.FileName = filename;
      IHr.TransNr = sernr;
      IHr.TransDate = tdp;
      IHr.FIFODate = tdp;
      IHr.StockAffectf = 0;
      IHr.Qty = qty;
      IHr.Qty2 = qty2;
      IHr.Row = rownr;
      IHr.StockAffectf = 0;
      IHr.RemQty = blankval;
      IHr.Source = -1;
      IHr.TotCostPrice = totalcost;
      IHr.RemCostPrice = blankval;
      IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");    
      q = IHr.Qty;
      lqty = qty;
      switch (filename) begin
        case "Fut2ProdOrderInVc":
        case "Fut2ProdOrderOutVc":
        case "Fut2ProdInVc":
        case "Fut2ProdOutVc":
        case "Fut1POVc":
        case "Fut3ORVc":
          if (q<0) then begin q= -q; end;
          if (lqty<0) then begin lqty= -lqty; end;
      end;      
      
      IHr.WATotCost = q*INr.WeighedAvPrice;
      IHr.WATotCostPerLoc = q*FindCostPriceWA(1,INr,location);
      IHr.CPTotCost = q*INr.InPrice;
      IHr.BPTotCost = q*FindCostPriceBasePrice(CAb,INr,ITr);

      ITr.Code = INr.Group;
      if (ReadFirstMain(ITr,1,true)) then begin
      end;
      GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
/*      
      switch (primary) begin
        case 1:
          IHr.CPTotCost = (totalcost/lqty)*(q);
  //        IHr.CPTotCostPerLoc = (totalcost/lqty)*(q);
        case 2:
          IHr.BPTotCost = (totalcost/lqty)*(q);
  //        IHr.BPTotCostPerLoc = (totalcost/lqty)*(q);
        case 3:
          IHr.WATotCost = (totalcost/lqty)*(q);
          IHr.WATotCostPerLoc = (totalcost/lqty)*(q);
      end;
*/
      if (RecordStore(IHr,true)) then begin end;;
    end else begin
      IHr.FileName = filename;
      IHr.TransNr = sernr;
      IHr.Row = rownr;
      if (ReadFirstKey("FNTransNr",IHr,3,true)) then begin
        RecordDelete(IHr);
      end;
    end;
  end;
  RETURN;
END;

global
updating procedure UpdatePOPlanned(record POVc POp,string location,Boolean addf)
BEGIN
  row POVc POrw;
  Integer rwcnt,i;
  Date theplandat,plandat,blankd;
  val plndv;
  
  if (StringIsDate(POp.PlanShip)) then begin
    theplandat = StringToDate(POp.PlanShip);
  end else begin
    theplandat = blankd;
  end;
  rwcnt = MatRowCnt(POp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (POrw.stp==1 and POrw.OrderType!=kOrderTypeDropShip) then begin
      plndv = POrw.Quant - POrw.Shipd2;//when POrw.Shipd1 used: make PO 20 , make GR, do not ok, gone from Item Hist
      plandat = theplandat;
      if (nonblank(POrw.PlanShipRow)) then begin
        if (StringIsDate(POrw.PlanShipRow)) then begin
          plandat = StringToDate(POrw.PlanShipRow);
        end;
      end;  
      UpdatePlanned(POrw.ArtCode,location,"Fut1POVc",POp.SerNr,plandat,plndv,i,plndv,POrw.Sum,addf);
    end;
  end;
  RETURN;
END;

global
updating procedure UpdatePOOut(record POVc POp,Boolean addf,Boolean importf)
BEGIN
  row POVc POrw;
  Integer i,rwcnt;
  val t,t2,t3;
  string 255 blanks;
  record MainStockBlock MainStockRec;
  string 255 location;
  transaction string 255 gRuniningMaint;
  
  switch (POp.OrderType) begin
    case kOrderTypeDropShip:
      goto LUpdatePOOut;
  end;
  location = POp.Location;
  if (blank(location)) then begin
    BlockLoad(MainStockRec);
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(POp);

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(POp,i,POrw);
    if (POrw.stp==1 and POrw.OrderType!=kOrderTypeDropShip) then begin
      switch (gRuniningMaint) begin    
        case "RecalcItemStatusMn":
          t2 = POrw.Quant - POrw.Shipd2;
        otherwise
          t2 = POrw.Quant - POrw.Shipd2;
      end;
      if (POp.OKFlag!=0) then begin
        t3 = t2;
      end else begin
        t3 = blankval;
      end;
      if (t2<0) then begin t2 = 0; end;
      if (POp.Closed!=0) then begin  // if po is closed then nothing left to deliver
        t2 = 0;
        t3 = 0;
      end;
      if (addf==false) then begin
        t2 = -t2;
        t3 = -t3;
      end;
      if ((t2!=0) or (t3!=0)) then begin
        blanks = "";
        UpdateInstock("POVc",POp.SerNr,POrw.ArtCode,location,POp.TransDate,t,t,t,t3,t2,t,t,t,t);
      end;
    end;
  end;
  if (importf==false) then begin
    UpdatePOPlanned(POp,location,addf);
  end;
LUpdatePOOut:;  
  RETURN;
END;

global
updating function Boolean UpdatePOFromPU(record PUVc PUp,record PUVc PU2p,Boolean pu2only)
BEGIN
  Boolean res;
  record POVc oldPOr;
  record POVc POr;
  row PUVc PUrw;
  row POVc POrw;
  Integer i,rwcnt;
  Integer orw,orcnt;
  Boolean testf;
  record INVc INr;
  string 255 tstr;
  
  testf = false;
  if (PUp.Invalid!=0) then begin
    if (PU2p.SerNr!=-1) then begin
      if (PU2p.Invalid!=0) then begin
        testf = true;
      end;
    end else begin
      testf = true;
    end;
  end;
  if (testf) then begin
    goto LUpdatePOFromPU;
  end;  
  if (PUp.SerNr!=-1) then begin
    POr.SerNr = PUp.PONr;
  end else begin
    POr.SerNr = PU2p.PONr;
  end;
  if (ReadFirstMain(POr,1,true)) then begin
    RecordCopy(oldPOr,POr);
    orcnt = MatRowCnt(POr);
    UpdatePOOut(POr,false,false);    
    if (PU2p.SerNr!=-1) then begin
      rwcnt = MatRowCnt(PU2p);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(PU2p,i,PUrw);
        if (PUrw.OrdRow!=-1) and (PUrw.ovst==0) then begin
          orw = PUrw.OrdRow;
          if (orw<orcnt) then begin
            MatRowGet(POr,orw,POrw);
            if (pu2only==false) then begin
              POrw.Shipd1 = POrw.Shipd1 - PUrw.Quant;
            end;
            if (PU2p.OKFlag!=0) then begin
              POrw.Shipd2 = POrw.Shipd2 - PUrw.Quant;
            end;
            if (POrw.Shipd1==0) then begin
              POrw.Shipd1 = blankval;
            end;
            if (POrw.Shipd2==0) then begin
              POrw.Shipd2 = blankval;
            end;
            MatRowPut(POr,orw,POrw);
          end;
        end;
      end;
    end;
    if (PUp.SerNr!=-1) then begin
      if (PUp.Invalid==0) then begin
        rwcnt = MatRowCnt(PUp);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(PUp,i,PUrw);
          if (PUrw.OrdRow!=-1) then begin
            orw = PUrw.OrdRow;
            if (orw<orcnt) and (PUrw.ovst==0) then begin
              MatRowGet(POr,orw,POrw);
              if (pu2only==false) then begin
                if (POrw.StockType!=PUrw.StockType) then begin
                  POrw.StockType = PUrw.StockType;
                  if (ReadFirstItem(POrw.ArtCode,INr,true,false)) then begin end;
                  GetINPurchaseControlAcc(INr,tstr,POr.VECode,POr.Location,POrw.StockType);
                  POrw.CostAcc = tstr;
                end;
              end;
              if (pu2only==false) then begin
                POrw.Shipd1 = POrw.Shipd1 + PUrw.Quant;
              end;
              if (PUp.OKFlag!=0) then begin
                POrw.Shipd2 = POrw.Shipd2 + PUrw.Quant;
              end;
              if (POrw.Shipd1==0) then begin
                POrw.Shipd1 = blankval;
              end;
              if (POrw.Shipd2==0) then begin
                POrw.Shipd2 = blankval;
              end;
              MatRowPut(POr,orw,POrw);
            end;
          end;
        end;
      end;
      UpdatePOOut(POr,true,false);
    end;
    SetPOFlags(POr,false);
    if (RecordUpdate(oldPOr,POr,false)==0) then begin
    end;
    res = true;
  end;
LUpdatePOFromPU:;  
  UpdatePOFromPU = res;
  RETURN;
END;

/*
updating procedure UpdatePORowWithPURow(record PUVc PUp,row PUVc PUrw,LongInt PONr,Boolean addf,Boolean shipd1f,Boolean shipd2f)
begin
  record POVc POr;
  record POVc oldPOr;
  row POVc POrw;
  Integer porwcnt;
  record INVc INr;
  string 255 tstr;

  POr.SerNr = PONr;
  if (ReadFirstMain(POr,1,true)) then begin
    RecordCopy(oldPOr,POr);
    porwcnt = MatRowCnt(POr);
    if (PUrw.OrdRow<porwcnt) then begin
      MatRowGet(POr,PUrw.OrdRow,POrw);
      if (POrw.StockType!=PUrw.StockType) then begin
        POrw.StockType = PUrw.StockType;
        if (ReadFirstItem(POrw.ArtCode,INr,true,false)) then begin end;
        GetINPurchaseControlAcc(INr,tstr,POr.VECode,POr.Location,POrw.StockType);
        POrw.CostAcc = tstr;
      end;
      if (shipd1f) then begin
        if (addf) then begin
          POrw.Shipd1 = POrw.Shipd1 + PUrw.Quant;
        end else begin
          POrw.Shipd1 = POrw.Shipd1 - PUrw.Quant;
        end;
      end;
      if (shipd2f) then begin
        if (PUp.OKFlag!=0) then begin
          if (addf) then begin
            POrw.Shipd2 = POrw.Shipd2 + PUrw.Quant;
          end else begin
            POrw.Shipd2 = POrw.Shipd2 - PUrw.Quant;
          end;
        end;
      end;
      if (POrw.Shipd1==0) then begin
        POrw.Shipd1 = blankval;
      end;
      if (POrw.Shipd2==0) then begin
        POrw.Shipd2 = blankval;
      end;
      MatRowPut(POr,PUrw.OrdRow,POrw);
    end;
    if (RecordUpdate(oldPOr,POr,true)==0) then begin
    end;
  end;
  return;
end;

global
updating procedure UpdatePOFromPURows(record PUVc PUp,Boolean puf,record PUVc PU2p,Boolean pu2f,Boolean shipd1f)
begin
  Integer i,rwcnt;
  row PUVc PUrw;
  LongInt PONr;
  
  if (PUp.PONr!=-1) then begin goto LUpdatePOFromPURows; end;
  if (pu2f) then begin
    rwcnt = MatRowCnt(PU2p);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PU2p,i,PUrw);
      PONr = PUrw.PONr;
      if (PONr<=0) then begin PONr = PU2p.PONr; end;
      if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        UpdatePORowWithPURow(PU2p,PUrw,PONr,false,shipd1f,true);
      end;
    end;
  end;
  if (puf) then begin
    rwcnt = MatRowCnt(PUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUp,i,PUrw);
      if (PUrw.PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        UpdatePORowWithPURow(PUp,PUrw,PUrw.PONr,true,shipd1f,true);
      end;
    end;
  end;
//  UpdatePOOut(POr,true,false);
//  SetPOFlags(POr,false);
  
LUpdatePOFromPURows:;  
  return;
end;

global
updating procedure RemovePU_PORows(var record PUVc PUp)
begin
  Integer i,rwcnt;
  row PUVc PUrw;

  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    if (PUrw.PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
      UpdatePORowWithPURow(PUp,PUrw,PUrw.PONr,false,true,true);
    end;
  end;
  return;
end;

*/

updating procedure UpdatePORowWithPURow(record PUVc PUp,row PUVc PUrw,Boolean addf,Boolean shipd1f,Boolean shipd2f,var record POVc POr)
begin
  row POVc POrw;
  Integer porwcnt;
  record INVc INr;
  string 255 tstr;

  porwcnt = MatRowCnt(POr);
  if (PUrw.OrdRow<porwcnt) then begin
    MatRowGet(POr,PUrw.OrdRow,POrw);
    if (POrw.StockType!=PUrw.StockType) then begin
      POrw.StockType = PUrw.StockType;
      if (ReadFirstItem(POrw.ArtCode,INr,true,false)) then begin end;
      GetINPurchaseControlAcc(INr,tstr,POr.VECode,POr.Location,POrw.StockType);
      POrw.CostAcc = tstr;
    end;
    if (shipd1f) then begin
      if (addf) then begin
        POrw.Shipd1 = POrw.Shipd1 + PUrw.Quant;
      end else begin
        POrw.Shipd1 = POrw.Shipd1 - PUrw.Quant;
      end;
    end;
    if (shipd2f) then begin
      if (PUp.OKFlag!=0) then begin
        if (addf) then begin
          POrw.Shipd2 = POrw.Shipd2 + PUrw.Quant;
        end else begin
          POrw.Shipd2 = POrw.Shipd2 - PUrw.Quant;
        end;
      end;
    end;
    if (POrw.Shipd1==0) then begin
      POrw.Shipd1 = blankval;
    end;
    if (POrw.Shipd2==0) then begin
      POrw.Shipd2 = blankval;
    end;
    MatRowPut(POr,PUrw.OrdRow,POrw);
  end;
  return;
end;

global
updating procedure UpdatePOFromPURows(record PUVc PUp,Boolean puf,record PUVc PU2p,Boolean pu2f,Boolean shipd1f)
begin
  Integer i,rwcnt,err;
  row PUVc PUrw;
  LongInt PONr;
  Integer apocnt,pos;
  record POVc POr;
  record POVc oldPOr;
  vector LongInt vponr;
  array record POVc aPOr;
  array record POVc aoldPOr;
  
  if (PUp.PONr!=-1) then begin goto LUpdatePOFromPURows; end;
  if (pu2f) then begin
    apocnt = 0;
    rwcnt = MatRowCnt(PU2p);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PU2p,i,PUrw);
      PONr = PUrw.PONr;
      if (PONr<=0) then begin PONr = PU2p.PONr; end;
      if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        if (vponr[PONr]<0) then begin
          POr.SerNr = PONr;
          if (ReadFirstMain(POr,1,true)) then begin
            aPOr[apocnt] = POr;
            aoldPOr[apocnt] = POr;
            vponr[PONr] = apocnt;
            apocnt = apocnt + 1;
          end;
        end;
      end;
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PU2p,i,PUrw);
      PONr = PUrw.PONr;
      if (PONr<=0) then begin PONr = PU2p.PONr; end;
      if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        if (vponr[PONr]>=0) then begin
          pos = vponr[PONr];
          RecordCopy(POr,aPOr[pos]);
          UpdatePOOut(POr,false,false);    
          UpdatePORowWithPURow(PU2p,PUrw,false,shipd1f,true,POr);
          UpdatePOOut(POr,true,false);    
          aPOr[pos] = POr;
        end;
      end;
    end;
    for (i=0;i<apocnt;i=i+1) begin
      RecordCopy(POr,aPOr[i]);
      RecordCopy(oldPOr,aoldPOr[i]);
      RecordUpdate(oldPOr,POr,false);//why record update dont work here ? 
//      RecordStore(POr,true);
    end;
  end;
  
  if (puf) then begin
    ClearArray(aPOr);
    ClearArray(aoldPOr);
    ClearVector(vponr);
    apocnt = 0;

    rwcnt = MatRowCnt(PUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUp,i,PUrw);
      PONr = PUrw.PONr;
      if (PONr<=0) then begin PONr = PUp.PONr; end;
      if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        if (vponr[PONr]<0) then begin
          POr.SerNr = PONr;
          if (ReadFirstMain(POr,1,true)) then begin
            aPOr[apocnt] = POr;
            aoldPOr[apocnt] = POr;
            vponr[PONr] = apocnt;
            apocnt = apocnt + 1;
          end;
        end;
      end;
    end;

    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUp,i,PUrw);
      PONr = PUrw.PONr;
      if (PONr<=0) then begin PONr = PUp.PONr; end;
      if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
        if (vponr[PONr]>=0) then begin
          pos = vponr[PONr];
          RecordCopy(POr,aPOr[pos]);
          UpdatePOOut(POr,false,false);    
          UpdatePORowWithPURow(PUp,PUrw,true,shipd1f,true,POr);
          UpdatePOOut(POr,true,false);    
          aPOr[pos] = POr;
        end;
      end;
    end;
    for (i=0;i<apocnt;i=i+1) begin
      RecordCopy(POr,aPOr[i]);
      RecordCopy(oldPOr,aoldPOr[i]);
      err = RecordUpdate(oldPOr,POr,false);//why record update dont work here ? 
//      RecordStore(POr,true);
    end;
  end;
//  UpdatePOOut(POr,true,false);
//  SetPOFlags(POr,false);
  
LUpdatePOFromPURows:;  
  return;
end;

global
updating procedure RemovePU_PORows(var record PUVc PUp)
begin
  Integer i,rwcnt;
  row PUVc PUrw;
  Integer apocnt,pos;
  LongInt PONr;
  record POVc POr;
  record POVc oldPOr;
  vector LongInt vponr;
  array record POVc aPOr;
  array record POVc aoldPOr;

  apocnt = 0;
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    PONr = PUrw.PONr;
    if (PONr<=0) then begin PONr = PUp.PONr; end;
    if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
      if (vponr[PONr]<0) then begin
        POr.SerNr = PONr;
        if (ReadFirstMain(POr,1,true)) then begin
          aPOr[apocnt] = POr;
          aoldPOr[apocnt] = POr;
          vponr[POr.SerNr] = apocnt;
          apocnt = apocnt + 1;
        end;
      end;
    end;
  end;
  
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    PONr = PUrw.PONr;
    if (PONr<=0) then begin PONr = PUp.PONr; end;
    if (PONr!=-1) and (PUrw.OrdRow>=0) and (PUrw.ovst==0) then begin
      if (vponr[PONr]>=0) then begin
        pos = vponr[PONr];
        RecordCopy(POr,aPOr[pos]);
        UpdatePORowWithPURow(PUp,PUrw,false,true,true,POr);
        aPOr[pos] = POr;
      end;
    end;
  end;
  for (i=0;i<apocnt;i=i+1) begin
    RecordCopy(POr,aPOr[i]);
    RecordCopy(oldPOr,aoldPOr[i]);
//      err = RecordUpdate(POr,oldPOr,true);//why record update dont work here ? 
    RecordStore(POr,true);
  end;
  return;
end;


procedure ArtCodeOnThisPU(Integer cnt,record PUVc PUp,string artcode,string location,string MainStock,record INVc INr,var val resp)
begin
  row PUVc PUrw;
  Integer rwcnt,i;
  string 255 location2;

  resp = blankval;
  rwcnt = MatRowCnt(PUp); 
  for (i=cnt;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    location2 = PUrw.Location;
    if (blank(location2)) then begin
      location2 = PUp.Location;
    end;
    if (blank(location2)) then begin
      location2 = MainStock;
    end;  
    if (location==location2) then begin
      if (TestArtCode(PUrw.ArtCode,artcode,INr)) then begin
        resp = resp + PUrw.Quant;
      end;
    end;
  end;
  return;
end;

global
updating procedure UpdateLocationWeightedAv(string itemcode,string location,val qty,val price,val priceb2,val qonrecp,Boolean ovstf)
begin
  record ItemStatusVc ISr;
  record WeigAvVc war;
  record WeigAvVc oldwar;
  val nv,t,tq,trs;
  Boolean found;
  val sl;
  string 10 llocation;
  record RoundBlock RoundRec;
  record MainStockBlock MSb;
  
  if (blank(itemcode)) then begin goto LUpdateLocationWeightedAv; end;
  llocation = location;
  BlockLoad(MSb);
  if (MSb.DontCalcWAPerLoc!=0) then begin goto LUpdateLocationWeightedAv; end;
  if (blank(llocation)) then begin 
    llocation = MSb.MainStock;
  end;    
  if (blank(llocation)) then begin goto LUpdateLocationWeightedAv; end;  
  BlockLoad(RoundRec);
  war.ArtCode = itemcode;
  war.Location = llocation;
  found = ReadFirstMain(war,2,true);
  if (found==false) then begin
    war.ArtCode = itemcode;
    war.Location = llocation;
    war.WeighedAvPrice = blankval;
    war.WeighedAvPriceB2 = blankval;
  end else begin
    RecordCopy(oldwar,war);
  end;
  FindStockValue(itemcode,llocation,ISr);
  ISr.Instock = ISr.Instock - qonrecp;
  nv = qty*price;
  if (ovstf==false) then begin
    sl = ISr.Instock - qty;
    if (sl<0) then begin sl = 0; end;
  end else begin
    sl = ISr.Instock + qty;
  end;
  t = sl*war.WeighedAvPrice;
  if (ovstf==false) then begin
    t = t + nv;
    tq = sl + qty;
  end else begin
    t = t - nv;
    tq = sl - qty;
  end;
  trs = t/tq;  
  war.WeighedAvPrice = Round(trs,GetCostRoundMode(RoundRec));//war.WeighedAvPrice = trs;
  nv = qty*priceb2;
  t = sl*war.WeighedAvPriceB2;
  if (ovstf==false) then begin
    t = t + nv;
    tq = sl + qty;
  end else begin
    t = t - nv;
    tq = sl - qty;
  end;
  trs = t/tq;  
  war.WeighedAvPriceB2 = Round(trs,GetCostRoundMode(RoundRec));//war.WeighedAvPrice = trs;
  if (tq>=0) then begin
    if (found==false) then begin
      if (RecordStore(war,true)) then begin end;
    end else begin
      if (RecordUpdate(oldwar,war,found)==0) then begin end;
    end;
  end;
LUpdateLocationWeightedAv:;
  return;
end;

global
updating procedure UpdateLocationWeightedAv2(string itemcode,string location,val qty,val price,val priceb2,val qonrecp)
begin
  record ItemStatusVc ISr;
  record WeigAvVc war;
  record WeigAvVc oldwar;
  val nv,t,tq,trs;
  Boolean found;
  val sl;
  string 10 llocation;
  record RoundBlock RoundRec;
  record MainStockBlock MSb;
  
  if (blank(itemcode)) then begin goto LUpdateLocationWeightedAv2; end;
  llocation = location;
  BlockLoad(MSb);
  if (MSb.DontCalcWAPerLoc!=0) then begin goto LUpdateLocationWeightedAv2; end;
  if (blank(llocation)) then begin 
    llocation = MSb.MainStock;
  end;    
  if (blank(llocation)) then begin goto LUpdateLocationWeightedAv2; end;  
  BlockLoad(RoundRec);
  war.ArtCode = itemcode;
  war.Location = llocation;
  found = ReadFirstMain(war,2,true);
  if (found==false) then begin
    war.ArtCode = itemcode;
    war.Location = llocation;
    war.WeighedAvPrice = blankval;
    war.WeighedAvPriceB2 = blankval;
  end else begin
    RecordCopy(oldwar,war);
  end;
  FindStockValue(itemcode,llocation,ISr);
  ISr.Instock = ISr.Instock - qonrecp;
  nv = qty*price;
  sl = ISr.Instock;
  t = sl*war.WeighedAvPrice;
  t = t - nv;
  tq = sl - qty;
  trs = t/tq;  
  war.WeighedAvPrice = Round(trs,GetCostRoundMode(RoundRec));//war.WeighedAvPrice = trs;
  nv = qty*priceb2;
  t = sl*war.WeighedAvPriceB2;
  t = t - nv;
  tq = sl - qty;
  trs = t/tq;  
  war.WeighedAvPriceB2 = Round(trs,GetCostRoundMode(RoundRec));//war.WeighedAvPrice = trs;
  if (tq>=0) then begin
    if (found==false) then begin
      if (RecordStore(war,true)) then begin end;
    end else begin
      if (RecordUpdate(oldwar,war,found)==0) then begin end;
    end;
  end;
LUpdateLocationWeightedAv2:;
  RETURN;
END;

procedure FindLastPurchase(record PUVc PUr,Integer purow,
                           var val lastuprice,var val lastupriceb1,
                           var val lastupriceb2,var val lastcostprice,                           
                           var val lastcostpriceb2,var string lastcurncycode)
begin
  record ItemHistVc IHr;
  Boolean found,testf;
  LongInt startsernr;
  record PUVc lPUr;
  row PUVc lPUrw;
  string 255 startartcode;
  
  lastuprice = blankval;
  lastupriceb1 = blankval;
  lastupriceb2 = blankval;
  lastcostprice = blankval;
  lastcostpriceb2 = blankval;
  lastcurncycode = "";
  IHr.FileName = "PUVc";
  IHr.TransNr = PUr.SerNr;
  IHr.Row = purow;
  if (ReadFirstKey("FNTransNr",IHr,3,true)) then begin
    startsernr = IHr.SerNr;
    startartcode = IHr.ArtCode;
    ResetLoop(IHr);
    IHr.FileName = "PUVc";
    IHr.ArtCode = startartcode;
    IHr.SerNr = IHr.SerNr - 1;
    found = true;
    while (LoopBackKey("FNArtCode",IHr,3,found)) begin      
      if (IHr.FileName!="PUVc") then begin found = false; end;
      if (IHr.ArtCode!=startartcode) then begin found = false; end;
//      if (IHr.SerNr>startsernr) then begin found = false; end;
      if (found) then begin
        testf = true;
        if (IHr.TransNr==PUr.SerNr) then begin testf = false; end;
        if (testf) then begin
          lPUr.SerNr = IHr.TransNr;
          if (ReadFirstMain(lPUr,1,true)) then begin
            if (IHr.Row<MatRowCnt(lPUr)) then begin            
              MatRowGet(lPUr,IHr.Row,lPUrw);
              lastuprice = lPUrw.UPrice;
              lastcostprice = lPUrw.CostPrice;
              lastcostpriceb2 = MulRateToBase2(lPUr.CurncyCode,lPUrw.CostPrice,lPUr.FrRate,lPUr.ToRateB1,lPUr.ToRateB2,lPUr.BaseRate1,lPUr.BaseRate2,SetRoundModeD(5));
              lastupriceb1 = MulRateToBase1(lPUr.CurncyCode,lPUrw.UPrice,lPUr.FrRate,lPUr.ToRateB1,lPUr.ToRateB2,lPUr.BaseRate1,lPUr.BaseRate2,SetRoundModeD(5));
              lastupriceb2 = MulRateToBase2(lPUr.CurncyCode,lPUrw.UPrice,lPUr.FrRate,lPUr.ToRateB1,lPUr.ToRateB2,lPUr.BaseRate1,lPUr.BaseRate2,SetRoundModeD(5));
              lastcurncycode = lPUr.CurncyCode;          
              found = false;
            end;
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure AddToSummaryPU(record MainStockBlock MSb,row PUVc nextPUrw,Boolean ovstf,Boolean perlocationf,
                         var record PUVc PUp,var vector val LastPUCostPrice,var vector val LastPUUPrice)
begin
  Integer rwcnt,i;
  row PUVc PUrw;
  Boolean testf;
  string 255 location,nextlocation;
  record INVc INr;
  
  if (ovstf==false) then begin
    if ((nextPUrw.stp==3) or (nextPUrw.ovst!=0)) then begin
      goto LAddToSummaryPU;
    end;
  end else begin
    if ((nextPUrw.stp==3) or (nextPUrw.ovst==0)) then begin
      goto LAddToSummaryPU;
    end;
  end;
  nextlocation = nextPUrw.Location;
  if (blank(nextlocation)) then begin
    nextlocation = PUp.Location;
  end;
  if (blank(nextlocation)) then begin
    nextlocation = MSb.MainStock;
  end;  

  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    testf = true;
    if (nextPUrw.ArtCode!=PUrw.ArtCode) then begin testf = false; end;
    if (perlocationf) then begin
      location = PUrw.Location;
      if (blank(location)) then begin
        location = PUp.Location;
      end;
      if (blank(location)) then begin
        location = MSb.MainStock;
      end;  
      if (nextlocation!=location) then begin testf = false; end;
    end;
    if (ovstf==false) then begin
      if ((PUrw.stp==3) or (PUrw.ovst!=0)) then begin
        testf = false;
      end;
    end else begin
      if ((PUrw.stp==3) or (PUrw.ovst==0)) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      ReadFirstItemInclClosed(PUrw.ArtCode,INr,false,false);
      PUrw.Quant = PUrw.Quant + nextPUrw.Quant;
      PUrw.CostPrice = PUrw.CostPrice + nextPUrw.Quant*nextPUrw.CostPrice;
      PUrw.UPrice = PUrw.UPrice + nextPUrw.UPrice;
      MatRowPut(PUp,i,PUrw);
      LastPUCostPrice[INr.Code] = nextPUrw.CostPrice;
      LastPUUPrice[INr.Code] = nextPUrw.UPrice;
      goto LAddToSummaryPU;
    end;
  end;
  PUrw.ArtCode = nextPUrw.ArtCode;
  if (perlocationf) then begin
    PUrw.Location = nextlocation;
  end;
  PUrw.Quant = nextPUrw.Quant;
  PUrw.CostPrice = nextPUrw.Quant*nextPUrw.CostPrice;
  PUrw.UPrice = nextPUrw.UPrice;
  MatRowPut(PUp,MatRowCnt(PUp),PUrw);
  ReadFirstItemInclClosed(PUrw.ArtCode,INr,false,false);
  LastPUCostPrice[INr.Code] = nextPUrw.CostPrice;
  LastPUUPrice[INr.Code] = nextPUrw.UPrice;
LAddToSummaryPU:;  
  return;
end;

global
updating procedure PurUpdateCostPrice(record PUVc okPUp,Boolean ovstf)
BEGIN
  record INVc oldINr;
  record INVc INr;
  record ItemStatusVc ISr;
  row PUVc PUrw;
  row PUVc PU2rw;
  Integer j,rwcnt,i;
  val rs,rsb2,t,t2,q,trs,trsb2,qonrec,tb2;
  Date curdate;
  record RoundBlock RoundRec;
  record MainStockBlock MSb;
  string 255 location,location2,lastcurncycode,tstr;
  val lastuprice,lastupriceb1,lastupriceb2,lastcostprice,lastcostpriceb2;
  record BaseCurBlock BCb;
  record PUVc PUp;
  vector val LastPUCostPrice,LastPUUPrice;
  
  if ((okPUp.OKFlag==1) and (okPUp.Invalid==0)) then begin
    BlockLoad(RoundRec);
    BlockLoad(MSb);
    BlockLoad(BCb);
    curdate = CurrentDate;
    
    RecordCopy(PUp,okPUp);
    rwcnt = MatRowCnt(PUp);
    while (rwcnt>0) begin
      MatRowDelete(PUp,0);
      rwcnt = rwcnt - 1;
    end;

    rwcnt = MatRowCnt(okPUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(okPUp,i,PUrw);
      AddToSummaryPU(MSb,PUrw,ovstf,false,PUp,LastPUCostPrice,LastPUUPrice);
    end;


    rwcnt = MatRowCnt(PUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUp,i,PUrw);
      if (ovstf==false) then begin
        if ((PUrw.stp==3) or (PUrw.ovst!=0)) then begin
          goto LSKIPPUROW;
        end;
      end else begin
        if ((PUrw.stp==3) or (PUrw.ovst==0)) then begin
          goto LSKIPPUROW;
        end;
      end;
      if (PUrw.Quant!=0) then begin
      if (ReadFirstItemInclClosed(PUrw.ArtCode,INr,false,false)) then begin
        location = PUrw.Location;
        if (blank(location)) then begin
          location = PUp.Location;
        end;
        if (blank(location)) then begin
          location = MSb.MainStock;
        end;  
        RecordCopy(oldINr,INr);

        if (ovstf==false) then begin
          INr.LastPurchPrice2 = Round(LastPUUPrice[INr.Code],GetCostRoundMode(RoundRec));
          INr.LastPurchPrice = Round(LastPUCostPrice[INr.Code],GetCostRoundMode(RoundRec));
          INr.LastPurchCurncyCode = PUp.CurncyCode;          
        end else begin
          FindLastPurchase(PUp,i,lastuprice,lastupriceb1,lastupriceb2,lastcostprice,lastcostpriceb2,lastcurncycode);
          INr.LastPurchPrice2 = lastuprice;
          INr.LastPurchPrice = lastcostprice;
          INr.LastPurchCurncyCode = lastcurncycode;
        end;
        rs = PUrw.CostPrice;
//        rsb2 = MulRateToBase2(PUp.CurncyCode,PUrw.InPrice,PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,DefaultCurRoundOff);//rs is in Base 1 not curency !!? PUrw.UPrice  is
//InPrice Doesnt have extra costs invludecd
        tstr = "";
        rsb2 = MulRateToBase2(tstr,PUrw.CostPrice,PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,DefaultCurRoundOff);//rs is in Base 1 not curency !!? PUrw.UPrice  is
        FindStockValue(INr.Code,"",ISr);
        if (ovstf==false) then begin
          q = ISr.Instock - PUrw.Quant;
        end else begin
          q = ISr.Instock + PUrw.Quant;
        end;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(PUp,j,PU2rw);
          if (TestArtCode(PU2rw.ArtCode,PUrw.ArtCode,INr)) then begin
            q = q - PU2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        t = q*INr.WeighedAvPrice;
        tb2 = q*INr.WeighedAvPriceB2;
/*
it really doenst mae sense   
rs is already with Price factor included
     
        if (INr.PriceFactor!=0) then begin
          rs = rs*INr.PriceFactor; 
//this is sick isnt it ? at least causing WA be not same as NL transaction from PU , and what is someone changes this afterwads ? shouldnt we use GR value always? 
//but maybe calc cost price when editng GR ? 
          rsb2 = rsb2*INr.PriceFactor;
        end;
*/        
        if (ovstf==false) then begin
          q = q + PUrw.Quant;
        end else begin
          q = q - PUrw.Quant;
        end;
        if (q!=0) then begin
//          t2 = PUrw.Quant*rs;
          t2 = rs;
          if (ovstf==false) then begin
            t = t + t2;
          end else begin
            t = t - t2;
          end;
          trs = t/q;

//          t2 = PUrw.Quant*rsb2;
          t2 = rsb2;
          if (ovstf==false) then begin
            tb2 = tb2 + t2;
          end else begin
            tb2 = tb2 - t2;
          end;
          trsb2 = tb2/q;
        end;
        if (q>=0) then begin
          INr.WeighedAvPrice = trs;
          INr.WeighedAvPriceB2 = trsb2;
        end;
        ArtCodeOnThisPU(i+1,PUp,PUrw.ArtCode,location,MSb.MainStock,INr,qonrec);
        INr.WeighedAvPrice = Round(INr.WeighedAvPrice,GetCostRoundMode(RoundRec));
        INr.WeighedAvPriceB2 = Round(INr.WeighedAvPriceB2,GetCostRoundMode(RoundRec));
        switch (INr.UpdateCost) begin
          case 1:
            if (ovstf==false) then begin
              rs = LastPUCostPrice[INr.Code];
            end else begin
              rs = lastcostprice;
            end;
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = Round(rs,GetCostRoundMode(RoundRec));
              INr.LastPriceChange = curdate;
            end;
            if (ovstf==false) then begin
              rsb2 = MulRateToBase2(BCb.BaseCur1,LastPUCostPrice[INr.Code],PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,SetRoundModeD(5));
            end else begin
              rsb2 = lastcostprice;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = Round(rsb2,GetCostRoundMode(RoundRec));
            end;
          case 2:
            rs = INr.WeighedAvPrice;
            rsb2 = INr.WeighedAvPriceB2;
            if (INr.PriceFactor!=0) then begin            
              rs = rs*INr.PriceFactor;
              rsb2 = rsb2*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = rs;
              INr.LastPriceChange = curdate;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = rsb2;
            end;
          case 3:
            if (ovstf==false) then begin
              rs = MulRateToBase1(PUp.CurncyCode,LastPUUPrice[INr.Code],PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,SetRoundModeD(5));
            end else begin
              rs = lastupriceb1;
            end;
            if (INr.PriceFactor!=0) then begin
              rs = rs*INr.PriceFactor;
            end;
            if (INr.InPrice!=rs) then begin  // inprice has changed 
              INr.InPrice = Round(rs,GetCostRoundMode(RoundRec));
              INr.LastPriceChange = curdate;
            end;
            if (ovstf==false) then begin
              rsb2 = MulRateToBase2(PUp.CurncyCode,LastPUUPrice[INr.Code],PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,SetRoundModeD(5));
            end else begin
              rsb2 = lastupriceb2;
            end;
            if (INr.PriceFactor!=0) then begin
              rsb2 = rsb2*INr.PriceFactor;
            end;
            if (INr.InPriceB2!=rsb2) then begin  // inprice has changed 
              INr.InPriceB2 = Round(rsb2,GetCostRoundMode(RoundRec));
            end;
        end;
        switch(INr.UpdateCost) begin
          case 0:;
          otherwise
            INr.InPrice = Round(INr.InPrice,GetCostRoundMode(RoundRec));
            if (nonblank(BCb.BaseCur2)) then begin
              INr.InPriceB2 = Round(INr.InPriceB2,GetCostRoundMode(RoundRec));
            end else begin
              INr.InPriceB2 = blankval;
            end;
            INr.LastPriceChange = CurrentDate;
        end;
        if (RecordUpdate(oldINr,INr,false)==0) then begin
        end;
      end;
      end;
LSKIPPUROW:;      
    end;
    RecordCopy(PUp,okPUp);
    rwcnt = MatRowCnt(PUp);
    while (rwcnt>0) begin
      MatRowDelete(PUp,0);
      rwcnt = rwcnt - 1;
    end;
    
    rwcnt = MatRowCnt(okPUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(okPUp,i,PUrw);
      AddToSummaryPU(MSb,PUrw,ovstf,true,PUp,LastPUCostPrice,LastPUUPrice);
    end;

    rwcnt = MatRowCnt(PUp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PUp,i,PUrw);
      if (ovstf==false) then begin
        if ((PUrw.stp==3) or (PUrw.ovst!=0)) then begin
          goto LSKIPPUROW2;
        end;
      end else begin
        if ((PUrw.stp==3) or (PUrw.ovst==0)) then begin
          goto LSKIPPUROW2;
        end;
      end;
      if (PUrw.Quant!=0) then begin
      if (ReadFirstItemInclClosed(PUrw.ArtCode,INr,false,false)) then begin
        location = PUrw.Location;
        if (blank(location)) then begin
          location = PUp.Location;
        end;
        if (blank(location)) then begin
          location = MSb.MainStock;
        end;  
        rs = PUrw.CostPrice;
//        rsb2 = MulRateToBase2(PUp.CurncyCode,PUrw.InPrice,PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,DefaultCurRoundOff);//rs is in Base 1 not curency !!? PUrw.UPrice  is
//InPrice Doesnt have extra costs invludecd
        tstr = "";
        rsb2 = MulRateToBase2(tstr,PUrw.CostPrice,PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,DefaultCurRoundOff);//rs is in Base 1 not curency !!? PUrw.UPrice  is
        FindStockValue(INr.Code,"",ISr);
        if (ovstf==false) then begin
          q = ISr.Instock - PUrw.Quant;
        end else begin
          q = ISr.Instock + PUrw.Quant;
        end;
        for (j=i+1;j<rwcnt;j=j+1) begin
          MatRowGet(PUp,j,PU2rw);
          if (TestArtCode(PU2rw.ArtCode,PUrw.ArtCode,INr)) then begin
            q = q - PU2rw.Quant;
          end;
        end;
        if (q<0) then begin q = blankval; end;
        t = q*INr.WeighedAvPrice;
        tb2 = q*INr.WeighedAvPriceB2;
/*        
it really doenst mae sense   
rs is already with Price factor included
        if (INr.PriceFactor!=0) then begin        
          rs = rs*INr.PriceFactor; 
//this is sick isnt it ? at least causing WA be not same as NL transaction from PU , and what is someone changes this afterwads ? shouldnt we use GR value always? 
//but maybe calc cost price when editng GR ? 
          rsb2 = rsb2*INr.PriceFactor;
        end;
*/        
        if (ovstf==false) then begin
          q = q + PUrw.Quant;
        end else begin
          q = q - PUrw.Quant;
        end;
        if (q!=0) then begin
//          t2 = PUrw.Quant*rs;
          t2 = rs/PUrw.Quant;
          if (ovstf==false) then begin
            t = t + t2;
          end else begin
            t = t - t2;
          end;
          trs = t/q;
//          t2 = PUrw.Quant*rsb2;
          t2 = rsb2/PUrw.Quant;
          if (ovstf==false) then begin
            tb2 = tb2 + t2;
          end else begin
            tb2 = tb2 - t2;
          end;
          trsb2 = tb2/q;
        end;
        ArtCodeOnThisPU(i+1,PUp,PUrw.ArtCode,location,MSb.MainStock,INr,qonrec);
        if (blank(PUrw.Location)) then begin
          UpdateLocationWeightedAv(INr.Code,PUp.Location,PUrw.Quant,rs/PUrw.Quant,rsb2/PUrw.Quant,qonrec,ovstf);
        end else begin
          UpdateLocationWeightedAv(INr.Code,PUrw.Location,PUrw.Quant,rs/PUrw.Quant,rsb2/PUrw.Quant,qonrec,ovstf);
        end;
      end;
      end;
LSKIPPUROW2:;      
    end;
  end;
  RETURN;
END;
