external function Boolean HasApprovals();
remote function Integer PUApprovalStatus(record PUVc,var record AcceptanceRulesVc);
external function Boolean BulkSerialNos_CalculateQuantityAndSerialNr(record SerNrTrackBlock,Boolean,string,var string,var val);
external function Boolean PUDchrsum(record PUVc,Integer);
external function string 255 FillupTaxMatrix(Integer,string,string,string,string,string,var record TaxMatrixVc);
external function Boolean GetItemPurchasePriceDiscount(string,string,Date,string,string,val,string,string,string,string,Integer,Boolean,val,val,val,val,val,
         var record INVc,var record PIVc,var Boolean,var val,var string,var val,var string,var string,var Boolean,var string);
external function Boolean SerialNrEverinStock(string,string);
external function Integer SerBlockCheckOverlap(LongInt,LongInt,LongInt,LongInt);
external procedure RowCalculateTaxMatrix_VIVc(var record VIVc,Integer,row VIVc,Integer);
external function Boolean CalculateOPPrepaymentAvgRate(record PUVc,LongInt,val,var val,var val,var val,var val,var val);
external function roundmode GetCostRoundMode(record RoundBlock);
external function roundmode DefaultRoundMode();
external function Integer ValidatePORecord(var record POVc,record POVc,LongInt,LongInt,Boolean,var string);
external procedure DivPIFactor(val,val,var val);
external procedure RoundVATSum(string,string,string,var val);
external function string 255 FindINObjects(string,string);
external procedure PURecalcCost(var record PUVc);
external procedure PUSetShipCost(var record PUVc,Integer);
external function Integer GetPUPControlAcc(string,string,Integer,string,string,record AccBlock,Integer,var string,var string,Boolean);
external function Integer GetPUStockAcc(Integer,string,string,string,record AccBlock,Integer,var string,var string,Boolean);
external procedure NextM4Number(string,var string);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function string 20 FindFreePositionInLocArea_ExcludePositionFromArray(string,string,val,record INVc,Integer,Array string,Integer);
external procedure CalculatePURowSum(val,val,string,var val,val,
                                     val,val,val,val,val,
                                     string,var val,Boolean,string,
                                     val,val,val,val,val);
external function Boolean GetFirstItem(var string,var record INVc);
external function Integer GetPO(LongInt,var record POVc,string,Boolean);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val FindVAT(string,val,Integer,Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetAPAcc(string,var string);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstPurchaseItem(string,string,string,var record PIVc);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external procedure PUCalcPerc(val,string,var val);
external procedure PUSumUp(var record PUVc);
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                                   val,val,val,val,val,
                                   val,val,val,val,val,val,
                                   string,var val,val,var val,string,Integer);
external procedure ReadLastINSer(string,var string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external function Boolean GetAccName(string,var string,Integer);
external procedure GetPurchaseControlAcc(string,Integer,string,record AccBlock,string,var string,string);
external procedure MulM4ProcVal(val,val,var val);
external procedure VISumup(record VIVc,var val);
external procedure VICalcVals(var record VIVc);
external procedure VICalcEReb(var record VIVc);
external procedure AddExtraCostRow(record AccBlock,record BaseCurBlock,record VIVc,string,val,Integer,Integer,Integer,string,var record SMVc,Integer);
external function Boolean VIVc_PasteVECode(var record VIVc,Integer,Boolean,Boolean,var string);

global
procedure NextNumber(string code,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      goto L10NextNumber;
    end;
  end;
L10NextNumber:;
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end;  
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  padcnt = len(suff);
  t = StringToVal(suff,M40Val);
  t = t + 1;
//  tstr = Left(t,len(t)-3);
  tstr = ValToString(t,M40Val,"","",0);  
  M4PadString(tstr,padcnt,"0",true,suff);
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
procedure NextM4SerialNumber(string code,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      goto L10NextM4SerialNumber;
    end;
  end;
L10NextM4SerialNumber:;
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end;  
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  padcnt = len(suff);
  if (padcnt==0) then begin 
    padcnt = 1; 
  end;
  t = StringToVal(suff,M40Val);
  t = t + 1;
  tstr = ValToString(t,M40Val,"","",0);  
  if (len(suff))<(len(tstr)) then begin
    suff = tstr;
  end else begin
    M4PadString(tstr,padcnt,"0",true,suff);
  end;
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
procedure NextSerialNumberWithPad(string code,Integer extrapad,var string next)
BEGIN
  string 255 pre;
  string 255 suff;
  Integer i,j;
  val t;
  string 1 c;
  string 255 zerostr,tstr;
  Integer padcnt;
  Boolean alphaf;

  for (i=len(code);i>0;i=i-1) begin
    c = Mid(code,i-1,1);
    if ((asc(c)<asc("0")) or (asc(c)>asc("9"))) then begin//if it is 0, next number for 0123 will be 124
      alphaf = true;
      goto L10NextSerialNumberWithPad;
    end;
  end;
L10NextSerialNumberWithPad:;  
  for (j=0;j<i;j=j+1) begin
    pre = pre & Mid(code,j,1);
  end; 
  for (j=i;j<=len(code);j=j+1) begin
    suff = suff & Mid(code,j,1);
  end;
  if (alphaf==false) then begin
    if (i==0) then begin
      pre = suff; 
      suff = "";
    end;
    padcnt = len(suff);
    if (padcnt==0) then begin 
      padcnt = 1; 
      padcnt = padcnt + extrapad - 1; 
    end else begin
      padcnt = padcnt + extrapad;
    end;
  end else begin  
    padcnt = len(suff);
    if (padcnt==0) then begin 
      padcnt = 1; 
      padcnt = padcnt + extrapad - 1; 
    end else begin
      padcnt = padcnt + extrapad;
    end;
  end;
  if (padcnt<0) then begin
    padcnt = 0;
  end;
  t = StringToVal(suff,M40Val);
  t = t + 1;
  tstr = ValToString(t,M40Val,"","",0);  
  M4PadString(tstr,padcnt,"0",true,suff);
  next = pre & suff;
  if (next=="0") then begin next = "1"; end;
  if (next=="") then begin next = "1"; end;
  if (nonblank(zerostr)) then begin
    suff = next;
    next = zerostr & suff;
  end;
  RETURN;
END;

global
function string 255 NextSerialNumber(string artcode,string curserialnr,record SerNrTrackBlock SNrb)
BEGIN
  string 255 next,lastnr;
  Integer extrapad;
  
  lastnr = curserialnr;
  if (SNrb.SerNrLength<=0) then begin
    NextM4SerialNumber(lastnr,next);
  end else begin
    if (blank(lastnr)) then begin
      switch (SNrb.GenSerNumber) begin
        case 0: lastnr = "0";
        case 1: lastnr = artcode;
      end;
      if (SNrb.SerNrLength<0) then begin
        extrapad = 0;
      end else begin
        extrapad = SNrb.SerNrLength - len(lastnr);
      end;
      NextSerialNumberWithPad(lastnr,extrapad,next);
    end else begin
      NextM4SerialNumber(lastnr,next);
    end;    
  end;
  NextSerialNumber = next;
  RETURN;
END;

global
function Integer VIRowExists(record CYBlock CYb,record VIVc VIp,string accnumber,string vatcode,string taxtemplate,val rowsump,val q)
BEGIN
  Integer res;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean testf;
 
  res = -1;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(VIp,i,VIrw);
    testf = false;
    if (CYb.UseTaxTemplatesforTaxCalc==0) then begin
      if ((accnumber==VIrw.AccNumber) and (vatcode==VIrw.VATCode)) then begin
        testf = true;
      end;
    end else begin
      if ((accnumber==VIrw.AccNumber) and (taxtemplate==VIrw.TaxTemplateCode)) then begin
        testf = true;
      end;
    end;
    if (testf) then begin//TaxTemplateCode
      VIrw.Sum = VIrw.Sum + rowsump;
      VIrw.qty = VIrw.qty + q;
      MatRowPut(VIp,i,VIrw);
      res = i;
      goto LVIRowExists;
    end;
  end;  
LVIRowExists:; 
  VIRowExists = res; 
  RETURN;
END;

global
function Integer VIPRRowExists(record VIVc VIp,string prcode,string artcode,string vatcode,val rowsump,val q)
begin
  Integer res;
  row VIVc VIrw;
  Integer i,rwcnt;
 
  res = -1;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(VIp,i,VIrw);
    if ((vatcode==VIrw.VATCode) and (artcode==VIrw.Item) and (prcode==VIrw.PRCode)) then begin
//TaxTemplateCode    
      VIrw.Sum = VIrw.Sum + rowsump;
      VIrw.qty = VIrw.qty + q;
      MatRowPut(VIp,i,VIrw);
      res = i;
      goto LVIPRRowExists;
    end;
  end;  
LVIPRRowExists:; 
  VIPRRowExists = res; 
  return;
end;

global
function Boolean PUQtyInvoiced(LongInt PUNr,LongInt PURow,LongInt POSerNr,var val puqtyinvd)
begin
  Boolean res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found,testf;
  
  puqtyinvd = blankval;
  if (POSerNr>0) then begin
    found = true;
    VIr.POSerNr = POSerNr;
    while (LoopKey("POSerNr",VIr,1,found)) begin
      if (VIr.POSerNr!=POSerNr) then begin found = false; end;
      if (found) then begin
        testf = true;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (PUNr>0) and (PURow>=0) then begin
              if (VIrw.PUNr==PUNr) and (VIrw.PURow==PURow) then begin
                if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                  puqtyinvd = puqtyinvd - VIrw.qty;
                end else begin
                  puqtyinvd = puqtyinvd + VIrw.qty;
                end;
                res = true;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  PUQtyInvoiced = res;
  return;
end;

/*
function Boolean POQtyInvoiced(LongInt POSerNr,LongInt RowPOSerNr,LongInt PORow,var val puqtyinvd)
begin
  Boolean res;
  record POVc POr;
  row POVc POrw;
  
  puqtyinvd = blankval;
  if (PORow>=0) then begin
    if (RowPOSerNr>0) then begin
      POr.SerNr = RowPOSerNr;
    end else begin
      POr.SerNr = POSerNr;
    end;
    if (ReadFirstMain(POr,1,true)) then begin
      MatRowGet(POr,PORow,POrw);
      puqtyinvd = POrw.Invd;    
      if (POrw.Invd!=0) then begin
        res = true;
      end;
    end;
  end;
  POQtyInvoiced = res;
  return;
end;
*/

function Boolean POQtyInvoiced(LongInt PUNr,LongInt PURow,LongInt POSerNr,var val puqtyinvd,var val powopuqtyinvd)
begin
  Boolean res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found,testf,purowf;
  
  puqtyinvd = blankval;
  powopuqtyinvd = blankval;
  if (POSerNr>0) then begin
    found = true;
    VIr.POSerNr = POSerNr;
    while (LoopKey("POSerNr",VIr,1,found)) begin
      if (VIr.POSerNr!=POSerNr) then begin found = false; end;
      if (found) then begin
        testf = true;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            purowf = false;
            if (PUNr>0) and (PURow>=0) then begin
              if (VIrw.PUNr==PUNr) and (VIrw.PURow==PURow) then begin
//              if (VIrw.PUNr>0) and (VIrw.PURow>=0) then begin
                if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                  puqtyinvd = puqtyinvd - VIrw.qty;
                end else begin
                  puqtyinvd = puqtyinvd + VIrw.qty;
                end;
                res = true;
                purowf = true;
              end;
            end;
            if (purowf==false) then begin
              if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
                powopuqtyinvd = powopuqtyinvd - VIrw.qty;
              end else begin
                powopuqtyinvd = powopuqtyinvd + VIrw.qty;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  POQtyInvoiced = res;
  return;
end;

function Boolean POQtyOrdered(LongInt POSerNr,LongInt RowPOSerNr,LongInt PORow,var val poqtyord)
begin
  Boolean res;
  record POVc POr;
  row POVc POrw;
  
  poqtyord = blankval;
  if (PORow>=0) then begin
    if (RowPOSerNr>0) then begin
      POr.SerNr = RowPOSerNr;
    end else begin
      POr.SerNr = POSerNr;
    end;
    if (ReadFirstMain(POr,1,true)) then begin
      MatRowGet(POr,PORow,POrw);
      poqtyord = POrw.Quant;    
      res = true;
    end;
  end;
  POQtyOrdered = res;
  return;
end;

function val FrieghtAlreadyInvoiced(LongInt PUNr,LongInt POSerNr)
begin
  val res;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  Boolean found;
  
  if (POSerNr>0) then begin
  found = true;
  VIr.POSerNr = POSerNr;
  while (LoopKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=POSerNr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(VIr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(VIr,i,VIrw);
        if (PUNr>0) then begin
          if (VIrw.PUNr==PUNr) then begin
            res = res + VIrw.Sum;
          end;
        end;
      end;
    end;
  end;
  end;
  FrieghtAlreadyInvoiced = res;
  return;
end;

global
procedure PUAddFreightRow(record PUVc PUp,record VIVc VIp,
                           record AccBlock ARb,record APAccBlock APb,record BaseCurBlock BCb,
                           var Integer nrwcnt)
begin
  row VIVc VIrw;
  string 255 tstr;
  val t,alreadyinvd;

  if (PUp.ShipCost!=0) then begin
    if (GetAccName(ARb.PUFreightAcc,tstr,60)==false) then begin
      goto LPUAddFreightRow;
    end;
    alreadyinvd = FrieghtAlreadyInvoiced(PUp.SerNr,VIp.POSerNr);
    ClearRow(VIp,VIrw,1);
    VIrw.AccNumber = ARb.PUFreightAcc;
    VIrw.Comment = tstr;
    if (ARb.BookPriceVar!=0) then begin
      VIrw.OrdRow = -8;
    end;

    VIrw.qty = PUp.SumQuant;
    VIrw.PUNr = PUp.SerNr;
    VIrw.Objects = "";
    VIrw.Sum = PUp.ShipCost;    
    switch (VIp.ExportFlag) begin
      case 0: VIrw.VATCode = APb.VATCodeDom;
      case 1: VIrw.VATCode = APb.VATCodeEU;
      case 3: VIrw.VATCode = APb.VATCodeEU;
      case 2: VIrw.VATCode = APb.VATCodeExp;
      case 4: VIrw.VATCode = APb.VATCodeExp;
    end;
    switch (VIp.ExportFlag) begin
      case 0: VIrw.TaxTemplateCode = APb.TaxTemplateCode;
      case 1: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 3: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 2: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
      case 4: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
    end;
    if (BCb.BaseCur1!=VIp.CurncyCode) then begin
      CurValToOtherCur(PUp.TransDate,BCb.BaseCur1,VIrw.Sum,VIp.CurncyCode,t,DefaultCurRoundOff);
      VIrw.Sum = t;
    end;
    VIrw.Sum = VIrw.Sum - alreadyinvd;
    if (VIrw.Sum>0) then begin
      MatRowPut(VIp,nrwcnt,VIrw);
      nrwcnt = nrwcnt + 1;
    end;
  end;  
LPUAddFreightRow:;
  return;
end;

procedure AddFreightRow(record PUVc PUp,row PUVc PUrw,Integer purow,record VIVc VIp,
                        record AccBlock ARb,record APAccBlock APb,record BaseCurBlock BCb,
                        var Integer nrwcnt)
BEGIN
  row VIVc VIrw;
  string 255 tstr;
  val t;
  
  if (PUrw.ShipCost!=0) then begin
    if (GetAccName(ARb.PUFreightAcc,tstr,60)==false) then begin
      goto LAddFreightRow;
    end;
    ClearRow(VIp,VIrw,1);
    VIrw.AccNumber = ARb.PUFreightAcc;
    VIrw.Comment = tstr;
    if (ARb.BookPriceVar!=0) then begin
      VIrw.OrdRow = -8;
    end else begin
      VIrw.Item = PUrw.ArtCode;
      VIrw.OrdRow = PUrw.OrdRow;
    end;
//      VIrw.PONr = PUp.PONr;

//    VIrw.qty = PUrw.Quant;, qty can not be here
    VIrw.PUNr = PUp.SerNr;
    VIrw.PURow = purow;
    VIrw.Objects = PUrw.Objects;
    VIrw.Sum = PUrw.Quant*PUrw.ShipCost;    
    switch (VIp.ExportFlag) begin
      case 0: VIrw.VATCode = APb.VATCodeDom;
      case 1: VIrw.VATCode = APb.VATCodeEU;
      case 3: VIrw.VATCode = APb.VATCodeEU;
      case 2: VIrw.VATCode = APb.VATCodeExp;
      case 4: VIrw.VATCode = APb.VATCodeExp;
    end;
    switch (VIp.ExportFlag) begin
      case 0: VIrw.TaxTemplateCode = APb.TaxTemplateCode;
      case 1: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 3: VIrw.TaxTemplateCode = APb.TaxTemplateCodeEU;
      case 2: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
      case 4: VIrw.TaxTemplateCode = APb.TaxTemplateCodeExp;
    end;
    if (BCb.BaseCur1!=VIp.CurncyCode) then begin
      CurValToOtherCur(PUp.TransDate,BCb.BaseCur1,VIrw.Sum,VIp.CurncyCode,t,DefaultCurRoundOff);
      VIrw.Sum = t;
    end;
    MatRowPut(VIp,nrwcnt,VIrw);
    nrwcnt = nrwcnt + 1;
  end;
LAddFreightRow:;  
  RETURN;
END;

global
updating function LongInt PastePUInVI(record PUVc PUp,var record VIVc VIp,var string errmsg,
                                      Boolean customsf,Boolean freightf,Boolean cost1f,Boolean cost2f,
                                      Boolean cost3f,Boolean cost4f,Boolean cost5f)
begin
  LongInt res;
  Integer i,rwcnt,vatcnt;
  row VIVc VIrw;
  row PUVc PUrw;  
  Integer nrwcnt,virow;
  record INVc INr;
  val net,sum,t,q;
  record CUVc VEr;
  record APAccBlock APb;
  record AccBlock ARb;
  record CostAccBlock CAb;
  record BaseCurBlock BCb;
  record VITBlock VITb;
  val from,to1,to2,base1,base2;
  string 255 tstr,viitgroup;
  val purowsum,puqinvd,puqord,powopuqtyinvd;
  record POVc POr;
  record POVc rPOr;
  record POVc oldPOr;
  row POVc POrw;
  Boolean vifound;
  record TaxMatrixVc TMr;
  record SMVc VATr;
  record CYBlock CYb;

  res = 0;
  BlockLoad(BCb);
  BlockLoad(ARb);
  BlockLoad(APb);
  BlockLoad(VITb);
  BlockLoad(CYb);
  BlockLoad(CAb);  
  VEr.Code = PUp.VECode;
  if (ReadFirstMain(VEr,1,true)==false) then begin 
    res = 1434;
    goto LPastePUInVI; 
  end;
  if (PUp.PONr>0) then begin
    POr.SerNr = PUp.PONr;
    if (ReadFirstMain(POr,1,true)==false) then begin 
      res = 1434;
      goto LPastePUInVI; 
    end else begin
      res = ValidatePORecord(POr,oldPOr,Rs_insert,10,false,errmsg);
// why to we need to validate PO when making PI from GR ? 
// 
      res = 0;
      if (res!=0) then begin
        goto LPastePUInVI; 
      end;
    end;
  end;
  GetAPAcc(VEr.Code,tstr);
  VIp.APAcc = tstr;
  VIp.POCQStatNr = -1;
  VIp.POSerNr = PUp.PONr;
  VIp.TransDate = PUp.TransDate;
  VIp.InvDate = PUp.TransDate;  
  VIp.VECode = PUp.VECode;
  VIp.VECode = PUp.VECode;
  if (PUp.PONr>0) then begin
    if (nonblank(POr.InvoiceToCode)) then begin
      VIp.OrgVE = POr.VECode;
      VIp.VECode = POr.InvoiceToCode;
    end;
  end;
//  VIp.VEName = PUp.VEName;
  VIVc_PasteVECode(VIp,0,true,false,tstr);
  while (MatRowCnt(VIp)>0) begin
    MatRowDelete(VIp,0);
  end;
  VIp.CurncyCode = PUp.CurncyCode;
  VIp.LangCode = VEr.LangCode;
//  VIp.PRCode = VEr.VEInvoiceToCode;
  VIp.VATNr = VEr.VATNr;
  VIp.POCQStatNr = -1;
  VIp.PayDeal = "";
  VIp.BranchID = PUp.BranchID;
  if (blank(VIp.BranchID)) then begin
    VIp.BranchID = POr.BranchID;
  end;
  VIp.FrRate = PUp.FrRate;
  VIp.ToRateB1 = PUp.ToRateB1;
  VIp.ToRateB2 = PUp.ToRateB2;
  VIp.BaseRate1 = PUp.BaseRate1;
  VIp.BaseRate2 = PUp.BaseRate2;

  VIp.VATFrRate = PUp.FrRate;
  VIp.VATToRateB1 = PUp.ToRateB1;
  VIp.VATToRateB2 = PUp.ToRateB2;
  VIp.VATBaseRate1 = PUp.BaseRate1;
  VIp.VATBaseRate2 = PUp.BaseRate2;
  VIp.NoTAXonVAT = PUp.NoTAXonVAT;
  if ((APb.UpdBaseRate!=0) or (APb.UpdForeginRate!=0)) then begin
    GetFullCurncyRate(VIp.CurncyCode,VIp.TransDate,from,to1,to2,base1,base2);
    if (APb.UpdBaseRate!=0) then begin
      VIp.BaseRate1 = base1;
      VIp.BaseRate2 = base2;
    end;
    if (APb.UpdForeginRate!=0) then begin
      VIp.FrRate = from;
      VIp.ToRateB1 = to1;
      VIp.ToRateB2 = to2;
    end;
  end;
  VIp.PayDeal = POr.PayDeal;
  if (blank(VIp.PayDeal)) then begin 
    VIp.PayDeal = VEr.VEPayDeal;
  end;
  VIp.ExportFlag = VEr.ExportFlag;
  if (APb.APUseObj!=0) then begin
    VIp.Objects = PUp.Objects;
    if (blank(VIp.Objects)) then begin
      VIp.Objects = VEr.VEObjects;
    end;
  end;
  VIp.POCOSerNr = PUp.POCOSerNr;
  rwcnt = MatRowCnt(PUp);
  nrwcnt = 0;
  ClearRow(VIp,VIrw,1);
  for (i=0;i<rwcnt;i=i+1) begin  
    MatRowGet(PUp,i,PUrw);
    ClearRow(VIp,VIrw,1);
    POQtyOrdered(PUp.PONr,PUrw.PONr,PUrw.OrdRow,puqord);
    vifound = POQtyInvoiced(PUp.SerNr,i,PUp.PONr,puqinvd,powopuqtyinvd);
    if (vifound) then begin
      q = PUrw.Quant - puqinvd;
    end else begin
      if (VITb.VIBasedOnPU==0) then begin
        vifound = POQtyInvoiced(PUp.PONr,PUrw.PONr,PUrw.OrdRow,puqinvd,powopuqtyinvd);
        if (((PUrw.PONr>0) or (PUp.PONr>0)) and (PUrw.OrdRow>=0)) then begin
          q = puqord - puqinvd;
        end else begin
          q = PUrw.Quant - puqinvd;
        end;
      end else begin
        q = PUrw.Quant - puqinvd;
      end;
    end;
    if (PUrw.Quant>q) then begin
      PUrw.Quant = q;
    end;
    q = PUrw.Quant;
    VIrw.VATCode = PUrw.VATCode;
    if ((PUrw.PONr>0) and (PUrw.OrdRow>=0)) then begin
      VIrw.PONr = PUrw.PONr;
      VIrw.OrdRow = PUrw.OrdRow;
      if (vifound==false) and (VITb.VIBasedOnPU==0) then begin
        rPOr.SerNr = PUrw.PONr;
        if (ReadFirstMain(rPOr,1,true)) then begin 
          if (PUrw.OrdRow>=0) then begin
            MatRowGet(rPOr,PUrw.OrdRow,POrw);
            if (q>(POrw.Quant-POrw.Invd)) then begin
              q = POrw.Quant - POrw.Invd; //inst it done above ? 
            end;
          end;
        end;
      end;
      if (q>0) then begin 
        VIrw.Item = PUrw.ArtCode;
        VIrw.qty = q;
        VIrw.PUNr = PUp.SerNr;
        VIrw.PURow = i;
        VIrw.Objects = PUrw.Objects;
        VIrw.SerialNr = PUrw.SerialNr;
        if (PUrw.PONr>0) then begin
          VIrw.PRCode = rPOr.PRCode;
        end else begin
          VIrw.PRCode = POr.PRCode;
        end;
      end;
    end else begin
      if (vifound==false) and (VITb.VIBasedOnPU==0) then begin
        if (PUrw.OrdRow>=0) then begin
          MatRowGet(POr,PUrw.OrdRow,POrw);
          if (q>(POrw.Quant-POrw.Invd)) then begin
            q = POrw.Quant - POrw.Invd;
          end;
        end;
      end;
      if (q>0) then begin 
        VIrw.OrdRow = -2; // Row comes from Order, but is not connected to a specific row 
        if (VITb.TransferItems==2) or (PUrw.StockType==kStockTypeConsigment) then begin
          VIrw.Item = PUrw.ArtCode;
          VIrw.qty = q;
          VIrw.OrdRow = PUrw.OrdRow;
          VIrw.PUNr = PUp.SerNr;
          VIrw.PURow = i;
          VIrw.Objects = PUrw.Objects;
          VIrw.SerialNr = PUrw.SerialNr;//??
          if (PUrw.PONr>0) then begin
            VIrw.PRCode = rPOr.PRCode;
          end else begin
            VIrw.PRCode = POr.PRCode;
          end;
        end;
        if (PUrw.StockType!=kStockTypeConsigment) then begin
          if (VITb.TransferItems==1) then begin
            VIrw.OrdRow = PUrw.OrdRow;
            VIrw.Item = PUrw.ArtCode;
            if (PUrw.PONr>0) then begin
              VIrw.PRCode = rPOr.PRCode;
            end else begin
              VIrw.PRCode = POr.PRCode;
            end;
            VIrw.qty = q;
            
            purowsum = PUrw.Quant*PUrw.UPrice;
            if (PUrw.PONr>0) or (PUp.PONr>0) then begin
              purowsum = PUrw.Quant*PUrw.UPrice;
            end;
            sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
//TaxTemplateCode            
            if (PUp.InclVAT!=0) then begin
              sum = purowsum - sum;
            end else begin
              sum = purowsum;
            end;  

            virow = VIPRRowExists(VIp,VIrw.PRCode,VIrw.Item,VIrw.VATCode,sum,q);
            if (virow==-1) then begin
              if (nonblank(VIrw.AccNumber)) then begin
                VIrw.PUNr = PUp.SerNr;
              end;
            end else begin
              goto LSKIPROW;
            end;
          end;
          if (VITb.TransferItems==0) then begin
            VIrw.qty = q;
            purowsum = PUrw.Quant*PUrw.UPrice;
            if (PUrw.PONr>0) or (PUp.PONr>0) then begin
              purowsum = PUrw.Quant*PUrw.UPrice;
            end;
            sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
            if (PUp.InclVAT!=0) then begin
              sum = purowsum - sum;
            end else begin
              sum = purowsum;
            end;  
            GetPurchaseControlAcc(PUrw.CredAcc,CAb.ItemGroupAccounts,PUrw.ArtCode,ARb,VEr.AccCost,VIrw.AccNumber,PUp.VECode);
            GetAccName(VIrw.AccNumber,VIrw.Comment,60);
            virow = VIRowExists(CYb,VIp,VIrw.AccNumber,VIrw.VATCode,VIrw.TaxTemplateCode,sum,q);
            if (virow==-1) then begin
              if (nonblank(VIrw.AccNumber)) then begin 
                MatRowPut(VIp,nrwcnt,VIrw);
                VIrw.PUNr = PUp.SerNr;
//                nrwcnt = nrwcnt + 1;
              end;
            end else begin
              goto LSKIPROW;
            end;
          end;
        end;
      end;      
    end;
//TaxTemplateCode    
    VIrw.StockType = PUrw.StockType;
    if (blank(VIrw.VATCode)) then begin
      VIrw.VATCode = VEr.VEVATCode;
      VIrw.TaxTemplateCode = VEr.VETaxTemplateCode;
    end;
    if (blank(VIrw.VATCode)) then begin
      GetItemVATCode(PUrw.ArtCode,VEr.ExportFlag,tstr,false);
      VIrw.VATCode = tstr;
    end;  
    GetPurchaseControlAcc(PUrw.CredAcc,CAb.ItemGroupAccounts,PUrw.ArtCode,ARb,VEr.AccCost,tstr,PUp.VECode);
    VIrw.AccNumber = tstr;
    if (GetAccName(VIrw.AccNumber,tstr,60)) then begin end;
    VIrw.Comment = tstr;    
    purowsum = PUrw.Quant*PUrw.UPrice;
    if (PUrw.PONr>0) or (PUp.PONr>0) then begin
      purowsum = PUrw.Quant*PUrw.UPrice;
    end;
    sum = FindVAT(VIrw.VATCode,purowsum,PUp.InclVAT,PUp.NoTAXonVAT);
    if (PUp.InclVAT!=0) then begin
      sum = purowsum - sum;
    end else begin
      sum = purowsum;
    end;  
    VIrw.Sum = Round(sum,DefaultRoundMode);
    net = net + VIrw.Sum;
    if (PUrw.PONr>0) then begin
      VIrw.PRCode = rPOr.PRCode;
    end else begin
      VIrw.PRCode = POr.PRCode;
    end;
    
    if (nonblank(VIrw.Item)) then begin
      if (blank(viitgroup)) then begin
        if (ReadFirstItem(VIrw.Item,INr,true,true)) then begin
          viitgroup = INr.Group;
        end;
      end;    
    end;
    if (VIrw.Sum!=0) then begin
      VIrw.TaxTemplateCode = PUrw.TaxTemplateCode;
      UnpackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
      PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
      RowCalculateTaxMatrix_VIVc(VIp,nrwcnt,VIrw,0);
      MatRowPut(VIp,nrwcnt,VIrw);
      nrwcnt = nrwcnt + 1;         
    end;
LSKIPROW:;    
  end;  
//  PUAddFreightRow(PUp,VIp,ARb,APb,BCb,nrwcnt);//setting for this is needed and customs, and PO do not add freight nor Customs to INvoice
  if (customsf) then begin
    AddExtraCostRow(ARb,BCb,VIp,"customs",PUp.CustomsCost,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (freightf) then begin  
    AddExtraCostRow(ARb,BCb,VIp,"freight",PUp.ShipCost,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost1f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost1",PUp.Cost1,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost2f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost2",PUp.Cost2,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost3f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost3",PUp.Cost3,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost4f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost4",PUp.Cost4,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  if (cost5f) then begin
    AddExtraCostRow(ARb,BCb,VIp,"pucost5",PUp.Cost5,PUp.InclVAT,VIp.ExportFlag,PUp.ExportFlag,PUp.CurncyCode,VATr,vatcnt);
  end;
  VICalcVals(VIp);
  VISumup(VIp,t);
  VIp.PayVal = -t;
  VIp.PayVal = Round(VIp.PayVal,DefaultRoundMode);
  VICalcEReb(VIp);
  if (VITb.autoVATflag!=0) then begin
    if (nonblank(VITb.autoVATVal)) then begin
      if ((VIp.ExportFlag==0) or (VIp.ExportFlag==3) or (VIp.ExportFlag==4)) then begin
        MulM4ProcVal(StringToVal(VITb.autoVATVal,M4Rate),VIp.PayVal,t);
        RoundVATSum(VIp.CurncyCode,VIp.PayDeal,"VIVc",t);      
        VIp.VATVal = t;
      end;
    end;
  end;
  if (nonblank(VEr.VEWarnText1)) then begin 
    MessageBox(0,VEr.VEWarnText1);
  end;
LPastePUInVI:;
  PastePUInVI = res;
  RETURN;
END;

function string 255 ReadLastSerialNr(record PUVc PUp,string artcode,Integer currow)
begin
  string 255 res;
  row PUVc PUrw;
  Integer i;

  for (i=currow-1;i>=0;i=i-1) begin
    MatRowGet(PUp,i,PUrw);
    if (PUrw.ArtCode==artcode) then begin
      if (nonblank(PUrw.SerialNr)) then begin
        res = PUrw.SerialNr;
        goto LReadLastSerialNr;
      end;
    end;
  end;
LReadLastSerialNr:;  
  ReadLastSerialNr = res;
  return;
end;

global
procedure AutoFillPUSerNr(var record PUVc PUp)
begin
  Integer i,rwcnt;
  row PUVc PUrw;
  string 255 lastnr,lastitem;
  record INVc INr;
  record SerNrTrackBlock SNrb;
  Integer extrapad;
  Boolean testf;
  string 255 lastnrstart,lastnrend;
  val q;
  
  rwcnt = MatRowCnt(PUp);
  if (rwcnt==0) then begin goto LAutoFillPUSerNr; end;
  BlockLoad(SNrb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    ReadFirstItem(PUrw.ArtCode,INr,true,true);
    if (INr.SerNrf==0) then begin
      goto L33AutoFillPUSerNr;
    end;
    if (blank(lastitem)) then begin
      lastitem = PUrw.ArtCode;
    end;
    if (blank(lastnr)) then begin
      if (blank(PUrw.SerialNr)) then begin
        ReadLastINSer(PUrw.ArtCode,lastnr);
      end else begin
        lastnr = PUrw.SerialNr;
        if (INr.SerNrf==1) then begin
          if (PUrw.Quant>1) then begin
            lastnrstart = FirstInRange(lastnr,60);
            lastnrend = LastInRange(lastnr,60);
            if (lastnr==lastnrend) then begin
              q = 1;
              while (q<PUrw.Quant) begin
                lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);
                q = q + 1;
              end;
            end else begin
              lastnr = lastnrend;
            end;
          end;
        end;
        goto L33AutoFillPUSerNr;
      end;
    end;
    if ((blank(PUrw.SerialNr)) and (PUrw.ArtCode==lastitem)) then begin
      if (INr.SerNrf==1) then begin
        testf = true;
        while (testf) begin
          lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);    
/*                 
          if (SerialNrEverinStock(PUrw.ArtCode,lastnr)==false) then begin
            PUrw.SerialNr = lastnr;
            testf = false;
          end;
*/          
          PUrw.SerialNr = lastnr;
          testf = false;
        end;
      end else begin
        lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);
        PUrw.SerialNr = lastnr;
      end;
    end else begin
      lastnr = PUrw.SerialNr;
      lastitem = PUrw.ArtCode;
      if (blank(lastnr)) then begin
        lastnr = ReadLastSerialNr(PUp,PUrw.ArtCode,i);
        if (blank(lastnr)) then begin
          ReadLastINSer(PUrw.ArtCode,lastnr);
        end;
      end else begin
        lastnr = PUrw.SerialNr;
        goto L33AutoFillPUSerNr;
      end;
      lastnr = NextSerialNumber(PUrw.ArtCode,lastnr,SNrb);      
      PUrw.SerialNr = lastnr;
    end;
    MatRowPut(PUp,i,PUrw);
L33AutoFillPUSerNr:;
  end;
LAutoFillPUSerNr:;
  return;
end;

global
procedure FindPUStockAcc(string vecode,record CostAccBlock CAb,string rowstockacc,string rowcontrolacc,string loccode,record INVc INr,Integer stocktype,var string stockacc,var string purchacc,Boolean findnewf)
begin
  record AccBlock ARb;
  string 255 tstr;
  record LocationVc Locr;

  BlockLoad(ARb);
  Locr.Code = loccode;
  if (ReadFirstMain(Locr,1,true)) then begin end;
  if (GetPUStockAcc(CAb.ItemGroupAccounts,rowstockacc,Locr.StockAcc,INr.Group,ARb,stocktype,stockacc,tstr,findnewf)==0) then begin end;  
  if (GetPUPControlAcc(loccode,vecode,CAb.ItemGroupAccounts,rowcontrolacc,INr.Group,ARb,stocktype,purchacc,tstr,findnewf)==0) then begin end;
  return;
end;

global
function Boolean PUVc_PasteArtCode(var record PUVc PUr,Integer rownr,var string warning,var string inwarn)
BEGIN
  Boolean res;
  record CostAccBlock CAb;
  record PIVc PIr;
  record INVc INr;
  row PUVc PUrw;
  Boolean chsum,chrsum;
  string 60 sz,msk,mskrep,pcstr,tstr;
  val t,p,s,t2;
  record SysFormatBlock SFb;
  string 200 varsubset,location;
  Boolean infoundf;
  record RoundBlock Roundb;
  string 20 stockacc,purchacc;
  record LocationVc Locr;
  record MainStockBlock MSb;
  Boolean nomoreremotecalls,pifound;
  record TaxMatrixVc TMr;
  string 255 taxtemplatecode,vatcode,descstr;
  val price,reb;
  
  MatRowGet(PUr,rownr,PUrw); 
/*   
  infoundf = GetFirstItem(PUrw.ArtCode,INr);
  if (infoundf==false) then begin
    infoundf = ReadFirstItem(PUrw.ArtCode,INr,true,true);
    if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin INr.Code = PUrw.ArtCode; end;
  end;
*/
  infoundf = GetItemPurchasePriceDiscount(PUr.VECode,PUr.Location,PUr.TransDate,PUr.CurncyCode,PUrw.ArtCode,PUrw.Quant,
                                   PUr.Location,"","","",0,true,
                                   PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                                   INr,PIr,pifound,price,descstr,reb,vatcode,purchacc,nomoreremotecalls,taxtemplatecode);
  if (infoundf) then begin
    BlockLoad(SFb);
    BlockLoad(CAb);    
    BlockLoad(Roundb);    
    BlockLoad(MSb);
    Locr.Code = PUr.Location;
    if (blank(Locr.Code)) then begin
      Locr.Code = MSb.MainStock;
    end;
    ReadFirstMain(Locr,1,true);

    if (nonblank(INr.WarnText1)) then begin
      inwarn = INr.WarnText1;
    end;
    if (INr.ItemType!=kItemTypeStocked) then begin
      warning = USetStr(1301);
    end;
    pcstr = "";
    if (GetFirstPurchaseItem(PUrw.ArtCode,PUr.Location,PUr.VECode,PIr)) then begin
      if (PIr.CurncyCode==PUr.CurncyCode) then begin
        PUrw.UPrice = PIr.PurPrice;
        p = PIr.PurPrice;
      end else begin
        CurValToOtherCur(PUr.TransDate,PIr.CurncyCode,PIr.PurPrice,PUr.CurncyCode,t,GetCostRoundMode(Roundb));
        PUrw.UPrice = t;  
        p = PUrw.UPrice;
      end;          
      PUrw.CountryOfOrg = PIr.OrgCountry;
      PUrw.CustomsCost = PIr.PurchaseCost;
      PUrw.VEItemCode = PIr.VEItemCode;
      PUrw.VEUnit = PIr.VEUnit;
      PUrw.CountryOfOrg = PIr.OrgCountry;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
    end else begin
      PUrw.Spec = INr.Name;
      PUrw.UPrice = INr.InPrice;
      p = INr.InPrice;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
      p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,GetCostRoundMode(Roundb));
    end; 
    PUrw.VATCode = PUr.VEVATCode;    
    if (blank(PUrw.VATCode)) then begin
      GetItemVATCode(PUrw.ArtCode,PUr.ExportFlag,tstr,false);
      PUrw.VATCode = tstr;
    end;
    PUrw.TaxTemplateCode = FillupTaxMatrix(1,PUr.BranchID,PUr.VECode,"","",taxtemplatecode,TMr);
    PUrw.Coefficient = INr.UnitCoefficient;
    PUrw.InPrice = INr.InPrice;
    PUrw.ArtCode = INr.Code;
    PUrw.Spec = INr.Name;
    PUrw.Objects = FindINObjects(INr.Objects,INr.Group);
    PUrw.UPrice = p;
    PUrw.UnitXval = INr.Width;
    PUrw.UnitYval = INr.Height;
    PUrw.UnitZval = INr.Depth;
    PUrw.UnitCode = INr.Unittext;
    location = PUrw.Location;
    if (blank(location)) then begin
      location = PUr.Location;
    end;
    if (Locr.RequirePos!=0) then begin
      PUrw.PosCode = Locr.WHMDefPUPosCode;
    end;

    t2 = MulRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,GetCostRoundMode(Roundb));
    PUCalcPerc(t2,PUrw.CustomsCost,t2);
    pcstr = ValToString(t2,M45Val,SFb.thousSep,SFb.decimalPt,0);
    PUrw.CustomsCost = pcstr;
    PUrw.BasePrice = INr.UPrice1;
    tstr = INr.ExtraCost;
    PUrw.Extra = tstr;
    PUrw.PIFactor = PIr.PIFactor;
    PUrw.StockType = PIr.DefStockType;
    if (PUrw.PIFactor!=0) then begin
      PUrw.UPrice = PUrw.UPrice/PUrw.PIFactor;
//      PUrw.BasePrice = PUrw.BasePrice/PUrw.PIFactor;
//BasePrice effected by Supplier Unit ? 
    end;
    DivPIFactor(PUrw.Quant,PUrw.PIFactor,t);
    PUrw.VEQuant = t;
    
    if (blank(PUrw.Location)) then begin
      FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUr.Location,INr,PUrw.StockType,stockacc,purchacc,true);
    end else begin
      FindPUStockAcc(PUr.VECode,CAb,PUrw.CostAcc,PUrw.CredAcc,PUrw.Location,INr,PUrw.StockType,stockacc,purchacc,true);
    end;
    PUrw.CostAcc = stockacc;
    PUrw.CredAcc = purchacc;

    PUrw.SuppSerialNr = INr.SuppSerialNr;
    PUrw.MajStoneDet = INr.MajStoneDet;
    PUrw.Colour = INr.Colour;
    PUrw.Clarity = INr.Clarity;
    PUrw.Cert = INr.Cert;
    PUrw.MinStoneDet = INr.MinStoneDet;
    PUrw.Metal = INr.Metal;
    PUrw.RowWeight = INr.RowWeight;
    PUrw.Size = INr.Size;
    PUrw.Length = INr.Length;

    PUrw.WatchBrand = INr.WatchBrand;
    PUrw.StyleName = INr.StyleName;
    PUrw.WatchMetal = INr.WatchMetal;
    PUrw.Movement = INr.Movement;
    PUrw.BrcStr = INr.BrcStr;
    PUrw.Gender = INr.Gender;
    PUrw.Other = INr.Other;
    PUrw.Other2 = INr.Other2;

    PackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
    MatRowPut(PUr,rownr,PUrw);
    chrsum = true;
    res = true;
  end else begin
    if (nonblank(PUrw.ArtCode)) then begin
      warning = USetStr(1120) & PUrw.ArtCode;
    end;
  end;
  if (chrsum) then begin
    PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUr.InclVAT,PUr.NoTAXonVAT,PUrw.Extra,PUr.CurncyCode,
                    PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                    PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,PUrw.Quant,s,PUrw.VATCode,PUr.ExportFlag);
    PUrw.CostPrice = p;
    PUrw.Sum = s;
    chsum = true;
  end;
  MatRowPut(PUr,rownr,PUrw);    
  if (chsum) then begin
    PUSumUp(PUr);
  end;
LPUVc_PasteArtCode:; 
  PUVc_PasteArtCode = res;
  RETURN;
END;
      
global
procedure PUVc_InclVATButtonAction(var record PUVc PUp)
BEGIN    
  row PUVc PUrw;
  val bas,s;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,PUrw.Extra,PUp.CurncyCode,
                    PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                    PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,bas,PUrw.Quant,s,PUrw.VATCode,PUp.ExportFlag);
    PUrw.CostPrice = bas;
    PUrw.Sum = s;
    MatRowPut(PUp,i,PUrw);
  end;
  PUSumUp(PUp);
  RETURN;
END;
      
global
function Integer PUVc_PastePONr(var record PUVc PUp,Integer rownr)
BEGIN
  row PUVc PUrw;
  record POVc POr;
  Integer retval;
  
  MatRowGet(PUp,rownr,PUrw);
  if (PUrw.PONr>0) then begin
    retval = GetPO(PUrw.PONr,POr,PUp.VECode,false);
  end;
  PUVc_PastePONr = retval;
  RETURN;
END;

procedure AddToSkiposArray(string poscode,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i;
  
  if (blank(poscode)) then begin goto LAddToSkiposArray; end;
  for (i=0;i<acnt;i=i+1) begin
    if (askippos[i]==poscode) then begin
      goto LAddToSkiposArray;
    end;
  end;
  askippos[acnt] = poscode; 
  acnt = acnt + 1;
LAddToSkiposArray:;  
  RETURN;
END;

procedure PrepareSkiposArray(record PUVc PUr,var Array string askippos,var Integer acnt)
BEGIN
  row PUVc PUrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    AddToSkiposArray(PUrw.PosCode,askippos,acnt);
    AddToSkiposArray(PUrw.ToPosCode,askippos,acnt);
  end;
  RETURN;
END;

global
function Boolean IsQtyAllowed_QtyonPallet(val Quant,string artcode)
BEGIN
  Boolean res;
  record INVc INr;
  Boolean itemfound;
  
  res = true;
  itemfound = GetFirstItem(artcode,INr);
  if (itemfound==false) then begin
    itemfound = ReadFirstItem(artcode,INr,true,false);
  end;
  if ((itemfound) and (INr.QtyonPallet>0)) then begin
    if ((Quant/INr.QtyonPallet)>78) then begin
      res = false;
    end;
  end;
  IsQtyAllowed_QtyonPallet = res;
  RETURN;
END;

global
function Integer PUVc_PasteQuant(var record PUVc PUr,Integer rownr)
BEGIN
  Integer res,i;
  row PUVc PUrw,orgPUrw;
  row PUVc palletPUrw;
  val p,s;
  Boolean chsum,testf,itemfoundf;
  record MainStockBlock MainStockRec;
  record INVc INr;
  val orgquant;
  string 255 tstr,tstr2;
  Integer lrownr;
  Array string 20 askippos;
  Integer acnt;
  record LocationVc LocRec;
  val qtyonpallet,defposhight;
  val fr,to1,to2,br1,br2;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  LocRec.Code = PUr.Location;
  if (blank(LocRec.Code)) then begin 
    BlockLoad(MainStockRec);
    LocRec.Code = MainStockRec.MainStock;
  end;
  ReadFirstMain(LocRec,1,true);
  switch (PUr.PUFromPORate) begin
    case kPURateFromPrepayment:
      if (PUr.PONr>0) then begin
        PUSumUp(PUr);
        if (CalculateOPPrepaymentAvgRate(PUr,PUr.PONr,PUr.TotUPrice,fr,to1,to2,br1,br2)) then begin
          PUr.FrRate = fr;
          PUr.ToRateB1 = to1; 
          PUr.ToRateB2 = to2;
          PUr.BaseRate1 = br1;
          PUr.BaseRate2 = br2;
        end;
      end;
  end;

  res = 0;      
  lrownr = rownr;
  MatRowGet(PUr,lrownr,PUrw);
  itemfoundf = ReadFirstItem(PUrw.ArtCode,INr,true,true);
  if (nonblank(PUrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,false,PUrw.ArtCode,PUrw.SerialNr,PUrw.Quant)) then begin
      MatRowPut(PUr,lrownr,PUrw);
      MatRowGet(PUr,lrownr,PUrw);
    end;
  end;

  CopyRow(PUr,PUrw,orgPUrw);
  orgquant = orgPUrw.Quant;
LPUVc_PasteQuantAGAIN:;  
  if (LocRec.RequirePos!=0) then begin    
    PrepareSkiposArray(PUr,askippos,acnt);
    
    if (itemfoundf) then begin
      qtyonpallet = INr.QtyonPallet + (INr.QtyonPallet*20)/100;
      if (nonblank(INr.DefPalletItem)) then begin
        if (INr.QtyonPallet>0) then begin
          if ((PUrw.Quant/INr.QtyonPallet)>100) then begin 
            res = 1733;
            goto LPUVc_PasteQuant;
          end;
          if (PUrw.Quant>INr.QtyonPallet) then begin
            if (PUrw.Quant<=qtyonpallet) then begin
              if (PUrw.Quant>=qtyonpallet) then begin
                PUrw.Quant = qtyonpallet;
              end;
            end else begin
              PUrw.Quant = INr.QtyonPallet;
            end;
          end;
        end;
      end;
    end;
  end;
  DivPIFactor(PUrw.Quant,PUrw.PIFactor,p);
  PUrw.VEQuant = p;
  CalculatePURowSum(PUrw.Quant,PUrw.UPrice,PUrw.Extra,PUrw.CostPrice,PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,false,PUr.CurncyCode,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2);

  PUrw.Sum = p;
  chsum = true;
  if (blank(PUrw.PosCode)) then begin 
    if (LocRec.RequirePos!=0) then begin
      PUrw.PosCode = LocRec.WHMDefPUPosCode; 
    end;
  end;
  if (LocRec.RequirePos!=0) then begin    
    if (blank(PUrw.ToPosCode)) then begin
      defposhight = INr.DefPosHeight;
      if (defposhight==0) then begin
        defposhight = INr.PalletHeight + 3; 
      end;
      PUrw.ToPosCode = FindFreePositionInLocArea_ExcludePositionFromArray(LocRec.Code,INr.LocArea,defposhight,INr,LocRec.WHMHighestPosCodeFirst,askippos,acnt);
    end;
  end;
  MatRowPut(PUr,lrownr,PUrw);    
  if (PUDchrsum(PUr,lrownr)) then begin
  end;
  if (LocRec.RequirePos!=0) then begin
    if (nonblank(INr.DefPalletItem)) then begin
      lrownr = lrownr + 1;
      ClearRow(PUr,palletPUrw,1);
      palletPUrw.PosCode = PUrw.PosCode;
      palletPUrw.ToPosCode = PUrw.ToPosCode;
      palletPUrw.ArtCode = INr.DefPalletItem;
      palletPUrw.Quant = 1;
      palletPUrw.MotherPURow = lrownr;
      MatRowInsert(PUr,lrownr,palletPUrw); 
      testf = PUVc_PasteArtCode(PUr,lrownr,tstr,tstr2);       
    end;
    lrownr = lrownr + 1;
    orgquant = orgquant - PUrw.Quant;
    if (orgquant>0) then begin
      CopyRow(PUr,orgPUrw,PUrw);
      PUrw.Quant = orgquant;
      goto LPUVc_PasteQuantAGAIN;
    end;
  end;    
LPUVc_PasteQuant:; 
//  PUSetShipCost(PUr,2);// why RowCost1 works difrent than and other RowCost and difrnet than on PO ? 
  PURecalcCost(PUr);
  PUSumUp(PUr);
  PUVc_PasteQuant = res;
  RETURN;
END;

global
procedure RefillPURows(var record PUVc PUp)
BEGIN
  Integer rwcnt,i;
  Integer oldrwcnt;
  row PUVc PUrw;
  row PUVc newPUrw;
  record INVc INr;
  record MainStockBlock MSb;
  val remn,pv,sv;
  Integer nrwcnt;
  Boolean firstf;
  
  BlockLoad(MSb);
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    oldrwcnt = MatRowCnt(PUp);
    MatRowGet(PUp,i,PUrw);
    if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
      if (nonblank(INr.DefPalletItem)) then begin        
        if (INr.QtyonPallet>0) then begin
          if ((PUrw.Quant/INr.QtyonPallet)>100) then begin
            MessageBox(1733,"");
          end else begin    
            if (PUVc_PasteQuant(PUp,i)==0) then begin end;
            rwcnt = MatRowCnt(PUp);
            i = i + (rwcnt - oldrwcnt);
          end;
        end;
      end;
    end;
  end;

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    if ((MSb.NoSerOnPU==0) and (PUrw.Quant>1)) then begin
      if (ReadFirstItem(PUrw.ArtCode,INr,true,true)) then begin
        if (INr.SerNrf==1) then begin
          firstf = true;
          nrwcnt = i;
          remn = PUrw.Quant;
          while (remn>0) begin
            if (rwcnt>=200) then begin
              goto LRefillPURows;
            end;
            CopyRow(PUp,PUrw,newPUrw);
            
            newPUrw.Quant = 1;
            remn = remn - 1;
            if (CharacterMatch(newPUrw.CustomsCost,"%",len(newPUrw.CustomsCost))==false) then begin
              newPUrw.CustomsCost = StringToVal(newPUrw.CustomsCost,M4Val)/PUrw.Quant;
            end;
            if (CharacterMatch(newPUrw.ShipCost,"%",len(newPUrw.ShipCost))==false) then begin
              newPUrw.ShipCost = StringToVal(newPUrw.CustomsCost,M4Val)/PUrw.Quant;
            end;
            newPUrw.RowCost1 = newPUrw.RowCost1/PUrw.Quant;
            newPUrw.RowCost2 = newPUrw.RowCost2/PUrw.Quant;
            newPUrw.RowCost3 = newPUrw.RowCost3/PUrw.Quant;
            newPUrw.RowCost4 = newPUrw.RowCost4/PUrw.Quant;
            newPUrw.RowCost5 = newPUrw.RowCost5/PUrw.Quant;            

            PUCalcCostPrice(PUrw.ArtCode,newPUrw.UPrice,PUp.InclVAT,PUp.NoTAXonVAT,newPUrw.Extra,PUp.CurncyCode,
                            PUp.FrRate,PUp.ToRateB1,PUp.ToRateB2,PUp.BaseRate1,PUp.BaseRate2,
                            newPUrw.ShipCost,newPUrw.RowCost1,newPUrw.RowCost2,newPUrw.RowCost3,newPUrw.RowCost4,newPUrw.RowCost5,
                            newPUrw.CustomsCost,pv,newPUrw.Quant,sv,newPUrw.VATCode,PUp.ExportFlag);
            newPUrw.CostPrice = pv;                                        
            newPUrw.Sum = sv;          
            if (firstf) then begin
              MatRowPut(PUp,nrwcnt,newPUrw);
              firstf = false;
            end else begin
              MatRowInsert(PUp,nrwcnt,newPUrw);
            end;
            nrwcnt = nrwcnt + 1;
          end;
          rwcnt = MatRowCnt(PUp);
          i = nrwcnt;
        end;
      end;
    end;
  end;
LRefillPURows:;  
  PUSumUp(PUp);
  RETURN;
END;

global
procedure PUDClassOnOpenWindowRemote(var record PUVc PUr,var Integer AcceptanceStatusFlag)
begin
  record AcceptanceRulesVc Acptr;
  record ActVc Actr;
  
  if (HasApprovals) then begin
    AcceptanceStatusFlag = PUApprovalStatus(PUr,Acptr);
  end;
  return;
end;