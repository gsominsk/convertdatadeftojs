external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external updating procedure StoreeShipTaxAuthReply(string,LongInt,string,string);
external updating procedure SMSWhenSHOK(LongInt,string,Integer);
external procedure GetCountryName(string,string,var string);
external function Boolean BulkSerialNos_CalculateQuantityAndSerialNr(record SerNrTrackBlock,Boolean,string,var string,var val);
external function Integer ArtCodeWAPerLocation(string);
external function val FindCostPrice_ReturnedGoods_FromSH(record CostAccBlock,record INVc,record RetVc,row RetVc,Integer,Integer);
external function val FindCostPrice_ReturnedGoods_FromSH_Source(record INVc,record RetVc,row RetVc,Integer,Integer,Integer);
external function roundmode SetRoundModeD(Integer);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val FindCostPriceWA(Integer,record INVc,string);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function val FindCostPrice_ReturnedGoods(record RetVc,row RetVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external procedure RetSumUp(var record RetVc);
external function Boolean PasteBatchSerItems(var string,var Date,var Integer,var val,record ORVc,Integer,var record SHVc,Integer,string,Integer,var Integer);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external function Boolean GetItemStatus(string,string,string,Integer,var val,var val,var val,var val,var val,var val,var val);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function val FindSerialNrQty(string,string,string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure FindBatchBestBeforeDate(string,string,var Date);
external procedure FindStockValueAtPosition(string,string,string,var record PISVc);
external function Integer CheckSerialStatus(string,string,var string);
external function val CalculateSerialNrQuantity(string,string,string,Boolean,val,val,val,val);
external procedure SHSumUp(var record SHVc);
external procedure CalcSHWeight(var record SHVc,Boolean);
external function Boolean RefillShipRow(var Array record StockMovVc,var Integer,var record SHVc,record SHVc,record INVc,var Integer,Integer,Integer,var array string,var array string,var array string,var array val,var Integer);
external procedure SerialNrDimensions(string,string,var val,var val,var val);

procedure SHChangeShip(record SHVc SHr,Integer rownr)
BEGIN
  row SHVc SHrw;
  record ORVc ORr;
  row ORVc ORrw;
  record MainStockBlock MainStockRec;
  record RoundBlock RoundRec;
  val t;

  BlockLoad(MainStockRec);
  MatRowGet(SHr,rownr,SHrw);
  if (MainStockRec.DelOrdQty==0) then begin
    if (SHrw.Ship>SHrw.Ordered) then begin
      MessageBox(1303,"");
    end;
  end;
  if (SHrw.Ship<0) then begin
    SHrw.Ship = 0;
  end;
  CalcSHWeight(SHr,true);
  BlockLoad(RoundRec);
  ORr.SerNr = SHr.OrderNr;
  if (ReadFirstMain(ORr,1,true)) then begin
    if ((SHrw.OrdRow<MatRowCnt(ORr)) and (SHrw.OrdRow>-1)) then begin
      MatRowGet(ORr,SHrw.OrdRow,ORrw);
      t = ORrw.Sum/ORrw.Quant;
      SHr.TAX1Sum = t * SHrw.Ship;
    end;
  end;  
  MatRowPut(SHr,rownr,SHrw);
  SHSumUp(SHr);  
  RETURN;          
END;

global
procedure SHVc_PasteSerialNr(var record SHVc SHp,Integer rownr,var string warning)
BEGIN
  row SHVc SHrw;
  string 255 tstr;
  val UnitXval,UnitYval,UnitZval;
  Date td;
  string 20 location;
  record INVc INr;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  warning = "";
  MatRowGet(SHp,rownr,SHrw);
  location = SHrw.Location;
  if (blank(location)) then begin
    location = SHp.Location;
  end;
  ReadFirstItem(SHrw.ArtCode,INr,true,true);
  if (nonblank(SHrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,true,SHrw.ArtCode,SHrw.SerialNr,SHrw.Ship)) then begin
      MatRowPut(SHp,rownr,SHrw);
      MatRowGet(SHp,rownr,SHrw);
    end;
  end;

  if ((SNrb.BulkSerialNos==0) or (InString(SHrw.SerialNr,":")==0)) then begin
    SerialNrDimensions(SHrw.ArtCode,SHrw.SerialNr,UnitXval,UnitYval,UnitZval);
    if (UnitXval!=0) then begin SHrw.UnitXval = UnitXval; end;
    if (UnitYval!=0) then begin SHrw.UnitYval = UnitYval; end;
    if (UnitZval!=0) then begin SHrw.UnitZval = UnitZval; end;
    if (CheckSerialStatus(SHrw.ArtCode,SHrw.SerialNr,tstr)==1) then begin
      warning = tstr;
    end;    
    SHrw.Ship = CalculateSerialNrQuantity(SHrw.ArtCode,SHrw.SerialNr,location,true,SHrw.UnitXval,SHrw.UnitYval,SHrw.UnitZval,SHrw.Ship);    
    FindBatchBestBeforeDate(SHrw.ArtCode,SHrw.SerialNr,td);
    SHrw.BestBefore = td;
//  CostPriceForGP(SHrw.ArtCode,SHrw.SerialNr,SHp.PriceList,SHp.CustCode,SHrw.BasePrice);
  end;
  if (SHrw.Ship>SHrw.Ordered) then begin SHrw.Ship = SHrw.Ordered; end;
  MatRowPut(SHp,rownr,SHrw);
  SHChangeShip(SHp,rownr);
  RETURN;
END;

global
procedure RefillShipment(var record SHVc SHr,record SHVc SH2r)
begin
  record INVc INr;
  Integer rwcnt,i;
  record SHVc dbSHr;
  row SHVc dbSHrw;
  row SHVc SH2rw;
  row SHVc SHrw;
  row SHVc tmpSHrw;
  Array record StockMovVc aStockMovr;
  Integer asmcnt;
  val remn,instock;
  Boolean firstf,testf,found;
  record MainStockBlock MSb;
  array string 40 aincode;
  array string 40 aloc;
  array string 40 aserialnr;
  array val aqty;
  Integer acnt;
  record SerBalVc SBr;
  vector val vsernrqty;
  
  acnt = 0;
  dbSHr.SerNr = SHr.SerNr;
  ReadFirstMain(dbSHr,1,true);
  BlockLoad(MSb);
  rwcnt = MatRowCnt(SHr);
  for (i=0;i<rwcnt;i=i+1) begin
    if (RefillShipRow(aStockMovr,asmcnt,SHr,SH2r,INr,i,rwcnt,1,aincode,aloc,aserialnr,aqty,acnt)) then begin end;
    MatRowGet(SHr,i,SHrw);
    if (INr.SerNrf==2) and (nonblank(SHrw.SerialNr)) then begin
      if (SHrw.Ship>=0) then begin
        ResetLoop(SBr);
        remn = 0;
        instock = 0;
        SBr.Item = SHrw.ArtCode;  
        SBr.Location = SHrw.Location;
        if (blank(SBr.Location)) then begin
          SBr.Location = SHr.Location;
        end;
        SBr.Serial = SHrw.SerialNr;
        if (nonblank(SBr.Location)) then begin
          if (ReadFirstKey("ItemSerial",SBr,3,true)) then begin
            if (SBr.Quant<=SHrw.InStock) then begin  
              instock = SBr.Quant;// in or out ? , should we be showing qty of batch nr  or total qty for that batch ? 
              remn = SBr.Quant;
            end;
          end else begin
          end;
        end else begin
          found = true;
          while (LoopKey("ItemSerial",SBr,2,found)) begin
            if (SBr.Item!=SHrw.ArtCode) then begin found = false; end;
            if (SBr.Serial!=SHrw.SerialNr) then begin found = false; end;
            if (found) then begin
              instock = instock + SBr.Quant;
              remn = remn + SBr.Quant;
            end;
          end;
        end;      
        SHrw.InStock = instock;
        SHrw.Ship = remn - vsernrqty[SHrw.SerialNr];
        if (SHrw.Ship>SHrw.Ordered) then begin
          SHrw.Ship = SHrw.Ordered;
        end;
        vsernrqty[SHrw.SerialNr] = vsernrqty[SHrw.SerialNr] + SHrw.InStock;
        MatRowPut(SHr,i,SHrw);
        MatRowGet(SHr,i,SHrw);
        instock = 0;
        remn = 0;
      end;
    end;
    if (SHrw.InStock<>0) then begin
      if (SHrw.InStock>=SHrw.Ordered) then begin
        testf = true;
        if (i<MatRowCnt(dbSHr)) then begin
          MatRowGet(dbSHr,i,dbSHrw);
          if (dbSHrw.Ship!=SHrw.Ship) then begin
            testf = false;
          end;
        end;

        if (testf) then begin
          if (SHrw.Ship>=SHrw.Ordered) or (SHrw.Ship<=SHrw.InStock) then begin
            SHrw.Ship = SHrw.Ordered;
          end;  
        end;
      end else begin
        switch (MSb.dontAllowOvership) begin
          case 1:
            if (SHrw.Ship>=SHrw.InStock) then begin
              SHrw.Ship = SHrw.InStock;        
            end;  
            if (SHrw.Ship<0) then begin
              SHrw.Ship = 0;
            end;        
          case 0: ;
          case 2: ;
        end;
      end;
      MatRowPut(SHr,i,SHrw);
    end else begin
      SHrw.SerialNr = "";
      MatRowPut(SHr,i,SHrw);
    end;
  end;
  
  rwcnt = MatRowCnt(SHr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHr,i,SHrw);
    remn = SHrw.Ship;
    if (ReadFirstItem(SHrw.ArtCode,INr,true,true)) then begin
      CopyRow(SHr,SHrw,tmpSHrw);
      if (INr.SerNrf==1) then begin
        if (SHrw.Ship>0) then begin
          firstf = true;
L10RefillShipment:;
          CopyRow(SHr,tmpSHrw,SHrw);
          SHrw.Ship = 1;
          SHrw.Ordered = 1;
          if (SHrw.InStock<=0) then begin
            SHrw.Ship = 0;
          end;
          SHrw.InStock = SHrw.InStock - instock;
          if (firstf) then begin
            MatRowPut(SHr,i,SHrw);
            firstf = false;
          end else begin
            MatRowInsert(SHr,i+1,SHrw);
          end;
          remn = remn - 1;
          if (remn>0) then begin
            instock = instock + 1;
            goto L10RefillShipment;
          end;
        end;
      end;
    end;     
  end;
  return;
end;

global
procedure SHVc_PastePosCode(var record SHVc SHp,Integer rownr)
begin
  row SHVc SHrw;
  row SHVc toSHrw;
  record PISVc PISr;
  record MainStockBlock MainStockRec;
  string 255 location;
  val rem;

  MatRowGet(SHp,rownr,SHrw);
  if (nonblank(SHrw.Location)) then begin
    location = SHrw.Location;
  end else begin
    location = SHp.Location;
    if (blank(location)) then begin
      BlockLoad(MainStockRec);
      location = MainStockRec.MainStock;
    end;
  end;  
  FindStockValueAtPosition(SHrw.ArtCode,location,SHrw.PosCode,PISr);
  if (SHrw.Ship>PISr.LeftQty) then begin
    rem = SHrw.Ship - PISr.LeftQty;
    SHrw.Ship = PISr.LeftQty;
    SHrw.Ordered = SHrw.Ship;
    MatRowPut(SHp,rownr,SHrw);
    CopyRow(SHp,SHrw,toSHrw);    
    toSHrw.PosCode = "";
    toSHrw.InStock = SHrw.InStock - SHrw.Ship;
    toSHrw.Ship = rem;
    toSHrw.Ordered = toSHrw.Ship;
    MatRowInsert(SHp,rownr+1,toSHrw);
  end else begin  
  end;
  return;
end;

global
function string 20 NextTransportSerNr(string filename,LongInt skipsh,string shipmode)
BEGIN
  string 20 res;
  record DMVc DMr;
  record SHVc SHr;
  string 255 oldser;
  string 255 tmpoffserno;
  Boolean found;
  Boolean TrHs,testf;
  
  
  res = "";
  DMr.Code = shipmode;
  if (ReadFirstMain(DMr,1,true)) then begin
    if (DMr.UseTransSerNr!=0)  then begin
      found = true;
    end;
  end;
  if (found) then begin
    if (filename=="SHVc") then begin
      if (nonblank(DMr.TranspSerStart)) then begin
        SHr.SerNr = 999999999;
        TrHs = true;
        while (LoopBackKey("SerNr",SHr,1,TrHs)) begin
          if (TrHs) then begin
            testf = true;
            if (SHr.SerNr==skipsh) then begin testf = false; end;
            if (testf) then begin
              oldser = SHr.TransportNumber;
              if (blank(oldser)) then begin
                res = DMr.TranspSerStart;
                goto LNextTransportSerNr;
              end;
              if (DMr.TranspSerStart>oldser) then begin
                oldser = DMr.TranspSerStart;
              end;  
              res = NextStrNumber(oldser,true);        
              tmpoffserno = res;
              if (len(tmpoffserno)<len(DMr.TranspSerEnd)) then begin
                M4PadString(tmpoffserno,len(DMr.TranspSerEnd),"0",true,tmpoffserno);  
              end;
              if (tmpoffserno>DMr.TranspSerEnd) then begin
                res = "";
              end;  
              TrHs = false;
            end;
          end;
        end;
      end;
    end;
  end;
LNextTransportSerNr:;
  NextTransportSerNr = res;  
  RETURN;
END;
global
procedure SHVc_PasteShipMode(var record SHVc SHp)
begin
  SHp.TransportNumber = NextTransportSerNr("SHVc",SHp.SerNr,SHp.ShipMode);
  return;
end;

global
procedure SplitRowSHDsmRemote(record SHVc prevSHr,var record SHVc SHr,Integer rownr)
BEGIN
  row SHVc frSHrw;
  row SHVc toSHrw;
  record INVc INr;
  string 20 location;
  Boolean insf;
  val t,t2;
  Integer i,rwcnt;
  row SHVc SHrw;

  MatRowGet(SHr,rownr,frSHrw);
  CopyRow(SHr,frSHrw,toSHrw);
  toSHrw.PosCode = "";
  if (ReadFirstItem(frSHrw.ArtCode,INr,true,true)) then begin end; 
  if ((INr.SerNrf==2) and (nonblank(frSHrw.SerialNr))) then begin
    toSHrw.SerialNr = "";
    location = frSHrw.Location;
    if (blank(location)) then begin
      location = SHr.Location;
    end;
    t = FindSerialNrQty(frSHrw.ArtCode,frSHrw.SerialNr,location);
    if (frSHrw.Ship>t) then begin frSHrw.Ship = t; end;
    MatRowPut(SHr,rownr,frSHrw);    
    if (frSHrw.Ordered>frSHrw.Ship) then begin
      toSHrw.Ship = frSHrw.Ordered - frSHrw.Ship;
      toSHrw.Ordered = frSHrw.Ordered - frSHrw.Ship;
      toSHrw.InStock = frSHrw.InStock - frSHrw.Ship;    
      insf = true;
    end;
  end else begin
    if (frSHrw.Ordered>frSHrw.Ship) then begin
      toSHrw.InStock = frSHrw.InStock - toSHrw.Ship;    
      toSHrw.Ship = frSHrw.Ordered - toSHrw.Ship;
      toSHrw.Ordered = toSHrw.Ship;
      insf = true;
    end;
  end;
  if (insf) then begin 
    t = 0;
    rwcnt = MatRowCnt(prevSHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(prevSHr,i,SHrw);
      if (SHrw.OrdRow==frSHrw.OrdRow) then begin
        t = t + SHrw.Ship;
      end;
    end;
    t2 = 0;
    rwcnt = MatRowCnt(SHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHr,i,SHrw);
      if (SHrw.OrdRow==frSHrw.OrdRow) then begin
        t2 = t2 + SHrw.Ship;
      end;
    end;
    t2 = t2 + toSHrw.Ship;
    //if (t2>t) then begin insf = false; end;
  end;
  if (insf) then begin
    MatRowInsert(SHr,rownr+1,toSHrw);
  end;
  RETURN;
END;

procedure RefillOvershipedSH(Integer mainrownr,var record SHVc SHr,record MainStockBlock MSb)
BEGIN
  record INVc INr;
  record ItemStatusVc ISr;
  row SHVc MainSHrw;
  row SHVc SHrw;
  Integer rownr;
  string 30 cursernr,mainlocation,mainserialnr;
  val remn,instock;
  val t,t2;
  Boolean newlinf,found;  
  Date td;
  record SerBalVc SBr;
  Integer keys;
  record ORVc ORr;
  Integer i,rwcnt;
  
  rownr = mainrownr;
  if (rownr>=0) then begin
    MatRowGet(SHr,rownr,MainSHrw);
    rwcnt = MatRowCnt(SHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHr,i,SHrw);
      if (SHrw.ArtCode==MainSHrw.ArtCode) then begin
        remn = remn + SHrw.Ship;
      end;
    end;
    ORr.SerNr = SHr.OrderNr;
    if (ReadFirstMain(ORr,1,true)) then begin
    end;
    INr.Code = MainSHrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.SerNrf==2) then begin
        if (remn==0) then begin
          remn = MainSHrw.Ship;
        end;
        if (nonblank(MainSHrw.Location)) then begin
          mainlocation = MainSHrw.Location;        
        end else begin
          mainlocation = SHr.Location;        
        end;
        if (blank(mainlocation)) then begin
          mainlocation = MSb.MainStock;        
        end;
        while (remn>0) begin
          if (rownr==mainrownr) then begin
            keys = 2;
            SBr.Item = MainSHrw.ArtCode;
            SBr.Location = mainlocation;
            if (nonblank(MainSHrw.SerialNr)) then begin
              keys = 3;
              SBr.Serial = MainSHrw.SerialNr;
            end;  
            if (ReadFirstMain(SBr,keys,true)) then begin      
              if (GetItemStatus(MainSHrw.ArtCode,mainlocation,"",0,t,t2,t2,t2,t2,t2,t2)) then begin end;
              FindStockValue(MainSHrw.ArtCode,mainlocation,ISr);
              if (ORr.Reserved==0) then begin
                t = t - ISr.RsrvQty;
              end;

              FindBatchBestBeforeDate(MainSHrw.ArtCode,MainSHrw.SerialNr,td);
              MainSHrw.BestBefore = td;
              MainSHrw.FIFO = blankval;
              MainSHrw.FIFORowVal = blankval;
              if (remn>SBr.Quant) then begin
                MainSHrw.Ship = SBr.Quant;
              end else begin
                MainSHrw.Ship = remn;
              end;
              MainSHrw.InStock = t;
              
              MatRowPut(SHr,rownr,MainSHrw); 
              mainserialnr = MainSHrw.SerialNr;
              instock = MainSHrw.InStock - MainSHrw.Ship;
              remn = remn - MainSHrw.Ship;
              if (remn>instock) then begin
                remn = instock;
              end;
              rownr = rownr + 1;
            end else begin
              remn = 0;
            end;
          end else begin
            SBr.Item = MainSHrw.ArtCode;
            SBr.Location = mainlocation;
            SBr.Serial = "";
            found = true;
            if (LoopMain(SBr,2,found)) then begin/*no reset Loop*/
              if ((SBr.Serial!=mainserialnr) and found) then begin
                ClearRow(SHr,SHrw,1);
                SHrw.SerialNr = SBr.Serial;
                SHrw.OrdRow = MainSHrw.OrdRow;
                SHrw.ArtCode = MainSHrw.ArtCode;
                SHrw.Spec = MainSHrw.Spec;
                SHrw.Objects = MainSHrw.Objects;
                SHrw.Recepy = MainSHrw.Recepy;
                SHrw.VARList = MainSHrw.VARList;
                SHrw.Location = MainSHrw.Location;
                SHrw.Source = MainSHrw.Source;
                SHrw.DespatchRowTime = MainSHrw.DespatchRowTime;
                SHrw.DespatchRowDate = MainSHrw.DespatchRowDate;
                FindBatchBestBeforeDate(SHrw.ArtCode,SHrw.SerialNr,td);
                SHrw.BestBefore = td;  
                SHrw.Ordered = MainSHrw.Ordered;
                SHrw.BasePrice = MainSHrw.BasePrice;
                SHrw.FIFO = blankval;
                SHrw.FIFORowVal = blankval;
                if (remn>SBr.Quant) then begin
                  SHrw.Ship = SBr.Quant;
                end else begin
                  SHrw.Ship = remn;
                end;
                SHrw.InStock = instock;
                remn = remn - SHrw.Ship; 
                instock = instock - SHrw.Ship;
                MatRowInsert(SHr,rownr,SHrw);
                rownr = rownr + 1;
                found = false;
              end;
            end else begin
              remn = 0;
            end;
          end;
        end;             
      end;
    end;
    rwcnt = MatRowCnt(SHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHr,i,SHrw);
      if (SHrw.Ship==0) then begin
        MatRowDelete(SHr,i);
        rwcnt = MatRowCnt(SHr);
        i = 0;
      end;
    end;
  end;    
  RETURN;
END;

global
procedure RefillSHRow(Integer arownr,var record SHVc SHr)
BEGIN
  record ORVc ORr;
  record INVc INr;
  record MainStockBlock MSb;
  row SHVc SHrw;
  row ORVc ORrw;
  Integer rownr,rownr2,ordrow,errmsg;
  string 30 cursernr;
  val remn;
  Boolean newlinf;  
  Date td;
  Date curbestbef,bb;
    
  rownr = arownr;
  BlockLoad(MSb);
  if (MSb.DelivSetBatch!=1) then begin 
    goto LRefillSHRow; 
  end;
  if (MSb.dontAllowOvership==1) then begin
    RefillOvershipedSH(rownr,SHr,MSb);
  end else begin
    if (rownr>=0) then begin
      MatRowGet(SHr,rownr,SHrw);
      INr.Code = SHrw.ArtCode;
      if (ReadFirstMain(INr,1,true)) then begin
        if (INr.SerNrf==2) then begin
          ORr.SerNr = SHr.OrderNr;
          if (SHrw.OrdRow>-1) then begin
          if (ReadFirstMain(ORr,1,true)) then begin
            ordrow = SHrw.OrdRow;
            MatRowGet(ORr,SHrw.OrdRow,ORrw);
//          remn = ORrw.Quant - ORrw.Shipd2;
            remn = SHrw.Ordered;
            cursernr = SHrw.SerialNr;
            curbestbef = SHrw.BestBefore;
LNEWLINE:;          
            if (newlinf) then begin          
              rownr = rownr + 1;
              ClearRow(SHr,SHrw,1);
              SHrw.OrdRow = ordrow;
              SHrw.ArtCode = ORrw.ArtCode;
              SHrw.Spec = ORrw.Spec;
              SHrw.Objects = ORrw.Objects;
              SHrw.SerialNr = cursernr;
              SHrw.BestBefore = curbestbef;
              SHrw.Recepy = ORrw.Recepy;
              SHrw.VARList = ORrw.VARList;
              SHrw.Location = ORrw.Location;
              SHrw.Source = ORrw.Source;
              SHrw.DespatchRowTime = ORrw.DespatchRowTime;
              if (nonblankdate(ORrw.DespatchRowDate)) then begin
                SHrw.DespatchRowDate = ORrw.DespatchRowDate;
              end else begin
                SHrw.DespatchRowDate = ORr.DespatchDate;
              end;  
              FindBatchBestBeforeDate(SHrw.ArtCode,SHrw.SerialNr,td);
              SHrw.BestBefore = td;
              SHrw.Ordered = remn;
              SHrw.InStock = blankval;
              SHrw.FIFO = blankval;
              SHrw.FIFORowVal = blankval;
              SHrw.Ship = SHrw.Ordered;
              SHrw.BasePrice = ORrw.Price;
              MatRowInsert(SHr,rownr,SHrw);
//              cursernr = "";
            end;
            rownr2 = rownr + 1;
            if (PasteBatchSerItems(cursernr,curbestbef,rownr2,remn,ORr,SHrw.OrdRow,SHr,rownr,MSb.MainStock,MSb.SortBatchOnBestBefore,errmsg)==false) then begin
              newlinf = true;
              goto LNEWLINE;
            end else begin
              newlinf = false;
            end; 
          end;  
          end;
        end;
      end;  
    end;  
  end;
LRefillSHRow:;  
  RETURN;
END;

global
function val NotOKedReturnForOR(LongInt ornr,Integer ordrow)
begin
  Boolean found;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  val res;
  Integer i,rwcnt;
  record RetVc Retr;
  row RetVc Retrw;
  record IVVc IVr;
  row IVVc IVrw;
  Boolean retfound;

  retfound = true;
  Retr.OrdNr = ornr;
  while (LoopKey("OrdNr",Retr,1,retfound)) begin
    if (Retr.OrdNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
      if (Retr.OKFlag==0) then begin
        rwcnt = MatRowCnt(Retr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Retr,i,Retrw);
          if (Retrw.OrdRow==ordrow) then begin
            res = res + Retrw.Quant;
          end;
        end;
      end;
    end;
  end;


  retfound = true;
  IVr.OrderNr = ornr;
  while (LoopKey("OrderNr",IVr,1,retfound)) begin
    if (IVr.OrderNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
//      if (IVr.UpdStockFlag!=0) and (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and (IVr.OKFlag==0) then begin
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and (IVr.OKFlag==0) then begin
        rwcnt = MatRowCnt(IVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.OrdRow==ordrow) then begin
            res = res + IVrw.Quant;
          end;
        end;
      end;
    end;
    
  end;
  NotOKedReturnForOR = res;
  return;
end;

global
function val BatchDeliveredForOR(LongInt ornr,Integer ordrow,string batchnr)
begin
  record SHVc SHr;
  row SHVc SHrw;
  Integer rwcnt,i;
  Boolean shfound;
  val res;
  
  res = 0;
  shfound = true;
  SHr.OrderNr = ornr;
  while (LoopKey("OrderKey",SHr,1,shfound)) begin
    if (SHr.OrderNr!=ornr) then begin
      shfound = false;
    end;
    if (shfound) then begin
      rwcnt = MatRowCnt(SHr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SHr,i,SHrw);
        if (SHrw.OrdRow==ordrow and SHrw.SerialNr==batchnr) then begin
          res = res + SHrw.Ship;
        end;
      end;
    end;
  end;  
  BatchDeliveredForOR = res;
  return;
end;

global
function val BatchReturnForOR(LongInt ornr,Integer ordrow,string batchnr)
begin
  Boolean found;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  val res;
  Integer i,rwcnt;
  record RetVc Retr;
  row RetVc Retrw;
  record IVVc IVr;
  row IVVc IVrw;
  Boolean retfound;

  retfound = true;
  Retr.OrdNr = ornr;
  while (LoopKey("OrdNr",Retr,1,retfound)) begin
    if (Retr.OrdNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
      rwcnt = MatRowCnt(Retr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Retr,i,Retrw);
        if (Retrw.OrdRow==ordrow and Retrw.SerialNr==batchnr) then begin
          res = res + Retrw.Quant;
        end;
      end;
    end;
  end;


  retfound = true;
  IVr.OrderNr = ornr;
  while (LoopKey("OrderNr",IVr,1,retfound)) begin
    if (IVr.OrderNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
//      if (IVr.UpdStockFlag!=0) and (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and (IVr.OKFlag==0) then begin
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and (IVr.OKFlag==0) then begin
        rwcnt = MatRowCnt(IVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.OrdRow==ordrow and IVrw.SerialNr==batchnr) then begin
            res = res + IVrw.Quant;
          end;
        end;
      end;
    end;
    
  end;
  BatchReturnForOR = res;
  return;
end;


global
function val AlreadyReturnedforOR(LongInt ornr,Integer ordrow)
begin
  Boolean found;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  val res;
  Integer i,rwcnt;
  record RetVc Retr;
  row RetVc Retrw;
  record IVVc IVr;
  row IVVc IVrw;
  Boolean retfound;

  retfound = true;
  Retr.OrdNr = ornr;
  while (LoopKey("OrdNr",Retr,1,retfound)) begin
    if (Retr.OrdNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
      rwcnt = MatRowCnt(Retr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Retr,i,Retrw);
        if (Retrw.OrdRow==ordrow) then begin
          res = res + Retrw.Quant;
        end;
      end;
    end;
  end;

  retfound = true;
  IVr.OrderNr = ornr;
  while (LoopKey("OrderNr",IVr,1,retfound)) begin
    if (IVr.OrderNr!=ornr) then begin retfound = false; end;
    if (retfound) then begin
      if (IVr.UpdStockFlag!=0) and (IVr.InvType!=kInvoiceTypeCredit and IVr.InvType!=kInvoiceTypeCreditSpecialSales) then begin
        rwcnt = MatRowCnt(IVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.OrdRow==ordrow) then begin
              res = res - IVrw.Quant;
          end;
        end;
      end;
    end;
  end;
  AlreadyReturnedforOR = res;
  return;
end;

/*
function val AlreadyReturned(LongInt sernr,Integer rownr)
begin
  Boolean found;
  record RetVc Retr;
  row RetVc Retrw;
  Integer i,rwcnt;
  val res;

  found = true;
  Retr.SHNr = sernr;
  while (LoopKey("SHNr",Retr,1,found)) begin
    if (Retr.SHNr!=sernr) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(Retr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Retr,i,Retrw);
        if (Retrw.SHRow==rownr) then begin
          res = res + Retrw.Quant;
        end;
      end;
    end;
  end;  
  AlreadyReturned = res;
  return;
end;
 */
global
updating function Integer PasteSHInRet(var record SHVc SHr,var record RetVc Retr,string defreturnlocation)
BEGIN
  Integer res;
  record INVc INr;
  row RetVc Retrw;
  row SHVc SHrw;
  val remn,costprice;
  val ordered,stock,t1;
  Boolean testf;
  Integer i,j,q,srw,rwcnt;
  record CostAccBlock CAb;
  record RetGoodsBlock RGb;
  record AccBlock ARb;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;
  record ORVc ORr;
  row ORVc ORrw;
  record WeigAvVc WAr;
  string 255 tstr;

  res = 1;
  BlockLoad(CAb);
  BlockLoad(RGb);
  BlockLoad(ARb);
  t1 = 1.00;
  RecordNew(Retr);
  Retr.OrdNr = SHr.OrderNr;
  Retr.Type = RGb.ReduceDefault;
  Retr.CustCode = SHr.CustCode;
  Retr.CustName = SHr.Addr0;
  if (blank(defreturnlocation)) then begin
    Retr.Location = SHr.Location;
  end else begin
    Retr.Location = defreturnlocation;
  end;
  Retr.Objects = SHr.Objects; 
  Retr.SHNr = SHr.SerNr; 
  ORr.SerNr = SHr.OrderNr;
  if (ReadFirstMain(ORr,1,true)) then begin end;
  rwcnt = MatRowCnt(SHr);
  srw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHr,i,SHrw);
    if (blank(SHrw.ArtCode)) then begin goto LFOR; end;
    MatRowGet(ORr,SHrw.OrdRow,ORrw);
    if (ReadFirstItem(ORrw.ArtCode,INr,false,false)) then begin end;
    switch (INr.SerNrf) begin
      case 1:
        remn = SHrw.Ship;
      case 2:
//        remn = SHrw.Ship - BatchReturnForOR(SHr.OrderNr,SHrw.OrdRow,SHrw.SerialNr);
        remn = BatchDeliveredForOR(SHr.OrderNr,SHrw.OrdRow,SHrw.SerialNr) - BatchReturnForOR(SHr.OrderNr,SHrw.OrdRow,SHrw.SerialNr);
      otherwise
        remn = ORrw.Shipd2 - NotOKedReturnForOR(SHr.OrderNr,SHrw.OrdRow);
//    remn = remn - AlreadyReturnedforOR(SHr.OrderNr,SHrw.OrdRow);
    end;
    if (remn>SHrw.Ship) then begin remn = SHrw.Ship; end;
    ordered = remn;
    testf = false;
    if (SHrw.Ship!=0) then begin testf = true; end;
    if (testf) then begin
      GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);  
      if (INr.ItemType==0) or (INr.ItemType==3) then begin
      end else begin
        waperloc = WAPerLocation(INr,ITr,CAb);
      end;
      stock = blankval;
      ClearRow(Retr,Retrw,1);
      Retrw.SHRow = i;
      if (blank(defreturnlocation)) then begin
        Retrw.Location = SHrw.Location;
      end else begin
        Retrw.Location = defreturnlocation;
        GetCOSAcc("",Retr.CustCode,Retrw.Location,ARb,INr,CAb.ItemGroupAccounts,true,kItemTypeStocked,Retrw.CostAcc,tstr);        
      end;
      Retrw.OrdRow = SHrw.OrdRow;
      Retrw.ArtCode = SHrw.ArtCode;
      Retrw.Spec = SHrw.Spec;
      Retrw.SerialNr = SHrw.SerialNr;
      Retrw.VARList = SHrw.VARList;
      Retrw.Recepy = SHrw.Recepy;
      Retrw.Objects = SHrw.Objects;
      Retrw.BestBefore = SHrw.BestBefore;
      Retrw.PosCode = SHrw.PosCode;
      Retrw.Coefficient = SHrw.Coefficient;
      Retrw.BBCostPrice = SHrw.BBCostPrice;
      Retrw.CostAcc = SHrw.CostAcc;
      Retrw.UnitXval = SHrw.UnitXval;
      Retrw.UnitYval = SHrw.UnitYval;
      Retrw.UnitZval = SHrw.UnitZval;
      if ((SHrw.Ordered==0) and (remn==0)) then begin remn = blankval; end;
      Retrw.Quant = remn;
      if (SHrw.Ship==0) then begin Retrw.Quant = blankval; end;
      testf = true;
      if (CAb.RetCostPriceFromSH!=0) then begin          
//rememebr about CalculateRetRowFIFO when changing this      
        switch (primary) begin
          case kCostModelNone: 
            Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH_Source(INr,Retr,Retrw,primary,CAb.QueuedCostModel,i);
          case kCostModelCostPrice: 
            Retrw.CostPrice = INr.InPrice;
          case kCostModelPctBasePrice: 
            Retrw.CostPrice = FindCostPriceBasePrice(CAb,INr,ITr);
          case kCostModelWA: 
            Retrw.CostPrice = FindCostPriceWA(waperloc,INr,Retrw.Location);
            Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retr,Retrw,CAb.QueuedCostModel,i);
          case kCostModelQueued: 
            Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retr,Retrw,CAb.QueuedCostModel,i);
          case kCostModelNoneItem: 
            switch (queuecostmodel) begin
              case kQueuedCostModelPerSerialNr:
                Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retr,Retrw,CAb.QueuedCostModel,i);
              otherwise
                Retrw.CostPrice = FindCostPrice_ReturnedGoods_FromSH(CAb,INr,Retr,Retrw,CAb.QueuedCostModel,i);
            end;
          otherwise
            Retrw.CostPrice = FindCostPrice_ReturnedGoods(Retr,Retrw)/Retrw.Quant;
        end;
        Retrw.UPrice = Retrw.CostPrice;
      end else begin
        switch (primary) begin
          case kCostModelCostPrice: 
            Retrw.CostPrice = INr.InPrice;
          case kCostModelCostPrice: 
            Retrw.UPrice = INr.InPrice;
            Retrw.CostPrice = Retrw.UPrice;
          case kCostModelWA:
            if (waperloc==0) then begin
              Retrw.CostPrice = INr.InPrice;
              Retrw.UPrice = INr.InPrice;
            end else begin
              WAr.ArtCode = INr.Code;
              WAr.Location = Retrw.Location;
              if (blank(WAr.Location)) then begin
                WAr.Location = Retr.Location;
              end;
              if (ReadFirstMain(WAr,2,true)) then begin
                Retrw.CostPrice = WAr.WeighedAvPrice;
                Retrw.UPrice = WAr.WeighedAvPrice;
              end else begin
                Retrw.CostPrice = INr.InPrice;
                Retrw.UPrice = INr.InPrice;
              end;
            end;
          case kCostModelQueued: 
            Retrw.CostPrice = INr.InPrice;
            Retrw.UPrice = INr.InPrice;
          otherwise
            Retrw.UPrice = SHrw.FIFO;
            Retrw.CostPrice = SHrw.FIFO;
        end;
      end;
//      RetCalcCostPrice(Retrw.ArtCode,Retrw.UPrice,Retr.InclVAT,Retrw.Extra,Retr.CurncyCode,
//                      Retr.FrRate,Retr.ToRateB1,Retr.ToRateB2,Retr.BaseRate1,Retr.BaseRate2,costprice);
//      Retrw.CostPrice = costprice;    

      
      if (INr.PriceFactor!=0) then begin
//        Retrw.UPrice = Retrw.UPrice/INr.PriceFactor;
//        Retrw.CostPrice = Retrw.CostPrice/INr.PriceFactor;
//Cost Price on delivery already knows about factor
      end;
      if (Retrw.Quant!=0) then begin              
        MatRowPut(Retr,srw,Retrw);
        srw = srw + 1;
      end;
    end;
LFOR:;    
  end;
/*
  srw = MatRowCnt(Retr);
  rwcnt = srw;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retr,i,Retrw);
    if (nonblank(Retrw.Recepy)) then begin
      INr.Code = Retrw.ArtCode;
      if (ReadFirstMain(INr,1,true)) then begin      
//        ExplodeRecepy(RetVc,&INr,&Retrw.Quant,Retp,Retrw.Recepy,srw-1);
        MatRowGet(Retr,i,Retrw);
        Retrw.Recepy = "";
        Retrw.OrdRow = 0;
        MatRowPut(Retr,i,Retrw);
        srw = MatRowCnt(Retr);
      end;  
    end;
  end;  
*/
  RetSumUp(Retr);
  if (Retr.SerNr<0) then begin
    Retr.SerNr = NextSerNr("RetVc",Retr.TransDate,-1,false,"");
  end;
  if (Retr.SerNr>0) then begin
    if (MatRowCnt(Retr)>0) then begin
      if (RecordStore(Retr,false)) then begin
        res = 0;
        CreateRecordLink(Retr,CurrentCompany,SHr,CurrentCompany);  
        CreateRecordLink(SHr,CurrentCompany,Retr,CurrentCompany);  
      end;  
    end else begin
      res = 0;
    end;
  end else begin
    res = 1747;
  end;
  PasteSHInRet = res;
  RETURN;
END;

procedure CalcItemWeghtandVolume(record INVc INr,string serialnr,var val inweight,var val involume)
BEGIN
  record BatchTextVc BatchTextr;
  record ItemSettingBlock ItemSettingRec;
  
  inweight = INr.Weight;
  involume = INr.Volume;
  if (nonblank(serialnr)) then begin
    BlockLoad(ItemSettingRec);
    if (ItemSettingRec.EnCalcDimQty!=0) then begin
      BatchTextr.ArtCode = INr.Code;
      BatchTextr.SerialNr = serialnr;
      if (ReadFirstMain(BatchTextr,2,true)) then begin
        if ((BatchTextr.SaleUnitXval!=0) and (BatchTextr.SaleUnitYval!=0) and (BatchTextr.SaleUnitZval!=0)) then begin
          involume = BatchTextr.SaleUnitXval*BatchTextr.SaleUnitYval*BatchTextr.SaleUnitZval;
          inweight = inweight*involume;
        end;
      end;
    end;
  end;
  RETURN;
END;

global
procedure CalcSHWeight(var record SHVc SHr,Boolean change)
begin
  row SHVc SHrw;
  record INVc INr;
  Integer rwcnt,i;
  val rowweight;
  Boolean doit;
  val inweight,involume;
  
  SHr.Weight = blankval;
  SHr.Volyme = blankval;
  SHr.TotWeight = blankval;
  SHr.TotVolume = blankval;
  doit = true;
  if (change==false) then begin
    if (SHr.Weight<>0) then begin
      doit = false;
    end;
  end;
  if (doit) then begin
    rwcnt = MatRowCnt(SHr);
    for (i=0; i<rwcnt; i=i+1) begin
      MatRowGet(SHr,i,SHrw);
      if (ReadFirstItem(SHrw.ArtCode,INr,true,true)) then begin
        CalcItemWeghtandVolume(INr,SHrw.SerialNr,inweight,involume);
        rowweight = SHrw.Ship * inweight;
        SHr.Weight = SHr.Weight + rowweight;
        rowweight = SHrw.Ship * involume;
        SHr.Volyme = SHr.Volyme + rowweight;
      end;
    end;
    if (SHr.Weight==0) then begin SHr.Weight = blankval; end;
    if (SHr.Volyme==0) then begin SHr.Volyme = blankval; end;
  end;
  SHr.Weight = Round(SHr.Weight,SetRoundModeD(2));
  SHr.Volyme = Round(SHr.Volyme,SetRoundModeD(2));
  SHr.TotWeight = SHr.Weight;
  SHr.TotVolume = SHr.Volyme;
  if (SHr.Weight==0) then begin SHr.Weight = blankval; end;
  if (SHr.Volyme==0) then begin SHr.Volyme = blankval; end;
  if (SHr.TotVolume==0) then begin SHr.TotVolume = blankval; end;
  if (SHr.TotWeight==0) then begin SHr.TotWeight = blankval; end;
  return;
end;

global
procedure SHVc_ChangeQuantityRecepy(string motherartcode,val newq,Integer arow,var record SHVc SHp)
begin
  row SHVc SHrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(SHp);
  for (i=arow+1;i<rwcnt;i=i+1) begin
    MatRowGet(SHp,i,SHrw); 
    if (SHrw.stp==kInvoiceRowTypeStructuredItemComponent) then begin
      SHrw.Ship = SHrw.RecipeQuant*newq;
      if (blank(SHrw.RecipeQuant)) then begin
        SHrw.Ship = blankval;
      end;
      MatRowPut(SHp,i,SHrw); 
    end else begin
      goto LSHVc_ChangeQuantityRecepy;
    end;
  end;
LSHVc_ChangeQuantityRecepy:;  
  return;
end;

global
procedure SHVc_PasteShip(var record SHVc SHr,var Integer rownr)
begin
  row SHVc SHrw;
  record ORVc ORr;
  row ORVc ORrw;
  record MainStockBlock MainStockRec;
  record RoundBlock RoundRec;
  val t;
  record INVc INr;
  record SerNrTrackBlock SNrb;
  Boolean itemfoundf;

  BlockLoad(SNrb);
  BlockLoad(MainStockRec);
  MatRowGet(SHr,rownr,SHrw);
  itemfoundf = ReadFirstItem(SHrw.ArtCode,INr,true,true);
  if (nonblank(SHrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,false,SHrw.ArtCode,SHrw.SerialNr,SHrw.Ship)) then begin
      MatRowPut(SHr,rownr,SHrw);
      MatRowGet(SHr,rownr,SHrw);
    end;
  end;

  if (INr.ExplodeRec!=0) then begin
    if (nonblank(ORrw.Recepy)) then begin
    end else begin
      SHVc_ChangeQuantityRecepy(SHrw.ArtCode,SHrw.Ship,rownr,SHr);
    end;
  end;
  if (MainStockRec.DelOrdQty==0) then begin
    if (SHrw.Ship>SHrw.Ordered) then begin
      MessageBox(1303,"");
    end;
  end;
  if (SHrw.Ship<0) then begin
    SHrw.Ship = 0;
  end;
  CalcSHWeight(SHr,true);
  BlockLoad(RoundRec);
  ORr.SerNr = SHr.OrderNr;
  if (ReadFirstMain(ORr,1,true)) then begin
    if ((SHrw.OrdRow<MatRowCnt(ORr)) and (SHrw.OrdRow>-1)) then begin
      MatRowGet(ORr,SHrw.OrdRow,ORrw);
      t = ORrw.Sum/ORrw.Quant;
      SHr.TAX1Sum = t * SHrw.Ship;
    end;
  end;  
  MatRowPut(SHr,rownr,SHrw);
  return;
end;

global
procedure SHVc_PasteDelCountry(var record SHVc SHp,string oldCountryCode)
begin 
  if (SHp.DelCountry!=oldCountryCode or blank(oldCountryCode)) then begin
    
    if (nonblank(SHp.DelCountry)) then begin 
      GetCountryName(SHp.DelCountry,SHp.LangCode,SHp.DelCountryName);
    end else begin
      SHp.DelCountryName = "";
    end;     
  end;
  return;
end;

global
updating procedure SHVcRecordUpdateClientRemote(record SHVc SHr,record SHVc SH2r,string TaxAdminServSeal)
begin
  if ((SHr.OKFlag!=0) and (SH2r.OKFlag==0)) then begin
    SMSWhenSHOK(SHr.OrderNr,SHr.CustCode,2);
  end;
  if (HasLocalization("PRT")) then begin
    StoreeShipTaxAuthReply("SHVc",SHr.SerNr,SHr.OfficialSerNr,TaxAdminServSeal);
  end;
  return;
end;