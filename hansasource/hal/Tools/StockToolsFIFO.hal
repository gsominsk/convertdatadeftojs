external function roundmode DefaultRoundMode();
external function Integer GetFIFOPerSerialNr(record INVc,record ITVc,record CostAccBlock);
external procedure CalcCostPrice(val,val,val,Integer,val,var val,var val);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Integer ItemCostPerLocation(record INVc);
external function roundmode SetRoundModeD(Integer);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function Boolean ConsigmentStock(string,string,Date);
external function Boolean TREOStock(string,string,Date);
external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCostPriceBP(Integer,record INVc,string);
external function val GetStockQty(string,string,Date,Boolean);
//external function val FindCostPriceCostPrice(Integer,record INVc,string);
external function roundmode CostPriceDecimals();
external procedure GetCostsFromRecords(record ItemHistVc,var val,var val,Boolean,Date);
external function Integer ArtCodeCostPerLocation(string);
external function Integer CostPricePerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer FIFOPerLocation(record INVc,record ITVc,record CostAccBlock);
external function val CalculateQty2(val,val);
external function Boolean TestArtCode(string,string,record INVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetStockedItemFromRecepy(record SHVc,var string,var val);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external procedure PrintItemHistLine(record ItemHistVc,val);
external function val FindCostPriceWA(Integer,record INVc,string);


// adjustqty = Quantities from lines above with the same item number, indicates how many IHr will be skipped until first will be used
// takenqty = How many quantities was used from the qty
// skippedqty = How many quantities was skipped on the IHr we will use for cost


function val FindCostPriceCP(Integer WAPerLocation,record INVc INr,string location)
begin
  val res;
  
  if (INr.PriceFactor!=0) then begin
    res = INr.InPrice / INr.PriceFactor;
  end else begin
    res = INr.InPrice;
  end;
  FindCostPriceCP = res;
  return;
end;

function val CalculateCosts(record ItemHistVc IHr,val qty,var val adjv,var val skippedqty,var val takenqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer PerLocation,record INVc INr)
begin
  val res;
  val remcost,t;
  val remcostprice,totcostprice;
  record ItemHistVc printIHr;
  
  res = blankval;
  switch (OverwriteCostModel) begin 
    case 1:
      t = FindCostPriceCP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 2:
      t = FindCostPriceBP(PerLocation,INr,IHr.Location);
      remcostprice = (IHr.RemQty-takenqty)*t;
      totcostprice = IHr.Qty*t;
    case 3:
      t = FindCostPriceWA(PerLocation,INr,IHr.Location);
//      remcostprice = (IHr.RemQty-takenqty)*t; this or below ? , but this sounds worng doesnt it ?  or maybe only for FIFO ? 
      remcostprice = IHr.RemQty*t;
      
      totcostprice = IHr.Qty*t;
    otherwise
      remcostprice = IHr.RemCostPrice;
      totcostprice = IHr.TotCostPrice;
  end;
  if (costfrrecf) or (todaysratef) then begin
    GetCostsFromRecords(IHr,remcostprice,totcostprice,todaysratef,CurrentDate);
  end;
  if (printf) then begin
    RecordCopy(printIHr,IHr);
//    printIHr.RemQty = printIHr.RemQty - takenqty;
    if (printIHr.RemQty>(qty - takenqty)) then begin
      printIHr.RemQty = qty - takenqty;
    end else begin
      printIHr.RemQty = printIHr.RemQty;
    end;
    if (printIHr.RemQty>qty) then begin
      remcostprice = (remcostprice*qty)/printIHr.RemQty;
      printIHr.RemQty = qty;
    end else begin
      switch (OverwriteCostModel) begin
        case 1:
          remcostprice = printIHr.RemQty*FindCostPriceCP(PerLocation,INr,IHr.Location);
        case 2:
          remcostprice = printIHr.RemQty*FindCostPriceBP(PerLocation,INr,IHr.Location);
      end;
    end;
    PrintItemHistLine(printIHr,remcostprice);
  end;
  remcost = remcostprice - adjv*(Round(totcostprice/IHr.Qty,CostPriceDecimals));
  if ((adjv - IHr.RemQty)<0) then begin
    t = IHr.RemQty - adjv;
    skippedqty = IHr.RemQty-t;
    adjv = 0;
  end else begin
    adjv = adjv - IHr.RemQty;
    skippedqty = IHr.RemQty;
    t = 0;
  end;
  if (adjv==0) then begin // stop skipping...
    if (t+takenqty>qty) then begin
      t = qty - takenqty;
    end;
    if (t!=0) then begin
      if (IHr.RemQty==t) then begin
        res = res + remcostprice;
      end else begin
        if (t==IHr.RemQty-skippedqty) then begin
          res = res + remcost;
        end else begin
          res = res + (round(totcostprice/IHr.Qty,CostPriceDecimals) * t);
        end;
      end;
      takenqty = takenqty + t;
    end;
  end;
  CalculateCosts = res;
  return;
end;

global
function val FindCostPriceFIFO(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  if ((FIFOPerLocation==0) or (blank(location))) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    if (IHr.RemQty<0) then begin
      if ((blank(IHr.SerialNr)) and (blank(IHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin//current status
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;          
      end;
      if (printf) then begin
        if (nonblank(location)) then begin
          if (OverwriteCostModel!=kCostModelWA) then begin
            if (IHr.Location!=location) then begin testf = false; end;
          end;
        end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,FIFOPerLocation,INr);
      end;
    end;
  end;
  FindCostPriceFIFO = res;
  return;
end;

global
function val FindCostPriceLIFO(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean costfrrecf,Boolean printf,Boolean todaysratef,Integer OverwriteCostModel,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  if ((FIFOPerLocation==0) or (blank(location))) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    if (IHr.RemQty<0) then begin
      if ((blank(IHr.SerialNr)) and (blank(IHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,costfrrecf,printf,todaysratef,OverwriteCostModel,0,INr);
      end;
    end;
  end;
  FindCostPriceLIFO = res;
  return;
end;

global
function val FindCostPriceSerial(record INVc INr,string location,string serialnr,val qty,val adjustqty,Boolean printf,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty;
  Date blankd;
  
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  thekey = "ActiveQty";
  keys = 1;
  if (nonblank(IHr.Location)) then begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  adjv = adjustqty;
  ResetLoop(IHr);
  foundf = true;
  while (LoopKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (takenqty>=qty) then begin
      foundf = false;
    end;
    testf = foundf;
    if (nonblank(serialnr)) then begin
      if (IHr.SerialNr!=serialnr) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
//          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)==false) then begin
//          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        res = res + CalculateCosts(IHr,qty,adjv,skippedqty,takenqty,false,printf,false,0,0,INr);
      end;
    end;
  end;
  FindCostPriceSerial = res;
  return;
end;

function val FindLastCostPriceSerial(record INVc INr,string location,string serialnr,val qty,Boolean printf,Integer consigstock)
begin
  record ItemHistVc IHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val res,adjv,t,takenqty,remcost,skippedqty,lqty;
  
  lqty = -qty;
  res = blankval;
  takenqty = 0;
  IHr.ArtCode = INr.Code;
  IHr.SerialNr = serialnr;
  thekey = "ArtCodeSerialNr";
  keys = 2;
  adjv = 0;
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (IHr.SerialNr!=serialnr) then begin
      foundf = false;
    end;
    if (takenqty>=lqty) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      testf = true;
      switch (consigstock) begin
        case 1: 
          if (IHr.ConsigStock!=0) then begin 
            testf = false;
          end;
        case 2: 
          if (IHr.ConsigStock==0) then begin 
            testf = false;
          end;
      end;
      if (testf) then begin
        if (IHr.Qty<lqty) then begin
          takenqty = takenqty + IHr.Qty;
        end else begin
          takenqty = takenqty + lqty;
        end;
        res = res + (IHr.TotCostPrice*lqty)/IHr.Qty;
      end;
    end;
  end;
  FindLastCostPriceSerial = res;
  return;
end;

global
function val QtyUsedBeforeDate(record ItemHistVc sourceIHr,Boolean fifodatef,Date td)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  
  found = true;
  IHr.Source = sourceIHr.SerNr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sourceIHr.SerNr) then begin
      found = false;
    end;
    if (found) then begin
      testf = true;
      if (fifodatef) then begin
        if (IHr.FIFODate>td) then begin testf = false; end;
       end else begin
        if (IHr.TransDate>td) then begin testf = false; end;
      end;
      if (IHr.FileName=="RetVc") then begin testf = false; end;//returned goods have source but should not be used for calcualtion, they dont take out of stock
      if (testf) then begin
        res = res - IHr.Qty;
      end;
    end;
  end;
  QtyUsedBeforeDate = res;
  return;
end;

global
function val FindCostPriceBasePrice(record CostAccBlock CAb,record INVc INr,record ITVc ITr)
begin
  val res;
  val CostPerc;
  
  res = blankval;
  CostPerc = INr.CostPerc;
  if (blank(CostPerc)) then begin
    if (CAb.ItemGroupCostModel!=0) then begin//ISVC, per location
      CostPerc = ITr.CostPerc;
    end;
  end;
  if (CostPerc==0) then begin
    CostPerc = CAb.CostPerc;
  end;
  if (CostPerc==0) then begin
    CostPerc = 100;
  end;
  res = Round((INr.UPrice1 * CostPerc)/100,SetRoundModeD(3));
  if (INr.PriceFactor!=0) then begin        
    res = res/INr.PriceFactor; 
  end;
  FindCostPriceBasePrice = res;
  return;
end;

function Boolean FindNegativeSourceFIFOCost(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,var val inprice)
begin
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  val qcnt,fifoq,fifov;
  
  inprice = qty * INr.InPrice;
  qcnt = -qty;
  fifoq = 0;
  fifov = 0;
  foundf = true;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    if (blank(td)) then begin
      keys = 1;
    end else begin
      keys = 2;
    end;
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
  end;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (IHr.Qty>0) then begin foundf = false; end; // As soon as we have a positive one, we stop, on purpouse, because after this it is impossible to figure out negative qty FIFO cost...
    if (foundf) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
          if (qcnt>=sourceIHr.Qty) then begin
            fifoq = fifoq + sourceIHr.Qty;
            fifov = fifov + sourceIHr.TotCostPrice;
            qcnt = qcnt - sourceIHr.Qty;
          end else begin
            fifoq = fifoq + qcnt;
            fifov = fifov + ((sourceIHr.TotCostPrice / sourceIHr.Qty) * qcnt);
            qcnt = 0;
          end;
          if (qcnt<=0) then begin
            foundf = false;
          end;
        end;
      end;
    end;
  end;
  if (fifoq>0) then begin
    qcnt = -qty;
    if (fifoq<qcnt) then begin
      inprice = -((fifov / fifoq) * qcnt);
    end else begin
      inprice = -fifov;
    end;
  end;
  return;
end;

global
function val FindCostPriceFIFOBackDated(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,Boolean costfrrecf,Integer print,Boolean ondayratef,Integer OverwriteCostModel,Integer consigstock,Integer repcalcwa)
//val adjustqty ? 
begin
  record ItemHistVc IHr;
  record ItemHistVc nextIHr;
  record ItemHistVc outIHr;
  record ItemHistVc printIHr;
  record ITVc ITr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,firstf,testf;
  val qcnt,res,instock,inprice,qusebefdat;
  val remcostprice,totcostprice,t,usedqty,outqty,nextqty;
  record CostAccBlock CAb;
  LongInt looppos;

  res = blankval;
  testf = false;
  BlockLoad(CAb);
  if (qty<0) then begin
    switch (OverwriteCostModel) begin
      case 2:
        ITr.Code = INr.Group;
        if (ReadFirstMain(ITr,1,true)) then begin
        end;
        inprice = qty * FindCostPriceBasePrice(CAb,INr,ITr);
      case 3:
        inprice = qty * INr.WeighedAvPrice;
      otherwise
        FindNegativeSourceFIFOCost(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,td,inprice);
    end;
    goto LFindCostPriceFIFOBackDated;
  end;
  if (blankdate(td)) or (td==CurrentDate) then begin
    testf = true;
  end;  
  switch (OverwriteCostModel) begin
    case 1:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
    case 2:
      if (blankdate(td)) or (td>=CurrentDate) then begin
        testf = true;
      end;
  end;
  if (testf) then begin
    inprice = FindCostPriceFIFO(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,costfrrecf,print!=0,ondayratef,OverwriteCostModel,consigstock);
    goto LFindCostPriceFIFOBackDated;
  end;
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  
/*if FIFO per location it is not that simple at all
*/
  

  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    keys = 2;
    instock = GetStockQty(INr.Code,"",td,false);
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
    instock = GetStockQty(INr.Code,location,td,false);
  end;
  
  RecordNew(nextIHr);
  ResetLoop(IHr);
  foundf = true;
  while (LoopBackKey(thekey,IHr,keys,foundf)) begin
    if (IHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (IHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + IHr.Qty;
        if (IHr.Qty<0) then begin 
          outqty = outqty - IHr.Qty;
        end;
        if (qcnt>=(instock-adjustqty)) then begin
          looppos = GetLoopPosition(IHr);
          RecordCopy(nextIHr,IHr);
          RecordCopy(printIHr,IHr);
          printIHr.RemQty = printIHr.Qty;
          switch (OverwriteCostModel) begin 
            case 3:
              printIHr.RemCostPrice = printIHr.TotCostPrice;
            otherwise
              printIHr.RemCostPrice = printIHr.TotCostPrice;
          end;
          foundf = false;
        end;
      end;
    end;
  end;

  outqty = 0;
/* // This causes problems, what is this function supposed to solve, cause whatever it does it screwes up the new "QtyUsedBeforeDate" function
  RecordCopy(outIHr,nextIHr);
  outIHr.ArtCode = INr.Code;
  outIHr.Location = location;
  outIHr.FIFODate = td;

  qcnt = 0;
// shuld be possible to move to loop above    
  foundf = true;
  while (LoopBackKey(thekey,outIHr,keys,foundf)) begin // Start from the nextIHr record and find all out things
    if (outIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (outIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      testf = true;
      if (outIHr.StockAffectf==0) then begin testf = false; end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        qcnt = qcnt + outIHr.Qty;
        if (qcnt>=(instock-adjustqty)) then begin
          foundf = false;
        end;
        if (outIHr.Qty>0) then begin 
          if (CAb.RetFIFOQue!=0) then begin
            if (outIHr.FileName=="RetVc") then begin
            end else begin
              testf = false; 
            end;
          end else begin
            testf = false; 
          end;
        end;
      end;
      if (outIHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        outqty = outqty - outIHr.Qty;
      end;
    end;
  end;
  outqty = outqty + adjustqty;
*/
  ResetLoop(nextIHr);
  nextIHr.ArtCode = INr.Code;
  nextIHr.Location = location;
  SetLoopPosition(nextIHr,looppos-1);  

  inprice = 0;
  usedqty = 0;
  firstf = true;
  foundf = true;
  while (LoopKey(thekey,nextIHr,keys,foundf)) begin // Start from the nextIHr record
    if (nextIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (nextIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (nextIHr.FIFODate>td) then begin
      foundf = false;
    end;
    if (usedqty>=qty) then begin
      foundf = false;
    end;
    if (foundf) then begin
      testf = true;
      if (nextIHr.StockAffectf==0) then begin testf = false; end;
      if (nextIHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (nextIHr.Invalid!=0) then begin testf = false; end;
      if (nextIHr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        qusebefdat = QtyUsedBeforeDate(nextIHr,FIFOPerLocation!=0,AddDay(td,0)); // nextIHr.FIFODate
//        qusebefdat = QtyUsedBeforeDate(nextIHr,true,AddDay(td,-1)); //what if run on date when "things" happen 
        nextqty = nextIHr.Qty - outqty - qusebefdat;
        outqty = outqty - nextIHr.Qty - qusebefdat;
        if (outqty<0) then begin
          outqty = 0;
        end;
        if (nextqty<0) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        if ((usedqty+nextqty)>qty) then begin
          nextqty = qty - usedqty;
        end else begin
          nextqty = nextqty; 
        end;
        usedqty = usedqty + nextqty;
        switch (consigstock) begin
          case 1: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)) then begin
//            if (nextIHr.ConsigStock!=0) then begin 
              testf = false;
            end;
          case 2: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)==false) then begin
//            if (nextIHr.ConsigStock==0) then begin 
              testf = false;
            end;
        end;
        if (testf) then begin        
        switch (OverwriteCostModel) begin 
          case 3:
            if (FIFOPerLocation!=0) then begin
              t = nextIHr.WATotCostPerLoc/nextIHr.Qty;
            end else begin
              t = nextIHr.WATotCost/nextIHr.Qty;
            end;
            t = FindWAPriceBackdated(FIFOPerLocation,INr,nextIHr.Location,1,td,false,repcalcwa);
            if (nextIHr.FileName=="RetVc") then begin
              if (CAb.RetFIFOQue!=0) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextIHr.RemQty*t;
              end;
            end else begin
//              remcostprice = nextIHr.RemQty*t;
              if (nextqty>nextIHr.Qty) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextqty*t;
              end;
            end;
            if (nextIHr.Qty>0) then begin
              totcostprice = nextIHr.Qty*t;
            end else begin
              totcostprice = nextIHr.Qty*t;
            end;
//StopAlert("totcostprice " & totcostprice & " nextIHr.SerNr " & nextIHr.SerNr);        
            
          case 2:
            remcostprice = FindCostPriceBasePrice(CAb,INr,ITr) * nextIHr.Qty; // nextIHr.BPTotCost; // BPTotCost seems to be blank at all time
            totcostprice = FindCostPriceBasePrice(CAb,INr,ITr) * nextIHr.Qty; // nextIHr.BPTotCost; // BPTotCost seems to be blank at all time
          case 1:
            if (INr.PriceFactor!=0) then begin
              remcostprice = nextIHr.CPTotCost / INr.PriceFactor; //CPTotCost; I don't think CPTotCost is correct....
              totcostprice = nextIHr.CPTotCost / INr.PriceFactor; //CPTotCost; I don't think CPTotCost is correct....
            end else begin
              remcostprice = nextIHr.CPTotCost; //CPTotCost; I don't think CPTotCost is correct....
              totcostprice = nextIHr.CPTotCost; //CPTotCost; I don't think CPTotCost is correct....
            end;
          otherwise
//            remcostprice = nextIHr.RemCostPrice;
            remcostprice = nextIHr.TotCostPrice;
            totcostprice = nextIHr.TotCostPrice;
        end;
        if (costfrrecf) or (ondayratef) then begin
          GetCostsFromRecords(nextIHr,remcostprice,totcostprice,ondayratef,td);
        end;
        if (print==2) then begin
          if (nextqty!=0) then begin
//          if (remcostprice!=0) and (nextqty!=0) then begin// qty can be no zero and price zero
            RecordCopy(printIHr,nextIHr);
            switch (OverwriteCostModel) begin 
              case 3:
                if (nextIHr.FileName=="RetVc") then begin
                  if (CAb.RetFIFOQue!=0) then begin
                    printIHr.RemQty = nextIHr.Qty;
                  end;
                end;
            end;
            printIHr.RemQty = nextqty;
            PrintItemHistLine(printIHr,nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals));
          end;          
        end;
        
        inprice = inprice + nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals);
        printIHr.RemQty = printIHr.RemQty + nextqty;
        end;
      end;
    end;
  end;
  if (print==1) then begin
    if (printIHr.Qty!=0) then begin
//    if (printIHr.TotCostPrice!=0) then begin // qty can be no zero and price zero
      PrintItemHistLine(printIHr,Round(printIHr.TotCostPrice,CostPriceDecimals));
    end;
  end;
LFindCostPriceFIFOBackDated:;  
  res = Round(inprice,CostPriceDecimals);
  FindCostPriceFIFOBackDated = res;
  return;
end;

global
procedure GetCostModel(record INVc INr,record CostAccBlock CAb,var record ITVc ITr,var Integer primary,var Integer queuedcostmodel,Boolean serialprimary)
begin
  Boolean defprimaryf;
  Integer defqueued;
  
  primary = INr.PrimaryCostModel;
  queuedcostmodel = INr.QueuedCostModel;

  if (CAb.ItemGroupCostModel!=0) then begin
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
      if (primary==0) then begin primary = ITr.PrimaryCostModel; end;
      if (queuedcostmodel==0) then begin queuedcostmodel = ITr.QueuedCostModel; end;
    end;
  end;
  if (primary==0) then begin
    primary = CAb.PrimaryCostModel;
  end;
  if (primary==0) then begin primary = 9; end;// 9 means none on item and group

  if (queuedcostmodel==0) then begin
    queuedcostmodel = CAb.QueuedCostModel;
  end else begin
    queuedcostmodel = queuedcostmodel - 1;
  end;
  defqueued = queuedcostmodel;
  if (INr.SerNrf>0) then begin
    switch (INr.FIFOPerSerialNr) begin
      case 1: queuedcostmodel = defqueued;
      case 2:
        if (serialprimary) then begin
          primary = 20;
        end;
        queuedcostmodel = 20;
      otherwise
        if (CAb.FIFOPerSerialNr!=0) then begin
          if (serialprimary) then begin
            primary = 20;
          end;
          queuedcostmodel = 20;
        end;
    end;
    if (INr.FIFOPerSerialNr==0) then begin
    if (CAb.ItemGroupCostModel!=0) then begin
      switch (ITr.FIFOPerSerialNr) begin
        case 1: queuedcostmodel = defqueued;
        case 2:
          if (serialprimary) then begin
            primary = 20;
          end;
          queuedcostmodel = 20;
        otherwise
          if (CAb.FIFOPerSerialNr!=0) then begin
            if (serialprimary) then begin
              primary = 20;
            end;
            queuedcostmodel = 20;
          end;
      end;
    end;
    end;
  end;
  return;
end;

global
function val FindCostPrice(string artcode,string location,string serialnr,val qty,val adjustqty,Boolean todaysratef)
begin
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel,waperloc;
  record CostAccBlock CAb;
  val res,v;
  
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    BlockLoad(CAb);
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
    if (INr.ItemType==0) or (INr.ItemType==3) then begin
      switch (primary) begin
        case 1: primary = 1;
        case 2: primary = 2;
        case 3: 
          primary = 3;
          waperloc = 0;
        case 9: 
          primary = 9;
        otherwise 
          primary = 1;
      end;
    end else begin
      waperloc = WAPerLocation(INr,ITr,CAb);
    end;
    switch (primary) begin
      case kCostModelCostPrice: res = qty*INr.InPrice;//CostPricePerLocation(INr,ITr,CAb)
//      case 1: res = qty*FindCostPriceCostPrice(CostPricePerLocation(INr,ITr,CAb),INr,location);//no alue per location
      case kCostModelPctBasePrice: res = qty*FindCostPriceBasePrice(CAb,INr,ITr);
      case kCostModelWA: 
        v = FindCostPriceWA(waperloc,INr,location);
        if (INr.ItemType!=kItemTypeStocked) then begin
          if (v==0) then begin v = INr.InPrice; end;
        end;
        res = qty*v;
      case kCostModelQueued:
        switch (queuecostmodel) begin
          case kQueuedCostModelFIFO: res = FindCostPriceFIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0);
          case kQueuedCostModelLIFO: res = FindCostPriceLIFO(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,adjustqty,false,false,todaysratef,0,0);
        end;
      case 20: 
//        res = FindCostPriceSerial(INr,location,serialnr,qty,adjustqty,false,0);
//adjustqty must be zero for Serial Nr tracking , not sure for Batch nr
        if (qty<0) then begin
          res = -FindLastCostPriceSerial(INr,location,serialnr,qty,false,0);//here
        end else begin
          res = FindCostPriceSerial(INr,location,serialnr,qty,0,false,0);
        end;
    end;
  end;
  if (blank(res)) then begin
    if (qty<0) then begin
//      res = qty*INr.InPrice;
    end;
  end else begin
    if (qty<0) then begin
//      res = -res;//or here
    end;
  end;
  res = Round(res,CostPriceDecimals);
  FindCostPrice = res;
  RETURN;
END;

// Returns Cost for ONE item
global
function val FindCPPriceBackdated(Integer CPPerLocation,record INVc INr,string location,val isqtyp,Date todatp,Boolean curncytday)
begin
  val res;
  record ItemHistVc ItemHistr;
  Boolean found,testf;
  Integer keys;
  string 255 ckey;
  Boolean perlocf;
  
  if (blankdate(todatp) or isqtyp<0) then begin
    res = INr.InPrice;
  end else begin
    if (isqtyp==0) then begin
      goto LFindCPPriceBackdated;
    end;
    if (CPPerLocation!=0) and nonblank(location) then begin
      ckey = "ArtCodeLoc";
      keys = 3;
      ItemHistr.Location = location;
      perlocf = true;
    end else begin
      ckey = "ArtCode";
      keys = 2;
      perlocf = false;
    end;
    ItemHistr.ArtCode = INr.Code;
    ItemHistr.TransDate = todatp;
    found = true;
    while (LoopBackKey("ArtCode",ItemHistr,2,found)) begin    
      if (found) then begin
        if (ItemHistr.ArtCode!=INr.Code) then begin found = false; end;
      end; 
      if (perlocf) then begin
        if (ItemHistr.Location!=location) then begin found = false; end;
      end;
      testf = found;
      if (ItemHistr.StockAffectf==0) then begin testf = false; end;
      if (ItemHistr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (ItemHistr.Invalid!=0) then begin testf = false; end;
      if (ItemHistr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        if (perlocf) then begin
          res = ItemHistr.CPTotCostPerLoc; // this value doesn't seem to be correct anywhere... it is only used here, but set in a few places...
        end else begin
          if (INr.PriceFactor!=0) then begin
            res = ItemHistr.CPTotCost / ItemHistr.Qty / INr.PriceFactor;
          end else begin
            res = ItemHistr.CPTotCost / ItemHistr.Qty;
          end;
        end;
        if (res<0) then begin res = -res; end;
        found = false;
      end;
    end;
  end;
LFindCPPriceBackdated:;  
  FindCPPriceBackdated = res;  
  return;
end;

// Returns Cost for one item, and backdated it is COSTPRICE not BP....
global
function val FindBPPriceBackdated(record CostAccBlock CAb,record INVc INr,string location,val isqtyp,Date todatp,Boolean curncytday)
begin
  val res;
  record ItemHistVc ItemHistr;
  Boolean found,testf;
  record ITVc ITr;
  
  if (blankdate(todatp) or isqtyp<0) then begin
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
    end;
    res = FindCostPriceBasePrice(CAb,INr,ITr);
  end else begin
    ItemHistr.ArtCode = INr.Code;
    ItemHistr.TransDate = todatp;
    found = true;
    while (LoopBackKey("ArtCode",ItemHistr,2,found)) begin    
      if (found) then begin
        if (ItemHistr.ArtCode!=INr.Code) then begin found = false; end;
      end; 
      testf = found;
      if (ItemHistr.StockAffectf==0) then begin testf = false; end;
      if (ItemHistr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (ItemHistr.Invalid!=0) then begin testf = false; end;
      if (ItemHistr.Qty<0) then begin testf = false; end;
      if (testf) then begin
        if (INr.PriceFactor!=0) then begin
          res = ItemHistr.CPTotCost / ItemHistr.Qty / INr.PriceFactor;
        end else begin
          res = ItemHistr.CPTotCost / ItemHistr.Qty;
        end;
        found = false;
      end;
    end;
  end;
  FindBPPriceBackdated = res;  
  return;
end;

// This isn't used in many places....
global
function val FindCostPriceBackDated(string artcode,string location,string serialnr,val qty,Date td,Boolean ondayratef)
begin
  record INVc INr;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  record CostAccBlock CAb;
  val res;
  val adjustqty;
  
  adjustqty = 0;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    BlockLoad(CAb);
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    switch (primary) begin
      case 1: res = FindCPPriceBackdated(CostPricePerLocation(INr,ITr,CAb),INr,location,qty,td,ondayratef);
      case 2: res = FindBPPriceBackdated(CAb,INr,location,qty,td,ondayratef);
      case 3: res = FindWAPriceBackdated(WAPerLocation(INr,ITr,CAb),INr,location,qty,td,ondayratef,0);
      case 4:
        switch (queuecostmodel) begin
          case 0: res = FindCostPriceFIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0);
          case 1: res = FindCostPriceLIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0);
          case 20: res = FindCostPriceFIFOBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,0,td,false,0,ondayratef,0,0,0); // wrong...
        end;
//      case 20: res = FindCostPriceSerialBackDated(FIFOPerLocation(INr,ITr,CAb),INr,location,serialnr,qty,td,false);
    end;
  end;
  res = Round(res,CostPriceDecimals);
  FindCostPriceBackDated = res;
  return;
end;

global
procedure FindAdjstockvQtySHVc(string fnr,record SHVc SHp,string stockartcodep,Integer currow,var val adjstockvp)
BEGIN
  Integer j;
  record SHVc RecSHp;
  row SHVc SHrw;
  Boolean isstruct;
  string 20 locartcode;
  val recqty;

  adjstockvp = blankval;
  if (fnr=="SHVc") then begin
    for (j=0;j<currow;j=j+1) begin
      MatRowGet(SHp,j,SHrw);
      isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHp);
      if (isstruct) then begin
        if (MatRowCnt(RecSHp)!=1) then begin goto LFindAdjstockvQtySHVcSkipRow; end;
        GetStockedItemFromRecepy(RecSHp,locartcode,recqty); 
        if (stockartcodep==locartcode) then begin
          adjstockvp = adjstockvp + recqty;
        end;  
      end;  
LFindAdjstockvQtySHVcSkipRow:;    
    end;  
  end;
  RETURN;
END;

global
procedure CalculateSHRowFIFO(record CostAccBlock CostAccRec,string location,record ORVc ORr,record SHVc SHp,row SHVc SHrw,Integer currow)
BEGIN
  val adjstockv,t,v;
  row SHVc SH2rw;
  Integer j;
  string 10 loc2;
  record INVc INr;
  Boolean testf;
  record SerNrTrackBlock SNrb;
  string 255 serialnr;
  val qty,sum;
  record OrdSettBlock OSb;
  row ORVc ORrw;

  BlockLoad(SNrb);
  BlockLoad(OSb);
  if (ReadFirstItem(SHrw.ArtCode,INr,true,false)) then begin end;
  for (j=0;j<currow;j=j+1) begin  
    MatRowGet(SHp,j,SH2rw);
    testf = true;
    loc2 = SH2rw.Location;
    if (blank(loc2)) then begin
      loc2 = location;
    end;
//    if (TestArtCode(SH2rw.ArtCode,SHrw.ArtCode,INr)) and (location==loc2) then begin
    if (TestArtCode(SH2rw.ArtCode,SHrw.ArtCode,INr)==false) then begin
      testf = false;
    end;
    if (CostAccRec.FIFOPerLocation!=0) then begin
      if (location!=loc2) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      adjstockv = adjstockv + SH2rw.Ship;
    end;
  end;
  if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
    SHrw.FIFORowVal = blankval;
    qty = blankval;
    serialnr = FirstInRange(SHrw.SerialNr,60);
    while (nonblank(serialnr)) begin
      SHrw.FIFORowVal = SHrw.FIFORowVal + FindCostPrice(SHrw.ArtCode,location,serialnr,1.00,adjstockv,false);
      qty = qty + 1;
      adjstockv = adjstockv + 1;
      serialnr = NextSerialNumber(SHrw.ArtCode,serialnr,SNrb);
      if (qty>=SHrw.Ship) then begin serialnr = ""; end;
    end;
  end else begin
    SHrw.FIFORowVal = FindCostPrice(SHrw.ArtCode,location,SHrw.SerialNr,SHrw.Ship,adjstockv,false);
  end;
  SHrw.FIFORowVal = Round(SHrw.FIFORowVal,SetRoundModeD(5));
  SHrw.FIFO = SHrw.FIFORowVal/SHrw.Ship;
  SHrw.FIFO = Round(SHrw.FIFO,SetRoundModeD(5));  
//  SHrw.WAB2 = (INr.WeighedAvPriceB2/INr.WeighedAvPrice)*SHrw.FIFO;
  SHrw.WAB2 = INr.WeighedAvPriceB2;
  if (SHp.OKFlag!=0) then begin
    if (OSb.UpdateGPWhenDel!=0) then begin
      if (SHrw.OrdRow<MatRowCnt(ORr)) then begin
        if (SHrw.FIFORowVal>=0 and SHrw.Ship>0 and SHrw.InStock>0 and SHrw.OrdRow>-1) then begin
          MatRowGet(ORr,SHrw.OrdRow,ORrw);
          v = SHrw.FIFORowVal;
          if (ORrw.PriceFactor!=0) then begin
            v = v*ORrw.PriceFactor;
          end;
          t = v + ORrw.Shipd2*SHrw.BBCostPrice;
          t = t/(SHrw.Ship+ORrw.Shipd2);
          SHrw.BBCostPrice = Round(t,DefaultRoundMode);
        end;
      end;
    end;
  end;
  RETURN;
END;

global
procedure UpdateSHFIFO(record SHVc SHp)
BEGIN
  record MainStockBlock MSb;
  record CostAccBlock CostAccRec;
  record SHVc RecSHr;
  row SHVc SHrw,SH2rw,RecSHrw;
  Integer i,rwcnt;
  Integer j;
  string 10 location,loc2;  
  Boolean isstruct;
  string 20 stockartcode;
  val t,recqty,adjstockv;
  record ORVc ORr;
  
  BlockLoad(CostAccRec);
  location = SHp.Location;
  if (blank(location)) then begin
    BlockLoad(MSb);
    location = MSb.MainStock;
  end;
  ORr.SerNr = SHp.OrderNr;
  ReadFirstMain(ORr,1,true);
  rwcnt = MatRowCnt(SHp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SHp,i,SHrw);
    loc2 = SHrw.Location;
    if (blank(loc2)) then begin
      loc2 = location;
    end;
    if (nonblank(SHrw.ArtCode)) then begin
      if (SHrw.Ship!=0) then begin
        isstruct = ExpandStructItem(SHrw.ArtCode,SHrw.Recepy,SHrw.Ship,RecSHr);
        if (isstruct==false) then begin
          CalculateSHRowFIFO(CostAccRec,loc2,ORr,SHp,SHrw,i);
        end else begin
          adjstockv = blankval;
          SHrw.FIFORowVal = blankval;
          if (MatRowCnt(RecSHr)!=1) then begin goto L88UpdateSHFIFOSkipRow; end;
//same as in  FindAdjstockvQtySHVc       
//          if (MatRowCnt(RecSHr)==0) then begin goto L88UpdateSHFIFOSkipRow; end;
          GetStockedItemFromRecepy(RecSHr,stockartcode,recqty);
          FindAdjstockvQtySHVc("SHVc",SHp,stockartcode,i,adjstockv);  
          SHrw.FIFORowVal = FindCostPrice(stockartcode,loc2,"",recqty,adjstockv,false);
          SHrw.FIFORowVal = Round(SHrw.FIFORowVal,SetRoundModeD(5));          
          SHrw.FIFO = SHrw.FIFORowVal/recqty;
          SHrw.FIFO = Round(SHrw.FIFO,SetRoundModeD(5));
        end;  
      end else begin
        SHrw.FIFO = blankval;
        SHrw.FIFORowVal = blankval;
      end;
      MatRowPut(SHp,i,SHrw);
    end;
L88UpdateSHFIFOSkipRow:;    
  end;
  RETURN;
END;

// Function safe, very few reads.
function Boolean FindDestinationFIFO(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,record ITVc ITr,string location,string serialnr,var record ItemHistVc destIHr)
begin
  Boolean res;
  string 200 thekey;
  Integer keys;
  Boolean foundf;
  
  res = false;
  destIHr.ArtCode = INr.Code;
  destIHr.Location = location;
//  if (FIFOPerLocation(INr,ITr,CAb)==0) then begin
  if (ItemCostPerLocation(INr)==0) then begin//must be same as in FindSourceFIFO otherwise we look here in all locations and in  FindSourceFIFO 1 location
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  ResetLoop(destIHr);
  foundf = true;
  while (LoopKey(thekey,destIHr,keys,foundf)) begin
    if (destIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (destIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      if (destIHr.Qty<0) then begin
        res = true;
        goto LFindDestinationFIFO;
      end else begin
        res = false;
        goto LFindDestinationFIFO;
      end;
    end;
  end;
LFindDestinationFIFO:;
  FindDestinationFIFO = res;
  RETURN;
END;

updating procedure UpdateItemHistory_In_OverDelivered(record MainStockBlock MSb,record CostAccBlock CAb,record ItemHistVc inIHr,record INVc INr,record ITVc ITr)
begin
  record ItemHistVc destinationIHr;
  record ItemHistVc oldIHr;
  val rem,useqty,totuseqty;
  Boolean foundf;
  
  rem = inIHr.Qty;
  while (rem>0) begin
    foundf = FindDestinationFIFO(MSb,CAb,INr,ITr,inIHr.Location,inIHr.SerialNr,destinationIHr);
    if (foundf) then begin
      RecordCopy(oldIHr,destinationIHr);
    end;
    destinationIHr.RemQty = -destinationIHr.RemQty;
    if (foundf) then begin
      if (rem>destinationIHr.RemQty) then begin
        useqty = destinationIHr.RemQty;
      end else begin
        useqty = rem;
      end;
    end else begin
      useqty = rem;
    end;
    if (foundf) then begin
      destinationIHr.Source = inIHr.SerNr;
      destinationIHr.RemQty = -(destinationIHr.RemQty - useqty);
      if (RecordUpdate(oldIHr,destinationIHr,false)==0) then begin end;
      totuseqty = totuseqty + useqty;
    end;
    rem = rem - useqty;
  end;
  if (totuseqty!=0) then begin
    RecordCopy(oldIHr,inIHr);
    inIHr.RemQty = inIHr.RemQty - totuseqty;
    inIHr.RemCostPrice = inIHr.RemCostPrice - (inIHr.TotCostPrice/inIHr.Qty)*totuseqty;
    if (RecordUpdate(oldIHr,inIHr,false)==0) then begin end;
  end;
  return;
end;

global
procedure FindTempStockRow(LongInt rownr,string artcode,Boolean matchartcodef,record TempStockVc TSr,var row TempStockVc resTSrw)
begin
  row TempStockVc TSrw;
  Integer i,rwcnt;
  Boolean testf;
  
  ClearRow(TSr,resTSrw,1);
  rwcnt = MatRowCnt(TSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TSr,i,TSrw);
    testf = true;
    if (TSrw.Row!=rownr) then begin testf = false; end;
    if (matchartcodef) then begin
      if (TSrw.ArtCode!=Left(artcode,len(TSrw.ArtCode))) then begin testf = false; end;
    end;    
    if (testf) then begin
      CopyRow(TSr,TSrw,resTSrw);
      i = rwcnt;
    end;
  end;
  return;
end;

global
updating procedure StoreItemHistory_In(record MainStockBlock MSb,string artcode,string serialnr,string location,string filename,Date td,Date fifod,val qty,val coeff,val totalcost,LongInt transnr,Integer rownr,Integer stockaffectf,string position,string vecode,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record INVc INr;
  record ITVc ITr;
  record CostAccBlock CAb;
  Integer primary,queuecostmodel;
  val t;
  Boolean setremqty;
  Date blankd;
  row TempStockVc TSrw;

  if (blank(artcode)) then begin 
    goto LStoreItemHistory_In;
  end;
  BlockLoad(CAb);  
  RecordNew(IHr);
  setremqty = true;
  IHr.ArtCode = artcode;
  IHr.Variety = "";
  IHr.StockAffectf = stockaffectf;
  if (ReadFirstItem(artcode,INr,false,false)) then begin
    if (artcode!=INr.Code) then begin
      IHr.Variety = right(artcode,len(artcode)-len(INr.Code));
      IHr.ArtCode = INr.Code;
    end;
    switch (INr.ItemType) begin
      case kItemTypePlain:
        switch (filename) begin
          case "SHVc": ;
          otherwise 
            IHr.StockAffectf = 0;
        end;
        setremqty = false;
      case kItemTypeStocked: 
        if (IHr.StockAffectf==0) then begin
          setremqty = false;
        end;
      case kItemTypeStructured:
        if (nonblank(INr.Recepy)) then begin
          IHr.StockAffectf = 0;
        end;
      case kItemTypeService:
        IHr.StockAffectf = 0;
        setremqty = false;
    end;
  end;
  IHr.SerialNr = serialnr;
  IHr.Location = location;
  IHr.FileName = filename;
  IHr.TransDate = td;
  IHr.FIFODate = fifod;
  IHr.Qty = qty;
  IHr.Qty2 = CalculateQty2(IHr.Qty,coeff);
  IHr.TransNr = transnr;
  IHr.Row = rownr;
  if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.ConsigStock = 1;
  end;
  if (TREOStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
    IHr.TREOStock = 1;
  end;
  if (setremqty) then begin
    IHr.RemQty = qty;
  end else begin
    IHr.RemQty = blankval;
  end;
  IHr.Source = -1;
  IHr.TotCostPrice = totalcost;
  IHr.RemCostPrice = totalcost; 
  
  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin
  end;
  if (usetmpstkf) then begin
    FindTempStockRow(IHr.Row,IHr.ArtCode,true,TSr,TSrw);
    IHr.PrimaryCostModel = TSrw.PrimaryCostModel;
    IHr.QueuedCostModel = TSrw.QueuedCostModel;
    IHr.ItemType = TSrw.ItemType;
    IHr.FIFOPerSerialNr = TSrw.FIFOPerSerialNr;
    IHr.FIFOPerLocation = TSrw.FIFOPerLocation;
    IHr.NoNLCostOnShip = TSrw.NoNLCostOnShip;
    IHr.WAPerLocation = TSrw.WAPerLocation;
    IHr.WABase2 = TSrw.WABase2;
    IHr.UpdWeightAvFromRet = TSrw.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = TSrw.UpdWeightAvFromRetPU;
    IHr.StockAffectf = TSrw.StockAffectf;
  end else begin
    GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
    IHr.PrimaryCostModel = primary;
    IHr.QueuedCostModel = queuecostmodel;
    IHr.ItemType = INr.ItemType;
    IHr.FIFOPerSerialNr = GetFIFOPerSerialNr(INr,ITr,CAb);
    IHr.FIFOPerLocation = FIFOPerLocation(INr,ITr,CAb);
    IHr.NoNLCostOnShip = CAb.NoNLCostOnShip;
    IHr.WAPerLocation = WAPerLocation(INr,ITr,CAb);
    IHr.WABase2 = CAb.WABase2;
    IHr.UpdWeightAvFromRet = CAb.UpdWeightAvFromRet;
    IHr.UpdWeightAvFromRetPU = CAb.UpdWeightAvFromRetPU;
  end;

  IHr.WATotCost = IHr.Qty*INr.WeighedAvPrice;

  IHr.WATotCostPerLoc = IHr.Qty*FindCostPriceWA(1,INr,location);
  IHr.CPTotCost = IHr.Qty*INr.InPrice;
  CalcCostPrice(IHr.Qty,INr.InPrice,INr.PriceFactor,0,100,t,IHr.CPTotCost);
//  IHr.CPTotCostPerLoc = IHr.Qty*;
  IHr.BPTotCost = IHr.Qty*FindCostPriceBasePrice(CAb,INr,ITr);
//  IHr.BPTotCostPerLoc = IHr.Qty*;
  IHr.Position = position;
/*  this may not be right
  switch (primary) begin
    case 1:
     IHr.CPTotCost = totalcost;
//     IHr.CPTotCostPerLoc = totalcost;
    case 2:
     IHr.BPTotCost = totalcost;
//     IHr.BPTotCostPerLoc = totalcost;
    case 3:
     IHr.WATotCost = totalcost;
     IHr.WATotCostPerLoc = totalcost;
  end;
*/

  IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");
  if (RecordStore(IHr,false)) then begin end;
  if (IHr.StockAffectf!=0) then begin
    UpdateItemHistory_In_OverDelivered(MSb,CAb,IHr,INr,ITr);
  end;
LStoreItemHistory_In:;
  return;
end;

