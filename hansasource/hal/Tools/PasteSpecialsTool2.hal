remote procedure GetAccStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val);
remote procedure CUListSClassRemote(LongInt,string,var Array string,var Integer);
external procedure ExtractObj(string,var Integer,var string);
remote procedure BuildFolioLists(record JobVc,var record RcVc);
remote procedure FillSerialNr2(string,string,var Array string,var Integer);
remote function LongInt FindReservation(string,Date,Time);
external procedure M4PadString(string,Integer,string,Boolean,var string);
remote procedure FillSerialNr(string,string,var Array string,var Integer);
remote procedure XXINTSTOCKXX(string,string,var Array string,var Integer);
remote procedure XXINTSTOCK2XX(string,var Array string,var Integer);

function boolean IsInList(String Element,Array string Aclist)
begin
  integer i;
  boolean res;
  
  i = 0;
  res = false;
  if nonblank(Element) then begin
    while nonblank(aclist[i]) begin
      if (Element == aclist[i]) then begin
        res = true;
      end;
      i = i + 1;
    end;
  end;
  IsInList = res;
  return;
end;

global
procedure JobCust2Array(record JobVc Jobr,var Array string Aclist,var Array string Aclistname)
begin
  integer i,j,r,rows;
  Row JobVc Jobrw;
  
  i = 0;
  if nonblank(Jobr.Source) then begin
    Aclist[i] = Jobr.Source;
    Aclistname[i] = Jobr.SourceName;
    i = i +1;
  end;
  if (nonblank(Jobr.CUCode) and (Jobr.CUCode<>Jobr.Source)) then begin
    Aclist[i] = Jobr.CUCode;
    Aclistname[i] = Jobr.CUName;
    i = i +1;
  end;
  rows = MatrowCnt(Jobr);
  for (j=0;j<rows;j=j+1) begin
    MatrowGet(Jobr,j,Jobrw);
    if nonblank(Jobrw.CUCode) then begin
      if Not IsInList(Jobrw.CUCode,Aclist) then begin 
        Aclist[i] = Jobrw.CUCode;
        Aclistname[i] = Jobrw.CUName;
        i = i + 1;
      end;
    end;
  end;
  return;
end;

procedure AddCharToStringOnOpen(var string res,string addch,Integer maxchar)
BEGIN  
  while (len(res)<maxchar) begin
    res = res & addch;
  end;
  RETURN;
END;

procedure WSVc_SerialNrSClassOnOpen(LongInt svonr,LongInt wonr,string item,Integer wn,var Array string asernrstr,var Integer acnt)
BEGIN
  record WOVc WOr;
  record SVOVc SVOr;
  row WOVc WOrw;
  row SVOVc SVOrw;
  Integer rwcnt,i;
  string 255 tstr;
  Boolean found;

  if (wonr!=-1) then begin
    WOr.SerNr = wonr;
    if (ReadFirstMain(WOr,1,true)) then begin
      rwcnt = MatRowCnt(WOr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(WOr,i,WOrw);
        found = true;   
        if (nonblank(item)) then begin
          if (WOrw.ArtCode==item) then begin found = true; end;
        end;
        if (found) then begin
          tstr = WOrw.SerialNr;
          M4PadString(tstr,31," ",false,tstr);
          tstr = tstr & WOrw.ArtCode;
          asernrstr[acnt] = tstr;
          acnt = acnt + 1;
        end;
      end;
    end;
  end else begin
    SVOr.SerNr = SVOnr;
    if (ReadFirstMain(SVOr,1,true)) then begin
      rwcnt = MatRowCnt(SVOr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SVOr,i,SVOrw);
        found = true;   
        if (nonblank(item)) then begin
          if (SVOrw.ArtCode==item) then begin found = true; end;
        end;
        if (found) then begin
          tstr = SVOrw.SerialNr;
          M4PadString(tstr,31," ",false,tstr);
          tstr = tstr & SVOrw.ArtCode;
          asernrstr[acnt] = tstr;
          acnt = acnt + 1;
        end;
      end;
    end;
  end;
  RETURN;
END;

global
procedure WSVc_SerialNrSClass(Integer type,Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record WSVc WSr;
  row WSVc WSrw;
  Integer rn,rwcnt;
  
  GetWindowRecord(mwn,WSr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(WSr);
  if (rn<=rwcnt) then begin
    MatRowGet(WSr,rn,WSrw);
    switch (WindowActiveField(mwn)) begin
      case "SerialNr": 
        if (type==1) then begin
          FillSerialNr(WSrw.ArtCode,WSr.Location,asernrstr,acnt);
        end else begin
          FillSerialNr2(WSrw.ArtCode,WSr.Location,asernrstr,acnt);
        end;
      case "MotherNr": WSVc_SerialNrSClassOnOpen(WSr.SVONr,WSr.WONr,WSrw.ArtCode,wn,asernrstr,acnt);
    end;
  end;  
  RETURN;
END;

procedure RetVc_SerialNrSClassOnOpen(LongInt svonr,LongInt wonr,string item,Integer wn,var Array string asernrstr,var Integer acnt)
begin
  record WOVc WOr;
  record SVOVc SVOr;
  row WOVc WOrw;
  row SVOVc SVOrw;
  Integer rwcnt,i;
  string 255 tstr;
  Boolean found;

  if (wonr!=-1) then begin
    WOr.SerNr = wonr;
    if (ReadFirstMain(WOr,1,true)) then begin
      rwcnt = MatRowCnt(WOr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(WOr,i,WOrw);
        found = true;   
        if (nonblank(item)) then begin
          if (WOrw.ArtCode==item) then begin found = true; end;
        end;
        if (found) then begin
          tstr = WOrw.SerialNr;
          M4PadString(tstr,31," ",false,tstr);
          tstr = tstr & WOrw.ArtCode;
          asernrstr[acnt] = tstr;
          acnt = acnt + 1;
        end;
      end;
    end;
  end else begin
    SVOr.SerNr = SVOnr;
    if (ReadFirstMain(SVOr,1,true)) then begin
      rwcnt = MatRowCnt(SVOr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SVOr,i,SVOrw);
        found = true;   
        if (nonblank(item)) then begin
          if (SVOrw.ArtCode==item) then begin found = true; end;
        end;
        if (found) then begin
          tstr = SVOrw.SerialNr;
          M4PadString(tstr,31," ",false,tstr);
          tstr = tstr & SVOrw.ArtCode;
          asernrstr[acnt] = tstr;
          acnt = acnt + 1;
        end;
      end;
    end;
  end;
  return;
end;

global
procedure RetVc_SerialNrSClass(Integer type,Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
begin
  record RetVc Retr;
  row RetVc Retrw;
  Integer rn,rwcnt;
  
  GetWindowRecord(mwn,Retr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(Retr);
  if (rn<=rwcnt) then begin
    MatRowGet(Retr,rn,Retrw);
    switch (WindowActiveField(mwn)) begin
      case "SerialNr": 
        if (type==1) then begin
          FillSerialNr(Retrw.ArtCode,Retr.Location,asernrstr,acnt);
        end else begin
          FillSerialNr2(Retrw.ArtCode,Retr.Location,asernrstr,acnt);
        end;
      case "MotherNr": RetVc_SerialNrSClassOnOpen(Retr.SVONr,-1,Retrw.ArtCode,wn,asernrstr,acnt);
    end;
  end;  
  return;
end;

global
procedure INTransferVc_SerialNrSClass(Integer type,Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record INTransferVc INTransferr;
  row INTransferVc INTransferrw;
  Integer rn,rwcnt;
  
  GetWindowRecord(mwn,INTransferr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(INTransferr);
  if (rn<=rwcnt) then begin
    MatRowGet(INTransferr,rn,INTransferrw);
    switch (type) begin
      case 1: FillSerialNr(INTransferrw.ArtCode,INTransferr.FrLocation,asernrstr,acnt);
      case 2: FillSerialNr2(INTransferrw.ArtCode,INTransferr.FrLocation,asernrstr,acnt);
    end;           
  end;  
  RETURN;
END;

global
procedure SerialNrRClass_SerialNrSClass(string fieldname,Integer type,Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record RcVc RepSpec;
  Integer rn,rwcnt;
  string 255 tstr;
  
  GetWindowRecord(mwn,RepSpec);
  switch (fieldname) begin
    case "f3":
      tstr = RepSpec.f3;
      if (FirstInRange(RepSpec.f3,20)!=LastInRange(RepSpec.f3,20)) then begin
        tstr = "";
      end;
    otherwise
      tstr = RepSpec.f1;
      if (FirstInRange(RepSpec.f1,20)!=LastInRange(RepSpec.f1,20)) then begin
        tstr = "";
      end;
  end;
  FillSerialNr(tstr,RepSpec.TransStr,asernrstr,acnt);
  RETURN;
END;

global
procedure SerialNoScanNPTSSClass_SerialNrSClass(Integer type,Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
begin
  record RcVc RepSpec;
  Integer rn,rwcnt;
  string 255 artcode,location;
  Integer own;
  record IVVc IVr;
  row IVVc IVrw;
  record IVCashVc IVCashr;
  row IVCashVc IVCashrw;
  
  own = MotherWindow(mwn);
  GetWindowRecord(mwn,RepSpec);
  artcode = "";
  switch (GetWindowFileName(own)) begin
    case "IVVc":
      GetWindowRecord(own,IVr);
      location = IVr.Location;
      if (RepSpec.long1>=0) then begin
        MatRowGet(IVr,RepSpec.long1,IVrw);
        artcode = IVrw.ArtCode;
      end;
    case "IVCashVc":
      GetWindowRecord(own,IVCashr);
      location = IVCashr.Location;
      if (RepSpec.long1>=0) then begin
        MatRowGet(IVCashr,RepSpec.long1,IVCashrw);
        artcode = IVCashrw.ArtCode;
      end;
  end;
  FillSerialNr(artcode,location,asernrstr,acnt);
  return;
end;

global
procedure OffHireVc_SerialNrSClass(Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record OffHireVc OffHirer;
  row OffHireVc OffHirerw;
  Integer rn,rwcnt;
  
  GetWindowRecord(mwn,OffHirer);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(OffHirer);
  if (rn<=rwcnt) then begin
    MatRowGet(OffHirer,rn,OffHirerw);
    XXINTSTOCKXX(OffHirerw.ArtCode,OffHirer.Location,asernrstr,acnt);
  end;  
  RETURN;
END;

global
procedure InternMovVc_SerialNrSClass(Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record InternMovVc InternMovr;
  row InternMovVc InternMovrw;
  Integer rn,rwcnt;
  
  GetWindowRecord(mwn,InternMovr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(InternMovr);
  if (rn<=rwcnt) then begin
    MatRowGet(InternMovr,rn,InternMovrw);
    XXINTSTOCKXX(InternMovrw.ArtCode,InternMovr.FrLocation,asernrstr,acnt);
  end;  
  RETURN;
END;


global
procedure RentResVc_SerialNrSClass(Integer wn,Integer mwn)
BEGIN
  record RentResVc RentResr;
  Array string 255 asernrstr;
  Integer i,acnt;
   
  GetWindowRecord(mwn,RentResr);
  XXINTSTOCK2XX(RentResr.Code,asernrstr,acnt);
  for (i=0;i<acnt;i=i+1) begin
    SetListString(wn,len(asernrstr[i]),asernrstr[i],false); 
  end;
  RETURN;
END;

global
procedure QualConVc_SerialNrSClass(Integer wn,Integer mwn,var Array string asernrstr,var Integer acnt)
BEGIN
  record QualConVc QualConr;
  
  GetWindowRecord(mwn,QualConr);
  if (GetWindowClass(wn)=="InspectConDClass")then  begin
    XXINTSTOCKXX(QualConr.ArtCode,"",asernrstr,acnt);
  end else begin
    FillSerialNr(QualConr.ArtCode,"",asernrstr,acnt);
  end;
  RETURN;
END;

global
procedure DispatchVc_SerialNrSClass(Integer wn,Integer mwn)
BEGIN
  record DispatchVc Dispatchr;
  row DispatchVc Dispatchrw;
  Integer rn,rwcnt;
  Array string 255 asernrstr;
  Integer i,acnt;
  
  GetWindowRecord(mwn,Dispatchr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(Dispatchr);
  if (rn<=rwcnt) then begin
    MatRowGet(Dispatchr,rn,Dispatchrw);
    XXINTSTOCKXX(Dispatchrw.ArtCode,Dispatchr.Location,asernrstr,acnt);
	  for (i=0;i<acnt;i=i+1) begin
	    SetListString(wn,len(asernrstr[i]),asernrstr[i],false); 
	  end;
  end;  
  RETURN;
END;

global
procedure RentINVc_SerialNrSClass(Integer wn,Integer mwn)
BEGIN
  record RentINVc RentINr;
  Array string 255 asernrstr;
  Integer i,acnt;
  
  GetWindowRecord(mwn,RentINr);
  XXINTSTOCKXX(RentINr.Code,"",asernrstr,acnt);
  for (i=0;i<acnt;i=i+1) begin
    SetListString(wn,len(asernrstr[i]),asernrstr[i],false); 
  end;
  RETURN;
END;

global
procedure CollectionVc_SerialNrSClass(Integer wn,Integer mwn)
BEGIN
  record CollectionVc Collectionr;
  row CollectionVc Collectionrw;
  Integer rn,rwcnt;
  Array string 255 asernrstr;
  Integer i,acnt;
  
  GetWindowRecord(mwn,Collectionr);
  rn = WindowActiveRow(mwn);
  rwcnt = MatRowCnt(Collectionr);
  if (rn<=rwcnt) then begin
    MatRowGet(Collectionr,rn,Collectionrw);
    XXINTSTOCKXX(Collectionrw.ArtCode,Collectionr.Location,asernrstr,acnt);
    for (i=0;i<acnt;i=i+1) begin
      SetListString(wn,len(asernrstr[i]),asernrstr[i],false); 
    end;
  end;  
  RETURN;
END;

procedure JobCustSClassonOpen(LongInt jobnr,Integer wn)
begin
  record JobVc Jobr;
  record RcVc RepSpec;
  Array string 20 Aclist;
  Array string 60 Aclistname;
  string 255 tstr,t2,t3;
  LongInt lastnr;
  Integer apos,pos;

  if (jobnr<0) then begin
  end else begin
    Jobr.SerNr = jobnr;
    if (ReadFirstMain(Jobr,1,true)) then begin
      RecordNew(RepSpec);
      JobCust2Array(Jobr,Aclist,Aclistname);
      BuildFolioLists(Jobr,RepSpec);
      pos = 0;
      while (nonblank(Aclist[pos])) begin
        M4PadString(Aclist[pos],30," ",false,tstr);
        tstr = tstr & Aclistname[pos];
        SetListString(wn,30,tstr,false);
        switch (pos) begin
          case 0: t2 = RepSpec.f3;
          case 1: t2 = RepSpec.f4;
          case 2: t2 = RepSpec.f5;
          case 3: t2 = RepSpec.f6;
        end;
        apos = 0;
        ExtractObj(t2,apos,t3);
        while (nonblank(t3)) begin
          lastnr = StringToLongInt(t3);
          if (lastnr>0) then begin
            M4PadString(Aclist[pos] & "." & lastnr,30," ",false,tstr);
            tstr = tstr & Aclistname[pos];
            SetListString(wn,30,tstr,false);
          end;
          ExtractObj(t2,apos,t3);
        end;
        pos = pos + 1;
      end;  
    end;
  end;
  return;
end;

global
procedure RestAccVc_JobCustSClass(Integer wn,Integer mwn)
BEGIN
  record RestAccVc RestAccr;
  LongInt jobnr;

  GetWindowRecord(mwn,RestAccr);
  jobnr = FindReservation(RestAccr.Resource,RestAccr.TransDate,RestAccr.TransTime);
  JobCustSClassonOpen(jobnr,wn);
  RETURN;
END;

global
procedure SoftFVc_JobCustSClass(Integer wn,Integer mwn)
BEGIN
  record SoftFVc SoftFr;
  LongInt jobnr;

  GetWindowRecord(mwn,SoftFr);
  JobCustSClassonOpen(SoftFr.SerNr,wn);
  RETURN;
END;

global
procedure RcVc_JobCustSClass(Integer wn,Integer mwn)
begin
  record RcVc Rcr;

  GetWindowRecord(mwn,Rcr);
  JobCustSClassonOpen(Rcr.long1,wn);
  return;
end;

global
procedure RepItemsVc_JobCustSClass(Integer wn,Integer mwn)
BEGIN
  record RepItemsVc RIr;

  GetWindowRecord(mwn,RIr);
  JobCustSClassonOpen(RIr.SerNr,wn);
  RETURN;
END;

global
procedure ShopBaskVc_JobCustSClass(Integer wn,Integer mwn)
BEGIN
  record ShopBaskVc ShopBaskr;

  GetWindowRecord(mwn,ShopBaskr);
  JobCustSClassonOpen(ShopBaskr.OwnerSerNr,wn);
  RETURN;
END;

procedure GuestSClassonOpen(LongInt jobnr,Integer wn)
BEGIN
  record JobVc Jobr;
  row JobVc Jobrw;
  Integer i,rwcnt;
  string 255 tstr;

  Jobr.SerNr = jobnr;
  if (ReadFirstMain(Jobr,1,true)) then begin
    rwcnt = MatRowCnt(Jobr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Jobr,i,Jobrw);
      if (nonblank(Jobrw.GuestCode)) then begin
        M4PadString(Jobrw.GuestCode,20," ",false,tstr);
        tstr = tstr & Jobrw.CUName;
        SetListString(wn,len(tstr),tstr,false);
      end;  
    end;    
  end;
  RETURN;
END;

global
procedure RestAccVc_GuestSClass(Integer wn,Integer mwn)
BEGIN
  record RestAccVc RestAccr;
  LongInt jobnr;
  record HotelBlock Hotelb;
  record JobVc Jobr;

  GetWindowRecord(mwn,RestAccr);
/*
  jobnr = FindReservation(RestAccr.Resource,RestAccr.TransDate,RestAccr.TransTime);
*/
  BlockLoad(Hotelb);
  Jobr.ResStatus = Hotelb.ChInSt;
  Jobr.ResCode = RestAccr.Resource;
  if (ReadLastKey("ResCodeStatus",Jobr,2,true)) then  begin end;    
  GuestSClassonOpen(Jobr.SerNr,wn);
  RETURN;
END;

global
procedure OnHotelGuestTouchScreenOClass_GuestSClass(Integer wn,Integer mwn)
begin
  record RcVc RepSpec;
  record JobVc Jobr;
  record HotelBlock Hotelb;

  GetWindowRecord(mwn,RepSpec);
  Jobr.SerNr = RepSpec.long2;
  if (Jobr.SerNr<=0) then begin
    BlockLoad(Hotelb);
    Jobr.ResStatus = Hotelb.ChInSt;
    Jobr.ResCode = RepSpec.f1;
    if (ReadLastKey("ResCodeStatus",Jobr,2,true)) then  begin end;    
  end;
  GuestSClassonOpen(Jobr.SerNr,wn);
  return;
end;

global
procedure RcVc_GuestSClass(Integer wn,Integer mwn)
BEGIN
  record RcVc Rcr;

  GetWindowRecord(mwn,Rcr);

  GuestSClassonOpen(StringToLongInt(Rcr.f1),wn);
  RETURN;
END;

global
procedure ShopBaskVc_GuestSClass(Integer wn,Integer mwn)
BEGIN
  record ShopBaskVc ShopBaskr;

  GetWindowRecord(mwn,ShopBaskr);
  GuestSClassonOpen(ShopBaskr.OwnerSerNr,wn);
  RETURN;
END;

global
procedure OnHotelGuestTouchScreenOClass_CUListSClass(Integer wn,Integer mwn)
begin
  record RcVc RepSpec;
  Array string 255 acusts;
  Integer i,acnt;

  GetWindowRecord(mwn,RepSpec);
  CUListSClassRemote(RepSpec.long2,RepSpec.f1,acusts,acnt);
  for (i=0;i<acnt;i=i+1) begin
    SetListString(wn,len(acusts[i]),acusts[i],false); 
  end;
  
  return;
end;

global
procedure RcVc_CUListSClass(Integer wn,Integer mwn)
begin
  record RcVc RepSpec;
  Array string 255 acusts;
  Integer i,acnt;

  GetWindowRecord(mwn,RepSpec);
  CUListSClassRemote(StringToLongInt(RepSpec.f1),RepSpec.f1,acusts,acnt);
  for (i=0;i<acnt;i=i+1) begin
    SetListString(wn,len(acusts[i]),acusts[i],false); 
  end;
  return;
end;

global
procedure PMSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record PMBlock PMRec;
  row PMBlock PMrw;
  Integer i,rwcnt;
  
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMRec,i,PMrw);
    astr[acnt] = PMrw.Code & "     ";
    astr[acnt] = Left(astr[acnt],5);
    astr[acnt] = astr[acnt] & PMrw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure PMSClassArrayOnOpen2(var Array string astr,var Array string astr2,var Array val av)
begin
  record PMBlock PMb;
  row PMBlock PMrw;
  Integer i,rwcnt;
  record ObjBalVc ObjBalr;
  val v;
  
  BlockLoad(PMb);
  rwcnt = MatRowCnt(PMb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMb,i,PMrw);
    astr[astr.length] = PMrw.Code;
    astr2[astr2.length] = PMrw.Comment;
    if (UserModuleAccess("modNL")==kAccessLevelFull) then begin
      ObjBalr.AccNumber = PMrw.AccNr;
      GetAccStartBalance(PMrw.AccNr,"",AddDay(CurrentDate,1),ObjBalr,0,0,"",0,v);
      av[av.length] = v;
    end;
  end;
  return;
end;

global
procedure PMSClassArrayOnOpen3(var Array string astr,var Array string astr2)
begin
  record PMBlock PMb;
  row PMBlock PMrw;
  Integer i,rwcnt;
  
  BlockLoad(PMb);
  rwcnt = MatRowCnt(PMb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMb,i,PMrw);
    astr[astr.length] = PMrw.Code;
    astr2[astr2.length] = PMrw.Comment;
  end;
  return;
end;

global
procedure WHTaxSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record WHTaxBlock WHTaxRec;
  row WHTaxBlock WHTaxrw;
  Integer i,rwcnt;
  
  BlockLoad(WHTaxRec);
  rwcnt = MatRowCnt(WHTaxRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WHTaxRec,i,WHTaxrw);
    astr[acnt] = WHTaxrw.Code & "     ";
    astr[acnt] = Left(astr[acnt],5);
    astr[acnt] = astr[acnt] & WHTaxrw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure PDMSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record PMBlock PMRec;
  row PMBlock PMrw;
  Integer i,rwcnt;
  record PDVc PDr;
  
  while (LoopMain(PDr,1,true)) begin
    astr[acnt] = PDr.Code & "     ";
    astr[acnt] = Left(astr[acnt],5);
    astr[acnt] = astr[acnt] & PDr.pdComment;
    acnt = acnt + 1;
  end;  
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMRec,i,PMrw);
    astr[acnt] = PMrw.Code & "     ";
    astr[acnt] = Left(astr[acnt],5);
    astr[acnt] = astr[acnt] & PMrw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure RestPMSClassArrayOnOpen(string machine,var Array string astr,var Integer acnt)
BEGIN
  record PMBlock PMRec;
  row PMBlock PMrw;
  record RestPMBlock RestPMRec;
  row RestPMBlock RestPMrw;
  Integer i,j,rwcnt,pmrwcnt;
  Boolean testf;
  
  BlockLoad(PMRec);
  BlockLoad(RestPMRec);
  pmrwcnt = MatRowCnt(PMRec);
  rwcnt = MatRowCnt(RestPMRec);
  for (j=0;j<rwcnt;j=j+1) begin
    MatRowGet(RestPMRec,j,RestPMrw);
    for (i=0;i<pmrwcnt;i=i+1) begin
      MatRowGet(PMRec,i,PMrw);
      testf = true;
      if (RestPMrw.PMCode!=PMrw.Code) then begin testf = false; end;
      if (nonblank(machine)) then begin
        if (SetInSet(machine,RestPMrw.MachineName)==false) then begin testf = false; end;
      end;
      if (testf) then begin
        astr[acnt] = PMrw.Code & "     ";
        astr[acnt] = Left(astr[acnt],5);
        astr[acnt] = astr[acnt] & PMrw.Comment;
        acnt = acnt + 1;
        goto L88;
      end;
    end;
L88:;    
  end;
  RETURN;
END;

global
procedure VATCodeSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record VATCodeBlock VATCodeRec;
  row VATCodeBlock VATCoderw;
  Integer i,rwcnt;
  
  BlockLoad(VATCodeRec);
  rwcnt = MatRowCnt(VATCodeRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATCodeRec,i,VATCoderw);
//    astr[acnt] = VATCoderw.VATCode & "    ";
    astr[acnt] = Left(VATCoderw.VATCode & "    ",14);
    astr[acnt] = astr[acnt] & VATCoderw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure VATVITypeSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record VATVITypeBlock VATVITypeb;
  row VATVITypeBlock VATVITypebrw;
  Integer i,rwcnt;
  
  BlockLoad(VATVITypeb);
  rwcnt = MatRowCnt(VATVITypeb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATVITypeb,i,VATVITypebrw);
    astr[acnt] = Left(VATVITypebrw.Code & "    ",5);
    astr[acnt] = astr[acnt] & VATVITypebrw.Name;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure VATIVTypeSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record VATIVTypeBlock VATIVTypeb;
  row VATIVTypeBlock VATIVTypebrw;
  Integer i,rwcnt;
  
  BlockLoad(VATIVTypeb);
  rwcnt = MatRowCnt(VATIVTypeb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VATIVTypeb,i,VATIVTypebrw);
    astr[acnt] = Left(VATIVTypebrw.Code & "    ",5);
    astr[acnt] = astr[acnt] & VATIVTypebrw.Name;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure CalDispGroupSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record CalDispGroupBlock CalDispGroupRec;
  row CalDispGroupBlock CalDispGrouprw;
  Integer i,rwcnt;
  
  BlockLoad(CalDispGroupRec);
  rwcnt = MatRowCnt(CalDispGroupRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CalDispGroupRec,i,CalDispGrouprw);
    astr[acnt] = Left(CalDispGrouprw.Code & "       ",8);
    if (nonblank(CalDispGrouprw.Comment)) then begin
      astr[acnt] = astr[acnt] & CalDispGrouprw.Comment & "    ";
    end;
    astr[acnt] = astr[acnt] & CalDispGrouprw.DefStr;    
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure DayShiftSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record SalesTimeBlock STr;
  
  BlockLoad(STr);
  if (nonblank(STr.Comment1)) then begin
    astr[acnt] = STr.Comment1;
    acnt = acnt + 1;
  end;
  if (nonblank(STr.Comment2)) then begin
    astr[acnt] = STr.Comment2;
    acnt = acnt + 1;
  end;
  if (nonblank(STr.Comment3)) then begin
    astr[acnt] = STr.Comment3;
    acnt = acnt + 1;
  end;
  if (nonblank(STr.Comment4)) then begin
    astr[acnt] = STr.Comment4;
    acnt = acnt + 1;
  end;
  if (nonblank(STr.Comment5)) then begin
    astr[acnt] = STr.Comment5;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure CustomDeclKeySClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record CustomDecKeyBlock CustomDecKeyRec;
  row CustomDecKeyBlock CustomDecKeyrw;
  Integer i,rwcnt;
  
  BlockLoad(CustomDecKeyRec);
  rwcnt = MatRowCnt(CustomDecKeyRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CustomDecKeyRec,i,CustomDecKeyrw);
    astr[acnt] = CustomDecKeyrw.Code & "     ";
    astr[acnt] = Left(astr[acnt],8);
    astr[acnt] = astr[acnt] & CustomDecKeyrw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure RegDefSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record RegDefBlock RegDefRec;
  row RegDefBlock RegDefrw;
  Integer i,rwcnt;
  
  BlockLoad(RegDefRec);
  rwcnt = MatRowCnt(RegDefRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RegDefRec,i,RegDefrw);
    astr[acnt] = RegDefrw.RegNo2;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure AC2SClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record AC2Block AC2Rec;
  row AC2Block AC2rw;
  Integer i,rwcnt;
  string 255 tstr;
  
  BlockLoad(AC2Rec);
  rwcnt = MatRowCnt(AC2Rec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(AC2Rec,i,AC2rw);
    tstr = AC2rw.Code;   
    AddCharToStringOnOpen(tstr," ",8);
    astr[acnt] = tstr & AC2rw.Comment;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure JobDescSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record JobDescBlock JobDescRec;
  row JobDescBlock JobDescrw;
  Integer i,rwcnt;
  
  BlockLoad(JobDescRec);
  rwcnt = MatRowCnt(JobDescRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(JobDescRec,i,JobDescrw);
    astr[acnt] = JobDescrw.Job;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure EthnicitySClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record EthnicityBlock EthnicityRec;
  row EthnicityBlock Ethnicityrw;
  Integer i,rwcnt;
  
  BlockLoad(EthnicityRec);
  rwcnt = MatRowCnt(EthnicityRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(EthnicityRec,i,Ethnicityrw);
    astr[acnt] = Ethnicityrw.Ethnicity;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure HealthStatusSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record HealthStatusBlock HealthStatusRec;
  row HealthStatusBlock HealthStatusrw;
  Integer i,rwcnt;
  
  BlockLoad(HealthStatusRec);
  rwcnt = MatRowCnt(HealthStatusRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(HealthStatusRec,i,HealthStatusrw);
    astr[acnt] = HealthStatusrw.HealthStatus;
    acnt = acnt + 1;
  end;
  return;
end;


global
procedure CourtesyTitlesTClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record CourtesyTitleBlock CourtesyTitleb;
  row CourtesyTitleBlock CourtesyTitlebrw;
  Integer i,rwcnt;
  
  BlockLoad(CourtesyTitleb);
  rwcnt = MatRowCnt(CourtesyTitleb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CourtesyTitleb,i,CourtesyTitlebrw);
    astr[acnt] = CourtesyTitlebrw.Title;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure EducationDegreesSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record EduDegreesBlock EducationDegreesRec;
  row EduDegreesBlock EducationDegreesrw;
  Integer i,rwcnt;
  
  BlockLoad(EducationDegreesRec);
  rwcnt = MatRowCnt(EducationDegreesRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(EducationDegreesRec,i,EducationDegreesrw);
    astr[acnt] = EducationDegreesrw.EducationDegree;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure LeaveSchemeSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record LeaveSchemeBlock LeaveSchemeRec;
  row LeaveSchemeBlock LeaveSchemerw;
  Integer i,rwcnt;
  
  BlockLoad(LeaveSchemeRec);
  rwcnt = MatRowCnt(LeaveSchemeRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LeaveSchemeRec,i,LeaveSchemerw);
    astr[acnt] = LeaveSchemerw.LeaveScheme;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure LoanStatusSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record LoanStatusBlock LoanStatusRec;
  row LoanStatusBlock LoanStatusrw;
  Integer i,rwcnt;
  
  BlockLoad(LoanStatusRec);
  rwcnt = MatRowCnt(LoanStatusRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LoanStatusRec,i,LoanStatusrw);
    astr[acnt] = LoanStatusrw.Status2;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure LoanSuccessSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record LoanSuccessBlock LoanSuccessRec;
  row LoanSuccessBlock LoanSuccessrw;
  Integer i,rwcnt;
  
  BlockLoad(LoanSuccessRec);
  rwcnt = MatRowCnt(LoanSuccessRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LoanSuccessRec,i,LoanSuccessrw);
    astr[acnt] = LoanSuccessrw.Success2;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure IDTSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record IDTBlock IDTRec;
  row IDTBlock IDTrw;
  Integer i,rwcnt;
  
  BlockLoad(IDTRec);
  rwcnt = MatRowCnt(IDTRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IDTRec,i,IDTrw);
    astr[acnt] = IDTrw.Desc;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure BookOrgSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record BookOrgBlock BookOrgRec;
  row BookOrgBlock BookOrgrw;
  Integer i,rwcnt;
  
  BlockLoad(BookOrgRec);
  rwcnt = MatRowCnt(BookOrgRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(BookOrgRec,i,BookOrgrw);
    astr[acnt] = BookOrgrw.Code & "     ";
    astr[acnt] = Left(astr[acnt],20);
    astr[acnt] = astr[acnt] & BookOrgrw.Name;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure TTRFieldSClassArrayOnOpen(var Array string astr,var Integer acnt)
BEGIN
  record TTRFieldBlock TTRFieldRec;
  row TTRFieldBlock TTRFieldrw;
  Integer i,rwcnt;
  
  BlockLoad(TTRFieldRec);
  rwcnt = MatRowCnt(TTRFieldRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TTRFieldRec,i,TTRFieldrw);
    astr[acnt] = Left(TTRFieldrw.Code,100);
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
procedure CourtesyTitlesSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record CourtesyTitleBlock CourtesyTitleRec;
  row CourtesyTitleBlock CourtesyTitlerw;
  Integer i,rwcnt;
  
  BlockLoad(CourtesyTitleRec);
  rwcnt = MatRowCnt(CourtesyTitleRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CourtesyTitleRec,i,CourtesyTitlerw);
    astr[acnt] = CourtesyTitlerw.Title;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure IntrastatTransCodeSClassArrayOnOpen(var Array string astr,var Integer acnt)
begin
  record ItrsTransCodeBlock IntrastatTransCodeb;
  row ItrsTransCodeBlock IntrastatTransCoderw;
  string 255 tstr;
  array string 255 aClass;
  Integer rwcnt,i;
  
  BlockLoad(IntrastatTransCodeb);
  rwcnt = MatRowCnt(IntrastatTransCodeb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IntrastatTransCodeb,i,IntrastatTransCoderw);
    M4PadString(IntrastatTransCoderw.Code,20,"",false,tstr);
    astr[acnt] = tstr & " " & IntrastatTransCoderw.Description;
    acnt = acnt + 1;
  end;
  return;
end;

global
function string 255 GetIntrastatTransCode(integer rwnr,string tstr)
begin
  record ItrsTransCodeBlock IntrastatTransCodeb;
  row ItrsTransCodeBlock IntrastatTransCoderw;
  string 255 res;
  Integer i;
  
  res = "";
  BlockLoad(IntrastatTransCodeb);
  MatRowGet(IntrastatTransCodeb,rwnr,IntrastatTransCoderw);
  i = len(IntrastatTransCoderw.Code);
  res = Left(tstr,i);
  GetIntrastatTransCode = res;
  return;
end;

global
procedure POSButtonsPagesSClassArrayOnOpen(string wc,LongInt page,var Array string astr)
begin
  record POSButtonsVc POSBr;
  Boolean testf,found;
  
  found = true;
  POSBr.WindowClass = wc;
  while (LoopMain(POSBr,1,found)) begin
    if (POSBr.WindowClass!=wc) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (POSBr.Page==page) then begin testf = false; end;
      if (testf) then begin
        astr[astr.length] = POSBr.Page;
      end;
    end;
  end;  
  return;
end;
