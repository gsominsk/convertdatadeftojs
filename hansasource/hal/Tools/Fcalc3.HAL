external procedure APFindPaydAmount(record OPrsVc,var val);
external procedure TRExtYc(record TRVc,var string);
external procedure KLIVGetPaidVal(record IVVc,var val,var val,Date);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt DateDiff(Date,Date);
external procedure APGetOnAccBalance(record RcVc,record CUVc,Boolean,var val,var val,var val,var val,var val,var val,var val,
                   Array string,Array val,var Integer,Array string,Array val,var Integer);
external function Integer GetIntYc(Date);
external procedure PSFindPaydAmount(record IPrsVc,var val);
external procedure GetAccDCStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val,var val);
external procedure GetAccDCBalance(string,string,Date,record ObjBalVc,Integer,Integer,Integer,string,var val,var val,Integer);
external function Boolean GetObjBal(string,string,var record ObjBalVc);
external procedure GetOnAccBalance(record RcVc,string,string,Boolean,Integer,var val,var val,var val,var val,var val,var val,var val,record SMVc,
                   Array string,Array val,var Integer);

//--------------SPDIVIDER--------------------

global procedure spdivider(integer c,integer w, integer x1,integer x2)
begin
  integer i;
  
  for (i=1;i<=w;i=i+1)
  begin
    if (c==0) then begin
      Black_Divider(x1,x2);
    end else begin
      Gray_Divider(x1,x2);
    end; 
  end;
  return;
end;

//------------------TURNOVER---------------------
global procedure TAX_turnover(date d1,date d2,string acc,var Val res1,var Val res2)
begin
  record TRVc TRr;
  record MainVc Mainr;
  row TRVc TRrw;
  integer i,amrow;
  Boolean TrHs,testf;
  string 21 keyname,acc1,acc2;
  Val DSum,CSum;
  
  TrHs=True;
  DSum=0;
  CSum=0;
  acc1=FirstInRange(acc,10);
  acc2=LastInRange(acc,10);
  keyname="TransDate";
  Mainr.AccNumber=acc1;
  Mainr.TransDate=d1;
  while (LoopMain(Mainr,2,TrHs)==True) begin
    testf=true;
    if (Mainr.AccNumber>acc2) then begin
      TrHs = false;
      testf=false; 
    end;
    if (Mainr.TransDate<d1) or (Mainr.TransDate>d2) then begin testf=false;end; 
      if (testf==True) then begin 
        TRr.Number=Mainr.TransNr;
        TRr.IntYc=Mainr.IntYc; 
        if (ReadFirstMain(TRr,2,true)) then begin   
          if (Mainr.TransDate==TRr.TransDate) then begin     
            amrow=MatRowCnt(TRr);
            for (i=0;i<amrow;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              if (TRrw.ovst==0) and (TRrw.stp==1) then begin
                if (TRrw.AccNumber==Mainr.AccNumber) then begin
                  DSum=DSum+TRrw.DebVal;
                  CSum=CSum+TRrw.CredVal;
                end;
              end;  
            end;  
          end;  
        end; 
     end;
  end;
  
  res1=DSum;
  res2=CSum;
  return;
end;


//------------------TURNOVER2---------------------

global procedure TAX_turnover2(date d1,date d2,string acc1,string acc2,var Val res)
begin
  record TRVc TRr;
  record MainVc Mainr,Mainr1;
  record AccVc Accr;
  row TRVc TRrw;
  LongInt i,amrow,j,CurCs,PrevCs;
  Boolean TrHs,IsAllCodes,IsFirst,testf;
  string 21 keyname,acccode,acc11,acc12,acc21,acc22;
  Val DSum,Ac1Sum,Ac2Sum,ChSum;
  
  TrHs=True;
  DSum=0;
  acc11=FirstInRange(acc1,10);
  acc12=LastInRange(acc1,10);
  acc21=FirstInRange(acc2,10);
  acc22=LastInRange(acc2,10);
  
  Mainr.TransDate=d1;
  Mainr.AccNumber=acc11;
  while (LoopMain(mainr,2,TrHs)==True) begin
    testf=true;
    if (Mainr.AccNumber>acc12) then begin
      testf = false;
      TrHs=false;
    end;
    if (Mainr.TransDate>d2) or (Mainr.TransDate<d1) then begin
      testf = false;
    end;
     
    if (testf==True) then begin 
      TRr.Number=Mainr.TransNr;
      TRr.IntYc=Mainr.IntYc; 
      if (ReadFirstMain(TRr,2,true)) then begin  
        if (Mainr.TransDate==TRr.TransDate) then begin   
          amrow=MatRowCnt(TRr);
          Ac1Sum=0; Ac2Sum=0; ChSum=0;
          for (i=0;i<amrow;i=i+1) begin //for empty codes
            MatRowGet(TRr,i,TRrw);
            if (TRrw.ovst==0) and Not (TRrw.CorspSer>=0) and (TRrw.stp==1) then begin
              ChSum=ChSum+ TRrw.DebVal- TRrw.CredVal;
              if (TRrw.AccNumber==Mainr.AccNumber)   then begin
                Ac1Sum=Ac1Sum+TRrw.DebVal;
              end;
              if (TRrw.AccNumber>=acc21) and  (TRrw.AccNumber<=acc22)   then begin
                Ac2Sum=Ac2Sum+TRrw.CredVal;
              end;
                  
              if (Chsum==0) then begin 
                if (Ac1Sum<>0) and (Ac2Sum<>0) then begin
                  if (Ac1Sum>Ac2Sum) then begin
                    DSum=Dsum+Ac2Sum;
                  end else begin
                    DSum=Dsum+Ac1Sum;
                  end;
                end;
                Ac1Sum=0;Ac2Sum=0;
              end;
            end;
          end;
       
          PrevCs=0;
          IsAllCodes=False;
             
           While (IsAllCodes==False) begin  //For other codes
             IsFirst=True;
             for (j=0;j<amrow;j=j+1) begin
               MatRowGet(TRr,j,TRrw);
               if  (TRrw.CorspSer>PrevCS) then begin
                 if (IsFirst) then begin
                   IsFirst=False;
                   CurCs=TRrw.CorspSer;  
                 end else begin    
                   if (TRrw.CorspSer<CurCS)  then begin
                     CurCS=TRrw.CorspSer;
                   end;
                 end; 
               end;   
             end;     
              
             Ac1Sum=0; Ac2Sum=0; ChSum=0;
             for (i=0;i<amrow;i=i+1) begin
               MatRowGet(TRr,i,TRrw);
                 if (TRrw.ovst==0) and (TRrw.CorspSer==PrevCs) and (TRrw.stp==1) then begin
                   ChSum=ChSum+ TRrw.DebVal- TRrw.CredVal;
                   if  (TRrw.AccNumber==Mainr.AccNumber)  then begin
                     Ac1Sum=Ac1Sum+TRrw.DebVal;
                   end;
                   if (TRrw.AccNumber>=acc21) and  (TRrw.AccNumber<=acc22) then begin
                     Ac2Sum=Ac2Sum+TRrw.CredVal;
                   end;
                   if (Chsum==0) then begin 
                     if (Ac1Sum<>0) and (Ac2Sum<>0) then begin
                       if (Ac1Sum>Ac2Sum) then begin
                         DSum=Dsum+Ac2Sum;
                       end else begin
                         DSum=Dsum+Ac1Sum;
                       end;
                     end;
                     Ac1Sum=0;Ac2Sum=0;
                   end;
                 end;      
               end;
    
               if (CurCs>PrevCs) then begin
                 PrevCs=CurCs;
               end else begin 
                 IsAllCodes=True;
               end;     
             End;
           end;
         end;     
    end;  
  end;
  
  res=DSum;
  
  return;
end;

//------------------BALANCE---------------------
global procedure TAX_balance(date d1,string acc,var Val res1,var Val res2)
begin
  record TRVc TRr;
  record MainVc Mainr;
  row TRVc TRrw;
  record FBVc FBr;
  row FBVc FBrw;
  record RegArchiveDetailVc RADr;
  integer i,amrow;
  Boolean TrHs,testf;
  string 21 keyname,acccode,acc1,acc2;
  Val DSum,CSum;
  
  TrHs=True;
  DSum=0;
  CSum=0;
  acc1=FirstInRange(acc,10);
  acc2=LastInRange(acc,10);
  keyname="TransDate";
  Mainr.AccNumber=acc1;
  while (LoopMain(Mainr,1,TrHs)==True) begin
    testf=true;
    if (Mainr.AccNumber>acc2) then begin
      TrHs = false;
      testf=false; 
    end;
    if (Mainr.TransDate>d1) then begin testf=false;end; 
    if (testf==true) then begin
      if (Mainr.FileName=="TRVc") then begin 
        TRr.Number=Mainr.TransNr;
        TRr.IntYc=Mainr.IntYc; 
        if (ReadFirstMain(TRr,2,true)) then begin  
          if (Mainr.TransDate==TRr.TransDate) then begin           
            amrow=MatRowCnt(TRr);
            for (i=0;i<amrow;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              acccode=TRrw.AccNumber;
              if (TRrw.ovst==0) and (TRrw.stp==1) then begin
                if (acccode==Mainr.AccNumber) then begin
                  DSum=DSum+TRrw.DebVal;
                  CSum=CSum+TRrw.CredVal;
                end;
              end;   
            end;
          end;    
        end;
      end;   
      if (Mainr.FileName=="FBVc") then begin 
        FBr.SerNr=Mainr.TransNr;
        if (ReadFirstMain(FBr,1,true)) then begin  
          if (Mainr.TransDate==FBr.TransDate) and (blank(FBr.Objects)) and (FBr.SimFlag==0) then begin           
            amrow=MatRowCnt(FBr);
            for (i=0;i<amrow;i=i+1) begin
              MatRowGet(FBr,i,FBrw);
              acccode=FBrw.AccNumber;    
              if (acccode==Mainr.AccNumber) then begin
                DSum=DSum+FBrw.DebVal;
                CSum=CSum+FBrw.CredVal;
              end;        
            end;
          end;    
        end;
      end;   
      if (Mainr.FileName=="RegArchiveDetailVc") then begin 
        RADr.SerNr=Mainr.TransNr;
        if (ReadFirstMain(RADr,1,true)) then begin  
          if (Mainr.TransDate==RADr.TransDate) and (blank(RADr.KeyTwo)) then begin           
            acccode=RADr.KeyOne;    
            if (acccode==Mainr.AccNumber) then begin
              DSum=DSum+RADr.dv;
              CSum=CSum+RADr.cv;
            end;
          end;    
        end;
      end;   
    end;
  end;
  
  res1=DSum;
  res2=CSum;
  return;
end;

//------------------BALANCE Portugal---------------------
global procedure TAX_balancePor(date d1,string acc,var Val res1,var Val res2)
begin
  record TRVc TRr;
  record MainVc Mainr;
  record AccVc Accr;
  row TRVc TRrw;
  record FBVc FBr;
  row FBVc FBrw;
  record RegArchiveDetailVc RADr;
  integer i,amrow;
  Boolean TrHs,testf;
  string 21 keyname,acccode,acc1,acc2, lastAcc;
  Val DSum,CSum;
  Val totCred, totDeb;
  
  TrHs=True;
  totCred = 0;
  totDeb = 0;
  DSum=0;
  CSum=0;
  acc1=FirstInRange(acc,10);
  acc2=LastInRange(acc,10);

  Mainr.AccNumber=acc1;
  while (LoopMain(Mainr,1,TrHs)==True) begin
    testf=true;
    if (Mainr.AccNumber>acc2) then begin
      TrHs = false;
      testf=false; 
    end;
    if (Mainr.TransDate>d1) then begin testf=false;end; 
    if (Mainr.AccNumber <> lastAcc) then begin
       if(nonblank(lastAcc)) then begin
          if(CSum > DSum) then begin
             totCred = totCred + CSum - DSum;   
          end
          else begin
             totDeb = totDeb + DSum - CSum;   
          end;
          CSum = 0;
          DSum = 0;
       end;
       lastAcc = Mainr.AccNumber;
    end;
        
    if (testf==true) then begin
      if (Mainr.FileName=="TRVc") then begin 
        TRr.Number=Mainr.TransNr;
        TRr.IntYc=Mainr.IntYc; 
        if (ReadFirstMain(TRr,2,true)) then begin  
          if (Mainr.TransDate==TRr.TransDate) then begin           
            amrow=MatRowCnt(TRr);
            for (i=0;i<amrow;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              acccode=TRrw.AccNumber;
              if (TRrw.ovst==0) and (TRrw.stp==1) then begin
                if (acccode==Mainr.AccNumber) then begin
                  DSum=DSum+TRrw.DebVal;
                  CSum=CSum+TRrw.CredVal;
                end;
              end;   
            end;
          end;    
        end;
      end;   
      if (Mainr.FileName=="FBVc") then begin 
        FBr.SerNr=Mainr.TransNr;
        if (ReadFirstMain(FBr,1,true)) then begin  
          if (Mainr.TransDate==FBr.TransDate) and (blank(FBr.Objects)) and (FBr.SimFlag==0) then begin           
            amrow=MatRowCnt(FBr);
            for (i=0;i<amrow;i=i+1) begin
              MatRowGet(FBr,i,FBrw);
              acccode=FBrw.AccNumber;    
              if (acccode==Mainr.AccNumber) then begin
                DSum=DSum+FBrw.DebVal;
                CSum=CSum+FBrw.CredVal;
              end;        
            end;
          end;    
        end;
      end;   
      if (Mainr.FileName=="RegArchiveDetailVc") then begin 
        RADr.SerNr=Mainr.TransNr;
        if (ReadFirstMain(RADr,1,true)) then begin  
          if (Mainr.TransDate==RADr.TransDate) and (blank(RADr.KeyTwo)) then begin           
            acccode=RADr.KeyOne;    
            if (acccode==Mainr.AccNumber) then begin
              DSum=DSum+RADr.dv;
              CSum=CSum+RADr.cv;
            end;
          end;    
        end;
      end;   
    end;
  end;
  if (Mainr.AccNumber <> lastAcc) then begin
     if(nonblank(lastAcc)) then begin
        if(CSum > DSum) then begin
           totCred = totCred + CSum - DSum;   
        end
        else begin
           totDeb = totDeb + DSum - CSum;   
        end;
        CSum = 0;
        DSum = 0;
     end;
     lastAcc = Mainr.AccNumber;
  end;
  
  res1=totDeb;
  res2=totCred;
  return;
end;

//------------------BALANCE2---------------------
global procedure TAX_balance2(date d1,string acc,var Val res1,var Val res2)
begin

  string 21 keyname,acccode,acc1,acc2;
  Val DSum,CSum;
  Val dSb,cSb;
  record AccVc Accr;
  record ObjBalVc ObjBalr;
  Boolean TrHs;

  acc1 = FirstInRange(acc,10);
  acc2 = LastInRange(acc,10);
  TrHs = true;
  Accr.AccNumber = acc1;
  while (LoopMain(Accr,1,TrHs)) begin
    if (Accr.AccNumber>acc2) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (GetObjBal(Accr.AccNumber,"",ObjBalr)) then begin
        GetAccDCStartBalance(Accr.AccNumber,"",d1,ObjBalr,0,0,"",0,dSb,cSb);
//StopAlert("d122 " & dSb & " cSb " & cSb);
        DSum =  DSum + dSb;
        CSum =  CSum + cSb;
      end;
    end;
  end;
  res1 = DSum;
  res2 = CSum;
  
  return;
end;

global procedure TAX_result(date d1,date d2,string acc,var Val res1,var Val res2)
begin
  string 21 keyname,acccode,acc1,acc2;
  Val DSum,CSum;
  Val dEb,cEb;
  Val dSb,cSb;
  record AccVc Accr;
  record ObjBalVc ObjBalr;
  Boolean TrHs;

  acc1 = FirstInRange(acc,10);
  acc2 = LastInRange(acc,10);

  TrHs = true;
  Accr.AccNumber = acc1;
  while (LoopMain(Accr,1,TrHs)) begin
    if (Accr.AccNumber>acc2) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (GetObjBal(Accr.AccNumber,"",ObjBalr)) then begin
        GetAccDCStartBalance(Accr.AccNumber,"",d1,ObjBalr,0,0,"",0,dSb,cSb);
        GetAccDCBalance(Accr.AccNumber,"",d2,ObjBalr,0,0,0,"",dEb,cEb,0);
        DSum =  DSum + (dEb-dSb);
        CSum =  CSum + (cEb-cSb);
      end;
    end;
  end;
  res1 = DSum;
  res2 = CSum;
  return;
end;

global procedure TAX_ardue(Date untildat,string acc,var Val res)
BEGIN
  record ARVc ARr;
  record CUVc CUr;
  record IVVc IVr;
  record RcVc RepSpec;
  Boolean found2,testf,found;
  LongInt diff;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,credited;
  Boolean backdatf;
  LongInt daysoverdue;
  record SMVc Dummyr;
  string 255 tstr;
  Array string 10 debaccs;
  Array val debbal;
  Integer debcnt;

  backdatf = true;
  RepSpec.d1=untildat;
  daysoverdue = StringToLongInt(acc);
  res = 0;
  if (untildat==CurrentDate) then begin backdatf = false; end;  
    RepSpec.d1 = untildat;
    found2 = true;
    if (backdatf) then begin
      ResetLoop(IVr);
      while (LoopKey("SerNr",IVr,1,found2)) begin
        testf = true;
        if (IVr.OKFlag==0) then begin testf = false; end;
        if (IVr.Invalid!=0) then begin testf = false; end;
        if (IVr.InvType==kInvoiceTypeEmployee or IVr.InvType==kInvoiceTypeCash or IVr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin testf = false; end;
        if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin 
          if (IVr.CredInv>0) then begin 
            testf = false; 
          end;
        end;
        if (found2==false) then begin testf = false; end;        
        if (daysoverdue>=0) then begin
          diff = DateDiff(untildat,IVr.PayDate);
//stopalert("IVr.SerNr " & IVr.SerNr & " diff " & diff  & " IVr.PayDate " & IVr.PayDate & " untildat " & untildat);
          if (diff<=daysoverdue) then begin testf = false; end;
        end;
        if (IVr.TransDate>untildat) then begin testf = false; end;
        if (testf) then begin
          KLIVGetPaidVal(IVr,baseopen,credited,untildat);
          baseopen = baseopen + credited;
          if (baseopen!=IVr.Sum4) then begin
            switch(IVr.InvType) begin
              case kInvoiceTypeCredit:
                t2 = -IVr.Sum4;
              case kInvoiceTypeCreditSpecialSales:
                t2 = -IVr.Sum4;
              otherwise
                t2 = IVr.Sum4;
            end;
            baseopen = t2 - baseopen;
            baseopen = MulRateToBase1(IVr.CurncyCode,baseopen,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
            res = res + baseopen;
//StartFormat(15);     
//OutString(0,0,"IVr.SerNr " & IVr.SerNr & " diff " & diff  & " IVr.PayDate " & IVr.PayDate & " baseopen " & baseopen,false);
//EndFormat;
          end;
        end;
      end;
    end else begin
      ResetLoop(ARr);
      while (LoopKey("InvoiceNr",ARr,1,found2)) begin
        testf = true;
        if (found2==false) then begin testf = false; end;
        if (daysoverdue>=0) then begin
          diff = DateDiff(untildat,ARr.DueDate);
          if (diff<=daysoverdue) then begin testf = false; end;
        end;
        if (testf) then begin
          baseopen = MulRateToBase1(IVr.CurncyCode,ARr.RVal,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
          res = res + baseopen;
        end;
      end;
    end;
    if (daysoverdue<0) then begin
      RepSpec.d1 = AddDay(untildat,-daysoverdue);
      RepSpec.d1 = untildat;
      found = true;
      while (LoopMain(CUr,1,found)) begin
        if (found) then begin
          GetOnAccBalance(RepSpec,CUr.Code,CUr.CurncyCode,true,1,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,Dummyr,debaccs,debbal,debcnt);      
          res = res + baseopen;
        end;
      end;
    end;
  RETURN;
END;

procedure KLVIGetPaidVal(record VIVc VIp,var val paidp,Date untildat)
BEGIN
  record OPrsVc OPrsr;
  record PurgeTRVc PurgeTRr;
  record TRVc TRr;
  row TRVc TRrw;
  record CLOutVc CLOutr;
  row CLOutVc CLOutrw;
  record VIVc VIr;
  Boolean found;
  val t,t2;
  Integer i,rwcnt;
  row VIVc VIrw;

  paidp = blankval;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VIp,i,VIrw);
    if (VIrw.stp==6) then begin
      paidp = paidp + VIrw.PrepayAmount;
    end;
  end;  
  OPrsr.VINr = VIp.SerNr;
  OPrsr.TransType = 0;
  found = true;
  while (LoopKey("VIDateKey",OPrsr,2,found)) begin
    if (OPrsr.TransDate>untildat) then begin found = false; end;
    if (OPrsr.VINr!=VIp.SerNr) then begin found = false; end;
    if (found) then begin
      switch (OPrsr.TransType) begin
        case 0:
          VIr.SerNr = OPrsr.TransNr;
          if (ReadFirstMain(VIr,1,true)) then begin
            if (VIr.Invalid==0) then begin
              if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) and (VIr.CredInv>0) then begin
                paidp = paidp + VIr.PayVal;
              end;
            end;
          end;
        case 1:
          APFindPaydAmount(OPrsr,t);
          paidp = paidp + t;
        case kOPrsTransTypePurgeNLTransaction:
          PurgeTRr.Number = OPrsr.TransNr;
          PurgeTRr.IntYc = GetIntYc(OPrsr.TransDate);
          PurgeTRr.TransRow = OPrsr.TransRow;
          if (ReadFirstMain(PurgeTRr,3,true)) then begin
            if (PurgeTRr.SerNr==OPrsr.VINr) then begin
              t = PurgeTRr.CurDebVal - PurgeTRr.CurCredVal;
              t2 = PurgeTRr.DebVal - PurgeTRr.CredVal;
              if ((blank(PurgeTRr.CurDebVal)) and (blank(PurgeTRr.CurCredVal))) then begin
                t = t2;
              end;
              paidp = paidp + t;
            end;
          end;
        case kOPrsTransTypeNLTransaction:
          TRr.Number = OPrsr.TransNr;
          TRr.IntYc = GetIntYc(OPrsr.TransDate);
          if (ReadFirstMain(TRr,2,true)) then begin
            rwcnt = MatRowCnt(TRr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              if (TRrw.stp==1) and (TRrw.ovst==0) then begin
                if (TRrw.SerNr==OPrsr.VINr) then begin
                  t = TRrw.CurDebVal - TRrw.CurCredVal;
                  t2 = TRrw.DebVal - TRrw.CredVal;
                  if ((blank(TRrw.CurDebVal)) and (blank(TRrw.CurCredVal))) then begin
                    t = t2;
                  end;
                  paidp = paidp + t;
                end;
              end;
            end;
          end;
        case 3:
          CLOutr.SerNr = OPrsr.TransNr;
          if (ReadFirstMain(CLOutr,1,true)) then begin
            rwcnt = MatRowCnt(CLOutr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(CLOutr,i,CLOutrw);
              if (CLOutrw.Type==2) then begin
                if (CLOutrw.TransNr==OPrsr.TransNr) then begin
                  t = CLOutrw.Sum;
                  paidp = paidp + t;
                end;
              end;
            end;
          end;          
      end;
    end;
  end;
  RETURN;
END;

global procedure TAX_apdue(Date untildat,string acc,var Val res)
BEGIN
  record APVc APr;
  record CUVc VEr;
  record VIVc VIr;
  record RcVc RepSpec;
  Boolean found,found2,testf;
  LongInt diff;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff;
  Boolean backdatf;
  LongInt daysoverdue;
  string 20 lastvecode;
  val vebal;
  Date sd;
  Array string 10 credaccs;
  Array val credbal;
  Integer credcnt;
  array val av1;
  array string 20 acur;
  Integer curcnt;

  backdatf = true;
  daysoverdue = StringToLongInt(acc);
  res = 0;
  if (untildat==CurrentDate) then begin backdatf = false; end;
  found = true;
    RepSpec.d1 = untildat;
    if (backdatf) then begin
      found2 = true;
      ResetLoop(VIr);
      sd.year = 1980;
      sd.month = 1;
      sd.day = 1;
      VIr.TransDate = sd;
      while (LoopKey("TransDate",VIr,1,found2)) begin
        if (VIr.TransDate>untildat) then begin found2 = false; end;//needforspeed
        testf = true;
        if (daysoverdue>=0) then begin
          diff = DateDiff(untildat,VIr.DueDate);
          if (diff<=daysoverdue) then begin testf = false; end;
        end;
        if (VIr.OKFlag==0) then begin testf = false; end;
        if (VIr.Invalid!=0) then begin testf = false; end;
        if (VIr.InvType==kInvoiceTypeEmployee or VIr.InvType==kInvoiceTypeCash or VIr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin testf = false; end;
        if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin 
          if (VIr.CredInv>0) then begin 
            testf = false; 
          end;
        end;
        if (found2==false) then begin testf = false; end;
        if (testf) then begin
          KLVIGetPaidVal(VIr,baseopen,untildat);
          if (baseopen!=VIr.PayVal) then begin
            switch(VIr.InvType) begin
              case kInvoiceTypeCredit:
                t2 = -VIr.PayVal;
              case kInvoiceTypeCreditSpecialSales:
                t2 = -VIr.PayVal;
              otherwise
                t2 = VIr.PayVal;
            end;
            baseopen = t2 - baseopen;
            baseopen = MulRateToBase1(VIr.CurncyCode,baseopen,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
            res = res + baseopen;
          end;
        end;
      end;
    end else begin
      found2 = true;
      ResetLoop(APr);
      while (LoopKey("SerNr",APr,1,found2)) begin
        testf = true;
        if (found2==false) then begin testf = false; end;
        if (testf) then begin
          if (daysoverdue>=0) then begin
            diff = DateDiff(untildat,APr.DueDate);
            if (diff<=daysoverdue) then begin testf = false; end;
          end;
        end;
        if (testf) then begin
          baseopen = MulRateToBase1(VIr.CurncyCode,APr.RVal,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
          res = res + baseopen;
        end;
      end;
    end;
    if (daysoverdue<0) then begin
      RepSpec.d1 = AddDay(untildat,-daysoverdue);
      RepSpec.d1 = untildat;
      found = true;
      while (LoopMain(VEr,1,found)) begin
        if (found) then begin
          APGetOnAccBalance(RepSpec,VEr,true,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,credaccs,credbal,credcnt,acur,av1,curcnt);
          res = res + baseopen;
        end;
      end;
    end;
  RETURN;
END;


//------------------Tax Transactions BALANCE---------------------
global 
procedure TTR_balance(date d1,string acc,var Val res)
begin
  record TTRVc TTRr;
  Boolean TrHs,testf;
  string 20 acc1,acc2;
  
  res = 0;
  acc1 = FirstInRange(acc,10);
  acc2 = LastInRange(acc,10);
  TTRr.AccNumber = acc1;
  TrHs = True;  
  while (LoopKey("ACTransDate",TTRr,1,TrHs)==True) begin
    testf = true;
    if (TTRr.AccNumber>acc2) then begin
      TrHs = false; testf = false; 
    end;
    if (TTRr.TransDate>d1) then begin
      testf = false;
    end; 
    if (TTRr.Invalid==1) then begin
      testf = false;
    end;
    if (testf==true) then begin
      res = res + TTRr.B1Val;  
    end;   
  end;
  return;
end;

//------------------Tax Transactions Turnover---------------------
global 
procedure TTR_turnover(date d1,date d2,string acc,var Val res)
begin
  record TTRVc TTRr;
  Boolean TrHs,testf;
  string 20 acc1,acc2;
  
  res = 0;
  acc1 = FirstInRange(acc,10);
  acc2 = LastInRange(acc,10);
  TTRr.AccNumber = acc1;
  TTRr.TransDate = d1;
  TrHs = True;  
  while (LoopKey("ACTransDate",TTRr,2,TrHs)==True) begin
    testf = true;
    if (TTRr.AccNumber>acc2) then begin
      TrHs = false; testf = false; 
    end;
    if (TTRr.TransDate>d2) then begin
      testf = false;
    end; 
    if (TTRr.Invalid==1) then begin
      testf = false;
    end;
    if (testf==true) then begin
      res = res + TTRr.B1Val;  
    end;   
  end;
  return;
end;