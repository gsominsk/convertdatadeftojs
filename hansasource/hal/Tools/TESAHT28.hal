external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);
external function string 255 NumToHex(string);

enum begin
  TESA_STX = 2,  // 0x02
  TESA_ETX = 3,  // 0x03
  TESA_ENQ = 5,  // 0x05
  TESA_ACK = 6,  // 0x06
  TESA_NAK = 21  // 0x15
  TESA_DELIMITER = 179 //0xb3
end;

function string 255 CommandSuccesful(string replystr)
begin
  string 255 replyerrstr;
  Integer pos,l,field;
  string 255 tstr;
  Integer i1;
    
  l = BytesInString(replystr);
  for (pos=0;pos<l;pos=pos+1) begin
    i1 = GetByteFromString(replystr,pos); 
    switch (i1) begin
      case TESA_DELIMITER:
        field = field  + 1;
      otherwise
        switch (field) begin
          case 1: 
            replyerrstr = replyerrstr & chr(i1);
        end;     
    end;
  end;
  CommandSuccesful = replyerrstr;
  return;
end;

function string 255 CalculateLRC(string CtrlSeq)
begin
  string 255 res;
  Integer i,resi;
  
  resi = 0;
  for (i=0;i<len(CtrlSeq);i=i+1) begin
    resi = BitXor(resi,asc(Mid(CtrlSeq,i,1)));
  end;
//  res = chr(resi);
//  res = NumToHex(resi);
//  res = Right(res,2);

  res = chr(13);
  CalculateLRC = res;
  return;
end;

procedure TESAHT28SendCommand(LongInt starttick,string command,string CtrlSeq,Integer LogComm,LongInt JobNr)
begin
  Area nt;
  transaction string 255 gTesaCurrentCtrlSeq;
  transaction string 255 gTesaCurrentCommand;
  transaction LongInt gTesaStartTick;
  transaction LongInt gTesaJobNr;
  Integer err;

  gTesaCurrentCommand = command;
  gTesaCurrentCtrlSeq = CtrlSeq;
  gTesaStartTick = starttick;
  gTesaJobNr = JobNr;
  
  AddTextToArea(CtrlSeq,nt);  
  if (LogComm!=0) then begin
    LogText(0,"TESAHT28SendCommand = " & CtrlSeq);
  end;
  err = SendTESAHT28(nt);
  if (err!=0) then begin
    MessageBox(err,"");
  end;
  return;
end;

procedure TESAHT28EncodeNewCard(record RcVc RepSpec,Integer typ,Integer LogComm,LongInt JobNr)
begin
  string 255 CtrlSeq;
  string 255 tstr,encoderno;
  Time tt;
  transaction Boolean gTesaNAKf;
  record LocalMachineBlock LMb;
  
  BlockLoad(LMb);  
  encoderno = LMb.LockSysEncoderNo;
  if (blank(encoderno)) then begin
    encoderno = "1";
  end;
  gTesaNAKf = false;
//STX|CN1|1|E|101|102| | |6| | |12140193| |101|MR SMITH |ETXLRC
  switch (typ) begin
    case 1:
      CtrlSeq = "CC" & RepSpec.long1 & chr(TESA_DELIMITER);
    otherwise
      CtrlSeq = "CN" & RepSpec.long1 & chr(TESA_DELIMITER);
  end;
  CtrlSeq = CtrlSeq & encoderno & chr(TESA_DELIMITER);//1
  CtrlSeq = CtrlSeq & "E" & chr(TESA_DELIMITER);//2
  CtrlSeq = CtrlSeq & RepSpec.f1 & chr(TESA_DELIMITER);//3
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//4
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//5
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//6
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//7
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//8
  tt = RepSpec.sStartTime;
  
  tstr = Left(tt,2);
  tstr = tstr & DateToString(RepSpec.sStartDate,"DDMMYY");
  CtrlSeq = CtrlSeq & tstr & chr(TESA_DELIMITER);//9

  tt = RepSpec.sEndTime;
  tstr = Left(tt,2);
  tstr = tstr & DateToString(RepSpec.sEndDate,"DDMMYY");
  CtrlSeq = CtrlSeq & tstr & chr(TESA_DELIMITER);//10

  CtrlSeq = CtrlSeq & "HANSA" & chr(TESA_DELIMITER);//11
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//12
  CtrlSeq = CtrlSeq & chr(TESA_DELIMITER);//13


  CtrlSeq = CtrlSeq & chr(TESA_ETX);
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = chr(TESA_STX) & chr(TESA_DELIMITER) & CtrlSeq;
  switch (typ) begin
    case 1:
      TESAHT28SendCommand(GetCurTick,"CC",CtrlSeq,LogComm,JobNr);
    otherwise
      TESAHT28SendCommand(GetCurTick,"CN",CtrlSeq,LogComm,JobNr);
  end;
  return;
end;

global
procedure ElectronicLockingSystemEncodeCard(record RcVc RepSpec,Integer typ,LongInt JobNr)
begin
  record ELockSystemBlock ELSb;
  
  BlockLoad(ELSb);
  switch (ELSb.ElectronicLockingSystemType) begin
    case kELockSystemTypeNone:
      MessageBox("",USetStr(25921));
    case kELockSystemTypeTESAHT28:
      TESAHT28EncodeNewCard(RepSpec,typ,ELSb.LogComm,JobNr);
  end;
  return;
end;

procedure TESAHT28Checkout(record RcVc RepSpec,Integer LogComm)
begin
  string 255 CtrlSeq;
  string 255 tstr,encoderno;
  Time tt;
  record LocalMachineBlock LMb;
  
  BlockLoad(LMb);  
  encoderno = LMb.LockSysEncoderNo;
  if (blank(encoderno)) then begin
    encoderno = "1";
  end;  
//STX|CO|0|1101|ETXLRC
  
  CtrlSeq = "CO" & chr(TESA_DELIMITER);
  CtrlSeq = CtrlSeq & encoderno & chr(TESA_DELIMITER);//1
  CtrlSeq = CtrlSeq & RepSpec.f1 & chr(TESA_DELIMITER);//2

  CtrlSeq = CtrlSeq & chr(TESA_ETX);
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = chr(TESA_STX) & chr(TESA_DELIMITER) & CtrlSeq;
  TESAHT28SendCommand(GetCurTick,"CO",CtrlSeq,LogComm,-1);
  return;
end;

global
procedure ElectronicLockingSystemCheckout(record RcVc RepSpec)
begin
  record ELockSystemBlock ELSb;
  
  BlockLoad(ELSb);
  switch (ELSb.ElectronicLockingSystemType) begin
    case kELockSystemTypeNone:
      MessageBox("",USetStr(25921));
    case kELockSystemTypeTESAHT28:
      TESAHT28Checkout(RepSpec,ELSb.LogComm);
  end;
  return;
end;


procedure TESAHT28ENQ(LongInt starttick,string command,string CtrlSeq)
begin
  Area nt;
  transaction string 255 gTesaCurrentCtrlSeq;
  transaction string 255 gTesaCurrentCommand;
  transaction LongInt gTesaStartTick;

  gTesaCurrentCommand = command;
  gTesaCurrentCtrlSeq = CtrlSeq;
  gTesaStartTick = starttick;
  AddTextToArea(chr(TESA_ENQ),nt);  
//Trace("4.TESA_NAK "," TESAHT28ENQ ");  
  SendTESAHT28(nt);
  return;
end;

//85.129.202.119:6669
global
procedure TESTHT28ENQ()
begin
  Area nt;
  record RcVc RepSpec;

//  AddTextToArea(chr(TESA_ENQ),nt);  
//  SendTESAHT28(nt);

  TESAHT28EncodeNewCard(RepSpec,0,1,-1);
//  TESAHT28Checkout;
 //STX message ETX LRC
  return;
end;

global
updating procedure TESAHT28UpdateReservation(LongInt gTesaJobNr,string replyerrstr)
begin
  record JobVc Jobr;
  record JobVc oldJobr;
  Integer cnt;
  
  if (gTesaJobNr>0) then begin
    Jobr.SerNr = gTesaJobNr;
    if (ReadFirstMain(Jobr,1,true)) then begin
      RecordCopy(oldJobr,Jobr);
      cnt = StringToInt(Right(replyerrstr,len(replyerrstr)-2));
      Jobr.ElectronicCardsNo = Jobr.ElectronicCardsNo + cnt;
      RecordUpdate(oldJobr,Jobr,true);
    end;
  end;
  return;
end;

global
function Boolean ReceiveTESAHT28Reply(Area reply)
begin
  Boolean res;
  LongInt l,i;
  transaction string 255 gTesaCurrentCtrlSeq;
  transaction string 255 gTesaCurrentCommand;
  transaction LongInt gTesaStartTick;
  transaction Boolean gTesaNAKf;
  transaction LongInt gTesaJobNr;
  string 255 tstr,replyerrstr;
  record ELockSystemBlock ELSb;
  
  BlockLoad(ELSb);
  if (ELSb.LogComm!=0) then begin
    LogText(0,"1.ReceiveTESAHT28Reply");  
    CreateFile("ReceiveTESAHT28Reply.txt");
    CloseFile;
    WriteAreaToFile(reply,"ReceiveTESAHT28Reply.txt",0);
  end;
  l = CountLinesInArea(reply);
  tstr = GetLineFromArea(reply,0);

  LogText(0,"ReceiveTESAHT28Reply = " & tstr);

  switch (asc(Left(tstr,1))) begin
    case TESA_NAK:
      if (ELSb.LogComm!=0) then begin
        LogText(0,"1.TESA_NAK" & "TESAHT28SendCommand gTesaCurrentCtrlSeq=" & gTesaCurrentCtrlSeq & " len " & len(gTesaCurrentCtrlSeq));  
      end;
      if ((GetCurTick-gTesaStartTick)<5000) then begin//should have been seconds max 2
        TESAHT28ENQ(gTesaStartTick,gTesaCurrentCommand,gTesaCurrentCtrlSeq);
        gTesaNAKf = true;
      end else begin
        res = true;
      end;
    case TESA_ACK:
      if (ELSb.LogComm!=0) then begin
        LogText(0,"2.TESA_ACK " & " gTesaCurrentCommand " & gTesaCurrentCommand);  
      end;
      if (gTesaNAKf) then begin
        if (nonblank(gTesaCurrentCommand)) then begin
          TESAHT28SendCommand(gTesaStartTick,gTesaCurrentCommand,gTesaCurrentCtrlSeq,ELSb.LogComm,gTesaJobNr);        
        end;
      end;
    case TESA_STX:
      if (ELSb.LogComm!=0) then begin
        LogText(0,"3.TESA_STX " & " tstr " & tstr);  
      end;
      res = true;
      replyerrstr = CommandSuccesful(tstr);
      if (ELSb.LogComm!=0) then begin
        LogText(0,"4.replyerrstr " & replyerrstr);  
      end;
      if (Left(replyerrstr,len(gTesaCurrentCommand))==gTesaCurrentCommand) then begin
        switch (gTesaCurrentCommand) begin
          case "CN":
            MessageBox(0,USetStr(25922));
            queued.TESAHT28UpdateReservation(gTesaJobNr,replyerrstr);
          case "CC":
            MessageBox(0,USetStr(25922));
            queued.TESAHT28UpdateReservation(gTesaJobNr,replyerrstr);
          case "CO":
            MessageBox(0,USetStr(25923));
        end;
     end else begin
        MessageBox(0,USetStr(25925) & " = " & replyerrstr);          
     end;
    otherwise
      MessageBox(0,USetStr(25924));
  end;
  ReceiveTESAHT28Reply = res;
  return;
end;






//ColourPushButtonTag

function Integer ReplyInTESAHT28Buffer(var string replystr)
begin
  Integer noErr;
  
  replystr = replystr & ReadComPort(0,255-len(replystr));
  ReplyInTESAHT28Buffer = noErr;
  return;
end;

function Integer WaitTESAHT28Time(var string replystr)
begin
  Integer res;
  Integer noErr;
  LongInt timeout;
  LongInt tickcount, tick;

  res = 12400;
  replystr = "";
  timeout = 100;
  tick = GetCurTick;
  tickcount = tick;
  while ((tickcount-tick)<timeout) begin
    tickcount = GetCurTick;
    res = ReplyInTESAHT28Buffer(replystr);
    if (len(replystr)>0) then begin
      res = noErr;
      goto LWaitTESAHT28Time;
    end;
  end;
LWaitTESAHT28Time:;
  WaitTESAHT28Time = res;
  return;
end;

function Integer SendTESAHT28_COM(string CtrlSeq)
begin
  LongInt starttick;
  Boolean testf;
  Integer res,err,noErr;
  string 255 replystr;
  Integer enqint;
  
  err = OpenComPort(0,"COM1",9600,-1,8,2,kFlowControlDefault);

  err = OutComPort(0,CtrlSeq);
  
  starttick = GetCurTick;
  testf = true;
  while (testf) begin
    err = WaitTESAHT28Time(replystr);
    if (nonblank(replystr)) then begin
      enqint = asc(Left(replystr,1));
      switch (enqint) begin
        case TESA_NAK: //retransmit
          err = OutComPort(0,CtrlSeq);
          if (err!=noErr) then begin
            res = err;
            goto LSendTESAHT28_COM;
          end;
        case TESA_ACK: //continue        
          testf = false;
          err = WaitTESAHT28Time(replystr);
          replystr = chr(enqint) & replystr;
          res = noErr;
        otherwise 
          testf = false;
          err = WaitTESAHT28Time(replystr);
          res = noErr;
      end;
    end;
    if ((GetCurTick-starttick)>2000) then begin
      testf = false;
    end;
  end;
LSendTESAHT28_COM:; 
  CloseComPort(0);
  LogText(0,"CtrlSeq=" & CtrlSeq);
  LogText(0,"replystr=" & replystr);
  SendTESAHT28_COM = res;
  return;
end;

procedure TESAHT28SendCommand_COM(LongInt starttick,string command,string CtrlSeq)
begin
  Area nt;
  transaction string 255 gTesaCurrentCtrlSeq;
  transaction string 255 gTesaCurrentCommand;
  transaction LongInt gTesaStartTick;

  gTesaCurrentCommand = command;
  gTesaCurrentCtrlSeq = CtrlSeq;
  gTesaStartTick = starttick;
    
  SendTESAHT28_COM(CtrlSeq);
  return;
end;


procedure TESAHT28EncodeNewCard_COM()
begin
  string 255 CtrlSeq;
  string 255 tstr;
  Time tt;
  
//STX|CN1|1|E|101|102| | |6| | |12140193| |101|MR SMITH |ETXLRC
  
  CtrlSeq = "CN1|";
  CtrlSeq = CtrlSeq & "1|";//1
  CtrlSeq = CtrlSeq & "E|";//2
  CtrlSeq = CtrlSeq & "1101|";//3
  CtrlSeq = CtrlSeq & "|";//4
  CtrlSeq = CtrlSeq & "|";//5
  CtrlSeq = CtrlSeq & "|";//6
  CtrlSeq = CtrlSeq & "|";//7
  CtrlSeq = CtrlSeq & "|";//8
  tt = CurrentTime;
  tt.hour = tt.hour + 1;//
  
  tstr = Left(tt,2);
  tstr = tstr & DateToString(CurrentDate,"DDMMYY");
  CtrlSeq = CtrlSeq & tstr & "|";//9

  tt.hour = tt.hour + 1;
  tstr = Left(tt,2);
  tstr = tstr & DateToString(CurrentDate,"DDMMYY");
  CtrlSeq = CtrlSeq & tstr & "|";//10

  CtrlSeq = CtrlSeq & "HANSA|";//11
  CtrlSeq = CtrlSeq & "|";//12
  CtrlSeq = CtrlSeq & "|";//13


  CtrlSeq = CtrlSeq & chr(TESA_ETX);
  CtrlSeq = CtrlSeq & CalculateLRC(CtrlSeq);
  CtrlSeq = chr(TESA_STX) & "|" & CtrlSeq;
  TESAHT28SendCommand_COM(GetCurTick,"CN",CtrlSeq);
  return;
end;

global
procedure TESTHT28ENQ_COM()
begin
  string 255 CtrlSeq;

  CtrlSeq = chr(TESA_ENQ);
  TESAHT28SendCommand_COM(GetCurTick,"ENQ",CtrlSeq);

  return;
end;

global
procedure TESTHT28NewCard_COM()
begin
  TESAHT28EncodeNewCard_COM;
  return;
end;




/*
global
procedure TESAHT28ResendCommandIdleTask(string arg)
begin
  Integer pos;
  LongInt tick;
  string 255 CtrlSeq;
  string 255 Command;
  string 255 tstr;
  
  pos = 0;
  ExtractObjWithSeparator(";",arg,false,pos,tstr);
  tick = STringToLongInt(tstr);
  ExtractObjWithSeparator(";",arg,false,pos,Command);
  ExtractObjWithSeparator(";",arg,false,pos,CtrlSeq);
  TESAHT28SendCommand(tick,Command,CtrlSeq);        
  return;
end;

global
procedure TESAHT28SendENQCommandIdleTask(string arg)
begin
  Integer pos;
  LongInt tick;
  string 255 CtrlSeq;
  string 255 Command;
  string 255 tstr;
  
  pos = 0;
  ExtractObjWithSeparator(";",arg,false,pos,tstr);
  tick = STringToLongInt(tstr);
  ExtractObjWithSeparator(";",arg,false,pos,Command);
  ExtractObjWithSeparator(";",arg,false,pos,CtrlSeq);
  TESAHT28ENQ(tick,Command,CtrlSeq);
  return;
end;

global
procedure ReceiveTESAHT28Reply(Area reply)
begin
  LongInt l,i;
  transaction string 255 gTesaCurrentCtrlSeq;
  transaction string 255 gTesaCurrentCommand;
  transaction LongInt gTesaStartTick;
  string 255 tstr;
  Time startt;
  Date td;

  CreateFile("ReceiveTESAHT28Reply.txt");
  CloseFile;
  WriteAreaToFile(reply,"ReceiveTESAHT28Reply.txt",0);

  l = CountLinesInArea(reply);
  tstr = GetLineFromArea(reply,0);

  LogText(0,"ReceiveTESAHT28Reply = " & tstr);

  switch (asc(Left(tstr,1))) begin
    case TESA_NAK:

      if ((GetCurTick-gTesaStartTick)<20000) then begin//2 seconds max
        startt = CurrentTime;
        startt.second = startt.second + 1;
        td = CurrentDate;
        NewTimedTask("TESAHT28SendENQ","Send TESAHT28ENQ","TESAHT28SendENQCommandIdleTask",gTesaStartTick & ";" & gTesaCurrentCommand & ";" & gTesaCurrentCtrlSeq,td,startt,"","");
      end;
    case TESA_ACK:
      if (nonblank(gTesaCurrentCommand)) then begin
        startt = CurrentTime;
        startt.second = startt.second + 1;
        td = CurrentDate;
        NewTimedTask("TESAHT28Resend","Resend TESAHT28","TESAHT28ResendCommandIdleTask",gTesaStartTick & ";" & gTesaCurrentCommand & ";" & gTesaCurrentCtrlSeq,td,startt,"","");
        gTesaCurrentCommand = "";
      end;
    case TESA_STX:
      if (CommandSuccesful(tstr)) then begin
        switch (gTesaCurrentCommand) begin
          case "CN":
            MessageBox(0,"Card encoded");
          case "CC":
            MessageBox(0,"Card encoded");
        end;
      end;
    otherwise
      MessageBox(0,"Unknown TESA HT28 reply");
  end;

  return;
end;
*/