external function roundmode SetRoundModeD(Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean GetPM(string,var string,var string);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external function Boolean GetPD(var record PDVc);

global
procedure SetInvARAcc(var record IVVc IVp)
BEGIN
  Integer i,rwcnt;
  string 255 ftxt;
  record PMBlock PMRec;
  record AccBlock ARAccRec;
  record CCatVc CCatR;
  record PDVc PDr;
  record IVVc lIVr;
  row IVVc IVrw;
  row PMBlock pmrw;

  if (nonblank(IVp.ARAcc)) then begin goto LSetInvARAcc99; end;
  BlockLoad(ARAccRec);
  switch (IVp.InvType) begin
    case kInvoiceTypeCashInvoiceReceiptPRT:
      goto LkInvoiceTypeCash;
    case kInvoiceTypeCash:
LkInvoiceTypeCash:;    
      PDr.Code = IVp.PayDeal;
      if (GetPD(PDr)) then begin    
        if (nonblank(PDr.pdCashAcc)) then begin ftxt = PDr.pdCashAcc; end;
      end;
      if (blank(ftxt)) then begin
        ftxt = ARAccRec.CashAcc;
        BlockLoad(PMRec);
        rwcnt = MatRowCnt(PMRec);      
        for (i=0; i<rwcnt; i=i+1) begin
          MatRowGet(PMRec,i,pmrw);
          if (IVp.PayDeal==pmrw.Code) then begin
            ftxt = pmrw.AccNr;
          end;  
        end;
      end;
      goto LSetInvARAcc;
    case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
    case kInvoiceTypeCredit:
      LkInvoiceTypeCredit:;
      rwcnt = MatRowCnt(IVp);      
      if (rwcnt>0) then begin
        MatRowGet(IVp,0,IVrw);
        if (IVrw.OrdRow!=-1) then begin
          lIVr.SerNr = IVrw.OrdRow;
          if (ReadFirstMain(lIVr,1,true)) then begin
            ftxt = lIVr.ARAcc;
            goto LSetInvARAcc;
          end;
        end;
      end;
  end;
  ftxt = ARAccRec.ARAcc;  
  if (nonblank(IVp.CustCat)) then begin
    CCatR.Code = IVp.CustCat;
    if (ReadFirstMain(CCatR,1,true)) then begin
      if (nonblank(CCatR.ARAcc)) then begin
        ftxt = CCatR.ARAcc;
      end;  
    end;
  end;  
LSetInvARAcc:;
  IVp.ARAcc = ftxt;
LSetInvARAcc99:;
  RETURN;
END;

global
function LongInt GetCurUserLastNr(string filename)
BEGIN
  record UserVc Userr;
  LongInt sernr;
  
  Userr.Code = CurrentUser;
  if (ReadFirstMain(Userr,1,true)) then begin
    switch (filename) begin
      case "ORVc" : sernr = Userr.LastOrdNr;
      case "SHVc" : sernr = Userr.LastShipNr;
      case "IVVc" : sernr = Userr.LastInvNr;
      case "CreditIVVc" : sernr = Userr.LastInvNr;//LastCredInvNr
      case "CreditVIVc" : sernr = Userr.LastVINr;//LastVINr
      case "PUVc" : sernr = Userr.LastPurNr;
      case "IPVc" : sernr = Userr.LastPayNr;
      case "TRVc" : sernr = Userr.LastTRNr;
      case "TTRVc" : sernr = Userr.LastTTRNr;
      case "VIVc" : sernr = Userr.LastVINr;
      case "OPVc" : sernr = Userr.LastOPNr;
      case "POVc" : sernr = Userr.LastPONr;
      case "CLInVc" : sernr = Userr.LastCLInNr;
      case "CLOutVc" : sernr = Userr.LastCLOutNr;
      case "IVCashVc" : sernr = Userr.LastIVCashNr;
      case "RestAccVc" : sernr = Userr.LastRestAccNr;
    end;
  end;  
  GetCurUserLastNr = sernr;
  RETURN;
END;

global
function Boolean GetAccCur(string acc,var string curncy)
BEGIN
  record AccVc Accr;
  Boolean Accs;

  if (nonblank(acc)) then begin
    Accr.AccNumber = acc;
    Accs = ReadFirstKey("AccNumber",Accr,1,true);
    curncy = Accr.Curncy;
  end;
  GetAccCur = Accs;
  RETURN;
END;

function LongInt NextFreeInCashTSerCLInVc(LongInt tstart,LongInt tend)
BEGIN
  record CLInVc CLInr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  CLInr.SerNr = tend;
  if (ReadLastMain(CLInr,1,false)) then begin
    if ((CLInr.SerNr>=tstart) and (CLInr.SerNr<tend)) then begin
      res = CLInr.SerNr + 1;
    end;
    if (CLInr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerCLInVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerIPVc(LongInt tstart,LongInt tend)
BEGIN
  record IPVc IPr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  IPr.SerNr = tend;
  if (ReadLastMain(IPr,1,false)) then begin
    if ((IPr.SerNr>=tstart) and (IPr.SerNr<tend)) then begin
      res = IPr.SerNr + 1;
    end;
    if (IPr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerIPVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerIVVc(LongInt tstart,LongInt tend)
BEGIN
  record IVVc IVr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  IVr.SerNr = tend;
  if (ReadLastMain(IVr,1,false)) then begin
    if ((IVr.SerNr>=tstart) and (IVr.SerNr<tend)) then begin
      res = IVr.SerNr + 1;
    end;
    if (IVr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerIVVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerCLOutVc(LongInt tstart,LongInt tend)
BEGIN
  record CLOutVc CLOutr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  CLOutr.SerNr = tend;
  if (ReadLastMain(CLOutr,1,false)) then begin
    if ((CLOutr.SerNr>=tstart) and (CLOutr.SerNr<tend)) then begin
      res = CLOutr.SerNr + 1;
    end;
    if (CLOutr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerCLOutVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerOPVc(LongInt tstart,LongInt tend)
BEGIN
  record OPVc OPr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  OPr.SerNr = tend;
  if (ReadLastMain(OPr,1,false)) then begin
    if ((OPr.SerNr>=tstart) and (OPr.SerNr<tend)) then begin
      res = OPr.SerNr + 1;
    end;
    if (OPr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerOPVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerVIVc(LongInt tstart,LongInt tend)
BEGIN
  record VIVc VIr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  VIr.SerNr = tend;
  if (ReadLastMain(VIr,1,false)) then begin
    if ((VIr.SerNr>=tstart) and (VIr.SerNr<tend)) then begin
      res = VIr.SerNr + 1;
    end;
    if (VIr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerVIVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSerPPVc(LongInt tstart,LongInt tend)
BEGIN
  record PPVc PPr;
  LongInt res;
  Boolean found;
  
  res = tstart;
  PPr.SerNr = tend;
  if (ReadLastMain(PPr,1,false)) then begin
    if ((PPr.SerNr>=tstart) and (PPr.SerNr<tend)) then begin
      res = PPr.SerNr + 1;
    end;
    if (PPr.SerNr==tend) then begin
      //## warning or error? 
      res = -1;
    end;
  end else begin
    res = tstart;
  end;
  NextFreeInCashTSerPPVc = res;
  RETURN;
END;

function LongInt NextFreeInCashTSer(string filename,LongInt tstart,LongInt tend)
BEGIN
  LongInt res;

  switch (filename) begin
    case "CLInVc":  res = NextFreeInCashTSerCLInVc(tstart,tend);
    case "IPVc":    res = NextFreeInCashTSerIPVc(tstart,tend);
    case "IVVc":    res = NextFreeInCashTSerIVVc(tstart,tend);
    case "CLOutVc": res = NextFreeInCashTSerCLOutVc(tstart,tend);
    case "OPVc":    res = NextFreeInCashTSerOPVc(tstart,tend);
    case "VIVc":    res = NextFreeInCashTSerVIVc(tstart,tend);
    case "PPVc":    res = NextFreeInCashTSerPPVc(tstart,tend);
  end;
  NextFreeInCashTSer = res;
  RETURN;
END;

global
function LongInt NextFreeCashSerNr(row PMBlock pmrw,Boolean clinf)
BEGIN
  LongInt res;
  LongInt sernr;
  LongInt serstart,serend;

  if (clinf) then begin
    serstart = pmrw.TSerStartIn;
    serend = pmrw.TSerEndIn;
  end else begin
    serstart = pmrw.TSerStartOut;
    serend = pmrw.TSerEndOut;
  end;
  if (clinf) then begin
    sernr = NextFreeInCashTSer("CLInVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
    sernr = NextFreeInCashTSer("IPVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
    sernr = NextFreeInCashTSer("IVVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
  end else begin      
    sernr = NextFreeInCashTSer("CLOutVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
    sernr = NextFreeInCashTSer("OPVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
    sernr = NextFreeInCashTSer("VIVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
    sernr = NextFreeInCashTSer("PPVc",serstart,serend);
    if (sernr>res) then begin res = sernr; end;
  end;  
  NextFreeCashSerNr = res;
  RETURN;
END;

global
function Integer PMCheckType(string pmt,var string accnr,var string objs)
BEGIN
  Integer res;
  Integer i,rwcnt;
  record PMBlock PMRec;
  row PMBlock pmrw;

  res = -1;
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  if (len(pmt)>0) then begin
    for (i = 0; i<rwcnt; i=i+1) begin
      MatRowGet(PMRec,i,pmrw);
      if (pmrw.Code==pmt) then begin
        res = pmrw.CheckType;
        accnr = pmrw.AccNr;
        objs = pmrw.Objects;
      end;
    end;
  end;
  PMCheckType = res;
  RETURN;
END;

global
function Boolean GetPMCurrency(string paymode,var string curr)
BEGIN
  record AccVc Accr;
  record BaseCurBlock bascur;
  Boolean res;
  string 255 tstr;
  string 10 accnum;
  
  curr = "";
  if (GetPM(paymode,accnum,tstr)) then begin
    Accr.AccNumber = accnum;
    if (ReadFirstMain(Accr,1,true)) then begin
      if (nonblank(Accr.Curncy)) then begin
        curr = Accr.Curncy;
      end;
      res = true;
    end;
    if (blank(curr)) then begin
      BlockLoad(bascur);
      curr = bascur.BaseCur1;
    end;
  end;
  GetPMCurrency = res;
  RETURN;
END;

global
function Boolean GetPMgentrans(string paymode)
BEGIN
  Boolean res;
  Integer i,rwcnt;
  record PMBlock PMRec;
  row PMBlock pmrw;
  
  res = true;
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  for (i=0 ;i<rwcnt;i=i+1) begin
    MatRowGet(PMRec,i,pmrw);
    if (pmrw.Code==paymode) then begin
      if (pmrw.DonotGenTrans==0) then begin
        res = true;
      end else begin
        res = false;
      end;
      goto LGetPMgentrans;
    end;
  end;
  res = false;
LGetPMgentrans:;
  GetPMgentrans = res;
  RETURN;
END;

global
function Boolean PayModeRegistered(string paymode)
BEGIN
  Boolean res;
  Integer i,rwcnt;
  record PMBlock PMRec;
  row PMBlock pmrw;
  
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PMRec,i,pmrw);
    if (pmrw.Code==paymode) then begin
      res = true;
      goto LPayModeRegistered;
    end;
  end;
LPayModeRegistered:;
  PayModeRegistered = res;
  RETURN;
END;

global
function Integer GetPayDealType(string paydeal,var LongInt pdaysp)
BEGIN
  Integer res;
  record PDVc PDr;
  
  res = -1;
  pdaysp = 0;
  PDr.Code = paydeal;
  if (ReadFirstMain(PDr,1,true)) then begin
    res = PDr.PDType;
    pdaysp = PDr.pdays;
    goto LGetPayDealType;    
  end;  
  if (PayModeRegistered(paydeal)) then begin
    res = 1;
    pdaysp = 0;
  end;  
LGetPayDealType:;  
  if (pdaysp<0) then begin
    pdaysp = 0;
  end;
  GetPayDealType = res;
  RETURN;
END;

global
function Integer GetCreditedInvoiceType(record IVVc IVp)
BEGIN
  record IVVc IVr;
  row IVVc IVrw;
  Integer rwcnt;
  Integer res;
    
  res = -1;
  rwcnt = MatRowCnt(IVp);
  if (rwcnt>0) then begin
    MatRowGet(IVp,0,IVrw);
    if (IVrw.stp==3) then begin
      IVr.SerNr = IVrw.OrdRow;
      if (ReadFirstMain(IVr,1,true)) then begin
        res = IVr.InvType;
      end;
    end;
  end;
  GetCreditedInvoiceType = res;
  RETURN;
END;

global
procedure RoundVATSum(string curncycode,string paydeal,string filename,var val vsum)
BEGIN
  roundmode roundlines,rndtotal,roundvat;

  GetCurncyRoundoff(curncycode,paydeal,filename,rndtotal,roundlines,roundvat);
  vsum = Round(vsum,roundvat);  
  RETURN;
END;

global
procedure SetDefProjectUnit(string itemcode,var string res)
begin
  record ProjectBlock PRRec;

  BlockLoad(PRRec);  
  if (nonblank(PRRec.DefUnit)) then begin
    res = PRRec.DefUnit;
  end;
  return;
end;

// The logic was very wierd and not working. This logic is better.
global
function Boolean SetUnitFactor(string unitc,var val unitqty,val unitw,val unith,val unitd,var val unitprice,var val resqty,var val price,var string comment,Boolean changeorgprice)
BEGIN
  record UnitVc Unitr;
  Boolean chsum,qtycalc;
  val temp,qty;

  chsum = false;
  qtycalc = false;
  comment = "";
  Unitr.Code = unitc;
  if (ReadFirstMain(Unitr,1,true)) then begin
    comment = Unitr.Comment;
    switch (Unitr.AllowDim) begin
      case 1:
        if (unitw!=0) then begin
          qty = unitw;
          qtycalc = true;
        end;
      case 2:
        if ((unitw!=0) and (unith!=0)) then begin 
          qty = unitw*unith;
          qtycalc = true;
        end;
      case 3:
        if ((unitw!=0) and (unith!=0) and (unitd!=0)) then begin 
          qty = unitw*unith*unitd;
          qtycalc = true;
        end;
    end;
    if (qtycalc) then begin
      if (Unitr.QtyFact!=0) then begin
        unitqty = qty;
        resqty = qty*Unitr.QtyFact;
        resqty = Round(resqty,SetRoundModeD(3));
      end else begin
        resqty = qty*unitqty;
        resqty = Round(resqty,SetRoundModeD(3));
      end;
    end else begin
      if (Unitr.QtyFact!=0) then begin
        if (unitqty!=0) then begin
          resqty = unitqty*Unitr.QtyFact;
          resqty = Round(resqty,SetRoundModeD(3));
        end;
      end;
    end;
    unitprice = price*resqty/unitqty;
    if (changeorgprice) then begin
      // This function is never called with changeorgprice true.....
    end;
  end;
  chsum = true;
  SetUnitFactor = chsum;
  RETURN;
END;

global
function val CalcUnitFactor(string unitc,val qty)
begin
  record UnitVc Unitr;
  Boolean chsum;
  val unitqty;

  chsum = false;
  Unitr.Code = unitc;
  if (ReadFirstMain(Unitr,1,true)) then begin
    if (Unitr.QtyFact!=0) then begin
      unitqty = qty/Unitr.QtyFact;
      unitqty = Round(unitqty,SetRoundModeD(3));
    end;
  end;
  CalcUnitFactor = unitqty;
  return;
end;

global
procedure SerialNrDimensions(string artno,string serno,var val UnitXval,var val UnitYval,var val UnitZval)
BEGIN
  record BatchTextVc btr;
    
  btr.ArtCode = artno;
  btr.SerialNr = serno;
  UnitXval = blankval;
  UnitYval = blankval;
  UnitZval = blankval;
  if (ReadFirstMain(btr,2,true)) then begin
    if (btr.UnitXval!=0) then begin UnitXval = btr.UnitXval; end;
    if (btr.UnitYval!=0) then begin UnitYval = btr.UnitYval; end;
    if (btr.UnitZval!=0) then begin UnitZval = btr.UnitZval; end;
  end; 
  RETURN;
END;

global
procedure SerialNrSDimensions(string artno,string serno,var val UnitXval,var val UnitYval,var val UnitZval)
BEGIN
  record BatchTextVc btr;
    
  btr.ArtCode = artno;
  btr.SerialNr = serno;
  UnitXval = blankval;
  UnitYval = blankval;
  UnitZval = blankval;
  if (ReadFirstMain(btr,2,true)) then begin
    if (btr.SaleUnitXval!=0) then begin UnitXval = btr.SaleUnitXval; end;
    if (btr.SaleUnitYval!=0) then begin UnitYval = btr.SaleUnitYval; end;
    if (btr.SaleUnitZval!=0) then begin UnitZval = btr.SaleUnitZval; end;
  end; 
  RETURN;
END;

global
function Integer GetUnitAllowDim(string unitcode)
BEGIN
  record UnitVc Unitr;
  Integer res;

  Unitr.Code = unitcode;
  if (ReadFirstMain(Unitr,1,true)) then begin
    if (Unitr.CalcDimQty!=0) then begin
      res = Unitr.AllowDim;
    end;
  end;
  GetUnitAllowDim = res;
  RETURN;
END;

global
function Boolean CheckAllowedSize(record INVc INr,val UnitXval,val UnitYval,val UnitZval)
BEGIN
  record UnitVc UNr;
  Boolean res;
  Integer cnt;

  res = true;
  UNr.Code = INr.Unittext;
  if (ReadFirstMain(UNr,1,true)) then begin
    if (UNr.CheckDim!=0) then begin
      if (UNr.AllowDim>0) then begin
        cnt = 0;
        if (UnitXval!=0) then begin cnt = cnt +1; end;;
        if (UnitYval!=0) then begin cnt = cnt +1; end;;
        if (UnitZval!=0) then begin cnt = cnt +1; end;;
        if (cnt>0) then begin
          if (UNr.AllowDim!=cnt) then begin res = false; end;
        end;
      end;
    end;
  end;
  CheckAllowedSize = res;
  RETURN;
END;
