external function Boolean LocationRequiresPositions(string);
external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function Integer FIFOPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer GetFIFOPerSerialNr(record INVc,record ITVc,record CostAccBlock);
external function val AbsoluteVal(val);
external function Integer ArtCodeWAPerLocation(string);
external procedure GetStockedItemFromRecepy(record SHVc,var string,var val);
external procedure CombineStructure(var record SHVc);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function roundmode SetRoundModeD(Integer);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external function val QtyUsedBeforeDate(record ItemHistVc,Boolean,Date);
external function val ConsigmentStockQty(string,string,Date);
external procedure GetCostsFromRecords(record ItemHistVc,var val,var val,Boolean,Date);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function val GetStockQty(string,string,Date,Boolean);
external function val FindCostPriceFIFO(Integer,record INVc,string,string,val,val,Boolean,Boolean,Boolean,Integer,Integer);
external function Boolean TestArtCode(string,string,record INVc);
external function roundmode CostPriceDecimals();
external function val CalculateQty2(val,val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external updating procedure StoreItemHistory_In(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,string,record TempStockVc,Boolean);
external function val FindCostPriceBasePrice(record CostAccBlock,record INVc,record ITVc);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function Integer ItemCostPerLocation(record INVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function Integer ArtCodeCostPerLocation(string);
external updating procedure StoreItemHistory_In_WithSource(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,val,LongInt,Integer,Integer,LongInt,string,record TempStockVc,Boolean);
external updating procedure StoreItemHistory_In_RetGoods_InQue(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,LongInt,Boolean,record TempStockVc,Boolean);

global
function Boolean ConsigmentStock(string item,string serialnr,Date td)
begin
  Boolean res,found;
  record BatchTextVc btr;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  string 255 keystr;
  
  btr.ArtCode = item;
  btr.SerialNr = serialnr;
  if (ReadFirstMain(btr,2,true)) then begin
    res = btr.ConsigStock!=0;
  end;
  if (res) then begin
    if (nonblankdate(td)) then begin
      keystr = "Item:" & item;
      VIr.TransDate = td;
      found = true;
      while (LoopBackKey(keystr,VIr,1,found)) begin
        if (VIr.TransDate>td) then begin found = false; end;
        if (found) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VIrw.SerialNr==serialnr) then begin
              res = 0;
              goto LConsigmentStock;
            end;
          end;
        end;
      end;
    end;
  end;
LConsigmentStock:;  
  ConsigmentStock = res;
  return;
end;

global
function Boolean TREOStock(string item,string serialnr,Date td)
begin
  Boolean res,found;
  record BatchTextVc btr;
  record VIVc VIr;
  row VIVc VIrw;
  Integer i,rwcnt;
  string 255 keystr;
  
  if (blank(serialnr)) then begin
    goto LTREOStock;
  end;
  btr.ArtCode = item;
  btr.SerialNr = serialnr;
  if (ReadFirstMain(btr,2,true)) then begin
    res = btr.TREOFlag!=0;
  end;
  if (res) then begin
    if (nonblankdate(td)) then begin
      keystr = "Item:" & item;
      VIr.TransDate = td;
      found = true;
      while (LoopBackKey(keystr,VIr,1,found)) begin
        if (VIr.TransDate>td) then begin found = false; end;
        if (found) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VIrw.SerialNr==serialnr) then begin
              res = 0;
              goto LTREOStock;
            end;
          end;
        end;
      end;
    end;
  end;
LTREOStock:;  
  TREOStock = res;
  return;
end;

global
function Integer WAPerLocation(record INVc INr,record ITVc ITr,record CostAccBlock CAb)
begin
  Integer res;
  
  switch (INr.WAPerLocation) begin
    case 0:
      if (CAb.ItemGroupCostModel!=0) then begin
        switch (ITr.WAPerLocation) begin
          case 0: ;
          otherwise
            res = ITr.WAPerLocation;
        end;
      end;
    otherwise
      res = INr.WAPerLocation;
  end;  
  if (res==0) then begin
    res = CAb.WAPerLocation;
  end else begin
    res = res - 1;
  end;
  WAPerLocation = res;
  return;
end;

global
updating function Boolean RetStoreItemHist_In_InQue_Comp(record MainStockBlock MSb,record CostAccBlock CAb,record RetVc Retp,row RetVc Retrw,
                                                  Integer rownr,row SHVc RecSHrw,Integer stockaffectf,
                                                  string location,record TempStockVc TSr,Boolean usetmpstkf)
begin
  Boolean res;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ItemHistVc oldsourceIHr;
  Boolean foundf,testf;
  Date fifod;
  val cost,remqty,qty,tmpqty;
  record INVc INr;

  remqty = RecSHrw.Ship;
  ReadFirstItem(RecSHrw.ArtCode,INr,false,false);
  foundf = true;
  IHr.FileName = "SHVc";
  IHr.TransNr = Retp.SHNr;
  IHr.Row = Retrw.SHRow;
  while (LoopKey("FNTransNr",IHr,3,foundf)) begin
    if (IHr.FileName!="SHVc") then begin foundf = false; end;
    if (IHr.TransNr!=Retp.SHNr) then begin foundf = false; end;
    if (IHr.Row!=Retrw.SHRow) then begin foundf = false; end;
    if (remqty<=0) then begin foundf = false; end;
    if (foundf) then begin
      testf = true;
      if (IHr.Source<=0) then begin testf = false; end;
      if (IHr.ArtCode!=RecSHrw.ArtCode) then begin testf = false; end;      
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        tmpqty = -IHr.Qty;
        if (tmpqty<0) then begin tmpqty = 0; end;
        if (remqty>tmpqty) then begin
          qty = tmpqty;
        end else begin
          qty = remqty;
        end;
        if (qty==0) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
          fifod = sourceIHr.FIFODate;                
          if (CAb.RetCostPriceFromSH==0) then begin
            cost = INr.InPrice*qty;
          end else begin
            cost = (IHr.TotCostPrice/IHr.Qty)*qty;
          end;
          if (cost<0) then begin cost = -cost; end;
          if (ArtCodeCostPerLocation(RecSHrw.ArtCode)!=0) then begin
            if (location!=sourceIHr.Location) then begin
              fifod = Retp.TransDate;
              StoreItemHistory_In_WithSource(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,fifod,qty,RecSHrw.Coefficient,cost,blankval,Retp.SerNr,rownr,stockaffectf,IHr.Source,Retrw.PosCode,TSr,usetmpstkf);
              StepForward(IHr,1);
              res = true;
            end else begin
              if (CAb.RetFIFOQue!=0) then begin 
                RecordCopy(oldsourceIHr,sourceIHr);
                sourceIHr.RemQty = sourceIHr.RemQty + qty;
                if (RecordUpdate(oldsourceIHr,sourceIHr,false)) then begin end;
                StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,false,TSr,usetmpstkf);
                res = true;
              end else begin
                if (CAb.RetCostPriceFromSH==0) then begin 
                  StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end else begin
                  StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
                end;
                res = true;
              end;
              StepForward(IHr,1);
            end;
          end else begin
            if (CAb.RetFIFOQue!=0) then begin 
              RecordCopy(oldsourceIHr,sourceIHr);
              sourceIHr.RemQty = sourceIHr.RemQty + qty;
              if (RecordUpdate(oldsourceIHr,sourceIHr,false)) then begin end;
              StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,false,TSr,usetmpstkf);
            end else begin
              if (CAb.RetCostPriceFromSH==0) then begin 
                StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
              end else begin
                StoreItemHistory_In_RetGoods_InQue(MSb,RecSHrw.ArtCode,"",location,"RetVc",Retp.TransDate,Retp.TransDate,qty,RecSHrw.Coefficient,cost,Retp.SerNr,rownr,stockaffectf,Retrw.PosCode,IHr.SerNr,true,TSr,usetmpstkf);
              end;
            end;
            StepForward(IHr,1);
            remqty = remqty - qty;
            res = true;
          end;          
        end;
      end;
    end;
  end;
  RetStoreItemHist_In_InQue_Comp = res;
  return;
end;

global
function val ItemHist_ComponentItem_CostPrice(record CostAccBlock CAb,string filename,LongInt transnr,LongInt rownr,string artcode,val recqty,string location)
begin
  val res;
  val qty,q;
  record ItemHistVc IHr;
  Boolean foundf,cosfound,testf;
  record INVc INr;

  if (CAb.RetCostPriceFromSH!=0) then begin
    if (rownr>=0)  then begin
      foundf = true;
      IHr.FileName = filename;
      IHr.TransNr = transnr;
      IHr.Row = rownr;
      while (LoopKey("FNTransNr",IHr,3,foundf)) begin
        if (IHr.FileName!=filename) then begin foundf = false; end;
        if (IHr.TransNr!=transnr) then begin foundf = false; end;
        if (IHr.Row!=rownr) then begin foundf = false; end;
        testf = true;
        if (IHr.Invalid!=0) then begin testf = false; end;
        if (foundf and testf) then begin
          if (IHr.ArtCode==artcode) then begin
            q = -recqty;
            if (AbsoluteVal(q)>AbsoluteVal(IHr.Qty)) then begin
              q = IHr.Qty;
            end;
            qty = qty + q;
            res = res + (IHr.TotCostPrice*q)/IHr.Qty;
          end;
        end;
      end;
      if (res<0) then begin res = -res; end;
      if (qty<0) then begin qty = -qty; end;
//      res = res/qty;  // this is price per unit  and we need total  
      cosfound = true;
    end;
  end;
  if (cosfound==false) then begin
//    res = FindCostPrice(artcode,location,"",1,0,false);  //into stock so this is a bit wierdo
    if (ReadFirstItem(artcode,INr,false,false)) then begin
      res = recqty*INr.InPrice;
    end;
  end;
  ItemHist_ComponentItem_CostPrice = res;
  RETURN;
END;

global
function val FindCostPriceWA(Integer WAPerLocation,record INVc INr,string location)
begin
  val res;
  record WeigAvVc WAr;

  res = 0;
  if (WAPerLocation!=0) then begin
    WAr.ArtCode = INr.Code;//ISVC
    WAr.Location = location;
    if (ReadFirstMain(WAr,2,true)) then begin
      res = WAr.WeighedAvPrice;
    end else begin
      res = INr.WeighedAvPrice;
    end;
  end else begin
    res = INr.WeighedAvPrice;//ISVC
  end;
  FindCostPriceWA = res;
  return;
end;

global
function val FindCostPrice_ReturnedGoods(record RetVc Retr,row RetVc Retrw)
begin
  val res;
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ItemHistVc oldsourceIHr;
  Boolean foundf,testf;
  Date fifod;
  val cost;
  val qty,remqty,sq;

  remqty = Retrw.Quant;
  foundf = true;
  IHr.FileName = "SHVc";
  IHr.TransNr = Retr.SHNr;
  IHr.Row = Retrw.SHRow;
  while (LoopKey("FNTransNr",IHr,3,foundf)) begin
    if (IHr.FileName!="SHVc") then begin foundf = false; end;
    if (IHr.TransNr!=Retr.SHNr) then begin foundf = false; end;
    if (IHr.Row!=Retrw.SHRow) then begin foundf = false; end;
    if (remqty<=0) then begin foundf = false; end;
    testf = foundf;
    if (IHr.Invalid!=0) then begin testf = false; end;
    if (testf) then begin
      if (IHr.Source>0) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
          sq = sourceIHr.Qty - sourceIHr.RemQty;
          if (remqty>sq) then begin
            qty = sq;
          end else begin
            qty = remqty;
          end;
          res = res + ((sourceIHr.TotCostPrice-sourceIHr.RemCostPrice)/sq)*qty;
          remqty = remqty - qty;
        end;
      end;
    end;
  end;
  FindCostPrice_ReturnedGoods = res;
  RETURN;
END;

global
function val FindCostPrice_ReturnedGoods_FromSH(record CostAccBlock CAb,record INVc INr,record RetVc Retr,row RetVc Retrw,Integer queuecostmodel,Integer currow)
begin  
  val res;
  record SHVc SHr;
  row SHVc SHrw;
  record SHVc recSHr;
  row SHVc recSHrw;
  Boolean isstruct;
  Integer i,rwcnt;
  string 255 location;
  record MainStockBlock MSb;
  
  isstruct = ExpandStructItem(Retrw.ArtCode,Retrw.Recepy,Retrw.Quant,recSHr);  
  if (isstruct==false) then begin
    SHr.SerNr = Retr.SHNr;
    if (ReadFirstMain(SHr,1,true)) then begin
      if (Retrw.SHRow>=0) then begin
        MatRowGet(SHr,Retrw.SHRow,SHrw);
        res = SHrw.FIFORowVal/SHrw.Ship;
      end else begin
        res = INr.WeighedAvPrice;
      end;
    end else begin    
      res = Retrw.CostPrice;
    end;
  end else begin    
    location = Retrw.Location;
    if (blank(location)) then begin
      location = Retr.Location;
    end;
    if (blank(location)) then begin
      BlockLoad(MSb);
      location = MSb.MainStock;
    end;
    CombineStructure(recSHr);
    rwcnt = MatRowCnt(recSHr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(recSHr,i,recSHrw);
      res = res + ItemHist_ComponentItem_CostPrice(CAb,"SHVc",Retr.SHNr,Retrw.SHRow,RecSHrw.ArtCode,RecSHrw.Ship,location);
    end;
  end;
  FindCostPrice_ReturnedGoods_FromSH = res;
  return;
end;

global
function val QtyUsedBeforeFromSH(record ItemHistVc sourceIHr)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  
  found = true;
  IHr.Source = sourceIHr.SerNr;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=sourceIHr.SerNr) then begin
      found = false;
    end;
    if (found) then begin
      res = res + IHr.Qty;
    end;    
  end;  
  QtyUsedBeforeFromSH = res;
  return;
end;

global
function val FindCostPrice_ReturnedGoods_FromSH_Source(record INVc INr,record RetVc Retp,row RetVc Retrw,Integer primary,Integer queuecostmodel,Integer currow)
begin  
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ItemHistVc oldsourceIHr;
  Boolean foundf,foundsrc;
  val cost;
  val qty,remqty,usedqty,tmpqty;

  remqty = Retrw.Quant;
  foundf = true;
  IHr.FileName = "SHVc";
  IHr.TransNr = Retp.SHNr;
  IHr.Row = Retrw.SHRow;
  while (LoopKey("FNTransNr",IHr,3,foundf)) begin
    if (IHr.FileName!="SHVc") then begin foundf = false; end;
    if (IHr.TransNr!=Retp.SHNr) then begin foundf = false; end;
    if (IHr.Row!=Retrw.SHRow) then begin foundf = false; end;
    if (remqty<=0) then begin foundf = false; end;
    if (foundf) then begin
      usedqty = QtyUsedBeforeFromSH(IHr);
      if (IHr.Source>0) then begin
        sourceIHr.SerNr = IHr.Source;
        if (ReadFirstMain(sourceIHr,1,true)) then begin
          tmpqty = sourceIHr.Qty - usedqty;
          if (tmpqty<0) then begin tmpqty = 0; end;
          
          if (remqty>tmpqty) then begin
            qty = tmpqty;
          end else begin
            qty = remqty;
          end;
          switch (primary) begin
            case kCostModelWA:
              if (remqty>(-IHr.Qty)) then begin
                qty = -IHr.Qty;
              end else begin
                qty = remqty;
              end;
              if (ArtCodeWAPerLocation(IHr.ArtCode)) then begin
                cost = cost + -(IHr.WATotCostPerLoc/IHr.Qty)*qty;
              end else begin
                cost = cost + -(IHr.WATotCost/IHr.Qty)*qty;
       	      end;
            case kCostModelCostPrice:
              cost = cost + (sourceIHr.CPTotCost/sourceIHr.Qty)*qty;
            case kCostModelPctBasePrice:
              cost = cost + (sourceIHr.BPTotCost/sourceIHr.Qty)*qty;
            otherwise
              cost = cost + (sourceIHr.TotCostPrice/sourceIHr.Qty)*qty;
          end;          
          remqty = remqty - qty;
        end;
      end;
    end;
  end;  
  
  cost = cost/Retrw.Quant;
  FindCostPrice_ReturnedGoods_FromSH_Source = cost;
  return;
end;

global
function val FindProdOperationsCost_FinalProduct(LongInt prodnr,LongInt MaxSequence,LongInt skipprodopnr)
begin
  val res;
  record ProdOperationVc ProdOpr;
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  Boolean found,testf;
  val actualqty;
  record ProdSettingsBlock PSb;
  
  BlockLoad(PSb);
  found = true;
	ProdOpr.ProdNr = prodnr;
	ProdOpr.PRStatusFlag = 3;
	while (LoopKey("ProdNrPRStatus",ProdOpr,2,found)) begin
	  if (ProdOpr.ProdNr!=prodnr) then begin found = false; end;
	  if (ProdOpr.PRStatusFlag!=3) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (ProdOpr.SerNr==skipprodopnr) then begin testf = false; end;
  	  if (ProdOpr.Sequence>MaxSequence) then begin testf = false; end;
      if (testf) then begin
			  rwcnt = MatRowCnt(ProdOpr);
			  for (i=0;i<rwcnt;i=i+1) begin
			    MatRowGet(ProdOpr,i,ProdOprw);
			    if (ProdOprw.InQty!=0) then begin
				    switch (ProdOpr.RowsHoldActualQty) begin
				      case 1: res = res + ProdOprw.InQty*ProdOprw.ItemCost;
				      otherwise res = res + ProdOprw.InQty*ProdOprw.ItemCost*ProdOpr.Qty;
				    end;				    
				    actualqty = actualqty + ProdOpr.ActualQty;
			    end;
			    if (ProdOprw.OutQty!=0) then begin
				    switch (ProdOpr.RowsHoldActualQty) begin
				      case 1: res = res - ProdOprw.OutQty*ProdOprw.ItemCost;
				      otherwise res = res - ProdOprw.OutQty*ProdOprw.ItemCost*ProdOpr.Qty;
				    end;				    
			    end;
			  end;
		  end;
		end;
  end;
  if (PSb.AddDiscardedCost!=0) then begin
	  ResetLoop(ProdOpr);
	  found = true;
		ProdOpr.ProdNr = prodnr;
		ProdOpr.PRStatusFlag = 5;
		while (LoopKey("ProdNrPRStatus",ProdOpr,2,found)) begin
		  if (ProdOpr.ProdNr!=prodnr) then begin found = false; end;
		  if (ProdOpr.PRStatusFlag!=5) then begin found = false; end;
	    if (found) then begin
	      testf = true;
	      if (ProdOpr.SerNr==skipprodopnr) then begin testf = false; end;
	  	  if (ProdOpr.Sequence>MaxSequence) then begin testf = false; end;
	      if (testf) then begin
				  rwcnt = MatRowCnt(ProdOpr);
				  for (i=0;i<rwcnt;i=i+1) begin
				    MatRowGet(ProdOpr,i,ProdOprw);
				    if (ProdOprw.InQty!=0) then begin
					    switch (ProdOpr.RowsHoldActualQty) begin
					      case 1: res = res + ProdOprw.InQty*ProdOprw.ItemCost;
					      otherwise res = res + ProdOprw.InQty*ProdOprw.ItemCost*ProdOpr.Qty;
					    end;		      
					    actualqty = actualqty + ProdOpr.ActualQty;
				    end;
				    if (ProdOprw.OutQty!=0) then begin
					    switch (ProdOpr.RowsHoldActualQty) begin
					      case 1: res = res - ProdOprw.InQty*ProdOprw.ItemCost;
					      otherwise res = res - ProdOprw.InQty*ProdOprw.ItemCost*ProdOpr.Qty;
					    end;		      
				    end;
				  end;
			  end;
			end;
	  end;
	end;
  FindProdOperationsCost_FinalProduct = res;
  RETURN;
END;

global
function val FindProdOperationsFinishedCost_FinalProduct(LongInt prodnr,LongInt TheSequence,LongInt skipprodopnr,var val finqty)
begin
  val res;
  record ProdOperationVc ProdOpr;
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  Boolean found,testf;
  val inv,outv;
  
  finqty = blankval;
  found = true;
	ProdOpr.ProdNr = prodnr;
	ProdOpr.PRStatusFlag = 3;
	while (LoopKey("ProdNrPRStatus",ProdOpr,2,found)) begin
	  if (ProdOpr.ProdNr!=prodnr) then begin found = false; end;
	  if (ProdOpr.PRStatusFlag!=3) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (ProdOpr.SerNr==skipprodopnr) then begin testf = false; end;
  	  if (ProdOpr.Sequence!=TheSequence) then begin testf = false; end;
      if (testf) then begin
			  rwcnt = MatRowCnt(ProdOpr);
			  for (i=0;i<rwcnt;i=i+1) begin
			    MatRowGet(ProdOpr,i,ProdOprw);
			    if (ProdOprw.InQty!=0) then begin
				    switch (ProdOpr.RowsHoldActualQty) begin
				      case 1: inv = inv + ProdOprw.InQty*ProdOprw.ItemCost;
				      otherwise inv = inv + ProdOprw.InQty*ProdOprw.ItemCost*ProdOpr.Qty;
				    end;				    
			    end;
			    if (ProdOprw.OutQty!=0) then begin
				    switch (ProdOpr.RowsHoldActualQty) begin
				      case 1: outv = outv + ProdOprw.OutQty*ProdOprw.ItemCost;
				      otherwise outv = outv + ProdOprw.OutQty*ProdOprw.ItemCost*ProdOpr.Qty;
				    end;				    
			    end;			   
			  end;
			  finqty = finqty + ProdOpr.ActualQty;
		  end;
		end;
  end;
  res = outv - inv;
  FindProdOperationsFinishedCost_FinalProduct = res;
  RETURN;
END;

function Boolean FindSourceFIFO(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,string location,string serialnr,var record ItemHistVc sourceIHr)
begin
  Boolean res;
  string 200 thekey;
  Integer keys;
  Boolean foundf;
  
  res = false;
  sourceIHr.ArtCode = INr.Code;
  sourceIHr.Location = location;
  if (ItemCostPerLocation(INr)==0) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  ResetLoop(sourceIHr);
  foundf = true;
  while (LoopKey(thekey,sourceIHr,keys,foundf)) begin
    if (sourceIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (sourceIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (sourceIHr.RemQty<0) then begin
      if ((blank(sourceIHr.SerialNr)) and (blank(sourceIHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      if (sourceIHr.Qty>0) then begin
        res = true;
        goto LFindSourceFIFO;
      end;
    end;
  end;
LFindSourceFIFO:;
  FindSourceFIFO = res;
  return;
end;

function Boolean FindSourceSerialNr(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,string location,string serialnr,var record ItemHistVc sourceIHr,string position)
begin
  Boolean res;
  string 200 thekey;
  Integer keys;
  Boolean foundf,testf;
  
  res = false;
  sourceIHr.ArtCode = INr.Code;
  sourceIHr.Location = location;
  if (ItemCostPerLocation(INr)==0) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  ResetLoop(sourceIHr);
  foundf = true;
  while (LoopKey(thekey,sourceIHr,keys,foundf)) begin
    testf = true;
    if (sourceIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (sourceIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (foundf and nonblank(position)) then begin 
      if (LocationRequiresPositions(location)) then begin 
        if (sourceIHr.Position!=position) then begin
          testf = false;
        end;      
      end;
    end;
    if (foundf and testf) then begin
      if (sourceIHr.SerialNr==serialnr) then begin
        if (sourceIHr.Qty>0) then begin
          res = true;
          goto LFindSourceSerialNr;
        end;
      end;
    end;
  end;
LFindSourceSerialNr:;
  FindSourceSerialNr = res;
  return;
end;

function Boolean FindSourceLIFO(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,string location,string serialnr,var record ItemHistVc sourceIHr)
begin
  Boolean res;
  string 200 thekey;
  Integer keys;
  Boolean foundf;
  
  res = false;
  sourceIHr.ArtCode = INr.Code;
  sourceIHr.Location = location;
  if (ItemCostPerLocation(INr)==0) then begin
    thekey = "ActiveQty";
    keys = 1;
  end else begin
    thekey = "ActiveLocQty";
    keys = 2;
  end;
  ResetLoop(sourceIHr);
  foundf = true;
  while (LoopBackKey(thekey,sourceIHr,keys,foundf)) begin
    if (sourceIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==2) then begin
      if (sourceIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (sourceIHr.RemQty<0) then begin
      if ((blank(sourceIHr.SerialNr)) and (blank(sourceIHr.Variety))) then begin // If a normal stocked item has a record with negative RemQty, there is no need to read further
        foundf = false;
      end;
    end;
    if (foundf) then begin
      if (sourceIHr.Qty>0) then begin
        res = true;
        goto LFindSourceLIFO;
      end;
    end;
  end;
LFindSourceLIFO:;
  FindSourceLIFO = res;
  return;
end;

function Boolean FindSource(record MainStockBlock MSb,record CostAccBlock CAb,record INVc INr,string filename,string location,string serialnr,var record ItemHistVc sourceIHr,string position)
begin
  Integer primary,queuecostmodel;
  Boolean res;
  record ITVc ITr;
  
  RecordNew(sourceIHr);
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,true);
  res = false;
  switch (queuecostmodel) begin
    case kQueuedCostModelFIFO:
      res = FindSourceFIFO(MSb,CAb,INr,location,serialnr,sourceIHr);
    case kQueuedCostModelLIFO:
      res = FindSourceLIFO(MSb,CAb,INr,location,serialnr,sourceIHr);
    case kQueuedCostModelPerSerialNr: 
      res = FindSourceSerialNr(MSb,CAb,INr,location,serialnr,sourceIHr,position);
  end;
/*
  if (CAb.FIFOPerLocation==0) then begin
    if (filename=="StockMovVc") then begin res = false; end;//we need price but we do not move FIFO queue
  end;
*/  
  FindSource = res;
  return;
end;

global
updating procedure StoreItemHistory_Out(record MainStockBlock MSb,string artcode,string serialnr,string location,string filename,Date td,val qty,val coeff,val totalcost,LongInt transnr,Integer rownr,Integer stockaffectf,string position,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ItemHistVc oldsourceIHr;
  record INVc INr;
  record ITVc ITr;
  LongInt sourcenr;
  val t,rem,remsourceqty,totsourceqty,totsourcecost,useqty;
  Boolean foundf;
  record CostAccBlock CAb;
  Integer primary,queuecostmodel;
  val ltotalcost;
  Date blankd;
  row TempStockVc TSrw;

  ltotalcost = totalcost;//JJ->KH waht do u think about it ?, this is cause of structure items, do we need flag or it can belike this and this what happens with ltotalcost
  if (blank(artcode)) then begin 
    goto LStoreItemHistory_Out;
  end;
  if (qty<0) then begin // for negative item lines, not allowed, but still exists in old data
    if (ltotalcost<0)  then begin
      StoreItemHistory_In(MSb,artcode,serialnr,location,filename,td,td,-qty,coeff,-ltotalcost,transnr,rownr,stockaffectf,position,"",TSr,usetmpstkf);
    end else begin
      StoreItemHistory_In(MSb,artcode,serialnr,location,filename,td,td,-qty,coeff,ltotalcost,transnr,rownr,stockaffectf,position,"",TSr,usetmpstkf);
    end;
    goto LStoreItemHistory_Out;
  end;
  BlockLoad(CAb);
  rem = qty;
  while (rem>0) begin
    RecordNew(IHr);
    IHr.ArtCode = artcode;
    IHr.Variety = "";
    IHr.StockAffectf = stockaffectf;
    if (ReadFirstItem(artcode,INr,false,false)) then begin
      if (artcode!=INr.Code) then begin
        IHr.Variety = right(artcode,len(artcode)-len(INr.Code));
        IHr.ArtCode = INr.Code;
      end;
      switch (INr.ItemType) begin
        case 0:
          switch (filename) begin
            case "SHVc": ;
            otherwise IHr.StockAffectf = 0;
          end;
        case 1: ;
        case 2:
          if (nonblank(INr.Recepy)) then begin
            IHr.StockAffectf = 0;
          end;
        case 3: IHr.StockAffectf = 0;
      end;
    end;
    IHr.SerialNr = serialnr;
    IHr.Location = location;
    IHr.FileName = filename;
    IHr.TransDate = td;
    IHr.FIFODate = td;
    IHr.RemQty = BlankVal;
    if (IHr.StockAffectf!=0) then begin
      foundf = FindSource(MSb,CAb,INr,filename,location,serialnr,sourceIHr,position);
      if (ItemCostPerLocation(INr)==0) then begin
        if (filename=="StockMovVc") then begin
          IHr.FIFODate = sourceIHr.FIFODate;
          if (blankdate(IHr.FIFODate)) then begin
            IHr.FIFODate = td;
          end;
        end;
      end;
    end;
    if (foundf) then begin
      if (rem>sourceIHr.RemQty) then begin
        useqty = sourceIHr.RemQty;
      end else begin
        useqty = rem;
      end;
    end else begin
      useqty = rem;
      if ((IHr.StockAffectf!=0) and (IHr.ItemType==kItemTypeStocked or IHr.ItemType==kItemTypeStructured) and ((INr.ItemType==kItemTypeStocked) or (INr.ItemType==kItemTypeStructured))) then begin
        IHr.RemQty = -useqty;
      end;
    end;
    if (ConsigmentStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
      IHr.ConsigStock = 1;
    end;
    if (TREOStock(IHr.ArtCode,IHr.SerialNr,blankd)) then begin
      IHr.TREOStock = 1;
    end;
    IHr.Qty = -useqty;
    IHr.Qty2 = CalculateQty2(IHr.Qty,coeff);
    IHr.TransNr = transnr;
    IHr.Row = rownr;
    if (foundf) then begin
      if (sourceIHr.RemQty==useqty) then begin
        IHr.TotCostPrice = sourceIHr.RemCostPrice;
      end else begin
        IHr.TotCostPrice = (sourceIHr.TotCostPrice/sourceIHr.Qty) * useqty;
      end;
      IHr.Source = sourceIHr.SerNr;
    end else begin
      if (IHr.RemQty<0) then begin
//        IHr.TotCostPrice = (ltotalcost/qty)*useqty;
        IHr.TotCostPrice = ltotalcost - totsourcecost;
      end else begin
        IHr.TotCostPrice = ltotalcost;
      end;
      IHr.Source = -1;
    end;

    if (ltotalcost==0) then begin
      ltotalcost = IHr.TotCostPrice;
    end;

/*
    switch (filename) begin
      case "RetPUVc":
        if (CAb.RetPUCostPriceNotFromPU!=0) then begin
          IHr.TotCostPrice = ltotalcost;
        end;
    end;
*/
    ITr.Code = INr.Group;
    if (ReadFirstMain(ITr,1,true)) then begin
    end;
    if (usetmpstkf) then begin
      FindTempStockRow(IHr.Row,IHr.ArtCode,true,TSr,TSrw);
      IHr.PrimaryCostModel = TSrw.PrimaryCostModel;
      IHr.QueuedCostModel = TSrw.QueuedCostModel;
      IHr.ItemType = TSrw.ItemType;
      IHr.FIFOPerSerialNr = TSrw.FIFOPerSerialNr;
      IHr.FIFOPerLocation = TSrw.FIFOPerLocation;
      IHr.NoNLCostOnShip = TSrw.NoNLCostOnShip;
      IHr.WAPerLocation = TSrw.WAPerLocation;
      IHr.WABase2 = TSrw.WABase2;
      IHr.UpdWeightAvFromRet = TSrw.UpdWeightAvFromRet;
      IHr.UpdWeightAvFromRetPU = TSrw.UpdWeightAvFromRetPU;
      IHr.StockAffectf = TSrw.StockAffectf;
    end else begin
      GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
      IHr.PrimaryCostModel = primary;
      IHr.QueuedCostModel = queuecostmodel;
      IHr.ItemType = INr.ItemType;
      IHr.FIFOPerSerialNr = GetFIFOPerSerialNr(INr,ITr,CAb);
      IHr.FIFOPerLocation = FIFOPerLocation(INr,ITr,CAb);
      IHr.NoNLCostOnShip = CAb.NoNLCostOnShip;
      IHr.WAPerLocation = WAPerLocation(INr,ITr,CAb);
      IHr.WABase2 = CAb.WABase2;
      IHr.UpdWeightAvFromRet = CAb.UpdWeightAvFromRet;
      IHr.UpdWeightAvFromRetPU = CAb.UpdWeightAvFromRetPU;
    end;
    IHr.VECode = sourceIHr.VECode;
//    IHr.TotCostPrice = Round(IHr.TotCostPrice,CostPriceDecimals);
    IHr.TotCostPrice = Round(IHr.TotCostPrice,CostPriceDecimals);
    IHr.WATotCost = -IHr.Qty*INr.WeighedAvPrice;
    IHr.WATotCostPerLoc = -IHr.Qty*FindCostPriceWA(1,INr,location);
    IHr.CPTotCost = -IHr.Qty*INr.InPrice;
//  IHr.CPTotCostPerLoc = -IHr.Qty*;
    IHr.BPTotCost = -IHr.Qty*FindCostPriceBasePrice(CAb,INr,ITr);
//  IHr.BPTotCostPerLoc = -IHr.Qty*;
/*
    switch (primary) begin
      case 1:
        IHr.CPTotCost = (ltotalcost/qty)*(-IHr.Qty);
//        IHr.CPTotCostPerLoc = (ltotalcost/qty)*(-IHr.Qty);
      case 2:
        IHr.BPTotCost = (ltotalcost/qty)*(-IHr.Qty);
//        IHr.BPTotCostPerLoc = (ltotalcost/qty)*(-IHr.Qty);
      case 3:
        IHr.WATotCost = (ltotalcost/qty)*(-IHr.Qty);
        IHr.WATotCostPerLoc = (ltotalcost/qty)*(-IHr.Qty);
    end;
*/    
    IHr.Position = position;
    IHr.SerNr = NextSerNr("ItemHistVc",IHr.TransDate,-1,false,"");
    if (RecordStore(IHr,false)) then begin end;
    if (foundf) then begin
      RecordCopy(oldsourceIHr,sourceIHr);
      sourceIHr.RemQty = sourceIHr.RemQty - useqty;
      sourceIHr.RemCostPrice = sourceIHr.RemCostPrice - IHr.TotCostPrice;
      totsourcecost = totsourcecost + IHr.TotCostPrice;
      if (RecordUpdate(oldsourceIHr,sourceIHr,false)==0) then begin end;
    end;
    rem = rem - useqty;
  end;
LStoreItemHistory_Out:;
  return;
end;

global
procedure PrintItemHistLine(record ItemHistVc IHr,val totcostprice)
BEGIN
  string 255 tstr;
  record PUVc PUr;
  row PUVc PUrw;
  string 255 disp;
  
  switch (IHr.FileName) begin
    case "IVVc": tstr = USetStr(1150);
    case "PUVc": 
      tstr = USetStr(1157);
      if (IHr.Row>=0) then begin
        PUr.SerNr = IHr.TransNr;
        if (ReadFirstMain(PUr,1,true)) then begin
          MatRowGet(PUr,IHr.Row,PUrw);
          disp = PUrw.DispatchNumber;
        end;
      end;
      
    case "ProdVc": tstr = USetStr(1162);
    case "RetVc": tstr = USetStr(1421);
    case "StockMovVc": tstr = USetStr(1172);
    case "StockTakeVc": tstr = USetStr(1392);
    case "ProdOperationVc": tstr = USetStr(1633);
    case "SRVc": tstr = USetStr(1636);
    
    case "SHVc": tstr = USetStr(5003);
    case "IVCashVc": tstr = USetStr(11675);
    case "SDVc": tstr = USetStr(5020);
    case "WSVc": tstr = USetStr(7650);
    case "INTransferVc": tstr = USetStr(5040);
  end;
  tstr = tstr & ":";
  tstr = tstr & IHr.TransNr;
  
  StartFormat(15);
  OutString(50,"DblItemHistLine",tstr,false);
  OutDate(160,0,IHr.TransDate,false);
  OutString(210,0,disp,false);
  OutVal(3,0,IHr.RemQty,M4Qty,true);
  OutVal(4,0,totcostprice/IHr.RemQty,M45Val,true);
  OutValBiDi(1,0,totcostprice,M45Val,true,505);
  EndFormat;
  return;
end;

/*
global
function val FindCostPriceCostPrice(Integer CostPricePerLocation,record INVc INr,string location)
begin
  val res;
  record ItemHistVc ItemHistr;
  Boolean found;

  res = 0;
  if (CostPricePerLocation!=0) then begin
    ItemHistr.ArtCode = INr.Code;
    ItemHistr.Location = location;
    if (ReadLastKey("ArtCodeLoc",ItemHistr,2,false)) begin    
      found = true;
      if (ItemHistr.ArtCode!=INr.Code) then begin found = false; end;
      if (ItemHistr.Location!=location) then begin found = false; end;
      if (found) then begin
        res = ItemHistr.CPTotCostPerLoc;//ISVC
      end;
    end;
  end else begin
    res = INr.InPrice;//ISVC
  end;
  FindCostPriceCostPrice = res;
  return;
end;
*/

global
updating procedure StockMovStoreItemHistory_In(record MainStockBlock MSb,string artcode,string serialnr,string frlocation,string location,string filename,Date td,val qty,val coeff,val unitcost,LongInt transnr,Integer rownr,Integer stockaffectf,string topos,record TempStockVc TSr,Boolean usetmpstkf)
begin
  record ItemHistVc IHr;
  record ItemHistVc newIHr;
  Boolean foundf,ihf,testf;
  record CostAccBlock CAb;
  Date fifod;

  BlockLoad(CAb);
  foundf = true;
  IHr.FileName = "StockMovVc";
  IHr.TransNr = transnr;
  IHr.Row = rownr;
  while (LoopKey("FNTransNr",IHr,3,foundf)) begin
    if (IHr.FileName!="StockMovVc") then begin foundf = false; end;
    if (IHr.TransNr!=transnr) then begin foundf = false; end;
    if (IHr.Row!=rownr) then begin foundf = false; end;
    if (foundf) then begin
//      if (IHr.Source>0) and (IHr.Qty<0) and (IHr.Location==frlocation) then begin
      testf = false;
      if (IHr.Qty<0) and (IHr.Location==frlocation) then begin
        testf = true;
      end;
      if (nonblank(serialnr)) then begin
        if (IHr.SerialNr!=serialnr) then begin testf = false; end;
      end;
      if (testf) then begin
        fifod = IHr.FIFODate;
        if (ArtCodeCostPerLocation(artcode)!=0) then begin
          fifod = IHr.TransDate;
        end;
//        StoreItemHistory_In(MSb,artcode,IHr.SerialNr,location,filename,IHr.TransDate,fifod,-IHr.Qty,coeff,IHr.TotCostPrice,transnr,rownr,stockaffectf,topos,"");
        StoreItemHistory_In(MSb,artcode,IHr.SerialNr,location,filename,IHr.TransDate,fifod,-IHr.Qty,coeff,-IHr.Qty*unitcost,transnr,rownr,stockaffectf,topos,"",TSr,usetmpstkf);
        ihf = true;
      end;
    end;
  end;
  if (ihf==false) and (ISMAINTENANCE) then begin
    StoreItemHistory_In(MSb,artcode,serialnr,location,"StockMovVc",td,td,qty,coeff,qty*unitcost,transnr,rownr,stockaffectf,topos,"",TSr,usetmpstkf);
  end;
  return;
end;

procedure CalculateINTransferRowFIFO(record CostAccBlock CostAccRec,string location,record INTransferVc INTransferp,row INTransferVc INTransferrw,Integer currow)
BEGIN
  val adjstockv,t;
  row INTransferVc INTransfer2rw;
  Integer j;
  record INVc INr;

  if (ReadFirstItem(INTransferrw.ArtCode,INr,true,false)) then begin end;
  adjstockv = 0;
  for (j=0;j<currow;j=j+1) begin  
    MatRowGet(INTransferp,j,INTransfer2rw);
    if (TestArtCode(INTransfer2rw.ArtCode,INTransferrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + INTransfer2rw.Quant;
    end;
  end;
  INTransferrw.FIFORowVal = FindCostPrice(INTransferrw.ArtCode,"",INTransferrw.SerialNr,INTransferrw.Quant,adjstockv,false);
  INTransferrw.FIFORowVal = Round(INTransferrw.FIFORowVal,SetRoundModeD(5));
  INTransferrw.FIFO = INTransferrw.FIFORowVal/INTransferrw.Quant;
  RETURN;
END;

global
procedure UpdateINTransferFIFO(record INTransferVc INTransferp)
BEGIN
  record MainStockBlock MainStockRec;
  record CostAccBlock CostAccRec;
  row INTransferVc INTransferrw;
  row INTransferVc INTransfer2rw;
  Integer i,rwcnt,j;
  val t,adjstockv;
  string 10 location;
  string 10 loc2;
  
  BlockLoad(MainStockRec);
  BlockLoad(CostAccRec);
  location = INTransferp.FrLocation;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(INTransferp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(INTransferp,i,INTransferrw);
    loc2 = location;
    if (nonblank(INTransferrw.ArtCode)) then begin
      if (INTransferrw.Quant!=0) then begin
        if ((INTransferrw.Quant!=0) and (INTransferrw.FIFO==0)) then begin          
          CalculateINTransferRowFIFO(CostAccRec,loc2,INTransferp,INTransferrw,i);
        end else begin
          INTransferrw.FIFORowVal = INTransferrw.Quant*INTransferrw.FIFO;
          INTransferrw.FIFORowVal = Round(INTransferrw.FIFORowVal,SetRoundModeD(5));
        end;
        MatRowPut(INTransferp,i,INTransferrw);
      end;
    end;
  end;
  return;
end;

function Boolean SerialNrCheck(string SerialNr,Array string aserialnr,Array val aserialnrqty,Integer acnt,var val qleft)
begin
  Boolean res;
  Integer i;
  
  res = false;
  for (i=0;i<acnt;i=i+1) begin
    if (aserialnr[i]==SerialNr) then begin
      if (aserialnrqty[i]!=0) then begin
        qleft = aserialnrqty[i];
        res = true;
      end;
    end;
  end;
  SerialNrCheck = res;
  return;
end;

procedure AddToSerialNr(Array string aserialnr,Array val aserialnrqty,var Integer acnt,val Qty,string SerialNr)
begin
  Integer i;
  
  for (i=0;i<acnt;i=i+1) begin
    if (SerialNr==aserialnr[i]) then begin
      aserialnrqty[i] = aserialnrqty[i] + Qty;
      goto LAddToSerialNr;
    end;
  end;
  aserialnr[acnt] = SerialNr;
  aserialnrqty[acnt] = Qty;
  acnt = acnt + 1;
LAddToSerialNr:;  
  return;
end;

global
function val FindCostPriceSerialNumberBackDated(Integer FIFOPerLocation,record INVc INr,string location,string serialnr,val qty,val adjustqty,Date td,Boolean costfrrecf,Integer print,Boolean ondayratef,Integer OverwriteCostModel,Integer consigstock)
//val adjustqty ? 
begin
  record ItemHistVc IHr;
  record ItemHistVc nextIHr;
  record ItemHistVc outIHr;
  record ItemHistVc printIHr;
  string 200 thekey;
  Integer keys;
  Boolean foundf,firstf,testf;
  val qcnt,res,instock,inprice,consiginstock,qusebefdat,qleft;
  val remcostprice,totcostprice,t,usedqty,outqty,nextqty;
  record CostAccBlock CAb;
  Integer acnt;
  Array string 255 aserialnr;
  Array val aserialnrqty;
  LongInt looppos;
  
  res = 0;
  if (blankdate(td)) or (td==CurrentDate) then begin
//  if (blankdate(td)) then begin
    inprice = FindCostPriceFIFO(FIFOPerLocation,INr,location,serialnr,qty,adjustqty,costfrrecf,print!=0,ondayratef,OverwriteCostModel,consigstock);
    goto LFindCostPriceSerialNumberBackDated;
  end;

  BlockLoad(CAb);
  IHr.ArtCode = INr.Code;
  IHr.Location = location;
  IHr.FIFODate = td;
  if ((FIFOPerLocation==0) or (blank(IHr.Location))) then begin
    thekey = "ArtCodeFD";
    keys = 2;
    instock = GetStockQty(INr.Code,"",td,false);
  end else begin
    thekey = "ArtCodeLocFD";
    keys = 3;
    instock = GetStockQty(INr.Code,location,td,false);
  end;

  switch (consigstock) begin
    case 0:  ;
    case 1: 
      if (blank(location)) then begin
        consiginstock = ConsigmentStockQty(INr.Code,";;;",td);
      end else begin
        consiginstock = ConsigmentStockQty(INr.Code,location,td);
      end;
      instock = instock - consiginstock;
    case 2: 
      if (blank(location)) then begin
        consiginstock = ConsigmentStockQty(INr.Code,";;;",td);
      end else begin
        consiginstock = ConsigmentStockQty(INr.Code,location,td);
      end;
      instock = consiginstock;
  end;
 
  ResetLoop(nextIHr);
  nextIHr.ArtCode = INr.Code;
  nextIHr.Location = location;
  SetLoopPosition(nextIHr,looppos-1);  

  inprice = 0;
  usedqty = 0;
  firstf = true;
  foundf = true;
  while (LoopKey(thekey,nextIHr,2,foundf)) begin // Start from the nextIHr record
    if (nextIHr.ArtCode!=INr.Code) then begin
      foundf = false;
    end;
    if (keys==3) then begin
      if (nextIHr.Location!=location) then begin
        foundf = false;
      end;
    end;
    if (nextIHr.FIFODate>td) then begin
      foundf = false;
    end;
    if (usedqty>=qty) then begin
      foundf = false;
    end;
    if (foundf) then begin
      testf = true;
      if (nextIHr.StockAffectf==0) then begin testf = false; end;
      if (nextIHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (nextIHr.Invalid!=0) then begin testf = false; end;
      if (nextIHr.Qty<0) then begin testf = false; end;
      if (nonblank(location)) then begin
        if (nextIHr.Location!=location) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        qusebefdat = QtyUsedBeforeDate(nextIHr,true,td);
        nextqty = nextIHr.Qty - qusebefdat;
        outqty = outqty - nextIHr.Qty - qusebefdat;
        if (outqty<0) then begin
          outqty = 0;
        end;
        if (nextqty<0) then begin
          testf = false;
        end;
      end;              
      if (testf) then begin     
        if ((usedqty+nextqty)>qty) then begin
          nextqty = qty - usedqty;
        end else begin
          nextqty = nextqty; 
        end;
        usedqty = usedqty + nextqty;
        switch (consigstock) begin
          case 1: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)) then begin
//            if (nextIHr.ConsigStock!=0) then begin 
              testf = false;
            end;
          case 2: 
            if (ConsigmentStock(nextIHr.ArtCode,nextIHr.SerialNr,td)==false) then begin
//            if (nextIHr.ConsigStock==0) then begin 
              testf = false;
            end;
        end;
        if (testf) then begin
        switch (OverwriteCostModel) begin 
          case 3:
            if (FIFOPerLocation!=0) then begin
              t = nextIHr.WATotCostPerLoc/nextIHr.Qty;
            end else begin
              t = nextIHr.WATotCost/nextIHr.Qty;
            end;
            t = FindWAPriceBackdated(FIFOPerLocation,INr,nextIHr.Location,1,td,false,0);
            t = Round(t,SetRoundModeD(2));
            if (nextIHr.FileName=="RetVc") then begin
              if (CAb.RetFIFOQue!=0) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextIHr.RemQty*t;
              end;
            end else begin
//              remcostprice = nextIHr.RemQty*t;
              if (nextqty>nextIHr.Qty) then begin
                remcostprice = nextIHr.Qty*t;
              end else begin
                remcostprice = nextqty*t;
              end;
            end;
            if (nextIHr.Qty>0) then begin
              totcostprice = nextIHr.Qty*t;
            end else begin
              totcostprice = nextIHr.Qty*t;
            end;
          otherwise
            remcostprice = nextIHr.TotCostPrice;
            totcostprice = nextIHr.TotCostPrice;
        end;
        if (costfrrecf) or (ondayratef) then begin
          GetCostsFromRecords(nextIHr,remcostprice,totcostprice,ondayratef,td);
        end;

        if (print==2) then begin
          if (remcostprice!=0) and (nextqty!=0) then begin
            RecordCopy(printIHr,nextIHr);
            switch (OverwriteCostModel) begin 
              case 3:
                if (nextIHr.FileName=="RetVc") then begin
                  if (CAb.RetFIFOQue!=0) then begin
                    printIHr.RemQty = nextIHr.Qty;
                  end;
                end;
            end;
            printIHr.RemQty = nextqty;
            PrintItemHistLine(printIHr,nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals));
          end;          
        end;
        
        inprice = inprice + nextqty * Round((totcostprice / nextIHr.Qty),CostPriceDecimals);

        printIHr.RemQty = printIHr.RemQty + nextqty;
        end;
      end;
    end;
  end;
  if (print==1) then begin
    if (printIHr.TotCostPrice!=0) then begin
      PrintItemHistLine(printIHr,Round(printIHr.TotCostPrice,CostPriceDecimals));
    end;
  end;
LFindCostPriceSerialNumberBackDated:;  
  res = Round(inprice,CostPriceDecimals);
  FindCostPriceSerialNumberBackDated = res;
  return;
end;

global
updating procedure DeleteItemHistVc(string filename,LongInt sernr,Integer rownr)
begin
  record ItemHistVc IHr;
  Boolean found;
  Integer keys;

  keys = 3;
  found = true;
  IHr.FileName = filename;
  IHr.TransNr = sernr;
  if (rownr>=0) then begin
    IHr.Row = rownr;
    keys = 2;
  end;
  while (LoopKey("FNTransNr",IHr,keys,found)) begin
    if (IHr.FileName!=filename) then begin found = false; end;
    if (IHr.TransNr!=sernr) then begin found = false; end;
    if (rownr>=0) then begin
      if (IHr.Row!=rownr) then begin found = false; end;
    end;
    if (found) then begin
      RecordDelete(IHr);
      StepBack(IHr);
    end;
  end;  
  return;
end;

global
updating procedure InvalidateItemHistVc(string filename,LongInt sernr,Integer rownr)
begin
  record ItemHistVc IHr;
  record ItemHistVc oldIHr;
  Boolean found;

  found = true;
  IHr.FileName = filename;
  IHr.TransNr = sernr;
  IHr.Row = rownr;
  while (LoopKey("FNTransNr",IHr,3,found)) begin
    if (IHr.FileName!=filename) then begin found = false; end;
    if (IHr.TransNr!=sernr) then begin found = false; end;
    if (IHr.Row!=rownr) then begin found = false; end;
    if (found) then begin
      RecordCopy(oldIHr,IHr);
      IHr.Invalid = 1;
      if (RecordUpdate(oldIHr,IHr,false)==0) then begin
      end;
    end;
  end;  
  return;
end;

global
function val FindCostPriceBP(Integer WAPerLocation,record INVc INr,string location)
begin
  val res;
  record ITVc ITr;
  record CostAccBlock CAb;

  BlockLoad(CAb);
  ITr.Code = INr.Group;
  if (ReadFirstMain(ITr,1,true)) then begin
  end;
  res = FindCostPriceBasePrice(CAb,INr,ITr);
  FindCostPriceBP = res;
  return;
end;

