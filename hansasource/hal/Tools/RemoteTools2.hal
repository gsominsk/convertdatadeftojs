external function Integer CountObjects(string);
external function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
external function Boolean IVDchrsum(var record IVVc,Integer);
external function string 60 AddObjectToObjectList(string,string);
external function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external procedure AddWithholdingTaxesRows_IVVc(var record IVVc);
external procedure AddPerceptionTaxesRows_IVVc(var record IVVc);
external function roundmode DefaultRoundMode();
external function Boolean GetAccName(string,var string,Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function string 255 FindNextLegalSerNr(record IVVc,string);
external procedure VIDDefault(Integer,string,var record VIVc);
external procedure VISumup(record VIVc,var val);
external procedure CheckFlush(var Integer,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure IVDchsum(var record IVVc,Integer);
external updating procedure DeleteIVrsStats(record IVVc);
external updating procedure SaveTrans(record TRVc);
external function Integer MakeTransFromSH(record TRVc,record SHVc,Boolean,record RcVc);
external function Integer MakeTransFromOwnCheck(record TRVc,var record OwnCheckVc,Boolean,Boolean);
external updating procedure ArtStats(record IVVc,Boolean,Boolean);
external updating procedure IVrsStats(record IVVc);
external procedure PasteCreditSalesAccs(record IVVc);
external procedure Do_InvoiceRecepy(record IVVc,record INVc,Integer);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure IVSumup(var record IVVc,Boolean);
external function LongInt GetCurUserLastNr(string);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);


procedure FindCreditNotePayTerm(var string paydeal)
BEGIN
  Boolean TrHs;
  record PDVc PDr;
  
  TrHs = true;
  paydeal = "";
  PDr.Code = "";
  while (LoopMain(PDr,1,TrHs)) begin
    if (PDr.PDType==3) then begin
      paydeal = PDr.Code;
      goto LFindCreditNotePayTerm;
    end;
  end;
LFindCreditNotePayTerm:;  
  RETURN;
END;

procedure VIClearRows(record VIVc VIp)
BEGIN
  Integer vicnt;

  vicnt = MatRowCnt(VIp);
  while (vicnt>0) begin
    MatRowDelete(VIp,0);
    vicnt = vicnt - 1;
  end;
  RETURN;
END;

function val RetPUVc_FindQtyToBeCredited(LongInt OrdNr,LongInt OrdRow)
begin
  val res;
  record POVc POr;
  row POVc POrw;
  Boolean found;
  Integer i,rwcnt;
  
  found = true;
  POr.SerNr = OrdNr;
  while (LoopMain(POr,1,found)) begin
    if (POr.SerNr!=OrdNr) then begin found = false; end;
    if (found) then begin
      if (OrdRow<MatRowCnt(POr)) then begin
        MatRowGet(POr,OrdRow,POrw);
        res = POrw.Invd - POrw.Shipd1;
      end;
    end;
  end;
  RetPUVc_FindQtyToBeCredited = res;
  return;
end;

function Boolean PasteRetPUInVI_OnePO(var record VIVc VIp,record RetPUVc RetPUp)
begin
  record VIVc VIr;
  row VIVc VIrw;
  row VIVc VI2rw;
  row RetPUVc RetPUrw;
  Integer i,vicnt;
  Integer j,rtcnt;
  Integer cnt;
  LongInt sernr;
  Boolean found,firstf;
  Boolean res,morethanoneinf,vifound;
  val t;
  string 255 tstr;
  record VITBlock VITb;
  string 255 curncy;
  record POSettingBlock POSb;

  BlockLoad(POSb);
  BlockLoad(VITb);
  res = true;
  firstf = true;
  VIr.SerNr = -1;  

  found = true;
  VIr.POSerNr = RetPUp.PONr;
  while (LoopBackKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=RetPUp.PONr) then begin 
      found = false;
    end;
    if (found) then begin
      if (vifound) then begin
        morethanoneinf = true;
        found = false;
      end;
      vifound = true;
    end;    
  end;

  ResetLoop(VIr);  
  VIr.SerNr = -1;  
  found = true;
  VIr.POSerNr = RetPUp.PONr;
  while (LoopBackKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=RetPUp.PONr) then begin 
      found = false;
    end;
    if (VIr.OKFlag==0) then begin goto L88PasteRetPUInVI_OnePO; end;
    if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin goto L88PasteRetPUInVI_OnePO; end;
    if (found) then begin
      rtcnt = MatRowCnt(RetPUp);
      vicnt = MatRowCnt(VIr);
      for (j=0;j<rtcnt;j=j+1) begin
        MatRowGet(RetPUp,j,RetPUrw);
        if ((RetPUrw.Quant!=0) and (RetPUrw.OrdRow!=-1)) then begin
          vicnt = MatRowCnt(VIr);
          for (i=0;i<vicnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (((RetPUrw.ArtCode==VIrw.Item) and (RetPUrw.OrdRow==VIrw.OrdRow)) or (VIrw.OrdRow==-2)) then begin
              if (firstf) then begin
                RecordCopy(VIp,VIr);
                VIClearRows(VIp);
                VIp.TransDate = CurrentDate;
                VIp.InvType = kInvoiceTypeCredit;
                FindCreditNotePayTerm(tstr);
                VIp.PayDeal = tstr;
                VIp.OKFlag = 0;
                VIp.POSerNr = RetPUp.PONr;
                VIp.SerNr = sernr;
                VIp.VATVal = blankval;
                if (morethanoneinf) then begin
                  VIp.CredInv = -1;
                end else begin
                  VIp.CredInv = VIr.SerNr;
                end;
                firstf = false;
              end;

              ClearRow(VIp,VI2rw,1);
              VI2rw.stp = 1;
              CopyRow(VIp,VIrw,VI2rw);


              if (POSb.CreateVIonRetPUOK!=0) then begin
                VI2rw.qty = RetPUVc_FindQtyToBeCredited(RetPUp.PONr,RetPUrw.OrdRow);
              end else begin
                VI2rw.qty = RetPUVc_FindQtyToBeCredited(RetPUp.PONr,RetPUrw.OrdRow);
              end;
              if (VI2rw.qty>RetPUrw.Quant) then begin
                VI2rw.qty = RetPUrw.Quant;
              end;
              if (VI2rw.qty!=0) then begin
                switch (VITb.TransferItems) begin
                  case 2:
                     VI2rw.Sum = VI2rw.qty*RetPUrw.PUCostPrice;
                     if (VI2rw.Sum==0) then begin
                       VI2rw.Sum = RetPUrw.FIFORowVal;
                     end;
                     CurValToOtherCur(CurrentDate,curncy,VI2rw.Sum,VIp.CurncyCode,VI2rw.Sum,DefaultCurRoundOff);
                  otherwise 
                     VI2rw.Sum = (VIrw.Sum*VI2rw.qty)/VIrw.qty;
                end;
                if (GetAccName(RetPUrw.CredAcc,tstr,60)) then begin
                  VI2rw.AccNumber = RetPUrw.CredAcc;
                  VI2rw.Comment = tstr;
                end;
                MatRowPut(VIp,cnt,VI2rw);
                cnt = cnt + 1;
                found = false;
                goto L77PasteRetPUInVI_OnePO;
              end;
            end;
          end;   
        end;
L77PasteRetPUInVI_OnePO:;
      end;
    end;
L88PasteRetPUInVI_OnePO:;
  end;
  VIp.InvoiceNr = "";
  VIp.Comment = RetPUp.Comment;
  VIDDefault(-1,"PayVal",VIp);  
  VISumup(VIp,t);
LPasteRetPUInVI_OnePO:;
  PasteRetPUInVI_OnePO = res;
  return;
end;

function Boolean PasteRetPUInVI_ManyPOs(var record VIVc VIp,record RetPUVc RetPUp)
begin
  Boolean res
/*
  record VIVc VIr;
  row VIVc VIrw;
  row VIVc VI2rw;
  row RetPUVc RetPUrw;
  Integer i,vicnt;
  Integer j,rtcnt;
  Integer cnt;
  LongInt sernr;
  Boolean found,firstf;
  Boolean morethanoneinf,vifound;
  val t;
  string 255 tstr;
  record VITBlock VITb;

  BlockLoad(VITb);
  res = true;
  firstf = true;
  VIr.SerNr = -1;  
  ResetLoop(VIr);  
  VIr.SerNr = -1;  
  found = true;
  VIr.POSerNr = RetPUp.PONr;
  while (LoopBackKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=RetPUp.PONr) then begin 
      found = false;
    end;
    if (VIr.OKFlag==0) then begin goto L88PasteRetPUInVI_ManyPOs; end;
    if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin goto L88PasteRetPUInVI_ManyPOs; end;
    if (found) then begin
      rtcnt = MatRowCnt(RetPUp);
      vicnt = MatRowCnt(VIr);
      for (j=0;j<rtcnt;j=j+1) begin
        MatRowGet(RetPUp,j,RetPUrw);
        if ((RetPUrw.Quant!=0) and (RetPUrw.OrdRow!=-1)) then begin
          vicnt = MatRowCnt(VIr);
          for (i=0;i<vicnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (((RetPUrw.ArtCode==VIrw.Item) and (RetPUrw.OrdRow==VIrw.OrdRow)) or (VIrw.OrdRow==-2)) then begin
              if (firstf) then begin
                RecordCopy(VIp,VIr);
                VIClearRows(VIp);
                VIp.TransDate = CurrentDate;
                VIp.InvType = kInvoiceTypeCredit;
                FindCreditNotePayTerm(tstr);
                VIp.PayDeal = tstr;
                VIp.OKFlag = 0;
                VIp.POSerNr = RetPUp.PONr;
                VIp.SerNr = sernr;
                if (morethanoneinf) then begin
                  VIp.CredInv = -1;
                end else begin
                  VIp.CredInv = VIr.SerNr;
                end;
                firstf = false;
              end;

              ClearRow(VIp,VI2rw,1);
              VI2rw.stp = 1;
              CopyRow(VIp,VIrw,VI2rw);
              VI2rw.qty = RetPUVc_FindQtyToBeCredited(RetPUp.PONr,RetPUrw.OrdRow);
              if (VI2rw.qty>RetPUrw.Quant) then begin
                VI2rw.qty = RetPUrw.Quant;
              end;
              if (VI2rw.qty!=0) then begin
                switch (VITb.TransferItems) begin
                  case 2: VI2rw.Sum = RetPUrw.FIFORowVal;
                  otherwise VI2rw.Sum = (VIrw.Sum*VI2rw.qty)/VIrw.qty;
                end;
                if (GetAccName(RetPUrw.CredAcc,tstr,60)) then begin
                  VI2rw.AccNumber = RetPUrw.CredAcc;
                  VI2rw.Comment = tstr;
                end;
                MatRowPut(VIp,cnt,VI2rw);
                cnt = cnt + 1;
                found = false;
                goto L77PasteRetPUInVI_ManyPOs;
              end;
            end;
          end;   
        end;
L77PasteRetPUInVI_ManyPOs:;
      end;
    end;
L88PasteRetPUInVI_ManyPOs:;
  end;
  VIp.Comment = RetPUp.Comment;
  VIDDefault(-1,"PayVal",VIp);  
  VISumup(VIp,t);
*/  
LPasteRetPUInVI_ManyPOs:;
  PasteRetPUInVI_ManyPOs = res;
  return;
end;

function Boolean PasteRetPUInVI(var record VIVc VIp,record RetPUVc RetPUp)
begin
  Boolean res;
  
  if (RetPUp.PONr>0) then begin
    res = PasteRetPUInVI_OnePO(VIp,RetPUp);
  end else begin
    res = PasteRetPUInVI_ManyPOs(VIp,RetPUp);
  end;
  PasteRetPUInVI = res;
  return;
end;

global
updating function Integer RecordAction_raPasteRetPUInVI(var record VIVc VIp,LongInt retpunr)
BEGIN
  record SRBlock SRRec;
  record RetPUVc RetPUr;
  Integer res;
  LongInt newnr;
  string 255 tstr;
  Boolean nousersernr;
  val temp;
  
  res = -1;
  RecordNew(VIp);
  VIp.SerNr = -1;
  RetPUr.SerNr = retpunr;
  if (ReadFirstMain(RetPUr,1,true)) then begin end;
  if (RetPUr.OKFlag==0) then begin goto LRecordAction_raPasteRetPUInVI; end;
  if (PasteRetPUInVI(VIp,RetPUr)) then begin
    if (VIp.SerNr==-1) then begin
      BlockLoad(SRRec);
      if ((VIp.InvType==kInvoiceTypeCredit or VIp.InvType==kInvoiceTypeCreditSpecialSales) and (SRRec.LastCredVINr!=-1))  then begin
        newnr = GetCurUserLastNr("CreditVIVc");
        if (newnr<=0) then begin
          newnr = SRRec.LastCredVINr;
        end;
        nousersernr = true;
      end;
    end;
    VIp.SerNr = NextSerNr("VIVc",VIp.TransDate,newnr,true,"");
    if (VIp.SerNr==-1) then begin
      res = 1747;
      goto LRecordAction_raPasteRetPUInVI;
    end;
    if ((MatRowCnt(VIp)>0) and (VIp.SerNr!=-1)) then begin
      VISumup(VIp,temp);
      if (RecordInsert(VIp,false)) then begin
        CreateRecordLink(VIp,CurrentCompany,RetPUr,CurrentCompany);  
        CreateRecordLink(RetPUr,CurrentCompany,VIp,CurrentCompany);  
        res = 1;
      end;
    end;
  end else begin
    res = -2;
  end;  
LRecordAction_raPasteRetPUInVI:;
  RecordAction_raPasteRetPUInVI = res;
  RETURN;
END;

procedure IVClearRows(record IVVc IVp)
BEGIN
  Integer ivcnt;

  ivcnt = MatRowCnt(IVp);
  while (ivcnt>0) begin
    MatRowDelete(IVp,0);
    ivcnt = ivcnt - 1;
  end;
  RETURN;
END;

function val RetVc_FindQtyToBeCredited(LongInt OrdNr,LongInt OrdRow)
begin
  val res;
  record ORVc ORr;
  row ORVc ORrw;
  Boolean found;
  Integer i,rwcnt;
  
  found = true;
  ORr.SerNr = OrdNr;
  while (LoopMain(ORr,1,found)) begin
    if (ORr.SerNr!=OrdNr) then begin found = false; end;
    if (found) then begin
      if (OrdRow<MatRowCnt(ORr)) then begin
        MatRowGet(ORr,OrdRow,ORrw);
        res = ORrw.Invd - ORrw.Shipd1;
      end;
    end;
  end;
  RetVc_FindQtyToBeCredited = res;
  return;
end;

procedure NewCreditNote(var record IVVc credIVr,record IVVc IVr,record AccBlock Accb,record RetVc Retp,Boolean morethanoneinf,Boolean pasteretf)
begin
  row IVVc IV2rw;
  string 255 tstr;
  Date blankd;
  record CUVc CUr;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  record LocalMachineBlock LMb;

  if (pasteretf) then begin
   RecordNew(credIVr);
   CUr.Code = credIVr.CustCode;
   ReadFirstMain(CUr,1,true);
   credIVr.CustCode = Retp.CustCode;
   PasteCust2InInv(credIVr,LMb,"",true,warning,errstr,prepstr,invdatewarn,transdatewarn);
   
   credIVr.Addr0 = Retp.CustName;
   credIVr.Location = Retp.Location;
   credIVr.Objects = AddObjectToObjectList(credIVr.Objects,Retp.Objects);
   credIVr.CurncyCode = Retp.CurncyCode;
   credIVr.FrRate = Retp.FrRate;
   credIVr.ToRateB1 = Retp.ToRateB1;
   credIVr.ToRateB2 = Retp.ToRateB2;
   credIVr.BaseRate1 = Retp.BaseRate1;
   credIVr.BaseRate2 = Retp.BaseRate2;
  end else begin
    RecordCopy(credIVr,IVr);
  end;
  credIVr.SerNr = -1;
  IVClearRows(credIVr);
  credIVr.Reason = Retp.Reason;
  credIVr.CAE = "";
  credIVr.OfficialSerNr = "";
  credIVr.OfficialSerNr2 = "";
  credIVr.CAEExpiry = blankd;
  credIVr.TransDate = CurrentDate;
  credIVr.InvDate = credIVr.TransDate;
  credIVr.PayDate = credIVr.TransDate;
  credIVr.ServiceDelDate = Retp.TransDate;
  credIVr.InvType = kInvoiceTypeCredit;
  FindCreditNotePayTerm(tstr);
  credIVr.PayDeal = tstr;
  credIVr.OKFlag = 0;
  credIVr.UpdStockFlag = 0;
  credIVr.OrderNr = Retp.OrdNr;
  credIVr.SVONr = -1;
  if (morethanoneinf) then begin
    credIVr.CredInv = -1;
  end else begin
    credIVr.CredInv = IVr.SerNr;
  end;    
  credIVr.DisputedFlag = Accb.SetDisputedFlagsOnCredIV;
  ClearRow(credIVr,IV2rw,3);
  IV2rw.stp = 3;
  IV2rw.OrdRow = credIVr.CredInv;
  MatRowInsert(credIVr,0,IV2rw);
  return;
end;

function Boolean PasteRetInInv(var record IVVc credIVr,record RetVc Retp,Boolean addon)
begin
  record AccBlock ARAccRec;
  record IVVc IVr;
  record INVc INr;
  row IVVc IVrw;
  row IVVc IV2rw;
  row RetVc Retrw;
  Integer i,ivcnt;
  Integer j,rtcnt;
  Integer cnt,sernrf;
  LongInt sernr;
  Boolean found,infound,credinvf;
  Boolean ivfound,res,morethanoneinf;
  val t;
  vector val vremq;
  vector Boolean vremqf;
  string 255 tstr,inwarning,warning;
  record GeneralOptionBlock GenOptRec;
  record CostAccBlock CostAccRec;
  Date blankd;

  BlockLoad(GenOptRec);
  BlockLoad(CostAccRec);
  res = true;
  BlockLoad(ARAccRec);          

  if (Retp.OrdNr>0) then begin
    IVr.SerNr = -1;  
    found = true;
    IVr.OrderNr = Retp.OrdNr;
    while (LoopBackKey("OrderNr",IVr,1,found)) begin
      if (IVr.OrderNr!=Retp.OrdNr) then begin 
        found = false;
      end;
      if (found and IVr.InvType<>kInvoiceTypeCredit) then begin
        if (ivfound) then begin
          morethanoneinf = true;
          found = false;
        end;
        ivfound = true;
      end;    
    end;
    ResetLoop(IVr);  
    IVr.SerNr = -1;  
    found = true;
    IVr.OrderNr = Retp.OrdNr;
    while (LoopBackKey("OrderNr",IVr,1,found)) begin
      if (IVr.OrderNr!=Retp.OrdNr) then begin 
        found = false;
      end;
      if (IVr.OKFlag==0) then begin goto L88PasteRetInInv; end;
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin goto L88PasteRetInInv; end;
      if (found) then begin
        rtcnt = MatRowCnt(Retp);
        ivcnt = MatRowCnt(IVr);
        for (j=0;j<rtcnt;j=j+1) begin
          MatRowGet(Retp,j,Retrw);
          if (vremqf[j]==false) then begin
            vremq[j] = Retrw.Quant;
            vremqf[j] = true;
          end;
          if ((vremq[j]!=0) and (Retrw.OrdRow!=-1)) then begin
            ivcnt = MatRowCnt(IVr);
            for (i=0;i<ivcnt;i=i+1) begin
              MatRowGet(IVr,i,IVrw);
              if ((Retrw.ArtCode==IVrw.ArtCode) and (Retrw.OrdRow==IVrw.OrdRow)) then begin
                if (credinvf==false) then begin
                  NewCreditNote(credIVr,IVr,ARAccRec,Retp,morethanoneinf,false);
                  cnt = MatRowCnt(credIVr);
                  credinvf = true;
                end;
                ClearRow(credIVr,IV2rw,1);
                IV2rw.stp = 1;
                CopyRow(credIVr,IVrw,IV2rw);
                IV2rw.RetRow = j;
  //              IV2rw.Quant = Retrw.Quant;
                IV2rw.Quant = RetVc_FindQtyToBeCredited(Retp.OrdNr,Retrw.OrdRow);
                if (IV2rw.Quant>vremq[j]) then begin
                  IV2rw.Quant = vremq[j];
                end;
                vremq[j] = vremq[j] - IV2rw.Quant;
                if (IV2rw.Quant<=0) then begin 
                  goto L77PasteRetInInvRow;
                end;
                
                IV2rw.Location = Retrw.Location;
                IV2rw.FIFO = Retrw.UPrice;
                IV2rw.FIFORowVal = IV2rw.Quant*IV2rw.FIFO;
                if (IV2rw.Quant!=0) then begin
                  IV2rw.Sum = (IVrw.Sum/IVrw.Quant)*IV2rw.Quant;
                end;
                IV2rw.SerialNr = Retrw.SerialNr;
                infound = ReadFirstItem(IVrw.ArtCode,INr,true,false);
                IV2rw.Perceptions = INr.Perceptions;
                MatRowPut(credIVr,cnt,IV2rw);
                IVDchsum(credIVr,cnt);
                cnt = cnt + 1;
                if (infound) then begin
                  if (nonblank(INr.InvRecepy)) then begin
                    if (IV2rw.Price==0) then begin
                      IV2rw.Price = INr.UPrice1;
                      CalcSum(IV2rw.Quant,IV2rw.Price,INr.PriceFactor,IV2rw.vRebate,t,GenOptRec.UseDiscount);
                      IV2rw.Sum = t;
                      MatRowPut(credIVr,cnt-1,IV2rw);
                    end;  
                    Do_InvoiceRecepy(credIVr,INr,cnt);
                    cnt = MatRowCnt(credIVr);
                  end;
                end;              
L77PasteRetInInvRow:;              
  //              found = false;//???????
                goto L77PasteRetInInv;
              end;
            end;   
          end;
L77PasteRetInInv:;
        end;
      end;
L88PasteRetInInv:;
    end;
  end else begin
    ResetLoop(IVr);  
    IVr.SerNr = -1;  
    found = true;
    IVr.SVONr = Retp.SVONr;
    while (LoopBackKey("SVONr",IVr,1,found)) begin
      if (IVr.SVONr!=Retp.SVONr) then begin 
        found = false;
      end;
      if (found and IVr.InvType<>kInvoiceTypeCredit) then begin
        if (ivfound) then begin
          morethanoneinf = true;
          found = false;
        end;
        ivfound = true;
      end;    
    end;
    if (ivfound) then begin
      ResetLoop(IVr);  
      IVr.SerNr = -1;  
      found = true;
      IVr.SVONr = Retp.SVONr;
      while (LoopBackKey("SVONr",IVr,1,found)) begin
        if (IVr.SVONr!=Retp.SVONr) then begin 
          found = false;
        end;
        if (IVr.OKFlag==0) then begin goto L88PasteRetInInv; end;
        if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin goto L88PasteRetInInvSVO; end;
        if (found) then begin
          rtcnt = MatRowCnt(Retp);
          ivcnt = MatRowCnt(IVr);
          for (j=0;j<rtcnt;j=j+1) begin
            MatRowGet(Retp,j,Retrw);
            if (vremqf[j]==false) then begin
              vremq[j] = Retrw.Quant;
              vremqf[j] = true;
            end;
            if ((vremq[j]!=0) and (Retrw.WSRow!=-1)) then begin
              ivcnt = MatRowCnt(IVr);
              for (i=0;i<ivcnt;i=i+1) begin
                MatRowGet(IVr,i,IVrw);
//                if ((Retrw.ArtCode==IVrw.ArtCode) and (Retrw.SVORow==IVrw.OrdRow)) then begin
                if (Retrw.ArtCode==IVrw.ArtCode) then begin
                  if (credinvf==false) then begin
                    NewCreditNote(credIVr,IVr,ARAccRec,Retp,morethanoneinf,false);
                    cnt = MatRowCnt(credIVr);
                    credinvf = true;
                  end;
                  ClearRow(credIVr,IV2rw,1);
                  IV2rw.stp = 1;
                  CopyRow(credIVr,IVrw,IV2rw);
                  IV2rw.RetRow = j;
                  IV2rw.Quant = Retrw.Quant;
//                  IV2rw.Quant = RetVc_FindQtyToBeCredited(Retp.OrdNr,Retrw.OrdRow);
                  if (IV2rw.Quant>vremq[j]) then begin
                    IV2rw.Quant = vremq[j];
                  end;
                  vremq[j] = vremq[j] - IV2rw.Quant;
                  if (IV2rw.Quant<=0) then begin 
                    goto L77PasteRetInInvSVORow;
                  end;
                  
                  IV2rw.Location = Retrw.Location;
                  IV2rw.FIFO = Retrw.UPrice;
                  IV2rw.FIFORowVal = IV2rw.Quant*IV2rw.FIFO;
                  if (IV2rw.Quant!=0) then begin
                    IV2rw.Sum = (IVrw.Sum/IVrw.Quant)*IV2rw.Quant;
                  end;
                  IV2rw.SerialNr = Retrw.SerialNr;
                  infound = ReadFirstItem(IVrw.ArtCode,INr,true,false);
                  IV2rw.Perceptions = INr.Perceptions;
                  MatRowPut(credIVr,cnt,IV2rw);
                  IVDchsum(credIVr,cnt);
                  cnt = cnt + 1;
                  if (infound) then begin
                    if (nonblank(INr.InvRecepy)) then begin
                      if (IV2rw.Price==0) then begin
                        IV2rw.Price = INr.UPrice1;
                        CalcSum(IV2rw.Quant,IV2rw.Price,INr.PriceFactor,IV2rw.vRebate,t,GenOptRec.UseDiscount);
                        IV2rw.Sum = t;
                        MatRowPut(credIVr,cnt-1,IV2rw);
                      end;  
                      Do_InvoiceRecepy(credIVr,INr,cnt);
                      cnt = MatRowCnt(credIVr);
                    end;
                  end;              
  L77PasteRetInInvSVORow:;              
    //              found = false;//???????
                  goto L77PasteRetInInvSVO;
                end;
              end;   
            end;
  L77PasteRetInInvSVO:;
          end;
        end;
L88PasteRetInInvSVO:;
      end;
    end;
  end;

  rtcnt = MatRowCnt(Retp);
  for (j=0;j<rtcnt;j=j+1) begin
    MatRowGet(Retp,j,Retrw);
    if ((Retrw.OrdRow==-1) and (Retrw.SHRow==-1) and (Retrw.WSRow==-1)) then begin
      if (credinvf==false) then begin
        RecordClear(IVr);
        NewCreditNote(credIVr,IVr,ARAccRec,Retp,true,true);
        cnt = MatRowCnt(credIVr);
        credinvf = true;
      end else begin
        credIVr.CredInv = -1;
        MatRowGet(credIVr,0,IV2rw);
        IV2rw.OrdRow = credIVr.CredInv;
        MatRowPut(credIVr,0,IV2rw);
      end;
      ClearRow(credIVr,IV2rw,1);
      IV2rw.stp = 1;
      IV2rw.RetRow = j;
      IV2rw.Quant = Retrw.Quant - Retrw.Invd;
      if (IV2rw.Quant<=0) then begin 
        goto L772PasteRetInInvRow;
      end;
      IV2rw.ArtCode = Retrw.ArtCode;
      MatRowPut(credIVr,cnt,IV2rw);
      IVVc_PasteArtCode(credIVr,cnt,inwarning,warning,false,sernrf);
      MatRowGet(credIVr,cnt,IV2rw);
      IV2rw.Spec = Retrw.Spec;
      IV2rw.SerialNr = Retrw.SerialNr;
      IV2rw.Location = Retrw.Location;
      IV2rw.Recepy = Retrw.Recepy;
      IV2rw.Objects = Retrw.Objects;
      IV2rw.UnitXval = Retrw.UnitXval;
      IV2rw.UnitYval = Retrw.UnitYval;
      IV2rw.UnitZval = Retrw.UnitZval;
      IV2rw.BasePrice = Retrw.BasePrice;
      IV2rw.Coefficient = Retrw.Coefficient;
      IV2rw.FIFO = Retrw.UPrice;
      IV2rw.NotUpdStockFlag = 1;
      IV2rw.FIFORowVal = IV2rw.Quant*IV2rw.FIFO;
      if (IV2rw.Quant!=0) then begin
        IV2rw.Sum = (IVrw.Sum/IVrw.Quant)*IV2rw.Quant;
      end;
      infound = ReadFirstItem(IVrw.ArtCode,INr,true,false);
      IVrw.Perceptions = INr.Perceptions;
      MatRowPut(credIVr,cnt,IV2rw);
      if (IV2rw.Sum==0) then begin
        IVDchrsum(credIVr,cnt);
      end;
      IVDchsum(credIVr,cnt);
      cnt = cnt + 1;
L772PasteRetInInvRow:;
    end;
  end;
  
  if (ARAccRec.CredSalesAccs!=0) then begin
    PasteCreditSalesAccs(credIVr);          
  end;  
  credIVr.InvComment = Retp.Comment;
  credIVr.Location = Retp.Location;
  credIVr.RetNr = Retp.SerNr;
  AddPerceptionTaxesRows_IVVc(credIVr);
  AddWithholdingTaxesRows_IVVc(credIVr);
  IVSumup(credIVr,true);
LPasteRetInInv:;
  PasteRetInInv = res;
  RETURN;
END;

global
updating function Integer RecordAction_raPasteRetInInv(var record IVVc IVp,LongInt retnr)
BEGIN
  record SRBlock SRb;
  record RetVc Retr;
  record RetVc oldRetr;
  Integer res;
  LongInt newnr;
  string 255 tstr;
  Boolean nousersernr;
  record CUVc CUr;
  
  res = -1;
  RecordNew(IVp);
  IVp.SerNr = -1;
  IVp.UpdStockFlag = 0;
  Retr.SerNr = retnr;
  if (ReadFirstMain(Retr,1,true)) then begin end;
  RecordCopy(oldRetr,Retr);
  if (PasteRetInInv(IVp,Retr,false)) then begin
    if (IVp.SerNr==-1) then begin
      BlockLoad(SRb);
      if ((IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) and (SRb.LastCredInvNr!=-1))  then begin
        newnr = GetCurUserLastNr("CreditIVVc");
        if (newnr<=0) then begin
          newnr = SRb.LastCredInvNr;
        end;
        nousersernr = true;
      end else begin
        if ((IVp.InvType==kInvoiceTypeCash or IVp.InvType==kInvoiceTypeCashInvoiceReceiptPRT) and (SRb.LastCashInvNr!=-1))  then begin
          newnr = SRb.LastCashInvNr;
          nousersernr = true;
          if (newnr==-1) then begin
            newnr = GetCurUserLastNr("IVVc");
            nousersernr = false;
          end;
        end else begin
          newnr = GetCurUserLastNr("IVVc");
          if (newnr<=0) then begin
            newnr = SRb.LastInvNr;
          end;
        end;
      end;
    end;
    IVp.SerNr = NextSerNr("IVVc",IVp.TransDate,newnr,true,"");
    if (IVp.SerNr==-1) then begin
      res = 1747;
      goto LRecordAction_raPasteRetInInv;
    end;
//    CUr.Code = IVp.CustCode;
//    if (ReadFirstMain(CUr,1,true)) then begin end;
//    IVp.OfficialSerNr = FindNextLegalSerNr(IVp,CUr.Classification);  //POSN
    if ((MatRowCnt(IVp)>1) and (IVp.SerNr!=-1)) then begin
      IVSumup(IVp,true);
      if (RecordInsert(IVp,false)) then begin
//        IVUpdateWSIVVc(IVp);
        res = 1;
//        Retr.InvoiceNr = IVp.SerNr;
//        RecordUpdate(oldRetr,Retr,false);
//moved to OnSaveInvoice
        CreateRecordLink(IVp,CurrentCompany,Retr,CurrentCompany);  
        CreateRecordLink(Retr,CurrentCompany,IVp,CurrentCompany);  
      end;
    end;
  end else begin
    res = -2;
  end;  
LRecordAction_raPasteRetInInv:;
  RecordAction_raPasteRetInInv = res;
  RETURN;
END;

global
updating function Boolean BatchStat(record IVVc IVp,Boolean negflag,Boolean unokf)
BEGIN
  if (unokf) then begin
    DeleteIVrsStats(IVp);
  end else begin
    IVrsStats(IVp);
  end;
  ArtStats(IVp,negflag,false);
LBatchStat:;
  BatchStat = true;
  RETURN;
END;

updating procedure UserStatUp(string salesmen,Date dp,val exlp,val inclp,val payp,val gpp,val basebalp,val sumpp,Boolean negf)
begin
  record USVc USr;
  Boolean found,testf;
  val exl,incl,pay,gp,basebal;
  val sump;
  Boolean found2;
  Date ldp;
  string 255 tmpsalesman,uc;
  longint charpos;
  val nrofsalesman;

  ldp = dp;
  testf = true;
  if (blankdate(ldp)) then begin testf = false; end;
  if (testf) then begin 
    if (GetYear(ldp)<1980) then begin
      ldp = AddYear(ldp,-GetYear(ldp)+1980);
    end;
    nrofsalesman = CountObjects(salesmen);
    if (nrofsalesman==0) then begin nrofsalesman = 1;  end;
    tmpsalesman = salesmen;
    charpos = 0;
    while (GetNextSubstring(tmpsalesman,charpos,",",uc)) begin
      USr.UserCode = uc;
      found = ReadFirstMain(USr,1,true);
      if (found) then begin
      end else begin
        USr.UserCode = uc;
      end;
      exl = exlp;
      incl = inclp;
      pay = payp;
      gp = gpp;
      basebal = basebalp;
      sump = sumpp;
      sump = Round(sump,DefaultRoundMode);
      if (negf==true) then begin
        exl = -exl;
        incl = -incl;
        pay = -pay;
        gp = -gp;
        basebal = -basebal;
        sump = -sump;
      end;  
      exl = exl / nrofsalesman;
      incl = incl / nrofsalesman;
      gp = gp / nrofsalesman; 
      pay = pay / nrofsalesman;  
      basebal = basebal / nrofsalesman; 
      sump = sump / nrofsalesman;
      AddBalance(USr,ldp,"salesexclvat",exl,"salesinclvat",incl,"grossprofit",gp,"paidvalue",pay,"balance",basebal,"priceexcldiscount",sump);  
    end;
  end;      
  return;
end;

updating procedure SalesmanArtStatUp(string ac,string salesmen,Date dp,val qp,val sp,val gpp,val pp,Boolean negf,val icssp,val icsgpsp,val icspp)
begin
  record IUSVc IUSr;
  Boolean found;
  val q,s,gp,p;
  Date ldp;
  boolean testf;
  string 255 tmpsalesman,uc;
  longint charpos;
  val nrofsalesman;
  
  ldp = dp;
  testf = true;
  if (blankdate(ldp)) then begin testf = false; end;
  if (testf) then begin 
    if (GetYear(ldp)<1980) then begin
      ldp = AddYear(ldp,-GetYear(ldp)+1980);
    end;
    nrofsalesman = CountObjects(salesmen);
    if (nrofsalesman==0) then begin nrofsalesman = 1;  end;
    tmpsalesman = salesmen;
    charpos = 0;
    while (GetNextSubstring(tmpsalesman,charpos,",",uc)) begin
      q = qp;
      s = icssp;
      gp = icsgpsp;
      p = icspp;
      p = Round(p,DefaultRoundMode);
      if (negf==true) then begin
        q = -q;
        s = -s;
        gp = -gp;
        p = -p;
      end;
      s = s / nrofsalesman;
      gp = gp / nrofsalesman;
      p = p / nrofsalesman;
      IUSr.ArtCode = ac;
      IUSr.UserCode = uc;
      found = ReadFirstMain(IUSr,2,true);
      if (found) then begin
      end else begin
        IUSr.ArtCode = ac;
        IUSr.UserCode = uc;
      end;
      AddBalance(IUSr,ldp,"salesexclvat",s,"quant",q,"grossprofit",gp,"price",p,"",blankval,"",blankval);  
    end;
  end;
  return;
end;

global
updating procedure SalesmanStats(record IVVc IVp,record IVVc IV2p,Boolean iv2f)
BEGIN
  Integer i,m;
  Integer rwcnt;
  record IVVc IV2r;
  row IVVc IVrw;
  row IVVc IV2rw;
  Boolean negf,rnegf;
  val t,t2;
  val basesum;
  val gps;
  val bv;
  val sumprice,temp;
  val pri;
  string 255 cust;
  Boolean cashcredit;
  Boolean sumpriceflag;
  val sum4,sumprice2,basesum2,bv2,gps2;
  val icsbasesum;
  val icsgps;
  val icsprice;
  val ts,tsum;
  record TaxMatrixVc TMr;
  string 255 salesmen,salesmen2;

  if (iv2f) then begin
    if ((IV2p.OKFlag!=0) and (IVp.OKFlag!=0)) then begin
      if (IVp.Invalid==IV2p.Invalid) and (IVp.Invalid==1) then begin goto LSalesmanStats; end;
      if (IVp.SalesMan==IV2p.SalesMan) then begin goto LSalesmanStats; end;
    end;
  end;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin negf = true; end;
  if (IVp.Invalid!=0) then begin
    if (negf) then begin
      negf = false; 
    end else  begin
      negf = true;
    end;
  end;
  rnegf = negf;
  if (blankdate(IVp.TransDate)) then begin goto LSalesmanStats; end;
  rwcnt = MatRowCnt(IVp);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.stp==5) then begin sumpriceflag=true; end;
    if (IVrw.stp==kInvoiceRowTypeNormal) or (IVrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVrw.stp==11) then begin
      salesmen = IVrw.Salesmen;
      if (blank(salesmen)) then begin salesmen = IVp.SalesMan; end;

      t = MulRateToBase1(IVp.CurncyCode,IVrw.Sum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
      UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
      FindSalesExVat(TMr,IVrw.VATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,basesum);
      gps = gps + IVrw.rowGP;
      temp = IVrw.Quant*IVrw.Price;
      if (temp==0) then begin temp = IVrw.Sum; end;
      icsprice = temp;
      icsbasesum = basesum;
      icsgps = IVrw.rowGP;
      if (IVp.DiscSum!=0) then begin
        ts = IVrw.Quant*IVrw.Price;
        ts = ts*IVp.DiscPerc;
        ts = ts/100;
        sumprice2 = sumprice2 + ts;        
        icsprice = ts;
        ts = IVrw.rowGP*IVp.DiscPerc;
        ts = ts/100;
        gps2 = gps2 + ts;     
        icsgps = ts;
        tsum = IVrw.Sum;
        ts = tsum*IVp.DiscPerc;
        ts = ts/100;
        tsum = tsum - ts;
        ts = MulRateToBase1(IVp.CurncyCode,tsum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
        FindSalesExVat(TMr,IVrw.VATCode,ts,IVp.InclVAT,IVp.NoTAXonVAT,icsbasesum);
      end;
      rnegf = negf;
      if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (IVrw.stp==11) then begin
          rnegf = !rnegf;
        end;
      end;
      if (iv2f) then begin
        if ((IV2p.OKFlag!=0) and (IVp.OKFlag!=0)) then begin
          if (IVp.Invalid==IV2p.Invalid) then begin
            MatRowGet(IV2p,i,IV2rw);
            salesmen2 = IV2rw.Salesmen;
            if (blank(salesmen2)) then begin salesmen2 = IV2p.SalesMan; end;
            if (blank(salesmen2)) then begin salesmen2 = IVrw.Salesmen; end;
            SalesmanArtStatUp(IVrw.ArtCode,salesmen2,IVp.TransDate,IVrw.Quant,basesum,IVrw.rowGP,temp,!rnegf,icsbasesum,icsgps,icsprice);      
          end;
        end;
      end;
      SalesmanArtStatUp(IVrw.ArtCode,salesmen,IVp.TransDate,IVrw.Quant,basesum,IVrw.rowGP,temp,rnegf,icsbasesum,icsgps,icsprice);      
      if (IVrw.stp==11) then begin
        sumprice = sumprice - temp;
      end else begin
        sumprice = sumprice + temp;
      end;
    end;
  end;
  if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin    
    if (rwcnt>0) then begin
      MatRowGet(IVp,0,IVrw);
      if (IVrw.stp==3) then begin
        IV2r.SerNr = IVrw.OrdRow;
        if (ReadFirstMain(IV2r,1,true)) then begin
          if (IV2r.InvType==kInvoiceTypeCash or IV2r.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin cashcredit = true; end;
        end;
      end;
    end;
  end;
  if (IVp.FrPrice!=0) then begin
    pri = 0;
    t = MulRateToBase1(IVp.CurncyCode,IVp.FrPrice,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
    RecordClear(TMr);
    FindSalesExVat(TMr,IVp.FrVATCode,t,IVp.InclVAT,IVp.NoTAXonVAT,basesum);
    t = 1;
    icsprice = pri; 
    icsbasesum = basesum;
    icsgps = IVp.FrGP;
    if (IVp.DiscSum!=0) then begin
      icsgps = IVp.FrGP;
      ts = IVp.FrGP*IVp.DiscPerc;
      ts = ts/100;
      gps2 = gps2 + ts;
      icsgps = icsgps - ts;       
      tsum = IVp.FrPrice;
      ts = IVp.FrPrice*IVp.DiscPerc;
      ts = ts/100;
      tsum = tsum - ts;
      ts = MulRateToBase1(IVp.CurncyCode,tsum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
      FindSalesExVat(TMr,IVp.FrVATCode,ts,IVp.InclVAT,IVp.NoTAXonVAT,icsbasesum);
    end;
    gps = gps + IVp.FrGP;
  end;
  t = 0;
  t2 = IVp.Sum1;
  if (IVp.InclVAT!=0) then begin
    t2 = IVp.Sum4 - IVp.Sum3;
  end;
  if (IVp.DiscSum!=0) then begin
    ts = t2;
    ts = ts*IVp.DiscPerc;
    ts = ts/100;
    basesum2 = MulRateToBase1(IVp.CurncyCode,ts,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
    bv2 = MulRateToBase1(IVp.CurncyCode,IVp.DiscSum,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  end;
  basesum = MulRateToBase1(IVp.CurncyCode,t2,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  bv = MulRateToBase1(IVp.CurncyCode,IVp.Sum4,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
  if ((IVp.InvType==kInvoiceTypeCash or IVp.InvType==kInvoiceTypeCashInvoiceReceiptPRT) or (cashcredit==true)) then begin
    t = IVp.Sum4;
    bv = blankval;
    bv2 = blankval;
  end;
  if (nonblank(IVp.OrgCust)) then begin
    cust = IVp.OrgCust;
  end else begin
    cust = IVp.CustCode;
  end;;
  if (sumpriceflag==true) then begin sumprice = basesum; end;
  sum4 = IVp.Sum4;
  if (IVp.DiscSum!=0) then begin
     if (sumpriceflag==true) then begin sumprice2 = basesum2; end;
     basesum = basesum - basesum2;
     sum4 = sum4 - IVp.DiscSum;
     if (t!=0) then begin t = t - IVp.DiscSum; end;
     gps = gps - gps2;
     bv = bv - bv2;
     sumprice = sumprice - sumprice2;
  end;  
  if (iv2f) then begin
    if ((IV2p.OKFlag!=0) and (IVp.OKFlag!=0)) then begin
      UserStatUp(IV2p.SalesMan,IV2p.TransDate,basesum,sum4,t,gps,bv,sumprice,!negf);    
    end;
  end;
  UserStatUp(IVp.SalesMan,IVp.TransDate,basesum,sum4,t,gps,bv,sumprice,negf);      
LSalesmanStats:;
  RETURN;
END;

global
updating function Boolean RecordAction_rlIVLOK(var record IVVc IVp,Boolean readf,var Integer flushcnt)
BEGIN
  Boolean res;
  record IVVc oldIVp;
  
  if (IsRecordLocked(IVp)==false) then begin
    if (readf) then begin
      if (ReadFirstMain(IVp,0,true)) then begin end;  
    end;
    RecordCopy(oldIVp,IVp);
//    res = acIVLOK(IVp);
//    if (res) then begin
    if (IVp.OKFlag==0) then begin
      IVp.OKFlag = 1;
      if (RecordUpdate(oldIVp,IVp,true)==0) then begin
        res = true;
      end;
    end;
  end;  
  RecordAction_rlIVLOK = res;
  RETURN;
END;

/*  
updating function Boolean acIVCashLOK(record IVCashVc IVCashp)
BEGIN
  record CUVc CUr;
  record IVCashVc IVCash2r;
  val limit,bal;
  Boolean res;
  Integer updatemode;

  updatemode = 2;//Rs_update
//    if (IVCashr.Invalid!=0) then begin testf = false; end;
  if (IVCashp.OKFlag==0) then begin
    RecordCopy(IVCash2r,IVCashp);
    BlockLoad(CreditLimitRec);
    IVCashUpdateFIFO(IVCashp,true);
    IVCashp.OKFlag = 1;
    if (IVCashVcRecordCheck(IVCashp,IVCash2r,updatemode,1)==0) then begin      
      IVCashp.Prntdf = 0;
//      InvOK(IVCashp,true);
      res = BatchStat(IVCashp,false,false);
      SalesmanStats(IVCashp,IVCash2r,true);
      res = true;
    end;
  end;
LacIVCashLOK:;
  acIVCashLOK = res;
  RETURN;
END;
*/  

global
updating function Boolean RecordAction_rlIVCashLOK(var record IVCashVc IVCashp)
BEGIN
  Boolean res;
  record IVCashVc oldIVCashp;
  
  if (IsRecordLocked(IVCashp)==false) then begin
    if (ReadFirstMain(IVCashp,0,true)) then begin end;  
    RecordCopy(oldIVCashp,IVCashp);
//    res = acIVCashLOK(IVCashp);
//    if (res) then begin
    if (IVCashp.OKFlag==0) and (IVCashp.Invalid==0) then begin
      IVCashp.OKFlag = 1;
      if (RecordUpdate(oldIVCashp,IVCashp,true)==0) then begin
        res = true;
      end;
    end;
  end;  
  RecordAction_rlIVCashLOK = res;
  RETURN;
END;

/* This code can't be correct */
updating function Boolean acOwnCheckClear(var record OwnCheckVc OwnCheckp)
BEGIN
  Boolean res;  
  record TRVc gTRp;

  OwnCheckp.Openf = 2;
  if (MakeTransFromOwnCheck(gTRp,OwnCheckp,false,false)==0) then begin
    if ((gTRp.Number>0) and (gTRp.IntYc==OwnCheckYc)) then begin
       SaveTrans(gTRp);
    end;        
    res = true;
  end;
  acOwnCheckClear = res;
  RETURN;
END;

global
updating function Boolean RecordAction_rlOwnCheckClear(var record OwnCheckVc OwnCheckp)
BEGIN
  Boolean res;
  record OwnCheckVc oldOwnCheckp;
  
  if (IsRecordLocked(OwnCheckp)==false) then begin
    if (ReadFirstMain(OwnCheckp,0,true)) then begin end;  
    RecordCopy(oldOwnCheckp,OwnCheckp);
    res = acOwnCheckClear(OwnCheckp);
    if (res) then begin
      if (RecordUpdate(oldOwnCheckp,OwnCheckp,false)==0) then begin
      end;
    end;
  end;
  RecordAction_rlOwnCheckClear = res;
  RETURN;
END;

global
updating function Boolean RecordAction_rlGCLOK(var record GCVc GCp,Boolean readf)
BEGIN
  Boolean res;
  record GCVc oldGCp;
  
  if (IsRecordLocked(GCp)==false) then begin
    if (readf) then begin
      if (ReadFirstMain(GCp,0,true)) then begin end;  
    end;
    RecordCopy(oldGCp,GCp);
    if (GCp.OKFlag==0) then begin
      GCp.OKFlag = 1;
      if (RecordUpdate(oldGCp,GCp,true)==0) then begin
        res = true;
      end;
    end;
  end;  
  RecordAction_rlGCLOK = res;
  RETURN;
END;

global
updating procedure SalesmanStats_IVCashVc(record IVCashVc IVCashp,record IVCashVc IVCash2p,Boolean iv2f)
BEGIN
  Integer i,m;
  Integer rwcnt;
  record IVCashVc IVCash2r;
  row IVCashVc IVCashrw;
  Boolean negf,rnegf;
  val t,t2;
  val basesum;
  val gps;
  val bv;
  val sumprice,temp;
  val pri;
  string 255 cust;
  Boolean cashcredit;
  Boolean sumpriceflag;
  val sum4,sumprice2,basesum2,bv2,gps2;
  val icsbasesum;
  val icsgps;
  val icsprice;
  val ts,tsum;
  record TaxMatrixVc TMr;

  if (iv2f) then begin
    if ((IVCash2p.OKFlag!=0) and (IVCashp.OKFlag!=0)) then begin
      if (IVCashp.Invalid==IVCash2p.Invalid) and (IVCashp.Invalid==1) then begin goto LSalesmanStats_IVCashVc; end;
      if (IVCashp.SalesMan==IVCash2p.SalesMan) then begin goto LSalesmanStats_IVCashVc; end;
    end;
  end;
  if (IVCashp.Invalid!=0) then begin
    if (negf) then begin
      negf = false; 
    end else  begin
      negf = true;
    end;
  end;
  rnegf = negf;
  if (blankdate(IVCashp.TransDate)) then begin goto LSalesmanStats_IVCashVc; end;
  rwcnt = MatRowCnt(IVCashp);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(IVCashp,i,IVCashrw);
    if (IVCashrw.stp==kInvoiceRowTypeNormal) or (IVCashrw.stp==kInvoiceRowTypeStructuredItemComponent) or (IVCashrw.stp==11) then begin
      t = MulRateToBase1(IVCashp.CurncyCode,IVCashrw.Sum,IVCashp.FrRate,IVCashp.ToRateB1,IVCashp.ToRateB2,IVCashp.BaseRate1,IVCashp.BaseRate2,DefaultCurRoundOff);
      UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
      FindSalesExVat(TMr,IVCashrw.VATCode,t,IVCashp.InclVAT,IVCashp.NoTAXonVAT,basesum);
      gps = gps + IVCashrw.rowGP;
      temp = IVCashrw.Quant*IVCashrw.Price;
      if (temp==0) then begin temp = IVCashrw.Sum; end;
      icsprice = temp;
      icsbasesum = basesum;
      icsgps = IVCashrw.rowGP;
      rnegf = negf;
      if (iv2f) then begin
        if ((IVCash2p.OKFlag!=0) and (IVCashp.OKFlag!=0)) then begin
          if (IVCashp.Invalid==IVCash2p.Invalid) then begin
            SalesmanArtStatUp(IVCashrw.ArtCode,IVCash2p.SalesMan,IVCashp.TransDate,IVCashrw.Quant,basesum,IVCashrw.rowGP,temp,!rnegf,icsbasesum,icsgps,icsprice);      
          end;
        end;
      end;
      SalesmanArtStatUp(IVCashrw.ArtCode,IVCashp.SalesMan,IVCashp.TransDate,IVCashrw.Quant,basesum,IVCashrw.rowGP,temp,rnegf,icsbasesum,icsgps,icsprice);      
      sumprice = sumprice + temp;
    end;
  end;
  t = 0;
  t2 = IVCashp.Sum1;
  if (IVCashp.InclVAT!=0) then begin
    t2 = IVCashp.Sum4 - IVCashp.Sum3;
  end;
  basesum = MulRateToBase1(IVCashp.CurncyCode,t2,IVCashp.FrRate,IVCashp.ToRateB1,IVCashp.ToRateB2,IVCashp.BaseRate1,IVCashp.BaseRate2,DefaultCurRoundOff);
  bv = MulRateToBase1(IVCashp.CurncyCode,IVCashp.Sum4,IVCashp.FrRate,IVCashp.ToRateB1,IVCashp.ToRateB2,IVCashp.BaseRate1,IVCashp.BaseRate2,DefaultCurRoundOff);
  t = IVCashp.Sum4;
  bv = blankval;
  bv2 = blankval;
  if (sumpriceflag==true) then begin sumprice = basesum; end;
  sum4 = IVCashp.Sum4;
  if (iv2f) then begin
    if ((IVCash2p.OKFlag!=0) and (IVCashp.OKFlag!=0)) then begin
      UserStatUp(IVCash2p.SalesMan,IVCash2p.TransDate,basesum,sum4,t,gps,bv,sumprice,!negf);    
    end;
  end;
  UserStatUp(IVCashp.SalesMan,IVCashp.TransDate,basesum,sum4,t,gps,bv,sumprice,negf);      
LSalesmanStats_IVCashVc:;
  RETURN;
END;
