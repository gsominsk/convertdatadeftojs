external function Integer DateGetIntMonth(Date);
external function roundmode SetRoundModeD(Integer);
external function Integer CheckTodoAcess(string,record ActVc,string);
external function val TimeToVal2(Time);
external function string 255 GetMachineGroup(string);
external procedure vTimeDiff(Time,Time,var val);
external function LongInt AddM4Time(Time,LongInt,var Time);
external function LongInt TimeToMinutes(Time);
external procedure ExtractObj(string,var Integer,var string);
external function LongInt ResLen(Date,Date,Time,LongInt,LongInt,Integer);
external function LongInt DateDiff(Date,Date);
external function LongInt RTLen(Date,Date,Time,LongInt,LongInt);
remote function val HALGetIntStockQty(string,string,Date);

function LongInt GetColourOfRecipe(string recipe)
BEGIN
  record RecVc Recr;
  LongInt res;
  
  res = 0;
  Recr.Code = recipe;
  if (ReadFirstMain(Recr,1,true)) then begin
    res = Recr.ResMgrColNr;
  end;
  GetColourOfRecipe = res;
  RETURN;
END;

procedure AddActDispRecToHandle(LongInt sernr,LongInt vcnr,LongInt spos,LongInt actlen,LongInt colnr,LongInt compno,string label,Area adhp)
BEGIN
  AddLongToArea(sernr,adhp);
  AddLongToArea(vcnr,adhp);
  AddLongToArea(spos,adhp);
  AddLongToArea(actlen,adhp);
  AddLongToArea(colnr,adhp);    
  AddLongToArea(compno,adhp);
  AddStringToArea(label,adhp);
  RETURN;
END;

procedure AddToNonWorkList(var array Date daya,var array Time fra,var array val hoursa,var array Integer cola,var Integer rwcnt,Date dayp,Time frtp,val hours,Integer col)
begin
  daya[rwcnt] = dayp;
  fra[rwcnt] = frtp;
  hoursa[rwcnt] = hours;
  cola[rwcnt] = col;
  rwcnt = rwcnt + 1;
  return;
end;

procedure CopyMachineHoursChangesToMachineHours(record MachineHoursChangesVc MHCr,var record MachineHoursVc resMHr)
begin
  resMHr.MonStart = MHCr.MonStart;
  resMHr.MonEnd = MHCr.MonEnd;
  resMHr.TueStart = MHCr.TueStart;
  resMHr.TueEnd = MHCr.TueEnd;
  resMHr.WedStart = MHCr.WedStart;
  resMHr.WedEnd = MHCr.WedEnd;
  resMHr.ThuStart = MHCr.ThuStart;
  resMHr.ThuEnd = MHCr.ThuEnd;
  resMHr.FriStart = MHCr.FriStart;
  resMHr.FriEnd = MHCr.FriEnd;
  resMHr.SatStart = MHCr.SatStart;
  resMHr.SatEnd = MHCr.SatEnd;
  resMHr.SunStart = MHCr.SunStart;
  resMHr.SunEnd = MHCr.SunEnd;
  resMHr.ResMgrColNr = MHCr.ResMgrColNr;
  return;
end;

function Boolean FindMachineHourChanges(string machinegroup,string machine,Date dat,var record MachineHoursVc resMHr)
begin
  Boolean res,found,testf;
  record MachineHoursChangesVc MHCr;
  
  found = true;
  MHCr.Code = machinegroup;
  while (LoopBackKey("Code",MHCr,1,found)) begin
    if (MHCr.Code!=machinegroup) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(machine)) then begin
        if (MHCr.InventoryNr!=machine) then begin testf = false; end;
      end;
      if (testf) then begin
        if (nonblankdate(MHCr.EndDate)) then begin
          if (DateInRange(dat,MHCr.StartDate,MHCr.EndDate)) then begin
            res = true;
            CopyMachineHoursChangesToMachineHours(MHCr,resMHr);
            goto LFindMachineHourChanges;
          end;
        end else begin
          if (dat>=MHCr.StartDate) then begin
            res = true;
            CopyMachineHoursChangesToMachineHours(MHCr,resMHr);
            goto LFindMachineHourChanges;
          end;
        end;
      end;
    end;
  end;
LFindMachineHourChanges:;
  if (res==false) then begin
    if (nonblank(machine)) then begin
      res = FindMachineHourChanges(resMHr.Code,"",dat,resMHr);
    end;
  end;
  FindMachineHourChanges = res;
  return;
end;


procedure GetTimes(var record MachineHoursVc MHp,string machine,Date dat,Integer datid,var Time frtmp,var val totmp,var Integer colnr)
begin
  record MachineHoursVc MHr;
  
  RecordCopy(MHr,MHp);
  FindMachineHourChanges(MHr.Code,machine,dat,MHr);
  totmp = 0;
  
  colnr = MHr.ResMgrColNr;
  switch (datid) begin
    case 1:
      frtmp = MHr.MonStart;
      totmp = MHr.MonEnd;
    case 2:
      frtmp = MHr.TueStart;
      totmp = MHr.TueEnd;
    case 3:
      frtmp = MHr.WedStart;
      totmp = MHr.WedEnd;
    case 4:
      frtmp = MHr.ThuStart;
      totmp = MHr.ThuEnd;
    case 5:
      frtmp = MHr.FriStart;
      totmp = MHr.FriEnd;
    case 6:
      frtmp = MHr.SatStart;
      totmp = MHr.SatEnd;
    case 7:
      frtmp = MHr.SunStart;
      totmp = MHr.SunEnd;
  end;
  return;
end;

procedure BuildNonWorkTime(var array Date daya,var array Time fra,var array val hoursa,var array Integer cola,var Integer rwcnt,
                           string machine,date dp,LongInt maxdays)
begin
  record MachineHoursVc MHr;
  string 255 tstr;
  date dat,dat2;
  LongInt i;
  Integer datid,colnr;
  Boolean res;
  Time frtm,timr,timr2,bltim;
  LongInt days;
  val diff,totm,tol;
  
  dat = CurrentDate;
  dat2 = AddDay(dp,maxdays);
  days = DateDiff(dat2,dat);
  tstr = GetMachineGroup(machine);
  MHr.Code = tstr;
  res = ReadFirstKey("Code",MHr,1,true);
  if (res==false) then begin goto LBuildNonWorkTime; end;
  
  for (i=0;i<days;i=i+1) begin
    datid = GetDateID(dat);
    frtm = bltim;
    totm = 0;
    if (res) then begin
      GetTimes(MHr,machine,dat,datid,frtm,totm,colnr);
    end;
    if (totm>=0) then begin
      timr = bltim;
      vTimeDiff(timr,frtm,diff);
      tol = Round(diff,SetRoundModeD(1));
      if (tol<=0) then begin
        tol = 0;
      end;
      AddToNonWorkList(daya,fra,hoursa,cola,rwcnt,dat,timr,tol,colnr);
      if (AddM4Time(frtm,totm*60.00,timr)==0) then begin // Not beyond 24:00
        timr2 = bltim;
        timr2 = AddHours(timr2,23);
        timr2 = AddMinutes(timr2,59);
        timr2 = AddSeconds(timr2,59);
        vTimeDiff(timr,timr2,diff);
        tol = Round(diff,SetRoundModeD(1));
        if (tol<=0) then begin
          tol = 0;
        end;
//Trace("bltim" & bltim," frtm " & frtm & " totm " & totm & " timr " & timr);      
        AddToNonWorkList(daya,fra,hoursa,cola,rwcnt,dat,timr,tol,colnr);
      end;
    end;
    dat = AddDay(dat,1);
  end;
LBuildNonWorkTime:;
  return;
end;

procedure AddNonWorkTime(var array Date daya,var array Time fra,var array val hoursa,var array Integer cola,Integer rwcnt,
                         Date startdatp,Time starttimp,var date enddatp,var Time endtimp)
begin
  Integer i;
  LongInt extradays,lastextradays;
  Date prevdat;
  val prevtim;
  LongInt lasth,lastexd;
  Integer lasti; 
  Time lastendtimp;
  val lastprevtim;
  
  lasti = -1;
  for (i=0;i<rwcnt;i=i+1) begin
    if (DateInRange(daya[i],startdatp,enddatp)) then begin
      if (prevdat==daya[i]) then begin
        lastendtimp = endtimp;
        lastprevtim = prevtim;
//StopAlert("1.endtimp " & endtimp &  " hoursa[i] "  & hoursa[i]);  
        extradays = AddM4Time(endtimp,hoursa[i]*60,endtimp);//what with last day??
        if ((prevtim+hoursa[i])>=24) then begin
          enddatp = AddDay(enddatp,extradays);
          lastexd = extradays;
        end;
        lasth = hoursa[i];
        lasti = i;
        lastextradays = extradays;
//StopAlert("2.endtimp " & endtimp &  " enddatp "  & enddatp);  
      end else begin
//StopAlert("3.endtimp " & endtimp &  " enddatp "  & enddatp & " starttimp " & starttimp & " hoursa[i] " & hoursa[i]);  
        if ((TimeToVal2(starttimp)<hoursa[i]) or (nonblankdate(prevdat))) then begin
          extradays = AddM4Time(endtimp,hoursa[i]*60,endtimp);
          enddatp = AddDay(enddatp,extradays);
//StopAlert("4.endtimp " & endtimp &  " enddatp "  & enddatp & " starttimp " & starttimp);  
        end else begin
        end;
        prevdat = daya[i];
        prevtim = TimeToVal2(endtimp);
      end;
    end;
  end;

  if (lasti>=0) then begin
    if (GetHour(fra[lasti])>GetHour(lastendtimp)) then begin//GetHour(fra[i])<GetHour(endtimp)
      extradays = AddM4Time(endtimp,-hoursa[lasti]*60,endtimp);//what with last day??
//StopAlert("endtimp " & endtimp);  
      if ((lastprevtim+hoursa[lasti])>=24) then begin
        enddatp = AddDay(enddatp,-lastextradays);
      end;
//StopAlert("5.endtimp " & endtimp &  " enddatp "  & enddatp);  
    end;
  end;
  return;
end;

global
function LongInt Do_ProdOrdersInDay(string uscode,string item,Date dp,LongInt maxdays,Integer dmode,Area adhp,var LongInt readrecs,var LongInt usedrecs)
BEGIN
  record ProdOrderVc ProdOr;
  Boolean TrHs;
  Boolean testf;
  LongInt uscnt;
  LongInt res;
  LongInt actpos;
  Date xdate;
  Time xtime;
  Date oldxdate;
  Time oldxtime;
  LongInt minutes;
  LongInt extradays;
  LongInt actlen;
  LongInt clr;
  LongInt adoff;
  array Date daya;
  array Time fra;
  array val hoursa;
  array Integer cola;
  Integer rwcnt,i;
  LongInt compno;

  uscnt = 0;
  clr = 2;
  adoff = GetAreaLength(adhp);
  AddLongToArea(uscnt,adhp);    
  AddLongToArea(kResourceMonthProdOrder,adhp);  //13, prod order
  AddStringToArea(uscode,adhp);    
  compno = CurrentCompany;
  ProdOr.Machine = uscode;
  TrHs = true;
  xdate = CurrentDate;
  
//  xtime = AddHours(xtime,-GetHour(xtime)+0); 
//  xtime = AddMinutes(xtime,-GetMinute(xtime)+0); 
//  xtime = AddSeconds(xtime,-GetSecond(xtime)+0); 

  if (nonblank(ProdOr.Machine)) then begin
    BuildNonWorkTime(daya,fra,hoursa,cola,rwcnt,ProdOr.Machine,dp,maxdays);
  end;

  while (LoopKey("Queue",ProdOr,2,TrHs)) begin
    readrecs = readrecs + 1;
    testf = true;
    if (ProdOr.Machine!=uscode) then begin TrHs = false; end;
    if (TrHs==false) then begin testf = false; end;    
    if (ProdOr.StatusFlag > 2) then begin testf = false; end;
//    if (itemcheckhere) then begin testf = false; end;
    if (testf) then begin
      usedrecs = usedrecs + 1;
      oldxdate = xdate;
      oldxtime = xtime;

      actpos = ResLen(dp,xdate,xtime,maxdays,0,dmode);
      minutes = TimeToMinutes(ProdOr.DurTime);
      extradays = AddM4Time(xtime,minutes,xtime);
      if (ProdOr.DurDays>0) then begin extradays = extradays + ProdOr.DurDays; end;
      xdate = AddDay(xdate,extradays);

      AddNonWorkTime(daya,fra,hoursa,cola,rwcnt,oldxdate,oldxtime,xdate,xtime);
      actlen = ResLen(dp,xdate,xtime,maxdays,1,dmode);
      if (minutes>0) then begin
        if (actpos==actlen) then begin
          actlen = actlen + 1; // Just to avoid empty, vierd looking, bars.
        end;
      end;
      clr = GetColourOfRecipe(ProdOr.Recipe);
      AddActDispRecToHandle(ProdOr.SerNr,kResourceProdOrderVc,actpos,actlen,clr,compno,"",adhp);
      uscnt = uscnt + 1;
    end;
  end;  

  for (i=0;i<rwcnt;i=i+1) begin
      actpos = ResLen(dp,daya[i],fra[i],maxdays,0,dmode);

      minutes = hoursa[i] * 60.00;
      extradays = AddM4Time(fra[i],minutes,xtime);
      xdate = AddDay(daya[i],extradays);
      actlen = ResLen(dp,xdate,xtime,maxdays,1,dmode);
      clr = cola[i];
      AddActDispRecToHandle(-1,-1,actpos,actlen,clr,compno,"",adhp);
      uscnt = uscnt + 1;
  end;  

  PutLongInArea(uscnt,adhp,adoff);
  res = 1;
  Do_ProdOrdersInDay = res;
  RETURN;
END;

global
function LongInt Do_ProdOpersInDay(string uscode,string item,Date dp,LongInt maxdays,Integer dmode,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  LongInt res;
  Boolean found;
  record ProdOperationVc ProdOpr;
  record ProdVc Prodr;
  Integer clr,compno;
  LongInt uscnt,adoff;
  LongInt startpos,endpos;
  array Date daya;
  array Time fra;
  array val hoursa;
  array Integer cola;
  Integer rwcnt,i;
  LongInt minutes;
  LongInt extradays;
  Date xdate;
  Time xtime;

  uscnt = 0;
  clr = 2;
  adoff = GetAreaLength(adhp);
  AddLongToArea(uscnt,adhp);    
  AddLongToArea(kResourceMonthProdOper,adhp);  //12,prod opers
  AddStringToArea(uscode,adhp);    
  compno = CurrentCompany;
  found = true;
  ProdOpr.Machine = uscode;
 
   if (nonblank(ProdOpr.Machine)) then begin
    BuildNonWorkTime(daya,fra,hoursa,cola,rwcnt,ProdOpr.Machine,dp,maxdays);
  end;
 
  ProdOpr.PRStatusFlag = kPRStatusStarted;
  ProdOpr.StartDate = dp;
  while (LoopKey("Machine",ProdOpr,3,found)) begin
    readrecs = readrecs + 1;
    if (ProdOpr.Machine!=uscode) then begin found = false; end;
    if (ProdOpr.PRStatusFlag!=kPRStatusStarted) then begin found = false; end;
    if (found) then begin
      usedrecs = usedrecs + 1;

      startpos = ResLen(dp,ProdOpr.StartDate,ProdOpr.StartTime,maxdays,0,dmode);

      AddNonWorkTime(daya,fra,hoursa,cola,rwcnt,ProdOpr.StartDate,ProdOpr.StartTime,ProdOpr.ProdDate,ProdOpr.EndTime);
      endpos = ResLen(dp,ProdOpr.ProdDate,ProdOpr.EndTime,maxdays,1,dmode);
      Prodr.SerNr = ProdOpr.ProdNr;
      if (ReadFirstMain(Prodr,1,true)) then begin end;
      clr = GetColourOfRecipe(Prodr.Recepy);
      AddActDispRecToHandle(ProdOpr.SerNr,kResourceProdOperationVc,startpos,endpos,clr,compno,"",adhp);
      uscnt = uscnt + 1;
    end;
  end;
  
  for (i=0;i<rwcnt;i=i+1) begin
    startpos = ResLen(dp,daya[i],fra[i],maxdays,0,dmode);

    minutes = hoursa[i] * 60.00;
    extradays = AddM4Time(fra[i],minutes,xtime);
    xdate = AddDay(daya[i],extradays);
    endpos = ResLen(dp,xdate,xtime,maxdays,1,dmode);
    clr = cola[i];
    AddActDispRecToHandle(-1,-1,startpos,endpos,clr,compno,"",adhp);
    uscnt = uscnt + 1;
  end;  

  PutLongInArea(uscnt,adhp,adoff);
  res = 1;
  Do_ProdOpersInDay = res;
  return;
end;

procedure Do_RentResInDay2Ra(string rescode,string location,Date dp,LongInt maxdays,Array LongInt ra,Time chkin,Time chkout,var LongInt readrecs,var LongInt usedrecs)
BEGIN
  record RentResBookVc RentBookr;
  Boolean TrHs;
  string 255 ckey;
  Boolean testf;
  LongInt daycnt;
  LongInt startpos;
  LongInt endpos;
  LongInt ddif;
  Integer lenclass;
  LongInt i;
  Boolean skipres;
  Date blankd;
  
  daycnt = 0;
  ckey = "AgreeItemStartTime";
  lenclass = 4;
LDo_RentResInDay2RaBEGIN:;
  ResetLoop(RentBookr);
  RentBookr.Code = rescode;
  RentBookr.LengthClass = lenclass;
  RentBookr.TransDate = dp;
  switch (lenclass) begin
    case 4: RentBookr.TransDate = blankd;
    case 3: RentBookr.TransDate = AddDay(RentBookr.TransDate,-366);
    case 2: RentBookr.TransDate = AddDay(RentBookr.TransDate,-31);
    case 1: RentBookr.TransDate = AddDay(RentBookr.TransDate,-7);
    case 0: ;
  end;
  TrHs = true;
  while (LoopKey(ckey,RentBookr,3,TrHs)) begin
    readrecs = readrecs + 1;
    ddif = DateDiff(RentBookr.TransDate,dp);
    if (ddif>=maxdays) then begin TrHs = false; end;
    if (RentBookr.LengthClass!=lenclass) then begin TrHs = false; end;
    if (RentBookr.Code!=rescode) then begin TrHs = false; end;
    testf = false;
    if (TrHs) then begin
      testf = true;
      if (nonblankdate(RentBookr.EndDate)) then begin
        if (RentBookr.EndDate<dp) then begin testf = false; end;
      end;
      if (nonblank(location)) then begin
        if (RentBookr.Location!=location) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        usedrecs = usedrecs + 1;
        skipres = false;
//        if (RentBookr.
        if (skipres) then begin goto L66Do_RentResInDay2Ra; end;
        startpos = RTLen(dp,RentBookr.TransDate,RentBookr.StartTime,maxdays,0);
        endpos = RTLen(dp,RentBookr.EndDate,RentBookr.EndTime,maxdays,1);
        if (blankdate(RentBookr.EndDate)) then begin
          endpos = maxdays;
        end;
        if (nonblank(RentBookr.StartTime)) then begin
          if (RentBookr.StartTime<=chkin) then begin startpos = startpos - 1; end;
        end;
        if (nonblank(RentBookr.EndTime)) then begin
          if (RentBookr.EndTime<=chkout) then begin endpos = endpos - 1; end;
        end;
        for (i=startpos;i<=endpos;i=i+1) begin
          if ((i>=0) and (i<maxdays)) then begin
            ra[i] = ra[i] - RentBookr.OpenRentQuant;
//            rap = (LongInt*)PtrAdd(ra,i*4);
//            *rap = (*rap)-1;
          end;
        end;
L66Do_RentResInDay2Ra:;
      end;
    end;
  end;
  lenclass = lenclass - 1;
  if (lenclass>=0) then begin
    goto LDo_RentResInDay2RaBEGIN;
  end;
  RETURN;  
END;

global
function LongInt Do_ProjectInDay2(string uscode,Date dp,LongInt maxdays,Integer dmode,Area adhp,string prcode,Integer mode,Integer calltime,string curuser,var LongInt readrecs,var LongInt usedrecs,Boolean showprcodef) //,Integer calltime,Integer dmode)
BEGIN
  record ActVc Actr;
  Boolean TrHs;
  string 255 ckey,tstr,user;
  Boolean testf;
  LongInt adractsernr;
  LongInt adrvcnr;  // 0 - ActVc, 1 - JobVc, 2 - RentResVc, 3 - ProdOrderVc, 4 - PRVc, 5 - ProdOperationVc
  LongInt adrStartPos;
  LongInt adractlen;
  LongInt adrcolnr;
  LongInt textcnt;
  LongInt adcnt;
  LongInt ppadcnt;
  LongInt adoff;
  record ActTypeVc atr;
  record ActTypeGrVc atgr;
  LongInt uscnt;
  Integer pos;
  Integer lenclass;
  LongInt startpos;
  LongInt endpos;
  LongInt ddif;
  LongInt colnr;
  Date blankd;
// calltime; // 0 = no show, 1 = time, 2 = profile
  LongInt compno;
  
  ppadcnt = 0;
  adcnt = 0;
  uscnt = 0;
  compno = CurrentCompany;
//  stopalert("test");
  
  textcnt = 0;
  pos = 0;
  uscnt = 0;
//  ExtractObj(uscode,pos,user); // ??
//  if (blank(user)) then begin goto LDo_ProjectInDay2; end;
  textcnt = 0;
  adcnt = 0;
  ppadcnt = 0;
  adcnt = 0;
  adoff = GetAreaLength(adhp);
  AddLongToArea(adcnt,adhp);
  AddLongToArea(kResourceMonthUser,adhp);  //7, user
  if (((dmode==1) or (dmode==3)) and (calltime==1)) then begin
    tstr = "";
    AddStringToArea(tstr,adhp);  
  end else begin
    if (showprcodef) then begin
      AddStringToArea(uscode & "  " & prcode,adhp);  
    end else begin
      AddStringToArea(uscode,adhp);  
    end;
  end;
  lenclass = 4;
  ckey = "CalUserMain:" & uscode;
LDo_ProjectInDay2BEGIN:;
  ResetLoop(Actr);
  Actr.PRCode = prcode;
  Actr.TransDate = dp;
  switch (lenclass) begin
    case 4: Actr.TransDate = blankd;
    case 3: Actr.TransDate = AddDay(Actr.TransDate,-366);
    case 2: Actr.TransDate = AddDay(Actr.TransDate,-31);
    case 1: Actr.TransDate = AddDay(Actr.TransDate,-7);
    case 0: ;
  end;
  Actr.LengthClass = lenclass;
  Actr.TodoFlag = 0;
  TrHs = true;
  while (LoopKey(ckey,Actr,3,TrHs)) begin
    readrecs = readrecs + 1;
    if (Actr.TodoFlag!=0) then begin TrHs = false; end;
    if (Actr.LengthClass!=lenclass) then begin TrHs = false; end;
    ddif = DateDiff(Actr.TransDate,dp);
    if (ddif>=maxdays) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
      if (blankdate(Actr.EndDate)) then begin
        if (Actr.TransDate<dp) then begin testf = false; end;
      end else begin
        ddif = DateDiff(Actr.TransDate,dp);
        if (Actr.EndDate<dp) then begin testf = false; end;
      end;
      
//      StopAlert("mode " & mode & " actr.prcode " & Actr.PRCode & " prcode " & prcode);
      if ((mode==1) and (Actr.PRCode!=prcode)) then begin
        testf = false;
      end;
      if (Actr.CalTimeFlag==0) then begin testf = false; end;
      if (Actr.Invalid!=0) then begin testf = false; end;
      if (Actr.PrivateFlag!=0) then begin
        tstr = curuser;
        if (SetInSet(tstr,Actr.MainPersons)==false) then begin testf = false; end;
      end;
      if (testf) then begin
        testf = CheckTodoAcess(uscode,Actr,curuser)!=kAccessLevelNone;
      end;
      if (testf) then begin
        usedrecs = usedrecs + 1;
        colnr = 1;
        adrcolnr = 1;
        adrvcnr = kResourceActVc;
        atr.Code = Actr.ActType;
        if (ReadFirstMain(atr,1,true)) then begin
          atgr.Code = atr.ActTypeGr;
          if (ReadFirstMain(atgr,1,true)) then begin
            colnr = atgr.CalColNr;
          end;
        end;
        adractsernr = Actr.SerNr;
        if (calltime==2) then begin
          colnr = -colnr;
        end;
        adrcolnr = colnr;
        if (blankdate(Actr.EndDate)) then begin Actr.EndDate = Actr.TransDate; end;

        if ((dmode==0) or (dmode==1)) then begin
          if (GetHour(Actr.StartTime)<=9) then begin 
            Actr.StartTime = AddHours(Actr.StartTime,-GetHour(Actr.StartTime)+0); 
            Actr.StartTime = AddMinutes(Actr.StartTime,-GetMinute(Actr.StartTime)+0); 
          end;
          if (GetHour(Actr.EndTime)>=17) then begin 
            Actr.EndTime = AddHours(Actr.EndTime,-GetHour(Actr.EndTime)+23); 
            Actr.EndTime = AddMinutes(Actr.EndTime,-GetMinute(Actr.EndTime)+59); 
          end;
        end;

        startpos = ResLen(dp,Actr.TransDate,Actr.StartTime,maxdays,0,dmode);
        endpos = ResLen(dp,Actr.EndDate,Actr.EndTime,maxdays,1,dmode);
        adrStartPos = startpos;
        adractlen = endpos;

        if ((mode==2) and (Actr.PRCode!=prcode)) then begin
//          adrcolnr = 1;colour is set already above
        end else begin
//          adrcolnr = 2;colour is set already above
        end;
        
        if (Actr.CalTimeFlag==calltime) then begin
          AddLongToArea(adractsernr,adhp);
          AddLongToArea(adrvcnr,adhp);
          AddLongToArea(adrStartPos,adhp);
          AddLongToArea(adractlen,adhp);
          AddLongToArea(adrcolnr,adhp);    
          AddLongToArea(compno,adhp);
          AddStringToArea("",adhp);
          adcnt = adcnt + 1;
        end;
      end;
    end;
  end;
  lenclass = lenclass - 1;
  if (lenclass>=0) then begin goto LDo_ProjectInDay2BEGIN; end;
  PutLongInArea(adcnt,adhp,adoff);
  uscnt = uscnt + 1;
LDo_ProjectInDay2:;
  Do_ProjectInDay2 = uscnt;
  return;
end;

global
function LongInt Do_ProjectInDay(string uscode,Date dp,LongInt maxdays,Integer dmode,Area adhp,string prcode,Integer mode,Integer calltime,string curuser,var LongInt readrecs,var LongInt usedrecs) //,Integer calltime,Integer dmode)
begin
  Do_ProjectInDay = Do_ProjectInDay2(uscode,dp,maxdays,dmode,adhp,prcode,mode,calltime,curuser,readrecs,usedrecs,false);
  return;
end;

global
function Boolean ExplodeRentIN(var record RentINVc RentINr,var array string incode,var array val outqty,var Integer cnt)
begin
  record RecVc Recr;
  row RecVc Recrw;
  Integer rwcnt,i,j;
  Boolean foundf;
  Boolean res;
  
  Recr.Code = RentINr.IncludeRecepy;
  if (ReadFirstMain(Recr,1,true)) then begin
    rwcnt = MatRowCnt(Recr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Recr,i,Recrw);
      if (Recrw.OutQty>0) then begin
        foundf = false;
        for (j=0;j<cnt;j=j+1) begin
          if (incode[j]==Recrw.Item) then begin
            outqty[j] = outqty[j] + Recrw.OutQty;
            j = cnt;
            foundf = true;
          end;
        end;
        if (foundf==false) then begin
          incode[cnt] = Recrw.Item;
          outqty[cnt] = Recrw.OutQty;
          cnt = cnt + 1;
        end;
        res = true;
      end;
    end;
  end;
  ExplodeRentIN = res;
  return;
end;

global
procedure SetupDayMatrix(var Array LongInt ra,var Array LongInt ra2,Date dp,LongInt maxdays,string restype,string location,Time chkin,Time chkout,var LongInt readrecs,var LongInt usedrecs)
begin
  record RentINVc RentINr;
  Date todat;
  LongInt i,j;
  val instock;
  Boolean explodef;
  array string 20 incode;
  array val outqty;
  Array LongInt lra;
  Integer cnt;

  explodef = false;
  RentINr.Code = restype;
  RentINr.SerialNr = "";
  if (ReadFirstMain(RentINr,2,true)) then begin
    if ((RentINr.RecepyItem!=0) and (nonblank(RentINr.IncludeRecepy))) then begin
      explodef = true;
    end;
  end;
  if (explodef) then begin
    explodef = ExplodeRentIN(RentINr,incode,outqty,cnt);
  end;
  if (explodef) then begin
    for (i=0;i<maxdays;i=i+1) begin
      ra[i] = 9999999999;
      ra2[i] = 0;
    end;  
    for (j=0;j<cnt;j=j+1) begin
      for (i=0;i<maxdays;i=i+1) begin
        lra[i] = 9999999999;
      end;  
      todat = dp;
      for (i=0;i<maxdays;i=i+1) begin
        instock = HALGetIntStockQty(incode[j],location,todat);
        todat = AddDay(todat,1);
        if (instock<lra[i]) then begin
          lra[i] = instock;
        end;
      end;  
      Do_RentResInDay2Ra(incode[j],location,dp,maxdays,lra,chkin,chkout,readrecs,usedrecs);
      for (i=0;i<maxdays;i=i+1) begin
        instock = Round(lra[i] / outqty[j],SetRoundModeD(1));
        if (ra[i]>instock) then begin
          ra[i] = instock;
        end;
      end;
    end;
  end else begin
    todat = dp;
    for (i=0;i<maxdays;i=i+1) begin
      instock = HALGetIntStockQty(restype,location,todat);
      todat = AddDay(todat,1);
      ra[i] = instock;
      ra2[i] = 0;
    end;  
    Do_RentResInDay2Ra(restype,location,dp,maxdays,ra,chkin,chkout,readrecs,usedrecs);
  end;
  return;
end;

procedure AddToPersonsArray(string persons,var Array string apersons,var Integer acnt)
begin
  string 255 user;
  Integer pos,i;
  
  pos = 0;
	ExtractObj(persons,pos,user);
	while (nonblank(user)) begin
	  for (i=0;i<acnt;i=i+1) begin
	    if (apersons[i]==user) then begin
	      goto LPEROSNINARRAY;
	    end;	    
	  end;
	  apersons[acnt] = user;
	  acnt = acnt + 1;
LPEROSNINARRAY:;	  
  	ExtractObj(persons,pos,user);
	end;
  return;
end;

global
procedure Do_FindPersonsInAssetsActivities(string asset,string acttype,Date startdate,LongInt maxdays,Integer calltime,var Array string apersons,var Integer acnt,var LongInt readrecs,var LongInt usedrecs)
BEGIN
  record ActVc Actr;
  Boolean TrHs,testf;
  Integer lenclass;
  Integer changing;
  string 255 tstr;
  Integer i;
  Date blankd;
  LongInt ddif;
// calltime; // 0 = no show, 1 = time, 2 = profile
  
  lenclass = 4;
  while (lenclass>=0) begin
	  ResetLoop(Actr);
	  Actr.InventoryNr = asset;
	  Actr.TodoFlag = 0;
	  Actr.TransDate = startdate;
	  switch (lenclass) begin
	    case 4: Actr.TransDate = blankd;
	    case 3: Actr.TransDate = AddDay(Actr.TransDate,-366);
	    case 2: Actr.TransDate = AddDay(Actr.TransDate,-31);
	    case 1: Actr.TransDate = AddDay(Actr.TransDate,-7);
	    case 0: ;
	  end;
	  Actr.LengthClass = lenclass;

	  TrHs = true;
	  while (LoopKey("InventoryNr",Actr,3,TrHs)) begin
	    readrecs = readrecs + 1;
	    if (Actr.InventoryNr!=asset) then begin TrHs = false; end;
	    if (Actr.TodoFlag!=0) then begin TrHs = false; end;
	    if (Actr.LengthClass!=lenclass) then begin TrHs = false; end;
	    ddif = DateDiff(Actr.TransDate,startdate);
	    if (ddif>=maxdays) then begin TrHs = false; end;
	    if (TrHs) then begin
	      testf = true;
	      if (blankdate(Actr.EndDate)) then begin
	        if (Actr.TransDate<startdate) then begin testf = false; end;
	      end else begin
	        ddif = DateDiff(Actr.TransDate,startdate);
	        if (Actr.EndDate<startdate) then begin testf = false; end;
	      end;      
	      if (Actr.CalTimeFlag==0) then begin testf = false; end;
	      if (Actr.Invalid!=0) then begin testf = false; end;
	      if (Actr.PrivateFlag!=0) then begin testf = false; end;
	      if (Actr.CalTimeFlag!=calltime) then begin testf = false; end;
	      if (nonblank(acttype)) then begin
  	      if (Actr.ActType!=acttype) then begin testf = false; end;
	      end;
	      if (testf) then begin
	        usedrecs = usedrecs + 1;
	        AddToPersonsArray(Actr.MainPersons,apersons,acnt);
	        AddToPersonsArray(Actr.CCPersons,apersons,acnt);
	      end;
	    end;
	  end;
	  lenclass = lenclass - 1;
	end;

  changing = 1;
  while (changing==1) begin
    changing = 0;
    for (i=0;i<(acnt-1);i=i+1) begin
      if (apersons[i]>apersons[i+1]) then begin
        changing = 1;
        tstr = apersons[i];
        apersons[i] = apersons[i+1];
        apersons[i+1] = tstr;
      end;
    end;
  end;
  return;
end;

global
function LongInt Do_ActsInDay_Assests(string asset,string acttype,string user,Date startdate,LongInt maxdays,Integer dmode,Integer calltime,var Area adhp,string curuser,var LongInt readrecs,var LongInt usedrecs)
BEGIN
  record ActVc Actr;
  record ActTypeVc ActTyper;
  record ActTypeGrVc ATGr;
  Boolean TrHs,testf;
  Integer lenclass;
  Date blankd;
  LongInt ddif;
  LongInt compno;
  LongInt startpos;
  LongInt actlen;
  LongInt colnr;
  LongInt actcnt;
// calltime; // 0 = no show, 1 = time, 2 = profile
  
  actcnt = 0;
  lenclass = 4;
  compno = CurrentCompany;
LDo_ActsInDay_AssestsBEGIN:;
  ResetLoop(Actr);
  Actr.InventoryNr = asset;
  Actr.TodoFlag = 0;
  Actr.TransDate = startdate;
  switch (lenclass) begin
    case 4: Actr.TransDate = blankd;
    case 3: Actr.TransDate = AddDay(Actr.TransDate,-366);
    case 2: Actr.TransDate = AddDay(Actr.TransDate,-31);
    case 1: Actr.TransDate = AddDay(Actr.TransDate,-7);
    case 0: ;
  end;
  Actr.LengthClass = lenclass;

  TrHs = true;
  while (LoopKey("InventoryNr",Actr,3,TrHs)) begin
    readrecs = readrecs + 1;
    if (Actr.InventoryNr!=asset) then begin TrHs = false; end;
    if (Actr.TodoFlag!=0) then begin TrHs = false; end;
    if (Actr.LengthClass!=lenclass) then begin TrHs = false; end;
    ddif = DateDiff(Actr.TransDate,startdate);
    if (ddif>=maxdays) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
      if (blankdate(Actr.EndDate)) then begin
        if (Actr.TransDate<startdate) then begin testf = false; end;
      end else begin
        ddif = DateDiff(Actr.TransDate,startdate);
        if (Actr.EndDate<startdate) then begin testf = false; end;
      end;      
      if (Actr.CalTimeFlag==0) then begin testf = false; end;
      if (Actr.Invalid!=0) then begin testf = false; end;
      if (Actr.PrivateFlag!=0) then begin testf = false; end;
      if (Actr.CalTimeFlag!=calltime) then begin testf = false; end;
      if (nonblank(user)) then begin
        if (SetInSet(user,Actr.MainPersons)==false) then begin testf = false; end;
      end;
      if (nonblank(acttype)) then begin
        if (Actr.ActType!=acttype) then begin testf = false; end;
      end;
      if (testf) then begin
        testf = CheckTodoAcess(user,Actr,curuser)!=kAccessLevelNone;
      end;
      if (testf) then begin
        usedrecs = usedrecs + 1;
        colnr = 1;
        ActTyper.Code = Actr.ActType;
        if (ReadFirstMain(ActTyper,1,true)) then begin
          ATGr.Code = ActTyper.ActTypeGr;
          if (ReadFirstMain(ATGr,1,true)) then begin
            colnr = ATGr.CalColNr;
          end;
        end;
        if (calltime==2) then begin
          colnr = -colnr;
        end;
        if (blankdate(Actr.EndDate)) then begin Actr.EndDate = Actr.TransDate; end;

        if ((dmode==0) or (dmode==1)) then begin
          if (GetHour(Actr.StartTime)<=9) then begin 
            Actr.StartTime = AddHours(Actr.StartTime,-GetHour(Actr.StartTime)+0); 
            Actr.StartTime = AddMinutes(Actr.StartTime,-GetMinute(Actr.StartTime)+0); 
          end;
          if (GetHour(Actr.EndTime)>=17) then begin 
            Actr.EndTime = AddHours(Actr.EndTime,-GetHour(Actr.EndTime)+23); 
            Actr.EndTime = AddMinutes(Actr.EndTime,-GetMinute(Actr.EndTime)+59); 
          end;
        end;

        startpos = ResLen(startdate,Actr.TransDate,Actr.StartTime,maxdays,0,dmode);
        actlen = ResLen(startdate,Actr.EndDate,Actr.EndTime,maxdays,1,dmode);
      
        AddActDispRecToHandle(Actr.SerNr,0,startpos,actlen,colnr,compno,"",adhp);
        actcnt = actcnt + 1;
      end;
    end;
  end;
  lenclass = lenclass - 1;
  if (lenclass>=0) then begin goto LDo_ActsInDay_AssestsBEGIN; end;
  Do_ActsInDay_Assests = actcnt;
  return;
end;

global
procedure ResourcePlanner_Resort(string location,LongInt maxdays,
                                 var LongInt rsrtrescnt,Area adhp)
begin
  record ResTypeVc RTr;
  Boolean found,testf;
  LongInt rescnt;
  LongInt rescntoff;

  LongInt adractsernr;
  LongInt adrvcnr;  // 0 - ActVc, 1 - JobVc, 2 - RentResVc, 3 - ProdOrderVc, 4 - PRVc, 5 - ProdOperationVc, 6 - RsrtEventVc
  LongInt adrStartPos;
  LongInt adractlen;
  LongInt adrcolnr;
  LongInt compno;
  Array LongInt aresperday;
  LongInt i;
  
  for (i=0;i<maxdays;i=i+1) begin
    aresperday[i] = 0;
  end;
  rescnt = 0;
  compno = CurrentCompany;
  rescntoff = GetAreaLength(adhp);
  found = true;
  RTr.Sort = 1;
  while (LoopKey("Sort",RTr,1,found)) begin
    if (RTr.Sort!=1) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(location)) then begin
        if (nonblank(RTr.ResLoc)) then begin
          if (RTr.ResLoc!=location) then begin testf = false; end;
        end;
      end;
      if (testf) then begin
        AddLongToArea(rescnt,adhp); 
        AddLongToArea(kResourceMonthResourceResort,adhp);
        AddStringToArea(RTr.Code,adhp);    
//find all available resources and all occupied ones
        for (i=0;i<maxdays;i=i+1) begin
          adractsernr = 0;
          adractlen = 0;
          adrStartPos = aresperday[i];
          
          AddLongToArea(adractsernr,adhp);
          AddLongToArea(kResourceRsrtEventVc,adhp);
          AddLongToArea(adrStartPos,adhp);
          AddLongToArea(adractlen,adhp);
          AddLongToArea(adrcolnr,adhp);    
          AddLongToArea(compno,adhp);
          AddStringToArea("",adhp);
          rescnt = rescnt + 1;
        end;        
        PutLongInArea(rescnt,adhp,rescntoff);
        rsrtrescnt = rsrtrescnt + 1;
      end;
    end;
  end;
  return;
end;

function LongInt RsrtEventsSchedulePerResourcePerDayEveryHour(record RsrtEventScheduleVc RESchr,Date td,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  return;
end;

function LongInt RsrtEventsSchedulePerResourcePerDay(record RsrtEventScheduleVc RESchr,Date td,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  LongInt res;
  Array record RsrtEventVc aREventr;
  Integer are;
  Boolean testf;
  LongInt diff;
  Date sd;
  
  testf = true;
  switch (RESchr.PeriodType) begin
    case kResortEventScheduleDaily:
      if (nonblankdate(RESchr.StartDate)) then begin
        diff = DateDiff(td,RESchr.StartDate);
        if (Mod(diff,RESchr.DayInterval)!=0) then begin
          testf = false;
        end;
      end;
    case kResortEventScheduleWeekly:
      sd = AddDay(RESchr.StartDate,-GetDateId(RESchr.StartDate)+1);
      diff = DateDiff(td,sd);
      if (Mod(diff/7,RESchr.WeekInterval)!=0) then begin
        testf = false;
      end;
      if (testf) then begin
        testf = false;
        if (RESchr.Mon!=0) then begin
          if (GetDateId(td)==1) then begin testf = true; end;
        end;
        if (RESchr.Tue!=0) then begin
          if (GetDateId(td)==2) then begin testf = true; end;
        end;
        if (RESchr.Wed!=0) then begin
          if (GetDateId(td)==3) then begin testf = true; end;
        end;
        if (RESchr.Thu!=0) then begin
          if (GetDateId(td)==4) then begin testf = true; end;
        end;
        if (RESchr.Fri!=0) then begin
          if (GetDateId(td)==5) then begin testf = true; end;
        end;
        if (RESchr.Sat!=0) then begin
          if (GetDateId(td)==6) then begin testf = true; end;
        end;
        if (RESchr.Sun!=0) then begin
          if (GetDateId(td)==7) then begin testf = true; end;
        end;
      end;
    case kResortEventScheduleMonthly:
      sd = AddDay(RESchr.StartDate,-GetDay(RESchr.StartDate)+1);
      diff = DateGetIntMonth(td) - DateGetIntMonth(sd);
      if (Mod(diff,RESchr.MonthInterval)!=0) then begin
        testf = false;
      end;
      switch (RESchr.MonthType) begin
        case 0:
          if (GetDay(td)!=RESchr.DayInterval) then begin
            testf = false;
          end;
        case 1:
          if (GetDateId(td)!=RESchr.WeekDay) then begin testf = false; end;
          if (testf) then begin
            testf = false;
            sd = AddDay(td,-GetDay(td)+1);
            diff = GetDay(td) - GetDay(sd)+1;
            if (diff>7*(RESchr.DayInterval-1)) and (diff<=7*RESchr.DayInterval) then begin
              testf = true;
            end;
          end;
      end;
  end;
  if (testf) then begin
    switch (RESchr.DayType) begin
      case kResortEventScheduleDailyFreqEveryHour:
//        RsrtEventsSchedulePerResourcePerDayEveryHour(RETr,RESchr,td,RepSpec,adhp,readrecs,usedrecs);
      case kResortEventScheduleDailyFreqSpecifiedHours:
//        RsrtEventsSchedulePerResourcePerDaySpecifiedHours(RETr,RESchr,td,RepSpec,adhp,readrecs,usedrecs);
    end;
  end;
  RsrtEventsSchedulePerResourcePerDay = res;
  return;
end;

function LongInt RsrtEventsSchedulePerResourceInPeriod(record RsrtEventScheduleVc RESchr,Date startdate,LongInt amaxdays,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  LongInt res;
  Date td;
  
  td = startdate;
  while (td<AddDay(td,amaxdays)) begin
    RsrtEventsSchedulePerResourcePerDay(RESchr,td,adhp,readrecs,usedrecs);
    td = AddDay(td,1);
  end;

  RsrtEventsSchedulePerResourceInPeriod = res;
  return;
end;

function LongInt FillResourceMonth_RsrtEventsPerResource(record RcVc RepSpec,string rescode,record ResTypeVc ResTyper,string rsrvstatus,Boolean restypef,Date startdate,LongInt amaxdays,Integer dmode,var LongInt avail,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  LongInt res;
  LongInt compno;
  LongInt maxdays;
  LongInt adoff;
  LongInt adcnt;
  Boolean restest;
  record RsrtEventScheduleVc RESr;
  Boolean foundsch,testf;
  
  compno = CurrentCompany;
  restest = false;
  res = 0;
  maxdays = amaxdays;
  if (dmode>=2) then begin
    maxdays = (amaxdays+23) / 24;
  end;
  adoff = GetAreaLength(adhp);
  if (restypef==false) then begin
    AddLongToArea(adcnt,adhp);      
    AddLongToArea(kResourceMonthResource,adhp);  //11,resource ??
    AddStringToArea(rescode,adhp);      
    res = 1;
  end;
  
  foundsch = true;
  RESr.ResCode = rescode;
  while (LoopKey("ActResCode",RESr,1,foundsch)) begin    
    readrecs = readrecs + 1;
    if (RESr.ResCode!=rescode) then begin foundsch = false; end;
    if (foundsch) then begin
      testf = true;
      if (nonblankdate(RESr.StartDate)) then begin
        if (RESr.StartDate>AddDay(startdate,maxdays)) then begin
          testf = false;
        end;
      end;
      if (nonblankdate(RESr.EndDate)) then begin
        if (RESr.EndDate<startdate) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        RsrtEventsSchedulePerResourceInPeriod(RESr,startdate,amaxdays,adhp,readrecs,usedrecs);
        usedrecs = usedrecs + 1;
      end;
    end;
  end;

  
  //Build Rsrt Event
//Do_ReservationsInDay2
  
  if (restypef==false) then begin
//    adcnt = adcnt + AddResourceExist(rescode,startdate,maxdays,adhp,dmode,readrecs,usedrecs);
  end;
  if (restest==false) then begin
    if (restypef==false) then begin
      avail = avail + 1;
    end;
  end;
  if (restypef==false) then begin
    PutLongInArea(adcnt,adhp,adoff);    
  end;
  FillResourceMonth_RsrtEventsPerResource = res;
  return;
end;

global
function LongInt FillResourceMonth_RsrtEvents(record RcVc RepSpec,string resourcetyp,string rsrvstatus,string reslocation,string resclass,Date startdate,LongInt maxdays,
                                              Integer dmode,var LongInt avail,Area adhp,var LongInt readrecs,var LongInt usedrecs)
begin
  record ResVc Resr;
  record ResTypeVc RTr;
  Boolean found;
  string 255 ckey;
  Boolean testf;
  LongInt uscnt;


  found = true;
  while (LoopKey("SortRsrtType",Resr,1,found)) begin
    if (found) then begin
    end;
  end;
  
  uscnt = 0;
  if (nonblank(resourcetyp)) then begin
    RTr.Code = resourcetyp;
    ReadFirstMain(RTr,1,true);
    ckey = "SortRsrtType";
    Resr.Type = resourcetyp;
  end else begin
    ckey = "SortRsrtCode";
    Resr.Code = "";
  end;  
  found = true;
  Resr.Sort = 1;
  while (LoopKey(ckey,Resr,1,found)) begin
    readrecs = readrecs + 1;
    if (Resr.Sort!=1) then begin found = false; end;
    if (nonblank(resourcetyp)) then begin
      if (Resr.Type!=resourcetyp) then begin found = false; end;
    end;
    testf = false;
    if (found) then begin
      testf = true;
      if (Resr.Terminated!=0) then begin testf = false; end;
      if (nonblank(reslocation)) then begin
        if (Resr.ResLoc!=reslocation) then begin testf = false; end;
      end;
      if (nonblank(resclass)) then begin
        if (SetInSet(resclass,Resr.Class)==false) then begin testf = false; end;
      end;
      if (testf) then begin
        usedrecs = usedrecs + 1;
        uscnt = uscnt + FillResourceMonth_RsrtEventsPerResource(RepSpec,Resr.Code,RTr,rsrvstatus,false,startdate,maxdays,dmode,avail,adhp,readrecs,usedrecs);
      end;
    end;
  end;
  if (nonblank(resourcetyp)) then begin
    uscnt = uscnt + FillResourceMonth_RsrtEventsPerResource(RepSpec,Resr.Code,RTr,rsrvstatus,true,startdate,maxdays,dmode,avail,adhp,readrecs,usedrecs);
  end;
  return;
end;
