external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Boolean GetItemStatus(string,string,string,Integer,var val,var val,var val,var val,var val,var val,var val);
external function roundmode SetRoundModeD(Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);
external function Boolean TestArtCode(string,string,record INVc);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating procedure UpdateSerStock(string,string,string,val,val);
external updating procedure DeleteBatchBestBefore(string,string);
external procedure GetCurUser(var record UserVc);

global
updating procedure UpdateSVOSerHist(string incode,string sercode,string vc,LongInt transnr,Date transdp,string cust,string vecode)
BEGIN
  record SVOSerHistVc SVOShr;
  
  if (blank(sercode)) then begin goto LUpdateSVOSerHist; end;
  SVOShr.ItemCode = incode;
  SVOShr.SerialNr = sercode;
  SVOShr.CustCode = cust;
  SVOShr.FileName = vc;
  if (nonblank(vecode)) then begin
    SVOShr.VECode = vecode;
  end else begin
    SVOShr.VECode = "";
  end;
  SVOShr.TransNr = transnr;
  SVOShr.Date = transdp;
  if (RecordStore(SVOShr,false)) then begin
  end;
LUpdateSVOSerHist:;
  RETURN;
END;

global
updating procedure UpdateSVOSerStock(string incode,string inname,string sernr,string secsernr,string altdevid,string cucode,string cuname,
                                     val costp,val salesp,Date soldp,Date warrup,val qtyp,string vecode)
BEGIN
  record SVOSerVc oldSVOSerr;
  record SVOSerVc SVOSerr;
  record INVc INr;
  Boolean found;
  LongInt warlen;
  Boolean soldnow,inf;
  Date blankd;
  
  if (blank(sernr)) then begin goto LUpdateSVOSerStock; end;
  if (blankdate(warrup)) then begin soldnow = true; end;
  inf = ReadFirstItem(incode,INr,true,false);
  if (INr.SerNrf!=1) then begin
    goto LUpdateSVOSerStock;
  end;
  SVOSerr.ItemCode = incode;
  SVOSerr.SerialNr = sernr;
  found = ReadFirstMain(SVOSerr,2,true);
  RecordCopy(oldSVOSerr,SVOSerr);
  if (found==false) then begin
    SVOSerr.ItemCode = incode;
    SVOSerr.ItemName = inname;
    SVOSerr.SerialNr = sernr;
    SVOSerr.SecondarySerialNr = secsernr;
    SVOSerr.AlternateDeviceID = altdevid;
    if (nonblank(vecode)) then begin
      SVOSerr.VECode = vecode;
    end else begin
      SVOSerr.VECode = "";
    end;
    SVOSerr.xInStock = blankval;
    if (soldnow==false) then begin
      SVOSerr.SoldDate = soldp;
      SVOSerr.WarrantyUntil = warrup;
    end;
  end;
  SVOSerr.CustCode = cucode;
  SVOSerr.CustName = cuname;
  if (soldnow) then begin
    SVOSerr.WarrantyUntil = blankd;
    if (inf) then begin
      warlen = INr.WarrantyLength;
      if (warlen>0) then begin
        SVOSerr.WarrantyUntil = soldp;
        SVOSerr.WarrantyUntil = AddMonth(SVOSerr.WarrantyUntil,warlen);
      end;
    end;
    SVOSerr.CostPrice = costp;
    SVOSerr.SalesPrice = salesp;
    SVOSerr.SoldDate = soldp;
  end;
  if (found) then begin
    if (RecordUpdate(oldSVOSerr,SVOSerr,true)==0) then begin
    end;
  end else begin
    if (RecordStore(SVOSerr,false)) then begin
    end;
  end;
LUpdateSVOSerStock:;
  RETURN;
END;

global
updating procedure UpdateSVOSerFromSH(record IVVc IVp,Integer rownr,val qtyp)
BEGIN
  row IVVc IVrw;
  record SHVc SHp;
  row SHVc SHrw;
  Boolean TrHs;
  Integer i,rwcnt;
  val t,absqty,qt,t1,serqty;
  Date blankd;
  string 255 serialnr;
  record SerNrTrackBlock SNrb;
  record INVc INr;
  
  BlockLoad(SNrb);
  t1 = 1;
  qt = 1;
  absqty = qtyp;
  if (absqty<0) then begin
    absqty = -absqty;
  end;
  MatRowGet(IVp,rownr,IVrw);
  TrHs = true;
  SHp.OrderNr = IVp.OrderNr;
  while (LoopKey("OrderKey",SHp,1,TrHs)) begin
    if (SHp.OrderNr!=IVp.OrderNr) then begin TrHs = false; end;
    if (TrHs) then begin
      rwcnt = MatRowCnt(SHp);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SHp,i,SHrw);
        if (SHrw.OrdRow==IVrw.OrdRow) then begin
          t = qtyp/absqty;
          if (qt<=absqty) then begin            
            ReadFirstItem(IVrw.ArtCode,INr,true,false);
            if (SNrb.BulkSerialNos!=0) and (INr.SerNrf==1) then begin
              serqty = blankval;
              serialnr = FirstInRange(SHrw.SerialNr,60);
              while (nonblank(serialnr)) begin
                UpdateSVOSerStock(IVrw.ArtCode,IVrw.Spec,serialnr,"","",IVp.CustCode,IVp.Addr0,
                                  IVrw.BasePrice,IVrw.Price,IVp.TransDate,blankd,t,"");
                UpdateSVOSerHist(IVrw.ArtCode,serialnr,"IVVc",IVp.SerNr,IVp.TransDate,IVp.CustCode,"");
                serqty = serqty + 1;
                serialnr = NextSerialNumber(IVrw.ArtCode,serialnr,SNrb);
                if (serqty>=IVrw.Quant) then begin serialnr = ""; end;
              end;

            end else begin
              if (INr.SerNrf==1) then begin
                UpdateSVOSerStock(IVrw.ArtCode,IVrw.Spec,SHrw.SerialNr,"","",SHp.CustCode,SHp.Addr0,
                                  IVrw.BasePrice,IVrw.Price,IVp.TransDate,blankd,t,"");
                UpdateSVOSerHist(IVrw.ArtCode,SHrw.SerialNr,"IVVc",IVp.SerNr,IVp.TransDate,IVp.CustCode,"");
                qt = qt + t1;
              end;
            end;
          end else begin
            goto LUpdateSVOSerFromSH;
          end;
        end;
      end;
    end;
  end;
LUpdateSVOSerFromSH:;  
  RETURN;
END;

global
function Boolean AllowedToTakeFromThisLoc(record LocationVc Locr)
begin
  record UserVc USr;
  Boolean res;
  
  res = true;
  if (nonblank(Locr.ReservLocAccess)) then begin
    res = false;
    GetCurUser(USr);
    if (SetInSet(Locr.ReservLocAccess,USr.ReservLocAccess)) then begin
      res = true;
    end;
  end;
  AllowedToTakeFromThisLoc = res;
  return;
end;

global
function Boolean AllowedToTakeFromLocation(string location)
begin
  record LocationVc Locr;
  Boolean res;
  
  res = true;
  Locr.Code = location;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = AllowedToTakeFromThisLoc(Locr);
  end;
  AllowedToTakeFromLocation = res;
  return;
end;

global
updating procedure UpdateRecalcStockNeeded(Integer v)
begin
  record MainStockBlock MSb;
  
  BlockLoad(MSb);
  if (MSb.RecalcStockNeeded!=v) then begin
    MSb.RecalcStockNeeded = v;
    BlockStore(MSb);
  end;
  return;
end;

global
function Boolean ItemHistExists(string filename,LongInt nr)
begin  
  Boolean res;
  record ItemHistVc IHr;

  IHr.FileName = filename;
  IHr.TransNr = nr;
  res = ReadFirstKey("FNTransNr",IHr,2,true);
  ItemHistExists = res;
  return;
end;

global
function Boolean ItemHistExistsThrou(string filename,LongInt nr,string location)
begin  
  Boolean res,found;
  record ItemHistVc IHr;

  IHr.FileName = filename;
  IHr.TransNr = nr;
  found = true;  
  while (LoopKey("FNTransNr",IHr,2,found)) begin
    if (IHr.FileName!=filename) then begin found = false; end;
    if (IHr.TransNr!=nr) then begin found = false; end;
    if (found) then begin
      if (IHr.Location==location) and (IHr.Qty>0) then begin
        res = true;
        found = false;
      end;
    end;
  end;
  ItemHistExistsThrou = res;
  return;
end;

global
procedure GetItemStatusSupersessions(string item,string location,string recepy,Integer inclsupersessin,var val stock,var val ord,var val purch,var val unitcoef,var val prodord,var val rsrv,var val inprice)
begin
  record ItemSettingBlock ISb;
  record SupersessionINVc SINr;
  Boolean found;

  BlockLoad(ISb);
  if (ISb.UseSupersessionIN!=0) then begin
    found = true;
    SINr.NewArtCode = item;
    while (LoopKey("ActNewArtCode",SINr,1,found)) begin
      if (SINr.NewArtCode!=item) then begin found = false; end;
      if (found) then begin
        if (GetItemStatus(SINr.OldArtCode,"","",0,stock,ord,purch,unitcoef,prodord,rsrv,inprice)) then begin
        end;
      end;
    end;
  end;
  return;
end;

global
updating procedure InvalidatePU(record PUVc PUr)
begin
  /* duplicated in PurUpdateOvst
  
  record MainStockBlock MainStockRec;
  record ItemHistVc IHr;
  record ItemHistVc oldIHr;
  Integer i,rwcnt;
  row PUVc PUrw;
  string 10 location;
  string 10 thelocation;
  val t,t2,q2;
  
  if (PUr.Invalid==0) then begin
    goto LInvalidatePU;
  end;
  location = PUr.Location;
  BlockLoad(MainStockRec);
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if (blank(PUrw.Location)) then begin
      thelocation = location;
    end else begin
      thelocation = PUrw.Location;
    end;
    IHr.FileName = "PUVc";
    IHr.TransNr = PUr.SerNr;
    IHr.Row = i;
    if (ReadFirstKey("FNTransNr",IHr,3,true)) begin
      RecordCopy(oldIHr,IHr);
      IHr.RemQty = 0;
      IHr.StockAffectf = 0;
      if (RecordUpdate(oldIHr,IHr,true)==0) then begin end;
      
      if (nonblank(PUrw.SerialNr)) then begin
        if ((nonblankdate(PUrw.BestBefore)) or (PUrw.UnitXval!=0)) then begin
          DeleteBatchBestBefore(PUrw.ArtCode,PUrw.SerialNr);
        end;
      end;
      UpdateSerStock(PUrw.ArtCode,thelocation,PUrw.SerialNr,-PUrw.Quant,-PUrw.CostPrice);
      t2 = -PUrw.Quant;
      if (MainStockRec.UnitConvCalc==0) then begin
        q2 = t2*PUrw.Coefficient;
      end else begin
        q2 = t2/PUrw.Coefficient;
      end;
      UpdateInstock("PUVc",PUr.SerNr,PUrw.ArtCode,thelocation,PUr.TransDate,t2,t,t,t,t,q2,t,t,t);
    end;
  end;
  */
LInvalidatePU:;
  return;
end;

global
procedure CalculateWSRowFIFO(record MainStockBlock MSb,record CostAccBlock CAb,string location,record WSVc WSp,row WSVc WSrw,Integer currow)
BEGIN
  val adjstockv;
  row WSVc WS2rw;
  Integer j;
  record INVc INr;

  if (ReadFirstItem(WSrw.ArtCode,INr,true,false)) then begin end;
  if (INr.ItemType!=kItemTypeStocked) then begin 
    if (CAb.CostAccForNonStocked==0) then begin
      goto LCalculateWSRowFIFO;
    end;
  end;
  adjstockv = blankval;
  for (j=0;j<currow;j=j+1) begin    
    MatRowGet(WSp,j,WS2rw);
    if (TestArtCode(WS2rw.ArtCode,WSrw.ArtCode,INr)) then begin
      adjstockv = adjstockv + WS2rw.Quant;
    end;
  end;
  WSrw.FIFORowVal = FindCostPrice(WSrw.ArtCode,location,WSrw.SerialNr,WSrw.Quant,adjstockv,false);
  WSrw.FIFORowVal = Round(WSrw.FIFORowVal,SetRoundModeD(5));
  WSrw.FIFO = WSrw.FIFORowVal/WSrw.Quant;
  WSrw.FIFO = Round(WSrw.FIFO,SetRoundModeD(5));
LCalculateWSRowFIFO:;
  RETURN;
END;

global
procedure WSUpdateFIFO(record WSVc WSp)
BEGIN
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  row WSVc WSrw;
  Integer i,rwcnt;
  string 10 location;
  
  BlockLoad(CAb);
  location = WSp.Location;
  if (blank(location)) then begin
    BlockLoad(MSb);
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (nonblank(WSrw.ArtCode)) then begin
      if (WSrw.Quant!=0) then begin//INRS strcuture
        CalculateWSRowFIFO(MSb,CAb,location,WSp,WSrw,i);
        MatRowPut(WSp,i,WSrw);
      end;
    end;
  end;
  RETURN;
END;
