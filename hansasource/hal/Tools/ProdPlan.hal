external procedure AddPlanRow(row TempProdPlanVc,longint,longint,integer,string,string,date,time,date,time,longint,record MachineShiftVc,boolean,var date,var time,var date,var time,date,time,                     array date,array time,array date,array time,val,var integer,integer);external updating procedure RemoveOldTempRecs();external function Integer GetWeekNr(Date,string,var LongInt);external procedure ExtractObjWithSeparator(string,string,Boolean,var Integer,var string);external function Integer IsRedDay(Boolean,record BHollVc,Integer,Date);external function LongInt TimeDiffInSeconds(Time,Time);external function roundmode SetRoundModeD(integer);external procedure ExtractObj(string,var Integer,var string);external function string 20 GetMainMachine(string,var integer);external function LongInt DateDiff(Date,Date);external function Time TimeDiff(Time,Time);external function LongInt TimeToSeconds2(Time);external procedure ProdPlanWebOut(string);external function longint DurToSeconds(duration);procedure LogDebugData(string tstr1,string tstr2,string tstr3,string tstr4,string tstr5,string tstr6,string tstr7,string tstr8,string tstr9,string tstr10,string tstr11)begin  if (OpenExportFile("debug.txt",true)==false) then begin    CreateFile("debug.txt");    OpenFile("debug.txt");  end;  ExportString(tstr1);  ExportString(tstr2);  ExportString(tstr3);  ExportString(tstr4);  ExportString(tstr5);  ExportString(tstr6);  ExportString(tstr7);  ExportString(tstr8);  ExportString(tstr9);  ExportString(tstr10);  ExportString(tstr11);  newline;  CloseFile;  return;end;globalfunction val sqrt(val x)begin  integer i;//iterations  integer a,c;  val t,t2,res,t3,px;    px = x;  if (px < 0) then begin px = -px; end;  i = 5;//number of iterations  t = x;  c = 1;  While t > 2 begin    t = t / 2;    c = c + 1;  end;  t = c;//guess value  for (a = 0; a < i; a = a + 1) begin    t2 = t - ((t*t-x)/(2*t));    t = t2;  end;  res = t;  sqrt = res;  return;end;function val sqr(val x)begin  sqr = x * x;  return;end;function val mypow(val b,val pw,val precision)begin  val res;  if (pw == 0) then begin res = 1; Goto LExitPow; end;//new  if (pw < 0) then begin res = 1 / mypow(b,-pw,precision); Goto LExitPow; end;  if (pw >= 10) then begin res = sqr(mypow(b,pw/2,precision/2)); Goto LExitPow; end;  if (pw >= 1) then begin res = b * mypow(b,pw-1,precision); Goto LExitPow; end;  if (precision >= 1) then begin res = sqrt(b); Goto LExitPow; end;  res = sqrt(mypow(b,pw*2,precision*2));LExitPow:;  mypow = res;  return;end;globalfunction val pow(val b,val pw)begin  pow = mypow(b,pw,0.00001);  return;end;globalfunction val exp(val v)begin  integer apx,i;  val res,tv;  res = 2.718281828459045;  tv = v;  if (tv > 14) then begin tv = 14; end;  exp = pow(res,tv);//a veeeery aproximate way to calculate exp, but it works  return;end;globalfunction longint GetFormatedDuration(duration t)begin  longint res;  longint l;  l = 3600.00 * t.Hour;  l = l + t.Minute * 60;  l = l + t.Second;  res = l;  GetFormatedDuration = res;  return;end;function longint GetParentNr(record ProdOperationVc tProdOpr)begin  record ProdOperationVc ProdOpr;  longint res;    ProdOpr.Sequence = tProdOpr.Sequence;  ProdOpr.ProdNr = tProdOpr.ProdNr;  ProdOpr.SubSequence = tProdOpr.SubSequence;  res = -1;  if (LoopBackKey("ProdNrSeq",ProdOpr,3,true)) then begin    if (LoopBackKey("ProdNrSeq",ProdOpr,3,true)) then begin      if (ProdOpr.ProdNr == tProdOpr.ProdNr) then begin        res = ProdOpr.SerNr;      end;    end;  end;  GetParentNr = res;  return;end;procedure InsertPlanRows(var record TempProdPlanVc Tempr,var row TempProdPlanVc Temprw,integer rownr,array date arStartDate,array time arStartTime,array date arEndDate,array time arEndTime,string ProdOPCode,string ProdOpRoute,var integer arsize,boolean InsertFlag,longint setuptime)begin  integer i;  if (InsertFlag) then begin    for (i = 0; i < arsize; i = i + 1) begin      Temprw.StartDate = arStartDate[i];      Temprw.EndDate = arEndDate[i];      Temprw.StartTime = arStartTime[i];      Temprw.EndTime = arEndTime[i];      Temprw.ProdOpCode = ProdOpCode;      Temprw.ProdRoute = ProdOpRoute;      Temprw.SetupTime = setuptime;      if (rownr + i > 20000) then begin        LogText(0,"DANGER ROWCNT");      end;      if (rownr + i >= MatRowCnt(Tempr)) then begin        MatRowPut(Tempr,rownr + i,Temprw);      end else begin        MatRowInsert(Tempr,rownr + i,Temprw);      end;    end;  end;  return;end;globalprocedure CalcAddTempProdPlan(var record TempProdPlanVc Tempr,record MachineShiftVc Shiftr,longint prodopnr,longint prodnr,integer type,string comstr,string addclass,longint dur,date mdate,time mtime,string ProdOpCode,string ProdOpRoute,var boolean savef,boolean forcesetf,var date FinStartDate,var date FinEndDate,var time finStartTime,var time FinEndTime,date gsd,time gst,var string PrevOpCode,var string PrevRouteCode,boolean InsertFlag,time tsetuptime,val qty,var boolean IsAfterMother)begin  row TempProdPlanVc Temprw,Temp2rw,Temp3rw;  row MachineShiftVc Shiftrw;  integer i,rw,rwc;  boolean foundf,donef;  integer insrow;  string 20 tPrevOpCode;  longint setuptime;  string 30 sessid,machineid;  array date arStartDate,arEndDate;  array time arStartTime,arEndTime;  integer arsize;  boolean testf;  transaction string 10 gAddPlanCnt;  longint wc;  setuptime = TimeToSeconds2(tSetupTime);  arsize =0;  rwc = MatRowCnt(Tempr);  PrevOpCode = "";  isAfterMother = false;  if (rwc > 0) then begin    MatRowGet(Tempr,0,Temprw);    if (rwc == 1) then begin      wc = gAddPlanCnt; gAddPlanCnt = wc + 1;      AddPlanRow(Temp3rw,prodopnr,prodnr,type,comstr,addclass,gsd,gst,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,0);      if (Temp3rw.EndDate < Temprw.StartDate or         (Temp3rw.EndDate == Temprw.StartDate and Temp3rw.EndTime < Temprw.StartTime)) then begin        InsertPlanRows(Tempr,Temp3rw,0,arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);      end else begin        wc = gAddPlanCnt; gAddPlanCnt = wc + 1;        AddPlanRow(Temp3rw,prodopnr,prodnr,type,comstr,addclass,Temprw.EndDate,Temprw.EndTime,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,1);        InsertPlanRows(Tempr,Temp3rw,1,arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);        PrevOpCode = tPrevOpCode;        if (Temprw.ProdNr == Temp3rw.ProdNr) then begin          isAfterMother = true;        end;        if (Temprw.EndDate == Temp3rw.StartDate and Temprw.EndTime == Temp3rw.StartTime) then begin          PrevOpCode = Temprw.ProdOpCode;          PrevRouteCode = Temprw.ProdRoute;        end;      end;    end else begin      wc = gAddPlanCnt; gAddPlanCnt = wc + 1;      AddPlanRow(Temp3rw,prodopnr,prodnr,type,comstr,addclass,gsd,gst,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,0);      donef = false;      if (Temp3rw.EndDate < Temprw.StartDate or         (Temp3rw.EndDate == Temprw.StartDate and Temp3rw.EndTime < Temprw.StartTime)) then begin        InsertPlanRows(Tempr,Temp3rw,0,arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);        donef = true;        //inserting at the first position      end else begin        for (rw = 1; rw < rwc; rw = rw + 1) begin          MatRowGet(Tempr,rw,Temprw);//next row          MatRowGet(Tempr,rw-1,Temp2rw);//previous row          testf = true;          if (Temp2rw.ProdOpNr == Temprw.ProdOpNr) then begin            testf = false;          end;          if (Temp2rw.EndDate==Temprw.StartDate and AddMinutes(Temp2rw.EndTime,5)>Temprw.StartTime) then begin            testf = false;          end;          if (Temprw.StartDate < mdate) then begin            testf = false;          end;          if (testf) then begin            wc = gAddPlanCnt; gAddPlanCnt = wc + 1;          //this is only partly fixed. TODO - if (previous job was the last in day, next is the first tomorow, there are some problems            arsize =0;            AddPlanRow(Temp3rw,prodopnr,prodnr,type,comstr,addclass,Temp2rw.EndDate,Temp2rw.EndTime,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,2);            if (Temp3rw.EndDate < Temprw.StartDate or              (Temp3rw.EndDate == Temprw.StartDate and Temp3rw.EndTime < Temprw.StartTime)) then begin              InsertPlanRows(Tempr,Temp3rw,rw,arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);              if (Temp2rw.ProdNr == Temp3rw.ProdNr) then begin                isAfterMother = true;              end;              if (Temprw.EndDate == Temp3rw.StartDate and Temprw.EndTime == Temp3rw.StartTime) then begin                PrevOpCode = Temprw.ProdOpCode;                PrevRouteCode = Temprw.ProdRoute;              end;              donef = true;              rw = rwc;            end;          end;        end;      end;      if (donef==false) then begin        MatRowGet(Tempr,MatRowCnt(Tempr)-1,Temprw);        wc = gAddPlanCnt; gAddPlanCnt = wc + 1;        AddPlanRow(Temp3rw,prodopnr,prodnr,type,comstr,addclass,Temprw.EndDate,Temprw.EndTime,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,3);        InsertPlanRows(Tempr,Temp3rw,MatRowCnt(Tempr),arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);        if (Temprw.ProdNr == Temp3rw.ProdNr) then begin          isAfterMother = true;        end;        if (Temprw.EndDate == Temp3rw.StartDate and Temprw.EndTime == Temp3rw.StartTime) then begin          PrevOpCode = Temprw.ProdOpCode;          PrevRouteCode = Temprw.ProdRoute;        end;      end;    end;  end else begin    ClearRow(Tempr,Temprw,1);    wc = gAddPlanCnt; gAddPlanCnt = wc + 1;    AddPlanRow(Temprw,prodopnr,prodnr,type,comstr,addclass,gsd,gst,mdate,mtime,dur,Shiftr,forcesetf,FinStartDate,FinStartTime,FinEndDate,finEndTime,gsd,gst,arStartDate,arStartTime,arEndDate,arEndTime,qty,arsize,4);    InsertPlanRows(Tempr,Temprw,0,arStartDate,arStartTime,arEndDate,arEndTime,ProdOpCode,ProdOpRoute,arsize,InsertFlag,setuptime);  end;  return;end;global updating procedure StoreTempPlanRec(record TempProdPlanVc Tempr,record TempProdPlanVc Temp2r,boolean savef)begin  if (savef) then begin    RecordStore(Tempr,true);  end else begin    if (RecordUpdate(Temp2r,Tempr,true)==0) then begin end;  end;  return;end;function integer GetProdArFromMachine(array record TempProdPlanVc arProdPlanr,integer prodarcnt,string machineid)begin  record TempProdPlanVc Tempr;  integer res,i;  res= -1;  for (i =0; i < prodarcnt; i = i + 1) begin    recordCopy(Tempr,arProdPlanr[i]);    if (Tempr.MachineID==machineid) then begin      res = i;      i = prodarcnt;    end;  end;  GetProdArFromMachine = res;  return;end;globalprocedure AddTempProdPlan(array record TempProdPlanVc arProdPlanr,array record MachineShiftVc arShiftr,var integer prodarcnt,record ProdOperationVc ProdOpr,string sessid,date mdate,time mtime,var date FinStartDate,var date FinEndDate,var time finStartTime,var time FinEndTime,date gsd,time gst,string comstr,boolean InsertFlag,var string PrevOpCode,var string PrevRouteCode,var boolean IsAfterMother,longint pdur)begin  time wstart;  time wend;  record TempProdPlanVc Tempr,Temp2r;  record MachineShiftVc Shiftr;  date pDate;  time pTime;  integer mpos;  longint dur;  boolean savef;    mpos = GetProdArFromMachine(arProdPlanr,prodarcnt,ProdOpr.Machine);  if (mpos >=0) then begin    Tempr=arProdPlanr[mpos];    Shiftr = arShiftr[mpos];    dur = pdur;    if (dur==-1) then begin      dur = TimeToSeconds2(ProdOpr.SetupTime) /*+ TimeToSeconds2(ProdOpr.QueueTime) */ /*+ TimeToSeconds2(ProdOpr.MoveTime)*/;      dur = dur + (DurToSeconds(ProdOpr.RunTime)+TimeToSeconds2(ProdOPr.QueueTime)) * ProdOpr.Qty;      if (dur==0) then begin dur = 1; end;    end;    CalcAddTempProdPlan(Tempr,Shiftr,ProdOpr.SerNr,ProdOpr.ProdNr,0,comstr,"",dur,mdate,mtime,ProdOpr.StdOperation,"",savef,false,FinStartDate,FinEndDate,finStartTime,FinEndTime,gsd,gst,PrevOpCode,PrevRouteCode,InsertFlag,ProdOpr.SetupTime,ProdOpr.Qty,IsAfterMother);    arProdPlanr[mpos] = Tempr;  end;  return;end;globalupdating procedure UpdateSessionRec(string sessid,string statstr,integer statflag,var boolean breakf)begin  record ProdPlanSessionVc ProdSesr,ProdSes2r;    ProdSesr.SessionID = sessid;  RecordCopy(ProdSes2r,ProdSesr);  if (ReadFirstMain(ProdSesr,1,true)==false) then begin    RecordNew(ProdSesr);    ProdSesr.SessionID = sessid;    ProdSesr.TransDate = CurrentDate;    ProdSesr.TransTime = CurrentTime;    ProdSesr.StatusFlag = statflag;    ProdSesr.StatusStr = statstr;    RecordStore(ProdSesr,true);  end else begin    RecordCopy(ProdSes2r,ProdSesr);    ProdSesr.StatusFlag = statflag;    ProdSesr.StatusStr = statstr;    RecordUpdate(ProdSes2r,ProdSesr,true);    LogText(0,statstr);  end;  return;end;globalfunction longint GetMotherProdOP(longint prodnr,longint seqnr)begin  record ProdOperationVc ProdOpr;  longint res;  boolean Trhs;  ProdOpr.Sequence = seqnr-1;  ProdOPr.ProdNr = prodnr;  TrHs = true;  res = -1;  While LoopBackKey("ProdNrSeq",ProdOPr,2,TrHs) begin    if (ProdOpr.ProdNr <> prodnr) then begin      TrHs = false;    end else begin      if (ProdOpr.PRStatusFlag==0) then begin        res = ProdOpr.SerNr;        TrHs = false;      end;    end;  end;  GetMotherProdOP = res;  return;end;function longint GetMotherProdOPPos(array longint arProdOpNr,longint arcnt,longint motherprodop)begin  longint res,i;    res = -1;  if (motherprodop > 0) then begin    for (i = 0; i < arcnt; i = i + 1) begin      if (arProdOPNr[i] == motherprodop) then begin        res = i;      end;    end;  end;  GetMotherProdOPPos = res;  return;end;function integer GetCustPrio(longint prodnr)begin  record StockReservVc SRr;  record ORVc Orr;  record CUVc Cur;  record ProdVc Prodr;  integer res;    Srr.ToFileName = 1;  SRr.ToSerNr = prodnr;  SRr.Donef = 0;  res = 3;  if (ReadFirstKey("ToItem",Srr,3,true)) then begin    ORr.SerNr = Srr.FromSerNr;    if (ReadFirstMain(Orr,1,true)) then begin      Cur.Code = Orr.CustCode;      if (ReadFirstMain(Cur,1,true)) then begin        if (Setinset("P1",Cur.Classification)) then begin          res = 1;        end;        if (Setinset("P2",Cur.Classification)) then begin          res = 2;        end;      end;    end;  end;  GetCustPrio = res;  return;end;globalfunction integer GetProdPrio(longint prodnr)begin  record ProdVc Prodr;  record ProdOrderVc ProdOr;  integer res;    Prodr.SerNr = prodnr;  res = 100;  /*  if (ReadFirstMain(Prodr,1,true)) then begin    ProdOr.SerNr = Prodr.ProdOrder;    if (ReadFirstmain(ProdOr,1,true)) then begin      if (ProdOr.Priority>0) then begin        res = ProdOr.Priority;      end;    end;  end;*/  GetProdPrio = res;  return;end;procedure RecalcProdQueue(array longint arProdNr,                        array longint arSetup,                        array longint arDur,                        array longint arMotherPos,                        array longint arTotQueueTime,                        array longint arChildCount,var longint arcnt)begin  vector integer vPodIsChecked;  longint dur,prevdur,ccnt;  longint rw,nextpos;  for (rw = arcnt-1; rw >=0;  rw = rw - 1) begin    if (vPodIsChecked[arProdNr[rw]]<>1) then begin      if (arMotherPos[rw] >= 0) then begin        vPodIsChecked[arProdNr[rw]] = 1;      end;      prevdur = arDur[rw];      nextpos = arMotherPos[rw];      ccnt = 0;     // logtext(0,nextpos);      While nextpos >= 0 begin        arTotQueueTime[nextpos] = arTotQueueTime[nextpos] + prevdur;        arChildCount[nextpos] = arChildCount[nextpos] + ccnt;        prevdur = prevdur + arDur[nextpos];        ccnt = ccnt + 1;        nextpos = arMotherPos[nextpos];      end;    end;  end;  return;end;globalprocedure BuildProdOpAr(array longint arProdNr,                        array longint arProdOpNr,                        array longint arProdOrderNr,                        array longint arMotherProdOpNr,                        array longint arSetup,                        array longint arDur,                        array string arMach,                        array longint arMotherPos,                        array integer arCustPrio,                        array integer arProdPrio,                        array string arProdOPCode,                        array string arProdRoute,                        array integer arProdOpRowNum,                        array longint arTotQueueTime,                        array longint arChildCount,                        array longint arDueDays,                        vector integer vProdNrOpCnt,                        array date arEarliestDate,var longint arcnt)begin  record ProdOperationVc ProdOpr;  record ProdOrderVc ProdOrderr;  record ProdVc Prodr;  boolean trHs,testf;  longint dur;  Trhs = true;  arcnt = 0;  While LoopKey("ProdNrSeq",ProdOpr,4,TrHs) begin    testf = true;    if (ProdOPr.PRStatusFlag <> 0) then begin      testf = false;    end;    if (ProdOpr.Machine == "") then begin      testf = false;    end;    if (testf) then begin      dur = TimeToSeconds2(ProdOpr.SetupTime) /*+ TimeToSeconds2(ProdOpr.QueueTime) + /*TimeToSeconds2(ProdOpr.MoveTime)*/;      dur = dur + (TimeToSeconds2(ProdOpr.QueueTime)+DurToSeconds(ProdOpr.RunTime)) * ProdOpr.Qty;      if (dur==0) then begin dur = 1; end;      if (dur < 0) then begin        testf = false;      end;    end;    if (testf) then begin      arProdNr[arcnt] = ProdOPr.ProdNr;      arProdOpNr[arcnt] = ProdOpr.SerNr;      arMotherProdOPNr[arcnt] = GetMotherProdOP(ProdOPr.ProdNr,ProdOPr.Sequence);      arMotherPos[arcnt] = GetMotherProdOPPos(arProdOpNr,arcnt,arMotherProdOPNr[arcnt]);      arMach[arcnt]= ProdOpr.Machine;      arSetup[arcnt] = TimeToSeconds2(ProdOpr.SetupTime);      arDur[arcnt] = dur;      arCustPrio[arcnt] = GetCustPrio(arProdNr[arcnt]);      arProdPrio[arcnt] = GetProdPrio(arProdNr[arcnt]);      arProdOPCode[arcnt] = ProdOPr.StdOperation;      Prodr.SerNr = ProdOPr.ProdNr;      if (ReadFirstMain(Prodr,1,true)) then begin        arProdRoute[arcnt] = Prodr.Routing;      end;      arProdOrderNr[arcnt] = ProdOPr.ProdOrdNr;      arProdOpRowNum[arcnt] = ProdOpr.Sequence;      arDueDays[arcnt] = -9999;      vProdNrOpCnt[arProdOrderNr[arcnt]] = vProdNrOpCnt[arProdOrderNr[arcnt]] + 1;      if (ProdOpr.ProdOrdNr > 0) then begin        ProdOrderr.SerNr = ProdOpr.ProdOrdNr;        if (ReadFirstMain(ProdOrderr,1,true)) then begin          //arEarliestDate[arcnt] = ProdOrderr.FastestDate;//jzs-combine          if (nonblank(ProdOrderr.DueDate)) then begin            arDueDays[arcnt] = DateDiff(ProdOrderr.DueDate,CurrentDate);          end;        end;      end;      arcnt = arcnt + 1;    end;  end;  RecalcProdQueue(arProdNr,arSetup,arDur,arMotherPos,arTotQueueTime,arChildCount,arcnt);  return;end;function integer GetIndexByMachine(string machinid,array record MachineShiftVc arShiftr,integer arcnt)begin  record MachineShiftVc Shiftr;  integer res,i;  for (i = 0; i < arcnt; i = i + 1) begin    Shiftr = arShiftr[i];    if (Shiftr.MachineID==machinid) then begin      res = i;      i = arcnt;    end;  end;  GetIndexByMachine = res;  return;end;function val expVector(val v,vector val vExpValue,roundmode rm)begin  val res,part;  res = round(v+0.05,rm);  part = res - v;  expVector = vExpValue[res]*(0.1-part)*10 + vExpValue[res-0.1] * (part) * 10;;  return;end;procedure CalcTardAr(array record TempProdPlanVc arProdPlanr,                      string sessid,                      array val Tardar,                      array longint TardarIdx,                      array string TardMachine,                      array record MachineShiftVc arShiftr,                      integer prodarcnt,                      array longint arProdNr,                      array longint arProdOPNr,                      array longint arProdOrderNr,                      array longint arMotherProdOPNr,                      array longint arSetup,                      array longint arDur,                      array string arMach,                      array longint arMotherPos,                      array integer arCustPrio,                      array integer arProdPrio,                      array date arStartdate,                      array date arEnddate,                      array time arStarttime,                      array time arEndtime,                      array string arProdOPCode,                      array string arProdRoute,                      array integer arProdOpRowNum,                      vector val arSwitchTime,                      vector longint vEqMachine,                      array string arEqMachine,                      array string arEqRoutingRow,                      array longint arNextEqMachine,                      longint arEqCnt,                      array longint arGainSetupTime,                      array longint arTotQueueTime,                      array longint arChildCount,                      array longint arDueDays,                      array date arEarliestDate,                      vector longint vMotherProdOr,longint arcnt,var longint tardcnt,date gsd,time gst,record ProdPlanCoefBlock ProdPlanCoefbl,vector val vExpValue,roundmode rm,var integer OverrideRow,array longint tarMotherProdNr,var boolean forcef,                      array date arTempStartdate,array date arTempEnddate,array time arTempStarttime,array time arTempEndtime,array integer arTempRecVersion,vector integer vMachineQueVersion)begin  transaction string 10 TardChecks;  longint tlong;  date StartDate;  time StartTime;  record TempProdPlanVc TempPlanr,TempPlan2r;  record ProdOperationVc ProdOpr;  array val tempar,tempar2,tempar3,tempar4,tempar5,tempar6,tempar7,tempar8,tempar9;  longint i,x,j,x2,x3;  val avfintime,avstarttime,avcustprio,custprio,totcustprio,totdistance;  val avprodprio,prodprio,totprodprio,avgainsetup,avdistance,avqueuetime,avchildcount,avDueDays;  date fromdate,EndDate;  time fromtime,EndTime;  boolean testf,foundf,savef,isMotherf;  longint offset,totoffset,totoffset2,cnt,totgainsetup,l,totqueuetime,totchildcount,totDueDays;  string 20 prevopcode,prevoproute;  string 200 eqm,newm;  longint eqmnr;  val coef;  integer p;  boolean IsAfterMother,DoEqMachinef,foundrec;  longint tl,tl2;  transaction string 1 gDebugLevel;  string 255 tstr;    //calculating tardiness for earliest finishing times  //BlockLoad(ProdPlanCoefbl);  totoffset = 0;  totoffset2 = 0;  cnt = 0;  /*  tempar - active planning  tempar2 - nodelay planning  tempar3 - customer priority  tempar4 - production priority  tempar5 - switchover time decrease  tempar6 - distance between mother and daughter  tempar7 - longest queue time first  tempar8 - largest number of children first  tempar9 - producation due date  */  foundrec = false;  tl = GetCurTick;LTryTardCalc:;  j = 0;  for (i =0; i < arcnt; i = i + 1) begin    if (arProdNr[i] > 0) then begin      fromdate = gsd;      fromtime = gst;      testf = true;      isMotherf = false;      if (arMotherPos[i] >= 0) then begin        if (arProdNr[arMotherPos[i]] <= 0) then begin          fromdate = arEndDate[arMotherPos[i]];          fromtime = arEndTime[arMotherPos[i]];          isMotherf = true;        end else begin          /*          if (mother operation still has Production number in array - mother production operation          is not yet put into array,) then this production should not be looked at          */          if (!forcef) then begin            testf = false;          end else begin            LogText(0,"Using force");          end;        end;      end;      if (arProdOrderNr[i] > 0) then begin        if (vMotherProdOr[arProdOrderNr[i]] > 0) then begin          if (!forcef) then begin            testf = false;            //there are still dependencies not solved for this production          end else begin            LogText(0,"Using force");          end;        end;      end;      if (testf) then begin        foundrec = true;        eqmnr = vEqMachine[arMach[i]];        TardMachine[j] = arMach[i];LAddEqMachineProd:;        Tardar[j] = 0;        TardArIdx[j] = i;        ProdOpr.SerNr = arProdOPNr[i];        ProdOpr.ProdNr = arProdNr[i];        ProdOPr.Machine = TardMachine[j];        IsAfterMother = false;        if (TardMachine[j] == arMach[i] and vMachineQueVersion[arMach[i]]==arTempRecVersion[i] and vMachineQueVersion[arMach[i]]>0) then begin          //using previous version          StartDate = arTempStartDate[i];          EndDate = arTempEndDate[i];          StartTime = arTempStartTime[i];          EndTime = arTempEndTime[i];        end else begin          //calculating plan row for new version          AddTempProdPlan(arProdPlanr,arShiftr,prodarcnt,ProdOpr,sessid,FromDate,FromTime,StartDate,EndDate,StartTime,EndTime,gsd,gst,"",false,PrevOpCode,PrevOpRoute,IsAfterMother,arDur[i])        end;        if (IsAfterMother and eqmnr<=0 and ProdPlanCoefbl.CompressProdFlag==1) then begin          OverrideRow = i;          i = arcnt;        end;        if (TardMachine[j]==arMach[i]) then begin          arTempStartDate[i] = StartDate;          arTempEndDate[i] = EndDate;          arTempStartTime[i] = StartTime;          arTempEndTime[i] = EndTime;          arTempRecVersion[i] = vMachineQueVersion[arMach[i]];        end;        if (ProdPlanCoefbl.Coef1 > 0) then begin          // Tardincess 1 - Active planning. Based on End Date          offset = DateDiff(EndDate,gsd) * 24 * 3600;          offset = offset - TimeToSeconds2(gst);          offset = offset + TimeToSeconds2(EndTime);          totoffset = totoffset + offset;          tempar[j] = offset;        end;        if (ProdPlanCoefbl.Coef2 > 0) then begin          // Tardiness 2 - No Delay planning. Based on start date          offset = DateDiff(StartDate,gsd) * 24 * 3600;          offset = offset - TimeToSeconds2(gst);          offset = offset + TimeToSeconds2(StartTime);          totoffset2 = totoffset2 + offset;          tempar2[j] = offset;        end;        if (ProdPlanCoefbl.Coef6 > 0) then begin          // Tardiness 3 - Customer priority          totcustprio = totcustprio + arCustPrio[i];          tempar3[j] = arCustPrio[i];        end;        if (ProdPlanCoefbl.Coef7 > 0) then begin          // Tardiness 4 - Production priority          totprodprio = totprodprio + arProdPrio[i];          tempar4[j] = arProdPrio[i];        end;        if (ProdPlanCoefbl.Coef4 > 0) then begin          // Tardiness 5 - switchover time decrease          coef = arSwitchTime[arMach[i] & "+" & prevOpCode & "+" & arProdOPCode[i]& "+" & PrevOpRoute  & "+" & arProdRoute[i]];          if (coef <= 0) then begin            coef = 1;          end;          tempar5[j] = arSetup[j] - arSetup[j] * coef;          if (coef <> 1) then begin            arGainSetupTime[i] = arSetup[i] * coef;          end else begin            arGainSetupTime[i] = -1;          end;          totgainsetup = totgainsetup + tempar5[j];        end;        if (ProdPlanCoefBl.Coef5 > 0) then begin          // Tardiness 6 - how far from mother is daugther          l = 0;          if (isMotherf) then begin            l = DateDiff(StartDate,FromDate) * 24 * 3600;            if (fromtime> StartTime) then begin              l = l - TimeDiffInSeconds(StartTime,FromTime);            end else begin              l = l + TimeDiffInSeconds(FromTime,StartTime);            end;          end;          tempar6[j] = l;          totdistance = totdistance + l;        end;        if (ProdPlanCoefBl.Coef8 > 0) then begin          // Tardiness 7 - longest queue time first          tempar7[j] = arTotQueueTime[i];          totQueueTime = totQueueTime + arTotQueueTime[i];        end;        if (ProdPlanCoefBl.Coef9 > 0) then begin          // Tardiness 8 - largest number of children first          tempar8[j] = arChildCount[i];          totChildCount = totChildCount + arChildCount[i];        end;        if (ProdPlanCoefBl.Coef3 > 0) then begin          // Tardiness 9 - production due date          tempar9[j] = arDueDays[i];          if (arDueDays[i]<>-9999) then begin            totDueDays = totDueDays + arDueDays[i];          end;        end;        cnt = cnt + 1;        j = j + 1;        While eqmnr>0 begin          TardMachine[j] = arEqMachine[eqmnr];          DoEqMachinef = false;          if (blank(arEqRoutingRow[eqmnr]) or arEqRoutingRow[eqmnr]==arProdRoute[i] & ":" & arProdOpRowNum[i]) then begin            DoEqMachinef = true;          end;          eqmnr = arNextEqMachine[eqmnr];          if (DoEqMachinef) then begin            goto LAddEqMachineProd;          end;        end;      end;    end;  end;  if (!foundrec and !forcef) then begin    forcef = true;    goto LTryTardCalc;  end;  tardcnt = j;  tlong = TardChecks;  tlong = tlong + tardcnt;  TardChecks = tlong;  avfintime = totoffset / cnt; //average finishing time  avstarttime = totoffset2 / cnt; //average finishing time  avcustprio = totcustprio / cnt;  avprodprio = totprodprio / cnt;  avgainsetup = totgainsetup / cnt;  avdistance = totdistance / cnt;  avqueuetime = totqueuetime / cnt;  avchildcount = totchildcount / cnt;  avduedays = totduedays / cnt;  x = 1000;//for default numbers/periods  x2 = 1;//for smaller numbers (priority, children count)  x3 = 10000;//for biggest numbers/periods (queue time)  for (j = 0; j < tardcnt; j = j + 1) begin      foundf = false;      if (tempar[j] < 0) then begin        tempar[j] = 0;      end else begin        tempar[j] = (tempar[j] + x*(100.00-ProdPlanCoefbl.Coef2)) / (avfintime + x*(100.00-ProdPlanCoefbl.Coef2));        foundf = true;      end;      if (tempar2[j] < 0) then begin        tempar2[j] = 0;      end else begin        tempar2[j] = (tempar2[j] + x*(100.00-ProdPlanCoefbl.Coef1)) / (avstarttime + x*(100.00-ProdPlanCoefbl.Coef1));        foundf = true;      end;      if (tempar3[j] < 0) then begin        tempar3[j] = 0;      end else begin        tempar3[j] = (tempar3[j] + (100.00*x-ProdPlanCoefbl.Coef6*x)) / (avcustprio + (100.00*x-ProdPlanCoefbl.Coef6*x));        foundf = true;      end;      if (tempar4[j] < 0) then begin        tempar4[j] = 0;      end else begin        tempar4[j] = (tempar4[j] + x2*(100.00-ProdPlanCoefbl.Coef7)) / (avprodprio + x2*(100.00-ProdPlanCoefbl.Coef7));        foundf = true;      end;      if (tempar5[j] < 0) then begin        tempar5[j] = 0;      end else begin        tempar5[j] = (avgainsetup + x*(100.00-ProdPlanCoefbl.Coef4)) / (tempar5[j] + x*(100.00-ProdPlanCoefbl.Coef4));        foundf = true;      end;      if (tempar6[j] < 0) then begin        tempar6[j] = 0;      end else begin        tempar6[j] = (tempar6[j] + (100.00*x-ProdPlanCoefbl.Coef5*x)) / (avdistance + (100.00*x-ProdPlanCoefbl.Coef5*x));        foundf = true;      end;      if (tempar7[j] < 0) then begin        tempar7[j] = 0;      end else begin        tempar7[j] = (avqueuetime + x3*(100.00-ProdPlanCoefbl.Coef8)) / (tempar7[j] + x3*(100.00-ProdPlanCoefbl.Coef8));        foundf = true;      end;      if (tempar8[j] < 0) then begin        tempar8[j] = 0;      end else begin        tempar8[j] = (avchildcount + x2*(100.00-ProdPlanCoefbl.Coef9)) / (tempar8[j] + x2*(100.00-ProdPlanCoefbl.Coef9));        foundf = true;      end;      if (tempar9[j] <> -9999 or ProdPlanCoefbl.Coef3==0) then begin        tempar9[j] = 0;      end else begin        if (tempar9[j] < 0) then begin          tempar9[j] = (1 - (ProdPlanCoefbl.Coef3/100)) / tempar9[j];        end else begin          tempar9[j] = (tempar9[j] + (100.00*x-ProdPlanCoefbl.Coef3*x)) / (avduedays + (100.00*x-ProdPlanCoefbl.Coef3*x));        end;        foundf = true;      end;      if (foundf) then begin        Tardar[j] = expVector(tempar[j],vExpValue,rm) *                    expVector(tempar2[j],vExpValue,rm) *                    expVector(tempar3[j],vExpValue,rm) *                    expVector(tempar4[j],vExpValue,rm) *                    expVector(tempar5[j],vExpValue,rm) *                    expVector(tempar6[j],vExpValue,rm) *                    expVector(tempar7[j],vExpValue,rm) *                    expVector(tempar8[j],vExpValue,rm) *                    expVector(tempar9[j],vExpValue,rm);        if (gDebugLevel<>"") then begin          LogDebugData(arProdOPNr[TardArIdx[j]],"o",                 ValToSTring(expVector(tempar[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar2[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar3[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar4[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar5[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar6[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar7[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar8[j],vExpValue,rm),M45Val,"",".",0),                 ValToSTring(expVector(tempar9[j],vExpValue,rm),M45Val,"",".",0));        end;      end;  end;  return;end;procedure RemoveFromMotherVectorNode(longint mainnr,var longint removenr,longint removeprod,array longint tarMotherProd,array longint tarMotherNode)begin  longint curnr,prevnr;  boolean TrHs;    curnr = removenr;  TrHs = true;  prevnr = curnr;  While (curnr > 0) begin    if (tarMotherProd[curnr]==removeprod) then begin      if (prevnr==curnr) then begin        curnr = tarMotherNode[curnr];        tarMotherNode[prevnr] = tarMotherNode[curnr];        removenr = curnr;      end else begin        tarMotherNode[prevnr] = tarMotherNode[curnr];//giving current step to teh prevous one        prevnr = curnr;        curnr = tarMotherNode[curnr];      end;      TrHs = false;    end else begin      prevnr = curnr;      curnr = tarMotherNode[curnr];    end;  end;  if (trhs) then begin    LogText(0,"WARNING: Failed to find entry for " & mainnr);  end;  return;end;procedure RemoveProdFromVectorNode(longint removeprod,var longint removenr,array longint tarProdNr,array longint tarProdNode,vector longint vMotherProdNr,array longint tarMotherProd,array longint tarMotherNode)begin  longint curnr;  longint firstidx;  curnr = removenr;  While (curnr > 0) begin    firstidx = vMotherProdNr[tarProdNr[curnr]];    RemoveFromMotherVectorNode(tarProdNr[curnr],firstidx,removeprod,tarMotherProd,tarMotherNode);    vMotherProdNr[tarProdNr[curnr]] = firstidx;    curnr = tarProdNode[curnr];  end;  removenr = -1;  return;end;procedure AddTempProdPlanBlock(longint minpos,                               array longint arProdNr,                               array longint arProdOpNr,                               array integer arCustPrio,                               array integer arProdPrio,                               vector longint vMotherProdNode,                               array longint tarMotherProdNr,                               array longint tarMotherProdNode,                               array longint arDueDays,                               array longint arGainSetupTime,                               array string TardMachine,                               var array string arMach,                               vector longint vReservProdNode,                               array longint tarReservProdNr,                               array longint tarReservProdNode,                               array record TempProdPlanVc arProdPlanr,                               array record MachineShiftVc arShiftr,                               array date arStartdate,                               array date arEnddate,                               array time arStarttime,                               array time arEndtime,                               array longint arDur,                               longint tarMothercnt,                               var longint tarReservcnt,                               vector integer vProdNrOpCnt,                               integer mini,                               var integer prodarcnt,                               record ProdOperationVc ProdOpr,                               string sessid,                               date mdate,                               time mtime,                               var date FinStartDate,                               var date FinEndDate,                               var time finStartTime,                               var time FinEndTime,                               date gsd,                               time gst,                               boolean InsertFlag,                               var string PrevOpCode,                               var string PrevRouteCode,                               var boolean IsAfterMother,                               integer debugtype)begin  time btime;  string 255 comstr;  longint tdur;  integer z;  comstr = "";  if (arCustPrio[minpos] <> 3) then begin    comstr = "Customer Priority : " & arCustPrio[minpos] & "<br>";  end;  if (arProdPrio[minpos] <> 3) then begin    comstr = "Production Priority : " & arProdPrio[minpos] & "<br>";  end;  if (arDueDays[minpos] > 0) then begin    comstr = "Due Date : " & AddDay(gsd,arDueDays[minpos]) & "<br>";  end;  if (arGainSetupTime[minpos] >= 0) then begin    ProdOPr.SetupTime = AddSeconds(btime,arGainSetupTime[minpos]);  end;  if (TardMachine[mini] <> "") then begin    arMach[minpos] = TardMachine[mini];  end;  ProdOpr.Machine = arMach[minpos];  tdur=-1;  if (debugtype==1 or debugtype==2) then begin    tdur = arDur[minpos];  end;  AddTempProdPlan(arProdPlanr,arShiftr,prodarcnt,ProdOpr,sessid,mdate,mtime,FinStartDate,FinEndDate,FinStartTime,FinEndTime,gsd,gst,comstr,true,PrevOpCode,PrevRouteCode,IsAfterMother,tdur);  arStartdate[minpos] = FinStartDate;  arEnddate[minpos] = FinEndDate;  arStartTime[minpos] = FinStartTime;  arEndTime[minpos] = FinEndTime;  arProdNr[minpos] = -1;  arProdOpNr[minpos] = -arProdOpNr[minpos];  vProdNrOpCnt[ProdOPr.ProdOrdNr] = vProdNrOpCnt[ProdOPr.ProdOrdNr] - 1;  if (vProdNrOpCnt[ProdOPr.ProdOrdNr] == 0 and ProdOPr.ProdOrdNr>0) then begin    RemoveProdFromVectorNode(ProdOpr.ProdOrdNr,vReservProdNode[ProdOpr.ProdOrdNr],tarReservProdNr,tarReservProdNode,vMotherProdNode,tarMotherProdNr,tarMotherProdNode);    //erase prodnr from reservations  end;  return;end;procedure GetPrevOperationsEndTime(record ProdOperationVc ProdOPr,array longint arProdNr,array longint arProdOrderNr,                                   vector longint vMotherProdNode,array longint tarMotherProdNr,array longint tarMotherProdNode,                                   array date arEnddate,array time arEndtime,longint tarMothercnt,                                   longint prodarcnt,var date mdate,var time mtime)begin  longint prodord,i,curnr;  mdate = "";  mtime = "";  if (vMotherProdNode[ProdOpr.ProdOrdNr]>0) then begin    curnr = vMotherProdNode[ProdOpr.ProdOrdNr];    prodord = tarMotherProdNr[curnr];    While (Prodord > 0) begin      for (i =0; i < prodarcnt; i = i + 1) begin        if (arProdOrderNr[i]==prodord) then begin          if (NonBlankDate(arEndDate[i]) and             (mdate<arEndDate[i] or (arEndDate[i]==mdate and mtime<arEndTime[i]))) then begin            mdate = arEndDate[i];            mtime= arEndTime[i];          end;        end;      end;      prodord = tarMotherProdNr[curnr];      curnr = tarMotherProdNode[curnr];    end;  end;  return;end;globalfunction boolean GenProdPlanRecs(array record TempProdPlanVc arProdPlanr,                                               array record MachineShiftVc arShiftr,                                               var integer prodarcnt,                                               string sessid,                                               array longint arProdNr,                                               array longint arProdOpNr,                                               array longint arProdOrderNr,                                               array longint arMotherProdOpNr,                                               array longint arSetup,                                               array longint arDur,                                               array string arMach,                                               array longint arMotherPos,                                               array integer arCustPrio,                                               array integer arProdPrio,                                               array date arStartdate,                                               array date arEnddate,                                               array time arStarttime,                                               array time arEndtime,                                               array string arProdOPCode,                                               array string arProdRoute,                                               array integer arProdOpRowNum,                                               vector val arSwitchTime,                                               vector longint vEqMachine,                                               array string arEqMachine,                                               array string arEqRoutingRow,                                               array longint arNextEqMachine,                                               var longint arEqCnt,                                               array longint arTotQueueTime,                                               array longint arChildCount,                                               array longint arDueDays,                                               array date arEarliestDate,                                               vector longint vMotherProdNode,array longint tarMotherProdNr,array longint tarMotherProdNode,var longint tarMothercnt,                                               vector longint vOrgMotherProdNode,array longint tarOrgMotherProdNr,array longint tarOrgMotherProdNode,var longint tarOrgMothercnt,                                               vector longint vReservProdNode,array longint tarReservProdNr,array longint tarReservProdNode,var longint tarReservcnt,                                               vector integer vProdNrOpCnt,                                               var longint arcnt,var longint pos,date gsd,time gst,record ProdPlanCoefBlock ProdPlanCoefbl,vector val vExpValue,roundmode rm,date effectenddate,var boolean forcef,                                               array date arTempStartdate,array date arTempEnddate,array time arTempStarttime,array time arTempEndtime,array integer arTempRecVersion,vector integer vMachineQueVersion)begin  transaction string 1 gDebugLevel;  array string 20 TardMachine;  array val Tardar;  array longint TardArIdx;  array longint arGainSetupTime;  record MachineShiftVc Shiftr;  record NotePadVc Noter;  row MachineShiftVc Shiftrw;  record ProdOperationVc ProdOpr;  record TempProdPlanVc TempPlanr,TempPlan2r;  row TempProdPlanVc TempPlanrw;  integer rw,rwc;  string 255 comstr;  boolean Trhs,testf;  longint dur;  longint cnt,rownr,i;  boolean res;  val ttard,mintard;  date mdate,pdate,FinStartDate,FinEndDate;  time mtime,ptime,FinStartTime,FinEndTime,btime;  longint minpos,tardcnt,mini,mpos;  string 20 PrevOpCode,PrevOpRoute;  boolean IsAfterMother;  integer OverrideRow,ei,si;  integer z;  longint tdur,l;  date tempenddate;  res = false;  minpos = -1;  OverrideRow = -1;  CalcTardAr(arProdPlanr,sessid,Tardar,TardArIdx,TardMachine,arShiftr,prodarcnt,arProdNr,arProdOPNr,arProdOrderNr,arMotherProdOPNr,             arSetup,arDur,arMach,arMotherPos,arCustPrio,arProdPrio,arStartdate,arEnddate,arStarttime,arEndtime,arProdOPCode,arProdRoute,             arProdOpRowNum,arSwitchTime,vEqMachine,arEqMachine,arEqRoutingRow,arNextEqMachine,arEqCnt,             arGainSetupTime,arTotQueueTime,arChildCount,arDueDays,arEarliestDate,vMotherProdNode,             arcnt,tardcnt,gsd,gst,ProdPlanCoefbl,vExpValue,rm,OverrideRow,tarMotherProdNr,forcef,             arTempStartdate,arTempEnddate,arTempStarttime,arTempEndtime,arTempRecVersion,vMachineQueVersion);//finishing times  mintard = 99999;  if (OverrideRow>=0) then begin    minpos = OverrideRow;  end else begin    for (i = 0; i < tardcnt; i = i + 1) begin      if (Tardar[i]>0) then begin        ttard = Tardar[i];        if (ttard < mintard) then begin           mintard = ttard;           minpos = TardArIdx[i];           mini = i;        end;      end;    end;  end;  if (minpos >= 0) then begin    ProdOPr.SerNr = arProdOpNr[minpos];    if (ReadFirstMain(ProdOPr,1,true)) then begin      if (gDebugLevel<>"") then begin        LogDebugData(ProdOPr.SerNr,"final",mintard,"","","","","","","","");      end;      if (arMotherPos[minpos] >= 0) then begin        //end date and time of previous prod operations for the same production        mdate = arEndDate[arMotherPos[minpos]];        mtime = arEndTime[arMotherPos[minpos]];      end else begin        //end date and time of last prod operation of prod orders from reservation chain        GetPrevOperationsEndTime(ProdOPr,arProdNr,arProdOrderNr,vOrgMotherProdNode,tarOrgMotherProdNr,tarOrgMotherProdNode,arEnddate,arEndtime,tarOrgMothercnt,prodarcnt,mdate,mtime);      end;      vMachineQueVersion[arMach[minpos]] = vMachineQueVersion[arMach[minpos]] + 1;      AddTempProdPlanBlock(minpos,arProdNr,arProdOpNr,arCustPrio,arProdPrio,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,arDueDays,                           arGainSetupTime,TardMachine,arMach,vReservProdNode,tarReservProdNr,tarReservProdNode,arProdPlanr,arShiftr,arStartdate,                           arEnddate,arStarttime,arEndtime,arDur,tarMothercnt,tarReservcnt,vProdNrOpCnt,mini,prodarcnt,ProdOpr,sessid,mdate,mtime,FinStartDate,                           FinEndDate,finStartTime,FinEndTime,gsd,gst,false,PrevOpCode,PrevOpRoute,IsAfterMother,0);      if (FinStartDate <= effectenddate) then begin      //TODO - only duration in this period should be taken        mpos = GetProdArFromMachine(arProdPlanr,prodarcnt,arMach[minpos]);        if (mpos >=0) then begin          if (FinEndDate>effectenddate) then begin            //calculating efficiency            tempenddate = effectenddate;            Shiftr = arShiftr[GetIndexByMachine(arMach[minpos],arShiftr,prodarcnt)];            ei = DateDiff(tempenddate,gsd);            si = DateDiff(FinStartDate,gsd);            for (i = si; i <= ei;i = i + 1) begin              MatRowGet(Shiftr,i,Shiftrw);            end;          end;          TempPlanr = arProdPlanr[mpos];          TempPlanr.EffectCoef = TempPlanr.EffectCoef + arDur[minpos];          arProdPlanr[mpos] = TempPlanr;        end;      end;      pos = pos + 1;      res = true;    end;  end;  GenProdPlanRecs = res;  return;end;function string 20 GetActAddClass(string acttype)begin  record ActTypevc ActTyper;  record NotepadVc Noter;  record RLinkVc RLr;  Integer notenr;  string 20 res;  notenr = 1;  ActTyper.Code = acttype;  if (ReadFirstMain(ActTyper,1,true)) then begin    While (ReadRecordLink(ActTyper,notenr,Noter,RLr)) begin      if ((RLr.Comment=="class")) then begin        if (LinetextCnt(Noter)> 0) then begin          res = LineTextGet(Noter,0);          goto LActGetClass;        end;      end;      notenr = notenr + 1;    end;  end;LActGetClass:;  GetActAddClass = res;  return;end;globalprocedure FillPlanWithPrevValues(record ProdPlanIDVc PPIDr,                               array longint arProdNr,                               array longint arProdOpNr,                               array integer arCustPrio,                               array integer arProdPrio,                               vector longint vMotherProdNode,                               array longint tarMotherProdNr,                               array longint tarMotherProdNode,                               array longint arDueDays,                               array string arMach,                               vector longint vReservProdNode,                               array longint tarReservProdNr,                               array longint tarReservProdNode,                               array record TempProdPlanVc arProdPlanr,                               array record MachineShiftVc arShiftr,                               array date arStartdate,                               array date arEnddate,                               array time arStarttime,                               array time arEndtime,                               array longint arMotherPos,                               array longint arDur,                               longint tarMothercnt,                               var longint tarReservcnt,                               vector integer vProdNrOpCnt,                               var integer prodarcnt,                               var longint arcnt,                               string sessid,                               date gsd,                               time gst,                               var longint pos)begin  longint minpos;  integer mini;  array string 20 TardMachine;  array integer arInsertedOp;  array longint arGainSetupTime;  record MachineShiftVc Shiftr;  record ProdPlanRecVc PPr;  record ProdOperationVc ProdOpr;  record TempProdPlanVc Tempr,Temp2r;  date FinStartDate,FinEndDate,mdate;  time FinStartTime,FinEndTime,mtime;  boolean savef;  integer rw,rwc,i,j,insertcnt;  string 255 tstr;  time wstart,wend;  longint dur;  string 50 PrevOpCode,PrevRouteCode,wt;  date sd,ed;  longint maxweeknr,wnr;  boolean Trhs,IsAfterMother,foundf;  sd = PPIdr.PlanDate;  LogText(0,"recalc weeks " & PPIdr.RecalcWeeks);  PPr.PlanID = PPIDr.SerNr;  trhs = true;  insertcnt = 0;  While LoopKey("PlanID",PPr,1,Trhs) begin    if (PPr.PlanID <> PPIDr.SerNr) then begin      TrHs = false;    end else begin      wnr = GetWeekNr(PPr.StartDate,"",maxweeknr);      wt = wnr;      if (SetinSet(wt,PPIdr.RecalcWeeks) or PPr.FreezeFlag==1) then begin        for (i = 0; i < arcnt; i = i + 1) begin          if (arProdOpNr[i]==PPr.ProdOpNr) then begin            mini = i;            j = i;            While arProdOpNr[arMotherPos[j]]>0 begin              ProdOPr.SerNr = arProdOpNr[arMotherPos[j]];              if (ReadFirstMain(ProdOPr,1,true)) then begin                mdate = PPr.StartDate;                mtime = PPr.StartTime;                AddTempProdPlanBlock(arMotherPos[j],arProdNr,arProdOpNr,arCustPrio,arProdPrio,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,arDueDays,                             arGainSetupTime,TardMachine,arMach,vReservProdNode,tarReservProdNr,tarReservProdNode,arProdPlanr,arShiftr,arStartdate,                             arEnddate,arStarttime,arEndtime,arDur,tarMothercnt,tarReservcnt,vProdNrOpCnt,arMotherPos[j],prodarcnt,ProdOpr,sessid,mdate,mtime,FinStartDate,                             FinEndDate,finStartTime,FinEndTime,gsd,gst,true,PrevOpCode,PrevRouteCode,IsAfterMother,1);                pos = pos  + 1;                j = arMotherPos[j];              end;            end;            ProdOPr.SerNr = arProdOpNr[i];            if (ReadFirstMain(ProdOPr,1,true)) then begin              mdate = PPr.StartDate;              mtime = PPr.StartTime;              AddTempProdPlanBlock(i,arProdNr,arProdOpNr,arCustPrio,arProdPrio,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,arDueDays,                             arGainSetupTime,TardMachine,arMach,vReservProdNode,tarReservProdNr,tarReservProdNode,arProdPlanr,arShiftr,arStartdate,                             arEnddate,arStarttime,arEndtime,arDur,tarMothercnt,tarReservcnt,vProdNrOpCnt,mini,prodarcnt,ProdOpr,sessid,mdate,mtime,FinStartDate,                             FinEndDate,finStartTime,FinEndTime,gsd,gst,true,PrevOpCode,PrevRouteCode,IsAfterMother,2);              pos = pos  + 1;              i = prodarcnt;            end;          end;        end;      end;    end;  end;  return;end;globalprocedure FillPlanWithCalendar(array record TempProdPlanVc arProdPlanr,array record MachineShiftVc arShiftr,var integer prodarcnt,string sessid,date gsd,time gst)begin  record MachineShiftVc Shiftr;  record ProdOperationVc ProdOpr;  record TempProdPlanVc Tempr,Temp2r;  record ActVc Actr;  record AT2UnitVc AT2Unitr;  record MachineGroupsBlock MachineGroupsbl;  row MachineGroupsBlock MachineGroupsrw;  integer rw,rwc,pos,i,j;  string 255 mainc,tstr,altmachines;  boolean Trhs;  integer lenclass;  date startdate,tdate;  boolean savef,testf;  longint readrecs,ddif,maxdays,usedrecs;  integer calltime;  date FinStartDate,FinEndDate,blankd;  time finStartTime,FinEndTime;  string 20 acttype,PrevOpCode,PrevRouteCode;  time wstart,wend,mtime;  date mdate;  longint dur;  boolean res,IsAfterMother;  calltime = 1;  startdate = "01.01.2010";  tdate = "31.12.2020";  maxdays = 365;  acttype = "";  res = false;  for (rw = 0; rw <prodarcnt; rw = rw + 1) begin    Tempr = arProdPlanr[rw];    AT2Unitr.InventoryNr = tempr.MachineID;    if (ReadFirstMain(AT2Unitr,1,true)) then begin      lenclass = 4;      While (lenclass>=0) begin        ResetLoop(Actr);        Actr.InventoryNr = AT2Unitr.InventoryNr;        Actr.TodoFlag = 0;        Actr.TransDate = startdate;        switch (lenclass) begin          case 4: Actr.TransDate = blankd;          case 3: Actr.TransDate = AddDay(Actr.TransDate,-366);          case 2: Actr.TransDate = AddDay(Actr.TransDate,-31);          case 1: Actr.TransDate = AddDay(Actr.TransDate,-7);          case 0: ;        end;        Actr.LengthClass = lenclass;        TrHs = true;        While (LoopKey("InventoryNr",Actr,3,TrHs)) begin          readrecs = readrecs + 1;          if ((Actr.InventoryNr!=AT2Unitr.InventoryNr)) then begin TrHs = false; end;          if ((Actr.TodoFlag!=0)) then begin TrHs = false; end;          if ((Actr.LengthClass!=lenclass)) then begin TrHs = false; end;          if ((TrHs)) then begin            testf = true;            if ((blankdate(Actr.EndDate))) then begin              if ((Actr.TransDate<startdate)) then begin testf = false; end;            end else begin              ddif = DateDiff(Actr.TransDate,startdate);              if ((Actr.EndDate<startdate)) then begin testf = false; end;            end;            if ((Actr.CalTimeFlag==0)) then begin testf = false; end;            if ((Actr.Invalid!=0)) then begin testf = false; end;            if ((Actr.PrivateFlag!=0)) then begin testf = false; end;            if ((Actr.CalTimeFlag!=calltime)) then begin testf = false; end;            if ((nonblank(acttype))) then begin              if ((Actr.ActType!=acttype)) then begin testf = false; end;            end;            if ((testf)) then begin              usedrecs = usedrecs + 1;              if (blank(Actr.EndDate)) then begin                dur = DateDiff(tdate,Actr.TransDate);              end else begin                dur = DateDiff(Actr.EndDate,Actr.TransDate);              end;              dur = dur * 3600 * 24;              dur = dur - TimeToSeconds2(Actr.StartTime);              dur = dur + TimeToSeconds2(Actr.EndTime);              wstart = "00:00:00";              wend = "24:00:00";              FinStartDate = Actr.TransDate;              FinStartTime = Actr.StartTime;              Shiftr = arShiftr[GetIndexByMachine(Actr.InventoryNr,arShiftr,prodarcnt)];              CalcAddTempProdPlan(Tempr,Shiftr,-1,-1,1,Actr.Comment,GetActAddClass(Actr.ActType),dur,mdate,mtime,"","",savef,true,FinStartDate,FinEndDate,finStartTime,FinEndTime,gsd,gst,PrevOpCode,PrevRouteCode,true,"",0,IsAfterMother);              arProdPlanr[rw]=Tempr;              queued.StoreTempPlanRec(Tempr,Temp2r,savef);            end;          end;        end;        lenclass = lenclass - 1;      end;      res = true;    end;  end;  return;end;globalfunction boolean CalcEffectivness(string sessid,var string nextrec,date gsd,time gst,var boolean breakf)begin  record TempProdPlanVc Tempr,Temp2r;  row TempProdPlanVc Temprw;  boolean res;  longint tottime,acttime,ttime;  integer rw,rwc;  date StartDate,EndDate;  time wstart,wend;  val v1,v2,v3;  boolean testf;    StartDate = gsd;  wstart = "01:00:00";  wend = "23:00:00";  EndDate = AddDay(gsd,3);  Tempr.SessionID = sessid;  Tempr.MachineID = nextrec;  tottime = DateDiff(EndDate,StartDate) * 24 * 3600 - (TimeToSeconds2(TimeDiff("00:00:00",wstart))+TimeToSeconds2(TimeDiff(wend,"24:00:00")));;  acttime = 0;  res = false;  if (ReadFirstKey("SessionID",Tempr,2,false)) then begin    if (Tempr.SessionID == sessid) then begin      rwc = MatRowCnt(Tempr);      for (rw =0; rw < rwc; rw = rw + 1) begin        MatRowGet(Tempr,rw,Temprw);        testf = true;        if (Temprw.Type<>0) then begin          testf = false;        end;        if (Temprw.StartDate < startDate) then begin          testf = false;        end;        if (Temprw.EndDate > EndDate) then begin          testf = false;        end;        ttime = (DateDiff(temprw.EndDate,Temprw.StartDate) * 24 * 3600);        ttime = ttime - TimeToSeconds2(Temprw.StartTime)+TimeToSeconds2(Temprw.EndTime);        ttime = ttime - DateDiff(temprw.EndDate,Temprw.StartDate) * (TimeToSeconds2(TimeDiff("00:00:00",wstart))+TimeToSeconds2(TimeDiff(wend,"24:00:00")));        acttime = acttime + ttime;      end;      RecordCopy(Temp2r,Tempr);      v1 = acttime;      v2 = tottime;      v3 = v1/v2 * 100;      Tempr.Comment = "Eq(m) = " & Round(v3,SetRoundModeD(3));      queued.StoreTempPlanRec(Tempr,Temp2r,false);      if (LoopKey("SessionID",Tempr,2,true)) then begin        if (LoopKey("SessionID",Tempr,2,true)) then begin          nextrec = Tempr.MachineID;          res = true;        end;      end;    end;  end;  CalcEffectivness = res;  return;end;procedure StoreProdPlanRecs(array record TempProdPlanVc arProdPlanr,var integer prodarcnt,date effectenddate,array record MachineShiftVc arShiftr)begin  record MachineShiftVc Shiftr;  record TempProdPlanVc Tempr;  row TempProdPlanVc Temprw;  row MachineShiftVc Shiftrw;  record AT2UnitVc AT2Unitr;  record MachineGroupsBlock MachineGroupsbl;  row MachineGroupsBlock MachineGroupsrw;  string 20 mainc;  integer fcnt;  val tcoef;  longint wrkcnt;  integer rw,rwc,pos,i,j,rwcnt;  longint startnr;  BlockLoad(MachineGroupsbl);  startnr = NextSerNr("TempProdPlanVc",CurrentDate,-1,false,"");  for (rw = 0; rw <prodarcnt; rw = rw + 1) begin    Tempr=arProdPlanr[rw];    if (NonBlankDate(effectenddate)) then begin      Shiftr = arShiftr[rw];      rwcnt = MatRowCnt(Shiftr);      wrkcnt = 0;      if (DateDiff(effectenddate,CurrentDate)<rwcnt) then begin        rwcnt = DateDiff(effectenddate,CurrentDate);      end;      for (j = 0; j < rwcnt; j = j + 1) begin        MatRowGet(Shiftr,j,Shiftrw);        wrkcnt = wrkcnt + TimeToSeconds2(Shiftrw.EndTime) - TimeToSeconds2(Shiftrw.StartTime);      end;      Tempr.EffectCoef = Tempr.EffectCoef / wrkcnt * 100;      if (Tempr.EffectCoef>100) then begin Tempr.EffectCoef=100; end;    end;    Tempr.SerNr = startnr;    startnr = startnr + 1;    LogText(0,"Storing record " & tempr.SerNr);    qupdating.StoreTempPlanRec(Tempr,Tempr,true);  end;  return;end;globalprocedure FillShiftDays(record MachineShiftVc Shiftr,record AT2UnitVc AT2Unitr,longint dcnt,date fromdate)begin  record WebPlanDefBlock WebPlanDefBl;  record MachineHoursVc MHr;  record BHollVc BHollr;  record MachineGroupsBlock MGBl;  record CYBlock CYBl;  record MachineHoursChangesVc MHCr;  row MachineGroupsBlock MGrw;  row MachineShiftVc Shiftrw;  date td;  string 255 wgroup,atcode;  integer i,weekday,rw,rwc,cnt;  val hours;  boolean foundf,bhollf,FoundChange;  time tt,st,et;    td = fromdate;  BlockLoad(WebPlanDefBl);  tt = "00:00:00";  BlockLoad(MGBl);  rwc = MatRowCnt(MGBl);  foundf = false;  MHr.InventoryNr = AT2Unitr.InventoryNr;  if (ReadFirstKey("InventoryNr",MHr,1,true)) then begin    foundf= true;    wgroup = "";    atcode = AT2Unitr.InventoryNr;  end;  for (rw = 0; rw < rwc; rw = rw + 1) begin    MatRowGet(MGBl,rw,MGrw);    if (SetInset(AT2Unitr.InventoryNr,MGrw.DefStr)) then begin      wgroup = MHr.Code;      if (!foundf) then begin        MHr.Code = MGrw.Code;        if (ReadFirstKey("Code",MHr,1,true)) then begin          foundf = true;          rw = rwc;        end;      end;    end;  end; // if (!foundf) then begin  if (true) then begin     MHr.SerNr = WebPlanDefBl.DefaultHours;    foundf = ReadFirstMain(MHr,1,true);    wgroup = MHr.Code;  end;  BlockLoad(CYbl);  BHollr.CountryCode = CYbl.CountryCode;  bhollf = ReadFirstMain(BHollr,1,true);  for (i = 0; i < dcnt; i = i + 1) begin    ClearRow(Shiftr,Shiftrw,1);    if (foundf) then begin      weekday = GetDateId(td);      if (foundChange) then begin        if (DateInRange(td,MHCr.StartDate,MHCr.EndDate)==false) then begin          foundChange = false;        end;      end else begin        MHCr.InventoryNr = AT2Unitr.InventoryNr;        MHCr.StartDate = td;        if (ReadFirstKey("InventoryNr",MHCr,2,false)) then begin          if (DateInRange(td,MHCr.StartDate,MHCr.EndDate) and MHCr.InventoryNr == AT2Unitr.InventoryNr) then begin            foundChange = true;          end;        end;        if (!foundChange) then begin          MHCr.Code = wgroup;          MHCr.StartDate = td;          if (ReadFirstKey("Code",MHCr,2,false)) then begin            if (MHCr.Code == wgroup) then begin              if (DateInRange(td,MHCr.StartDate,MHCr.EndDate)) then begin                foundChange = true;              end;            end;          end;        end;      end;      hours = 0;      if (foundChange) then begin        switch weekday begin          case 1: Shiftrw.StartTime = MHCr.MonStart; hours = MHCr.MonEnd;          case 2: Shiftrw.StartTime = MHCr.TueStart; hours = MHCr.TueEnd;          case 3: Shiftrw.StartTime = MHCr.WedStart; hours = MHCr.WedEnd;          case 4: Shiftrw.StartTime = MHCr.ThuStart; hours = MHCr.ThuEnd;          case 5: Shiftrw.StartTime = MHCr.FriStart; hours = MHCr.FriEnd;          case 6: Shiftrw.StartTime = MHCr.SatStart; hours = MHCr.SatEnd;          case 7: Shiftrw.StartTime = MHCr.SunStart; hours = MHCr.SunEnd;        end;      end else begin        switch weekday begin          case 1: Shiftrw.StartTime = MHr.MonStart; hours = MHr.MonEnd;          case 2: Shiftrw.StartTime = MHr.TueStart; hours = MHr.TueEnd;          case 3: Shiftrw.StartTime = MHr.WedStart; hours = MHr.WedEnd;          case 4: Shiftrw.StartTime = MHr.ThuStart; hours = MHr.ThuEnd;          case 5: Shiftrw.StartTime = MHr.FriStart; hours = MHr.FriEnd;          case 6: Shiftrw.StartTime = MHr.SatStart; hours = MHr.SatEnd;          case 7: Shiftrw.StartTime = MHr.SunStart; hours = MHr.SunEnd;        end;      end;      if (blanktime(Shiftrw.StartTime)) then begin Shiftrw.StartTime = "00:00:00"; end;      Shiftrw.EndTime = AddHours(Shiftrw.StartTime,hours);      if (Shiftrw.EndTime==tt and hours <> 0) then begin Shiftrw.EndTime = "23:59:00"; end;    end else begin      Shiftrw.StartTime = "01:00:00";      Shiftrw.EndTime = "23:00:00";    end;    MatRowPut(Shiftr,i,Shiftrw);    td = AddDay(td,1);  end;  rwc = MatRowCnt(Shiftr);  st = "00:00:00";  et = "23:59:00";  for (rw = rwc-1; rw >= 0;rw = rw - 1) begin    MatRowGet(Shiftr,rw,Shiftrw);    if (Shiftrw.StartTime==st and       Shiftrw.EndTime==et) then begin      cnt = cnt + 1;      Shiftrw.RepeatCnt = cnt;      MatRowPut(Shiftr,rw,Shiftrw);    end else begin      cnt = 0;      Shiftrw.RepeatCnt = 0;      MatRowPut(Shiftr,rw,Shiftrw);      st = Shiftrw.StartTime;      et = Shiftrw.EndTime;    end;  end;  return;end;procedure BuildProdMachineAr(array record TempProdPlanVc arProdPlanr,array record MachineShiftVc arShiftr,var integer prodarcnt,string sessid)begin  record WebPlanDefBlock WebDefBl;  record TempProdPlanVc Tempr;  record MachineShiftVc Shiftr;  record AT2UnitVc AT2Unitr;  record MachineGroupsBlock MachineGroupsbl;  longint dcnt;  row MachineGroupsBlock MachineGroupsrw;  string 20 mainc;  integer rw,rwc,pos,i,j;  BlockLoad(MachineGroupsbl);  rwc = MatRowCnt(MachineGroupsbl);  BlockLoad(WebDefBl);  dcnt = 30 * WebDefBl.ViewMonths;  While LoopMain(AT2Unitr,1,true) begin//  While LoopKey("ProdInventoryNr",AT2Unitr,1,true) begin//jzs-combine//    if (AT2Unitr.ProdMachineID<>"") then begin      RecordNew(Tempr);      Tempr.SessionID = sessid;      Tempr.MachineID = AT2Unitr.InventoryNr;      arProdPlanr[prodarcnt]=Tempr;      Shiftr.MachineID = AT2Unitr.InventoryNr;      FillShiftDays(Shiftr,AT2Unitr,dcnt,CurrentDate);      arShiftr[prodarcnt] = Shiftr;      prodarcnt = prodarcnt + 1;//    end;  end;  return;end;procedure BuildSwtichingTimeAr(vector val arSwitchTime)begin  record ProdSwitchTimeVc PSr;  While LoopMain(PSr,1,true) begin    if (PSr.Closedf <> 1) then begin      arSwitchTime[PSr.Machine & "+" & PSr.FromOperation & "+" & PSr.ToOperation & "+" &  PSr.FromRoute & "+" & PSr.ToRoute] = PSr.Coef;    end;  end;  return;end;procedure BuildExpVector(vector val vExpValue)begin  integer i,l;  val v,step;  l = 100;  v = 0;  step = 0.1;  for (i = 0; i < l; i = i + 1) begin    vExpValue[v] = exp(v);    v = v + step;  end;  return;end;procedure InsertEqIntoRoutingNodeAr(longint StartWithNr,array string arEqMachine,array string arEqRoutingRow,array longint arNextEqMachine,var longint arEqCnt,string InsertMachine,string insertRoutingRow)begin  longint curnr;    curnr = StartWithNr;  While arNextEqMachine[curnr] <> -1 begin    if ((arEqMachine[curnr] <> InsertMachine or arEqRoutingRow[curnr]<>insertRoutingRow) and        (insertRoutingRow=="" or (insertRoutingRow<>"" and arEqRoutingRow[curnr]<>""))) then begin      curnr = arNextEqMachine[curnr];    end else begin      Goto LSkipMachineInsert;    end;  end;  arNextEqMachine[curnr] = arEqCnt;  arEqMachine[arEqCnt] = InsertMachine;  arEqRoutingRow[arEqCnt] = InsertRoutingRow;  arEqCnt = arEqCnt + 1;LSkipMachineInsert:;  return;end;procedure InsertProdNrIntoNodeAr(longint StartWithNr,array longint tarMotherProdNr,array longint tarMotherProdNode,var longint tarMotherCnt,longint InsertNr)begin  longint curnr;    curnr = StartWithNr;  While tarMotherProdNode[curnr] <> -1 begin    if (tarMotherProdNr[curnr] <> InsertNr) then begin      curnr = tarMotherProdNode[curnr];    end else begin      goto LSkipNodeInsert;    end;  end;  tarMotherProdNode[curnr] = tarMotherCnt;  tarMotherProdNr[tarMotherCnt] = InsertNr;  tarMotherCnt = tarMotherCnt + 1;LSkipNodeInsert:;  return;end;procedure CheckMotherNodes(longint frompos,longint searchnr,vector longint vMotherProdNode,array longint tarMotherProdNr,array longint tarMotherProdNode,var longint tarMothercnt,var boolean res,integer depth)begin  longint curnr;    curnr = frompos;  While curnr <> -1 begin    if (tarMotherProdNr[curnr] <> searchnr) then begin      if (depth < 3) then begin        CheckMotherNodes(vMotherProdNode[curnr],searchnr,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,tarMothercnt,res,depth+1);        if (!res) then begin          Goto LSkipNodeValidate;        end;      end;      curnr = tarMotherProdNode[curnr];    end else begin      res = false;      Goto LSkipNodeValidate;    end;  end;LSkipNodeValidate:;  return;end;function boolean ValidateToSerNr(longint sernr,longint fromsernr,vector longint vMotherProdNode,array longint tarMotherProdNr,array longint tarMotherProdNode,var longint tarMothercnt)begin  record ProdOrderVc ProdOrderr;  record ProdOperationVc ProdOpr;  boolean res;    res = true;  CheckMotherNodes(vMotherProdNode[sernr],fromsernr,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,tarMothercnt,res,0);  if (res) then begin    ProdOrderr.SerNr = sernr;    res = false;    if (ReadFirstMain(ProdOrderr,1,true)) then begin      ProdOpr.ProdOrdNr = ProdOrderr.SerNr;      if (ReadFirstKey("ProdOrdNr",ProdOpr,1,true)) then begin        res = true;      end;    end;    if (!res) then begin      Logtext(0,"Warning: ProdOrder doesn't have an operation " & sernr);    end;  end;  ValidateToSerNr = res;  return;end;procedure BuildMotherProdAr(array longint arProdOrderNr,longint cnt,                            vector longint vMotherProdNode,array longint tarMotherProdNr,array longint tarMotherProdNode,var longint tarMothercnt,                            vector longint vOrgMotherProdNode,array longint tarOrgMotherProdNr,array longint tarOrgMotherProdNode,var longint tarOrgMothercnt,                            vector longint vReservProdNode,array longint tarReservProdNr,array longint tarReservProdNode,var longint tarReservcnt)begin//  record BRStockReservVc Resr;  integer i;  boolean Trhs,foundf,testf;    //jzs-combine  /*  for (i = 0;i < cnt; i = i + 1) begin    if (vMotherProdNode[arProdOrderNr[i]]<=0) then begin      if (vMotherProdNode[arProdOrderNr[i]]<>-2) then begin        //find all reservations        ResetLoop(Resr);        Resr.FromFileName = 2;        Resr.FromSerNr = arProdOrderNr[i];        Resr.Donef = 0;        TrHs = true;        foundf = false;        While LoopKey("FromItem",Resr,3,TrHs) begin          if (Resr.FromFileName <> 2 or             Resr.FromSerNr <> arProdOrderNr[i] or             Resr.Donef <> 0) then begin            TrHs = false;          end else begin            if (Resr.ToFileName==6) then begin              testf = ValidateToSerNr(Resr.ToSerNr,Resr.FromSerNr,vMotherProdNode,tarMotherProdNr,tarMotherProdNode,tarMothercnt);              if (testf) then begin                if (vMotherProdNode[arProdOrderNr[i]] <=0) then begin                //creating entry pointer for each production order                //building list of orders that need to be finished before                //this order can be done                  vMotherProdNode[arProdOrderNr[i]] = tarMotherCnt;                  vOrgMotherProdNode[arProdOrderNr[i]] = tarOrgMotherCnt;//readonly original                  tarMotherProdNr[tarMotherCnt] = Resr.ToSerNr;                  tarOrgMotherProdNr[tarOrgMotherCnt] = Resr.ToSerNr;                  tarMotherProdNode[tarMotherCnt] = -1;                  tarOrgMotherProdNode[tarOrgMotherCnt] = -1;                  tarMotherCnt = tarMotherCnt + 1;                  tarOrgMotherCnt = tarOrgMotherCnt + 1;                end else begin                  InsertProdNrIntoNodeAr(vMotherProdNode[arProdOrderNr[i]],tarMotherProdNr,tarMotherProdNode,tarMotherCnt,Resr.ToSerNr);                  InsertProdNrIntoNodeAr(vOrgMotherProdNode[arProdOrderNr[i]],tarOrgMotherProdNr,tarOrgMotherProdNode,tarOrgMotherCnt,Resr.ToSerNr);                end;                if (vReservProdNode[Resr.ToSerNr] <=0) then begin                  vReservProdNode[Resr.ToSerNr] = tarReservCnt;                  tarReservProdNr[tarReservCnt] = arProdOrderNr[i];                  tarReservProdNode[tarReservCnt] = -1;                  tarReservCnt = tarReservCnt + 1;                end else begin                  InsertProdNrIntoNodeAr(vReservProdNode[Resr.ToSerNr],tarReservProdNr,tarReservProdNode,tarReservCnt,arProdOrderNr[i]);                end;                foundf = true;              end else begin                LogText(0,"WARNING " & Resr.ToSerNr & " << " & Resr.FromSerNr );              end;            end;          end;        end;        if (!foundf) then begin          vMotherProdNode[arProdOrderNr[i]] = -2;          vOrgMotherProdNode[arProdOrderNr[i]] = -2;        end;      end;    end;  end;*/  return;end;procedure BuildEqMachineVector(array record MachineShiftVc arShiftr,vector longint vEqMachine,array string arEqMachine,array string arEqRoutingRow,array longint arNextEqMachine,integer prodarcnt,var longint arEqCnt)begin  record ProdMachineEqVc EQPlantr;  record MachineShiftVc Shiftr;  string 200 eq;  integer i;  boolean Trhs;  for (i = 0; i < prodarcnt; i = i + 1) begin    ResetLoop(EQPlantr);    Shiftr = arShiftr[i];    eq = "";    EQPlantr.Code = Shiftr.MachineID;    TrHs = true;    while(loopMain(EQPlantr,1,TrHs)) begin      if ((EQPlantr.Code != Shiftr.MachineID)) then begin        TrHs = false;      end;      if (TrHs) then begin        if (vEqMachine[Shiftr.MachineID] <= 0) then begin          vEqMachine[Shiftr.MachineID] = arEqCnt;          arEqMachine[arEqCnt] = EQPlantr.ProdEqCode;          arEqCnt = arEqCnt + 1;        end else begin          InsertEqIntoRoutingNodeAr(vEqMachine[Shiftr.MachineID],arEqMachine,arEqRoutingRow,arNextEqMachine,arEqCnt,EQPlantr.ProdEqCode,"")        end;      end;    end;    ResetLoop(EQPlantr);    EQPlantr.ProdEqCode = Shiftr.MachineID;    TrHs = true;    while (LoopKey("ProdEqCode",EQPlantr,1,TrHs)) begin      if (EQPlantr.ProdEqCode != Shiftr.MachineID) then begin        TrHs = false;      end;      if (TrHs) then begin        if (vEqMachine[Shiftr.MachineID] <= 0) then begin          vEqMachine[Shiftr.MachineID] = arEqCnt;          arEqMachine[arEqCnt] = EQPlantr.Code;          arEqCnt = arEqCnt + 1;        end else begin          InsertEqIntoRoutingNodeAr(vEqMachine[Shiftr.MachineID],arEqMachine,arEqRoutingRow,arNextEqMachine,arEqCnt,EQPlantr.Code,"")        end;      end;    end;  end;  return;end;/*procedure BuildRoutingEqMachineVector(array record MachineShiftVc arShiftr,vector longint vEqMachine,array string arEqMachine,array string arEqRoutingRow,array longint arNextEqMachine,integer prodarcnt,var longint arEqCnt)begin  vector string 20 vRowAT;  record RoutingVc Router;  record BREqvUnitVc EqvUnitr;  record MachineShiftVc Shiftr;  row RoutingVC Routerw;  string 200 eq;  integer i,rw,rwc;  boolean Trhs;  boolean firstf;  While LoopMain(Router,1,true) begin    if (Router.Closed<>1 and (Router.ValidTo>CurrentDate or blankdate(Router.ValidTo))) then begin      ResetLoop(EqvUnitr);      EqvUnitr.RouteCode = Router.Code;      Trhs = true;      firstf = true;      While LoopKey("RowNr",EqvUnitr,1,TrHs) begin        if (EqvUnitr.RouteCode<>Router.Code) then begin          TrHs = false;        end else begin          if (firstf) then begin            rwc = MatRowCnt(Router);            for (rw = 0; rw < rwc; rw = rw + 1) begin              MatRowGet(Router,rw,Routerw);              vRowAT[Routerw.Sequence] = Routerw.Machine;            end;            firstf = false;          end;          if (vEqMachine[vRowAT[EqvUnitr.RowNr]]<=0) then begin            vEqMachine[vRowAT[EqvUnitr.RowNr]] = arEqCnt;            arEqMachine[arEqCnt] = EqvUnitr.AT2UnitCode;            arEqRoutingRow[arEqCnt] = Router.Code & ":" & EqvUnitr.RowNr;            arEqCnt = arEqCnt + 1;          end else begin            InsertEqIntoRoutingNodeAr(vEqMachine[vRowAT[EqvUnitr.RowNr]],arEqMachine,arEqRoutingRow,arNextEqMachine,arEqCnt,EqvUnitr.AT2UnitCode,Router.Code & ":" & EqvUnitr.RowNr)          end;        end;      end;    end;  end;  return;end;*/global updatingprocedure StoreDebugNoteRecs()begin  area f;  record ProdOperationVc ProdOPr;  record NotePadVc Noter,tNoter;  record RLinkVc RLr;  string 255 tstr,valstr;  boolean testf;  string 20 statstr;  longint l;  integer rw,notenr;    OpenFile("debug.txt");  While testeof==false begin    tstr = ImportField;    statstr = ImportField;    if (statstr=="o") then begin      LineTextPut(Noter,rw,tstr & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField & chr(9) & ImportField );      rw = rw + 1;    end else begin      ProdOPr.SerNr = tstr;      if (ReadFirstMain(ProdOpr,1,true)) then begin        notenr = 1;        while (ReadRecordLink(ProdOpr,notenr,tNoter,RLr)) begin          if (tNoter.Classification == "DEBUG") then begin            RecordDelete(tNoter);          end;          notenr = notenr + 1;        end;        Noter.SerNr = NextSerNr("NotePadVc",CurrentDate,-1,false,"");        Noter.Classification = "DEBUG";        if (RecordStore(Noter,true)) then begin          CreaterecordLink(ProdOPr,CurrentCompany,Noter,CurrentCompany);        end;      end;      RecordNew(Noter);    end;    testf = NextImportLine(false);  end;  closefile;  return;end;globalprocedure GenProdPlanRecsTask(string parstr)begin  string 20 sessid;  string 20 planr;  transaction string 10 tardchecks;  transaction string 10 wtimeChecks;  transaction string 10 gAddPlanCnt;  record ProdPlanCoefBlock ProdPlanCoefbl;  record WebPlanDefBlock WebDefbl;  array record TempProdPlanVc arProdPlanr;  array record MachineShiftVc arShiftr;  integer prodarcnt;  date cdate;  //to have the number of unassigned prodops for any given prodnr  vector integer vProdNrOpCnt;  //to be able to take out a done reserved production  vector longint vReservProdNode;  array longint tarReservProdNr;  array longint tarReservProdNode;  longint tarReservcnt;  //to have the whole list of productions that are needed to be finished to start the current production  vector longint vMotherProdNode;  array longint tarMotherProdNr;  array longint tarNextMotherProdNode;  longint tarMothercnt;  vector longint vOrgMotherProdNode;  array longint tarOrgMotherProdNr;  array longint tarOrgNextMotherProdNode;  longint tarOrgMothercnt;  vector val vExpValue;  vector longint vEqMachine;  array string 20 arEqMachine;  array longint arNextEqMachine;  array string 50 arEqRoutingRow;  longint EqCnt;  array longint arProdOrderNr;  array longint arProdNr;  array longint arProdOpNr;  array longint arSetup;  array longint arDur;  array longint arMotherProdOpNr;  array longint arMotherPos;  array longint arTotQueueTime;  array longint arChildCount;  array longint arDueDays;  array string 20 arMach;  array date arStartdate;  array date arEnddate;  array time arStarttime;  array time arEndtime;  array integer arCustPrio;  array integer arProdPrio;  array string 20 arProdOPCode,arProdRoute;  array integer arProdOpRowNum;  vector val arSwitchTime;  array longint arGainSetupTime;  array date arEarliestDate;  array date arTempStartdate,arTempEnddate;  array time arTempStarttime,arTempEndtime;  array integer arTempRecVersion;  vector integer vMachineQueVersion;  array record NotePadVc arDebugNoter;  record NotePadVc Noter;  date gsd;  time gst;  boolean breakf;  longint cnt,pos;  string 20 nextrec;  integer rownr,i;  time st,et;  record ProdPlanSessionVc ProdSesr;  record ProdOperationVc lastProdOpr;  record TempProdPlanVc Tempr;  record ProdPlanIDVc PIdr;  date effectenddate;  boolean foundplan,testf;  boolean forcef;  transaction string 1 gDebugLevel;  val pl;  longint pl2;    roundmode rm;  breakf = false;  cdate = "";  cdate.year = 1000+1012;  cdate.month = 12;  cdate.day = 10+20;  LogText(0,"parameter : " & parstr);  gDebugLevel = "";  Delete_File("debug.txt");  if (FileExists("EnProdPlanDebug")) then begin    gDebugLevel = "1";  end;  sessid = FirstInRange(parstr,20);  planr = LastInRange(parstr,20);  PIdr.SerNr = planr;  foundplan = ReadFirstMain(PIdr,1,true);  BlockLoad(ProdPlanCoefbl);  BlockLoad(WebDefbl);  if (WebDefbl.EffectWeekCnt > 0) then begin    effectenddate = AddDay(CurrentDate,-GetDateId(CurrentDate)+1);    effectenddate = AddDay(effectenddate,7*WebDefbl.EffectWeekCnt-1);  end;  if (cdate < CurrentDate) then begin    breakf = true;  end;  st = CurrentTime;  qupdating.UpdateSessionRec(sessid,"Step 1 of 5 <br> deleting old records ",0,breakf);// updating session status  qupdating.RemoveOldTempRecs;//1st step - delete previous temp production plans  qupdating.UpdateSessionRec(sessid,"Step 2 of 5 <br> building array ",0,breakf);// updating session status  BuildProdOpAr(arProdNr,arProdOPNr,arProdOrderNr,arMotherProdOpNr,arSetup,                arDur,arMach,arMotherPos,arCustPrio,arProdPrio,                arProdOPCode,arProdRoute,arProdOpRowNum,arTotQueueTime,arChildCount,arDueDays,vProdNrOpCnt,arEarliestDate,cnt);//gather all the operations that are to be included  //build node list of productions and reservations needed to be fulfilled to make the current production  tarMotherCnt = 1;  tarOrgMotherCnt = 1;  tarReservCnt = 1;  BuildMotherProdAr(arProdOrderNr,cnt,                    vMotherProdNode,tarMotherProdNr,tarNextMotherProdNode,tarMothercnt,                    vOrgMotherProdNode,tarOrgMotherProdNr,tarOrgNextMotherProdNode,tarOrgMothercnt,                    vReservProdNode,tarReservProdNr,tarReservProdNode,tarReservcnt);  prodarcnt = 0;  //gather all machines to be included and their working times  BuildProdMachineAr(arProdPlanr,arShiftr,prodarcnt,sessid);  BuildSwtichingTimeAr(arSwitchTime);  if (ProdPlanCoefbl.UseEqMachines==1) then begin    EqCnt = 1;    BuildEqMachineVector(arShiftr,vEqMachine,arEqMachine,arEqRoutingRow,arNextEqMachine,prodarcnt,EqCnt);    //if (ProdPlanCoefbl.UseRouteEqMachines==1) then begin    //  BuildRoutingEqMachineVector(arShiftr,vEqMachine,arEqMachine,arEqRoutingRow,arNextEqMachine,prodarcnt,EqCnt);    //end;  end;  gsd = CurrentDate;  gst = CurrentTime;  rownr = 0;  FillPlanWithCalendar(arProdPlanr,arShiftr,prodarcnt,sessid,gsd,gst);  pos = 0;  if (foundplan) then begin    LogText(0,"Inserting nonrecalculable values");    FillPlanWithPrevValues(PIdr,arProdNr,arProdOpNr,arCustPrio,arProdPrio,vMotherProdNode,tarMotherProdNr,tarNextMotherProdNode,arDueDays,                           arMach,vReservProdNode,tarReservProdNr,tarReservProdNode,arProdPlanr,arShiftr,arStartdate,arEnddate,                           arStarttime,arEndtime,arMotherPos,arDur,tarMothercnt,tarReservcnt,vProdNrOpCnt,prodarcnt,cnt,sessid,gsd,gst,pos);  //nonrecalc values should be entered in GenProdPlanRecs and takn out of "todo" list for production plan  end;  //calculating records into array  i = 0;  BuildExpVector(vExpValue);  qupdating.UpdateSessionRec(sessid,"Step 3 of 5 <br> Calculating records",0,breakf);  rm = SetRoundModeD(1);  forcef = false;  While (GenProdPlanRecs(arProdPlanr,arShiftr,prodarcnt,sessid,                         arProdNr,arProdOPNr,arProdOrderNr,arMotherProdOpNr,arSetup,                         arDur,arMach,arMotherPos,arCustPrio,arProdPrio,                         arStartdate,arEnddate,arStarttime,arEndtime,                         arProdOPCode,arProdRoute,arProdOpRowNum,arSwitchTime,vEqMachine,arEqMachine,arEqRoutingRow,arNextEqMachine,EqCnt,                         arTotQueueTime,arChildCount,arDueDays,arEarliestDate,                         vMotherProdNode,tarMotherProdNr,tarNextMotherProdNode,tarMothercnt,                         vOrgMotherProdNode,tarOrgMotherProdNr,tarOrgNextMotherProdNode,tarOrgMothercnt,                         vReservProdNode,tarReservProdNr,tarReservProdNode,tarReservcnt,                         vProdNrOpCnt,                         cnt,pos,gsd,gst,ProdPlanCoefbl,vExpValue,rm,effectenddate,forcef,                         arTempStartdate,arTempEnddate,arTempStarttime,arTempEndtime,arTempRecVersion,vMachineQueVersion)) begin    i = i + 1;    if (i > 10) then begin      ProdSesr.SessionID = sessid;      if (readFirstMain(ProdSesr,1,true)) then begin        if (ProdSesr.StatusFlag==2) then begin          Logtext(0,"-=======Break=======-");          goto LExitTask;        end;      end;      pl =TimeDiffInSeconds(gst,currentTime);      pl = pos / pl;      qupdating.UpdateSessionRec(sessid,"Step 3 of 5 <br> Calculating record " & pos & " of " & cnt & "<br>" & "Average speed : " & ValToString(pl,M4Val,"",".",0) & " records per second",0,breakf);      i = 0;    end else begin    end;  end;  for (i = 0; i < cnt; i = i + 1) begin    testf = true;    if (arProdNr[i] <= 0) then begin      testf = false;    end;    if (arMotherPos[i] >= 0) then begin      if (arProdNr[arMotherPos[i]] > 0) then begin     //   testf = false;      end;    end;    if (arProdOrderNr[i] > 0 and testf) then begin      if (vMotherProdNode[arProdOrderNr[i]] > 0) then begin    //    testf = false;        //there are still dependencies not solved for this production      end;    end;    if (testf) then begin      LogText(0,"still not done " & arProdNr[i]);    end;  end;  qupdating.UpdateSessionRec(sessid,"Step 4 of 5 <br> Storing Temporary Producation Plan",0,breakf);  StoreProdPlanrecs(arProdPlanr,prodarcnt,effectenddate,arShiftr);  if (gDebugLevel<>"") then begin    LogText(0,"Storing debug array");    qupdating.StoreDebugNoteRecs;  end;  if (breakf) then begin goto LExitTask; end;  nextrec = "";  qupdating.UpdateSessionRec(sessid,"done",1,breakf);// last step - finalize session status recordLExitTask:;  //Endjob;  et = CurrentTime;  LogText(0,"Process done in " & TimeDiffInSeconds(st,et) & " seconds");  LogText(0,"Tardiness checks : " & tardchecks);  LogText(0,"Work Time Checks : " & wtimeChecks);  LogText(0,"AddPlan Checks   : " & gAddPlanCnt);  return;end;globalprocedure TestProdRepRn(record RcVc RepSpec)begin  string 255 tstr;  StartReportJob("");;  EndHeader;  GenProdPlanRecsTask(tstr);  EndJob;  return;end;global webpublicprocedure WebGenProdPlanRecsTask()begin  string 255 tstr;    tstr = GetSessionString("prodsessionid");  GenProdPlanRecsTask(tstr);  WebOutString("<div class='sessid'>" & tstr & "</div>");  return;end;