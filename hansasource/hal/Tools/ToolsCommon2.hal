external function string 255 LetVcDoReplaceTokenEmailValidation(record RcVc,string);
external function string 255 LetVcDoReplaceTokenHWIDUser(record RcVc,string);
external function string 255 ReplaceCharByString(string,string,string);
external function string 255 GetFirstCompanyCountryCode();
forward function Integer InString2(string,string);
external function Boolean HasTouchScreenLook();
external function roundmode GetTotalRoundMode(record RoundBlock);
external procedure StripSpace(var string,string);
external function LongInt DateDiff(Date,Date);
external procedure GetCourseStr(record CourseVc,var string,var string,var string, string, var boolean);
external function string 255 GetWebHostAndPort2(boolean);
external function string 255 LetVcDoReplaceTokenResetPassword(record RCVc,string);

forward function string 255 RemoveStringFromString(string,string);

global
procedure StartDataTransfer(string partner,var Area request)
begin
  AddLongToArea(0,request);
  AddTextToArea(chr(13) & chr(10),request);
  AddTextToArea("53.0" & chr(9),request); // General Version number
  AddTextToArea(partner & chr(9),request); 
  AddTextToArea(BuildProductCode & chr(9),request); 
  if (IsStandardProduct) then begin
    AddTextToArea(GetFirstCompanyCountryCode & chr(9),request); 
  end else begin
    AddTextToArea("" & chr(9),request); 
  end;
  AddTextToArea(ProgramVersion & chr(9),request); 
  AddTextToArea(IsStandardProduct & chr(9),request); 
  if (IsStandardProduct) then begin
    AddTextToArea(ProductVATLaw & chr(9),request); 
  end else begin
    AddTextToArea("" & chr(9),request); 
  end;
  AddTextToArea(RunningBuild & chr(9),request); 
  AddTextToArea(chr(13) & chr(10),request);
  return;
end;

global
procedure SendTextParameter(string astr,var Area request)
begin
  AddTextToArea(astr & chr(9),request);
  return;
end;

global
procedure SendDateParameter(Date d,var Area request)
begin
  AddTextToArea(DateToString(d,"YYYY-MM-DD") & chr(9),request);
  return;
end;

global
procedure SendTimeParameter(Time t,var Area request)
begin
  AddTextToArea("" & t.hour & ":" & t.minute & ":" & t.second & chr(9),request);
  return;
end;

global
procedure SendValParameter(val v,var Area request)
begin
  AddTextToArea(ValToString(v,M4Val,"",".",0) & chr(9),request);
  return;
end;

global
procedure EndDataTransfer(var Area request)
begin
  PutLongInArea(GetAreaLength(request)-4,request,0);    
  return;
end;

global
procedure SendFunctionVersion(string funcversion,string partner,var Area request)
begin
  AddTextToArea(funcversion & chr(9),request); // Function Version number
  AddTextToArea(partner & chr(9),request);
  AddTextToArea(chr(13) & chr(10),request);
  return;
end;

global
procedure SendEOLParameter(var Area request)
begin
  AddTextToArea(chr(13) & chr(10),request);
  return;
end;

global 
function Boolean IsLiveHTS()
begin
  record HTSTestServerBlock HTSTSb;
  
  BlockLoad(HTSTSb);
  if (HTSTSb.ThisIsTestTX==0) then begin
    IsLiveHTS = true;
  end else begin
    IsLiveHTS = false;
  end;
  return;
end;

global
procedure WSLogLength(string service,LongInt srvstart)
begin
  record HTSTestServerBlock HTSTSb;
  LongInt l;
  string 255 tstr;
  
  BlockLoad(HTSTSb);
  if (HTSTSb.TestTX!=0) then begin
    tstr = "Service " & service;
    tstr = tstr & " lasted ";
    l = GetCurTick - srvstart;
    tstr = tstr & l;
    tstr = tstr & " milliseconds.";
    LogText(0,tstr);
  end;
  return;
end;

global
procedure ReverseString(string text,var string rtext)
begin
  Integer i,l;
  
  rtext = "";
  l = len(text);
  for (i=l-1;i>=0;i=i-1) begin
    rtext = rtext & Mid(text,i,1);
  end;
  return;
end;

global
procedure AddNLToMail(record MailVc Mailr)
begin
  if (windowsMode==0) then begin
    AddToText(Chr(13),Mailr);
  end else begin
    AddToText(Chr(10),Mailr);
    AddToText(Chr(13),Mailr);
  end;
  return;
end;

global
procedure AddTextLineToMail(string txt,record MailVc Mailr)
begin
  AddToText(txt,Mailr);
  AddNLToMail(Mailr);
  return;
end;

global
procedure AddNLToLetter(record LetVc Letr)
begin
  if (windowsMode==0) then begin
    AddToText(Chr(13),Letr);
  end else begin
    AddToText(Chr(10),Letr);
    AddToText(Chr(13),Letr);
  end;
  return;
end;

global
procedure AddTextLineToLetter(string txt,record LetVc Letr)
begin
  AddToText(txt,Letr);
  AddNLToLetter(Letr);
  return;
end;

global
function Integer GetVATLaw()
BEGIN
  record CYBlock cyr;

  BlockLoad(cyr);
  GetVATLaw = cyr.VATLaw;
  RETURN;
END;

global
procedure DblDigit(var string tstr,Integer v)
BEGIN
  Integer t;
  string 1 c;
  
  t = Mod(v/10,10) + 48;
  c = chr(t);
  tstr = c;
  t = Mod(v,10) + 48;
  c = chr(t);
  tstr = tstr & c;
  RETURN;
END;

global
procedure FinnishBankDate(var string res,Date td)
BEGIN
  string 255 tstr;

  DblDigit(res,GetYear(td));
  DblDigit(tstr,GetMonth(td));
  res = res & tstr;
  DblDigit(tstr,GetDay(td));
  res = res & tstr;
  RETURN;
END;

global
procedure FinnishBankVal(var string tstr,val vp)
BEGIN
  val nv;
  
  nv = vp*100;
  tstr = ValToString(nv,M40Val,"","",0);//  tstr = nv; in 6.1 this puts thousand separator
//  tstr = Left(tstr,len(tstr)-3);//ValToString is enough
  RETURN;
END;

global
procedure FinnishRebDate(val pdvrebt,Date invdate,LongInt pdrdays,var string res)
BEGIN
  Date td;
  
  res = "";
  if (pdvrebt!=0) then begin
    td = AddDay(invdate,pdrdays);
    FinnishBankDate(res,td);
  end;  
  RETURN;  
END;

global
procedure FinnishRebVal(val pdvrebt,val Sum1,val Sum4,var string res)
BEGIN
  val tv,t100;
  record RoundBlock RoundRec;
  record AccBlock atr;
  
  res = "";
  if (pdvrebt!=0) then begin    
    BlockLoad(atr);
    BlockLoad(RoundRec);  
    t100 = 100;
    if (atr.DiscCashVAT!=0) then begin
      tv = t100 - pdvrebt;
      tv = Sum1*tv;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      tv = Sum1 - tv;
    end else begin
      tv = t100 - pdvrebt;
      tv = Sum4*tv;
      tv = tv/100;
      tv = Round(tv,GetTotalRoundMode(RoundRec));
      tv = Sum4 - tv;
    end;
    res = tv;
  end;
  RETURN;             
END;

global
procedure M4PadString(string instr,Integer padlen,string padchar,Boolean padleft,var string res)
BEGIN
  string 255 tstr,t2;
  Integer i;
  Integer toff;
  
  toff = 0;
  res = "";
  for (i = 1; i<=padlen ;i=i+1) begin tstr = tstr & padchar; end;
  if (padleft) then begin
    tstr = tstr & instr;
    tstr = Right(tstr,(len(tstr)-len(instr)));    
  end else begin
    t2 = tstr;
    tstr = instr;
    tstr = tstr & t2;
    tstr = Left(tstr,padlen);
  end;
  res = tstr;
  RETURN;
END;

global
procedure M4ILMidstr(string ostr,var string res,Integer pos,Integer l)
BEGIN
  Integer tc,ill,lp;
  string 255 tstr;

  lp = pos-1;
  ill = len(ostr);
L11LOOPBEGIN:
  if (tc>=l) then begin
    goto L22LOOPEND;
  end;
  if (lp>ill) then begin
    goto L22LOOPEND;
  end;  
  tstr = tstr & Mid(ostr,lp,1);
  lp = lp + 1;
  tc = tc + 1;
  goto L11LOOPBEGIN;
L22LOOPEND:
  res = tstr;
  RETURN;
END;

global
function string 255 CreateInvoiceNumber(LongInt InvNr,string OfficialSerNr)
begin
  string 255 res;
  string 255 tstr;
  Integer i,l;
  
  switch (GetVATLaw) begin
/*
    case vatSAF: // Not for SAF, should possibly be for Argentina instead.
      tstr = InvNr;
      if (len(tstr)<9) then begin
        res = tstr;
        goto LCreateInvoiceNumber;
      end;
      switch (Left(tstr,1)) begin
        case "1":
          res = "A";
        case "2":
          res = "B";
        case "3":
          res = "C";
        case "4":
          res = "E";
        case "9":
          res = "Z";
        otherwise
          res = tstr;
          goto LCreateInvoiceNumber;
      end;
      res = res & "-";
      res = res & "00";
      res = res & Mid(tstr,1,1);
      res = res & Mid(tstr,2,1);
      res = res & "-";
      res = res & "00";      
      l = len(tstr)+2;
      for (i=6;i<=l;i=i+1) begin
        res = res & Mid(tstr,i-2,1);
      end;
*/
    otherwise
      res = InvNr;
  end;
  if (IsStandardProduct) then begin
    if (HasLocalization("POL")) then begin
      res = OfficialSerNr;
    end;
  end;
LCreateInvoiceNumber:;  
  CreateInvoiceNumber = res;
  return;
end;

global
procedure InitDateRange(var Date sDate,var Date eDate,Record RcVc RepSpec)
begin
  switch (RepSpec.flags[0]) begin
   case 0:  sDate = RepSpec.sStartDate;
            eDate = RepSpec.sStartDate;
   case 1:  sDate = addDay(RepSpec.sStartDate,-GetDateID(RepSpec.sStartDate)+1);
            eDate = addDay(sDate,6);
   case 2:  sDate = addDay(RepSpec.sStartDate,-GetDay(RepSpec.sStartDate)+1);
            eDate = addMonth(sDate,1);
  end;
  return;
end;

global
procedure UpdateDateRange(var Date sDate,var Date eDate,Record RcVc RepSpec)
begin

  switch (RepSpec.flags[0]) begin
    case 0:
      sDate = addDay(sDate,1);
      eDate = addDay(eDate,1);
    case 1:
      sDate = addDay(sDate,7);
      eDate = addDay(eDate,7);
    case 2:
      sDate = addMonth(sDate,1);
      eDate = addMonth(eDate,1);
  end;
  
  return;
end;

global
procedure In2Period(var string ps,var Date sd,var Date ed)
BEGIN
  In3Period(ps,sd,ed);
  ps = sd;
  ps = ps & ":";
  ps = ps & ed;
/*
  string 255 t1,t2,separator;
  record PeriodBlock PerRec;
  row PeriodBlock perrw;
  Integer i,rwcnt;
  LongInt pos;
  record SysFormatBlock SFb;

  i = 1;
  BlockLoad(SFb);
  BlockLoad(PerRec);
  rwcnt = MatRowCnt(PerRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PerRec,i,perrw);
    if (ps==perrw.CodeStr) then begin
      sd = perrw.FromDate;
      ed = perrw.ToDate;
      goto L99In2Period;
    end;
  end;
//  t1 = FirstInRange(ps,10);
//  t2 = LastInRange(ps,10);
  separator = RemoveStringFromString(";:, ",SFb.dateSep);
  pos = 0;
  GetNextSubstring(ps,pos,separator,t1);
  GetNextSubstring(ps,pos,separator,t2);
  if (blank(t1)) then begin
  end else begin
    sd = StringToDate(t1);
  end;
  if (blank(t2)) then begin
    ed = sd;
  end else begin
    ed = StringToDate(t2);
  end;
L99In2Period:;
  ps = sd;
  ps = ps & ":";
  ps = ps & ed;
*/  
  RETURN;
END;

global
function Boolean TouchScreenLook()
begin
  Boolean res;
/*
  record LocalMachineBlock LocalMachineRec;

  BlockLoad(LocalMachineRec);
  if (LocalMachineRec.TouchScreenLook!=0) then begin res = true; end;
*/  
  res = HasTouchScreenLook;
//  if (GuiType==kGuiiPhone or GuiType==kGuiAndroid) then begin res = true; end;
  TouchScreenLook = res;
  return;
end;

global
function Boolean TouchScreenLookVertical()
begin
  record LocalMachineBlock LMb;
  Boolean res;
  
  BlockLoad(LMb);
  res = LMb.TouchScreenLook2!=0;
  
  TouchScreenLookVertical = res;  
  return;
end;

global
procedure GetProgramName(var string res)
BEGIN
  string 255 tstr;
  Integer pt;
  
  pt = ProgramType;
  switch (pt) begin
    case typHansaWorldSMB: tstr = USetStr(20450); 
    case typHansaWorld: tstr = USetStr(1889);
    case typPurplesoftERP: tstr = USetStr(1889);
    case typPAYYAPERP: tstr = USetStr(1889);
    case typStandardERP: tstr = USetStr(1889);
    case typRussianStandard: tstr = USetStr(1889);
    case typFinancials: tstr = USetStr(1890); 
    case typClassic: tstr = USetStr(1891); 
    case typProfessional: tstr = USetStr(1892); 
    case typHansaRaama: tstr = USetStr(1893); 
    case typFirstOfficeASP: tstr = USetStr(1899);
    
    case typFirstOffice: tstr = USetStr(1894); 
    case typFirstOfficeCurrency: tstr = USetStr(1888);
    case typFirstOfficePro: tstr = USetStr(1888);
    case typFirstOfficeSmall: tstr = USetStr(1894); 

    case typBooks: 
      if (IsStandardProduct) then begin
//        tstr = BuildProductCode;
        tstr = USetStr(1802);
      end else begin
        tstr = USetStr(22300);
      end;
    case typBooksPro: tstr = USetStr(22301);
    case typBooksProAdv: tstr = USetStr(22302);
    case typBooksJobCost: tstr = USetStr(22303);
    case typBooksAcc: tstr = USetStr(22304);
    case typBooksPOS: tstr = USetStr(22305);

    case typClassicLit: tstr = USetStr(1891); 
    case typRiigiTarkvara: tstr = USetStr(1895); 
    case typOffice2: tstr = USetStr(1896); 
    case typOffice2TB: tstr = USetStr(1896); 
    case typFirstContact: tstr = USetStr(1897); 
    case typFirstOfficePro: tstr = USetStr(1888); 
    case typBusinessPhone: tstr = USetStr(20451);
    case typBusinessOrganizer: tstr = USetStr(20452);
    case typCRMBasic: tstr = USetStr(1802);
    case typHWMoney: tstr = USetStr(1802);
    case typPOSStandalone: tstr = USetStr(1802);
    case typStandardOrganizer: tstr = USetStr(1802);
    case typStandardCommunicator: tstr = USetStr(1802);
    case typStandardCRM: tstr = USetStr(1802);
    case typStdAccounts: tstr = USetStr(1802);
    case typStdBar: tstr = USetStr(1802);
    case typStdContracts: tstr = USetStr(1802);
    case typStdHotel: tstr = USetStr(1802);
    case typStdInvoicing: tstr = USetStr(1802);
    case typStdNominalLedger: tstr = USetStr(1802);
    case typStdProjects: tstr = USetStr(1802);
    case typStdRentals: tstr = USetStr(1802);
    case typStdRestaurant: tstr = USetStr(1802);
    case typStdShop: tstr = USetStr(1802);
    case typStdStock: tstr = USetStr(1802);
    case typStdConferences: tstr = USetStr(1802);
    case typStdDocuments: tstr = USetStr(1802);
    case typStdExpenses: tstr = USetStr(1802);
    case typStdHR: tstr = USetStr(1802);
    case typStdCRMServer: tstr = USetStr(1802);
    case typStdAccountsServer: tstr = USetStr(1802);
    case typSberbankInvoices: tstr = USetStr(1802);
    case typSberbankStock: tstr = USetStr(1802);
    case typSberbankStockandCRM: tstr = USetStr(1802);
    case typAdmiral: tstr = USetStr(1802);
    case typOBSHousing: tstr = USetStr(1802);
    case typTBAS: tstr = USetStr(1802);
    otherwise
      tstr = USetStr(1889);
  end;
  if (blank(tstr)) then begin
    tstr = USetStr(1802);
  end;
  res = tstr;
  RETURN;
END;

global
function Boolean IsOffice2(Boolean testf)
begin
  Boolean res;

  res = !testf;
  if (ProgramType==typOffice2) then begin res = testf; end;
  if (ProgramType==typOffice2TB) then begin res = testf; end;
  if (ProgramType==typFirstOfficeASP) then begin res = testf; end;
  IsOffice2 = res;
  return;
end;

global
function Boolean IsOffice1(Boolean testf)
begin
  Boolean res;

  res = !testf;
  if (ProgramType==typFirstOffice) then begin res = testf; end;
  if (ProgramType==typFirstOfficeSmall) then begin res = testf; end;
  if (IsBooks) then begin res = testf; end;
  IsOffice1 = res;
  return;
end;

global
Function Boolean GetPD(var Record PDVc PDp)
begin

  Boolean res;
  
  res = true;
  if (ReadFirstMain(PDp,1,true)==false) then begin
    res = ReadFirstMain(PDp,1,false);
    res = false;
  end;
  GetPD = res;
  return;
end;

function Boolean GetPayDealStr(record PDVc PDr,Integer tnr,string langcod2,string deftext,var string resstr)
begin
  Boolean res;
  Integer i,rwcnt;
  row PDVc PDrw;
  Integer hcnt;
  String 5 langcode;
  Boolean hitf;
  
  res = false;
  hcnt = 0;
  langcode = langcod2;
  if (nonblank(langcode)) then begin
    hitf = false;
    rwcnt = MatRowCnt(PDr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PDr,i,PDrw);
      if (langcode==PDrw.LangCode) then begin
        hitf = true;
      end;
    end;
    if (hitf==false) then begin
      langcode = "";
    end;
  end;
  resstr = deftext;
  if (blank(langcode)) then begin 
    hcnt = hcnt + 1; 
  end;
  if ((hcnt==1) and (tnr==1)) then begin
    res = true;
  end else begin
    rwcnt = MatRowCnt(PDr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PDr,i,PDrw);
      if (langcode==PDrw.LangCode) then begin
        hcnt = hcnt + 1;
        if (hcnt==tnr) then begin
          resstr = PDrw.Text;
          res = true;
          i = rwcnt;
        end;
      end;
    end;
  end;
  GetPayDealStr = res;   
  return;
end;

global
procedure GetPayDealText(string paydeal,string langcode,var string res)
BEGIN
  record PDVc PDr;
  Boolean pdflag;
  Integer i,mrwcnt;
  row PMBlock pmrw;
  record PMBlock PMRec;

  PDr.Code = paydeal;
  if (GetPD(PDr)==false) then begin
    BlockLoad(PMRec);
    mrwcnt = MatRowCnt(PMRec);
    for (i = 0; i<mrwcnt; i=i+1) begin
      MatRowGet(PMRec,i,pmrw);
      if (pmrw.Code==paydeal) then begin 
        res = pmrw.Comment;
        goto LGetPayDealText;
      end;
    end;
  end;
  if (GetPayDealStr(PDr,1,langcode,PDr.pdComment,res)) then begin
  end;
LGetPayDealText:;
  RETURN;
END;

global
procedure GetPDVRebt(string paydeal,var val rebtp)
begin
  record PDVc PDr;
  Boolean pdflag;
  
  rebtp = 0;
  PDr.Code = paydeal;
  pdflag = GetPD(PDr);
  if (pdflag) then begin
    rebtp = PDr.pdvrebt;
//    rebtp = PDr.pdvrebt2;
  end;
  return;
end;

global
function Boolean CheckPDExists(string paydeal)
BEGIN
  record PDVc PDr;
  Boolean res;
  
  PDr.Code = paydeal;
  res = ReadFirstMain(PDr,1,true);
  CheckPDExists = res;
  RETURN;
END;

global
function Boolean HasIllegalChar(string taddr)
begin
  Boolean res;
  
  res = false;
  if (InString(taddr," ")!=0) then begin res = true; end;
  if (InString(taddr,",")!=0) then begin res = true; end;
  HasIllegalChar = res;
  return;
end;

global
procedure StripSpace(var string tstr,string ostr)
begin
  LongInt i;
  
  tstr = "";
  for (i=0;i<=len(ostr);i=i+1) begin
    if (Mid(ostr,i,1)!=" ") then begin
      tstr = tstr &  Mid(ostr,i,1);
    end;
  end;
  return;
end;

global
function string 255 StripCharacter(string ostr,string char)
begin
  LongInt i;
  string 255 res;
  
  res = "";
  for (i=0;i<=len(ostr);i=i+1) begin
    if (Mid(ostr,i,1)!=char) then begin
      res = res &  Mid(ostr,i,1);
    end;
  end;
  StripCharacter = res;
  return;
end;

global
function Boolean FindEmbeddedEmail(string s,var LongInt stpos,var LongInt atpos,var LongInt adlen)
begin
  Boolean res;
  Integer i,l;
  string 255 addr;

  res = false;
  
  stpos = -1;
  adlen = -1;
  atpos = -1;
  
  l = len(s);
  
  for (i = 0; i<l; i = i + 1) begin
    if ((stpos<0) and (Mid(s,i,1)=="<")) then begin
      stpos = i;
    end;
    if (Mid(s,i,1)==">") then begin
      adlen = i - stpos + 1;
    end;
    if (Mid(s,i,1)=="@") then begin
      atpos = i;
    end;
  end;
  
  if ((stpos>=0) and (adlen>0)) then begin
    if ((stpos<atpos) and (atpos<(stpos + adlen))) then begin
      res = true;
    end;
    addr = mid(s,stpos + 1,adlen - 2);
  end;
  
  if (res) then begin
    if (HasIllegalChar(addr)) then begin
      res = false;
    end;
  end;
  
  FindEmbeddedEmail = res;
end;

global
function Boolean InterNetAddrTest(string taddr)
begin
  Boolean res;
  //Integer i,l,startpos,atpos,endpos;
  //string 255 tstr,t2;
  LongInt stpos,atpos,adlen;
  string 255 domain;
  
  res = FindEmbeddedEmail(taddr,stpos,atpos,adlen);
  if (res==false) then begin
    if ((atpos>0) and (HasIllegalChar(taddr)==false)) then begin
      res = true;
    end;
  end;
  if (res) then begin
    domain = right(taddr,len(taddr) - atpos - 1);
    if (InString2(domain,".")<=0) then begin
      res = false;
    end;
  end;
  /*
  res = false;
  l = len(taddr);
  for (i=0;i<l;i=i+1) begin
    if ((startpos==0) and (Mid(taddr,i,1)=="<")) then begin
      startpos = i;
    end;
    if (Mid(taddr,i,1)==">") then begin
      endpos = i;
    end;
    if (Mid(taddr,i,1)=="@") then begin
      res = true;
      atpos = i;
    end;
  end;
  
  if ((startpos>0) and (endpos>0)) then begin
    if ((atpos<=startpos) or (endpos<=atpos)) then begin
      res = false;
    end;
    tstr = mid(taddr,startpos + 1,endpos - startpos - 1);
    //stopalert(tstr);
  end;
  
  if (res) then begin
    //StripSpace(tstr,t2);
    if (HasIllegalChar(tstr)) then begin
      res = false;
    end;
  end;
  */
  
  InterNetAddrTest = res;
  return;
end;

global
function Boolean ValidEmailAddress(string as)
begin
  Boolean res;
  Integer i,l;
  string 255 addr,s;
  LongInt stpos,atpos,adlen,qtbegpos,qtendpos;
  
  res = false;
  
  stpos = -1;
  adlen = -1;
  atpos = -1;
  
  s = StripCharacter(as," ");
  l = len(s);
  for (i = 0; i<l; i = i + 1) begin
    if ((stpos<0) and (Mid(s,i,1)=="<")) then begin
      stpos = i;
    end;
    if (Mid(s,i,1)==">") then begin
      adlen = i - stpos + 1;
    end;

    if (Mid(s,i,1)=="""") then begin
      if (qtbegpos<0) then begin
        qtbegpos = i;
      end else begin
        qtendpos = i;
      end;
    end;

    if (Mid(s,i,1)=="@") then begin
      if (atpos>0 and qtendpos<0) then begin
        goto LValidEmailAddress;
      end;
      atpos = i;
    end;
  end;
  
  if ((stpos>=0) and (adlen>0)) then begin
    if ((stpos<atpos) and (atpos<(stpos + adlen))) then begin
      res = true;
    end;
    addr = mid(s,stpos + 1,adlen - 2);
  end else begin
    if (atpos>=0) then begin
      res = true;
    end;
  end;
  if (res) then begin
    if (HasIllegalChar(addr)) then begin
      res = false;
    end;
  end;
LValidEmailAddress:;  
  ValidEmailAddress = res;
end;


global
procedure StripNonChars(var string tstr,string ostr)
BEGIN
  Integer i,l;
  string 1 c;
  
  tstr = "";
  l = len(ostr);
  for (i=0; i<=l;i=i+1) begin
    c = Mid(ostr,i,1);
    if (((c>="a") and (c<="z")) or ((c>="A") and (c<="Z"))) then begin
      tstr = tstr & c;
    end;
  end;
  RETURN;
END;

global
function Integer InString2(string instr,string searchstring)
BEGIN 
  LongInt res;
  LongInt i,j;
  LongInt im,jm;
  string 255 a,b;
  string 1 ca,cb;

  res = -1;
  a = instr;
  b = searchstring;
  if (nonblank(b)) then begin

    jm = len(b);
    im = len(a);
    im = im - jm + 1;
    for (i = 0 ; i<im ; i=i+1) begin
      for (j = 1 ; j<=jm ;j=j+1) begin
        ca = Mid(a,i+j-1,1);
        cb = Mid(b,j-1,1);
        if (ca!=cb) then begin
          goto LInStringSkip; 
        end;
      end;
      res = i;      
      goto LInString;
LInStringSkip:;
    end;
    res = -1;
  end;
LInString:;
  InString2 = res;
  RETURN;
END;

global
function Integer InString3(string instr,string searchstring)
begin 
  LongInt res;
  LongInt i,j;
  LongInt im,jm;
  string 255 a,b;
  string 1 ca,cb;

  res = -1;
  a = searchstring;
  b = instr;
  if (nonblank(a)) then begin
    jm = len(b);
    im = len(a);
    im = im - jm + 1;
    for (i = 0 ; i<im ; i=i+1) begin
      for (j = 1 ; j<=jm ;j=j+1) begin
        ca = Mid(a,i+j-1,1);
        cb = Mid(b,j-1,1);
        if (ca!=cb) then begin
          goto LInString3Skip; 
        end;
      end;
      res = i;      
      goto LInString3;
LInString3Skip:;
    end;
    res = -1;
  end;
LInString3:; 
  InString3 = res;
  return;
end;

global
function string 255 RemoveStringFromString(string orgstr,string removestr)
begin
  Integer where;
  string 255 res;
  Integer l;
  
  res = orgstr;
  where = InString2(res,removestr);
  while (where>=0) begin
    l = len(res)-len(removestr)-where;
    if (l<len(removestr)) then begin l = 0; end;
    res = Left(res,where) & Right(res,l);
    where = InString2(res,removestr);
  end;
  RemoveStringFromString = res;
  return;
end;

procedure SplitStarStrs(string tstr,var string t1,var string t2,var LongInt starposp)
BEGIN
  LongInt i,l;
  string 1 c;
  Boolean L22SplitStarStrs,L33SplitStarStrs,L44SplitStarStrs,LSplitStarStrs;
  
  l = len(tstr);
  t1 = "";
  t2 = "";
  starposp = 0;
  i=0;
  while ((i<l) and (L22SplitStarStrs==false)) begin
    c = Mid(tstr,i,1);  
//    if (c=="*") then begin goto L22SplitStarStrs; end;
    if (c=="*") then begin 
      L22SplitStarStrs = true; 
    end else begin
      t1 = t1 & c;
      i = i + 1;
    end;  
  end;
  
  if (L22SplitStarStrs==false) then begin
//    goto LSplitStarStrs;  
    LSplitStarStrs = true;
  end;
//L22SplitStarStrs:;  
  if (LSplitStarStrs==false) then begin
    while ((i<l) and (L33SplitStarStrs==false)) begin
      c = Mid(tstr,i,1);  
//    if (c!="*") then begin goto L33SplitStarStrs; end;
      if (c!="*") then begin 
        L33SplitStarStrs = true; 
      end else begin
        i = i + 1;
      end;
    end;
    if (L33SplitStarStrs==false) then begin
//      goto LSplitStarStrs;
      LSplitStarStrs = true;
    end;  
//L33SplitStarStrs:;
    if (LSplitStarStrs==false) then begin
    
      starposp = i;
      while ((i<=l) and (L44SplitStarStrs==false)) begin
        c = Mid(tstr,i,1);  
//    if (c=="*") then begin goto L44SplitStarStrs; end;
        if (c=="*") then begin 
          L44SplitStarStrs = true; 
        end else begin
          t2 = t2 & c;
          i = i + 1;
        end;
      end;
    end;  
  end;  
//L44SplitStarStrs:;
//LSplitStarStrs:;
  RETURN;
END;

global
function Boolean StarMatch(string searchstr,string tstr)
BEGIN
  Boolean res;
  string 255 t0,t1,t2;
  LongInt starpos,i;
  string 1 c;
  
  res = true;
  SplitStarStrs(searchstr,t1,t2,starpos);
  
  if (len(t1)>len(tstr)) then begin
    res = false;
    goto LStarMatch;
  end;
  t0 = tstr;
  t0 = Left(tstr,len(t1));

  if (t0!=t1) then begin
    res = false;
    goto LStarMatch;
  end;  
  t0 = "";
  for (i=starpos-1;i<=len(tstr);i=i+1) begin
    c = Mid(tstr,i,1);  
    t0 = t0 & c;
  end;  
  if (nonblank(t2)) then begin
    if (InString2(t0,t2)<0) then begin  
      res = false;
      goto LStarMatch;
    end;
  end;  
LStarMatch:;
  StarMatch = res;
  RETURN;
END;

global
procedure AddCharsToString(var string tstr,string c,Integer qty)
BEGIN
  LongInt i;
  string 255 res;

  res = "";
  for (i=0;i<=qty;i=i+1) begin
    res = res & c;
  end;
  res = Left(res,i-1);//res[0] = i-1;
  res = res & tstr;
  tstr = res;
  RETURN;
END;

global
function Boolean IsDigit(string c)
BEGIN
  Boolean res;
  
  if (asc(c)>=asc("0")) and (asc(c)<=asc("9")) then begin
    res = true;
  end;
  IsDigit = res;
  return;
end;

global
function boolean IsNumeric(string s)
begin
  integer i;
  boolean res;
  
  res = true;
  for (i=0;i<len(s);i=i+1) begin
    if (IsDigit(mid(s,i,1))==false) then begin
      res = false;
      i = len(s)+1;
    end;
  end;
  
  IsNumeric = res;
  return;
end;

global
function Boolean IsCapitalLetter(string c)
begin
  Boolean res;
  
  if (asc(c)>=asc("A")) and (asc(c)<=asc("Z")) then begin
    res = true;
  end;
  IsCapitalLetter = res;
  return;
end;

global
function Boolean IsLetter(string c)
begin
  Boolean res;
  
  if (asc(c)>=asc("A")) and (asc(c)<=asc("Z")) or
     (asc(c)>=asc("a")) and (asc(c)<=asc("z")) then begin
    res = true;
  end;
  IsLetter = res;
  RETURN;
END;

global
function string 255 removenextlistitem(var string tstr,string delimiter)
begin
  integer l;
  string 255 res;

  l = InString(tstr,delimiter);
  if (l!=0) then begin
    res = left(tstr,l-1);
    tstr = mid(tstr,l,255);
  end else begin
    res = tstr;
    tstr = "";
  end;
  removenextlistitem = res;
  return;
end;

global
function string 255 removenextnode(var string tstr)
begin
  removenextnode = removenextlistitem(tstr,"/");
  return;
end;

global
function string 255 GetNextValue(var string tstr)
begin
  GetNextValue = removenextlistitem(tstr,",");
  return;
end;

global
procedure ExplodeString(string inputstr,string delimiter,var array string a_str,var Integer a_cnt)
begin
  string 255 minputstr,element;
  
  a_cnt = 0;
  minputstr = inputstr;
  element = removenextlistitem(minputstr,delimiter);
  while (nonblank(element)) begin
    a_str[a_cnt] = element;
    a_cnt = a_cnt + 1;
    element = removenextlistitem(minputstr,delimiter);
  end;
  
  return;
end;

global
function string 255 LetVcDoReplaceToken(record RcVc RepSpec,string token)
begin
  string 255 res,recname,field;
  LongInt pos;
  record CUVc CUr;
  record UserVc Userr;
  record CYBlock CYb;
  record GCVc GCr;
  record ORVc ORr;
  record SHVc SHr;
  record IVVc IVr;
  record CourseEventVc CourseEventr;
  record CourseVc Courser;
  string 255 name,description,length;
  Boolean translated;

  pos = -1;
  GetNextSubString(token,pos,".",recname);
  GetNextSubString(token,pos,".",field);
  
  switch (recname) begin
    case "CUr":
      CUr.Code = RepSpec.f1;
      if (ReadFirstMain(CUr,1,true)==false) then begin goto LLetVcReplaceToken; end;
      switch (field) begin
         case "Name": res = CUr.Name;
         case "InvAddr0": res = CUr.InvAddr0;
         case "InvAddr1": res = CUr.InvAddr1;
         case "InvAddr2": res = CUr.InvAddr2;
         case "InvAddr3": res = CUr.InvAddr3;
         case "InvAddr4": res = CUr.InvAddr4;
         case "Phone": res = CUr.Phone;
         case "eMail": res = CUr.eMail;
         case "RegNr2": res = CUr.RegNr2;
         case "RegNr1": res = CUr.RegNr1;
         case "VATNr": res = CUr.VATNr;
         case "Comment0": res = CUr.Comment0;
         case "Person": res = CUr.Person;
         case "MarketUserName": res = CUr.MarketUserName;
         case "Password": res = RepSpec.f3;
         case "Comment": res = CUr.Comment;
         case "UUID": res = CUr.UUID;
      end;
    case "EVr":
      res = LetVcDoReplaceTokenEmailValidation(RepSpec,field);
    case "PSr":
      res = LetVcDoReplaceTokenResetPassword(RepSpec,field);
    case "HWIDUserr":
      res = LetVcDoReplaceTokenHWIDUser(RepSpec,field);
    case "GCr":
      GCr.SerNr = StringToLongInt(RepSpec.f2);
      if (ReadFirstMain(GCr,1,true)==false) then begin goto LLetVcReplaceToken; end;
      switch (field) begin
         case "SerNr": res = GCr.SerNr;
      end;
    case "Userr":
      Userr.Code = RepSpec.f2;
      if (ReadFirstMain(Userr,1,true)==false) then begin goto LLetVcReplaceToken; end;
      switch (field) begin
         case "Name": res = Userr.Name;
      end;
    case "CYb":
      BlockLoad(CYb);
      switch (field) begin
         case "CompName": res = CYb.CompName;
      end;
    case "CustomerUUID":
      CUr.Code = RepSpec.f1;
      if (ReadFirstMain(CUr,1,true)==false) then begin goto LLetVcReplaceToken; end;
      res = "?id=" & CUr.UUID;
    case "ValidationUUID":
      res = LetVcDoReplaceTokenHWIDUser(RepSpec,"ValidationUUID");
    case "ServerHttpPort":
      res = ServerHttpPort;
    case "ServerHttpsPort":
      res = ServerHttpsPort;
    case "ForumLink":
      res = RepSpec.f4;
    case "ORr":
      ORr.SerNr = StringToLongint(RepSpec.f12);
      if (ReadFirstMain(ORr,1,true)) then begin
        switch (field) begin
          case "SerNr": res = ORr.SerNr;
          //case "ItemList":// This we have to think about in the future to add either html or plain items to the letter
        end;
      end;
    case "IVr":
      IVr.SerNr = StringToLongint(RepSpec.f12);
      if (ReadFirstMain(IVr,1,true)) then begin
        switch (field) begin
          case "SerNr": res = IVr.SerNr;
          //case "ItemList":// This we have to think about in the future to add either html or plain items to the letter
        end;
      end;
    case "SHr":
      SHr.SerNr = StringToLongint(RepSpec.f12);
      if (ReadFirstMain(SHr,1,true)) then begin
        switch (field) begin
          case "SerNr": res = SHr.SerNr;
          case "OrderNr": res = SHr.OrderNr;
          //case "ItemList":// This we have to think about in the future to add either html or plain items to the letter
        end;
      end;
    case "CourseEventr":
      CourseEventr.SerNr = RepSpec.long2;
      if (ReadFirstMain(CourseEventr,1,true)) then begin
        Courser.Code = CourseEventr.CourseCode;
        if (ReadFirstMain(Courser,1,true)) then begin
          switch (field) begin
            case "Name": GetCourseStr(Courser,name,description,length,RepSpec.f11,translated); res = name;
            case "Date": res = CourseEventr.TransDate; if (CourseEventr.TransDate!=CourseEventr.EndDate) then begin res = res & " - " & CourseEventr.EndDate; end;
            case "StartTime": res = CourseEventr.StartTime;
            case "EndTime": res = CourseEventr.EndTime;
          end;
        end;
      end;
    case "TraceNo":
      res = "http://" & GetWebHostAndPort2(false) & "/WebRecordMailView.hal?t=act&s=" & RepSpec.long2 & "&cc=" & RepSpec.f1;
    case "RegLink"://to get registration link from validation server
      res = RepSpec.f2;
    case "newpassword":
      res = RepSpec.f3;
    case "Language":
      res = RepSpec.f10;
    case "ServerUUID":
      res = RepSpec.f6;
    case "BuildNo":
      res = RepSpec.f7;
    case "ServerIPAddress":
      res = RepSpec.f8;
    case "ServerTCPPort":
      res = RepSpec.f9;
  end;
  
LLetVcReplaceToken:;
  LetVcDoReplaceToken = res;
end;

global
function string 255 LetVcReplaceToken(record LetVc Letr,record RcVc RepSpec,string token)
begin
  LetVcReplaceToken = LetVcDoReplaceToken(RepSpec,token);
end;

global
function string 255 EMailQueVcReplaceToken(record EMailQueVc EMailQuer,record RcVc RepSpec,string token)
begin
  EMailQueVcReplaceToken = LetVcDoReplaceToken(RepSpec,token);
end;

global
function string 255 ReplaceCharacterSeries(string ostr,string chars,string reptstr) // Replace any of the characters listed in: chars with reptstr
begin
  LongInt i;
  string 255 res,tstr;
  
  res = ostr;
  for (i=0;i<=len(chars);i=i+1) begin
    res = ReplaceCharByString(res,Mid(chars,i,1),reptstr);
  end;
  ReplaceCharacterSeries = res;
  return;
end;

global
function string 255 RemoveStringFromString2(string orgstr,string removestr) // Concatenates the remain string once it finds a matching sting.
begin
  string 255 res,chunk;
  Integer l,m,i;
  
  m = len(removestr);
  l = len(orgstr);
  for (i=0;i<l;i=i+1) begin
    if (i+m >= l) then begin
      goto LParser;
    end;
    chunk = Mid(orgstr,i,m);
    if (chunk==removestr) then begin
      res = res & Mid(orgstr,i+m,len(chunk));
      i = i + len(chunk);
    end else begin
      res = res & Mid(orgstr,i,1);
    end;
  end;
LParser:;  
  RemoveStringFromString2 = res;
  return;
end;

global
function LongInt GetLegalInvoiceNr(row LegalInvNrBlock LINrbrw,string OfficialSerNr)
begin
  string 255 res;

  res = Right(OfficialSerNr,len(OfficialSerNr)-len(LINrbrw.Serie));
  GetLegalInvoiceNr = StringToLongInt(res);
  return;
end;

global
function string 255 GetLegalInvoiceNrString(row LegalInvNrBlock LINrbrw,string OfficialSerNr)
begin
  string 255 res;

  res = Right(OfficialSerNr,len(OfficialSerNr)-len(LINrbrw.Serie));
  GetLegalInvoiceNrString = res;
  return;
end;

global
function string 255 GetLegalInvoiceNrSerie(row LegalInvNrBlock LINrbrw,string OfficialSerNr)
begin
  string 255 res;

  res = Left(OfficialSerNr,len(LINrbrw.Serie));
  GetLegalInvoiceNrSerie = res;
  return;
end;

global
function Boolean LegalRecordNumberInRange(string nr,string seriestart,string serieend)
begin
  Boolean res,testfstartf;
  Integer i;
  string 255 c,cs,ce;
  
  res = true;
  if (len(nr)<len(seriestart)) then begin
    res = false;
    goto LLegalRecordNumberInRange;
  end;
  if (len(nr)>len(serieend)) then begin
    res = false;
    goto LLegalRecordNumberInRange;
  end;
  testfstartf = true;
  for (i=0;i<len(seriestart);i=i+1) begin
    c = Mid(nr,i,1);
    cs = Mid(seriestart,i,1);
    ce = Mid(serieend,i,1);
    if (c!=cs and len(nr)==len(seriestart)) then begin
      if (testfstartf) then begin
        if (c<cs) then begin
          res = false;
          goto LLegalRecordNumberInRange;
        end;
        if (c>cs) then begin
          testfstartf = false;
        end;
      end;
    end;
    if (c!=ce and len(nr)==len(serieend)) then begin
      if (c>ce) then begin
        res = false;
        goto LLegalRecordNumberInRange;
      end;
    end;
  end;
  
LLegalRecordNumberInRange:;  
  LegalRecordNumberInRange = res;
  return;
end;
