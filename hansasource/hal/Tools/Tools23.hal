external function Boolean HasMultiCurrency();
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode DefaultRoundMode();
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure MulVATIV2(string,val,var val,var val,Integer,Integer,Boolean);

global
procedure MulM4ProcVal(val ap,val bp,var val cp)
begin
  val v1,v2;
  
  if (bp==0) then begin
    cp = 0;
  end else begin 
    v1 = ap*bp;
    v2 = v1 / 100;
    if (v2<0) then begin
      cp = -Round(-v2,DefaultRoundMode);
    end else begin
      cp = Round(v2,DefaultRoundMode);
    end;
  end;  
  return;
end;

global
procedure StripEndingSpaces(var string res)
begin
  Integer i,l;
  string 255 tstr;
    
  tstr = res;
  l = len(tstr);

  for (i = l; i>=1; i = i - 1) begin
    if (mid(tstr,i - 1,1)<>" ") then begin
      goto L88;
    end;
  end;
L88:;  
  if (i<>0) then begin
    res = Left(tstr,i);
  end else begin
    if (i==0) then begin
      res = "";
    end else begin
      res = tstr;
    end;  
  end;  

  RETURN;
END;

global
procedure StripLeadingSpaces(var string res)
BEGIN
  Integer i,l;
  string 255 tstr;

  tstr = res;
  l = len(tstr);
  for (i=0; i<=l; i=i+1) begin
    if (mid(tstr,i,1)<>" ") then begin
      goto L882;
    end;
  end;
L882:; 
  res = mid(tstr,i,l);
  RETURN;
END;

global
function boolean BlankString( string source )
begin
  Integer lSource,i;
  Boolean ret;
  
  ret= true;
  lSource= len(source);
  for (i=0;i<lSource;i=i+1) begin
    if (mid(source,i,1)!=" ") then begin
      ret=false;
    end;
  end;
  BlankString= ret;
  return;
end;

global
procedure Alltrim( string source, var string dest )
begin
Integer lSource,i;

  dest= "";
  lSource= len(source);
  for (i=0;i<lSource;i=i+1) begin
    if (mid(source,i,1)!=" ") then begin
      dest= dest & mid(source,i,1);
    end;
  end;
  return;
end;

global
procedure ConvYankeeStringToDate(string instr,var Date res)
BEGIN
  string 20 years,months,days,tstr;
  record SysFormatBlock DateFormatRec;
  
  BlockLoad(DateFormatRec);
  months = Left(instr,2);
  if (left(months,1)=="k") then begin //LO Search ASCII sign !!
    tstr = right(months,1);
    months = "0" & tstr;
  end;
  days   = MID(instr,3,2); 
  tstr = MID(instr,6,2); 
  years = "20" & tstr;

  if (DateFormatRec.dateOrder==2) then begin
    res = StringToDate(instr);
  end;
  if (DateFormatRec.dateOrder==1) then begin
    tstr = days;
    tstr = tstr & DateFormatRec.dateSep;
    tstr = tstr & months;
    tstr = tstr & DateFormatRec.dateSep;
    tstr = tstr & years;    
  end;
  if (DateFormatRec.dateOrder==0) then begin
    tstr = months;
    tstr = tstr & DateFormatRec.dateSep;
    tstr = tstr & days;
    tstr = tstr & DateFormatRec.dateSep;
    tstr = tstr & years;    
  end;  
  res = tstr;
  RETURN;
END;


// " 9:30PM" --> "21:30"
global
Procedure YankeeTimetoInternational(String times,var Time mTime)
begin
  string 30 tstr,res;
  Integer i;
  
  tstr = right(times,2);
  if (tstr=="PM") then begin
    i = stringtoint(left(times,2));
    i = i + 12;
    tstr = i;
    res = tstr & mid(times,2,3);
  end else begin
    res = left(times,5);
  end;
  //stopalert(times & "-->" & res);
  mTime = res;
  return;
end;

global
procedure CalcSum2(val q,val p,val f,val rvp,var val s,Integer UseDiscount)
BEGIN
  val s2;

  s2 = q*p;
  if (f!=0) then begin
    s2 = s2 / f;
  end;
  
  if (rvp!=0) then begin
    if (s2!=0) then begin
      if ((rvp>=-100) and (rvp<=100)) then begin
        s2 = s2 - (s2 * rvp / 100.0);
      end;
    end;
  end;
  s = s2;
  RETURN;
END;

global
procedure GetDateString(var string res)
BEGIN
  string 255 tstr,t2;
  
  tstr = res;
  res = "";
  res = MID(tstr,4,2);
  t2  = MID(tstr,2,2);
  res = res & t2;
  t2  = MID(tstr,0,2);
  res = res & t2;  
  RETURN;
END;

global
procedure GetDateString2(var string res)
BEGIN
  string 255 tstr,t2;
  
  tstr = res;
  res = "";
  res = MID(tstr,6,2);
  t2  = MID(tstr,4,2);
  res = res & t2;
  t2  = MID(tstr,0,4);
  res = res & t2;  
  RETURN;
END;

global
procedure CalcVATBaseVAT2(record SMVc SMr,Integer inclvat,Integer NoTAXonVAT,Integer vatcnt,Boolean ignorelimit,var val s3,var val tax1)
begin
  Integer i;
  val vat,t1;
  row SMVc SMrw;
  record RoundBlock Rb;
  
  BlockLoad(Rb);
  s3 = blankval;
  tax1 = blankval;
  for (i=0;i<vatcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);            
    switch (Rb.VATCalcWay) begin
      case 0:
        if (SMrw.DebVal!=0) then begin
          MulVATIV2(SMrw.VATCode,SMrw.DebVal,vat,t1,inclvat,NoTAXonVAT,ignorelimit);
          vat = Round(vat,GetVATRoundMode(Rb));
          SMrw.CredVal2 = SMrw.CredVal2 + vat;
          s3 = vat + s3;
          if (SMrw.BaseRate1!=0) then begin
            t1 = t1 - (t1*SMrw.BaseRate1)/100;
            t1 = Round(t1,DefaultRoundMode);
          end;
          if (t1<0) then begin
            if ((-t1)<SMrw.FrRate) then begin t1 = 0; end;
          end else begin
            if (t1<SMrw.FrRate) then begin t1 = 0; end;
          end;
          t1 = Round(t1,DefaultRoundMode);
          tax1 = t1 + tax1;
          MatRowPut(SMr,i,SMrw);            
        end;
      case 1:
        t1 = SMrw.CurCredVal;
        if (SMrw.BaseRate1!=0) then begin
          t1 = t1 - (t1*SMrw.BaseRate1)/100;
          t1 = Round(t1,DefaultRoundMode);
        end;
        if (t1<0) then begin
          if ((-t1)<SMrw.FrRate) then begin t1 = 0; end;
        end else begin
          if (t1<SMrw.FrRate) then begin t1 = 0; end;
        end;
        s3 = SMrw.CredVal2 + s3;
        tax1 = t1 + tax1;
    end;
  end;
  s3 = Round(s3,DefaultRoundMode);
  tax1 = Round(tax1,DefaultRoundMode);
  RETURN;
END;

global
procedure CalcVATBaseVAT(record SMVc VATr,Integer inclvat,Integer NoTAXonVAT,Integer vatcnt,var val s3,var val tax1)
begin
  CalcVATBaseVAT2(VATr,inclvat,NoTAXonVAT,vatcnt,false,s3,tax1);
  return;
end;

global
procedure AddVATBase(var record SMVc SMr,string vatcode,val t,val tax1reb,Integer vatcnt,Integer InclVAT,Integer NoTAXonVAT)
BEGIN
  row SMVc SMrw;
  Integer i;
  record RoundBlock Rb;
  val vatv,tax1;
  
  BlockLoad(Rb);
  for (i=0; i<vatcnt; i=i+1) begin
    MatRowGet(SMr,i,SMrw);          
    if (SMrw.VATCode==VATCode) then begin
      SMrw.DebVal = SMrw.DebVal + t;
      if (Rb.VATCalcWay!=0) then begin
        MulVATIV(vatcode,t,vatv,tax1,InclVAT,NoTAXonVAT);
        vatv = Round(vatv,GetVATRoundMode(Rb));        
        SMrw.CredVal2 = SMrw.CredVal2 + vatv;
        tax1 = Round(tax1,DefaultRoundMode);
        SMrw.CurCredVal = SMrw.CurCredVal + tax1;
      end;
      SMrw.BaseRate1 = tax1reb;
      MatRowPut(SMr,i,SMrw);
      goto LAddVATBase;
    end;
  end;      
LAddVATBase:;
  RETURN;
END;
    
global
procedure AddActualVATBase(var record SMVc SMr,string vatcode,val t,val vatval,Integer vatcnt,Integer InclVAT,Integer NoTAXonVAT)
BEGIN
  row SMVc SMrw;
  Integer i;
  record RoundBlock Rb;
  val vatv,tax1;
  
  BlockLoad(Rb);
  for (i=0; i<vatcnt; i=i+1) begin
    MatRowGet(SMr,i,SMrw);          
    if (SMrw.VATCode==VATCode) then begin
      SMrw.DebVal = SMrw.DebVal + t;
      if (Rb.VATCalcWay!=0) then begin
        MulVATIV(vatcode,t,vatv,tax1,InclVAT,NoTAXonVAT);
        vatv = Round(vatv,GetVATRoundMode(Rb));        
        SMrw.CredVal2 = SMrw.CredVal2 + vatval;
        tax1 = Round(tax1,DefaultRoundMode);
        SMrw.CurCredVal = SMrw.CurCredVal + tax1;
      end;
      MatRowPut(SMr,i,SMrw);
      goto LAddActualVATBase;
    end;
  end;      
LAddActualVATBase:;
  RETURN;
END;
    
global
procedure AddVATVat(var record SMVc SMr,string vatcode,val t,Integer vatcnt)
BEGIN
  row SMVc SMrw;
  Integer i;
  
  for (i=0; i<vatcnt; i=i+1) begin
    MatRowGet(SMr,i,SMrw);          
    if (SMrw.VATCode==VATCode) then begin
      SMrw.CredVal = SMrw.CredVal + t;
      MatRowPut(SMr,i,SMrw);
      goto LAddVATVat;
    end;
  end;      
LAddVATVat:;
  RETURN;
END;

global
procedure VATBaseMulRate(record SMVc SMr,string curncy,val frratep,val torate1,val torate2,val baserate1,val baserate2,Integer vatcnt)
BEGIN
  Integer i;
  row SMVc SMrw;
  
  for (i=0;i<vatcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);          
    if (SMrw.DebVal!=0) then begin
      SMrw.DebVal = MulRateToBase1(curncy,SMrw.DebVal,frratep,torate1,torate2,baserate1,baserate2,DefaultCurRoundOff);
    end;  
    SMrw.CredVal = MulRateToBase1(curncy,SMrw.CredVal,frratep,torate1,torate2,baserate1,baserate2,DefaultCurRoundOff);
    MatRowPut(SMr,i,SMrw);      
  end;
  RETURN;
END;

global
procedure SetupVATBase(var record SMVc SMr,var Integer vatcnt)
BEGIN
  row SMVc SMrw;
  Integer rwcnt,i;
  record VATCodeBlock VATr;
  row VATCodeBlock VATrw;
  
  BlockLoad(VATr);  
  rwcnt = MatRowCnt(VATr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(VATr,i,VATrw);
    SMrw.VATCode = VATrw.VATCode;
    SMrw.DebVal = blankval;
    SMrw.CredVal = blankval;
    SMrw.CredVal2 = blankval;
    SMrw.CurDebVal = blankval;
    SMrw.FrRate = VATrw.Tax1Min;
    MatRowPut(SMr,i,SMrw);
  end;
  vatcnt = rwcnt;
  RETURN;
END;

global
procedure FindVATCodeRow(string vatcode,record VATCodeBlock VATb,var row VATCodeBlock VATbrw)
begin
	integer i,rwcnt;
	
	rwcnt = MatrowCnt(VATb);
	for (i=0;i<rwcnt;i=i+1) begin
	  MatRowGet(VATb,i,VATbrw);
	  if (VATbrw.VATCode==vatcode) then begin
	    goto LFindVATCodeRow;
	  end;
	end;
LFindVATCodeRow:;	
	return;
end;

global
procedure AddToVATPrcBase(record VATCodeBlock VATb,string vatcode,val base,val vatv,var vector val vbase,var vector val vvat)
begin
  Integer rwcnt,i;
  row VATCodeBlock VATbrw;
  row VATCodeBlock tVATbrw;
  val vatprc,tvatprc;
  
  FindVATCodeRow(vatcode,VATb,tVATbrw);
  if (blank(tVATbrw.ExVatpr)) then begin
    tvatprc = tVATbrw.IncVatpr;
  end else begin
    tvatprc = tVATbrw.ExVatpr;
  end;
  rwcnt = MatRowCnt(VATb);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(VATb,i,VATbrw);
    if (blank(tVATbrw.ExVatpr)) then begin
      vatprc = VATbrw.IncVatpr;
    end else begin
      vatprc = VATbrw.ExVatpr;
    end;
    if (vatprc==tvatprc) then begin
      vbase[VATbrw.ExVatpr] = vbase[VATbrw.ExVatpr] + base;
      vvat[VATbrw.ExVatpr] = vvat[VATbrw.ExVatpr] + vatv;        
      goto LAddToVATPrcBase;
    end;
  end;  
LAddToVATPrcBase:;
  return;
end;

global
procedure SetupVATPrcBase(record VATCodeBlock VATb,var vector val vbase,var vector val vvat)
begin
  Integer rwcnt,i,v;
  row VATCodeBlock VATbrw;
  val vatprc;
  
  rwcnt = MatRowCnt(VATb);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(VATb,i,VATbrw);
    if (blank(VATbrw.ExVatpr)) then begin
      vatprc = VATbrw.IncVatpr;
    end else begin
      vatprc = VATbrw.ExVatpr;
    end;
    vbase[vatprc] = 0.00;
    vvat[vatprc] = 0.00;
  end;
  return;
end;

global
procedure SetupVATPrcArray(record VATCodeBlock VATb,var Array val avatprc,var Integer vatprccnt)
begin
  Integer rwcnt,i,v;
  row VATCodeBlock VATbrw;
  val vatprc;
  
  vatprccnt = 0;
  rwcnt = MatRowCnt(VATb);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(VATb,i,VATbrw);
    if (blank(VATbrw.ExVatpr)) then begin
      vatprc = VATbrw.IncVatpr;
    end else begin
      vatprc = VATbrw.ExVatpr;
    end;
    for (v=0;v<vatprccnt;v=v+1) begin
      if (avatprc[v]==vatprc) then begin
        goto LSetupVATPrcArray;
      end;
    end;
    avatprc[vatprccnt] = vatprc;
    vatprccnt = vatprccnt + 1;
LSetupVATPrcArray:;    
  end;
  return;
end;

global
function Integer CheckRates(string curncycode,val FrRate,val ToRateB1,val ToRateB2,val BaseRate1,val BaseRate2,var string gotofield)
BEGIN
  Integer res;
  record BaseCurBlock BCb;

  gotofield = "";
  if (blank(curncycode)) then begin goto LCheckRates; end;
  BlockLoad(BCb);  
  if (IsStandardProduct) then begin 
//    if (blank(BCb.BaseCur1) and blank(BCb.BaseCur2) and (HasMultiCurrency==false)) then begin goto LCheckRates; end;  
  end;
  if ((curncycode!=BCb.BaseCur1) and (curncycode!=BCb.BaseCur2)) then begin
    if ((ToRateB1!=0) and (ToRateB2!=0)) then begin
      res = 1259; 
      gotofield = "ToRateB1";
      goto LCheckRates;
    end;
    if ((ToRateB1==0) and (ToRateB2==0)) then begin
      res = 1264; 
      gotofield = "ToRateB1";
      goto LCheckRates;
    end;
    if (((BaseRate1!=0) or (BaseRate2!=0)) and ((ToRateB1!=0) or (ToRateB2!=0)) and (FrRate==0)) then begin
      res = 1854; 
      gotofield = "FrRate";
      goto LCheckRates;
    end;
  end;
  if ((curncycode==BCb.BaseCur1) or (curncycode==BCb.BaseCur2)) then begin
    if ((FrRate!=0) or (ToRateB1!=0) or (ToRateB2!=0)) then begin
      res = 1259; 
      gotofield = "ToRateB1";
      goto LCheckRates;
    end;
  end;
  if (nonblank(BCb.BaseCur1)) and (nonblank(BCb.BaseCur2)) then begin
    if ((BaseRate1==0) or (BaseRate2==0)) then begin
      res = 1264; 
      gotofield = "BaseRate1";
      goto LCheckRates;
    end;
  end;
LCheckRates:;  
  CheckRates = res;
  RETURN;
END;
