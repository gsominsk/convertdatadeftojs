external function Date DateFromString(string,string);
external procedure NewLineExport();
external function string 255 removenextnode(var string);
external function string 255 removenextlistitem(var string,string);

global
function Integer XmlGetInt(var xml message,string key)
begin
  XmlGetInt = StringToInt(XmlGet(message,key));
  return;
end;

global
function LongInt XmlGetLong(var xml message,string key)
begin
  XmlGetLong = StringToLongInt(XmlGet(message,key));
  return;
end;

procedure PutChar(var string theres,Integer i,string ch)
BEGIN
  string 255 tstr,tstr2,res;
  
  tstr = theres;
  res = Left(tstr,i);  
  res = res & ch;
  tstr2 = Right(tstr,len(tstr)-(i+1));
  res = res & tstr2;
  theres = res;
  RETURN;
END;

global
function val StringToValue(string vstr,Integer typ,string tho,string dec)
begin
  val res;
  Integer i;
  string 255 lvstr,tstr;
  string 1 nc;
  
  if (blank(vstr)) then begin goto LStringToValue; end;
  lvstr = vstr;
  for (i=0;i<len(lvstr);i=i+1) begin
    nc = Mid(lvstr,i,1);
    if (nc==tho) then begin PutChar(lvstr,i,ThousandSeparator); end;
    if (nc==dec) then begin PutChar(lvstr,i,DecimalSeparator); end;
  end;
  res = StringToVal(lvstr,typ);  
LStringToValue:;  
  StringToValue = res;
  return;
end;

global
function val XmlGetVal(var xml message,string key,Integer typ,string tho,string dec)
begin
  XmlGetVal = StringToValue(XmlGet(message,key),typ,tho,dec);
  return;
end;

global
function date XmlGetDate(var xml message,string key,string format)
begin
  XmlGetDate = DateFromString(XmlGet(message,key),format);
  return;
end;
    
global
procedure GetAreaFromFile(Area a_signed,string filename)
begin
  Boolean testf;
  LongInt pos;
  string 1 c;
  Integer cnt;
  string 255 tstr;
  
  SetAreaZeroSize(a_signed);
  OpenFile(filename);
  
  pos = 0;
  testf = true;
  while (testf) begin
    c = ReadChar(pos);
    tstr = tstr & c;
    cnt = cnt + 1;
    pos = pos + 1;
    if (TestEOF) then begin testf = false; end;
    if (cnt>=200) then begin
      AddTextToArea(tstr,a_signed);
      cnt = 0;
      tstr = "";
    end;
  end;
  AddTextToArea(tstr,a_signed);
  CloseFile;
  return;
end;
  
global  
function string 255 TimeStampStr()
begin
  string 255 res,tstr;
  Date td;
  Time tt;
  
  tt = CurrentTime;
  td = CurrentDate;
  res = td.year;

  tstr = td.month;
  if (len(tstr)<2) then begin tstr = "0" & td.month; end;
  res = res & tstr;
  tstr = td.day;
  if (len(tstr)<2) then begin tstr = "0" & td.day; end;
  res = res & tstr;

  tstr = tt.hour;
  if (len(tstr)<2) then begin tstr = "0" & tt.hour; end;
  res = res & tstr;
  tstr = tt.minute;
  if (len(tstr)<2) then begin tstr = "0" & tt.minute; end;
  res = res & tstr;
  tstr = tt.second;
  if (len(tstr)<2) then begin tstr = "0" & tt.second; end;
  res = res & tstr;
  res = res & "000";
  TimeStampStr = res;
  return;
end;

global
function string 255 ConvertXml(string source)
begin
  string 255 res;
  Integer l,i;
  string 1 addstr;
  
  l = len(source);
  for (i=0;i<l;i=i+1) begin
    addstr = Mid(source,i,1);
    switch (addstr) begin
      case "<": addstr = "&lt;";
      case ">": addstr = "&gt;";
      case "&": addstr = "&amp;";
      case "'": addstr = "&apos;";
      case """": addstr = "&quot;";
      otherwise
        if asc(addstr) > 127 then begin //asc returns an integer      
          addstr = "&#" & asc(addstr) & ";"; //add the integer not the actual character after the #& and also add a ; at the end
        end else begin
          if asc(addstr) < 32 then begin //dont allow special control characters
            addstr = ""; //just filter them out alltogether
          end;
          if asc(addstr)==9 then begin addstr = "&#9;"; end; //TAB
          if asc(addstr)==10 then begin addstr = "&#10;"; end; //LF
          if asc(addstr)==13 then begin addstr = "&#13;"; end; //CR
        end;
    end;
    res = res & addstr;
  end;
  ConvertXml = res;
  return;
end;

global
function string 255 ConvertXmlString(string source,Boolean crlf)
begin
  string 255 res;
  Integer l,i;
  string 1 addstr;
  
  l = len(source);
  for (i=0;i<l;i=i+1) begin
    addstr = Mid(source,i,1);
    switch (addstr) begin
      case "<": addstr = "&lt;";
      case ">": addstr = "&gt;";
      case "&": addstr = "&amp;";
      case "'": addstr = "&apos;";
      case """": addstr = "&quot;";
      otherwise
        if (crlf) then begin
          if asc(addstr)==9 then begin addstr = "&#9;"; end; //TAB
          if asc(addstr)==10 then begin addstr = "&#10;"; end; //LF
          if asc(addstr)==13 then begin addstr = "&#13;"; end; //CR
        end;
    end;
    res = res & addstr;
  end;
  ConvertXmlString = res;
  return;
end;

global
procedure ExportXml(string Text)
begin
  transaction Integer gXmlIndent;
  
  ExportPadString(Text,BytesInString(Text) + gXmlIndent," ",true);
  
  return;
end;

global
procedure ExportXmlNL(string Text)
begin
  ExportXml(Text);
  NewLineExport;
  
  return;
end;

global
procedure ExportXmlTagOpen(string Text)
begin
  transaction Integer gXmlIndent;
  
  ExportXmlNL(Text);
  gXmlIndent = gXmlIndent + 2;
  
  return;
end;

global
procedure ExportXmlTagClose(string Text)
begin
  transaction Integer gXmlIndent;
  
  gXmlIndent = gXmlIndent - 2;
  ExportXmlNL(Text);
  
  return;
end;
  
procedure SplitNodeNamePrefix(var string nodename,var string prefix)
begin
  prefix = FirstInRange(nodename,255);
  if (blank(prefix) or prefix==nodename) then begin
    prefix = "";
  end else begin
    nodename = right(nodename,len(nodename)-len(prefix)-1);
  end;
  return;
end;

procedure SplitNodeArrayIndex(var string nodename,var longint idx)
begin
  string 255 tstr,tstr2;
  
  idx = -1;
  tstr2 = nodename;
  tstr = removenextlistitem(tstr2,"[");
  if (nonblank(tstr)) then begin
    nodename = tstr;
    tstr = removenextlistitem(tstr2,"]");
    idx = StringToLongInt(tstr);
  end;
  return;
end;

function string 255 ConcatXPath(string parent,string child)
begin
  string 255 res;
  
  res = parent;
  if (nonblank(parent)) then begin
    res = res & "/";
  end;
  res = res & child;

  ConcatXPath = res;
  return;
end;

global
function string 255 BuildXPathWithXml(xml x,string inpath,string inns,boolean strictnsf)
begin
  string 255 node,mpath;
  string 255 ns,curpath,testpath;
  string 255 defns,ldefns;
  string 255 res;
  string 255 prefix,attr;
  string 255 childname,cprefix;
  string 255 lknownns;
  integer i,j,attrcnt,nodecnt;
  longint idx,foundcnt;
  vector string 255 vinputns;
  vector string 255 vknownns;
  vector string 255 vlknownns;
  
  mpath = inns;
  node = removenextlistitem(mpath,",");
  while (nonblank(node)) begin
    ns = removenextlistitem(node,"=");
    if (nonblank(ns)) then begin
      vinputns[ns] = node;
    end;
    node = removenextlistitem(mpath,",");
  end;
  
  mpath = inpath;
  node = removenextnode(mpath);
  while (nonblank(node)) begin
    ldefns = "";
    foundcnt = 0;
    
    SplitNodeArrayIndex(node,idx);

    SplitNodeNamePrefix(node,prefix);

    if (blank(prefix)) then begin
      testpath = ConcatXPath(curpath,node);
      if (idx!=-1) then begin
        testpath = testpath & "[" & idx & "]";
      end;
      attr = XmlGetAttribute(x,testpath,"xmlns");
      if (XmlNodeExists(x,testpath)) then begin
        if (strictnsf==false or (blank(attr) and blank(defns))) then begin
          goto Lmatch;
        end;
      end;
      if (strictnsf) then begin
        goto Lerror;
      end;
    end;

    nodecnt = XmlCountChildren(x,curpath);
    for (i=0;i<nodecnt;i=i+1) begin
      lknownns = "";
      
      ldefns = defns;
      
      childname = XmlGetChildName(x,curpath,i);

      if (childname=="?xml") then begin
        goto Lnextchild;
      end;

      testpath = ConcatXPath(curpath,childname);

      SplitNodeNamePrefix(childname,cprefix);

      if (strictnsf==false) then begin
        if (node==childname) then begin
          goto Lfound;
        end;
        goto Lnextchild;
      end;

      attrcnt = XmlCountAttributes(x,testpath);
      for (j=0;j<attrcnt;j=j+1) begin
        attr = XmlGetAttributeName(x,testpath,j);

        if (left(attr,6)=="xmlns:") then begin
          ns = right(attr,len(attr)-6);
          lknownns = lknownns & ns & ",";

          vlknownns[ns] = XmlGetAttribute(x,testpath,attr);
        end else begin
          if (attr=="xmlns") then begin
            ldefns = XmlGetAttribute(x,testpath,attr);
          end;
        end;
      end;

      if (blank(cprefix)) then begin
        if (vinputns[prefix]==ldefns) then begin
          goto Lfound;
        end;
        goto Lnextchild;
      end;

      ns = "";
      if (SetInSet(cprefix,lknownns)) then begin
        ns = vlknownns[cprefix];
      end else begin
        ns = vknownns[cprefix];
      end;

      if (vinputns[prefix]==ns) then begin
        goto Lfound;
      end;
      
      goto Lnextchild;

Lfound:;
      if (idx==-1) then begin
        goto Lmatch;
      end else begin
        if (foundcnt==idx) then begin
          goto Lmatch;
        end else begin
          foundcnt = foundcnt + 1;
        end;
      end;

Lnextchild:;
    end;
    
    goto Lerror;
    
Lmatch:;
    curpath = testpath;

    ns = removenextlistitem(lknownns,",");
    while (nonblank(ns)) begin
      vknownns[ns] = vlknownns[ns];
      ns = removenextlistitem(lknownns,",");
    end;

    if (nonblank(ldefns)) then begin
      defns = ldefns;
    end;

    node = removenextnode(mpath);
  end;
  
  res = curpath;

Lerror:;
  BuildXPathWithXml = res;
  return;
end;

procedure AddLevelToArea(area a,Integer level)
begin
  string 255 tstr;
  Integer i;
  
  tstr = "";
  for (i=0;i<level;i=i+1) begin
    tstr = tstr & "  ";
  end;
  AddTextToArea(tstr,a);
  return;
end;

global
procedure AddPlainXmlToArea(area a,string value,Integer level)
begin
  AddLevelToArea(a,level);
  AddTextToArea(value,a);
  AddTextToArea(chr(13) & chr(10),a);
  return;
end;

global
procedure AddXmlTagToArea(area a,string tag,string attrs,string tstr,Integer level)
begin
  AddLevelToArea(a,level);
  AddTextToArea("<",a);
  AddTextToArea(tag,a);
  if (nonblank(attrs)) then begin
    AddTextToArea(" " & attrs,a);
  end;
  AddTextToArea(">",a);

  AddTextToArea(tstr,a);

  AddTextToArea("</",a);
  AddTextToArea(tag,a);
  AddTextToArea(">",a);
  AddTextToArea(chr(13) & chr(10),a);
  return;
end;

procedure ExportLevel(Integer level)
begin
  string 255 tstr;
  Integer i;
  
  tstr = "";
  for (i=0;i<level;i=i+1) begin
    tstr = tstr & "  ";
  end;
  ExportPadString(tstr,len(tstr)," ",false);
  return;
end;

global
procedure ExportPlainXml(string value,Integer level)
begin
  ExportLevel(level);
  ExportPadString(value,BytesInString(value)," ",false);
  NewLineExport;
  return;
end;

global
procedure ExportTagXml(string tag,string pvalue,Integer level)
begin
  string 255 value;
  
  value = pvalue;
  ExportLevel(level);
  ExportPadString("<",1," ",false);
  ExportPadString(tag,len(tag)," ",false);
  ExportPadString(">",1," ",false);  
  ExportPadString(value,BytesInString(value)," ",false);
  ExportPadString("</",2," ",false);
  ExportPadString(tag,len(tag)," ",false);
  ExportPadString(">",1," ",false);
  NewLineExport;
  return;
end;

global
procedure ExportConvertTagXml(string tag,string pvalue,Integer level)
begin
  ExportTagXml(tag,ConvertXmlString(pvalue,false),level);
  return;
end;

global
procedure ExportAttributeTagXml(string tag,string pvalue,string attr,string attrvalue,Integer level)
begin
  string 255 value;
  
  value = pvalue;
  ExportLevel(level);
  ExportPadString("<",1," ",false);
  ExportPadString(tag,len(tag)," ",false);
  if (nonblank(attr)) then begin
    ExportPadString(" ",1," ",false);
    ExportPadString(attr,len(attr)," ",false);
    ExportPadString("=""",2," ",false);
    ExportPadString(attrvalue,BytesInString(attrvalue)," ",false);
    ExportPadString("""",1," ",false);
  end;
  ExportPadString(">",1," ",false);  
  ExportPadString(value,BytesInString(value)," ",false);
  ExportPadString("</",2," ",false);
  ExportPadString(tag,len(tag)," ",false);
  ExportPadString(">",1," ",false);
  NewLineExport;
  return;
end;