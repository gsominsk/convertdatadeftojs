external function string 255 FindINObjects(string,string);
external function Boolean GetFirstItem(var string,var record INVc);
external function Boolean BulkSerialNos_CalculateQuantityAndSerialNr(record SerNrTrackBlock,Boolean,string,var string,var val);
external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external procedure WarnFutureDate(Boolean,Date);
external function roundmode SetRoundModeD(Integer);
external procedure SerialNrDimensions(string,string,var val,var val,var val);
external function Integer CheckSerialStatus(string,string,var string);
external function val CalculateSerialNrQuantity(string,string,string,Boolean,val,val,val,val);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure RetSumUp(var record RetVc);
external procedure RetCalcCostPrice(string,val,Integer,string,string,val,val,val,val,val,var val);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);

global
function Boolean RetVc_PasteArtCode(var record RetVc Retp,Integer rownr,var string inwarn)
BEGIN
  Boolean res;
  record INVc INr;
  row RetVc Retrw;
  string 60 sz,msk,mskrep;
  string 200 varsubset;
  val p;
  record ORVc ORr;
  row ORVc ORrw;
  record RetGoodsBlock RGb;
  string 255 location,tstr;
  record AccBlock Accb;
  record CostAccBlock CAb;
  Boolean itemfound;
  
  BlockLoad(RGb);
  if (RGb.RetGoodsNotLinkedToOR==0) then begin
    goto LRetVc_PasteArtCode;
  end;
  BlockLoad(Accb);
  BlockLoad(CAb);
  MatRowGet(Retp,rownr,Retrw);
  if (Retrw.OrdRow>=0) then begin
    ORr.SerNr = Retp.OrdNr;
    if (ReadFirstMain(ORr,1,true)) then begin
      MatRowGet(ORr,Retrw.OrdRow,ORrw);
      if (ORrw.ArtCode!=Retrw.ArtCode) then begin
        goto LRetVc_PasteArtCode;
      end;
    end;
  end;
  itemfound = GetFirstItem(Retrw.ArtCode,INr);
  if (itemfound==false) then begin
    itemfound = ReadFirstItem(Retrw.ArtCode,INr,true,true);
  end;
  if (itemfound) then begin
    if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin
      INr.Code = Retrw.ArtCode;
    end;  
    if (nonblank(INr.WarnText1)) then begin
      inwarn = INr.WarnText1;
    end;
    Retrw.OrdRow = -1;
    Retrw.Spec = INr.Name;
    Retrw.UPrice = INr.InPrice;
    p = INr.InPrice;
    if (INr.PriceFactor!=0) then begin
      p = p / INr.PriceFactor;
    end;
    Retrw.ArtCode = INr.Code;
    Retrw.Spec = INr.Name;
    Retrw.UnitXval = INr.Width;
    Retrw.UnitYval = INr.Height;
    Retrw.UnitZval = INr.Depth;
    Retrw.UPrice = p;
    Retrw.Coefficient = INr.UnitCoefficient;
    RetCalcCostPrice(Retrw.ArtCode,Retrw.UPrice,Retp.InclVAT,Retrw.Extra,Retp.CurncyCode,
                     Retp.FrRate,Retp.ToRateB1,Retp.ToRateB2,Retp.BaseRate1,Retp.BaseRate2,p);
    Retrw.CostPrice = p;
    Retrw.Objects = FindINObjects(INr.Objects,INr.Group);
    location = Retrw.Location;
    if (blank(location)) then begin
      location = Retp.Location;
    end;
    Retrw.Recepy = "";
    if ((INr.ItemType==kItemTypeStructured) and (nonblank(INr.Recepy))) then begin
      Retrw.Recepy = INr.Recepy;
    end;
    if (GetCOSAcc(Retrw.CostAcc,Retp.CustCode,location,Accb,INr,CAb.ItemGroupAccounts,true,0,Retrw.CostAcc,tstr)) then begin
    end;

    MatRowPut(Retp,rownr,Retrw);
    RetSumUp(Retp);
    res = true;
  end;
LRetVc_PasteArtCode:;
  RetVc_PasteArtCode = res;
  RETURN;
END;

global
procedure RetRecalcCost(var record RetVc Retp)
BEGIN
  row RetVc Retrw; 
  Integer i,rwcnt;
  val t;
  
  rwcnt = MatRowCnt(Retp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    RetCalcCostPrice(Retrw.ArtCode,Retrw.UPrice,Retp.InclVAT,Retrw.Extra,Retp.CurncyCode,
                     Retp.FrRate,Retp.ToRateB1,Retp.ToRateB2,Retp.BaseRate1,Retp.BaseRate2,t);
    Retrw.CostPrice = t;
    MatRowPut(Retp,i,Retrw);
  end;
  RetSumUp(Retp);
  RETURN;
END;

global
procedure RetVc_PasteTransDate(var record RetVc Retp)
BEGIN
  val fr,to1,to2,br1,br2;

  GetFullCurncyRate(Retp.CurncyCode,Retp.TransDate,fr,to1,to2,br1,br2);
  Retp.FrRate = fr;
  Retp.ToRateB1 = to1; 
  Retp.ToRateB2 = to2;
  Retp.BaseRate1 = br1;
  Retp.BaseRate2 = br2;    
  WarnFutureDate(true,Retp.TransDate);
  RetRecalcCost(Retp);    
  RETURN;
END;

global
procedure RetVc_PasteCurncyCode(var record RetVc Retp)
BEGIN
  val fr,to1,to2,br1,br2;

  GetFullCurncyRate(Retp.CurncyCode,Retp.TransDate,fr,to1,to2,br1,br2);
  Retp.FrRate = fr;
  Retp.ToRateB1 = to1; 
  Retp.ToRateB2 = to2;
  Retp.BaseRate1 = br1;
  Retp.BaseRate2 = br2;    
  RetRecalcCost(Retp);    
  RETURN;
END;

global
procedure RetVc_PasteRate(var record RetVc Retp)
BEGIN
  RetRecalcCost(Retp);    
  RETURN;
END;

global
procedure RetVc_PasteCostPrice(var record RetVc Retp,Integer rownr)
BEGIN
  row RetVc Retrw;
  record INVc INr;
  record SysFormatBlock SysFormatRec;
  val t,t1,bas,vat;
  string 255 vatcode,tstr;
  Boolean chrsum;

  BlockLoad(SysFormatRec);
  MatRowGet(Retp,rownr,Retrw);  
  bas = MulRateToBase1(Retp.CurncyCode,Retrw.UPrice,Retp.FrRate,Retp.ToRateB1,Retp.ToRateB2,Retp.BaseRate1,Retp.BaseRate2,SetRoundModeD(5));
  if (Retp.InclVAT!=0) then begin
    GetItemVATCode(Retrw.ArtCode,0,vatcode,true);
    MulVATIV(vatcode,bas,vat,t1,Retp.InclVAT,0);
    bas  = bas - vat;
  end;
  tstr = Retrw.Extra;
  if (nonblank(tstr)) then begin
    if (CharacterMatch(tstr,"%",len(tstr))) then begin
      t = ((Retrw.CostPrice - bas)*100)/bas;
      tstr = ValToString(t,M4Val,SysFormatRec.thousSep,SysFormatRec.decimalPt,0);
      Retrw.Extra = tstr & "%";
    end else begin
      t = Retrw.CostPrice - bas;
      Retrw.Extra = ValToString(t,M4Val,SysFormatRec.thousSep,SysFormatRec.decimalPt,0);
    end;
  end;
  MatRowPut(Retp,rownr,Retrw);
  RetSumUp(Retp);
  RETURN;
END;

global
procedure RetVc_PastePrice(var record RetVc Retp,Integer rownr)
BEGIN
  row RetVc Retrw;
  val t;

  MatRowGet(Retp,rownr,Retrw);
  RetCalcCostPrice(Retrw.ArtCode,Retrw.UPrice,Retp.InclVAT,Retrw.Extra,Retp.CurncyCode,
                   Retp.FrRate,Retp.ToRateB1,Retp.ToRateB2,Retp.BaseRate1,Retp.BaseRate2,t);
  Retrw.CostPrice = t;
  MatRowPut(Retp,rownr,Retrw);
  RetSumUp(Retp);
  RETURN;
END;

global
procedure RetVc_PasteSerialNr(var record RetVc Retp,Integer rownr,var string warning)
BEGIN
  row RetVc Retrw;
  record BatchTextVc btr;
  string 255 tstr;
  val UnitXval,UnitYval,UnitZval;
  record INVc INr;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  warning = "";
  MatRowGet(Retp,rownr,Retrw);
  ReadFirstItem(Retrw.ArtCode,INr,true,true);
  if (nonblank(Retrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,true,Retrw.ArtCode,Retrw.SerialNr,Retrw.Quant)) then begin
      MatRowPut(Retp,rownr,Retrw);
      MatRowGet(Retp,rownr,Retrw);
    end;
  end;
  if ((SNrb.BulkSerialNos==0) or (InString(Retrw.SerialNr,":")==0)) then begin
    SerialNrDimensions(Retrw.ArtCode,Retrw.SerialNr,UnitXval,UnitYval,UnitZval);
    if (UnitXval!=0) then begin Retrw.UnitXval = UnitXval; end;
    if (UnitYval!=0) then begin Retrw.UnitYval = UnitYval; end;
    if (UnitZval!=0) then begin Retrw.UnitZval = UnitZval; end;
    if (CheckSerialStatus(Retrw.ArtCode,Retrw.SerialNr,tstr)==1) then begin
      warning = tstr;
    end;    
    Retrw.Quant = CalculateSerialNrQuantity(Retrw.ArtCode,"","",false,Retrw.UnitXval,Retrw.UnitYval,Retrw.UnitZval,Retrw.Quant);
  end;
  MatRowPut(Retp,rownr,Retrw);
  RETURN;
END;

global
procedure RetVc_PasteQuant(var record RetVc Retr,Integer rownr)
begin
  row RetVc Retrw;
  record INVc INr;
  record SerNrTrackBlock SNrb;

  BlockLoad(SNrb);
  MatRowGet(Retr,rownr,Retrw);
  ReadFirstItem(Retrw.ArtCode,INr,true,true);
  if (nonblank(Retrw.ArtCode)) and (INr.SerNrf==1) then begin
    if (BulkSerialNos_CalculateQuantityAndSerialNr(SNrb,true,Retrw.ArtCode,Retrw.SerialNr,Retrw.Quant)) then begin
      MatRowPut(Retr,rownr,Retrw);
      MatRowGet(Retr,rownr,Retrw);
    end;
  end;
  RetSumUp(Retr);
  return;
end;