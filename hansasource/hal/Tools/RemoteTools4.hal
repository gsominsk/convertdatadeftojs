external function Boolean AssignOfficialSerNr();
external procedure FindNextIVVcOfficialSerialNr(var record IVVc);
external procedure AddPerceptionTaxesRows_ORVc(var record ORVc);
external procedure IVCashDchsum(record IVCashVc,Integer);
external function Boolean IVCashDchrsum(record IVCashVc,Integer,Integer);
external procedure RowCalculateTaxMatrix_IVCashVc(var record IVCashVc,Integer,row IVCashVc);
external procedure IVCashSumup(var record IVCashVc,Boolean);
external procedure RowCalculateTaxMatrix_COVc(var record COVc,Integer,row COVc);
external function Boolean IVDchrsum(var record IVVc,Integer);
external procedure IVDchsum(var record IVVc,Integer);
external procedure RowCalculateTaxMatrix_IVVc(var record IVVc,Integer,row IVVc);
external procedure RowCalculateTaxMatrix_ORVc(var record ORVc,Integer,row ORVc);
external procedure AddWithholdingTaxesRows_IVVc(var record IVVc);
external procedure AddPerceptionTaxesRows_IVVc(var record IVVc);
external function roundmode SetRoundModeD(Integer);
external procedure AddCredManDeposit(var record IVVc,LongInt);
external updating procedure UpdateCredMan(record IVVc,LongInt,var Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure UpdateStockMovFIFO(var record StockMovVc,record StockMovVc,Integer);
external function string 255 FindINObjects(string,string);
external function string 255 FindNextLegalSerNr(record IVVc,string);
external function val CalcItemRepa(val,val,val,var string,val,val,val,val,val,roundmode);
external updating function LongInt SHVcRecordCheck(var record SHVc,record SHVc,LongInt,LongInt);
external procedure UpdateSHFIFO(record SHVc);
external updating function Boolean UpdateOrderFromShip(record SHVc,Boolean,record SHVc,Boolean,Boolean);
external procedure Bud1Sumup(var record Bud1Vc);
external procedure Bud1AccObjCalc(var record Bud1Vc);
external updating function Integer GenPOFromORMn2(record RcVc,var string);
external procedure SetIntORFlags(record IntORVc);
external procedure COSumup(var record COVc);
external function Boolean PasteCust2InCO(var record COVc,Boolean,var string);
external procedure COVcGetCalcItemPrice(record COVc,Integer,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external function Boolean GetItemPriceDiscount3(string,val,var record INVc,string,val,val,val,val,val,string,string,string,string,
                                                var val,var string,var val,var string,var val,var string,Integer,var Boolean,Date,Time,
                                                string,Boolean,var Boolean,string,var string,var val,string,string,var string);
external procedure PastePDInInv(var record IVVc,string,Boolean);
external procedure PasteCompulsoryINtoIV(string,record IVVc);
external procedure IVSumup(var record IVVc,Boolean);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure SetORFlags(record ORVc);
external procedure ORSumup(var record ORVc);
external function LongInt GetCurUserLastNr(string);
external updating procedure UpdateProdOut(record ProdVc,Boolean,Boolean);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external updating procedure ReconcileCheck(record CheckVc);
external updating procedure SaveTrans(record TRVc);
external function Integer MakeTransFromCheck(record TRVc,var record CheckVc,Boolean);
external procedure FindUserMailboxName(string,var string,var string);
external procedure IVVc_PasteSalesMan(var record IVVc,string);

global
updating procedure SetReadFlagHAL(LongInt sernr,Integer accode)
begin
  record MailReadVc MRr;
  record MailReadVc lMRr;
  string 60 mailboxcode,mailboxname;  
  LongInt l;
  
  RecordNew(MRr);  
  MRr.mailSerNr = sernr;
  FindUserMailboxName(CurrentUser,mailboxcode,mailboxname);
  MRr.mailBoxNr = StringToLongInt(mailboxcode);
  MRr.accode = accode;
  MRr.fDate = CurrentDate;
  MRr.fTime = CurrentTime;
  if (accode==0) then begin
//    OnReadMail();
  end;
  RecordCopy(lMRr,MRr);
  if (ReadFirstMain(lMRr,0,true)==false) then begin
    if (RecordStore(MRr,false)) then begin
    end;
  end;
  return;
end;

global
updating procedure SetMailAcceptancePostponed(LongInt sernr)
begin
  record MailReadVc MRr;
  record MailReadVc nMRr;
  Boolean found;
  
  found = true;
  MRr.mailSerNr = sernr;
  MRr.accode = kMailStatusAccepted;        
  while (LoopKey("accode",MRr,2,found)) begin
    if (MRr.mailSerNr!=sernr or MRr.accode!=kMailStatusAccepted) then begin
      found = false;
    end;
    if (found) then begin
      RecordCopy(nMRr,MRr);
      nMRr.fDate = CurrentDate;
      nMRr.fTime = CurrentTime;
      nMRr.accode = kMailStatusPostponed;
      RecordStore(nMRr,false);
    end;
  end;
  ResetLoop(MRr);
  found = true;
  MRr.mailSerNr = sernr;
  MRr.accode = kMailStatusRejected;        
  while (LoopKey("accode",MRr,2,found)) begin
    if (MRr.mailSerNr!=sernr or MRr.accode!=kMailStatusRejected) then begin
      found = false;
    end;
    if (found) then begin
      RecordCopy(nMRr,MRr);
      nMRr.fDate = CurrentDate;
      nMRr.fTime = CurrentTime;
      nMRr.accode = kMailStatusPostponed;
      RecordStore(nMRr,false);
    end;
  end;
  return;
end;

global
updating function Boolean RecListAction_rlMailUnread(var record MailVc Mailp)
begin
  Boolean res;

  if (IsRecordLocked(Mailp)==false) then begin
    SetReadFlagHAL(Mailp.SerNr,4);
  end;
  RecListAction_rlMailUnread = res;
  return;
end;

global
updating function Boolean RecListAction_rlMailRequireAcceptance(var record MailVc Mailr)
begin
  record MailVc oMailr;
  
  if (IsRecordLocked(Mailr)==false) then begin
    oMailr.SerNr = Mailr.SerNr;
    if (ReadFirstMain(oMailr,1,true)) then begin
      RecordCopy(Mailr,oMailr);
      Mailr.RequireAcceptance = 1;
      RecordUpdate(oMailr,Mailr,false);
    end;
  end;
  return;
end;

global
updating function Boolean RecListAction_rlEMailQueUnread(var record EMailQueVc EMailQuep)
BEGIN
  Boolean res;

  if (IsRecordLocked(EMailQuep)==false) then begin
    if (blank(EMailQuep.FileName) or EMailQuep.FileName=="MailVc") then begin
      SetReadFlagHAL(EMailQuep.OrgSerNr,4);
    end;
  end;
  RecListAction_rlEMailQueUnread = res;
  RETURN;
END;

global
updating function Boolean RecListAction_rlLocalMailUnread(var record LocalMailVc LocalMailp)
BEGIN
  Boolean res;

  if (IsRecordLocked(LocalMailp)==false) then begin
    SetReadFlagHAL(LocalMailp.SerNr,4);
  end;
  RecListAction_rlLocalMailUnread = res;
  RETURN;
END;

global
updating function Boolean DoDeleteEMailQuesm(record EMailQueVc EMailQuep)
begin
  record EMailQueVc EMailQuer;
  Boolean foundf;
  Boolean res;
  
  res = false;
  foundf = true;
  EMailQuer.OrgSerNr = EMailQuep.OrgSerNr;
  EMailQuer.FileName = EMailQuep.FileName;
  while (LoopKey("OrgSerNr",EMailQuer,2,foundf)) begin
    if ((EMailQuer.OrgSerNr!=EMailQuep.OrgSerNr) or (EMailQuer.FileName!=EMailQuep.FileName)) then begin
      foundf = false;
    end;
    if (foundf) then begin
      if (EMailQuep.SerNr==EMailQuer.SerNr) then begin
        res = true;
      end;
      RecordDelete(EMailQuer);
      StepBack(EMailQuer);
    end;
  end;
  DoDeleteEMailQuesm = res;
  return;
end;

updating function Boolean acCheckDep(var record CheckVc Checkp)
BEGIN
  Boolean res;  
  string 255 tstr;
  record TRVc gTRp;

  if (CurrentDate<Checkp.EffectDate) then begin    
    tstr = Checkp.SerNr;
    MessageBox(1940," " & tstr);//is it client server
    goto LacCheckDep;
  end;
  Checkp.Openf = 2;
  if (Checkp.ClearedAmount==0) then begin
    Checkp.ClearedAmount = Checkp.Amount - Checkp.BankFee;
  end;
  if (MakeTransFromCheck(gTRp,Checkp,false)==0) then begin
    if ((gTRp.Number>0) and (gTRp.IntYc==CheckYc)) then begin
       SaveTrans(gTRp);
    end;        
    res = true;
  end else begin//is it client server
    tstr = Checkp.SerNr;
    MessageBox(1276,tstr);
  end;
LacCheckDep:;
  acCheckDep = res;
  RETURN;
END;

global
updating function Boolean RecordAction_rlCheckDep(var record CheckVc Checkp)
BEGIN
  Boolean res;
  record CheckVc oldCheckp;
  
  if (IsRecordLocked(Checkp)==false) then begin
    if (ReadFirstMain(Checkp,0,true)) then begin end;  
    RecordCopy(oldCheckp,Checkp);
    res = acCheckDep(Checkp);
    if (res) then begin
      if (RecordUpdate(oldCheckp,Checkp,false)==0) then begin
      end;
    end;
  end;
  RecordAction_rlCheckDep = res;
  RETURN;
END;

updating function Boolean acCheckClear(var record CheckVc Checkp)
BEGIN
  Boolean res;
  
  res = true;
  Checkp.Openf = 3;
  ReconcileCheck(Checkp);
  acCheckClear = res;
  RETURN;
END;

global
updating function Boolean RecordAction_rlCheckClear(var record CheckVc Checkr)
BEGIN
  Boolean res;
  record CheckVc oldCheckr;

  if (IsRecordLocked(Checkr)==false) then begin
    if (ReadFirstMain(Checkr,0,true)) then begin end;  
    RecordCopy(oldCheckr,Checkr);
    res = acCheckClear(Checkr);
    if (res) then begin
      if (RecordUpdate(oldCheckr,Checkr,false)==0) then begin
      end;    
    end;
  end;
  RecordAction_rlCheckClear = res;
  RETURN;
END;

function Boolean FindRecQty(record INVc INp,record ItemStatusVc ISp,var record RecVc Recp,var val t1p,var val t2p)
BEGIN
  Boolean res;
  val t,outsum;
  row RecVc Recrw;
  Integer i,rwcnt;
  string 255 location;
  
  FindStockValue(INp.Code,location,ISp);
  t = ISp.Instock - ISp.OrddOut;
  t1p = t + ISp.POUnOKQty;
  t2p = blankval;
  if (t1p<INp.MinLevel) then begin
    t2p = INp.MinLevel - t1p;
  end;  
  Recp.Code = INp.Recepy;
  res = ReadFirstMain(Recp,1,true);
  rwcnt = MatRowCnt(Recp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Recp,i,Recrw);
    if (INp.Code==Recrw.Item) then begin
      outsum = Recrw.OutQty + outsum;
    end;
  end;
  if (outsum>0) then begin
    t1p = t2p/outsum;
    t1p = Round(t1p,SetRoundModeD(0));
    t = t1p*outsum;
    if (t<t2p) then begin
      t1p = t1p + 1;
    end;
  end else begin
    res = false;
  end;
  FindRecQty = res;
  RETURN;
END;

global
function Boolean PasteRecInProd(var record ProdVc Prodp)
BEGIN
  Boolean res;
  Integer i,rwcnt;
  record RecVc Recr;
  row RecVc Recrw;
  row ProdVc Prodrw;
  record INVc INr;
  Integer rows,j;
  Integer prodrows;
  val rem;
  
  Recr.Code = Prodp.Recepy;
  res = ReadFirstMain(Recr,1,true);
  if (res) then begin
    while (MatRowCnt(Prodp)>0) begin
      MatRowDelete(Prodp,0);
    end;
    if (Recr.Closed!=0) then begin 
      goto LPasteRecInProd;
    end;
    Prodp.Recepy = Recr.Code;
    Prodp.RecName = Recr.Comment;
    Prodp.Routing = Recr.DefaultRouting;
    Prodp.Qty = Recr.NormProdQty;
    Prodp.TotalIdleTime = Recr.SetUpTime;
    Prodp.LangCode = Recr.LangCode;
    Prodp.ExtraProdQty = Recr.ExtraProdQty;
//    Prodp.Scale = Recr.Scale;
    rwcnt = MatRowCnt(Recr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Recr,i,Recrw);
      if (ReadFirstItem(Recrw.Item,INr,false,false)) then begin end;
      if (INr.SerNrf==1) then begin
        if (Recrw.InQty!=0) then begin
          rows = Recrw.InQty*Prodp.Qty;
          for (j=0;j<rows;j=j+1) begin            
            prodrows = MatRowCnt(Prodp);
            ClearRow(Prodp,Prodrw,1);
            Prodrw.Item = Recrw.Item;
            Prodrw.Comment = Recrw.Comment;
            Prodrw.Objects = FindINObjects(INr.Objects,INr.Group);
            Prodrw.InQty = 1;
            Prodrw.OutQty = blankval;
            Prodrw.ItemCost = Recrw.ItemCost;
            Prodrw.RelVal = Recrw.RelVal;
            Prodrw.ExtraCost = Recrw.ExtraCost;
            Prodrw.FIFORowVal = Prodrw.InQty * Prodrw.ItemCost;
            Prodrw.FIFORowVal = Round(Prodrw.FIFORowVal,SetRoundModeD(5));
            Prodrw.Coefficient = INr.UnitCoefficient;
            Prodrw.Material = Recrw.Material;
            Prodrw.UnitXval = INr.Width;
            Prodrw.UnitYval = INr.Height;
            Prodrw.UnitZval = INr.Depth;
            Prodrw.Weight = INr.Weight;

            Prodrw.SuppSerialNr = INr.SuppSerialNr;
            Prodrw.MajStoneDet = INr.MajStoneDet;
            Prodrw.Colour = INr.Colour;
            Prodrw.Clarity = INr.Clarity;
            Prodrw.Cert = INr.Cert;
            Prodrw.MinStoneDet = INr.MinStoneDet;
            Prodrw.Metal = INr.Metal;
            Prodrw.RowWeight = INr.RowWeight;
            Prodrw.Size = INr.Size;
            Prodrw.Length = INr.Length;
        
            Prodrw.WatchBrand = INr.WatchBrand;
            Prodrw.StyleName = INr.StyleName;
            Prodrw.WatchMetal = INr.WatchMetal;
            Prodrw.Movement = INr.Movement;
            Prodrw.BrcStr = INr.BrcStr;
            Prodrw.Gender = INr.Gender;
            Prodrw.Other = INr.Other;
            Prodrw.Other2 = INr.Other2;
            MatRowPut(Prodp,prodrows,Prodrw);
          end;
        end;
        if (Recrw.OutQty!=0) then begin
          rows = Recrw.OutQty*Prodp.Qty;
          for (j=0;j<rows;j=j+1) begin
            prodrows = MatRowCnt(Prodp);
            ClearRow(Prodp,Prodrw,1);
            Prodrw.Item = Recrw.Item;
            Prodrw.Comment = Recrw.Comment;
            Prodrw.Objects = FindINObjects(INr.Objects,INr.Group);
            Prodrw.OutQty = 1;
            Prodrw.InQty = blankval;
            Prodrw.ItemCost = Recrw.ItemCost;
            Prodrw.RelVal = Recrw.RelVal;
            Prodrw.ExtraCost = Recrw.ExtraCost;
            Prodrw.Coefficient = INr.UnitCoefficient;
            Prodrw.Material = Recrw.Material;
            Prodrw.UnitXval = INr.Width;
            Prodrw.UnitYval = INr.Height;
            Prodrw.UnitZval = INr.Depth;
            Prodrw.Weight = INr.Weight;

            Prodrw.SuppSerialNr = INr.SuppSerialNr;
            Prodrw.MajStoneDet = INr.MajStoneDet;
            Prodrw.Colour = INr.Colour;
            Prodrw.Clarity = INr.Clarity;
            Prodrw.Cert = INr.Cert;
            Prodrw.MinStoneDet = INr.MinStoneDet;
            Prodrw.Metal = INr.Metal;
            Prodrw.RowWeight = INr.RowWeight;
            Prodrw.Size = INr.Size;
            Prodrw.Length = INr.Length;
        
            Prodrw.WatchBrand = INr.WatchBrand;
            Prodrw.StyleName = INr.StyleName;
            Prodrw.WatchMetal = INr.WatchMetal;
            Prodrw.Movement = INr.Movement;
            Prodrw.BrcStr = INr.BrcStr;
            Prodrw.Gender = INr.Gender;
            Prodrw.Other = INr.Other;
            Prodrw.Other2 = INr.Other2;
            MatRowPut(Prodp,prodrows,Prodrw);
          end;
        end;
      end else begin
        prodrows = MatRowCnt(Prodp);
        ClearRow(Prodp,Prodrw,1);
        Prodrw.Item = Recrw.Item;
        Prodrw.Comment = Recrw.Comment;
        Prodrw.Objects = FindINObjects(INr.Objects,INr.Group);
        switch (Prodp.RowsHoldActualQty) begin
          case 1: 
            Prodrw.InQty = Recrw.InQty;
            if (Prodp.Qty!=0) then begin
              Prodrw.InQty = Recrw.InQty*Prodp.Qty;
            end;
          otherwise 
            Prodrw.InQty = Recrw.InQty;
        end;
        switch (Prodp.RowsHoldActualQty) begin
          case 1: 
            Prodrw.OutQty = Recrw.OutQty;
            if (Prodp.Qty!=0) then begin
              Prodrw.OutQty = Recrw.OutQty*Prodp.Qty;
            end;            
          otherwise 
            Prodrw.OutQty = Recrw.OutQty;
        end;
        if (Prodrw.InQty==0) then begin Prodrw.InQty = blankval; end;
        if (Prodrw.OutQty==0) then begin Prodrw.OutQty = blankval; end;
        Prodrw.ItemCost = Recrw.ItemCost;
        Prodrw.RelVal = Recrw.RelVal;
        Prodrw.ExtraCost = Recrw.ExtraCost;       
        Prodrw.Coefficient = blankval;
        if (Recrw.InQty!=0) then begin
          Prodrw.FIFORowVal = Prodrw.InQty * Prodrw.ItemCost;
          Prodrw.FIFORowVal = Round(Prodrw.FIFORowVal,SetRoundModeD(5));
        end;
        Prodrw.Coefficient = INr.UnitCoefficient;
        Prodrw.Material = Recrw.Material;
        Prodrw.UnitXval = INr.Width;
        Prodrw.UnitYval = INr.Height;
        Prodrw.UnitZval = INr.Depth;
        Prodrw.Weight = INr.Weight;

        Prodrw.SuppSerialNr = INr.SuppSerialNr;
        Prodrw.MajStoneDet = INr.MajStoneDet;
        Prodrw.Colour = INr.Colour;
        Prodrw.Clarity = INr.Clarity;
        Prodrw.Cert = INr.Cert;
        Prodrw.MinStoneDet = INr.MinStoneDet;
        Prodrw.Metal = INr.Metal;
        Prodrw.RowWeight = INr.RowWeight;
        Prodrw.Size = INr.Size;
        Prodrw.Length = INr.Length;
        
        Prodrw.WatchBrand = INr.WatchBrand;
        Prodrw.StyleName = INr.StyleName;
        Prodrw.WatchMetal = INr.WatchMetal;
        Prodrw.Movement = INr.Movement;
        Prodrw.BrcStr = INr.BrcStr;
        Prodrw.Gender = INr.Gender;
        Prodrw.Other = INr.Other;
        Prodrw.Other2 = INr.Other2;
        MatRowPut(Prodp,prodrows,Prodrw);
      end;
    end;
  end;
LPasteRecInProd:;  
  PasteRecInProd = res;
  RETURN;
END;

updating procedure DoProd(record RecVc Recp,val prodqtyp)
BEGIN
  record ProdVc Prodr;
  
  RecordNew(Prodr);
  Prodr.SerNr = NextSerNr("ProdVc",Prodr.ProdDate,-1,false,"");
  Prodr.Recepy = Recp.Code;
  if (PasteRecInProd(Prodr)) then begin end;
  Prodr.Qty = prodqtyp;
  Prodr.SerNr = NextSerNr("ProdVc",Prodr.ProdDate,-1,false,"");
  if (Prodr.SerNr!=-1) then begin
    if (RecordStore(Prodr,false)) then begin end;
    UpdateProdOut(Prodr,true,true);
  end;
  RETURN;
END;

global
updating procedure ProdCreate(record RcVc RepSpec)
BEGIN
  record INVc INr;
  record ItemStatusVc ISr;
  record RecVc Recr;
  Boolean TrHs,testf,pifound;
  val t1,t2;
  val sum1;
  Integer vatflag;
  string 20 fromart,toart;
  string 20 frcc,tocc;
  string 30 keystr;
  Integer keys;

  fromart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);
  vatflag = 0;
  if (blank(RepSpec.f3)) then begin
    INr.Code = fromart;
    keystr = "Code";
    keys = 1;
  end else begin
    INr.Group = frcc;
    INr.Code = fromart;
    keystr = "Group";
    keys = 2;
  end;
  TrHs = true;
  while (LoopKey(keystr,INr,keys,TrHs)) begin
    testf = false;
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      if (nonblank(toart)) then begin
        if (INr.Code>toart) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      if (nonblank(RepSpec.AccStr)) then begin
        if (INr.Department!=RepSpec.AccStr) then begin
          testf = false;
        end;
      end;
      if (INr.ItemType!=1) then begin testf = false; end;
    end;
    if (testf) then begin
      pifound = FindRecQty(INr,ISr,Recr,t1,t2);          
      if (t1>0) then begin
        if (pifound) then begin
          DoProd(Recr,t1);
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure PasteQTInOrd(var record ORVc ORp,record QTVc QTp,string orderclass)
BEGIN
  record CUVc CUr;
  Integer i,rwcnt;
  record INVc INr;
  row ORVc ORrw;
  row QTVc QTrw;
  Integer srw;
  record PlanDeliveryBlock PlanDelRec;
  record OrdSettBlock OrdSettRec;
  record TaxMatrixVc TMr;
  
  BlockLoad(OrdSettRec);
  BlockLoad(PlanDelRec);
  ORp.OrderClass = orderclass;
  ORp.BankCode = QTp.BankCode;
  ORp.CustCode = QTp.CustCode;
  ORp.CustVATCode = QTp.CustVATCode;
  ORp.Addr0 = QTp.Addr0;
  ORp.Addr1 = QTp.Addr1;
  ORp.Addr2 = QTp.Addr2;
  ORp.Addr3 = QTp.Addr3;
  ORp.InvAddr3 = QTp.InvAddr3;
  ORp.InvAddr4 = QTp.InvAddr4;
  ORp.InvCountry = QTp.InvCountry;
  ORp.CustCat = QTp.CustCat;
  ORp.ShipAddr0 = QTp.ShipAddr0;
  ORp.ShipAddr1 = QTp.ShipAddr1;
  ORp.ShipAddr2 = QTp.ShipAddr2;
  ORp.ShipAddr3 = QTp.ShipAddr3;
  ORp.DelAddr3 = QTp.DelAddr3;
  ORp.DelAddr4 = QTp.DelAddr4;
  ORp.DelCountry = QTp.DelCountry;
  ORp.InvoiceToCode = QTp.InvoiceToCode;
  ORp.VATNr = QTp.VATNr;
  ORp.RvrsVAT = QTp.RvrsVAT;
  ORp.Phone = QTp.Phone;
  ORp.Fax = QTp.Fax;
  if (nonblank(QTp.OrgCust)) then begin
    CUr.Code = QTp.OrgCust;
    if (ReadFirstMain(CUr,1,true)) then begin
      ORp.CustCode = CUr.Code;
      ORp.InvoiceToCode = QTp.CustCode;
      ORp.Addr0 = CUr.Name;
      ORp.Addr1 = CUr.InvAddr0;
      ORp.Addr2 = CUr.InvAddr1;
      ORp.Addr3 = CUr.InvAddr2;
      ORp.InvAddr3 = CUr.InvAddr3;
      ORp.InvAddr4 = CUr.InvAddr4;
      ORp.InvCountry = CUr.CountryCode;
      ORp.CustCat = CUr.CustCat;
      ORp.ShipAddr0 = CUr.Name;
      ORp.ShipAddr1 = CUr.DelAddr0;
      ORp.ShipAddr2 = CUr.DelAddr1;
      ORp.ShipAddr3 = CUr.DelAddr2;
      ORp.DelAddr3 = CUr.DelAddr3;
      ORp.DelAddr4 = CUr.DelAddr4;
      ORp.DelCountry = CUr.DelCountry;
      ORp.VATNr = CUr.VATNr;
      ORp.Phone = CUr.Phone;
      ORp.Fax = CUr.Fax;
      ORp.RecipientGLN = CUr.RecipientGLN;
    end;
  end else begin
    CUr.Code = QTp.CustCode;
    if (ReadFirstMain(CUr,1,true)) then begin
      ORp.RecipientGLN = CUr.RecipientGLN;
    end;    
  end;

  ORp.OurContact = QTp.OurContact;
  ORp.CustContact = QTp.CustContact;
  ORp.OrdDate = CurrentDate;
  ORp.SalesGroup = QTp.SalesGroup;
  ORp.Location = QTp.Location;
  ORp.InvFlag = 0;
  ORp.ShipFlag = 0;
  ORp.Prntdf = 0;
  ORp.QuoteNr = QTp.SerNr;
  ORp.PayDeal = QTp.PayDeal;
  ORp.Objects = QTp.Objects;
  ORp.RefStr = QTp.RefStr;
  ORp.ShipMode = QTp.ShipMode;
  ORp.OrderStatus = 0;
  ORp.PlanShip = QTp.PlanShip;
  ORp.FrPrice = QTp.FrPrice;
  if (PlanDelRec.FieldType==1) then begin
    if (QTp.DaysToDelivery!=-1) then begin
      ORp.PlanShip = AddDay(ORp.OrdDate,QTp.DaysToDelivery);
    end;
  end;
  ORp.SalesMan = QTp.SalesMan;
  ORp.Sign = QTp.Sign; 
  ORp.ShipDeal = QTp.ShipDeal;
  ORp.DelAddrCode = QTp.DelAddrCode;
  ORp.Region = QTp.Region;
  ORp.CurncyCode = QTp.CurncyCode;
  ORp.LangCode = QTp.LangCode;
  ORp.Sorting = QTp.Sorting;
  ORp.PriceList = QTp.PriceList;
  ORp.InclVAT = QTp.InclVAT;
  ORp.NoTAXonVAT = QTp.NoTAXonVAT;
  ORp.TotalwoTAX = QTp.TotalwoTAX;
  ORp.FrRate = QTp.FrRate;
  ORp.ToRateB1 = QTp.ToRateB1;
  ORp.ToRateB2 = QTp.ToRateB2;
  ORp.BaseRate1 = QTp.BaseRate1;
  ORp.BaseRate2 = QTp.BaseRate2;
  ORp.Closed = 0;
  ORp.ExportFlag = QTp.ExportFlag;
  ORp.BuildOn = QTp.BuildOn;
  ORp.PRCode = QTp.PRCode;
  ORp.Comment = QTp.Comment;
  ORp.Comment2 = QTp.Comment2;
  ORp.Comment3 = QTp.Comment3;
  ORp.Comment4 = QTp.Comment4;
  ORp.InvOnlyOnFull = QTp.InvOnlyOnFull;
  if (OrdSettRec.QTClassToOR!=0) then begin
    ORp.OrderClass = QTp.QuoteClass;
  end;
  ORp.RebCode = QTp.RebCode;
  rwcnt = MatRowCnt(QTp);
  srw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(QTp,i,QTrw);
    if (QTrw.stp!=10) then begin
      ClearRow(ORp,ORrw,QTrw.stp);
      ORrw.stp = QTrw.stp;
      ORrw.ArtCode = QTrw.ArtCode;
      ORrw.CustArtCode = QTrw.CustArtCode;
      ReadFirstItem(ORrw.ArtCode,INr,false,false);
/* Not good to have at all!!
      INr.Code = ORrw.ArtCode;
      if (ReadFirstMain(INr,1,true)) then begin
        if (INr.ItemType==2) then begin  //BS not for stocked items. 
                                         //Creates problem with deficiency list
          if (nonblank(INr.Recepy)) then begin
            ORrw.Recepy = INr.Recepy;
          end;
        end;
      end;
*/
      ORrw.Salesmen = QTrw.Salesmen;
      ORrw.Recepy = QTrw.Recepy;
      ORrw.MotherArtCode = QTrw.MotherArtCode;
      ORrw.RecipeQuant = QTrw.RecipeQuant;
      ORrw.Quant = QTrw.Quant;
      ORrw.Spec = QTrw.Spec;
      ORrw.Price = QTrw.Price;
      ORrw.Sum = QTrw.Sum;
      ORrw.vRebate = QTrw.vRebate;
      ORrw.SalesAcc = QTrw.SalesAcc;
      ORrw.VATCode = QTrw.VATCode;
      ORrw.RvrsVATCode = QTrw.RvrsVATCode;
      ORrw.Shipd1 = blankval;
      ORrw.Shipd2 = blankval;
      ORrw.Invd = blankval;
      ORrw.Objects = QTrw.Objects;
      ORrw.UnitCode = QTrw.UnitCode;
      ORrw.UnitFactQuant = QTrw.UnitFactQuant;
      ORrw.UnitFactPrice = QTrw.UnitFactPrice;
      ORrw.UnitXval = QTrw.UnitXval;
      ORrw.UnitYval = QTrw.UnitYval;
      ORrw.UnitZval = QTrw.UnitZval;
      ORrw.BasePrice = QTrw.BasePrice;
      ORrw.rowGP = QTrw.rowGP;
      ORrw.PriceFactor = QTrw.PriceFactor;
      ORrw.VARList = QTrw.VARList;
      ORrw.TAX2Code = QTrw.TAX2Code;
      ORrw.TAX2Prc = QTrw.TAX2Prc;
      ORrw.TAX2Reb = QTrw.TAX2Reb;
      ORrw.TAX1Reb = QTrw.TAX1Reb;
      ORrw.TAX2Acc = QTrw.TAX2Acc;
      ORrw.VARList = QTrw.VARList;
      ORrw.TaxTemplateCode = QTrw.TaxTemplateCode;
      ORrw.Perceptions = INr.Perceptions;
      UnpackRowFieldMatrix(QTrw,"TaxMatrix",TMr);
      PackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
      RowCalculateTaxMatrix_ORVc(ORp,srw,ORrw);
      MatRowPut(ORp,srw,ORrw);
      srw = srw + 1;
    end else begin
      ClearRow(ORp,ORrw,10);
      MatRowPut(ORp,srw,ORrw);
      srw = srw + 1;
    end;
  end;
  ORp.DiscPerc = QTp.DiscPerc;
  ORp.DiscSum = QTp.DiscSum;
  ORp.TotVolume = QTp.TotVolume;
  ORp.TotWeight = QTp.TotWeight;
  ORp.TotQty = QTp.TotQty;
  ORSumup(ORp);
  AddPerceptionTaxesRows_ORVc(ORp);
  SetORFlags(ORp);
  RETURN;
END;

global
updating function Integer RecordAction_raPasteQTInOrder2(var record ORVc ORp,var record QTVc QTp,Boolean storef,string orderclass)
begin
  Integer res;
  record SRBlock SRRec;
  LongInt newnr;
  record QTVc oldQTr;         
  
  res = -1;
  if (ReadFirstMain(QTp,0,true)) then begin end;  
  RecordCopy(oldQTr,QTp);
  RecordNew(ORp);
  if (ORp.SerNr==-1) then begin
    BlockLoad(SRRec);
    newnr = GetCurUserLastNr("ORVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastOrdNr;
    end;    
    ORp.SerNr = NextSerNr("ORVc",ORp.OrdDate,newnr,false,"");
    if (ORp.SerNr==-1) then begin 
      res = 1747;
      goto LRecordAction_raPasteQTInOrder2; 
    end;
  end;
  PasteQTInOrd(ORp,QTp,orderclass);
  if ((MatRowCnt(ORp)>0) and (ORp.SerNr!=-1)) then begin
    QTp.OrderNr = ORp.SerNr;        
    res = 0;
    if (blankdate(QTp.RejectDate)) then begin
      QTp.RejectDate = CurrentDate;
    end;
    QTp.Rejected = 2;
    QTp.Probability = 100;
    if (RecordStore(ORp,false)) then begin 
      CreateRecordLink(ORp,CurrentCompany,QTp,CurrentCompany);  
      CreateRecordLink(QTp,CurrentCompany,ORp,CurrentCompany);        
    end;
    if (storef) then begin
      RecordUpdate(oldQTr,QTp,false);
    end;
  end;
LRecordAction_raPasteQTInOrder2:;
  RecordAction_raPasteQTInOrder2 = res;
  return;
end;

global
updating function Integer RecordAction_raPasteQTInOrder(var record ORVc ORp,var record QTVc QTp,Boolean storef)
begin
  RecordAction_raPasteQTInOrder = RecordAction_raPasteQTInOrder2(ORp,QTp,storef,"");
  return;
end;

procedure PasteSerialNumberItemToIV(record IVVc IVr,var Integer currow)
begin
  row IVVc curIVrw;
  row IVVc newIVrw;
  val rem;
  
  MatRowGet(IVr,currow,curIVrw);
  rem = curIVrw.Quant;
  while (rem>=1) begin
    CopyRow(IVr,curIVrw,newIVrw);
    newIVrw.Quant = 1;
    MatRowPut(IVr,currow,newIVrw);    
    IVDchsum(IVr,currow);
    currow = currow + 1;
    rem = rem - 1;
  end;
  return;
end;

procedure PasteQTInInv(var record IVVc IVp,record QTVc QTp)
begin
  Integer i,rwcnt;
  record AccBlock ARAccb;
  record CUVc CUr;
  record INVc INr;
  row IVVc IVrw;
  row QTVc QTrw;
  Integer srw;
  val from,to1,to2,base1,base2;
  record TaxMatrixVc TMr;
  string 255 custcode;
  val qrem;
  record SerNrTrackBlock SNrb;

  BlockLoad(ARAccb);
  BlockLoad(SNrb);
  if (nonblank(QTp.InvoiceToCode)) then begin
    custcode = QTp.InvoiceToCode;
  end else begin
    custcode = QTp.CustCode;
  end;

  IVp.CustCode = custcode;
  CUr.Code = IVp.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (CUr.IntRate!=0) then begin
      IVp.IntCode = CUr.IntRate;
    end;
  end;
  if (nonblank(QTp.InvoiceToCode)) then begin
    IVp.Addr0 = CUr.Name;
    IVp.Addr1 = CUr.InvAddr0;
    IVp.Addr2 = CUr.InvAddr1;
    IVp.Addr3 = CUr.InvAddr2;
    IVp.InvAddr3 = CUr.InvAddr3;
    IVp.InvAddr4 = CUr.InvAddr4;
    IVp.InvCountry = CUr.CountryCode;
    IVp.Region = CUr.Region;
    IVp.VATNr = CUr.VATNr;
    IVp.RegNr1 = CUr.RegNr1;
    IVp.OrgCust = QTp.CustCode;
  end else begin
    IVp.Addr0 = QTp.Addr0;
    IVp.Addr1 = QTp.Addr1;
    IVp.Addr2 = QTp.Addr2;
    IVp.Addr3 = QTp.Addr3;
    IVp.InvAddr3 = QTp.InvAddr3;
    IVp.InvAddr4 = QTp.InvAddr4;
    IVp.InvCountry = QTp.InvCountry;
    IVp.Region = QTp.Region;
    IVp.VATNr = QTp.VATNr;
  end;
  IVp.QTNr = QTp.SerNr;
  IVp.InvDate = CurrentDate;
  IVp.BankCode = QTp.BankCode;
  IVp.CustVATCode = QTp.CustVATCode;
  IVp.OurContact = QTp.OurContact;
  IVp.ClientContact = QTp.CustContact;
  if (nonblank(QTp.OrgCust)) then begin
    IVp.OrgCust = QTp.OrgCust;
  end;
  IVp.Prntdf = 0;
  IVp.RecipientGLN = QTp.RecipientGLN;
  IVp.PayDeal = QTp.PayDeal;
  PastePDInInv(IVp,"",false);
  IVp.CustCat = QTp.CustCat;
  IVp.Objects = QTp.Objects;
  IVp.RefStr = QTp.RefStr;
  IVp.ShipMode = QTp.ShipMode;
  IVp.SalesMan = QTp.SalesMan;
  IVVc_PasteSalesMan(IVp,"");
  IVp.Sign = QTp.Sign;
  IVp.ShipDeal = QTp.ShipDeal;
  IVp.ShipAddr0 = QTp.ShipAddr0;
  IVp.ShipAddr1 = QTp.ShipAddr1;
  IVp.ShipAddr2 = QTp.ShipAddr2;
  IVp.ShipAddr3 = QTp.ShipAddr3;
  IVp.DelAddr3 = QTp.DelAddr3;
  IVp.DelAddr4 = QTp.DelAddr4;
  IVp.DelCountry = QTp.DelCountry;
  IVp.DelAddrCode = QTp.DelAddrCode;
  IVp.CurncyCode = QTp.CurncyCode;
  IVp.Sorting = QTp.Sorting;
  IVp.LangCode = QTp.LangCode;
  IVp.PriceList = QTp.PriceList;
  IVp.InclVAT = QTp.InclVAT;
  IVp.NoTAXonVAT = QTp.NoTAXonVAT;
  IVp.TotalwoTAX = QTp.TotalwoTAX;
  IVp.FrRate = QTp.FrRate;
  IVp.ToRateB1 = QTp.ToRateB1;
  IVp.ToRateB2 = QTp.ToRateB2;
  IVp.BaseRate1 = QTp.BaseRate1;
  IVp.BaseRate2 = QTp.BaseRate2;
  IVp.Location = QTp.Location;
  IVp.FrPrice = QTp.FrPrice;
  IVp.RvrsVAT = QTp.RvrsVAT;
  if ((ARAccb.UpdBaseRate!=0) or (ARAccb.UpdForeginRate!=0)) then begin
    GetFullCurncyRate(IVp.CurncyCode,IVp.TransDate,from,to1,to2,base1,base2);
    if (ARAccb.UpdBaseRate!=0) then begin
      IVp.BaseRate1 = base1;
      IVp.BaseRate2 = base2;
    end;
    if (ARAccb.UpdForeginRate!=0) then begin
      IVp.FrRate = from;
      IVp.ToRateB1 = to1;
      IVp.ToRateB2 = to2;
    end;
  end;
  IVp.ExportFlag = QTp.ExportFlag;
  IVp.PRCode = QTp.PRCode;
  IVp.InvComment = QTp.Comment;
  IVp.RebCode = QTp.RebCode;
  IVp.Phone = QTp.Phone;
  IVp.Fax = QTp.Fax;
  rwcnt = MatRowCnt(QTp);
  srw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(QTp,i,QTrw);
    qrem = QTrw.Quant;
    if (QTp.DisallowInvoicemorethanQuoted!=0 and nonblank(QTrw.ArtCode)) then begin
      qrem = QTrw.Quant - QTrw.Invd;
      if (qrem<=0) then begin
        goto L22PasteQTInInv;
      end;
    end;
    ClearRow(IVp,IVrw,QTrw.stp);
    switch (IVrw.stp) begin
      case 9:
        if (QTrw.Invoiced!=-1) then begin goto L22PasteQTInInv; end;
        IVrw.QTRow = i;
        IVrw.Spec = QTrw.Spec;
        IVrw.Sum = QTrw.Sum;
        MatRowPut(IVp,srw,IVrw);
        srw = srw + 1;      
        goto L22PasteQTInInv;
      case 10:
        IVrw.Spec = QTrw.Spec;
        MatRowPut(IVp,srw,IVrw);
        srw = srw + 1;      
        goto L22PasteQTInInv;
      case 17:
        if (QTrw.Invoiced!=-1) then begin goto L22PasteQTInInv; end;
        IVrw.QTRow = i;
        IVrw.Spec = QTrw.Spec;
        MatRowPut(IVp,srw,IVrw);
        srw = srw + 1;      
        goto L22PasteQTInInv;
      otherwise
        if (blank(QTrw.ArtCode) and (QTrw.Sum!=0)) then begin goto L22PasteQTInInv; end;
        if (QTp.DisallowInvoicemorethanQuoted!=0 and nonblank(QTrw.ArtCode)) then begin
          if (qrem<=0) then begin goto L22PasteQTInInv; end;
        end else begin
//          if (QTrw.Invoiced!=-1) then begin goto L22PasteQTInInv; end; 
//in previous versions people where able to make as many invoices as they wanted from same qt
//JJ->people still want to invoice more than quoted , or even make several invoices from same quotation row, 
//if 1st invocie didnt have enough qty
//          if (QTrw.Invoiced!=-1 and nonblank(QTrw.ArtCode)) then begin goto L22PasteQTInInv; end;
        end;
        if (QTrw.InvAfter>CurrentDate) then begin goto L22PasteQTInInv; end;      
    end;
    IVrw.OrdRow = -1;
    IVrw.Salesmen = QTrw.Salesmen;
    IVrw.ArtCode = QTrw.ArtCode;
    IVrw.CustArtCode = QTrw.CustArtCode;
    IVrw.ServiceDelDate = QTrw.ServiceDelDate;
    IVrw.Quant = qrem;
    IVrw.Spec = QTrw.Spec;
    IVrw.Price = QTrw.Price;
    IVrw.Sum = QTrw.Sum;
    IVrw.vRebate = QTrw.vRebate;
    IVrw.SalesAcc = QTrw.SalesAcc;
    IVrw.VATCode = QTrw.VATCode;
    IVrw.RvrsVATCode = QTrw.RvrsVATCode;
    IVrw.Objects = QTrw.Objects;
    IVrw.UnitCode = QTrw.UnitCode;
    IVrw.UnitFactQuant = QTrw.UnitFactQuant;
    IVrw.UnitFactPrice = QTrw.UnitFactPrice;
    IVrw.UnitXval = QTrw.UnitXval;
    IVrw.UnitYval = QTrw.UnitYval;
    IVrw.UnitZval = QTrw.UnitZval;
    IVrw.BasePrice = QTrw.BasePrice;
    IVrw.rowGP = QTrw.rowGP;
    IVrw.PriceFactor = QTrw.PriceFactor;
    IVrw.VARList = QTrw.VARList;
    if (ReadFirstItem(QTrw.ArtCode,INr,false,false)) then begin
/* Why why why?
      if ((INr.ItemType==3) and (nonblank(INr.Recepy))) then begin
        IVrw.Recepy = INr.Recepy;
      end;
*/
      IVrw.RepaExVAT = CalcItemRepa(INr.RepaPricePerWeight,INr.Weight,IVrw.Quant,IVp.CurncyCode,
                                    IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
    end;
    IVrw.Recepy = QTrw.Recepy;
    IVrw.MotherArtCode = QTrw.MotherArtCode;
    IVrw.RecipeQuant = QTrw.RecipeQuant;
    IVrw.QTRow = i;

    IVrw.TAX2Code = QTrw.TAX2Code;
    IVrw.TAX2Prc = QTrw.TAX2Prc;
    IVrw.TAX2Reb = QTrw.TAX2Reb;
    IVrw.TAX1Reb = QTrw.TAX1Reb;
    IVrw.TAX2Acc = QTrw.TAX2Acc;
    IVrw.Perceptions = INr.Perceptions;
    IVrw.TaxTemplateCode = QTrw.TaxTemplateCode;
    UnpackRowFieldMatrix(QTrw,"TaxMatrix",TMr);
    PackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
    RowCalculateTaxMatrix_IVVc(IVp,srw,IVrw);
    MatRowPut(IVp,srw,IVrw);
    IVDchrsum(IVp,srw);
    MatRowGet(IVp,srw,IVrw);
    if ((IVrw.Sum==0) and (IVrw.Quant==blankval) and (IVrw.Price==blankval)) then begin
      IVrw.Sum = blankval;
    end;
    MatRowPut(IVp,srw,IVrw);
    IVDchsum(IVp,srw);
    if (INr.SerNrf==1) and (SNrb.BulkSerialNos==0) then begin
      PasteSerialNumberItemToIV(IVp,srw);
    end else begin
      srw = srw + 1;
    end;
L22PasteQTInInv:;
  end;
  IVp.DiscPerc = QTp.DiscPerc;
  IVp.DiscSum = QTp.DiscSum;
  IVp.TotVolume = QTp.TotVolume;
  IVp.TotWeight = QTp.TotWeight;
  IVp.TotQty = QTp.TotQty;
  IVp.TAX1Sum = QTp.TAX1Sum;
  IVp.TAX2Sum = QTp.TAX2Sum;
  AddPerceptionTaxesRows_IVVc(IVp);
  AddWithholdingTaxesRows_IVVc(IVp);
  IVSumup(IVp,true);
  if (nonblank(CUr.CompItemCode)) then begin
    PasteCompulsoryINtoIV(CUr.CompItemCode,IVp);
  end;
  AddCredManDeposit(IVp,QTp.SerNr);
//  IVp.OfficialSerNr = FindNextLegalSerNr(IVp,CUr.Classification);  //POSN
  RETURN;
END;

global
updating function Integer RecordAction_raPasteQTInInv(var record IVVc IVp,var record QTVc QTp,var Integer errcode,Boolean storef)
BEGIN
  Integer res;
  record SRBlock SRRec;
  LongInt newnr;
  string 255 tstr;
  record QTVc oldQTr;
  
  res = -1;
  if (ReadFirstMain(QTp,0,true)) then begin end;  
  RecordCopy(oldQTr,QTp);
  RecordNew(IVp);
  PasteQTInInv(IVp,QTp);
  if (IVp.SerNr==-1) then begin
    BlockLoad(SRRec);
    newnr = GetCurUserLastNr("IVVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastInvNr;
    end;    
    IVp.SerNr = NextSerNr("IVVc",IVp.TransDate,newnr,false,"");
    if (IVp.SerNr==-1) then begin goto LRecordAction_raPasteQTInInv; end;
  end;
  if (HasLocalization("ARG")) then begin 
    IVp.BranchID = CurBranchID;
    if (blank(IVp.BranchID)) then begin
      IVp.BranchID = QTp.BranchID;
    end;
  end;
  if ((MatRowCnt(IVp)>0) and (IVp.SerNr!=-1)) then begin
    if (AssignOfficialSerNr==false) then begin
      FindNextIVVcOfficialSerialNr(IVp);
    end;
    if (RecordStore(IVp,false)) then begin //QT has changed
//      ReadFirstMain(QTp,0,true);
      CreateRecordLink(IVp,CurrentCompany,QTp,CurrentCompany);  
      CreateRecordLink(QTp,CurrentCompany,IVp,CurrentCompany);  
      if (blankdate(QTp.RejectDate)) then begin
        QTp.RejectDate = CurrentDate;
      end;
      QTp.Rejected = 2;
      QTp.Probability = 100;
      if (storef) then begin
        RecordUpdate(oldQTr,QTp,false);
      end;
    end;
    UpdateCredMan(IVp,QTp.SerNr,errcode);
    res = 1;
  end;
LRecordAction_raPasteQTInInv:;
  RecordAction_raPasteQTInInv = res;
  RETURN;
END;

procedure PasteQTInIVCash(var record IVCashVc IVCashp,record QTVc QTp)
BEGIN
  Integer i,rwcnt;
  record AccBlock ARAccb;
  record CUVc CUr;
  record INVc INr;
  row IVCashVc IVCashrw;
  row QTVc QTrw;
  Integer srw;
  val from,to1,to2,base1,base2;
  record TaxMatrixVc TMr;
  string 255 custcode;
  val qrem;
  
  BlockLoad(ARAccb);
  if (nonblank(QTp.InvoiceToCode)) then begin
    custcode = QTp.InvoiceToCode;
  end else begin
    custcode = QTp.CustCode;
  end;
  IVCashp.CustCode = custcode;
  CUr.Code = IVCashp.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
  end;
  if (nonblank(QTp.InvoiceToCode)) then begin
    IVCashp.Addr0 = CUr.Name;
    IVCashp.Addr1 = CUr.InvAddr0;
    IVCashp.Addr2 = CUr.InvAddr1;
    IVCashp.Addr3 = CUr.InvAddr2;
    IVCashp.InvAddr3 = CUr.InvAddr3;
    IVCashp.InvAddr4 = CUr.InvAddr4;
//    IVCashp.InvCountry = CUr.CountryCode;
    IVCashp.Region = CUr.Region;
    IVCashp.VATNr = CUr.VATNr;
  end else begin
    IVCashp.Addr0 = QTp.Addr0;
    IVCashp.Addr1 = QTp.Addr1;
    IVCashp.Addr2 = QTp.Addr2;
    IVCashp.Addr3 = QTp.Addr3;
    IVCashp.InvAddr3 = QTp.InvAddr3;
    IVCashp.InvAddr4 = QTp.InvAddr4;
//    IVCashp.InvCountry = QTp.InvCountry;
    IVCashp.Region = QTp.Region;
    IVCashp.VATNr = QTp.VATNr;
  end;
//  IVCashp.QTNr = QTp.SerNr;
  IVCashp.InvDate = CurrentDate;
  IVCashp.CustVATCode = QTp.CustVATCode;
  IVCashp.OurContact = QTp.OurContact;
  IVCashp.ClientContact = QTp.CustContact;
  IVCashp.Prntdf = 0;
  IVCashp.PayDeal = QTp.PayDeal;
  IVCashp.CustCat = QTp.CustCat;
  IVCashp.Objects = QTp.Objects;
  IVCashp.RefStr = QTp.RefStr;
//  IVCashp.ShipMode = QTp.ShipMode;
  IVCashp.SalesMan = QTp.SalesMan;
//  IVCashp.Sign = QTp.Sign;
//  IVCashp.ShipDeal = QTp.ShipDeal;
  IVCashp.CurncyCode = QTp.CurncyCode;
//  IVCashp.Sorting = QTp.Sorting;
  IVCashp.LangCode = QTp.LangCode;
  IVCashp.PriceList = QTp.PriceList;
  IVCashp.InclVAT = QTp.InclVAT;
  IVCashp.NoTAXonVAT = QTp.NoTAXonVAT;
  IVCashp.TotalwoTAX = QTp.TotalwoTAX;
  IVCashp.FrRate = QTp.FrRate;
  IVCashp.ToRateB1 = QTp.ToRateB1;
  IVCashp.ToRateB2 = QTp.ToRateB2;
  IVCashp.BaseRate1 = QTp.BaseRate1;
  IVCashp.BaseRate2 = QTp.BaseRate2;
  IVCashp.Location = QTp.Location;
  IVCashp.InvComment = QTp.Comment;
  IVCashp.RebCode = QTp.RebCode;
//  IVCashp.Phone = QTp.Phone;
//  IVCashp.Fax = QTp.Fax;
  rwcnt = MatRowCnt(QTp);
  srw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(QTp,i,QTrw);
    qrem = QTrw.Quant;
    ClearRow(IVCashp,IVCashrw,QTrw.stp);
    switch (IVCashrw.stp) begin
      case 9:
        IVCashrw.Spec = QTrw.Spec;
        IVCashrw.Sum = QTrw.Sum;
        MatRowPut(IVCashp,srw,IVCashrw);
        srw = srw + 1;      
        goto L22PasteQTInIVCash;
      case 10:
        IVCashrw.Spec = QTrw.Spec;
        MatRowPut(IVCashp,srw,IVCashrw);
        srw = srw + 1;      
        goto L22PasteQTInIVCash;
      case 17:
        IVCashrw.Spec = QTrw.Spec;
        MatRowPut(IVCashp,srw,IVCashrw);
        srw = srw + 1;      
        goto L22PasteQTInIVCash;
      otherwise
        if (blank(QTrw.ArtCode) and (QTrw.Sum!=0)) then begin goto L22PasteQTInIVCash; end;
        if (QTrw.InvAfter>CurrentDate) then begin goto L22PasteQTInIVCash; end;      
    end;
    IVCashrw.OrdRow = -1;
    IVCashrw.Salesmen = QTrw.Salesmen;
    IVCashrw.ArtCode = QTrw.ArtCode;
    IVCashrw.CustArtCode = QTrw.CustArtCode;
    IVCashrw.Quant = qrem;
    IVCashrw.Spec = QTrw.Spec;
    IVCashrw.Price = QTrw.Price;
    IVCashrw.Sum = QTrw.Sum;
    IVCashrw.vRebate = QTrw.vRebate;
    IVCashrw.SalesAcc = QTrw.SalesAcc;
    IVCashrw.VATCode = QTrw.VATCode;
    IVCashrw.Objects = QTrw.Objects;
    IVCashrw.UnitCode = QTrw.UnitCode;
    IVCashrw.UnitFactQuant = QTrw.UnitFactQuant;
    IVCashrw.UnitFactPrice = QTrw.UnitFactPrice;
    IVCashrw.UnitXval = QTrw.UnitXval;
    IVCashrw.UnitYval = QTrw.UnitYval;
    IVCashrw.UnitZval = QTrw.UnitZval;
    IVCashrw.BasePrice = QTrw.BasePrice;
    IVCashrw.rowGP = QTrw.rowGP;
    IVCashrw.PriceFactor = QTrw.PriceFactor;
    IVCashrw.Recepy = QTrw.Recepy;
    IVCashrw.MotherArtCode = QTrw.MotherArtCode;
    IVCashrw.RecipeQuant = QTrw.RecipeQuant;
//    IVCashrw.QTRow = i;

    IVCashrw.TAX2Code = QTrw.TAX2Code;
    IVCashrw.TAX2Prc = QTrw.TAX2Prc;
    IVCashrw.TAX2Reb = QTrw.TAX2Reb;
    IVCashrw.TAX1Reb = QTrw.TAX1Reb;
    IVCashrw.TAX2Acc = QTrw.TAX2Acc;
//    IVCashrw.Perceptions = INr.Perceptions;
    IVCashrw.TaxTemplateCode = QTrw.TaxTemplateCode;
    UnpackRowFieldMatrix(QTrw,"TaxMatrix",TMr);
    PackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
    RowCalculateTaxMatrix_IVCashVc(IVCashp,srw,IVCashrw);
    MatRowPut(IVCashp,srw,IVCashrw);
    IVCashDchrsum(IVCashp,srw,0);
    IVCashDchsum(IVCashp,srw);
    srw = srw + 1;
L22PasteQTInIVCash:;
  end;
  IVCashp.TotVolume = QTp.TotVolume;
  IVCashp.TotWeight = QTp.TotWeight;
  IVCashp.TotQty = QTp.TotQty;
  IVCashp.TAX1Sum = QTp.TAX1Sum;
  IVCashp.TAX2Sum = QTp.TAX2Sum;
  IVCashSumup(IVCashp,true);
  RETURN;
END;

global
updating function Integer RecordAction_raPasteQTInIVCash(var record IVCashVc IVCashp,var record QTVc QTp,var Integer errcode,Boolean storef)
BEGIN
  Integer res;
  record SRBlock SRRec;
  LongInt newnr;
  string 255 tstr;
  record QTVc oldQTr;
  
  res = -1;
  if (ReadFirstMain(QTp,0,true)) then begin end;  
  RecordCopy(oldQTr,QTp);
  RecordNew(IVCashp);
  PasteQTInIVCash(IVCashp,QTp);
  if (IVCashp.SerNr==-1) then begin
    BlockLoad(SRRec);
    newnr = GetCurUserLastNr("IVCashVc");
    if (newnr==-1) then begin
      newnr = SRRec.LastInvNr;
    end;    
    IVCashp.SerNr = NextSerNr("IVCashVc",IVCashp.TransDate,newnr,false,"");
    if (IVCashp.SerNr==-1) then begin goto LRecordAction_raPasteQTInIVCash; end;
  end;
  if ((MatRowCnt(IVCashp)>0) and (IVCashp.SerNr!=-1)) then begin
    if (RecordStore(IVCashp,false)) then begin //QT has changed
//      ReadFirstMain(QTp,0,true);
      CreateRecordLink(IVCashp,CurrentCompany,QTp,CurrentCompany);  
      CreateRecordLink(QTp,CurrentCompany,IVCashp,CurrentCompany);  
      if (blankdate(QTp.RejectDate)) then begin
        QTp.RejectDate = CurrentDate;
      end;
      QTp.Rejected = 2;
      QTp.Probability = 100;
      if (storef) then begin
        RecordUpdate(oldQTr,QTp,false);
      end;
    end;
    res = 1;
  end;
LRecordAction_raPasteQTInIVCash:;
  RecordAction_raPasteQTInIVCash = res;
  RETURN;
END;

global
function Boolean PasteFunderInCO(var record COVc COp)
BEGIN
  record CUVc CUr;
  Boolean found;

  CUr.Code = COp.FunderCode;
  found = ReadFirstMain(CUr,1,true);
  if (found) then begin
    COp.FunderName = CUr.Name;
  end;
  PasteFunderInCO = found;
  RETURN;
END;

global
function Boolean PasteVEInCO(var record COVc COp)
BEGIN
  record CUVc VEr;
  Boolean found;

  VEr.Code = COp.VECode;
  found = ReadFirstMain(VEr,1,true);
  if (found) then begin
    if (VEr.blockedFlag!=0) then begin found = false; end;
  end;
  if (found) then begin
    COp.VEName = VEr.Name;
    COp.VEContact = VEr.Person;
  end;
  PasteVEInCO = found;
  RETURN;
END;

procedure PasteCQInCO(record COVc COp,record CQVc CQp)
BEGIN
  row CQVc CQrw;
  row COVc COrw;
  Boolean calcpricef;
  Integer i,rwcnt;
  Integer srw;
  record INVc INr;
  record GeneralOptionBlock GenOptr;
  string 255 curitemname,salesacc,vatcode,tax2code,taxtemplatecode;
  val t,price,vreb,baseprice,tax2prc;
  Boolean dummyf;
  Time blankt;
  
  BlockLoad(GenOptr);
  if (CQp.CONr!=-1) then begin goto LPasteCQInCO; end;
  COp.CQNr = CQp.SerNr;
  COp.CQVersion = CQp.Version;
  COp.CustCode = CQp.CustCode;
  if (PasteCust2InCO(COp,true,curitemname)) then begin end;
  COp.FunderCode = CQp.FunderCode;
  if (PasteFunderInCO(COp)) then begin end;
  COp.VECode = CQp.VECode;
  if (PasteVEInCO(COp)) then begin end;
  COp.OurContact = CQp.OurContact;
  COp.ClientContact = CQp.ClientContact;
  COp.InvComment = CQp.Text0;
  COp.SalesMan = CQp.SalesMan;
  COp.CurncyCode = "";
  COp.LangCode = "";
  COp.FrRate = blankval;
  COp.ToRateB1 = blankval;
  COp.ToRateB2 = blankval;
  COp.BaseRate1 = blankval;
  COp.BaseRate2 = blankval;
  COp.perType = CQp.perType;
  COp.perLength = CQp.perLength;
  COp.invTimes = CQp.invTimes;
  COp.QBond = CQp.QBond;
  COp.PurOpt = CQp.PurOpt;
  COp.SWAPOpt = CQp.SWAPOpt;
  COp.ContractClass = CQp.ContractClass;
  rwcnt = MatRowCnt(CQp);
  srw = 0;
  for (i = 0;i<rwcnt;i=i+1) begin
    MatRowGet(CQp,i,CQrw);
    ClearRow(COp,COrw,1);
    COrw.Price = blankval;
    COrw.vRebate = blankval;
    COrw.stp = 1;
    COrw.ArtCode = CQrw.ArtCode;
    COrw.Quant = CQrw.Quant;
    COrw.Spec = CQrw.Spec;
    COrw.Price = CQrw.Price;
    COrw.Type = CQrw.Type;
    COrw.PurPrice = CQrw.PurPrice;
    COrw.BiVECode = CQrw.BiVECode;
    COrw.PeriodSum = CQrw.PeriodSum;
    if (GetItemPriceDiscount3(COrw.ArtCode,COrw.Quant,INr,COp.CurncyCode,
                              COp.FrRate,COp.ToRateB1,COp.ToRateB2,COp.BaseRate1,COp.BaseRate2,
                              COp.LangCode,COp.CustCat,COp.PriceList,COp.RebCode,
                              price,curitemname,vreb,vatcode,baseprice,salesacc,
                              COp.ExportFlag,calcpricef,COp.CODate,blankt,COp.CustCode,true,dummyf,COp.PayDeal,tax2code,tax2prc,"","",taxtemplatecode)) then begin
      COrw.Price = price;
      COrw.Spec = curitemname;
      COrw.vRebate = vreb;
      COrw.VATCode = vatcode;
      COrw.BasePrice = baseprice;
      COrw.SalesAcc = salesacc;
      COrw.ArtCode = INr.Code;
      if (nonblank(COp.CustVATCode)) then begin COrw.VATCode = COp.CustVATCode; end;
      COrw.Contact = "";
      COrw.Objects = FindINObjects(INr.Objects,INr.Group);
      COrw.PriceFactor = INr.PriceFactor;
      CalcSum(COrw.Quant,COrw.Price,COrw.PriceFactor,COrw.vRebate,t,GenOptr.UseDiscount);
      COrw.Sum = t;
      MatRowPut(COp,i,COrw);
      if (calcpricef) then begin
        COVcGetCalcItemPrice(COp,i,t);
      end;
    end;
  end;
LPasteCQInCO:;
  RETURN;
END;

global
updating function Integer RecordAction_raPasteCQInCOr(var record COVc COp,var record CQVc CQp,Boolean readf)
BEGIN
  Integer res;
  record SRBlock SRRec;
  string 255 tstr;
  record CQVc oldCQr;
  
  RecordNew(COp);
  if (readf) then begin
    if (ReadFirstMain(CQp,0,true)) then begin end;  
  end;  
  PasteCQInCO(COp,CQp);
  if (COp.SerNr==-1) then begin
    COp.SerNr = NextSerNr("COVc",COp.CODate,-1,false,"");
    if (COp.SerNr==-1) then begin goto LRecordAction_raPasteCQInCOr; end;
  end;
  if ((MatRowCnt(COp)>0) and (COp.SerNr!=-1)) then begin
    COSumup(COp);
    if (RecordStore(COp,false)) then begin end;
    res = 1;
    RecordCopy(oldCQr,CQp);
    CQp.CONr = COp.SerNr;
    if (RecordUpdate(oldCQr,CQp,true)==0) then begin
    end;    
  end;
LRecordAction_raPasteCQInCOr:;
  RecordAction_raPasteCQInCOr = res;
  RETURN;
END;

procedure PasteInvInCO(record COVc COp,record IVVc IVp)
BEGIN
  record GeneralOptionBlock GenOptr;
  record INVc INr;
  row IVVc IVrw;
  row COVc COrw;
  Boolean calcpricef;
  Integer i,rwcnt,cnt;
  Integer srw;
  string 255 curitemname,salesacc,vatcode,tax2code,taxtemplatecode;
  val t,price,vreb,baseprice,tax2prc;
  Boolean dummyf;
  Time blankt;
  record TaxMatrixVc TMr;
  
  BlockLoad(GenOptr);
  COp.InvoiceNr = IVp.SerNr;
  COp.CQVersion = -1;
  COp.CODate = IVp.InvDate;
  COp.CustCode = IVp.CustCode;
  if (PasteCust2InCO(COp,true,curitemname)) then begin end;
  COp.FunderCode = "";
  COp.FunderName = "";
  COp.VECode = "";
  COp.VEName = "";
  COp.VEContact = "";
  COp.Phone = IVp.Phone;
  COp.Fax = IVp.Fax;
  COp.OurContact = IVp.OurContact;
  COp.ClientContact = IVp.ClientContact;
  COp.InvComment = IVp.InvComment;
  COp.SalesMan = IVp.SalesMan;
  COp.CurncyCode = IVp.CurncyCode;
  COp.LangCode = IVp.LangCode;
  COp.FrRate = IVp.FrRate;
  COp.ToRateB1 = IVp.ToRateB1;
  COp.ToRateB2 = IVp.ToRateB2;
  COp.BaseRate1 = IVp.BaseRate1;
  COp.BaseRate2 = IVp.BaseRate2;
  COp.PurOpt = "";
  COp.SWAPOpt = "";
//  COp.ContractClass = "";
//  COp.perLength = 1; it is in recorddefaults
//  COp.normalFactor = blankval;
  rwcnt = MatRowCnt(IVp);
  srw = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    INr.Code = IVrw.ArtCode;
    if (ReadFirstItem(IVrw.ArtCode,INr,false,false)) then begin
      if (nonblank(INr.ContractItem)) then begin
        ClearRow(COp,COrw,1);
        COrw.stp = 1;
        COrw.ArtCode = INr.ContractItem;
        COrw.OrgArtCode = IVrw.ArtCode;
        COrw.OrgSerNr = IVrw.SerialNr;
        COrw.Quant = IVrw.Quant;
        COrw.Type = "";
        if (GetItemPriceDiscount3(COrw.ArtCode,COrw.Quant,INr,COp.CurncyCode,
                                  COp.FrRate,COp.ToRateB1,COp.ToRateB2,COp.BaseRate1,COp.BaseRate2,
                                  COp.LangCode,COp.CustCat,COp.PriceList,COp.RebCode,
                                  price,curitemname,vreb,vatcode,baseprice,salesacc,
                                  COp.ExportFlag,calcpricef,COp.CODate,blankt,COp.CustCode,true,dummyf,COp.PayDeal,tax2code,tax2prc,"","",taxtemplatecode)) then begin
          COrw.Price = price;
          COrw.Spec = curitemname;
          COrw.vRebate = vreb;
          COrw.VATCode = vatcode;
          COrw.BasePrice = baseprice;
          COrw.SalesAcc = salesacc;
          COrw.ArtCode = INr.Code;
          if (nonblank(COp.CustVATCode)) then begin COrw.VATCode = COp.CustVATCode; end;

            
          COrw.Contact = "";
          COrw.Objects = FindINObjects(INr.Objects,INr.Group);
          COrw.PriceFactor = INr.PriceFactor;
          CalcSum(COrw.Quant,COrw.Price,COrw.PriceFactor,COrw.vRebate,t,GenOptr.UseDiscount);
          COrw.Sum = t;
          COrw.TaxTemplateCode = IVrw.TaxTemplateCode;
          UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
          PackRowFieldMatrix(COrw,"TaxMatrix",TMr);
          RowCalculateTaxMatrix_COVc(COp,cnt,COrw);
          MatRowPut(COp,cnt,COrw);
          cnt = cnt + 1;
          if (calcpricef) then begin
            COVcGetCalcItemPrice(COp,i,t);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating function Integer RecordAction_raPasteInvInCO(var record COVc COp,var record IVVc IVp)
BEGIN
  Integer res;
  record SRBlock SRRec;
  string 255 tstr;
  
  if (ReadFirstMain(IVp,0,true)) then begin end;  
  RecordNew(COp);
  PasteInvInCO(COp,IVp);
  if (COp.SerNr==-1) then begin
    COp.SerNr = NextSerNr("COVc",COp.CODate,-1,false,"");
    if (COp.SerNr==-1) then begin goto LRecordAction_raPasteInvInCO; end;
  end;
  if ((MatRowCnt(COp)>0) and (COp.SerNr!=-1)) then begin
    COSumup(COp);
    if (RecordStore(COp,false)) then begin 
      CreateRecordLink(COp,CurrentCompany,IVp,CurrentCompany);  
      CreateRecordLink(IVp,CurrentCompany,COp,CurrentCompany);  
    end;
    res = 1;
  end;
LRecordAction_raPasteInvInCO:;
  RecordAction_raPasteInvInCO = res;
  RETURN;
END;

global
updating function Boolean UpdateIntOrderFromStockMov(record StockMovVc StockMovp,record StockMovVc StockMov2p,Boolean sh2only)
BEGIN
  Integer i,rwcnt;
  row StockMovVc StockMovrw;
  record IntORVc oldIntORr;
  record IntORVc IntORr;
  record IntORSettingBlock IORSb;
  row IntORVc IntORrw;
  Integer orw,orcnt;
  Boolean updatesentf;
  Boolean treatedf;
  
  treatedf = false;
  if (RecordValid(StockMovp)) then begin
    IntORr.SerNr = StockMovp.IntORNo;
  end else begin
    IntORr.SerNr = StockMov2p.IntORNo;
  end;
  if (ReadFirstMain(IntORr,1,true)) then begin
    RecordCopy(oldIntORr,IntORr)
    orcnt = MatRowCnt(IntORr);    
    if (RecordValid(StockMov2p)) then begin
    if (StockMov2p.SerNr!=-1) then begin
      rwcnt = MatRowCnt(StockMov2p);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(StockMov2p,i,StockMovrw);
        if (StockMovrw.IntORRow!=-1) then begin
          orw = StockMovrw.IntORRow;
          if (orw<orcnt) then begin
            MatRowGet(IntORr,orw,IntORrw);
            if (sh2only==false) then begin
              if (StockMovrw.SentQuant>0) then begin
                IntORrw.Shipd1 = IntORrw.Shipd1 - StockMovrw.SentQuant;
              end else begin
                IntORrw.Shipd1 = IntORrw.Shipd1 - StockMovrw.Quant;
              end;
//              IntORrw.Shipd1 = IntORrw.Shipd1 - StockMovrw.OrdQuant;
            end;
            if (StockMov2p.OKFlag!=0) then begin
              IntORrw.Shipd2 = IntORrw.Shipd2 - StockMovrw.Quant;
            end;
/*            
            if (StockMov2p.SentOKFlag!=0) then begin
              IntORrw.Sent = IntORrw.Sent - StockMovrw.SentQuant;
            end;
*/            
            if (IntORrw.Shipd1==0) then begin
              IntORrw.Shipd1 = blankval;
            end;
            if (IntORrw.Shipd2==0) then begin
              IntORrw.Shipd2 = blankval;
            end;
            if (IntORrw.Shipd1!=0 or IntORrw.Shipd1!=0) then begin
              treatedf = true;
            end;
            MatRowPut(IntORr,orw,IntORrw);
          end;
        end;
      end;
      end;
    end;
    if (RecordValid(StockMovp)) then begin
      rwcnt = MatRowCnt(StockMovp);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(StockMovp,i,StockMovrw);
        if (StockMovrw.IntORRow!=-1) then begin
          orw = StockMovrw.IntORRow;
          if (orw<orcnt) then begin
            MatRowGet(IntORr,orw,IntORrw);
            if (sh2only==false) then begin
              if (StockMovrw.SentQuant>0) then begin
                IntORrw.Shipd1 = IntORrw.Shipd1 + StockMovrw.SentQuant;
              end else begin
                IntORrw.Shipd1 = IntORrw.Shipd1 + StockMovrw.Quant;
              end;
//              IntORrw.Shipd1 = IntORrw.Shipd1 + StockMovrw.OrdQuant;
            end;
            if (StockMovp.OKFlag!=0) then begin
              IntORrw.Shipd2 = IntORrw.Shipd2 + StockMovrw.Quant;
              if (IntORrw.Shipd2==0) then begin
                IntORrw.Shipd2 = blankval;
              end;
            end;
            updatesentf = false;
            if (StockMovp.SentOKFlag!=0) then begin
              updatesentf = true;
            end;  
            if (RecordValid(StockMov2p)) then begin
              if (StockMov2p.SentOKFlag!=0) then begin
                updatesentf = false;
              end;
            end;
            if (updatesentf) then begin          
              IntORrw.Sent = IntORrw.Sent + StockMovrw.SentQuant;
            end;
            if (IntORrw.Shipd1==0) then begin
              IntORrw.Shipd1 = blankval;
            end;
            if (IntORrw.Shipd1!=0 or IntORrw.Shipd1!=0) then begin
              treatedf = true;
            end;
            MatRowPut(IntORr,orw,IntORrw);
          end;
        end;
      end;
    end;
    SetIntORFlags(IntORr);
    if (treatedf) then begin
      BlockLoad(IORSb);
      if (IORSb.AutoCloseIntOR!=0) then begin
        IntORr.Closed = 1;
      end;
    end;
    if (RecordUpdate(oldIntORr,IntORr,false)==0) then begin
    end;
  end;
  UpdateIntOrderFromStockMov = true;
  RETURN;
END;

global
procedure RecordAction_raStockMovFillFIFO(var record StockMovVc StockMovr)
BEGIN
  record StockMovVc StockMov2r;
  
  UpdateStockMovFIFO(StockMovr,StockMov2r,0);//StockMovFillFIFO(StockMovr)
  RETURN;
END;

global
procedure RecAction_raBud1Sumup(var record Bud1Vc Bud1r)
BEGIN
  Bud1Sumup(Bud1r);
  RETURN;
END;

global
procedure RecAction_raBud1AccObjCalc(var record Bud1Vc Bud1r)
BEGIN
  Bud1AccObjCalc(Bud1r);
  RETURN;
END;

global
updating function Integer RecordAction_rlOrderToPO(var record ORVc ORp,var string errstr)
BEGIN
  record RcVc RepSpec;
  Integer res,err;
  
  if (IsRecordLocked(ORp)) then begin goto LRecordAction_rlOrderToPO; end;
  if (ReadFirstMain(ORp,0,true)) then begin end;  
  RepSpec.f1 = ORp.SerNr;
  RepSpec.sEndDate = ORp.OrdDate;
  RepSpec.sStartDate = ORp.OrdDate;
  RepSpec.ArtMode = 0;
  RepSpec.flags[1] = 0;
  RepSpec.flags[2] = 0;
  RepSpec.flags[3] = 0;//if 1 than it is not per order but for Instock Qty
  RepSpec.flags[4] = 2;
  res = GenPOFromORMn2(RepSpec,errstr);
LRecordAction_rlOrderToPO:;
  RecordAction_rlOrderToPO = res;
  RETURN;
END;

global
updating function Boolean RecordAction_rlSHLOK(var record SHVc SHp)
BEGIN
  Boolean res;
  record SHVc oldSHp;
  
  if (IsRecordLocked(SHp)==false) then begin
    if (ReadFirstMain(SHp,0,true)) then begin end;  
    RecordCopy(oldSHp,SHp);
//    res = acSHLOK(SHp);
//    if (res) then begin
    if (SHp.OKFlag==0) then begin
      SHp.OKFlag = 1;
      if (RecordUpdate(oldSHp,SHp,true)==0) then begin
        res = true;
      end;
    end;
  end;
  RecordAction_rlSHLOK = res;
  RETURN;
END;