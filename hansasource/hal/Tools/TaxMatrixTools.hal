external function roundmode GetVATRoundModeRB();
external function val AbsoluteVal(val);
external procedure ExtractObj(string,var Integer,var string);
external function string 60 AddObjectToObjectList(string,string);
external procedure B1ToB2Val(val,val,val,var val);
external function roundmode DefaultRoundMode();
external procedure GetVATdouble(string,var val,var val,Integer);
external procedure GetVATRow(string,var row VATCodeBlock);
external function Integer VATType(string);

function val CalculateTaxValue(string vatcode,val vatrate,val abaseval,Integer InclVAT,Integer NoTAXonVAT) 
begin
  val res;
  val vatperc,tax1percdummy,baseval,absbaseval;
  row VATCodeBlock VATCbrw;
  Boolean testf,exprcf;
  
  GetVATRow(vatcode,VATCbrw);
  baseval = abaseval;
  absbaseval = AbsoluteVal(baseval);
  testf = true;
  if (nonblank(VATCbrw.VATCode)) then begin
  if (blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false) then begin
    if (absbaseval<VATCbrw.MinBaseAmount) then begin
      testf = false;
    end;
    if (blank(VATCbrw.MaxBaseAmount)==false) then begin
      if (absbaseval>VATCbrw.MaxBaseAmount) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            baseval = baseval - VATCbrw.MinBaseAmount;
          end else begin
            baseval = baseval + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (baseval<0) then begin testf = false; end;
          end else begin
            if (baseval>0) then begin testf = false; end;
          end;        
      end;
    end;
  end;
  end;
  if (testf) then begin
    if (InclVAT!=0) then begin
      if (blank(VATCbrw.IncVatpr)) then begin
        exprcf = true;
        vatperc = VATCbrw.ExVatpr;
      end else begin
        exprcf = false;
        vatperc = VATCbrw.IncVatpr;
      end;
    end else begin
      if (blank(VATCbrw.ExVatpr)) then begin
        exprcf = false;
        vatperc = VATCbrw.IncVatpr;        
      end else begin
        exprcf = true;
        vatperc = VATCbrw.ExVatpr;
      end;
    end; 
    if (nonblank(vatrate)) then begin
      exprcf = true;
      vatperc = vatrate;
    end;
    if (vatperc!=0) then begin
      switch (InclVAT) begin
        case kBasePriceNotInclVAT:
          if (exprcf) then begin
            res = (baseval * vatperc)/ 100.00;
          end else begin
            res = ((baseval*100)/(100-vatperc)) - baseval;
          end;
        case kBasePriceInclVATandTax:
          if (exprcf) then begin
            res = baseval - (baseval * 100)/(100+vatperc);
          end else begin
            res = (baseval * vatperc)/ 100.00;
          end;
        case kBasePriceInclVAT:
          if (exprcf) then begin
            res = baseval - (baseval * 100)/(100+vatperc);
          end else begin
            res = (baseval * vatperc)/ 100.00;
          end;
      end; 
    end; 
  end;
  res = Round(res,DefaultRoundMode);
  CalculateTaxValue = res;
  return;
end;

/*

function val CalculateTaxValue(string vatcode,val vatrate,val abaseval,Integer InclVAT,Integer NoTAXonVAT) 
begin
  val res;
  val vatperc,tax1percdummy,baseval,absbaseval;
  row VATCodeBlock VATCbrw;
  Boolean testf;
  
  GetVATRow(vatcode,VATCbrw);
  baseval = abaseval;
  absbaseval = AbsoluteVal(baseval);
  testf = true;
  if (nonblank(VATCbrw.VATCode)) then begin
  if (blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false) then begin
    if (absbaseval<VATCbrw.MinBaseAmount) then begin
      testf = false;
    end;
    if (blank(VATCbrw.MaxBaseAmount)==false) then begin
      if (absbaseval>VATCbrw.MaxBaseAmount) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            baseval = baseval - VATCbrw.MinBaseAmount;
          end else begin
            baseval = baseval + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (baseval<0) then begin testf = false; end;
          end else begin
            if (baseval>0) then begin testf = false; end;
          end;        
      end;
    end;
  end;
  end;
  if (testf) then begin
    if (InclVAT!=0) then begin
      if (blank(VATCbrw.IncVatpr)) then begin
        vatperc = VATCbrw.ExVatpr;
        if (nonblank(vatperc)) then begin
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalNo:
            otherwise
              vatperc = (1-(100.00/(100.00+vatperc)))*100.00;
          end;
        end;
      end else begin
        vatperc = VATCbrw.IncVatpr;
      end;
    end else begin
      if (blank(VATCbrw.ExVatpr)) then begin
        vatperc = VATCbrw.IncVatpr;        
        if (vatperc!=blankval) then begin
          vatperc = ((100.00/(100.00-vatperc))-1)*100.00;
        end;
      end else begin
        vatperc = VATCbrw.ExVatpr;
      end;
    end; 
    if (nonblank(vatrate)) then begin
      vatperc = vatrate;
    end;
    switch (InclVAT) begin
      case kBasePriceNotInclVAT:
        res = (baseval * vatperc)/ 100.00;
      case kBasePriceInclVATandTax:
        res = (baseval * vatperc)/ 100.00;
      case kBasePriceInclVAT:
        res = (baseval * vatperc)/ 100.00;
    end;  
  end;
  res = Round(res,DefaultRoundMode);
  CalculateTaxValue = res;
  return;
end;

*/

global
function Boolean UseTaxTemplatesforTaxCalc()
begin
  record CYBlock CYb;
  
  BlockLoad(CYb);
  UseTaxTemplatesforTaxCalc = CYb.UseTaxTemplatesforTaxCalc!=0;
  return;
end;

global
procedure MulVATIVExecute2(string vatc,val vval,var val rval,var val tax1,Integer InclVAT,Integer NoTAXonVAT,Boolean ignorelimit,roundmode r)
begin
  val vatprc,vatval,baseval,t1val,t1prc;
  val t,absbaseval;
  row VATCodeBlock VATCbrw;
  Boolean testf,exprcf;
  
  if (blank(vval)) then begin
    rval = blankval;
    tax1 = blankval;
    goto LMulVATIV;
  end;
  if (vval==0) then begin
    rval = 0;
    tax1 = 0;
    goto LMulVATIV;
  end;
  if (blank(vatc)) then begin
    rval = blankval;
    tax1 = blankval;
    goto LMulVATIV;
  end;
  if (UseTaxTemplatesforTaxCalc) then begin
    rval = CalculateTaxValue(vatc,blankval,vval,InclVAT,NoTAXonVAT);
    goto LMulVATIV;
  end;
    
  GetVATRow(vatc,VATCbrw); 
  t1prc = VATCbrw.Tax1pr;
  switch (InclVAT) begin
    case kBasePriceNotInclVAT:
      vatprc = VATCbrw.ExVatpr;
      exprcf = true;
      if (blank(vatprc)) then begin
        vatprc = VATCbrw.IncVatpr;
        exprcf = false;
      end;
    case kBasePriceInclVATandTax:
      vatprc = VATCbrw.IncVatpr;
      exprcf = false;
      if (blank(vatprc)) then begin
        vatprc = VATCbrw.ExVatpr;
        exprcf = true;
      end;
    case kBasePriceInclVAT:
      vatprc = VATCbrw.IncVatpr;
      exprcf = false;
      if (blank(vatprc)) then begin
        vatprc = VATCbrw.ExVatpr;
        exprcf = true;
      end;
    otherwise
      vatprc = VATCbrw.ExVatpr;    
      exprcf = true;
  end;

  vatval = 0;
  t1val = 0;

  baseval = vval;  
  absbaseval = AbsoluteVal(baseval);
  testf = true;
  if ((blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false)) and (ignorelimit==false) then begin
    if (absbaseval<VATCbrw.MinBaseAmount) then begin
      testf = false;
    end;
    if (blank(VATCbrw.MaxBaseAmount)==false) then begin
      if (absbaseval>VATCbrw.MaxBaseAmount) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (vval>0) then begin
            baseval = baseval - VATCbrw.MinBaseAmount;
          end else begin
            baseval = baseval + VATCbrw.MinBaseAmount;
          end;
          if (vval>0) then begin
            if (baseval<0) then begin testf = false; end;
          end else begin
            if (baseval>0) then begin testf = false; end;
          end;        
      end;
    end;
  end;
//LogText(0,"B.InclVAT " & InclVAT & " NoTAXonVAT " &  NoTAXonVAT  & " exprcf " & exprcf);

  if (testf) then begin
//LogText(0,"baseval " & baseval & " t " & ValToString(t,M4Rate,"",".",0));
    switch (InclVAT) begin
      case 0:
        if (exprcf) then begin
          switch (NoTAXonVAT) begin
            case 0:
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * (baseval+vatval)) / 100; 
            case 1:
              t1val = (t1prc * baseval)/100; 
              vatval = (vatprc * baseval) / 100;
            case 2:
              t1val = (t1prc * baseval) / 100;
              vatval = (vatprc * (baseval+t1val)) / 100; 
            otherwise
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * (baseval+vatval)) / 100; 
          end;
        end else begin
          switch (NoTAXonVAT) begin
            case 0:
              if (vatprc!=0) then begin
                vatval = ((baseval*100)/(100-vatprc)) - baseval;
              end;
              t1val = (t1prc * (baseval+vatval)) / 100;
            case 1:
              if (vatprc!=0) then begin
                vatval = ((baseval*100)/(100-vatprc)) - baseval;
              end;
              t1val = (t1prc * baseval)/100; 
            case 2:
              if (vatprc!=0) then begin
                vatval = ((baseval*100)/(100-vatprc)) - baseval;
              end;
              t1val = (t1prc * baseval)/100; 
              if (vatprc!=0) then begin
                vatval = vatval + ((t1val*100)/(100-vatprc)) - t1val;
              end;
            otherwise
              if (vatprc!=0) then begin
                vatval = ((baseval*100)/(100-vatprc)) - baseval;
              end;
              t1val = (t1prc * (baseval+vatval)) / 100;
          end;
        end;
      case 1:    
        if (exprcf) then begin
          switch (NoTAXonVAT) begin
            case 0:
              if (t1prc!=0) then begin
                t1val = baseval - (baseval * 100)/(100+t1prc);
              end;
              if (t1val<VATCbrw.Tax1Min) then begin
                t1val = blankval;
              end;
              if (vatprc!=0) then begin
                vatval = (baseval-t1val) - ((baseval-t1val) * 100)/(100+vatprc);
              end;
            case 1:
              t = 0;
              if ((vatprc+t1prc)!=0) then begin
                t = (baseval * 100)/(100+vatprc+t1prc);
              end;
              GetVATdouble(vatc,vatprc,t1prc,0);
              vatval = (vatprc * t)/100;
              t1val = (t1prc * t)/100;
            case 2:
              t = 0;
              if ((vatprc+t1prc)!=0) then begin
                t = (baseval * 100)/(100+vatprc+t1prc+((vatprc*t1prc)/100));
              end;
              vatval = (vatprc * t)/100;
              t1val = (t1prc * t) / 100;
              vatval = vatval + (vatprc * t1val)/100;
            otherwise
              t1val = (baseval * t1prc) / 100;
              if (t1val<VATCbrw.Tax1Min) then begin
                t1val = blankval;
              end;
              vatval = (vatprc * (baseval-t1val)) / 100;
          end;
        end else begin
          switch (NoTAXonVAT) begin
            case 0:
              if (t1prc!=0) then begin
                t1val = baseval - (baseval * 100)/(100+t1prc);
                if (t1val<VATCbrw.Tax1Min) then begin
                  t1val = blankval;
                end;
                t1val = Round(t1val,GetVATRoundModeRB);
                if (vatprc!=0) then begin
                  vatval = ((baseval-t1val) * vatprc)/100;
                end;
              end else begin
                vatval = (baseval * vatprc)/100;
              end;
            case 1:

              if (t1prc!=0) then begin
                vatprc = (100*100)/(100-vatprc) - 100;  //i dont know any better way .....

                t = (baseval * 100)/(100+vatprc+t1prc);
                GetVATdouble(vatc,vatprc,t1prc,0);
                vatval = (vatprc * t)/100;
                t1val = (t1prc * t)/100;
              end else begin
                vatval = (baseval * vatprc)/100;
              end;
            case 2:
              if (t1prc!=0) then begin
                vatprc = (100*100)/(100-vatprc) - 100;  //i dont know any better way .....
                t = 0;
                if ((vatprc+t1prc)!=0) then begin
                  t = (baseval * 100)/(100+vatprc+t1prc+((vatprc*t1prc)/100));
                end;
                vatval = (vatprc * t)/100;
                t1val = (t1prc * t) / 100;
                vatval = vatval + (vatprc * t1val)/100;
              end else begin
                vatval = (baseval * vatprc)/100;
              end;
            otherwise
              if (t1prc!=0) then begin
                t1val = (baseval * t1prc) / 100;
                if (t1val<VATCbrw.Tax1Min) then begin
                  t1val = blankval;
                end;
                vatval = (vatprc * (baseval-t1val)) / 100;
              end else begin
                vatval = (baseval * vatprc)/100;
              end;
          end;
        end;
      case 2:    
        if (exprcf) then begin
          switch (NoTAXonVAT) begin
            case 0:
              if (vatprc!=0) then begin
                vatval = baseval - (baseval * 100)/(100+vatprc);
              end;
              if (t1prc!=0) then begin
                t1val = (t1prc * baseval) / 100;
              end;
            case 1:
              if (vatprc!=0) then begin
                vatval = baseval - (baseval * 100)/(100+vatprc);
              end;
              if (t1prc!=0) then begin
                t1val = (t1prc * (baseval-vatval)) / 100;
              end;
            case 2:
              if (vatprc!=0) then begin
                vatval = baseval - (baseval * 100)/(100+vatprc);
                vatval = Round(vatval,GetVATRoundModeRB);
              end;
              t1val = (t1prc * (baseval-vatval)) / 100;
              t1val = Round(t1val,GetVATRoundModeRB);
              GetVATdouble(vatc,vatprc,t,0);
              vatval = vatval + (vatprc * t1val)/100;
            otherwise
              if (vatprc!=0) then begin
                vatval = baseval - (baseval * 100)/(100+vatprc);
              end;
              if (t1prc!=0) then begin
                t1val = baseval - (t1prc * baseval) / 100;
              end;
          end;
        end else begin
          switch (NoTAXonVAT) begin
            case 0:
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * baseval) / 100; 
            case 1:
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * (baseval-vatval))/100; 
            case 2:
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * (baseval-vatval))/100; 
              vatval = vatval + (((t1val*100)/(100-vatprc)) - t1val);
            otherwise
              vatval = (vatprc * baseval) / 100;
              t1val = (t1prc * baseval) / 100; 
          end;
        end;
    end;
  end;
  rval = vatval;
  tax1 = t1val;
  rval = Round(rval,r);
  tax1 = Round(tax1,r);
LMulVATIV:; 
  return;
end;

/*
global
procedure MulVATIVExecute2(string vatc,val vval,var val rval,var val tax1,Integer InclVAT,Integer NoTAXonVAT,Boolean ignorelimit,roundmode r)
begin
  val drval,dvval,t1val;
  val vatprc,t,absbaseval;
  row VATCodeBlock VATCbrw;
  Boolean testf;
  
  if (blank(vval)) then begin
    rval = blankval;
    tax1 = blankval;
    goto LMulVATIV;
  end;
  if (vval==0) then begin
    rval = 0;
    tax1 = 0;
    goto LMulVATIV;
  end;
  if (blank(vatc)) then begin
    rval = blankval;
    tax1 = blankval;
    goto LMulVATIV;
  end;
  if (UseTaxTemplatesforTaxCalc) then begin
    rval = CalculateTaxValue(vatc,blankval,vval,InclVAT,NoTAXonVAT);
    goto LMulVATIV;
  end;

  GetVATdouble(vatc,drval,t1val,InclVAT);
  GetVATRow(vatc,VATCbrw);
  
  dvval = vval;  
  absbaseval = AbsoluteVal(dvval);
  testf = true;
  if ((blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false)) and (ignorelimit==false) then begin
    if (absbaseval<VATCbrw.MinBaseAmount) then begin
      testf = false;
    end;
    if (blank(VATCbrw.MaxBaseAmount)==false) then begin
      if (absbaseval>VATCbrw.MaxBaseAmount) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (vval>0) then begin
            dvval = dvval - VATCbrw.MinBaseAmount;
          end else begin
            dvval = dvval + VATCbrw.MinBaseAmount;
          end;
          if (vval>0) then begin
            if (dvval<0) then begin testf = false; end;
          end else begin
            if (dvval>0) then begin testf = false; end;
          end;        
      end;
    end;
  end;
  if (testf) then begin
    switch (InclVAT) begin
      case 0:
        switch (NoTAXonVAT) begin
          case 0:
            drval = drval * (dvval / 100);
            t1val = t1val * ((dvval+drval) / 100); 
          case 1:
            t1val = t1val * (dvval/100); 
            drval = drval * (dvval / 100);
          case 2:
            t1val = t1val * (dvval / 100);  
            
//            if (t1val<VATCbrw.Tax1Min) then begin
//              t1val = blankval;
//            end;
            
            drval = drval * ((dvval+t1val) / 100); 
          otherwise
            drval = drval * (dvval / 100);
            t1val = t1val * ((dvval+drval) / 100); 
        end;
            
//        if (t1val<VATCbrw.Tax1Min) then begin
//          t1val = blankval;
//        end;
            
      case 1:    
        switch (NoTAXonVAT) begin
          case 0:
            t1val = t1val * (dvval / 100);  
            drval = drval * ((dvval-t1val) / 100);
            if (t1val<VATCbrw.Tax1Min) then begin
              t1val = blankval;
              drval = drval * ((dvval-t1val) / 100);
            end;
          case 1:
            GetVATdouble(vatc,drval,t1val,0);
            t = (1-(100/(100+drval+t1val)))*100;
  //          dvval = dvval - Round(t * (dvval / 100),2);
            dvval = dvval - t * (dvval / 100);

            drval = drval * (dvval / 100);
            t1val = t1val * (dvval / 100);  
          case 2:
            drval = drval * (dvval / 100);
            t1val = t1val * ((dvval-drval)/ 100);  
          otherwise
            t1val = t1val * (dvval / 100);  
            drval = drval * ((dvval-t1val) / 100);
        end;
      case 2:
        switch (NoTAXonVAT) begin
          case 0:
            drval = drval * dvval / 100;
            t1val = t1val * dvval / 100;
          case 1:
            drval = drval * dvval / 100;
            t1val = t1val * (dvval-drval) / 100;
          case 2:
            vatprc = drval;
            drval = drval * dvval / 100;
            t1val = t1val * (dvval-drval) / 100;
            GetVATdouble(vatc,vatprc,t,0);
            drval = drval + t1val * vatprc / 100;
          otherwise
            drval = drval * dvval / 100;
            t1val = t1val * dvval / 100;
        end;
    end;  
  end else begin
    drval = 0;
    t1val = 0;
  end;
  rval = drval;
  tax1 = t1val;
  rval = Round(rval,r);
  tax1 = Round(tax1,r);
LMulVATIV:;  
  return;
end;
*/

global
procedure MulVATIVExecute(string vatc,val vval,var val rval,var val tax1,Integer InclVAT,Integer NoTAXonVAT,roundmode r)
begin
  MulVATIVExecute2(vatc,vval,rval,tax1,InclVAT,NoTAXonVAT,false,r);
  return;
end;

global
procedure MulVATIV(string vatc,val vval,var val rval,var val tax1,Integer InclVAT,Integer NoTAXonVAT)
begin
  MulVATIVExecute(vatc,vval,rval,tax1,InclVAT,NoTAXonVAT,DefaultRoundMode);
  return;
end;

global
procedure MulVATIV2(string vatc,val vval,var val rval,var val tax1,Integer InclVAT,Integer NoTAXonVAT,Boolean ignorelimit)
begin
  MulVATIVExecute2(vatc,vval,rval,tax1,InclVAT,NoTAXonVAT,ignorelimit,DefaultRoundMode);
  return;
end;

procedure TaxMatricesConjunction(record TaxMatrixVc TMr,var record TaxMatrixVc resTMr)
begin
  row TaxMatrixVc resTMrw;
  Integer resi,resrwcnt;
  row TaxMatrixVc TMrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(TMr);
  if (rwcnt==0) then begin goto Lfound; end;
  resrwcnt = MatRowCnt(resTMr);
  for (resi=0;resi<resrwcnt;resi=resi+1) begin
    MatRowGet(resTMr,resi,resTMrw);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
      if (TMrw.VATCode==resTMrw.VATCode) and (TMrw.CalcBase==resTMrw.CalcBase) then begin
        goto Lfound;
      end;
    end;
    MatRowDelete(resTMr,resi);
    resi = -1;
    resrwcnt = MatRowCnt(resTMr);
Lfound:;
  end;
  return;
end;

global
function string 255 FillupTaxMatrix(Integer type,string branchid,string custcode,string custcat,string deladdr,string itemtaxtempletecode,var record TaxMatrixVc resTMr)
begin
  string 255 res;
  record TaxTemplateVc TTr;
  row TaxTemplateVc TTrw;
  Integer i,rwcnt;
  record TaxMatrixVc TMr;
  row TaxMatrixVc TMrw;
  record CUVc CUr;
  record CUVc BranchCUr;
  record DelAddrVc DAr;
  string 255 deltaxtemplatecode,branchtaxtemplatecode,cutaxtemplatecode,taxtemplatecode,accustaxtemplatecode;
  Integer conjunction;
  record CYBlock CYb;
  record AccBlock ARAccb;
  record APAccBlock APAccb;

  BlockLoad(CYb);  
  RecordClear(resTMr);
  if (CYb.UseTaxTemplatesforTaxCalc!=0) then begin
    conjunction = 1;
    if (nonblank(branchid)) then begin
      BranchCUr.Code = branchid;
      ReadFirstMain(BranchCUr,1,true);
      switch (type) begin
        case 2:
          goto LUseBranchVETaxTemplateCode;
        case 1:
LUseBranchVETaxTemplateCode:;
          if (nonblank(BranchCUr.VETaxTemplateCode)) then begin
            branchtaxtemplatecode = BranchCUr.VETaxTemplateCode;
          end;
        otherwise
          if (nonblank(BranchCUr.TaxTemplateCode)) then begin
            branchtaxtemplatecode = BranchCUr.TaxTemplateCode;
          end;
      end;
    end;
    if (nonblank(custcode)) then begin
      CUr.Code = custcode;
      ReadFirstMain(CUr,1,true);
      switch (type) begin
        case 2:
          goto LUseVETaxTemplateCode;
        case 1:
LUseVETaxTemplateCode:;
          if (nonblank(CUr.VETaxTemplateCode)) then begin
            cutaxtemplatecode = CUr.VETaxTemplateCode;
          end;
        otherwise
          if (nonblank(CUr.TaxTemplateCode)) then begin
            cutaxtemplatecode = CUr.TaxTemplateCode;
          end;
      end;
    end;          
    if (type==0) then begin
//      if (blank(cutaxtemplatecode)) then begin
      if (true) then begin
        if (nonblank(deladdr)) then begin
          DAr.DelCode = deladdr;
          DAr.CustCode = CUr.Code;
          ReadFirstMain(DAr,2,true);
          if (nonblank(DAr.TaxTemplateCode)) then begin
            deltaxtemplatecode = DAr.TaxTemplateCode;
//            conjunction = 2;
          end;      
        end;
      end;
    end;
    if (CYb.CombineTaxTemplates==0) then begin
      conjunction = 0;
    end;      
    if (blank(cutaxtemplatecode)) and (conjunction!=2) then begin
      switch (type) begin
        case 2:   
          goto LFillupTaxMatrix_case1;
        case 1:        
LFillupTaxMatrix_case1:;        
          BlockLoad(APAccb);
          switch (CUr.ExportFlag) begin
            case 4: accustaxtemplatecode = APAccb.TaxTemplateCodeExp;
            case 3: accustaxtemplatecode = APAccb.TaxTemplateCodeEU;
            case 2: accustaxtemplatecode = APAccb.TaxTemplateCodeExp;
            case 1: accustaxtemplatecode = APAccb.TaxTemplateCodeEU;
            otherwise accustaxtemplatecode = APAccb.TaxTemplateCode;
          end;
          if (blank(accustaxtemplatecode)) then begin
            accustaxtemplatecode = APAccb.TaxTemplateCode;
          end;
        otherwise
          BlockLoad(ARAccb);
          switch (CUr.ExportFlag) begin
            case 4: accustaxtemplatecode = ARAccb.TaxTemplateCodeExp;
            case 3: accustaxtemplatecode = ARAccb.TaxTemplateCodeEU;
            case 2: accustaxtemplatecode = ARAccb.TaxTemplateCodeExp;
            case 1: accustaxtemplatecode = ARAccb.TaxTemplateCodeEU;
            otherwise accustaxtemplatecode = ARAccb.TaxTemplateCode;
          end;
          if (blank(accustaxtemplatecode)) then begin
            accustaxtemplatecode = ARAccb.TaxTemplateCode;
          end;
      end;
    end;

    switch (conjunction) begin
      case 1:
/*      
        taxtemplatecode = deltaxtemplatecode;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = cutaxtemplatecode;
        end;
*/        
        taxtemplatecode = "";
        if (blank(cutaxtemplatecode)) then begin
          taxtemplatecode = branchtaxtemplatecode;
        end;

        if (nonblank(taxtemplatecode)) then begin
          TTr.Code = taxtemplatecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);
              ClearRow(resTMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
            end;
          end;
        end;

        if (nonblank(deltaxtemplatecode)) then begin
          cutaxtemplatecode = deltaxtemplatecode;
        end;

        if (nonblank(cutaxtemplatecode)) then begin
          TTr.Code = cutaxtemplatecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);
              ClearRow(resTMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
            end;
          end;
          res = AddObjectToObjectList(taxtemplatecode,cutaxtemplatecode);
        end;
        
        if (nonblank(itemtaxtempletecode)) then begin
          RecordClear(TMr);
          TTr.Code = itemtaxtempletecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);          
              ClearRow(TMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(TMr,MatRowCnt(TMr),TMrw);
            end;
          end;
          if (nonblank(taxtemplatecode)) then begin
            TaxMatricesConjunction(TMr,resTMr);
            res = AddObjectToObjectList(res,taxtemplatecode);
            res = AddObjectToObjectList(res,itemtaxtempletecode);        
          end else begin
            RecordCopy(resTMr,TMr);
            res = AddObjectToObjectList(res,itemtaxtempletecode);
          end;
        end else begin
          res = AddObjectToObjectList(res,taxtemplatecode);
        end;
      case 2:
        TTr.Code = deltaxtemplatecode;
        if (ReadFirstMain(TTr,1,true)) then begin
          rwcnt = MatRowCnt(TTr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(TTr,i,TTrw);
            ClearRow(resTMr,TMrw,1);
            TMrw.VATCode = TTrw.VATCode;
            TMrw.VATRate = TTrw.VATRate;
            TMrw.CalcBase = TTrw.CalcBase;
            MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
          end;
        end;
        res = AddObjectToObjectList("",deltaxtemplatecode);
        if (nonblank(branchtaxtemplatecode)) then begin
          RecordClear(TMr);
          TTr.Code = branchtaxtemplatecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);
              ClearRow(TMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(TMr,MatRowCnt(TMr),TMrw);
            end;
          end;
          TaxMatricesConjunction(TMr,resTMr);
          res = AddObjectToObjectList(res,branchtaxtemplatecode);
        end;

        if (nonblank(itemtaxtempletecode)) then begin
          RecordClear(TMr);
          TTr.Code = itemtaxtempletecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);          
              ClearRow(TMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(TMr,MatRowCnt(TMr),TMrw);
            end;
          end;
          TaxMatricesConjunction(TMr,resTMr);
          res = AddObjectToObjectList(res,itemtaxtempletecode);        
        end;
      otherwise
        taxtemplatecode = deltaxtemplatecode;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = cutaxtemplatecode;
        end;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = itemtaxtempletecode;
        end;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = deltaxtemplatecode;
        end;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = branchtaxtemplatecode;
        end;
        if (blank(taxtemplatecode)) then begin
          taxtemplatecode = accustaxtemplatecode;
        end;
        if (nonblank(taxtemplatecode)) then begin
          TTr.Code = taxtemplatecode;
          if (ReadFirstMain(TTr,1,true)) then begin
            rwcnt = MatRowCnt(TTr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TTr,i,TTrw);
              ClearRow(resTMr,TMrw,1);
              TMrw.VATCode = TTrw.VATCode;
              TMrw.VATRate = TTrw.VATRate;
              TMrw.CalcBase = TTrw.CalcBase;
              MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
            end;
            res = AddObjectToObjectList("",taxtemplatecode);
          end;
        end else begin
          if (nonblank(itemtaxtempletecode)) then begin
            TTr.Code = itemtaxtempletecode;
            if (ReadFirstMain(TTr,1,true)) then begin
              rwcnt = MatRowCnt(TTr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(TTr,i,TTrw);          
                ClearRow(resTMr,TMrw,1);
                TMrw.VATCode = TTrw.VATCode;
                TMrw.VATRate = TTrw.VATRate;
                TMrw.CalcBase = TTrw.CalcBase;
                MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
              end;
              res = AddObjectToObjectList("",itemtaxtempletecode);
            end;
          end;
        end;
    end;    
  end;
  FillupTaxMatrix = res;
  return;
end;

global
function string 255 OverrideTaxMatrix(string taxtemplatecodes,var record TaxMatrixVc resTMr)
begin
  string 255 res;
  record TaxTemplateVc TTr;
  row TaxTemplateVc TTrw;
  Integer i,rwcnt;
  record TaxMatrixVc TMr;
  row TaxMatrixVc TMrw;
  string 255 taxtemplatecode;
  Integer pos;
  Boolean firstf;

  pos = 0;
  firstf = true;
  ExtractObj(taxtemplatecodes,pos,taxtemplatecode);
  TTr.Code = taxtemplatecode;
  if (ReadFirstMain(TTr,1,true)) then begin
    rwcnt = MatRowCnt(TTr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TTr,i,TTrw);
      ClearRow(TMr,TMrw,1);
      TMrw.VATCode = TTrw.VATCode;
      TMrw.VATRate = TTrw.VATRate;
      TMrw.CalcBase = TTrw.CalcBase;
      MatRowPut(resTMr,MatRowCnt(resTMr),TMrw);
    end;
  end;
  res = AddObjectToObjectList(res,taxtemplatecode);

  while (nonblank(taxtemplatecode)) begin
    if (firstf) then begin
      firstf = false;
    end else begin
      TTr.Code = taxtemplatecode;
      if (ReadFirstMain(TTr,1,true)) then begin
        rwcnt = MatRowCnt(TTr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(TTr,i,TTrw);          
          ClearRow(TMr,TMrw,1);
          TMrw.VATCode = TTrw.VATCode;
          TMrw.VATRate = TTrw.VATRate;
          TMrw.CalcBase = TTrw.CalcBase;
          MatRowPut(TMr,MatRowCnt(TMr),TMrw);
        end;
      end;
      TaxMatricesConjunction(TMr,resTMr);
      res = AddObjectToObjectList(res,taxtemplatecode);
    end;    
    ExtractObj(taxtemplatecodes,pos,taxtemplatecode);
  end;
  OverrideTaxMatrix = res;
  return;
end;

global
procedure RowCalculateTaxMatrix(var record TaxMatrixVc TMr,Integer InclVAT,Integer NoTAXonVAT,val sum)
begin
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  val t1dummy,rateincltax,sumrateincltax,taxv;
  val totvatsum,abaseval,inclprevbase;
  row VATCodeBlock VATCbrw;
  
  TMr.RoundVal = blankval;
  rwcnt = MatRowCnt(TMr);
//  if (InclVAT==0) or (rwcnt==1) then begin //ToConsideWhenChanging
  if (false) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          TMrw.BaseSum = sum;
        case kTaxTransCalcBaseInclAllPreviousTaxes:
          TMrw.BaseSum = sum + totvatsum;
      end;
      
      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,InclVAT,0);// no support for NoTAXonVAT 

      abaseval = TMrw.BaseSum;
      GetVATRow(TMrw.VATCode,VATCbrw);
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            TMrw.BaseSum = TMrw.BaseSum - VATCbrw.MinBaseAmount;
          end else begin
            TMrw.BaseSum = TMrw.BaseSum + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (TMrw.BaseSum<0) then begin TMrw.BaseSum = 0.00; end;
          end else begin
            if (TMrw.BaseSum>0) then begin TMrw.BaseSum = 0.00; end;
          end;        
      end;
      totvatsum = totvatsum  + TMrw.VATSum;
      MatRowPut(TMr,i,TMrw);
    end;
  end else begin
    inclprevbase = sum;
    if (InclVAT!=0) then begin
      for (i=rwcnt-1;i>=0;i=i-1) begin
        MatRowGet(TMr,i,TMrw);
        switch (TMrw.CalcBase) begin
          case kTaxTransCalcBaseInclAllPreviousTaxes:
            inclprevbase = inclprevbase/((100.00+TMrw.VATRate)/100.00);
            TMrw.BaseSum = inclprevbase;
            MatRowPut(TMr,i,TMrw);
        end;
      end;
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
//      rateincltax = (1-(100.00/(100.00+TMrw.VATRate)))*100.00;
//      sumrateincltax = sumrateincltax + rateincltax;
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          GetVATRow(TMrw.VATCode,VATCbrw);
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalYes:
              sumrateincltax = sumrateincltax + TMrw.VATRate;
          end;
      end;
    end;
    if (InclVAT!=0) then begin
//      sumrateincltax = (1-(100.00/(100.00+sumrateincltax)))*100.00;
      taxv = CalculateTaxValue("",sumrateincltax,inclprevbase,InclVAT,0); // NoTAXonVAT    
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          TMrw.BaseSum = inclprevbase - taxv;
//          TMrw.BaseSum = inclprevbase; //wierdo ? //ToConsideWhenChanging
        case kTaxTransCalcBaseInclAllPreviousTaxes:
          if (InclVAT==0) then begin
            TMrw.BaseSum = sum + totvatsum;
          end;
      end;
//      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,0,0);// no support for InclVAT,NoTAXonVAT 
      
      GetVATRow(TMrw.VATCode,VATCbrw);
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            TMrw.BaseSum = TMrw.BaseSum - VATCbrw.MinBaseAmount;
          end else begin
            TMrw.BaseSum = TMrw.BaseSum + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (TMrw.BaseSum<0) then begin TMrw.BaseSum = 0.00; end;
          end else begin
            if (TMrw.BaseSum>0) then begin TMrw.BaseSum = 0.00; end;
          end;        
      end;
//      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,InclVAT,0);// no support for InclVAT,NoTAXonVAT , //ToConsideWhenChanging
      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,0,0);// no support for NoTAXonVAT 
      TMrw.VATSum = Round(TMrw.VATSum,DefaultRoundMode);
      TMr.RoundVal = TMr.RoundVal + TMrw.VATSum;
      totvatsum = totvatsum  + TMrw.VATSum;
      MatRowPut(TMr,i,TMrw);
    end;
    TMr.RoundVal = TMr.RoundVal - taxv;    
  end;
  return;
end;

procedure PaymentRowCalculateTaxMatrix(var record TaxMatrixVc TMr,Integer InclVAT,Integer NoTAXonVAT,val sum)
begin
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  val t1dummy,rateincltax,sumrateincltax,taxv;
  val totvatsum,abaseval,inclprevbase;
  row VATCodeBlock VATCbrw;
  
  TMr.RoundVal = blankval;
  rwcnt = MatRowCnt(TMr);
//  if (InclVAT==0) or (rwcnt==1) then begin //ToConsideWhenChanging
  if (false) then begin //ToConsideWhenChanging
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          TMrw.BaseSum = sum;
        case kTaxTransCalcBaseInclAllPreviousTaxes:
          TMrw.BaseSum = sum + totvatsum;
      end;
      
      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,InclVAT,0);// no support for NoTAXonVAT 

      abaseval = TMrw.BaseSum;
      GetVATRow(TMrw.VATCode,VATCbrw);
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            TMrw.BaseSum = TMrw.BaseSum - VATCbrw.MinBaseAmount;
          end else begin
            TMrw.BaseSum = TMrw.BaseSum + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (TMrw.BaseSum<0) then begin TMrw.BaseSum = 0.00; end;
          end else begin
            if (TMrw.BaseSum>0) then begin TMrw.BaseSum = 0.00; end;
          end;        
      end;
      totvatsum = totvatsum  + TMrw.VATSum;
      MatRowPut(TMr,i,TMrw);
    end;
  end else begin
    inclprevbase = sum;
    for (i=rwcnt-1;i>=0;i=i-1) begin
      MatRowGet(TMr,i,TMrw);
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseInclAllPreviousTaxes:
          inclprevbase = inclprevbase/((100.00+TMrw.VATRate)/100.00);
          TMrw.BaseSum = inclprevbase;
          MatRowPut(TMr,i,TMrw);
      end;
    end;
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
//      rateincltax = (1-(100.00/(100.00+TMrw.VATRate)))*100.00;
//      sumrateincltax = sumrateincltax + rateincltax;
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          GetVATRow(TMrw.VATCode,VATCbrw);
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalYes:
              sumrateincltax = sumrateincltax + TMrw.VATRate;
          end;
      end;
    end;
    if (InclVAT!=0) then begin
      sumrateincltax = (1-(100.00/(100.00+sumrateincltax)))*100.00;
      taxv = CalculateTaxValue("",sumrateincltax,inclprevbase,InclVAT,0); // NoTAXonVAT    
    end;

    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TMr,i,TMrw);
      switch (TMrw.CalcBase) begin
        case kTaxTransCalcBaseNet:
          TMrw.BaseSum = inclprevbase - taxv;
//          TMrw.BaseSum = inclprevbase; //wierdo ? 
//        case kTaxTransCalcBaseInclAllPreviousTaxes:
//          TMrw.BaseSum = sum - taxv + totvatsum;
      end;
//      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,0,0);// no support for InclVAT,NoTAXonVAT 
      
      GetVATRow(TMrw.VATCode,VATCbrw);
      switch (VATCbrw.CalcRule) begin
        case kVATCalcRuleInRangeAmount:
          if (abaseval>0) then begin
            TMrw.BaseSum = TMrw.BaseSum - VATCbrw.MinBaseAmount;
          end else begin
            TMrw.BaseSum = TMrw.BaseSum + VATCbrw.MinBaseAmount;
          end;
          if (abaseval>0) then begin
            if (TMrw.BaseSum<0) then begin TMrw.BaseSum = 0.00; end;
          end else begin
            if (TMrw.BaseSum>0) then begin TMrw.BaseSum = 0.00; end;
          end;        
      end;

      MulVATIV(TMrw.VATCode,TMrw.BaseSum,TMrw.VATSum,t1dummy,0,0);// no support for InclVAT,NoTAXonVAT 
      //if InclVAT in in live aboove then TMrw.BaseSum cannot have -taxv , but results are starnge then
      TMrw.VATSum = Round(TMrw.VATSum,DefaultRoundMode);
      TMr.RoundVal = TMr.RoundVal + TMrw.VATSum;
      totvatsum = totvatsum  + TMrw.VATSum;
      MatRowPut(TMr,i,TMrw);
    end;
    TMr.RoundVal = TMr.RoundVal - taxv;    
  end;
  return;
end;

global
procedure RowCalculateTaxMatrix_SVOVc(var record SVOVc SVOp,Integer rownr,row SVOVc SVOrw)
begin
  record TaxMatrixVc TMr;
  
//  UnpackRowFieldMatrix(SVOrw,"TaxMatrix",TMr);
//  RowCalculateTaxMatrix(TMr,SVOp.InclVAT,SVOp.NoTAXonVAT,SVOrw.Sum);
//  RowCalculateTaxMatrix(TMr,SVOp.InclVAT,0,SVOrw.Sum);
//  PackRowFieldMatrix(SVOrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_IVVc(var record IVVc IVp,Integer rownr,row IVVc IVrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(IVrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,IVp.InclVAT,IVp.NoTAXonVAT,IVrw.Sum);
  PackRowFieldMatrix(IVrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_RestAccVc(var record RestAccVc RestAccp,Integer rownr,row RestAccVc RestAccrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,RestAccp.InclVAT,0,RestAccrw.Sum);//RestAccp.NoTAXonVAT
  PackRowFieldMatrix(RestAccrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_WSVc(var record WSVc WSp,Integer rownr,row WSVc WSrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(WSrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,WSp.InclVAT,0,WSrw.Sum);//WSp.NoTAXonVAT
  PackRowFieldMatrix(WSrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_IVCashVc(var record IVCashVc IVCashp,Integer rownr,row IVCashVc IVCashrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,IVCashp.InclVAT,IVCashp.NoTAXonVAT,IVCashrw.Sum);
  PackRowFieldMatrix(IVCashrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_CQVc(var record CQVc CQp,Integer rownr,row CQVc CQrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(CQrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,0,0,CQrw.Price);//CQp.InclVAT,CQp.NoTAXonVAT
  PackRowFieldMatrix(CQrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_COVc(var record COVc COp,Integer rownr,row COVc COrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(COrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,COp.InclVAT,COp.NoTAXonVAT,COrw.Sum);
  PackRowFieldMatrix(COrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_BPCVc(var record BPCVc BPCp,Integer rownr,row BPCVc BPCrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(BPCrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,BPCp.InclVAT,0,BPCrw.Qty*BPCrw.BasePriceAfter);
  PackRowFieldMatrix(BPCrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_QTVc(var record QTVc QTp,Integer rownr,row QTVc QTrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(QTrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,QTp.InclVAT,QTp.NoTAXonVAT,QTrw.Sum);
  PackRowFieldMatrix(QTrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_OYVc(var record OYVc OYp,Integer rownr,row OYVc OYrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(OYrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,OYp.InclVAT,OYp.NoTAXonVAT,OYrw.Sum);
  PackRowFieldMatrix(OYrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_ORVc(var record ORVc ORp,Integer rownr,row ORVc ORrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,ORp.InclVAT,ORp.NoTAXonVAT,ORrw.Sum);
  PackRowFieldMatrix(ORrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_POVc(var record POVc POp,Integer rownr,row POVc POrw)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(POrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,POp.InclVAT,POp.NoTAXonVAT,POrw.Sum);
  PackRowFieldMatrix(POrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_VIVc(var record VIVc VIp,Integer rownr,row VIVc VIrw,Integer InclVAT)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(VIrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,InclVAT,VIp.NoTAXonVAT,VIrw.Sum);
  PackRowFieldMatrix(VIrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_PUVc(var record PUVc PUp,Integer rownr,row PUVc PUrw,Integer InclVAT)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(PUrw,"TaxMatrix",TMr);
  RowCalculateTaxMatrix(TMr,InclVAT,0,PUrw.Sum);
  PackRowFieldMatrix(PUrw,"TaxMatrix",TMr);    
  return;
end;

global
procedure RowCalculateTaxMatrix_IPVc(var record IPVc IPp,Integer rownr,row IPVc IPrw,Integer InclVAT)
begin
  record TaxMatrixVc TMr;
  
  UnpackRowFieldMatrix(IPrw,"TaxMatrix",TMr);
  PaymentRowCalculateTaxMatrix(TMr,InclVAT,0,IPrw.RecVal);
  PackRowFieldMatrix(IPrw,"TaxMatrix",TMr);    
  return;
end;

procedure AddRowToSum(row TaxMatrixVc TMrw,var record TaxMatrixVc sumTMr,Integer InclVAT)
begin
  Integer sumi,sumrwcnt;
  row TaxMatrixVc sumTMrw;
  record RoundBlock Roundb;
  val t1dummy;

  BlockLoad(Roundb);
  sumrwcnt = MatRowCnt(sumTMr);
  for (sumi=0;sumi<sumrwcnt;sumi=sumi+1) begin
    MatRowGet(sumTMr,sumi,sumTMrw);
    if (sumTMrw.VATCode==TMrw.VATCode) then begin
      sumTMrw.BaseSum = sumTMrw.BaseSum + TMrw.BaseSum;
      switch (TMrw.CalcBase) begin
        case kTaxTransCalculatedExternally:
          sumTMrw.VATSum = sumTMrw.VATSum + TMrw.VATSum;
        otherwise
          switch (Roundb.VATCalcWay) begin
            case kVATCalcWayPerVATCode:
    //          MulVATIV(sumTMrw.VATCode,sumTMrw.BaseSum,sumTMrw.VATSum,t1dummy,InclVAT,0);// no support for NoTAXonVAT //ToConsideWhenChanging
              MulVATIV(sumTMrw.VATCode,sumTMrw.BaseSum,sumTMrw.VATSum,t1dummy,0,0);// no support for NoTAXonVAT //ToConsideWhenChanging
            case kVATCalcWayPerRow:
              sumTMrw.VATSum = sumTMrw.VATSum + TMrw.VATSum;
          end;
      end;
      MatRowPut(sumTMr,sumi,sumTMrw);
      goto LAddRowToSum;
    end;
  end;
  ClearRow(sumTMr,sumTMrw,1);
  CopyRow(sumTMr,TMrw,sumTMrw);
  MatRowPut(sumTMr,MatRowCnt(sumTMr),sumTMrw);
LAddRowToSum:;  
  return;
end;

global
procedure AddRowTaxMatrixToSumTaxMatrix(record TaxMatrixVc TMr,var record TaxMatrixVc sumTMr,Integer InclVAT)
begin
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  
  rwcnt = MatRowCnt(TMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TMr,i,TMrw);
    AddRowToSum(TMrw,sumTMr,InclVAT);
  end;
  return;
end;

global
function val CalculateTotalVATFromTaxMatrix3(record TaxMatrixVc TMr,Integer InclVAT,Boolean InclReversedVAT,Boolean InclConsumptionTax)
begin
  val res;
  record RoundBlock Roundb;
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  val t1dummy,rateincltax,sumrateincltax,taxv,basesum;
  row VATCodeBlock VATCbrw;
  Integer vt;

  res = blankval;
  BlockLoad(Roundb);
  switch (Roundb.VATCalcWay) begin
    case kVATCalcWayPerVATCode:
      rwcnt = MatRowCnt(TMr);
//      if (InclVAT==0) or (rwcnt==1) then begin //ToConsideWhenChanging
      if (false) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(TMr,i,TMrw);
          basesum = TMrw.BaseSum;
          
          GetVATRow(TMrw.VATCode,VATCbrw);
          vt = VATType(TMrw.VATCode);
          if (blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false) then begin
//other option is to add flag to MulVATIV, but many more places to change
            switch (VATCbrw.CalcRule) begin
              case kVATCalcRuleInRangeAmount:
                if (TMrw.VATSum>0) then begin
                  basesum = basesum + VATCbrw.MinBaseAmount;
                end else begin
                  basesum = basesum - VATCbrw.MinBaseAmount;
                end;
                if (TMrw.VATSum>0) then begin
                  if (basesum<0) then begin basesum = 0.00; end;
                end else begin
                  if (basesum>0) then begin basesum = 0.00; end;
                end;        
            end;
          end;

//          MulVATIV(TMrw.VATCode,basesum,TMrw.VATSum,t1dummy,InclVAT,0);// no support for NoTAXonVAT
          MulVATIV(TMrw.VATCode,basesum,TMrw.VATSum,t1dummy,0,0);// no support for NoTAXonVAT //ToConsideWhenChanging
          MatRowPut(TMr,i,TMrw);
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalNo:
            otherwise
              if ((InclReversedVAT or vt!=kVATTypeReversed) and (InclConsumptionTax or vt!=kVATTypeConsumptionTax)) then begin
                res = res + TMrw.VATSum;
              end;
          end;
        end;
      end else begin
        sumrateincltax = blankval;
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(TMr,i,TMrw);
//          rateincltax = (1-(100.00/(100.00+TMrw.VATRate)))*100.00;
//          sumrateincltax = sumrateincltax + rateincltax;
          switch (TMrw.CalcBase) begin
            case kTaxTransCalculatedExternally:
            otherwise
              sumrateincltax = sumrateincltax + TMrw.VATRate;
          end;
          basesum = TMrw.BaseSum;
        end;
        switch (TMrw.CalcBase) begin
          case kTaxTransCalculatedExternally:
          otherwise
            if (InclVAT!=0) then begin
              sumrateincltax = (1-(100.00/(100.00+sumrateincltax)))*100.00;
              taxv = CalculateTaxValue("",sumrateincltax,basesum,InclVAT,0); // NoTAXonVAT    
            end;
        end;
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(TMr,i,TMrw);
          GetVATRow(TMrw.VATCode,VATCbrw);
          vt = VATType(TMrw.VATCode);
          basesum = TMrw.BaseSum;

          if (blank(VATCbrw.MinBaseAmount)==false) or (blank(VATCbrw.MaxBaseAmount)==false) then begin
//other option is to add flag to MulVATIV, but many more places to change
            switch (VATCbrw.CalcRule) begin
              case kVATCalcRuleInRangeAmount:
                if (TMrw.VATSum>0) then begin
                  basesum = basesum + VATCbrw.MinBaseAmount;
                end else begin
                  basesum = basesum - VATCbrw.MinBaseAmount;
                end;
                if (TMrw.VATSum>0) then begin
                  if (basesum<0) then begin basesum = 0.00; end;
                end else begin
                  if (basesum>0) then begin basesum = 0.00; end;
                end;        
            end;
          end;
          
//          MulVATIV(TMrw.VATCode,basesum,TMrw.VATSum,t1dummy,InclVAT,0);// no support for NoTAXonVAT      
          switch (TMrw.CalcBase) begin
            case kTaxTransCalculatedExternally:
              res = res + TMrw.VATSum;
            otherwise
              MulVATIV(TMrw.VATCode,basesum,TMrw.VATSum,t1dummy,0,0);// no support for NoTAXonVAT      //ToConsideWhenChanging
              TMrw.VATSum = Round(TMrw.VATSum,DefaultRoundMode);
              TMr.RoundVal = TMr.RoundVal + TMrw.VATSum;
          end;
/*          
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalNo:
            otherwise
              res = res + TMrw.VATSum;
          end;
*/          
          switch (VATCbrw.InclinTotal) begin
            case kTaxTransInclinTotalNo:
            otherwise
              if ((InclReversedVAT or vt!=kVATTypeReversed) and (InclConsumptionTax or vt!=kVATTypeConsumptionTax)) then begin
                res = res + TMrw.VATSum;
              end;
          end;
          MatRowPut(TMr,i,TMrw);
        end;
        TMr.RoundVal = TMr.RoundVal - taxv;    
      end;
    case kVATCalcWayPerRow:
      rwcnt = MatRowCnt(TMr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(TMr,i,TMrw);
        GetVATRow(TMrw.VATCode,VATCbrw);
        vt = VATType(TMrw.VATCode);
        switch (VATCbrw.InclinTotal) begin
          case kTaxTransInclinTotalNo:
            switch (TMrw.CalcBase) begin
              case kTaxTransCalculatedExternally:
                res = res + TMrw.VATSum;
            end;
          otherwise
            if ((InclReversedVAT or vt!=kVATTypeReversed) and (InclConsumptionTax or vt!=kVATTypeConsumptionTax)) then begin
              res = res + TMrw.VATSum;
            end;
        end;
      end;
  end;
  CalculateTotalVATFromTaxMatrix3 = res;
  return;
end;

global
function val CalculateTotalVATFromTaxMatrix2(record TaxMatrixVc TMr,Integer InclVAT,Boolean InclReversedVAT)
begin
  CalculateTotalVATFromTaxMatrix2 = CalculateTotalVATFromTaxMatrix3(TMr,InclVAT,InclReversedVAT,true);
end;

global
function val CalculateTotalVATFromTaxMatrix(record TaxMatrixVc TMr,Integer InclVAT)
begin
  CalculateTotalVATFromTaxMatrix = CalculateTotalVATFromTaxMatrix2(TMr,InclVAT,true);
end;

global
procedure TaxMatrixConvertB1ToB2(record TaxMatrixVc TMr,var val to1,var val to2,var val br1,var val br2)
begin
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  val t;
  
  rwcnt = MatRowCnt(TMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TMr,i,TMrw);
    B1ToB2Val(TMrw.VATSum,br1,br2,t);
    TMrw.VATSum = t;
    B1ToB2Val(TMrw.BaseSum,br1,br2,t);
    TMrw.BaseSum = t;
    MatRowPut(TMr,i,TMrw);
  end;
  return;
end;

global
function val TaxMatrixVATTotal(record TaxMatrixVc TMr)
begin
  Integer i,rwcnt;
  row TaxMatrixVc TMrw;
  val res;
  
  rwcnt = MatRowCnt(TMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TMr,i,TMrw);
    res = res + TMrw.VATSum;
  end;
  TaxMatrixVATTotal = res;
  return;
end;
