external function Boolean ConsigmentStock(string,string,Date);
external function val QtyUsedBeforeDate(record ItemHistVc,Boolean,Date);
external function roundmode SetRoundModeD(Integer);
external function val ConsigmentStockQty(string,string,Date);
external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);
external procedure CalcCostPrice(val,val,val,Integer,val,var val,var val);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function Integer ArtCodeCostPricePerLocation(string);
external function Integer ArtCodeWAPerLocation(string);
external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function Integer ItemCostPerLocation(record INVc);
external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function LongInt DateDiff(Date,Date);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure ExpandStructure(record INVc,string,string,Integer,var val,var val,Boolean);
external function Boolean TestArtCodeMatch(string,string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure RemoveCharactersFromString(var string,string);
external procedure ExtractObj(string,var Integer,var string);
external function Boolean CheckVARSubsets(record VARVc,string,string);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);

global
function Boolean IsVarietyItem(string item)
BEGIN
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  
  IsVarietyItem = FindItemVAR(item,sz,msk,mskrep,varsubset);
  RETURN;
END;

procedure AddToAgedArray(Date dat,Date ondat,val valp,Integer acnt,array LongInt agedpera,var array val agedqtya)
begin
  LongInt per1,per2;
  Integer late;
  
  if (acnt>0) then begin
  if (blankdate(ondat)) then begin
    late = DateDiff(dat,CurrentDate);
  end else begin
    late = DateDiff(dat,ondat);
  end;
  per1 = agedpera[0];
  per2 = agedpera[1];
  if (per1==-1) then begin per1 = -15; end;  
  if (per2==-1) then begin per2 = -30; end;  
//  if (late>=0) then  begin s0 = valp + s0; end;  
  if (late<=0 and late>=-per1) then begin agedqtya[0] = valp + agedqtya[0]; end; 
  if (late<-per1 and late>=-per2) then begin agedqtya[1] = valp + agedqtya[1]; end;  
  if ((agedpera[1]>-1) and (late<-agedpera[1])) then begin
    if (agedpera[2]==-1) then begin
      agedqtya[2] = valp + agedqtya[2];
    end else begin
      if (late<-per2 and late>=-agedpera[2]) then begin agedqtya[2] = valp + agedqtya[2]; end;  
    end;
  end;
  if ((agedpera[2]>-1) and (late<-agedpera[2])) then begin
    if (agedpera[3]==-1) then begin
      agedqtya[3] = valp + agedqtya[3];
    end else begin
      if (late<-agedpera[2] and late>=-agedpera[3]) then begin agedqtya[3] = valp + agedqtya[3]; end;  
    end;
  end;
  if ((agedpera[3]>-1) and (late<-agedpera[3])) then begin
    if (agedpera[4]==-1) then begin
      agedqtya[4] = valp + agedqtya[4];
    end else begin
      if (late<-agedpera[3] and late>=-agedpera[4]) then begin agedqtya[4] = valp + agedqtya[4]; end;  
    end;
  end;
  if ((agedpera[4]>-1) and (late<-agedpera[4])) then begin
    if (agedpera[5]==-1) then begin
      agedqtya[5] = valp + agedqtya[5];
    end else begin
      if (late<-agedpera[4] and late>=-agedpera[5]) then begin agedqtya[5] = valp + agedqtya[5]; end;  
    end;
  end;
  if ((agedpera[5]>-1) and (late<-agedpera[5])) then begin 
    agedqtya[6] = valp + agedqtya[6]; 
  end;
  end;
  RETURN;
END;

global
function Boolean TestLocation(string loc1,string loc2)
BEGIN
  record MainStockBlock MSb;
  Boolean res;
  string 255 t1,t2;

  BlockLoad(MSb);
  t1 = loc1;
  t2 = loc2;
  if (blank(t1)) then begin
    t1 = MSb.MainStock;
  end;  
  if (blank(t2)) then begin
    t2 = MSb.MainStock;
  end;  
  if (t1==t2) then begin res = true; end;
  TestLocation = res;
  RETURN;
END;

global
function val CalculateQty2(val qty,val coefficient)
begin
  record MainStockBlock MSb;
  val res;
  
  BlockLoad(MSb);
  if (coefficient==0) then begin
    res = qty;
  end else begin
    switch (MSb.UnitConvCalc) begin
      case 0: res = qty*coefficient;
      case 1: res = qty/coefficient;
    end;
  end;  
  CalculateQty2 = res;  
  RETURN;
END;

procedure BackDatStockQty2Calc(Boolean varf,string item,string location,var val instock2p,Date datp)
BEGIN
  Boolean found,testf;
  record ItemHistVc IHr;
  Integer i,keys;
  record ItemStatusVc ISr;
  record INVc INr;
  string 20 keyname,variety;
  
  if (varf) then begin
    if (ReadFirstItem(item,INr,false,false)) then begin
    end;
    variety = right(item,len(item)-len(INr.Code));
    if (nonblank(variety)) then begin
      IHr.ArtCode = INr.Code;
      IHr.Variety = variety;
      keyname = "ArtCodeVariety";
      keys = 2;
    end else begin
      IHr.ArtCode = item;
      keyname = "ArtCode";
      keys = 1;
    end;
  end else begin
    IHr.ArtCode = item;
    keyname = "ArtCode";
    keys = 1;
  end;
  found = true;
  while (LoopBackKey(keyname,IHr,keys,found)) begin //TheItemCode
    if (found) then begin
      if (IHr.ArtCode!=item) then begin found = false; end;
      if (varf) then begin
        if (nonblank(variety)) then begin
          if (IHr.Variety!=variety) then begin found = false; end;
        end;
      end;
    end;
    if (found) then begin
      if (IHr.TransDate<=datp) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;      
      if (nonblank(location)) then begin
        if (TestLocation(location,IHr.Location)==false) then begin testf = false; end;
      end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (testf) then begin
        ISr.Code = IHr.ArtCode;
        ISr.Location = IHr.Location;
        if (ReadFirstMain(ISr,2,true)) then begin
          if (nonblankdate(ISr.NoDataBefore)) then begin//INRS
            if (IHr.TransDate<ISr.NoDataBefore) then begin
              testf = false;
            end;
          end;
        end;
      end;
      if (testf) then begin
        if (IHr.FileName=="AAAStockTakeVc") then begin//INRS
          instock2p = instock2p + IHr.Qty2;
        end else begin
          if (IHr.StockAffectf!=0) then begin
//StopAlert("instock2p " & instock2p & " IHr.FileName " & IHr.FileName & " IHr.TransNr " & IHr.TransNr & " IHr.Qty " & IHr.Qty);          
            instock2p = instock2p - Round(IHr.Qty2,SetRoundModeD(3));
          end;
        end;
      end;
    end;
  end;  
  RETURN;
END;

procedure BackDatStockQty2(string item,string location,var val instockp,Date datp)
BEGIN
  Boolean varf;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  
  varf = FindItemVAR(item,sz,msk,mskrep,varsubset);
  BackDatStockQty2Calc(varf,item,location,instockp,datp);
  RETURN;
END;

procedure BackDatStockCalc(Boolean varf,string item,string location,string position,var val instockp,Date datp,Integer cosigstock)
BEGIN
  Boolean found,testf;
  record ItemHistVc IHr;
  Integer i,keys;
  record ItemStatusVc ISr;
  record INVc INr;
  string 20 keyname,variety;
 
  if (varf) then begin
    if (ReadFirstItem(item,INr,false,false)) then begin
    end;
    variety = right(item,len(item)-len(INr.Code));
    if (nonblank(variety)) then begin
      IHr.ArtCode = INr.Code;
      IHr.Variety = variety;
      keyname = "ArtCodeVariety";
      keys = 2;
    end else begin
      IHr.ArtCode = item;
      keyname = "ArtCode";
      keys = 1;
    end;
  end else begin
    IHr.ArtCode = item;
    keyname = "ArtCode";
    keys = 1;
  end;
  found = true;
  while (LoopBackKey(keyname,IHr,keys,found)) begin
    if (found) then begin
      if (nonblank(variety)) then begin
        if (IHr.ArtCode!=INr.Code) then begin found = false; end;
      end else begin
        if (IHr.ArtCode!=item) then begin found = false; end;
      end;
      if (varf) then begin
        if (nonblank(variety)) then begin
          if (IHr.Variety!=variety) then begin found = false; end;
        end;
      end;
    end;
    if (found) then begin
      if (IHr.TransDate<=datp) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;      
      if (nonblank(location)) then begin
        if (TestLocation(location,IHr.Location)==false) then begin testf = false; end;
      end;
      if (nonblank(position)) then begin
        if (IHr.Position!=position) then begin testf = false; end; 
      end;
      if (testf) then begin
        ISr.Code = IHr.ArtCode;
        ISr.Location = IHr.Location;
        if (ReadFirstMain(ISr,2,true)) then begin
          if (nonblankdate(ISr.NoDataBefore)) then begin//INRS
            if (IHr.TransDate<ISr.NoDataBefore) then begin
              testf = false;
            end;
          end;
        end;
      end;
      switch (IHr.ItemType) begin
        case kItemTypeStocked:
          if (IHr.StockAffectf==0) then begin testf = false; end;
        case kItemTypeStructured:
        otherwise
          testf = false;
      end;
      if (cosigstock!=0) then begin
        if (IHr.ConsigStock==0) then begin testf = false; end;
      end;
      if (testf) then begin
        if (IHr.FileName=="AAAStockTakeVc") then begin//INRS
//          instockp = instockp + IHr.Qty;//Set Level is not suported on Stocktaking , right ? Well, it was supposed to WORK...
        end else begin
          if (IHr.StockAffectf!=0 or IHr.ItemType==kItemTypeStructured) then begin
            instockp = instockp - Round(IHr.Qty,SetRoundModeD(3));
          end;
        end;
      end;
    end;
  end;
//  Black_Divider(0,1);
//  Black_Divider(0,1);
  RETURN;
END;

global
procedure BackDatStock(string item,string location,string position,var val instockp,Date datp,Integer cosigstock)
BEGIN
  Boolean varf;
  string 60 sz,msk,mskrep;  
  string 200 varsubset;
  
  varf = FindItemVAR(item,sz,msk,mskrep,varsubset);
  BackDatStockCalc(varf,item,location,position,instockp,datp,cosigstock);
  RETURN;
END;

/* Copy the logic for Varieties from C to here, should be easy. When this is done, copy the logic to the above function as well */
/* Beware though, make sure you test it A LOT before shipping it. */
global
procedure FindStockValue(string item,string location,var record ItemStatusVc ISp)
BEGIN
  record ItemStatusVc ISr;
  record CostAccBlock CostAccRec;
  Boolean varf,testf;
  Boolean d;
  string 60 sz,msk,mskrep;
  string 200 varsubset,variety;
  record MainStockBlock MSb;
  record INVc INr;
  Integer keys;
  string 255 keystr;

  BlockLoad(MSb);
  varf = false;
  ISp.Instock = 0;
  ISp.UValue = 0;
  ISp.OrddOut = 0;
  ISp.POQty = 0;
  ISp.RsrvQty = 0;
  ISp.StockRsrvQty = 0;
  ISp.POUnOKQty = 0;
  ISp.Instock2 = 0;
  ISp.ProdOrd = 0;
  if (FindItemVAR(item,sz,msk,mskrep,varsubset)) then begin
    varf = true;
  end;
  if (varf) then begin
    ReadFirstItem(item,INr,false,false);
  end else begin
    INr.Code = item;
    ReadFirstMain(INr,1,true);
  end;
  if ((INr.ItemType==kItemTypeStructured) and (nonblank(INr.Recepy))) then begin
    ExpandStructure(INr,INr.Recepy,location,MSb.UpdateAvailable,ISp.Instock,ISp.OrddOut,false);
    goto LFindStockValue;
  end;
  if (nonblank(location)) then begin
    if (varf) then begin
      variety = right(item,len(item)-len(INr.Code));
      d = true;
      ISr.Code = INr.Code;
      keys = 2;
      keystr = "Code";
      if (item!=INr.Code) then begin
        ISr.Variety = variety;
        keys = 3;
        keystr = "CodeVariety";
      end;
      ISr.Variety = variety;
      ISr.Location = location;
      while (LoopKey(keystr,ISr,keys,d)) begin    
        if (ISr.Code!=INr.Code) then begin d = false; end;
        if (nonblank(variety)) then begin
          if (ISr.Variety!=variety) then begin d = false; end;
        end;
        testf = true;
        if (ISr.Location!=location) then begin
          testf = false;
        end;
        if (location!=";;;") then begin
          if (ISr.Location==";;;") then begin
            testf = false;
          end;
        end;
        if (d and testf) then begin
         ISp.Instock = ISp.Instock + ISr.Instock;
         ISp.UValue = ISp.UValue + ISr.UValue;
         ISp.OrddOut = ISp.OrddOut + ISr.OrddOut;
         ISp.POQty = ISp.POQty + ISr.POQty;
         ISp.RsrvQty = ISp.RsrvQty + ISr.RsrvQty;
         ISp.StockRsrvQty = ISp.StockRsrvQty + ISr.StockRsrvQty;
         ISp.POUnOKQty = ISp.POUnOKQty + ISr.POUnOKQty;
         ISp.InShipment = ISp.InShipment + ISr.InShipment;
         ISp.Instock2 = ISp.Instock2 + ISr.Instock2;      
         ISp.ProdOrd = ISp.ProdOrd + ISr.ProdOrd;
         ISp.NoDataBefore = ISr.NoDataBefore;
        end;
      end;
    end else begin
      ISp.Code = item;
      ISp.Location = location;
      d = ReadFirstMain(ISp,2,true);
      if (d==false) then begin
        ISp.Instock = 0;
        ISp.UValue = 0;
        ISp.OrddOut = 0;
        ISp.POQty = 0;
        ISp.RsrvQty = 0;
        ISp.StockRsrvQty = 0;
        ISp.POUnOKQty = 0;
        ISp.Instock2 = 0;
        ISp.InShipment = 0;
        ISp.ProdOrd = 0;
      end;
    end;
  end else begin
    if (varf) then begin
      variety = right(item,len(item)-len(INr.Code));
      d = true;
      ISr.Location = ";;;";
      ISr.Code = INr.Code;
      keys = 2;
      if (item!=INr.Code) then begin
        ISr.Variety = variety;
        keys = 3;
      end;
      while (LoopKey("Location",ISr,keys,d)) begin
        if (ISr.Location!=";;;") then begin d = false; end;
        if (ISr.Code!=INr.Code) then begin d = false; end;
        if (nonblank(variety)) then begin
          if (ISr.Variety!=variety) then begin d = false; end;
        end;
        if (d) then begin
          ISp.Instock = ISp.Instock + ISr.Instock;
          ISp.UValue = ISp.UValue + ISr.UValue;
          ISp.OrddOut = ISp.OrddOut + ISr.OrddOut;
          ISp.POQty = ISp.POQty + ISr.POQty;
          ISp.RsrvQty = ISp.RsrvQty + ISr.RsrvQty;
          ISp.StockRsrvQty = ISp.StockRsrvQty + ISr.StockRsrvQty;
          ISp.POUnOKQty = ISp.POUnOKQty + ISr.POUnOKQty;
          ISp.InShipment = ISp.InShipment + ISr.InShipment;
          ISp.Instock2 = ISp.Instock2 + ISr.Instock2;      
          ISp.ProdOrd = ISp.ProdOrd + ISr.ProdOrd;      
          ISp.NoDataBefore = ISr.NoDataBefore;
        end;
      end;
    end else begin
      ISr.Code = item;
      ISr.Location = ";;;";
      if (ReadFirstMain(ISr,2,true)) then begin
        ISp.Instock = ISp.Instock + ISr.Instock;
        ISp.UValue = ISp.UValue + ISr.UValue;
        ISp.OrddOut = ISp.OrddOut + ISr.OrddOut;
        ISp.POQty = ISp.POQty + ISr.POQty;
        ISp.RsrvQty = ISp.RsrvQty + ISr.RsrvQty;
        ISp.StockRsrvQty = ISp.StockRsrvQty + ISr.StockRsrvQty;
        ISp.POUnOKQty = ISp.POUnOKQty + ISr.POUnOKQty;
        ISp.InShipment = ISp.InShipment + ISr.InShipment;
        ISp.Instock2 = ISp.Instock2 + ISr.Instock2;      
        ISp.ProdOrd = ISp.ProdOrd + ISr.ProdOrd;      
        ISp.NoDataBefore = ISr.NoDataBefore;
      end;
    end;
  end;
LFindStockValue:;  
  RETURN;
END;

global
procedure FindStockValueInclStockReserv(LongInt ordnr,string item,string serialnr,string location,var record ItemStatusVc ISp,var val reservebeforeq)
begin
  record INVc INr;
  record SerBalVc SBr;
  record StockReservVc StockReservr;
  Boolean foundf,testf;
  Boolean sernrf;
  record MainStockBlock MSb;
  
  FindStockValue(item,location,ISp);
  INr.Code = item;
  if (ReadFirstMain(INr,1,true)) then begin
    if (INr.SerNrf>0) then begin
      sernrf = true;
    end;
  end;
  if (sernrf and nonblank(serialnr)) then begin
    BlockLoad(MSb);

    SBr.Item = item;
    SBr.Serial = serialnr;
    SBr.Location = location;
    if (ReadFirstMain(SBr,3,true)) then begin
      ISp.Instock = SBr.Quant;
    end else begin
      if (MSb.NoSerOnPU==0) then begin
        ISp.Instock = 0;
      end;
    end;
  end;
  reservebeforeq = 0;
  if (ISp.StockRsrvQty!=0) then begin
    if (nonblank(location)) then begin
      foundf = true;
      StockReservr.FromLocation = location;
      StockReservr.Donef = 0;
      StockReservr.ArtCode = item;
      while (LoopKey("FromLocation",StockReservr,3,foundf)) begin
        if (StockReservr.FromLocation!=location) then begin
          foundf = false;
        end;
        if (StockReservr.ArtCode!=item) then begin
          foundf = false;
        end;
        if (StockReservr.Donef!=0) then begin
          foundf = false;
        end;
        testf = foundf;
        if (StockReservr.ToFileName!=kResTypeStock) then begin
          testf = false;
        end;
        if (sernrf) then begin
          if (nonblank(serialnr) and serialnr!=StockReservr.SerialNr) then begin
            if (nonblank(StockReservr.SerialNr)) then begin
              testf = false;
            end;
          end;
        end;
        if (testf) then begin
          if (StockReservr.FromFileName==kResTypeSalesOrder and StockReservr.FromSerNr==ordnr) then begin
            foundf = false;
          end else begin
            reservebeforeq = reservebeforeq + (StockReservr.Quant - StockReservr.QuantDone);
          end;
        end;
      end;
    end else begin
      foundf = true;
      StockReservr.Donef = 0;
      StockReservr.ArtCode = item;
      while (LoopKey("ArtCode",StockReservr,2,foundf)) begin
        if (StockReservr.ArtCode!=item) then begin
          foundf = false;
        end;
        if (StockReservr.Donef!=0) then begin
          foundf = false;
        end;
        testf = foundf;
        if (StockReservr.ToFileName!=kResTypeStock) then begin
          testf = false;
        end;
        if (sernrf) then begin
          if (nonblank(serialnr) and serialnr!=StockReservr.SerialNr) then begin
            if (nonblank(StockReservr.SerialNr)) then begin
              testf = false;
            end;
          end;
        end;
        if (testf) then begin
          if (StockReservr.FromFileName==kResTypeSalesOrder and StockReservr.FromSerNr==ordnr) then begin
            foundf = false;
          end else begin
            reservebeforeq = reservebeforeq + (StockReservr.Quant - StockReservr.QuantDone);
          end;
        end;
      end;
    end;
  end;
  return;
end;


global
procedure FindStockValueInclEntireStockReserv(string item,string serialnr,string location,var record ItemStatusVc ISp,var val reservebeforeq)
begin
  record INVc INr;
  record SerBalVc SBr;
  record StockReservVc StockReservr;
  Boolean foundf,testf;
  Boolean sernrf;
  record MainStockBlock MSb;
  
  FindStockValue(item,location,ISp);
  INr.Code = item;
  if (ReadFirstMain(INr,1,true)) then begin
    if (INr.SerNrf>0) then begin
      sernrf = true;
    end;
  end;
  if (sernrf and nonblank(serialnr)) then begin
    BlockLoad(MSb);

    SBr.Item = item;
    SBr.Serial = serialnr;
    SBr.Location = location;
    if (ReadFirstMain(SBr,3,true)) then begin
      ISp.Instock = SBr.Quant;
    end else begin
      if (MSb.NoSerOnPU==0) then begin
        ISp.Instock = 0;
      end;
    end;
  end;
  if (ISp.StockRsrvQty!=0) then begin
    reservebeforeq = 0;
    foundf = true;
    if (nonblank(location)) then begin
      StockReservr.FromLocation = location;
      StockReservr.Donef = 0;
      StockReservr.ArtCode = item;
      while (LoopKey("FromLocation",StockReservr,3,foundf)) begin
        if (StockReservr.FromLocation!=location) then begin
          foundf = false;
        end;
        if (StockReservr.ArtCode!=item) then begin
          foundf = false;
        end;
        if (StockReservr.Donef!=0) then begin
          foundf = false;
        end;
        testf = foundf;
        if (StockReservr.ToFileName!=kResTypeStock) then begin
          testf = false;
        end;
        if (sernrf) then begin
          if (nonblank(serialnr) and serialnr!=StockReservr.SerialNr) then begin
            testf = false;
          end;
        end;
        if (testf) then begin
          reservebeforeq = reservebeforeq + (StockReservr.Quant - StockReservr.QuantDone);
        end;
      end;
    end else begin
      StockReservr.Donef = 0;
      StockReservr.ArtCode = item;
      while (LoopKey("ArtCode",StockReservr,2,foundf)) begin
        if (StockReservr.ArtCode!=item) then begin
          foundf = false;
        end;
        if (StockReservr.Donef!=0) then begin
          foundf = false;
        end;
        testf = foundf;
        if (StockReservr.ToFileName!=kResTypeStock) then begin
          testf = false;
        end;
        if (sernrf) then begin
          if (nonblank(serialnr) and serialnr!=StockReservr.SerialNr) then begin
            testf = false;
          end;
        end;
        if (testf) then begin
          reservebeforeq = reservebeforeq + (StockReservr.Quant - StockReservr.QuantDone);
        end;
      end;
    end;
  end;
  return;
end;

global
procedure Find2StockValue(string item,string location,var val instockp,Date datp)
BEGIN
  record ItemStatusVc ISr;
  
  FindStockValue(item,location,ISr);
  instockp = ISr.Instock;
  if (blankdate(datp)) then begin goto LFind2StockValue; end;
  BackDatStock(item,location,"",instockp,datp,0);
LFind2StockValue:;
  RETURN;
END;

global
procedure Find2Stock2Value(string item,string location,var val instock2p,Date datp)
BEGIN
  record ItemStatusVc ISr;
  
  FindStockValue(item,location,ISr);
  instock2p = ISr.Instock2;
  if (blankdate(datp)) then begin goto LFind2Stock2Value; end;
  BackDatStockQty2(item,location,instock2p,datp);
LFind2Stock2Value:;
  RETURN;
END;

global
function val GetStockQty(string item,string location,Date datp,Boolean qty2f)
BEGIN
  val res;
  
  if (qty2f==false) then begin
    Find2StockValue(item,location,res,datp);
  end else begin
    Find2Stock2Value(item,location,res,datp);
  end;
  GetStockQty = res;
  RETURN;
END;

global
function val GetStockQty2(string item,string location,Date datp,Boolean qty2f,Integer sumf)
BEGIN
  val res,r2;
  record AutoProdVc AutoProdr;
  Boolean foundf,testf;
  
  if (qty2f==false) then begin
    Find2StockValue(item,location,res,datp);
  end else begin
    Find2Stock2Value(item,location,res,datp);
  end;
  if (sumf==1) then begin
    foundf = true;
    AutoProdr.ToItemCode = item;
    while (LoopKey("ToItemCode",AutoProdr,1,foundf)) begin
      if (AutoProdr.ToItemCode!=item) then begin
        foundf = false;
      end;
      if (foundf) then begin
        r2 = 0;
        if (qty2f==false) then begin
          Find2StockValue(AutoProdr.FromItemCode,location,r2,datp);
        end else begin
          Find2Stock2Value(AutoProdr.FromItemCode,location,r2,datp);
        end;
        res = res + r2 * AutoProdr.UnitCoefficient;
      end;
    end;
  end;
  if (sumf==2) then begin
    foundf = true;
    AutoProdr.FromItemCode = item;
    while (LoopMain(AutoProdr,1,foundf)) begin
      if (AutoProdr.FromItemCode!=item) then begin
        foundf = false;
      end;
      testf = foundf;
      if (AutoProdr.Default==0) then begin
        testf = false;
      end;
      if (testf) then begin
        r2 = 0;
        if (qty2f==false) then begin
          Find2StockValue(AutoProdr.ToItemCode,location,r2,datp);
        end else begin
          Find2Stock2Value(AutoProdr.ToItemCode,location,r2,datp);
        end;
        res = res + r2 / AutoProdr.UnitCoefficient;
      end;
    end;
  end;
  GetStockQty2 = res;
  RETURN;
END;

global
updating procedure UpdateInShipment(string ac,string location,Date transdat,val q)
BEGIN
  record ItemStatusVc oldISr;
  record ItemStatusVc ISr;
  Boolean found;
  record INVc INr;
  Integer keys;

  keys = 2;
  ISr.Code = ac;
  if (ReadFirstItem(ac,INr,false,false)) then begin
    if (ac!=INr.Code) then begin
      ISr.Variety = right(ac,len(ac)-len(INr.Code));
      ISr.Code = INr.Code;
      keys = 3;
    end;
  end;
  ISr.Location = location;
  found = ReadFirstMain(ISr,keys,true);
  RecordCopy(oldISr,ISr);
  if (found==false) then begin
    ISr.Code = ac;
    if (nonblank(INr.Code)) then begin
      if (ac!=INr.Code) then begin
        ISr.Variety = right(ac,len(ac)-len(INr.Code));
        ISr.Code = INr.Code;
      end;
    end;
    ISr.Location = location;
    ISr.Instock = 0;
    ISr.UValue = 0;
    ISr.OrddOut = 0;
    ISr.POQty = 0;
    ISr.RsrvQty = 0;
    ISr.StockRsrvQty = 0;
    ISr.POUnOKQty = 0;
    ISr.InShipment = 0;
    ISr.Instock2 = 0;
  end;
  ISr.InShipment = ISr.InShipment + q;
  if (found) then begin
    if (RecordUpdate(oldISr,ISr,false)==0) then begin
    end;
  end else begin
    if (RecordStore(ISr,false)) then begin
    end;
  end;
  if (location!=";;;") then begin
    UpdateInShipment(ac,";;;",transdat,q);
  end;
  RETURN;
END;

global
procedure GetStockValue(string item,string location,var record ItemStatusVc ISp)
BEGIN
  record INVc INr;
  record MainStockBlock MSb;
  val stock,ord;

  BlockLoad(MSb);
  if (ReadFirstItem(item,INr,false,false)) then begin
    if ((INr.ItemType==kItemTypeStructured) and (nonblank(INr.Recepy))) then begin
      ExpandStructure(INr,INr.Recepy,location,MSb.UpdateAvailable,stock,ord,false);
      ISp.Instock = stock;
      ISp.OrddOut = ord;
      ISp.Code = item;
      ISp.Location = location;
    end else begin
      FindStockValue(item,location,ISp);
    end;
  end;
  RETURN;
END;

global
procedure FindStockValue2(record INVc INp,string variety,string location,Integer curncytday,Date todatp,Integer printvals,Boolean manyloc,var val totcp,var val totq,var val totq2,Integer qty2,Integer CostModel,Integer ConsigStock,Integer repcalcwa,
                          Boolean printlocqf,vector val vlocationtotals)
begin
  record LocationVc Locr;
  Boolean found;
  record CostAccBlock CAb;
  record WeigAvVc war;
  Boolean backf,d;
  val t,o;
  val instock,instock2;          
  Integer StockListCostModel;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  val costprc,resprice,restotprice,adjustqty,consiginstock,instockwithconsig;
  record GeneralOptionBlock GOb;
  
  BlockLoad(CAb);
  BlockLoad(GOb);
  GetCostModel(INp,CAb,ITr,primary,queuecostmodel,false);
  StockListCostModel = CostModel;
  if (CostModel==0) then begin
    StockListCostModel = primary;
  end;
  if (queuecostmodel==20) then begin
    StockListCostModel = 4;
  end;  

  totcp = blankval;
  totq = blankval;
  if (nonblankdate(todatp)) then begin backf = true; end;
  found = true;
  Locr.Code = location;
  while (LoopMain(Locr,1,found)) begin
    if (nonblank(location)) then begin
      if (Locr.Code!=location) then begin found = false; end;
    end;
    if (found) then begin
      instock = GetStockQty(INp.Code & variety,Locr.Code,todatp,false);
      switch (ConsigStock) begin
        case 0: instockwithconsig = instock;
        case 1:
          consiginstock = ConsigmentStockQty(INp.Code & variety,Locr.Code,todatp);
          instockwithconsig = instock - consiginstock;
        case 2: 
          consiginstock = ConsigmentStockQty(INp.Code & variety,Locr.Code,todatp);
          instockwithconsig = consiginstock;
      end;
      if (instockwithconsig!=0) then begin
        vlocationtotals[Locr.Code] = vlocationtotals[Locr.Code] + instock;
        if (printlocqf) then begin
          StartFormat(15);
          OutString(120,0,Locr.Code,false);
          OutVal(3,0,instockwithconsig,M4UVal,true);
          if (qty2!=0) then begin
            instock2 = GetStockQty(INp.Code & variety,Locr.Code,todatp,true);
            OutVal(360,0,instock2,M4UVal,true);
            totq2 = totq2 + instock2;
          end;  
        end;
        if (printvals!=0) then begin
          switch (StockListCostModel) begin
            case 1:
              if (nonblankdate(todatp)) and (todatp<CurrentDate) then begin
                t = FindCPPriceBackdated(ArtCodeCostPricePerLocation(INp.Code),INp,Locr.Code,instock,todatp,false);                
              end else begin
                t = INp.InPrice;
              end;            
            case 2:
                costprc = INp.CostPerc;
                if (costprc==0) then begin
                  costprc = ITr.CostPerc;
                end;
                if (costprc==0) then begin
                  costprc = CAb.CostPerc;
                end;
                CalcCostPrice(instock,INp.UPrice1,INp.PriceFactor,GOb.UseDiscount,costprc,t,restotprice);
            case 3:
              if (nonblankdate(todatp)) then begin
                t = FindWAPriceBackdated(ArtCodeWAPerLocation(INp.Code),INp,Locr.Code,instock,todatp,false,0);
                t = t/instock;
/*
                if (WAPerLocation(INp,ITr,CAb)) then begin
                  t = FindCostPriceFIFOBackDated(1,INp,Locr.Code,"",instock,todatp,false,0,false,0,0,repcalcwa);
                end else begin
//                  t = instock*INp.WeighedAvPrice;
                  t = FindCostPriceFIFOBackDated(1,INp,Locr.Code,"",instock,todatp,false,0,false,0,0,repcalcwa);
                end;
*/                
              end else begin
                if (WAPerLocation(INp,ITr,CAb)) then begin
                  war.ArtCode = INp.Code;
                  war.Location = Locr.Code;
                  if (ReadFirstMain(war,2,true)) then begin
                    t = war.WeighedAvPrice;
                  end;
                end else begin
                  t = INp.WeighedAvPrice;
                end;
              end;            
            case 4:
              switch (queuecostmodel) begin
                case 0: 
                  t = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,Locr.Code,"",instock,adjustqty,todatp,false,0,false,0,consigstock,repcalcwa);//Integer
                  if (ItemCostPerLocation(INp)==0) then begin
                    adjustqty = adjustqty + instock;
                  end;
                case 1: t = FindCostPriceLIFOBackDated(ItemCostPerLocation(INp),INp,Locr.Code,"",instock,adjustqty,todatp,false,0,false,0,0,repcalcwa);
                  if (ItemCostPerLocation(INp)==0) then begin
                    adjustqty = adjustqty + instock;
                  end;
                case 20: 
                  t = FindCostPriceFIFOBackDated(ItemCostPerLocation(INp),INp,Locr.Code,"",instock,adjustqty,todatp,false,0,false,0,consigstock,repcalcwa);//Integer
                  if (ItemCostPerLocation(INp)==0) then begin
                    adjustqty = adjustqty + instock;
                  end;
              end;
              t = t/instockwithconsig;
          end;
          o = t*instockwithconsig;
          if (printlocqf) then begin
            OutVal(4,0,t,M4Val,true);
            OutVal(1,0,o,M4Val,true);
          end;
          vlocationtotals[Locr.Code & ":" & "VALUE"] = vlocationtotals[Locr.Code & ":" & "VALUE"] + o;
        end;
        if (printlocqf) then begin
          EndFormat;
        end;
        totcp = totcp + o;
        totq = totq + instockwithconsig;
      end;
    end;
  end;
  return;
end;

function val SourceQtyUsedInPeriod(LongInt source,Date d1,string location)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  
  found = true;
  IHr.Source = source;
  while (LoopKey("Source",IHr,1,found)) begin
    if (IHr.Source!=source) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.TransDate>d1) then begin testf = false; end;
      switch (IHr.FileName) begin 
        case "StockMovVc":
          if (nonblank(location)) then begin
          end else begin
            testf = false;
          end;        
        case "SRVc": testf = false; 
      end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        res = res - IHr.Qty;
/*
      StartFormat(15);
      OutString(0,0,"jje",false);
      OutString(50,0,IHr.FileName,false);
      OutString(130,0,IHr.TransNr,false);
      OutString(200,0,IHr.TransDate,false);
      OutString(370,0,d1,false);
      EndFormat;
*/
      end;
    end;
  end;
  SourceQtyUsedInPeriod = res;
  return;
end;

global
function val ItemHistQtyInPeriod(string item,string location,Date d1,Date startd,Date endd)
begin
  val res;
  val v;
  record ItemHistVc IHr;
  Boolean found,testf;
  string 255 keystr;
  Integer keys;
  
  if (nonblank(location)) then begin
    keystr = "ArtCodeLoc";
    keys = 3;
    IHr.Location = location;
  end else begin
    keystr = "ArtCode";
    keys = 2;
  end;
  found = true;
  IHr.ArtCode = item;
  IHr.TransDate = endd;
  while (LoopBackKey(keystr,IHr,keys,found)) begin
    if (IHr.ArtCode!=item) then begin found = false; end;
    if (nonblank(location)) then begin
      if (IHr.Location!=location) then begin found = false; end;
    end;
    if (DateInRange(IHr.TransDate,startd,endd)==false) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        switch (IHr.FileName) begin
          case "PUVc":
          case "RetVc":
          case "RetPUVc":
          case "ProdVc":
          case "ProdOperationVc":
          case "IVVc":
            if (IHr.Qty<0) then begin testf = false; end;
          case "StockMovVc":
            if (nonblank(location)) then begin
            end else begin
              testf = false;
            end;
            if (IHr.Qty<0) then begin testf = false; end;
          otherwise 
            testf = false;
        end;
/*         
      StartFormat(15);
      OutString(0,0,"krakra",false);
      OutString(50,0,IHr.FileName,false);
      OutString(130,0,IHr.TransNr,false);
      OutString(200,0,res,false);
      OutString(300,0,IHr.TransDate,false);
      OutString(360,0,DateDiff(d1,IHr.TransDate)-1,false);
      OutString(390,0,startd,false);
      OutString(450,0,endd,false);
      EndFormat;
*/      

        if (testf) then begin
          v = 0;//SourceQtyUsedInPeriod(IHr.SerNr,d1,location);          
          res = res + (IHr.Qty - v);              
/*         
      StartFormat(15);
      OutString(0,0,"kka",false);
      OutString(50,0,IHr.FileName,false);
      OutString(130,0,IHr.TransNr,false);
      OutString(200,0,res,false);
      OutString(300,0,IHr.TransDate,false);
      OutString(360,0,DateDiff(d1,IHr.TransDate)-1,false);
      OutString(390,0,startd,false);
      OutString(450,0,endd,false);
      EndFormat;
*/      
        end;
      end;
    end;
  end;
  ItemHistQtyInPeriod = res;
  return;
end;

function LongInt CntStockMovInLines(record ItemHistVc sourceIHr)
begin
  LongInt res;
  record ItemHistVc IHr;
  Boolean found;
  
  res = 0;  
  if (sourceIHr.TransNr>0) then begin
    found = true;
    IHr.FileName = sourceIHr.FileName;
    IHr.TransNr = sourceIHr.TransNr;
    IHr.Row = sourceIHr.Row;
    while (LoopBackKey("FNTransNr",IHr,3,found)) begin
      if (IHr.FileName!=sourceIHr.FileName) then begin found = false; end;
      if (IHr.TransNr!=sourceIHr.TransNr) then begin found = false; end;
      if (IHr.Row!=sourceIHr.Row) then begin found = false; end;
      if (found) then begin
        if (IHr.Source>0) then begin 
          if (IHr.SerNr<sourceIHr.SerNr) then begin
            res = sourceIHr.SerNr - IHr.SerNr;
            found = false; 
          end;
        end;
      end;
    end;
  end;
  if (res<0) then begin
    res = 0;
  end;  
  CntStockMovInLines = res;
  return;
end;

function val QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov(LongInt SourceNr)
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  
  if (SourceNr>0) then begin
    found = true;
    IHr.Source = SourceNr;
    while (LoopKey("Source",IHr,1,found)) begin
      if (IHr.Source!=SourceNr) then begin
        found = false;
      end;
      if (found) then begin
        switch (IHr.FileName) begin
          case "StockMovVc":
//            res = res + QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov(IHr.SerNr+CntStockMovInLines(IHr));
            res = res + QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov(IHr.SerNr+1);
          otherwise 
            res = res + IHr.Qty;
        end;
      end;
    end;
  end;
  QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov = res;
  return;
end;

function val QtySoldBeforeDate_NOT_FIFOPerLocation(record ItemHistVc sourceIHr,Boolean fifodatef,Date td)//should be almost same as QtyUsedBeforeDate
begin
  val res;
  record ItemHistVc IHr;
  Boolean found,testf;
  val smsoldq;
  
  if (sourceIHr.SerNr>0) then begin
    found = true;
    IHr.Source = sourceIHr.SerNr;
    while (LoopKey("Source",IHr,1,found)) begin
      if (IHr.Source!=sourceIHr.SerNr) then begin
        found = false;
      end;
      if (found) then begin
        testf = true;
        if (fifodatef) then begin
          if (IHr.FIFODate>td) then begin testf = false; end;
         end else begin
          if (IHr.TransDate>td) then begin testf = false; end;
        end;
        if (testf) then begin
          switch (IHr.FileName) begin
            case "StockMovVc":
//              res = res - QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov(IHr.SerNr+CntStockMovInLines(IHr));
              res = res - QtySoldBeforeDate_NOT_FIFOPerLocation_StockMov(IHr.SerNr+1);
              testf = false;
          end;
        end;
        if (testf) then begin
          res = res - IHr.Qty;
        end;
      end;
    end;
  end;
  QtySoldBeforeDate_NOT_FIFOPerLocation = res;
  return;
end;

global
procedure FindSourcePU(LongInt source,var record ItemHistVc PUsourceIHr)
begin  
  record ItemHistVc sourceIHr;
  record RetVc Retr;
  row RetVc Retrw;
  Boolean found;
  row PUVc PUrw;

  if (source>0) then begin
    sourceIHr.SerNr = source;
    if (ReadFirstKey("SerNr",sourceIHr,1,true)) then begin
      switch (sourceIHr.FileName) begin
        case "PUVc":
          RecordCopy(PUsourceIHr,sourceIHr);
        case "StockMovVc":
          sourceIHr.SerNr = sourceIHr.SerNr - CntStockMovInLines(sourceIHr);
          if (ReadFirstKey("SerNr",sourceIHr,1,true)) then begin
            if (sourceIHr.Source>=source) then begin
              LogText(0,"1.FindSourcePU, sourceIHr.Source==source, source: " & source & " Item: " & sourceIHr.ArtCode & " Stock Movement: " & sourceIHr.TransNr & " ,skipping to avoid infinite loop...");
            end else begin
              FindSourcePU(sourceIHr.Source,PUsourceIHr);
            end;
          end;
        case "RetVc":
          Retr.SerNr = sourceIHr.TransNr;
          if (ReadFIrstMain(Retr,1,true)) then begin
            if (sourceIHr.Row<MatRowCnt(Retr)) then begin
              MatRowGet(Retr,sourceIHr.Row,Retrw);
              if (Retr.SHNr>0) then begin
                sourceIHr.FileName = "SHVc";
                sourceIHr.TransNr = Retr.SHNr;
                sourceIHr.Row = Retrw.SHRow;
                found = true;
//Trace("sourceIHr.FileName " & sourceIHr.FileName," sourceIHr.TransNr " & sourceIHr.TransNr & " sourceIHr.Row " & sourceIHr.Row);  
                while (LoopKey("FNTransNr",sourceIHr,3,found)) begin                
                  if (sourceIHr.FileName!="SHVc") then begin found = false; end;
                  if (sourceIHr.TransNr!=Retr.SHNr) then begin found = false; end;
                  if (sourceIHr.Row!=Retrw.SHRow) then begin found = false; end;
                  if (found) then begin
                    if (sourceIHr.Source>=source) then begin
                      LogText(0,"2.FindSourcePU, sourceIHr.Source==source, source: " & source & " Item: " & sourceIHr.ArtCode & " Stock Movement: " & sourceIHr.TransNr & " ,skipping to avoid infinite loop...");
                    end else begin
                      FindSourcePU(sourceIHr.Source,PUsourceIHr);
                    end;
//Trace("sourceIHr.Source " & sourceIHr.Source," sourceIHr.Qty " & sourceIHr.Qty & " acnt " & acnt );  
                  end;
                end;
              end;
            end;
          end;
      end;
    end;
  end;
  return;
end;

procedure AddToAgeingArrays(val qty,val sum,date backdate,date ihdate,LongInt acnt,array LongInt agedpera,var array val agedqtya,var array val agedsuma)
begin
  LongInt i;
  date fromdate,todate,bldate;
  Boolean addf;
  
  todate = backdate;
  
  for (i = 0; i<=acnt; i = i + 1) begin
    addf = true;
    
    if (agedpera[i]<0) then begin
      fromdate = bldate;
    end else begin
      fromdate = AddDay(backdate,-agedpera[i]+1);
    end;
    
    if (nonblankdate(fromdate)) then begin
      if (DateInRange(ihdate,fromdate,todate)==false) then begin addf = false; end;
    end else begin
      if (ihdate>todate) then begin addf = false; end;
    end;
    
    if (addf) then begin
      agedqtya[i] = agedqtya[i] + qty;
      agedsuma[i] = agedsuma[i] + sum;
    end;
    
    todate = AddDay(fromdate,-1);
  end;
end;

procedure ItemHistQty_NOT_FIFOPerLocation(string artcode,string location,Date d1,Integer acnt,array LongInt agedpera,var array val agedqtya,var array val agedsuma)
begin
  record ItemHistVc IHr;
  record ItemHistVc UserIHr;
  Integer i,segs;
  val instock,qcnt,qty,blval,sum,q;
  Boolean found,testf,foundsourcef;
  string 255 thekey;
  
  IHr.ArtCode = artcode;
  IHr.Location = location;
  IHr.FIFODate = d1;
  
  if (blank(IHr.Location)) then begin
    thekey = "ArtCodeFD";//ArtCodeFD
    segs = 2;
    instock = GetStockQty(artcode,"",d1,false);
  end else begin
    thekey = "ArtCodeLocFD";//ArtCodeLoc, ArtCodeLocFD
    segs = 3;
    instock = GetStockQty(artcode,location,d1,false);
  end;
  
  ResetLoop(IHr);
  found = true;
  while (LoopBackKey(thekey,IHr,segs,found)) begin
    if (IHr.ArtCode!=artcode) then begin
      found = false;
    end;
    if (segs==3) then begin
      if (IHr.Location!=location) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (IHr.FileName=="StockMovVc") then begin testf = false; end;
      if (testf and IHr.Qty>0) then begin
        qty = IHr.Qty;
        sum = IHr.TotCostPrice;
        if ((qcnt + qty)>instock) then begin
          qty = instock - qcnt;
          sum = (IHr.TotCostPrice*qty)/IHr.Qty;
        end;
        
        AddToAgeingArrays(qty,sum,d1,IHr.FIFODate,acnt,agedpera,agedqtya,agedsuma);
        qcnt = qcnt + qty;
        
        if (qcnt>=instock) then begin
          found = false;
        end;
      end;
    end;
  end;
  
  IHr.ArtCode = artcode;
  IHr.Location = location;
  IHr.FIFODate = CurrentDate;
  
  if (blank(IHr.Location)) then begin
    thekey = "ArtCodeFD";//ArtCodeFD
    segs = 2;
    instock = GetStockQty(artcode,"",CurrentDate,false);
  end else begin
    thekey = "ArtCodeLocFD";//ArtCodeLoc, ArtCodeLocFD
    segs = 3;
    instock = GetStockQty(artcode,location,CurrentDate,false);
  end;
  
  ResetLoop(IHr);
  found = true;
  while (LoopBackKey(thekey,IHr,segs,found)) begin
    if (IHr.ArtCode!=artcode) then begin
      found = false;
    end;
    if (segs==3) then begin
      if (IHr.Location!=location) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (IHr.StockAffectf==0) then begin testf = false; end;
      if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
      if (IHr.Invalid!=0) then begin testf = false; end;
      if (IHr.FileName!="StockMovVc") then begin testf = false; end;
      if (testf and IHr.Qty>0) then begin
        qty = IHr.Qty;
        sum = IHr.TotCostPrice;
        if ((qcnt + qty)>instock) then begin
          qty = instock - qcnt;
          sum = (IHr.TotCostPrice*qty)/IHr.Qty;
        end;
        FindSourcePU(IHr.SerNr-CntStockMovInLines(IHr),UserIHr);
        if (UserIHr.SerNr>0 and (UserIHr.Source!=-1) and (UserIHr.TransDate<=d1 or blankdate(d1))) then begin
          q = UserIHr.Qty;
          if (q>qty) then begin q = qty; end;
          qty = qty - q;
        end;
        
        AddToAgeingArrays(qty,sum,d1,IHr.FIFODate,acnt,agedpera,agedqtya,agedsuma);
        qcnt = qcnt + qty;
        
        if (qcnt>=instock) then begin
          found = false;
        end;
      end;
    end;
  end;
  
  return;
end;

global
procedure FindStockListAged(record INVc INr,string location,record RcVc RepSpec,val instock,Integer acnt,array LongInt agedpera,var array val agedqtya,var array val agedsuma)
begin
  Date td,td2,d1,startd;
  Integer i;
  val v,useqty,prevdv,prevdv2;
  record CostAccBlock CAb;
  record ItemHistVc IHr;
  Boolean found,testf;
  record ItemStatusVc ISr;
  
  BlockLoad(CAb);
  d1 = RepSpec.d1;
  if (blankdate(d1)) then begin
    d1 = CurrentDate;
  end;
  
  if (CAb.FIFOPerLocation!=0) or (nonblank(RepSpec.f2))  then begin
    td = d1;
    // ItemHistQty_NOT_FIFOPerLocation should work for Per Location as well    
    ItemHistQty_NOT_FIFOPerLocation(INr.Code,location,d1,acnt,agedpera,agedqtya,agedsuma);
  end else begin
    ItemHistQty_NOT_FIFOPerLocation(INr.Code,location,d1,acnt,agedpera,agedqtya,agedsuma);
  end;
  
  return;
end;
