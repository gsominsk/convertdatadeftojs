external function string 60 UpdatedeRowObject(string,string,string);
external function string 60 GetPayModeObjectsStr(string);
external function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
external procedure PasteARPayInIV(record IVVc,row IVVc,Integer);
external updating function Integer RecordAction_raOrdDownPay(LongInt,val,val,var record IVVc,var string,integer);
forward function Boolean IPVc_PasteToRateB1BankVal(var record IPVc,Integer);
external function val TaxMatrixVATTotal(record TaxMatrixVc);
external procedure RowCalculateTaxMatrix_IPVc(var record IPVc,Integer,row IPVc,Integer);
external function roundmode DefaultRoundMode();
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure FindUserMailboxName(string,var string,var string);
external function roundmode GetTotalRoundMode(record RoundBlock);
external function roundmode GetVATRoundMode(record RoundBlock);
external function roundmode SetRoundModeD(Integer);
external function string 255 GetCustomerOnAccountAC(string);
external procedure MulVATIV(string,val,var val,var val,Integer,Integer);
external procedure SetActTypeValues(record ActVc);
external function Boolean PasteActTypeInAct(string,var record ActVc);
external function LongInt NextFreeCashSerNr(row PMBlock,Boolean);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt DateDiff(Date,Date);
remote function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external function Integer PMCheckType(string,var string,var string);
external procedure Mul2VAT(string,val,var val,var val,Integer);
external procedure ChangeSVIPRecCur(row IPVc,Date,val);
external procedure IPInvsum(record IPVc,LongInt,string,var val);
external procedure MatchIPRowSums(string,string,Date,string,var val,var string,var val,string,var val,Boolean,Boolean,Boolean);
external function Boolean GetPMCurrency(string,var string);
external procedure IPSumup(var record IPVc);
external procedure Base1ToOther(var string,val,val,val,val,val,val,var val,roundmode);
external function Boolean GetFullCurncyRateDate(var string,Date,var val,var val,var val,var val,var val,var Date);
external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);

function string 255 ActContactFromIP(longint InvNr,longint OrderNr,string CustCode)
begin
  string 255 res;
  record IVVc IVr;
  record ORVc ORr;
  record CUVc CUr;
  boolean NoContactf;
  
  NoContactf = true;  
  if (nonblank(InvNr)) then begin 
    IVr.SerNr = InvNr;
    if (ReadFirstMain(IVr,1,true)) then begin 
      if (nonblank(IVr.ClientContact)) then begin 
        res = IVr.ClientContact;
        NoContactf = false;
      end;
    end;
  end;
  if (NoContactf and nonblank(OrderNr)) then begin 
    ORr.SerNr = OrderNr;
    if (ReadFirstMain(ORr,1,true)) then begin 
      if (nonblank(ORr.CustContact)) then begin
        res = ORr.CustContact;
        NoContactf = false;
      end;
    end;    
  end;
  if (NoContactf and nonblank(CustCode)) then begin 
    CUr.Code = CustCode;
    if (ReadFirstMain(CUr,1,true)) then begin 
      if (nonblank(CUr.Person)) then begin 
        res = CUr.Person;
        NoContactf = false;
      end;
    end;    
  end;  
  if (NoContactf) then begin 
    res = CurrentUser;
  end;
  ActContactFromIP = res;
end;

procedure CurValToOtherCurWithRate(Date td,string frcur,val frval,string tocur,val abr1,var val toval,roundmode roundof)
begin
  string 20 curncy;
  val fr,to1,to2,br1,br2;
  val temp;
  Date ed;
  Boolean testf;

  temp = MulWithRateToBase1(frcur,td,frval,SetRoundModeD(7));    
  testf = GetFullCurncyRateDate(tocur,td,fr,to1,to2,br1,br2,ed); 
  if (nonblank(abr1)) then begin
    br1 = abr1;
  end;
  curncy = tocur;
  Base1ToOther(curncy,temp,fr,to1,to2,br1,br2,toval,roundof);  
  return;
end;

global
procedure IPVc_PasteVATCode(var record IPVc IPp,Integer rownr)
begin
  row IPVc IPrw;
  val rs,t,t1;
  record RoundBlock Rb;
  record AccBlock Accb;
  
  BlockLoad(Rb);  
  MatRowGet(IPp,rownr,IPrw);  
  if (nonblank(IPrw.VATCode)) then begin
    if (IPrw.InvoiceNr<0) then begin
      BlockLoad(Accb);  
      MulVATIV(IPrw.VATCode,IPrw.InvVal,t,t1,1,Accb.NoTAXonVAT);
      IPrw.VATVal = Round(t,GetVATRoundMode(Rb));
      IPrw.TAX1Sum = Round(t1,GetVATRoundMode(Rb));
    end else begin
      Mul2VAT(IPrw.VATCode,IPrw.InvVal,t,rs,1);
      IPrw.VATVal = t;
      IPrw.VATVal = Round(t,GetVATRoundMode(Rb));
    end;
  end else begin
    IPrw.VATVal = blankval;
    IPrw.TAX1Sum = blankval;
  end;  
  MatRowPut(IPp,rownr,IPrw);
  return;
end;

// Not used anywhere else, removed the global.
function Boolean GetORRate(LongInt cupnr,var val fr,var val to1,var val to2,var val br1,var val br2)
begin
  record ORVc ORr;
  Boolean res;
  
  ORr.SerNr = cupnr;
  if (ReadFirstMain(ORr,1,true)) then begin
    fr = ORr.FrRate;
    to1 = ORr.ToRateB1;
    to2 = ORr.ToRateB2;
    br1 = ORr.BaseRate1;
    br2 = ORr.BaseRate2;
    res = true;
  end;
  GetORRate = res;
  return;
end;

global
procedure ChangeIPInvVal(row IPVc IPrw,Date tdp)
begin
  val fr,to1,to2,br1,br2,t;

  if (IPrw.InvCurncy==IPrw.RecCurncy) then begin
    IPrw.InvVal = IPrw.RecVal;
  end else begin
    if (IPrw.CUPNr==-1) then begin
      CurValToOtherCurWithRate(tdp,IPrw.RecCurncy,IPrw.RecVal,IPrw.InvCurncy,IPrw.ToRateB1BankVal,t,DefaultCurRoundOff);
      IPrw.InvVal = t;
    end else begin      
      if (GetORRate(IPrw.OrderNr,fr,to1,to2,br1,br2)) then begin//CUPNr
        t = MulRateToBase1(IPrw.RecCurncy,IPrw.RecVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);      
      end else begin
        t = MulWithRateToBase1(IPrw.RecCurncy,tdp,IPrw.RecVal,DefaultCurRoundOff);
      end;
      Base1ToOther(IPrw.InvCurncy,t,fr,to1,to2,br1,br2,t,DefaultCurRoundOff); 
      IPrw.InvVal = t;
    end;  
  end;
  return;
end;

procedure ChangeIPRecVal(Integer rownr,row IPVc IPrw,Date tdp)
begin
  val fr,to1,to2,br1,br2,t;
  record AccBlock Accb;
  record IVTBlock IVTb;
  
  BlockLoad(IVTb);
  ChangeIPInvVal(IPrw,tdp);
  if (IPrw.BankCurncy==IPrw.InvCurncy) then begin
    IPrw.BankVal = IPrw.InvVal;
  end else begin
    if (IPrw.BankCurncy==IPrw.RecCurncy) then begin
      IPrw.BankVal = IPrw.RecVal;
    end else begin
      if (IPrw.CUPNr==-1) then begin
        CurValToOtherCur(tdp,IPrw.RecCurncy,IPrw.RecVal,IPrw.BankCurncy,t,DefaultCurRoundOff);
        IPrw.BankVal = t;
      end else begin   
        switch (IVTb.IVFromORRate) begin
          case kIVRateFromPrepaymentandInvoice:
            CurValToOtherCur(tdp,IPrw.RecCurncy,IPrw.RecVal,IPrw.BankCurncy,IPrw.BankVal,DefaultCurRoundOff);
          case kIVRateFromPrepayment:
            CurValToOtherCur(tdp,IPrw.RecCurncy,IPrw.RecVal,IPrw.BankCurncy,IPrw.BankVal,DefaultCurRoundOff);
          otherwise
            if (GetORRate(IPrw.OrderNr,fr,to1,to2,br1,br2)) then begin//CUPNr        
              t = MulRateToBase1(IPrw.RecCurncy,IPrw.RecVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);      
            end else begin
              t = MulWithRateToBase1(IPrw.RecCurncy,tdp,IPrw.RecVal,DefaultCurRoundOff);
            end;
            Base1ToOther(IPrw.BankCurncy,t,fr,to1,to2,br1,br2,t,DefaultCurRoundOff); 
            IPrw.BankVal = t;
        end;
      end;  
    end;
  end;
  t = IPrw.RecVal/IPrw.InvOutstand;
  IPrw.TAX1Sum = t*IPrw.TAX1Sum;  
  if (IPrw.TAX1Sum==0) then begin
    IPrw.TAX1Sum = blankval;
  end;
  if (IPrw.InvVal<0) then begin
    if (IPrw.B1BankVal>0) then begin
      IPrw.B1BankVal = -IPrw.B1BankVal;
    end;
    if (IPrw.B2BankVal>0) then begin
      IPrw.B2BankVal = -IPrw.B2BankVal;
    end;
  end;
  if (IPrw.stp==kReceiptRowTypeWriteOff) then begin
    BlockLoad(Accb);  
    if (IPrw.BankVal<0) then begin
      IPrw.WriteOffAcc = Accb.CredAcc;
    end else begin
      IPrw.WriteOffAcc = Accb.WriteOffLossAcc;
    end;
    if (blank(IPrw.WriteOffAcc)) then begin
      IPrw.WriteOffAcc = Accb.CredAcc;
    end;
  end;
  return;
end;

procedure ChangeIPBankCurncy(var record IPVc IPp,string curcode)
begin
  row IPVc IPrw;
  Integer rwcnt,i;
  
  rwcnt = MatRowCnt(IPp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPp,i,IPrw);
    IPrw.BankCurncy= curcode;
    ChangeIPRecVal(i,IPrw,IPp.TransDate);
    MatRowPut(IPp,i,IPrw);
  end;
  return;
end;

global
procedure IPVc_PastePayCurCode(var record IPVc IPp)
begin
  ChangeIPBankCurncy(IPp,IPp.PayCurCode);
  IPSumup(IPp);
  return;
end;

function val IPPrepaysum(var record IPVc IPp,LongInt cupnr,Integer currow)
begin
  Integer i,rwcnt;
  row IPVc IPrw;
  val isp;
  
  isp = blankval;
  rwcnt = MatRowCnt(IPp);
  for (i=0;i<rwcnt;i=i+1) begin
    if (currow!=i) then begin
      MatRowGet(IPp,i,IPrw);
      if (IPrw.ovst==0) then begin
      switch (IPrw.stp) begin
        case 1:
          if (IPrw.CUPNr==cupnr) then begin isp = isp + IPrw.InvVal; end;
        case 5:
          if (IPrw.CUPNr==cupnr) then begin isp = isp + IPrw.InvVal; end;
        case 6:
          if (IPrw.CUPNr==cupnr) then begin isp = isp + IPrw.InvVal; end;
        case 7:
          if (IPrw.CUPNr==cupnr) then begin isp = isp + IPrw.InvVal; end;
      end;
      end;
    end;  
  end;
  IPPrepaysum = isp;
  return;
end;

global
procedure IPUsedPrepaysum(LongInt CUPNr,var val usedvp,var val usedvatp,var val taxusedp)
begin
  record ARPayHistVc ARPayHistr;
  record IVVc IVr;
  row IVVc IVrw;
  Integer i,rwcnt;
  Boolean TrHs;
  
  usedvp = blankval;
  usedvatp = blankval;
  ARPayHistr.CUPNr = CUPNr;
  ARPayHistr.FileName = "IVVc";
  TrHs = true;
  while (LoopMain(ARPayHistr,2,TrHs)) begin  
    if (ARPayHistr.CUPNr!=CUPNr) then begin TrHs = false; end;
    if (ARPayHistr.FileName!="IVVc") then begin TrHs = false; end;
    if (TrHs) then begin
      IVr.SerNr = ARPayHistr.SerNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        rwcnt = MatRowCnt(IVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
            if (IVrw.CUPNr==CUPNr) then begin
              usedvp = usedvp + IVrw.Sum;
              usedvatp = usedvatp + IVrw.Price;
              taxusedp = taxusedp + IVrw.TAX1Reb;
            end;  
          end;
        end;        
      end;  
    end;  
  end;  
  return;
end;

function val OrderTotalPrepaidAmount(LongInt OrderNr,LongInt CUPNr)
begin
  val res;
  record ARPayHistVc ARPayHistr;
  Boolean TrHs,testf;
  
  ARPayHistr.OrderNr = OrderNr;
  TrHs = true;
  while (LoopKey("OrderNr",ARPayHistr,1,TrHs)) begin  
    if (ARPayHistr.OrderNr!=OrderNr) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true; 
      if (ARPayHistr.FileName=="IVVc") then begin testf = false; end;
      if (testf) then begin
        res = res + ARPayHistr.Val;
      end;
    end;  
  end;  
  OrderTotalPrepaidAmount = res;
  return;
end;

function val IPPrepayOrdersum(LongInt OrderNr,LongInt CUPNr)
begin
  val res;
  record ARPayHistVc ARPayHistr;
  Boolean TrHs,testf;
  
  ARPayHistr.OrderNr = OrderNr;
  TrHs = true;
  while (LoopKey("OrderNr",ARPayHistr,1,TrHs)) begin  
    if (ARPayHistr.OrderNr!=OrderNr) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true; 
      if (testf) then begin
        res = res + ARPayHistr.Val;
      end;
    end;  
  end;  
  IPPrepayOrdersum = res;
  return;
end;

procedure PasteORIn2IPr(var record IPVc IPp,row IPVc IPrwp,Integer rownr,Date tdp,val checkamountp)
begin
  record ORVc ORr;
  record CUVc CUr;
  row ORVc ORrw;
  record ARPayVc ARPayr;
  record AccBlock Accb;
  val rv,rebval,t,t1;
  val fr,to1,to2,br1,br2;
  val vatval,vatused,taxused;
  string 2 vatcod,taxtemplatecode;
  record RoundBlock RoundRec;
  string 20 curncycode,thepm,bankcurncy;
  Integer i,rwcnt;
  string 10 invcur,bankcur,reccur;
  val invval,bankval,recval;  
  
  BlockLoad(RoundRec);  
  BlockLoad(Accb);
  if (IPrwp.OrderNr>0) then begin
    ORr.SerNr = IPrwp.OrderNr;
  end else begin
    ORr.SerNr = IPrwp.CUPNr;
  end;
  curncycode = IPrwp.InvCurncy;
  if (ReadFirstMain(ORr,1,true)) then begin
    if (nonblank(ORr.InvoiceToCode)) then begin
      CUr.Code = ORr.InvoiceToCode;
      if (ReadFirstMain(CUr,1,true)) then begin
        IPrwp.CustCode = CUr.Code;
        IPrwp.CustName = CUr.Name;
      end else begin
        IPrwp.CustCode = ORr.CustCode;
        IPrwp.CustName = ORr.Addr0;
      end;
    end else begin
      IPrwp.CustCode = ORr.CustCode;
      IPrwp.CustName = ORr.Addr0;
    end;
    if (Accb.ARUseObj!=0) then begin
      IPrwp.Objects = ORr.Objects;
    end;
    IPrwp.ARAcc = GetCustomerOnAccountAC(IPrwp.CustCode);
    IPrwp.PayDate = tdp;
    curncycode = ORr.CurncyCode;
    fr = ORr.FrRate;
    to1 = ORr.ToRateB1;
    to2 = ORr.ToRateB2;
    br1 = ORr.BaseRate1;
    br2 = ORr.BaseRate2;
    rwcnt = MatRowCnt(ORr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ORr,i,ORrw);
      if (ORrw.Sum!=0) then begin
        if (blank(vatcod)) then begin
          vatcod = ORrw.VATCode;
          taxtemplatecode = ORrw.TaxTemplateCode;
        end else begin
          if (vatcod!=ORrw.VATCode) then begin
            vatcod = "";
            goto L33PasteORIn2IPr;
          end;
          if (taxtemplatecode!=ORrw.TaxTemplateCode) then begin
            vatcod = "";
            goto L33PasteORIn2IPr;
          end;
        end;
      end;
    end;
L33PasteORIn2IPr:;
  end else begin
    BlockLoad(Accb);
    CUr.Code = IPrwp.CustCode;
    if (ReadFirstMain(CUr,1,true)) then begin
      vatcod = CUr.VATCode;
      taxtemplatecode = CUr.TaxTemplateCode;
    end;
    if (blank(vatcod)) then begin
      switch (CUr.ExportFlag) begin
        case 4: vatcod = Accb.VATCodeExp;
        case 3: vatcod = Accb.VATCodeEU;
        case 2: vatcod = Accb.VATCodeExp;
        case 1: vatcod = Accb.VATCodeEU;
        otherwise vatcod = Accb.VATCodeDom;
      end;
    end;
    if (blank(taxtemplatecode)) then begin
      switch (CUr.ExportFlag) begin
        case 4: taxtemplatecode = Accb.TaxTemplateCodeExp;
        case 3: taxtemplatecode = Accb.TaxTemplateCodeEU;
        case 2: taxtemplatecode = Accb.TaxTemplateCodeExp;
        case 1: taxtemplatecode = Accb.TaxTemplateCodeEU;
        otherwise taxtemplatecode = Accb.TaxTemplateCode;
      end;
    end;
    if (Accb.PreIPBookVAT!=0) then begin
      IPrwp.VATCode = vatcod;
      IPrwp.TaxTemplateCode = taxtemplatecode;
    end;
    goto LPasteORIn2IPr;
  end;
  rv = OrderTotalPrepaidAmount(IPrwp.OrderNr,IPrwp.CUPNr);
  if (rv>=ORr.Sum4) then begin
    ARPayr.CUPNr = IPrwp.CUPNr;
    ReadFirstMain(ARPayr,1,true);
    rv = -ARPayr.RVal;
  end else begin  
    rv = ORr.Sum4;
    rv = rv + ORr.Commision;
    rv = rv - IPPrepaysum(IPp,IPrwp.CUPNr,rownr);  
    if (IPrwp.OrderNr>0) then begin
      rv = rv - IPPrepayOrdersum(IPrwp.OrderNr,IPrwp.CUPNr);  
    end else begin
      ARPayr.CUPNr = IPrwp.CUPNr;
      if (ReadFirstMain(ARPayr,1,true)) then begin
        rv = rv - ARPayr.RVal;    
      end;  
    end;
    IPUsedPrepaysum(IPrwp.CUPNr,t,vatused,taxused);
    rv = rv - t;      
  end;
  if (nonblank(IPrwp.PayMode)) then begin
    thepm = IPrwp.PayMode;
  end else begin
    thepm = IPp.PayMode;
  end;
  if (GetPMCurrency(thepm,bankcurncy)) then begin end;
  IPrwp.BankCurncy = bankcurncy;
  IPrwp.RecCurncy = curncycode;
  IPrwp.InvCurncy = curncycode;
  IPrwp.InvVal = rv;
  IPrwp.RecVal = rv;
  GetFullCurncyRate(curncycode,IPp.TransDate,IPrwp.FrRateBankVal,IPrwp.ToRateB1BankVal,IPrwp.ToRateB2BankVal,IPrwp.BaseRate1BankVal,IPrwp.BaseRate2BankVal); 

  if (bankcurncy!=curncycode) then begin
    CurValToOtherCur(IPp.TransDate,curncycode,rv,bankcurncy,t,DefaultCurRoundOff);
    IPrwp.BankVal = t;
   end else begin
    IPrwp.BankVal = rv;
  end;
  invcur = IPrwp.InvCurncy;
  invval = IPrwp.InvVal;
  bankcur = IPrwp.BankCurncy;
  bankval = IPrwp.BankVal;
  reccur = IPrwp.RecCurncy;
  recval = IPrwp.RecVal;  
  MatchIPRowSums(IPp.PayMode,IPrwp.PayMode,IPp.TransDate,invcur,invval,bankcur,bankval,reccur,recval,true,true,true);
  IPrwp.InvCurncy = invcur;
  IPrwp.InvVal = invval;
  IPrwp.BankCurncy = bankcur;
  IPrwp.BankVal = bankval;
  IPrwp.RecCurncy = reccur;
  IPrwp.RecVal = recval;
  IPrwp.InvOutstand = blankval;
  if (Accb.PreIPBookVAT!=0) then begin
    IPrwp.VATCode = vatcod;
    IPrwp.TaxTemplateCode = taxtemplatecode;
  end;
  IPrwp.B1BankVal = blankval;
  if (IPrwp.InvoiceNr<0) then begin
    if (Accb.BasePriceInclVAT==0) then begin
      MulVATIV(IPrwp.VATCode,IPrwp.InvVal,vatval,t1,1,1);
    end else begin
      MulVATIV(IPrwp.VATCode,IPrwp.InvVal,vatval,t1,Accb.BasePriceInclVAT,Accb.NoTAXonVAT);
    end;
    vatval = vatval - ARPayr.VATVal;
  end else begin
    vatval = ORr.Sum3 - ARPayr.VATVal;
  end;
  IPrwp.VATVal = vatval - vatused;
  vatval = ORr.TAX1Sum - ARPayr.TAX1Sum;
  IPrwp.TAX1Sum = vatval - taxused;
LPasteORIn2IPr:;
  return;
end;

global
procedure IPVc_PasteCUPNr(var record IPVc IPp,Integer rownr)
begin
  val t,rs;
  row IPVc IPrw;
  
  MatRowGet(IPp,rownr,IPrw);
  PasteORIn2IPr(IPp,IPrw,rownr,IPp.TransDate,t);
  if (nonblank(IPrw.VATCode)) then begin
    Mul2VAT(IPrw.VATCode,IPrw.InvVal,t,rs,1);
    IPrw.VATVal = t;
  end else begin
    IPrw.VATVal = blankval;
  end;
  MatRowPut(IPp,rownr,IPrw);
  IPSumup(IPp);
  return;
end;

global
procedure IPVc_PasteOrderNr(var record IPVc IPp,Integer rownr)
begin
  val t;
  row IPVc IPrw;
  record ARPayHistVc ARHistr;
  record AccBlock Accb;
  
  MatRowGet(IPp,rownr,IPrw);
  IPrw.CUPNr = IPrw.OrderNr;  
  if (Accb.ForceUniquePP!=0) then begin
    ARHistr.CUPNr = IPrw.CUPNr;
    if (ReadFirstMain(ARHistr,1,true)) then begin
      ARHistr.CUPNr = 3000000000;
      ReadLastKey("MainKey",ARHistr,1,false);
      IPrw.CUPNr = ARHistr.CUPNr + 1;
    end;  
  end;
  PasteORIn2IPr(IPp,IPrw,rownr,IPp.TransDate,t);
  MatRowPut(IPp,rownr,IPrw);
  IPSumup(IPp);
  return;
end;

global
function Boolean CheckMultipleCustomers_IPVc(record IPVc IPp,Integer rownr,var LongInt error)
begin
  row IPVc IPrw;
  row IPVc IPrwFirst;
  Boolean res;

  error = -1;
  if (rownr>0) then begin 
    MatRowGet(IPp,rownr,IPrw);
    MatRowGet(IPp,0,IPrwFirst);
    if (IPrwFirst.CustCode!=IPrw.CustCode) then begin 
      res = true;
      error = 19124;
    end;
  end;
  CheckMultipleCustomers_IPVc = res;
  return;
end;
  
function Boolean PasteCustIn2IPr(var record IPVc IPp,Integer rownr,Date tdp,var LongInt error)
begin
  Boolean res;
  record AccBlock ARAccRec;
  record BaseCurBlock bascur;
  record CUVc CUr;
  row IPVc IPrw;
  val tot;
  string 5 crncy,thepm;

  MatRowGet(IPp,rownr,IPrw);
  if (HasLocalization("PRT")) then begin 
    if (CheckMultipleCustomers_IPVc(IPp,rownr,error)) then begin 
      res = false;
      goto LPasteCustIn2IPr;
    end;
  end;
  if (IPrw.InvoiceNr!=-1) then begin
    goto LPasteCustIn2IPr;
  end;
  BlockLoad(ARAccRec);
  CUr.Code = IPrw.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    crncy = CUr.CurncyCode; 
    if (blank(crncy)) then begin
      BlockLoad(bascur);
      crncy = bascur.StdBaseCur;
    end;     
    if (IPrw.InvoiceNr<0) then begin
      IPrw.ARAcc = GetCustomerOnAccountAC(CUr.Code);
    end;    
    IPrw.CustCode = CUr.Code;
    IPrw.CustName = CUr.Name;
    IPrw.PayDate = tdp;
    IPrw.InvVal = tot;    
    IPrw.InvCurncy = crncy;
    IPrw.BankVal = tot;
    IPrw.BankCurncy = crncy;
    IPrw.RecVal = tot;
    IPrw.RecCurncy = crncy;
    if (nonblank(IPrw.PayMode)) then begin
      thepm = IPrw.PayMode;
    end else begin
      thepm = IPp.PayMode;
    end;    
    if (GetPMCurrency(thepm,crncy)) then begin end;    
    if (nonblank(crncy)) then begin
      IPrw.BankCurncy = crncy;
    end;
    if (ARAccRec.ARUseObj!=0) then begin
      IPrw.Objects = CUr.Objects;
    end;
    MatRowPut(IPp,rownr,IPrw);
    IPSumup(IPp);
    res = true;
  end else begin
    res = false;
  end;
LPasteCustIn2IPr:;  
  PasteCustIn2IPr = res;
  return;
end;

global
function Boolean IPVc_PasteCustCode(var record IPVc IPp,Integer rownr,var LongInt error)
begin
  Boolean res;
  
  res = PasteCustIn2IPr(IPp,rownr,IPp.TransDate,error);
  IPVc_PasteCustCode = res;
  return;
end;

procedure IPChangePayDate(record IPVc IPp,row IPVc iprp,Integer rownr,Date tdp)
begin
  record ARVc ARr;
  record IVVc IVr;
  string 20 pmod,curncy,bankcurncy;
  val tv,rv,rebval,t;
  LongInt rebdays;
  record RoundBlock RoundRec;
  row IPVc locIPrw;
  Boolean bankvalcf;
  string 10 invcur,bankcur,reccur;
  val invval,bankval,recval;  

  BlockLoad(RoundRec);
  IPInvsum(IPp,iprp.InvoiceNr,iprp.InvCurncy,tv);
  tv = tv - iprp.InvVal; 
  pmod = IPp.PayMode;
  IVr.SerNr = iprp.InvoiceNr;
  if (ReadFirstMain(IVr,1,true)) then begin
    if (IVr.Invalid!=0) then begin goto LIPChangePayDate; end;
  end else begin
    goto LIPChangePayDate;
  end;
  curncy = IVr.CurncyCode;
  if (GetPMCurrency(pmod,bankcurncy)) then begin end;
  ARr.InvoiceNr = iprp.InvoiceNr;
  if (ReadFirstMain(ARr,1,true)) then begin
    rv = ARr.RVal - tv;
  end;
  if (iprp.InvVal!=rv) then begin goto LIPChangePayDate; end;
  if (IVr.pdvrebt!=0) then begin
    rebdays = DateDiff(ARr.ARRebDate,tdp);
    if (rebdays>=0) then begin
      rebval = iprp.InvVal*IVr.pdvrebt;    
      rebval = rebval/100;
      rebval = Round(rebval,GetTotalRoundMode(RoundRec));
      rv = iprp.InvVal - rebval;      
      iprp.InvVal = rv;
      bankvalcf = true;      
    end;
  end;
  if (IVr.pdvrebt2!=0) then begin
    rebdays = DateDiff(ARr.ARRebDate2,tdp);
    if (rebdays>=0) then begin
      rebval = iprp.InvVal*IVr.pdvrebt2;    
      rebval = rebval/100;
      rebval = Round(rebval,GetTotalRoundMode(RoundRec));
      rv = iprp.InvVal - rebval;      
      iprp.InvVal = rv;
      bankvalcf = true;      
    end;
  end;
  iprp.InvVal = rv;
  iprp.RecVal = rv;
  if (bankcurncy!=curncy) then begin
    CurValToOtherCur(IPp.TransDate,curncy,rv,bankcurncy,t,DefaultCurRoundOff);
    iprp.BankVal = t;
   end else begin
    iprp.BankVal = rv;
  end;
  invcur = iprp.InvCurncy;
  invval = iprp.InvVal;
  bankcur = iprp.BankCurncy;
  bankval = iprp.BankVal;
  reccur = iprp.RecCurncy;
  recval = iprp.RecVal;  
  MatchIPRowSums(IPp.PayMode,iprp.PayMode,IPp.TransDate,invcur,invval,bankcur,bankval,reccur,recval,false,false,true);
  iprp.InvCurncy = invcur;
  iprp.InvVal = invval;
  iprp.BankCurncy = bankcur;
  iprp.BankVal = bankval;
  iprp.RecCurncy = reccur;
  iprp.RecVal = recval;
  MatRowPut(IPp,rownr,iprp);  
  if (rebval!=0) then begin
    ClearRow(IPp,locIPrw,5);
    locIPrw.InvoiceNr = iprp.InvoiceNr;
    locIPrw.BankCurncy = bankcurncy;
    locIPrw.RecCurncy = curncy;
    locIPrw.InvCurncy = curncy;
    locIPrw.InvVal = rebval;
    locIPrw.RecVal = rebval;
    if (bankcurncy!=curncy) then begin
      CurValToOtherCur(IPp.TransDate,curncy,rebval,bankcurncy,t,DefaultCurRoundOff);
      iprp.BankVal = t;
     end else begin
      iprp.BankVal = rebval;
    end;    
    if (GetPMCurrency(IPp.PayMode,bankcurncy)) then begin end;
    locIPrw.BankCurncy = bankcurncy;
    locIPrw.RecCurncy = curncy;
    locIPrw.InvCurncy = curncy;
    
    invcur = locIPrw.InvCurncy;
    invval = locIPrw.InvVal;
    bankcur = locIPrw.BankCurncy;
    bankval = locIPrw.BankVal;
    reccur = locIPrw.RecCurncy;
    recval = locIPrw.RecVal;  
    MatchIPRowSums(IPp.PayMode,pmod,IPp.TransDate,locIPrw.InvCurncy,locIPrw.InvVal,locIPrw.BankCurncy,locIPrw.BankVal,locIPrw.RecCurncy,locIPrw.RecVal,true,true,true);
    locIPrw.InvCurncy = invcur;
    locIPrw.InvVal = invval;
    locIPrw.BankCurncy = bankcur;
    locIPrw.BankVal = bankval;
    locIPrw.RecCurncy = reccur;
    locIPrw.RecVal = recval;    
    locIPrw.CustCode = IVr.CustCode;
    locIPrw.CustName = IVr.Addr0;
    MatRowInsert(IPp,rownr+1,locIPrw);
  end;
LIPChangePayDate:;
  return;
end;

global
procedure IPVc_PastePayDate(var record IPVc IPp,Integer rownr)
begin
  Boolean testf;
  row IPVc IPrw;
  row IPVc IP2rw;
  Integer rwcnt;
  
  rwcnt = MatRowCnt(IPp);
  MatRowGet(IPp,rownr,IPrw);            
  if (rownr<(rwcnt-1)) then begin
    MatRowGet(IPp,rownr+1,IP2rw);            
    if (IP2rw.stp!=5) then begin testf = true; end;
  end;
  if (rownr==rwcnt-1) then begin testf = true; end;
  if (testf) then begin
    IPChangePayDate(IPp,IPrw,rownr,IPrw.PayDate);
  end;
  IPSumup(IPp);
  return;
end;

procedure ChangeIPRecCur(row IPVc iprp,Date tdp)
begin
  val t;
  
  ChangeSVIPRecCur(iprp,tdp,t);
  if (iprp.InvoiceNr==-1) then begin
    iprp.InvVal = iprp.RecVal;
    iprp.InvCurncy = iprp.BankCurncy;
  end;  
  return;
end;

global
procedure IPVc_PasteRecCurncy(var record IPVc IPp,Integer rownr)
begin
  row IPVc IPrw;
  
  MatRowGet(IPp,rownr,IPrw);            
  ChangeIPRecCur(IPrw,IPp.TransDate);
  MatRowPut(IPp,rownr,IPrw);
  if (nonblank(IPrw.VATCode)) then begin
    IPVc_PasteVATCode(IPp,rownr);
  end;
  IPSumup(IPp);
  return;
end;

global
procedure IPVc_PasteRecVal(var record IPVc IPp,Integer rownr)
begin
  row IPVc IPrw;
  val rs,t,t1,v;
  record AccBlock Accb;
  record IVVc IVr;
  record TaxMatrixVc TMr;
  
  MatRowGet(IPp,rownr,IPrw);  
  ChangeIPRecVal(rownr,IPrw,IPp.TransDate);
  if (nonblank(IPrw.VATCode)) then begin
    if (IPrw.InvoiceNr<0) then begin
      BlockLoad(Accb);  
      if (Accb.BasePriceInclVAT==0) then begin
        MulVATIV(IPrw.VATCode,IPrw.InvVal,t,t1,1,1);
      end else begin
        MulVATIV(IPrw.VATCode,IPrw.InvVal,t,t1,Accb.BasePriceInclVAT,Accb.NoTAXonVAT);
      end;
      IPrw.VATVal = Round(t,SetRoundModeD(2));
      IPrw.TAX1Sum = Round(t1,SetRoundModeD(2));
      if (IPrw.VATVal==0) then begin
        IPrw.VATVal = blankval;
      end;
      if (IPrw.TAX1Sum==0) then begin
        IPrw.TAX1Sum = blankval;
      end;
    end else begin
      MulVATIV(IPrw.VATCode,IPrw.InvVal,IPrw.VATVal,t1,1,0);
/*
the code below can NOT be correct, 
do many vat rates on same invoice and many recipts!

      IVr.SerNr = IPrw.InvoiceNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        v = IVr.Sum4;
        if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          v = -v;
        end;
        if (v==IPrw.InvVal) then begin
          IPrw.VATVal = IVr.Sum3;
          if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
            IPrw.VATVal = -IVr.Sum3;
          end;
        end else begin
          IPrw.VATVal = IPrw.InvVal*IVr.Sum3;
          IPrw.VATVal = IPrw.VATVal/IVr.Sum4;
        end;
      end else begin
        Mul2VAT(IPrw.VATCode,IPrw.InvVal,t,rs,1);
        IPrw.VATVal = t;
      end;
*/      
    end;
  end;
  MatRowPut(IPp,rownr,IPrw);
  if (nonblank(IPrw.TaxTemplateCode)) then begin
    if (IPrw.InvoiceNr<0) then begin
    end else begin
      IVr.SerNr = IPrw.InvoiceNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        MatRowGet(IPp,rownr,IPrw);
        RowCalculateTaxMatrix_IPVc(IPp,rownr,IPrw,1);
        MatRowPut(IPp,rownr,IPrw);
        MatRowGet(IPp,rownr,IPrw);
        UnpackRowFieldMatrix(IPrw,"TaxMatrix",TMr);
        IPrw.VATVal = TaxMatrixVATTotal(TMr);
        MatRowPut(IPp,rownr,IPrw);
      end;
    end;
  end else begin
    if (blank(IPrw.VATCode)) then begin //if prepayment why to blank out ? 
      MatRowGet(IPp,rownr,IPrw);
      IPrw.VATVal = blankval;
      IPrw.TAX1Sum = blankval;
      MatRowPut(IPp,rownr,IPrw);
   end;
  end;
  IPVc_PasteToRateB1BankVal(IPp,rownr);  
  IPSumup(IPp);
  return;
end;

global
procedure IPVc_PasteBankVal(var record IPVc IPp,Integer rownr)
begin
  row IPVc IPrw;
  val rs,t;
  
  MatRowGet(IPp,rownr,IPrw);  
  if (IPrw.BankCurncy==IPrw.RecCurncy) then begin
    ChangeIPRecVal(rownr,IPrw,IPp.TransDate);
    if (nonblank(IPrw.VATCode)) then begin
      Mul2VAT(IPrw.VATCode,IPrw.InvVal,t,rs,1);
      IPrw.VATVal = t;
    end else begin
      IPrw.VATVal = blankval;
    end;
    MatRowPut(IPp,rownr,IPrw);
  end else begin
    if (blank(IPrw.FrRateBankVal)) and (blank(IPrw.ToRateB1BankVal)) then begin    
      IPrw.B1BankVal = blankval;
    end;
    if (blank(IPrw.FrRateBankVal)) and (blank(IPrw.ToRateB2BankVal)) then begin    
      IPrw.B2BankVal = blankval;
    end;
    MatRowPut(IPp,rownr,IPrw);
  end;
  IPSumup(IPp);
  return;
end;

function val FindCheckAmount(var record IPVc IPp,Integer rownr,record CheckVc Checkr)
begin
  val res,t,v;
  row IPVc IPrw;
  Integer i;
  
  res = Checkr.Amount;  
  for (i=0;i<rownr;i=i+1) begin
    MatRowGet(IPp,i,IPrw);
    if (IPrw.ChequeNr==Checkr.SerNr) then begin
      CurValToOtherCur(IPp.TransDate,IPrw.RecCurncy,IPrw.RecVal,Checkr.CurncyCode,t,DefaultCurRoundOff);
      v = v + t;
    end;
  end;
  res = res - v;  
  FindCheckAmount = res;
  return;
end;

function Boolean PasteCheckInIP(var record IPVc IPp,Integer rownr,row IPVc iprp,LongInt checknr)
begin
  Boolean res,installmentf;
  row IPVc IPrw;
  row IPVc IP2rw;
  row IPVc IP3rw;
  record CheckVc Checkr;
  record CouponVc Couponr;
  val temp,checkamount,recamount,t;
  Integer i,j,cht,row1,newrownr;
  string 2 thepm;
  string 255 tstr,bankcur;
  Integer n;
  Boolean rowfound;
  Integer rwcnt;
  LongInt error;
  
  if (nonblank(iprp.PayMode)) then begin
    thepm = iprp.PayMode;
  end else begin
    thepm = IPp.PayMode;
  end;
  MatRowGet(IPp,rownr,IPrw);
  if (nonblank(IPrw.PayMode)) then begin
    cht = PMCheckType(IPrw.PayMode,tstr,tstr);
  end else begin
    cht = PMCheckType(IPp.PayMode,tstr,tstr);
  end;
  if (cht==kPayModeTypeCheque) then begin
    Checkr.SerNr = checknr;
    if (ReadFirstMain(Checkr,1,true)) then begin
      if (true) then begin//strpeq(iprp.RecCurncy,Checkr.CurncyCode)==false
        checkamount = FindCheckAmount(IPp,rownr,Checkr);
        if (GetPMCurrency(thepm,bankcur)) then begin end;
        iprp.BankCurncy = bankcur;
        IPrw.RecCurncy = Checkr.CurncyCode;
        CurValToOtherCurWithRate(IPp.TransDate,Checkr.CurncyCode,checkamount,iprp.RecCurncy,iprp.ToRateB1BankVal,recamount,DefaultCurRoundOff);
        if (recamount>iprp.RecVal) and (iprp.RecVal<>0) then begin
          CurValToOtherCur(IPp.TransDate,iprp.RecCurncy,iprp.RecVal,Checkr.CurncyCode,t,DefaultCurRoundOff);
          IPrw.RecVal = t;
        end else begin
          IPrw.RecVal = checkamount;
        end;
        iprp.RecVal = IPrw.RecVal;
        iprp.RecCurncy = Checkr.CurncyCode;
        MatRowPut(IPp,rownr,iprp);        
        IPVc_PasteRecVal(IPp,rownr);
        MatRowGet(IPp,rownr,iprp);        
      end;
      if (true) then begin
        CurValToOtherCur(IPp.TransDate,Checkr.CurncyCode,checkamount,iprp.RecCurncy,recamount,DefaultCurRoundOff);
        if (checkamount<0) then begin checkamount = blankval; end;
        if (recamount<0) then begin recamount = blankval; end;
            
        if (iprp.RecVal<recamount) then begin
          checkamount = FindCheckAmount(IPp,rownr,Checkr);

          CurValToOtherCur(IPp.TransDate,iprp.RecCurncy,iprp.RecVal,Checkr.CurncyCode,recamount,DefaultCurRoundOff);
          checkamount = checkamount - recamount;

          rowfound = false; 
          rwcnt = MatRowCnt(IPp);
          for (i=rownr+1;i<rwcnt;i=i+1) begin
            MatRowGet(IPp,i,IP2rw);
            if ((IP2rw.stp==1) and (IP2rw.ChequeNr==-1) and (iprp.CustCode==IP2rw.CustCode)) then begin
              IP2rw.ChequeNr = iprp.ChequeNr;

              IP2rw.BankCurncy = bankcur;
              IP2rw.RecCurncy = Checkr.CurncyCode;
              CurValToOtherCurWithRate(IPp.TransDate,Checkr.CurncyCode,checkamount,IP2rw.RecCurncy,IP2rw.ToRateB1BankVal,recamount,DefaultCurRoundOff);
              if (recamount>IP2rw.RecVal) and (IP2rw.RecVal<>0) then begin
                CurValToOtherCur(IPp.TransDate,IP2rw.RecCurncy,IP2rw.RecVal,Checkr.CurncyCode,t,DefaultCurRoundOff);
                IP2rw.RecVal = t;
              end else begin
                IP2rw.RecVal = checkamount;
              end;
              MatRowPut(IPp,i,IP2rw);
              IPVc_PasteRecVal(IPp,i);

              CurValToOtherCur(IPp.TransDate,IP2rw.RecCurncy,IP2rw.RecVal,Checkr.CurncyCode,recamount,DefaultCurRoundOff);
              checkamount = checkamount - recamount;
              rowfound = true; 
            end;
          end;  
          temp = checkamount;      
          if (rowfound==false) then begin            
            ClearRow(IPp,IP2rw,1);
            IP2rw.CustCode = IPrw.CustCode;
            MatRowInsert(IPp,rownr+1,IP2rw);
            if (PasteCustIn2IPr(IPp,rownr+1,IPp.TransDate,error)) then begin end;
            MatRowGet(IPp,rownr+1,IP2rw);
            IP2rw.ChequeNr = IPrw.ChequeNr;
            IP2rw.PayMode = IPrw.PayMode;
            IP2rw.BankCurncy = Checkr.CurncyCode;
            IP2rw.RecCurncy = Checkr.CurncyCode;
            IP2rw.InvCurncy = Checkr.CurncyCode;
            IP2rw.BankVal = temp;
            IP2rw.InvVal = temp;
            IP2rw.RecVal = temp;
            MatRowPut(IPp,rownr+1,IP2rw);
          end;

        end else begin        
          temp = iprp.RecVal;
          for (i=0;i<=rownr;i=i+1) begin
            MatRowGet(IPp,i,IPrw);
            if (IPrw.ChequeNr==iprp.ChequeNr) then begin
              if (iprp.RecCurncy==Checkr.CurncyCode) then begin
                temp = temp - IPrw.RecVal;
              end;
            end;
          end;          
          if (temp>0) then begin
            ClearRow(IPp,IPrw,1);
            temp = iprp.RecVal;
            MatRowInsert(IPp,rownr + 1,IPrw);
            if (PasteInvIn2IPr(IPp,rownr + 1,IPp.TransDate,temp,false,installmentf)) then begin end;
          end;
        end;
      end else begin
        MessageBox(1217,"");
      end;
      res = true;
    end else begin
      res = false;
    end;
  end;
  if ((cht==kPayModeTypeCreditCard) or (cht==kPayModeTypeDebitCard)) then begin
    Couponr.SerNr = checknr;
    if (ReadFirstMain(Couponr,1,true)) then begin
      checkamount = Couponr.Amount;
      for (i=0;i<rownr;i=i+1) begin
        MatRowGet(IPp,i,IPrw);
        if (IPrw.ChequeNr==checknr) then begin
          checkamount = checkamount - IPrw.BankVal;
        end;
      end;
      if (checkamount<0) then begin checkamount = blankval; end;
      if (iprp.BankVal!=checkamount) then begin
        if (iprp.BankVal>checkamount) then begin
          temp = iprp.BankVal - checkamount;        
          iprp.BankVal = checkamount;
          iprp.RecVal = checkamount;
          iprp.InvVal = checkamount;
          if (iprp.BankCurncy!=iprp.RecCurncy) then begin
          end;
          MatRowPut(IPp,rownr,iprp);
          if (iprp.BankCurncy!=iprp.RecCurncy) then begin
            ChangeIPRecVal(rownr,iprp,IPp.TransDate);
            MatRowPut(IPp,rownr,iprp);
          end;
          if (temp!=0) then begin
            if (rownr<99) then begin
              ClearRow(IPp,IPrw,1);
              CopyRow(IPp,iprp,IPrw);
              if (temp>0) then begin
                IPrw.ChequeNr = -1;
                MatRowInsert(IPp,rownr + 1,IPrw);
                if (PasteInvIn2IPr(IPp,rownr + 1,IPp.TransDate,temp,false,installmentf)) then begin end;            
              end else begin
              end;
            end;
          end;
        end else begin
          temp = checkamount - iprp.BankVal;        
          if (temp!=0) then begin
            if (rownr<199) then begin
              ClearRow(IPp,IPrw,1);
              CopyRow(IPp,iprp,IPrw);
              if (temp>0) then begin
                IPrw.InvoiceNr = -1;
                IPrw.ARAcc = GetCustomerOnAccountAC(IPrw.CustCode);
                IPrw.RecVal = temp;
                MatRowInsert(IPp,rownr + 1,IPrw);
                MatRowGet(IPp,rownr+1,iprp);
                ChangeIPRecVal(rownr+1,iprp,IPp.TransDate);
                MatRowPut(IPp,rownr+1,iprp);
              end;
            end;
          end;
        end;
      end;
      res = true;
    end else begin
      res = false;
    end;
  end;
  PasteCheckInIP = res;
  return;
end;

global
function Boolean IPVc_PasteChequeNr(var record IPVc IPp,Integer rownr)
begin
  Boolean res;
  row IPVc IPrw;
  
  MatRowGet(IPp,rownr,IPrw);  
  if (IPrw.ChequeNr!=-1) then begin
    res = PasteCheckInIP(IPp,rownr,IPrw,IPrw.ChequeNr);  
    IPSumup(IPp);
  end;
  IPVc_PasteChequeNr = res;
  return;
end;

function Boolean FindChequenr(string cucode,var val chval,var LongInt lastchnr)
begin
  Boolean res;
  record CheckVc Checkr;
  Boolean found;
  
  chval = blankval;
  found = true;
  Checkr.Openf = 0;
  Checkr.CUCode = cucode;
  Checkr.SerNr = lastchnr + 1;
  while (LoopKey("RegCUCode",Checkr,3,found)) begin
    if (Checkr.Openf!=0) then begin found = false; end;
    if (Checkr.CUCode!=cucode) then begin found = false; end;
    if (found) then begin
      lastchnr = Checkr.SerNr;
      chval = Checkr.Amount;
      found = false;
      res = true;
    end;
  end;
  FindChequenr = res;
  return;
end;

function val ThisCheuqeAmount(record IPVc IPp,Integer rwcnt,LongInt lastchnr)
begin
  val res;
  row IPVc IPrw;
  Integer i;
  
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPp,i,IPrw);
    if (IPrw.ChequeNr==lastchnr) then begin
      res = res + IPrw.RecVal;
    end;
  end;
  ThisCheuqeAmount = res;
  return;
end;

global
procedure DoDistributeChequesIP(var record IPVc IPp,Integer currow,var string gotofieldname,var Integer gotorownr)
begin
  row IPVc IPrw;
  row IPVc newIPrw;
  row IPVc curIPrw;
  row IPVc nextIPrw;
  Integer i,rwcnt;
  LongInt lastchnr;
  val chval;

  if (currow>=0) then begin
    MatRowGet(IPp,currow,curIPrw);
    rwcnt = MatRowCnt(IPp);
    for (i=currow;i<rwcnt;i=i+1) begin
      MatRowGet(IPp,i,IPrw);
      if (IPrw.ChequeNr<0) and (IPrw.CustCode==curIPrw.CustCode) then begin
        if (FindChequenr(IPrw.CustCode,chval,lastchnr)) then begin
          chval = chval - ThisCheuqeAmount(IPp,i,lastchnr);
          IPrw.ChequeNr = lastchnr;
          if (chval==IPrw.RecVal) then begin
            MatRowPut(IPp,i,IPrw);
          end;
          if (chval>IPrw.RecVal) then begin
            MatRowPut(IPp,i,IPrw);                                    
            ClearRow(IPp,newIPrw,1);
            CopyRow(IPp,IPrw,newIPrw);
            newIPrw.InstNr = -1;
            newIPrw.RecVal = chval - newIPrw.RecVal;
            ChangeIPRecVal(i+1,newIPrw,IPp.TransDate);  
            if (newIPrw.RecVal>0) then begin  
              nextIPrw.CustCode = "";
              if ((i+1)<rwcnt) then begin
                MatRowGet(IPp,i+1,nextIPrw); 
              end;                                   
              if (nextIPrw.CustCode!=newIPrw.CustCode) then begin
                newIPrw.InvoiceNr = -1;
                newIPrw.PayMode = "";
                MatRowInsert(IPp,i+1,newIPrw);
                rwcnt = MatRowCnt(IPp);
              end else begin
                lastchnr = lastchnr - 1;
              end;
            end;
            gotofieldname = "InvoiceNr";
            gotorownr = i + 1;
          end;
          if (chval<IPrw.RecVal) then begin
            ClearRow(IPp,newIPrw,1);
            CopyRow(IPp,IPrw,newIPrw);
            IPrw.RecVal = chval;
            ChangeIPRecVal(i,IPrw,IPp.TransDate);          
            MatRowPut(IPp,i,IPrw);
            newIPrw.ChequeNr = -1;          
            newIPrw.RecVal = newIPrw.RecVal - chval;
            ChangeIPRecVal(i+1,newIPrw,IPp.TransDate);    
            MatRowInsert(IPp,i+1,newIPrw);
            rwcnt = MatRowCnt(IPp);
            gotofieldname = "ChequeNr";
            gotorownr = i + 1;
          end;
        end;
      end;
    end;
    IPSumup(IPp);
  end;
  return;
end;

global
updating function Boolean CreateActFromIP(record IPVc IPr,Integer rownr,var record ActVc Actr)
begin
  Boolean res;
  row IPVc IPrw;
  record CUVc CUr;
  Integer curcomp;
  record ASTBlock ASTb;

  if (rownr>=0) then begin
    BlockLoad(ASTb);
    MatRowGet(IPr,rownr,IPrw);
    curcomp = CurrentCompany;
    Actr.MainPersons = CurrentUser;

    Actr.TransDate = IPr.TransDate;
    Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
    Actr.Invalid = 0;
    Actr.TodoFlag = 1;
    Actr.CUCode = IPrw.CustCode;
    Actr.Comment = IPrw.Comment;
    CUr.Code = IPrw.CustCode;
    if (ReadFirstMain(CUr,1,true)) then begin
      Actr.CUName = CUr.Name;
      Actr.Phone = CUr.Phone;
      if (blank(Actr.Contact)) then begin 
        Actr.Contact = ActContactFromIP(IPrw.InvoiceNr,IPrw.OrderNr,IPrw.CustCode); 
      end;
    end;
    Actr.ActType = ASTb.Receipts;
    if (PasteActTypeInAct("",Actr)) then begin
    end;
    SetActTypeValues(Actr);
    Actr.OKFlag = ASTb.ReceiptsDone;
    if (RecordInsert(Actr,false)) then begin
      CreateRecordLink(Actr,curcomp,IPr,curcomp);  
      CreateRecordLink(IPr,curcomp,Actr,curcomp);  
      res = true;
    end;
  end;
  CreateActFromIP = res;
  return;
end;

global
procedure IPPastePayMode2(var record IPVc IPp,string prevpaymode)
begin
  Integer i,rwcnt,rn;
  record PMBlock PMRec;
  row PMBlock pmrw;
  record MainCLBlock MainCLRec;
  string 255 objectstoremove,objectstoadd,pmcode;
  row IPVc IPrw;

  if (IPp.PayMode!=prevpaymode) then begin 
    if (blank(prevpaymode)) then begin 
      objectstoremove = GetPayModeObjectsStr(IPp.PayMode);
    end else begin 
      objectstoremove = GetPayModeObjectsStr(prevpaymode);
    end;
  end;
  BlockLoad(MainCLRec);
  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  rn = 0;
  if (blank(IPp.PayMode)) then begin goto L88IPPastePayMode; end;
  for (i = 0; i<rwcnt; i=i+1) begin
    MatRowGet(PMRec,i,pmrw);
    if (pmrw.Code==IPp.PayMode) then begin
      if (MainCLRec.CommonNoSer!=0) then begin
        if (pmrw.TSerStartIn!=-1) then begin
          IPp.SerNr = NextFreeCashSerNr(pmrw,true);
        end else begin
          IPp.SerNr = -1;
          if (SingleUserMode) then begin
            IPp.SerNr = NextSerNr("IPVc",IPp.TransDate,-1,false,"");
          end;
        end;
      end;
      rn = i;
      goto L88IPPastePayMode;
    end;
  end;

L88IPPastePayMode:;
  if (rwcnt>0) then begin
    MatRowGet(PMRec,rn,pmrw);      
    IPp.PayMode = pmrw.Code;
    IPp.Comment = pmrw.Comment;
    IPp.Objects = pmrw.Objects;
    rwcnt = MatRowCnt(IPp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IPp,i,IPrw);
      pmcode = IPrw.PayMode;
      if (blank(pmcode)) then begin
        objectstoadd = GetPayModeObjectsStr(IPp.PayMode);
        IPrw.Objects = UpdatedeRowObject(objectstoremove,objectstoadd,IPrw.Objects);      
        MatRowPut(IPp,i,IPrw);
        pmcode = IPp.PayMode;
      end;
    end;    
    if (pmrw.TSerStartIn!=-1) and (MainCLRec.CommonNoSer!=0) then begin
      IPp.SerNr = NextFreeCashSerNr(pmrw,true);
    end;
  end;
LIPPastePayMode:;
  return;
end;

global
procedure IPPastePayMode(var record IPVc IPp)
begin
  IPPastePayMode2(IPp,"");
  return;
end;

global
procedure IPPasteRowPayMode3(var row IPVc IPrwp,string headerpaymentcode,string prevpaymode)
begin
  Integer i,rwcnt,rn;
  record PMBlock PMRec;
  row PMBlock pmrw;
  string 255 objectstoremove,objectstoadd;

  BlockLoad(PMRec);
  rwcnt = MatRowCnt(PMRec);
  rn = 0;
  if (blank(IPrwp.PayMode)) then begin goto L88IPPasteRowPayMode; end;
  for (i = 0; i<rwcnt; i=i+1) begin
    MatRowGet(PMRec,i,pmrw);
    if (pmrw.Code==IPrwp.PayMode) then begin
      rn = i;
      goto L88IPPasteRowPayMode;
    end;
  end;
L88IPPasteRowPayMode:;
  if (rwcnt>0) then begin
    if (nonblank(pmrw.Objects) or blank(IPrwp.PayMode) or (IPrwp.PayMode!=prevpaymode)) then begin
      if (IPrwp.PayMode!=prevpaymode) then begin 
        if (blank(prevpaymode)) then begin 
          objectstoremove = GetPayModeObjectsStr(headerpaymentcode);
        end else begin 
          objectstoremove = GetPayModeObjectsStr(prevpaymode);
        end;
      end; 
      if (blank(IPrwp.PayMode)) then begin 
        objectstoadd = GetPayModeObjectsStr(headerpaymentcode);
      end else begin
        objectstoadd = pmrw.Objects;
      end; 
      IPrwp.Objects = UpdatedeRowObject(objectstoremove,objectstoadd,IPrwp.Objects);    
    end;
  end;
  return;
end;

global
procedure IPPasteRowPayMode2(var row IPVc IPrwp,string headerpaymentcode)
begin
  IPPasteRowPayMode3(IPrwp,headerpaymentcode,"");
end;

global
procedure IPPasteRowPayMode(var row IPVc IPrwp)
begin
  IPPasteRowPayMode3(IPrwp,"","");
end;

global
updating function Integer CreateMailFromIPD(record IPVc IPr,var record MailVc Mailr,var string warning,string custcode,string pdfform)
begin
  Integer res;
  record LTxtVc LTxtr;
  record CUVc CUr;
  record CUVc ContactCUr;
  row IPVc IPrw;
  row MailVc MArw;
  Integer i,rwcnt;
  string 255 mailboxnr,tstr;
  string 255 docname,fname;
  
  res = 0;
  if (ReadFirstMain(IPr,0,true)) then begin end;  
  FindUserMailboxName(CurrentUser,mailboxnr,tstr);
  if (blank(tstr)) then begin
    res = 2289;
    warning = CurrentUser;
    goto LCreateMailFromIPD;
  end;  
  MArw.RowTyp = 1;
  MArw.AddrCode = tstr;
  MatRowPut(Mailr,0,MArw);
  CUr.Code = custcode;
  if (ReadFirstMain(CUr,1,true)) then begin end;
  MArw.RowTyp = 0;
  MArw.AddrCode = CUr.eMail;
  if (blank(MArw.AddrCode)) then begin
    res = 2289;
    warning = CUr.Code;
    goto LCreateMailFromIPD;
  end;
  MatRowPut(Mailr,1,MArw);
  Mailr.Header = Mailr.Header & USetStr(1818) & " ";
  Mailr.Header = Mailr.Header & IPr.SerNr;  
  Mailr.TransDate = CurrentDate;
  Mailr.SerNr = NextSerNr("MailVc",Mailr.TransDate,-1,false,"");
  if (RecordStore(Mailr,false)) then begin 
    CreateRecordLink(Mailr,CurrentCompany,IPr,CurrentCompany);  
    CreateRecordLink(IPr,CurrentCompany,Mailr,CurrentCompany);  
  end;

  docname = pdfform;
  if (blank(docname)) then begin
    docname = "IPDForm";
  end;
  fname = "tmp/" & USetStr(1818) & " " & IPr.SerNr & ".pdf";
  SetDocumentFilename(fname);
  SetMedia(mtPdf);
  PrintDocument(IPr,docname,false);
  if (FileExists(fname)) then begin
    RecordLinkFile(fname,0,Mailr,CurrentCompany);
  end;
  SetDocumentFilename("");
  Delete_File(fname);

LCreateMailFromIPD:;  
  CreateMailFromIPD = res;
  return;
end;

global
function Boolean IPVc_PasteToRateB1BankVal(var record IPVc IPp,Integer rownr)
begin
  Boolean res;
  row IPVc IPrw;
  record BaseCurBlock BCb;
  val fr,to1,to2,br1,br2;

  BlockLoad(BCb);  
  MatRowGet(IPp,rownr,IPrw);
  if (true) then begin
    if (IPrw.BankCurncy!=BCb.BaseCur1) then begin
      if (HasLocalization("POL") or nonblank(IPrw.B1BankVal) or nonblank(IPrw.FrRateBankVal) or nonblank(IPrw.ToRateB1BankVal) or nonblank(IPrw.ToRateB2BankVal) or nonblank(IPrw.BaseRate1BankVal) or nonblank(IPrw.BaseRate2BankVal)) then begin
        GetFullCurncyRate(IPrw.BankCurncy,IPp.TransDate,fr,to1,to2,br1,br2);
        if (blank(IPrw.FrRateBankVal)==false) then begin fr = IPrw.FrRateBankVal; end;
        if (blank(IPrw.ToRateB1BankVal)==false) then begin to1 = IPrw.ToRateB1BankVal; end;
        if (blank(IPrw.ToRateB2BankVal)==false) then begin to2 = IPrw.ToRateB2BankVal; end;
        if (blank(IPrw.BaseRate1BankVal)==false) then begin br1 = IPrw.BaseRate1BankVal; end;
        if (blank(IPrw.BaseRate2BankVal)==false) then begin br2 = IPrw.BaseRate2BankVal; end;      
//      IPrw.B1BankVal = IPrw.ToRateB1BankVal*IPrw.BankVal;//must be very wrong
//      IPrw.B1BankVal = Round(IPrw.B1BankVal,DefaultRoundMode);
        if (blank(fr)) and ((nonblank(to1)) or (nonblank(to2))) then begin fr = 1; end;
        IPrw.B1BankVal = MulRateToBase1(IPrw.BankCurncy,IPrw.BankVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);
        if (IPrw.B1BankVal==0) then begin IPrw.B1BankVal = blankval; end;
        MatRowPut(IPp,rownr,IPrw);
      end;
      res = true;
    end else begin
      GetFullCurncyRate(IPrw.InvCurncy,IPp.TransDate,fr,to1,to2,br1,br2);
      if (blank(IPrw.FrRateBankVal)==false) then begin fr = IPrw.FrRateBankVal; end;
      if (blank(IPrw.ToRateB1BankVal)==false) then begin to1 = IPrw.ToRateB1BankVal; end;
      if (blank(IPrw.ToRateB2BankVal)==false) then begin to2 = IPrw.ToRateB2BankVal; end;
      if (blank(IPrw.BaseRate1BankVal)==false) then begin br1 = IPrw.BaseRate1BankVal; end;
      if (blank(IPrw.BaseRate2BankVal)==false) then begin br2 = IPrw.BaseRate2BankVal; end;      
//      IPrw.B1BankVal = IPrw.ToRateB1BankVal*IPrw.InvVal;
//      IPrw.B1BankVal = Round(IPrw.B1BankVal,DefaultRoundMode);
      if (blank(fr)) and ((nonblank(to1)) or (nonblank(to2))) then begin fr = 1; end;
      if (HasLocalization("POL") or nonblank(IPrw.B1BankVal) or nonblank(IPrw.FrRateBankVal) or nonblank(IPrw.ToRateB1BankVal) or nonblank(IPrw.ToRateB2BankVal) or nonblank(IPrw.BaseRate1BankVal) or nonblank(IPrw.BaseRate2BankVal)) then begin
        IPrw.B1BankVal = MulRateToBase1(IPrw.InvCurncy,IPrw.InvVal,fr,to1,to2,br1,br2,DefaultCurRoundOff);
        if (IPrw.B1BankVal==0) then begin IPrw.B1BankVal = blankval; end;
      end;
      if (HasLocalization("POL") or nonblank(IPrw.B1BankVal)) then begin
        IPrw.BankVal = IPrw.B1BankVal;
      end;
      MatRowPut(IPp,rownr,IPrw);
      res = true;
    end;
    IPSumup(IPp);
  end;
/*  
  if (IPrw.BankCurncy!=BCb.BaseCur1) then begin
    IPrw.B1BankVal = IPrw.ToRateB1BankVal*IPrw.BankVal;
    IPrw.B1BankVal = Round(IPrw.B1BankVal,DefaultRoundMode);
//    IPrw.B1BankVal = MulRateToBase1(IPrw.RecCurncy,IPrw.BankVal,IPrw.FrRateBankVal,IPrw.ToRateB1BankVal,IPrw.ToRateB2BankVal,IPrw.BaseRate1BankVal,IPrw.BaseRate2BankVal,DefaultCurRoundOff);
    MatRowPut(IPp,rownr,IPrw);
    res = true;
  end else begin
    IPrw.B1BankVal = IPrw.ToRateB1BankVal*IPrw.InvVal;
    IPrw.B1BankVal = Round(IPrw.B1BankVal,DefaultRoundMode);
//    IPrw.B1BankVal = MulRateToBase1(IPrw.RecCurncy,IPrw.BankVal,IPrw.FrRateBankVal,IPrw.ToRateB1BankVal,IPrw.ToRateB2BankVal,IPrw.BaseRate1BankVal,IPrw.BaseRate2BankVal,DefaultCurRoundOff);
    if (blank(IPrw.ToRateB1BankVal)) then begin
      IPrw.B1BankVal = blankval;
    end;
    IPrw.BankVal = IPrw.B1BankVal;
    MatRowPut(IPp,rownr,IPrw);
    res = true;
  end;
*/  
  IPSumup(IPp);
  IPVc_PasteToRateB1BankVal = res;
  return;
end;

global
function Boolean FindCheque(string custcode,string ownbankacc,var record CheckVc Checkr)
begin
  record CUVc CUr;  
  Boolean TrHs,openf,testf;
  
  RecordClear(Checkr);
  TrHs = true;
  Checkr.SerNr = -1;
  Checkr.Openf = 0;
  while (LoopKey("OpenSerNr",Checkr,1,TrHs)) begin
    if (TrHs) then begin
      testf = true;
      if (Checkr.Amount!=0) then begin
        testf = false;
      end;
      if (nonblank(Checkr.CUCode)) then begin
        if (Checkr.CUCode!=custcode) then begin
          testf = false;
        end;
      end;
      if (nonblank(ownbankacc)) then begin
        if (nonblank(Checkr.BankAcc)) then begin
          if (Checkr.BankAcc!=ownbankacc) then begin
            testf = false;
          end;
        end;
      end;
      if (testf) then begin
        TrHs = false;
        openf = true;
      end;
    end;
  end;
  FindCheque = openf;
  return;
end;

global
function Boolean CheckMultipleCurrencies_IPVc(record IPVc IPp,Integer rownr,var LongInt error)
begin
  row IPVc IPrw;
  row IPVc IPrwCurRow;
  Boolean res;
  integer i,rwcnt;

  error = -1;
  if (rownr>0) then begin 
    rwcnt = MatRowCnt(IPp);
    MatRowGet(IPp,rownr,IPrwCurRow);
    if (nonblank(IPrwCurRow.RecCurncy)) then begin 
      for (i=0; i<rwcnt; i=i+1) begin
        MatRowGet(IPp,i,IPrw);
        if (nonblank(IPrw.RecCurncy)) then begin
          if (IPrw.RecCurncy!=IPrwCurRow.RecCurncy) then begin
            res = true;
            error = 19126;
            i = rwcnt; 
          end;  
        end;
      end;
    end;
  end;
  CheckMultipleCurrencies_IPVc = res;
  return;
end;

/*
procedure AddToInvoice(record IPVc IPr,row IPVc IPrw,array record IVVc aIVr)
begin
  record IVVc IVr;
  Integer i;
  Boolean found;
  
  for (i=0;i<aIVr.length;i=i+1) begin
    IVr = aIVr[i];
    if (IVr.CustCode==IPrw.CustCode) then begin
      
      found = true;
    end;
  end;
  if (found==false) then begin
     
  end;
  return;
end;
*/  

updating procedure AddToInvoice(record IPVc IPr,row IPVc IPrw,array record IVVc aIVr,var string errstr)
begin
  record IVVc oldIVr;
  record IVVc IVr;
  row IVVc IVrw;
  record ORVc ORr;
  Integer err;
  record LocalMachineBlock LMb;
  string 255 warning,prepstr,invdatewarn,transdatewarn;
  Boolean ivfound;
  record SRBlock SRb;
  
  errstr = "";
  if (IPrw.OrderNr>0) then begin
    ORr.SerNr = IPrw.OrderNr;
    if (ReadFirstMain(ORr,1,true)) then begin
      err = RecordAction_raOrdDownPay(ORr.SerNr,blankval,IPrw.InvVal,IVr,errstr,1);
      if (err!=1) then begin
        goto LAddToInvoice;
      end;
      ivfound = true;
    end;
  end;
  if (IPrw.CUPNr>0) then begin
    if (ivfound==false) then begin
      RecordNew(IVr);
      IVr.CustCode = IPrw.CustCode;
      PasteCust2InInv(IVr,LMb,"",true,warning,errstr,prepstr,invdatewarn,transdatewarn);
    end else begin
      RecordCopy(oldIVr,IVr);
    end;
    ClearRow(IVr,IVrw,kInvoiceRowTypePrepayment);
    IVrw.Spec = USetStr(1288);
    IVrw.CUPNr = IPrw.CUPNr;
    PasteARPayInIV(IVr,IVrw,-1);
    MatRowInsert(IVr,MatRowCnt(IVr),IVrw);
    if (ivfound==false) then begin
      BlockLoad(SRb);
      if (IVr.SerNr<0) then begin
        IVr.SerNr = NextSerNr("IVVc",IVr.TransDate,SRb.LastInvNr,false,"");            
      end;
      if (IVr.SerNr>0) then begin
        RecordStore(IVr,false);
      end else begin
        errstr = USetStr(1747);
      end;
    end else begin
      RecordUpdate(oldIVr,IVr,true);
    end;
  end;
  aIVr[aIVr.length] = IVr;
LAddToInvoice:;
  return;
end;

global
updating procedure MakeDownPayFromOKedIPD(record IPVc IPr,Integer rownr,var array record IVVc aIVr,var string errstr)
begin
  row IPVc IPrw;
  Integer i,rwcnt;
  
  if (rownr<0) then begin
    rwcnt = MatRowCnt(IPr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IPr,i,IPrw);
      AddToInvoice(IPr,IPrw,aIVr,errstr);
    end;
  end else begin
    MatRowGet(IPr,rownr,IPrw);
    if (IPrw.OrderNr>0) then begin
      AddToInvoice(IPr,IPrw,aIVr,errstr);
    end;
  end;
  return;
end;