external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating procedure StoreItemHistory_In(record MainStockBlock,string,string,string,string,Date,Date,val,val,val,LongInt,Integer,Integer,string,string,record TempStockVc,Boolean);
external procedure ExtractObj(string,var Integer,var string);
external function Boolean GetObjBal(string,string,var record ObjBalVc);

procedure SetupRAD(var record RegArchiveDetailVc RADr,string filename,string keyone,string keytwo,string keythree,Date transdate,string colname,string serialnr)
begin
  RecordNew(RADr);
//  RADr.SerNr = NextSerNr("RegArchiveDetailVc",transdate,-1,false,"");
  RADr.FileName = filename;
  RADr.KeyOne = keyone;
  RADr.KeyTwo = keytwo;
  RADr.KeyThree = keythree;
  RADr.TransDate = transdate;
  RADr.ColName = colname;
  RADr.SerialNr = serialnr;
  switch (filename) begin
    case "MainVc": RADr.Comment = "Archive Fwd Balance";
    case "ItemHistVc": RADr.Comment = "Item History Fwd Balance";
  end;
  return;
end;

function boolean CompareRAD(record RegArchiveDetailVc RAD1r,record RegArchiveDetailVc RAD2r)
begin
  boolean res;
  
  res = false;
  
  if (RAD1r.FileName != RAD2r.FileName) then begin goto LCompareRAD; end;
  if (RAD1r.KeyOne != RAD2r.KeyOne) then begin goto LCompareRAD; end;
  if (RAD1r.KeyTwo != RAD2r.KeyTwo) then begin goto LCompareRAD; end;
  if (RAD1r.KeyThree != RAD2r.KeyThree) then begin goto LCompareRAD; end;
  if (RAD1r.TransDate != RAD2r.TransDate) then begin goto LCompareRAD; end;
  if (RAD1r.ColName != RAD2r.ColName) then begin goto LCompareRAD; end;
  if (RAD1r.SerialNr != RAD2r.SerialNr) then begin goto LCompareRAD; end;
  
  res = true;
LCompareRAD:;
  CompareRAD = res;
  return;
end;

updating procedure StoreRAD(record RegArchiveDetailVc RADr,Boolean allowduplicatesf)
begin
  record RegArchiveDetailVc prevRADr;
  record RegArchiveDetailVc oldRADr;
  
  if (allowduplicatesf) then begin
    RADr.SerNr = NextSerNr("RegArchiveDetailVc",RADr.TransDate,-1,false,"");
    if (RecordStore(RADr,false)) then begin
    end;
  end else begin
    RecordCopy(prevRADr,RADr);
    if (ReadFirstKey("FindDuplicates",prevRADr,7,true)) then begin
      RecordCopy(oldRADr,prevRADr);
      prevRADr.vp = prevRADr.vp + RADr.vp;
      prevRADr.dv = prevRADr.dv + RADr.dv;
      prevRADr.cv = prevRADr.cv + RADr.cv;
      prevRADr.dv2 = prevRADr.dv2 + RADr.dv2;
      prevRADr.cv2 = prevRADr.cv2 + RADr.cv2;
      prevRADr.dcv = prevRADr.dcv + RADr.dcv;
      prevRADr.ccv = prevRADr.ccv + RADr.ccv;
      prevRADr.v1 = prevRADr.v1 + RADr.v1;
      prevRADr.v2 = prevRADr.v2 + RADr.v2;
      prevRADr.v3 = prevRADr.v3 + RADr.v3;
      prevRADr.v4 = prevRADr.v4 + RADr.v4;
      if (RecordUpdate(oldRADr,prevRADr,false)==0) then begin
      end;
    end else begin
      RADr.SerNr = NextSerNr("RegArchiveDetailVc",RADr.TransDate,-1,false,"");
      if (RecordStore(RADr,false)) then begin
      end;
    end;
  end;
  return;
end;

global
updating procedure AddToArchive(string filename,string keyone,string keytwo,Date transdate,string colname,val v)
begin
  record RegArchiveDetailVc RADr;
  
  SetupRAD(RADr,filename,keyone,keytwo,"",transdate,colname,"");
  RADr.vp = v;
  StoreRAD(RADr,false);
  return;
end;

updating procedure DoAddHistoryToArchive(string filename,string keyone,string keytwo,Date transdate,string colname,val dv,val cv,val dv2,val cv2,val dcv,val ccv)
begin
  record RegArchiveDetailVc RADr;
  
  SetupRAD(RADr,filename,keyone,keytwo,"",transdate,colname,"");
  RADr.dv = dv;
  RADr.cv = cv;
  RADr.dv2 = dv2;
  RADr.cv2 = cv2;
  RADr.dcv = dcv;
  RADr.ccv = ccv;
  StoreRAD(RADr,false);
  return;
end;

global
updating procedure DoAddItemHistoryToArchive(string filename,string keyone,string keytwo,string keythree,Date transdate,string colname,
                                             val dv,val cv,string serialnr,val dv2,val cv2,val dcv,val ccv,val v1,val v2,val v3,val v4)
begin
  record RegArchiveDetailVc RADr;
  record RegArchiveDetailVc oldRADr;
  record RegArchiveDetailVc prevRADr;
  Boolean foundf;
  val remqty,remqty2,prc,v;
  
  SetupRAD(RADr,filename,keyone,keytwo,keythree,transdate,colname,serialnr);
  remqty = dv;
  remqty2 = cv;
  prc = 1;
  RecordCopy(prevRADr,RADr);
  if (dv>0) then begin
    foundf = true;
    while (LoopKey("FindDuplicates",prevRADr,7,foundf)) begin
      foundf = CompareRAD(RADr,prevRADr);
      if (foundf) then begin
        if (prevRADr.vp<0) then begin
          if (prevRADr.vp + remqty<=0) then begin
            RecordCopy(oldRADr,prevRADr);
            prevRADr.vp = prevRADr.vp + remqty;
            prevRADr.dv = prevRADr.dv + remqty;
            prevRADr.cv = prevRADr.cv + remqty2;
            prevRADr.dv2 = prevRADr.dv2 - (dv2 * prc);
            prevRADr.cv2 = prevRADr.cv2 - (cv2 * prc);
            prevRADr.dcv = prevRADr.dcv - (dcv * prc);
            prevRADr.ccv = prevRADr.ccv - (ccv * prc);
            prevRADr.v1 = prevRADr.v1 - (v1 * prc);
            prevRADr.v2 = prevRADr.v2 - (v2 * prc);
            prevRADr.v3 = prevRADr.v3 - (v3 * prc);
            prevRADr.v4 = prevRADr.v4 - (v4 * prc);
            if (prevRADr.vp==0) then begin
              RecordDelete(prevRADr);
            end else begin
              if (RecordUpdate(oldRADr,prevRADr,false)==0) then begin
              end;
            end;
            remqty = 0;
            foundf = false;
          end else begin
            v = dv;
            remqty = remqty + prevRADr.dv;
            remqty2 = remqty2 + prevRADr.cv;
            prc = remqty / v;
            RecordDelete(prevRADr);
          end;
        end;
      end;
    end;
  end;
  if (remqty!=0) then begin
    RADr.vp = remqty;
    RADr.dv = remqty;
    RADr.cv = remqty2;
    RADr.dv2 = dv2 * prc;
    RADr.cv2 = cv2 * prc;
    RADr.dcv = dcv * prc;
    RADr.ccv = ccv * prc;
    RADr.v1 = v1 * prc;
    RADr.v2 = v2 * prc;
    RADr.v3 = v3 * prc;
    RADr.v4 = v4 * prc;
    StoreRAD(RADr,true);
  end;
  return;
end;

global
updating procedure DoSubItemHistoryFromArchive(string filename,string keyone,string keytwo,string keythree,Date transdate,string colname,
                                               val dv,val cv,string serialnr,val dv2,val cv2,val dcv,val ccv,val v1,val v2,val v3,val v4)
begin
  record RegArchiveDetailVc RADr;
  record RegArchiveDetailVc oldRADr;
  Boolean foundf;
  val remqty,remqty2,prc,v;
  
  SetupRAD(RADr,filename,keyone,keytwo,keythree,transdate,colname,serialnr);
  remqty = -dv;
  remqty2 = -cv;
  prc = 1;
  foundf = true;
  while (LoopKey("FindDuplicates",RADr,7,foundf)) begin
    if (RADr.vp>=remqty) then begin
      RecordCopy(oldRADr,RADr);
      RADr.vp = RADr.vp - remqty;
      RADr.dv = RADr.dv - remqty;
      RADr.cv = RADr.cv - remqty2;
      RADr.dv2 = RADr.dv2 - (dv2 * prc);
      RADr.cv2 = RADr.cv2 - (cv2 * prc);
      RADr.dcv = RADr.dcv - (dcv * prc);
      RADr.ccv = RADr.ccv - (ccv * prc);
      RADr.v1 = RADr.v1 - (v1 * prc);
      RADr.v2 = RADr.v2 - (v2 * prc);
      RADr.v3 = RADr.v3 - (v3 * prc);
      RADr.v4 = RADr.v4 - (v4 * prc);
      if (RADr.vp==0) then begin
        RecordDelete(RADr);
      end else begin
        if (RecordUpdate(oldRADr,RADr,false)==0) then begin
        end;
      end;
      remqty = 0;
      foundf = false;
    end else begin
      v = -dv;
      remqty = remqty - RADr.dv;
      remqty2 = remqty2 - RADr.cv;
      prc = remqty / v;
      RecordDelete(RADr);
    end;
  end;
  if (remqty!=0) then begin
    DoAddItemHistoryToArchive(filename,keyone,keytwo,keythree,transdate,colname,-remqty,-remqty2,serialnr,dv2*prc,cv2*prc,dcv*prc,ccv*prc,v1*prc,v2*prc,v3*prc,v4*prc);
  end;
  return;
end;

global
updating procedure AddHistoryToArchive(string filename,string keyone,string keytwo,Date transdate,string colname,val dv,val cv,val dv2,val cv2,val dcv,val ccv)
begin
  Integer pos;
  string 255 ostr;

  DoAddHistoryToArchive(filename,keyone,"",transdate,colname,dv,cv,dv2,cv2,dcv,ccv);
  pos = 0;
  ExtractObj(keytwo,pos,ostr);
  while (nonblank(ostr)) begin
    DoAddHistoryToArchive(filename,keyone,ostr,transdate,colname,dv,cv,dv2,cv2,dcv,ccv);
    ExtractObj(keytwo,pos,ostr);
  end;
  return;
end;

updating procedure ArchiveMainVc(record RegArchiveDetailVc RegArchiveDetailr,Boolean addf)
begin
  record MainVc Mainr;

  Mainr.AccNumber = RegArchiveDetailr.KeyOne;
  Mainr.TransDate = RegArchiveDetailr.TransDate;
  Mainr.TransNr = RegArchiveDetailr.SerNr;
  Mainr.FileName = "RegArchiveDetailVc";
  Mainr.IntYc = 0;
  if (addf) then begin
    if (RecordStore(Mainr,false)) then begin end;
  end else begin
    if (ReadFirstMain(Mainr,5,true)) then begin
      RecordDelete(Mainr);
    end;
  end;
  return;
end;

global
updating procedure ArchiveUpdateStockVc(record RegArchiveDetailVc RegArchiveDetailr)
begin
  val t;
  
  UpdateInstock("PUVc",-1,RegArchiveDetailr.KeyOne,RegArchiveDetailr.KeyTwo,RegArchiveDetailr.TransDate,RegArchiveDetailr.dv,t,t,RegArchiveDetailr.dv,RegArchiveDetailr.dv,RegArchiveDetailr.cv,t,t,t);
  return;
end;

// Might want to have a new type of record, like B.FWD type of record that can point to the Archive record, but this is good enough for testing
global
updating procedure ArchiveItemHistVc2(record RegArchiveDetailVc RegArchiveDetailr,record MainStockBlock MSb,Boolean addf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  if (addf) then begin
    StoreItemHistory_In(MSb,RegArchiveDetailr.KeyOne,RegArchiveDetailr.SerialNr,RegArchiveDetailr.KeyTwo,"PUVc",RegArchiveDetailr.TransDate,RegArchiveDetailr.TransDate,RegArchiveDetailr.dv,1,RegArchiveDetailr.dv2,-1,-1,1,RegArchiveDetailr.ColName,"",TSr,usetmpstkf);
  end else begin
    // Might need to support updates, but doesn't at the moment.
  end;
  return;
end;

global
updating procedure ArchiveItemHistVc(record RegArchiveDetailVc RegArchiveDetailr,record MainStockBlock MSb,Boolean addf)
begin
  record TempStockVc TSr;

  ArchiveItemHistVc2(RegArchiveDetailr,MSb,addf,TSr,false);
  return;
end;

updating procedure UpdateProperSupportReg(record RegArchiveDetailVc RegArchiveDetailr,record RegArchiveDetailVc RegArchiveDetail2r,Boolean updatef,Boolean importf)
begin
  record ObjBalVc ObjBalr;
  record MainStockBlock MSb;
  Boolean foundf,testf;
  
  testf = false;
  if (updatef==false) then begin
    if (RegArchiveDetailr.OKFlag!=0) then begin
      testf = true;
    end;
  end else begin
    if (RegArchiveDetailr.OKFlag!=0 or RegArchiveDetail2r.OKFlag!=0) then begin
      testf = true;
    end;
  end;
  if (testf) then begin
    switch (RegArchiveDetailr.FileName) begin
      case "ObjBalVc":
        foundf = GetObjBal(RegArchiveDetailr.KeyOne,RegArchiveDetailr.KeyTwo,ObjBalr);
        if (updatef) then begin
          if (RegArchiveDetail2r.OKFlag!=0) then begin
            AddBalance(ObjBalr,RegArchiveDetailr.TransDate,RegArchiveDetailr.ColName,-RegArchiveDetailr.vp,"",blankval,"",blankval,"",blankval,"",blankval,"",blankval);
          end;
        end;
        if (RegArchiveDetailr.OKFlag!=0) then begin
          AddBalance(ObjBalr,RegArchiveDetailr.TransDate,RegArchiveDetailr.ColName,RegArchiveDetailr.vp,"",blankval,"",blankval,"",blankval,"",blankval,"",blankval);
        end;
      case "MainVc":
        if (updatef) then begin
          if (RegArchiveDetail2r.OKFlag!=0) then begin
            ArchiveMainVc(RegArchiveDetail2r,false);
          end;
        end;
        if (RegArchiveDetailr.OKFlag!=0) then begin
          ArchiveMainVc(RegArchiveDetailr,true);
        end;
      case "ItemHistVc":
        if (importf==false) then begin
          BlockLoad(MSb);
          if (updatef) then begin
//            if (RegArchiveDetail2r.OKFlag!=0) then begin
//              ArchiveItemHistVc(RegArchiveDetail2r,MSb,false);
//            end;
            if (RegArchiveDetailr.OKFlag!=0 and RegArchiveDetail2r.OKFlag==0) then begin // Can't handle updates....
              ArchiveItemHistVc(RegArchiveDetail2r,MSb,true);
            end;
          end;
//          if (RegArchiveDetailr.OKFlag!=0) then begin
//            ArchiveItemHistVc(RegArchiveDetailr,MSb,true);
//          end;
          if (RegArchiveDetailr.OKFlag!=0 and updatef==false) then begin // Can't handle updates....
            ArchiveItemHistVc(RegArchiveDetailr,MSb,true);
          end;
        end;
    end;
  end;
  return;
end;

global
updating function LongInt RegArchiveDetailVcRecordSaveAfter(var record RegArchiveDetailVc RegArchiveDetailr,record RegArchiveDetailVc RegArchiveDetail2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  
  UpdateProperSupportReg(RegArchiveDetailr,RegArchiveDetail2r,false,false);
  RegArchiveDetailVcRecordSaveAfter = res;
  RETURN;
END;

global
updating function LongInt RegArchiveDetailVcRecordUpdateAfter(var record RegArchiveDetailVc RegArchiveDetailr,record RegArchiveDetailVc RegArchiveDetail2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  
  UpdateProperSupportReg(RegArchiveDetailr,RegArchiveDetail2r,true,false);
  RegArchiveDetailVcRecordUpdateAfter = res;
  RETURN;
END;

global
updating function LongInt RegArchiveDetailVcRecordImportAfter(var record RegArchiveDetailVc RegArchiveDetailr,record RegArchiveDetailVc RegArchiveDetail2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  
  UpdateProperSupportReg(RegArchiveDetailr,RegArchiveDetail2r,false,true);
  RegArchiveDetailVcRecordImportAfter = res;
  RETURN;
END;

