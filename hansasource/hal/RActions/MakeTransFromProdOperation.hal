external function Integer CheckObjs(string,string,var string);
external function string 60 AddObjectToObjectList(string,string);
external function roundmode DefaultRoundMode();
external procedure GetITWIPAccAcc(string,var string);
external procedure GetConsigmentStockAcc(string,string,var string);
external function Boolean ProdOperationForFinalProduct(record ProdOperationVc);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetProdWCostAcc(Integer,string,string,var string);
external procedure GetProductionAccounts(Integer,string,string,string,string,var string,var string);
external procedure GetProdStockAcc(Integer,string,string,string,string,string,var string,var string);
external function Boolean GetAccName(string,var string,Integer);
external function Boolean CheckTTRPerRow(string,string,string,Boolean,var string,Integer);
external procedure AddEuroTrRowType(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string,Integer);
external procedure AddEuroTrRowTypeQty(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string,Integer,val);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function Boolean TransInFiscal(Date);

function val AcumCost_PreviousProdOperations(record ProdOperationVc curProdOpr)
begin
  val res;
  record ProdOperationVc ProdOpr;
  row ProdOperationVc ProdOprw;
  Boolean found;
  Integer i,rwcnt;
  string 255 keystr;
  Integer keys;
    
  found = true;
  if (curProdOpr.SubSequence>0) then begin
    ProdOpr.SubSequence = curProdOpr.SubSequence;
    keystr = "SubSequence";
    keys = 4;
  end else begin
    keystr = "Sequence";
    keys = 3;
  end;
  ProdOpr.Sequence = curProdOpr.Sequence - 1;
  ProdOpr.ProdNr = curProdOpr.ProdNr;
  ProdOpr.PRStatusFlag = 3;  
  while (LoopBackKey(keystr,ProdOpr,keys,found)) begin
    if (ProdOpr.Sequence>curProdOpr.Sequence - 1) then begin found = false; end;
    if (ProdOpr.ProdNr>curProdOpr.ProdNr) then begin found = false; end;
    if (curProdOpr.SubSequence>0) then begin
      if (ProdOpr.SubSequence>0) then begin
        if (ProdOpr.SubSequence!=curProdOpr.SubSequence) then begin found = false; end;
      end;
    end;
    if (ProdOpr.PRStatusFlag!=3) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(ProdOpr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(ProdOpr,i,ProdOprw);
        if (ProdOprw.OutQty!=0) then begin
          found = false;
        end;
      end;
      if (found) then begin
        rwcnt = MatRowCnt(ProdOpr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(ProdOpr,i,ProdOprw);
          if (ProdOprw.InQty!=0) then begin
            switch (ProdOpr.RowsHoldActualQty) begin
              case 1: res = res + ProdOprw.ItemCost;;
              otherwise res = res + ProdOprw.ItemCost*ProdOpr.ActualQty;
            end;            
          end;
        end;
      end;
    end;
  end;

  ResetLoop(ProdOpr);
  found = true;
  ProdOpr.Sequence = curProdOpr.Sequence - 1;
  ProdOpr.ProdNr = curProdOpr.ProdNr;
  ProdOpr.PRStatusFlag = 5;  
  while (LoopBackKey(keystr,ProdOpr,keys,found)) begin
    if (ProdOpr.Sequence>curProdOpr.Sequence - 1) then begin found = false; end;
    if (ProdOpr.ProdNr>curProdOpr.ProdNr) then begin found = false; end;
    if (curProdOpr.SubSequence>0) then begin
      if (ProdOpr.SubSequence>0) then begin
        if (ProdOpr.SubSequence!=curProdOpr.SubSequence) then begin found = false; end;
      end;
    end;
    if (ProdOpr.PRStatusFlag!=5) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(ProdOpr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(ProdOpr,i,ProdOprw);
        if (ProdOprw.OutQty!=0) then begin
          found = false;
        end;
      end;
      if (found) then begin
        rwcnt = MatRowCnt(ProdOpr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(ProdOpr,i,ProdOprw);
          if (ProdOprw.InQty!=0) then begin
            switch (ProdOpr.RowsHoldActualQty) begin
              case 1: res = res + ProdOprw.ItemCost;;
              otherwise res = res + ProdOprw.ItemCost*ProdOpr.ActualQty;
            end;            
          end;
        end;
      end;
    end;
  end;
  
  AcumCost_PreviousProdOperations = res;
  return;
end;

function Integer AddAcumulatedCostRows(record TRVc gTRp,record ProdOperationVc ProdOpr,record LocationVc Locr,record MainStockBlock MSb,record CostAccBlock CAb,record AccBlock ARb,
                                       record ProdAccBlock PAb,val br1,val br2,var val TotSum)
begin
  Integer res;
  Integer i,rwcnt;
  row ProdOperationVc ProdOprw;
  val totrelprices;
  Integer outrows;
  val totfifo,t,t2,fifoshare;
  record INVc INr;
  string 255 rowstockacc,tstr,objstr,taccnumber,locobjstr,errstr;
  Boolean dc1,dc2;
  
  dc1 = true;
  dc2 = false;  
  totfifo = AcumCost_PreviousProdOperations(ProdOpr);
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (ProdOprw.OutQty!=0) then begin
      outrows = outrows + 1;
      totrelprices = totrelprices + ProdOprw.OutQty*ProdOprw.RelVal;
    end else begin
      totfifo = totfifo + ProdOprw.ItemCost;
    end;
  end;
  if (outrows>0) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ProdOpr,i,ProdOprw);
      if (ProdOprw.OutQty!=0) then begin
        if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin
        end;
        t2 = ProdOprw.OutQty*ProdOprw.RelVal;   
        if (t2!=0) then begin   
          fifoshare = t2/totrelprices;
          t2 = fifoshare*totfifo;
        end else begin
          if (totrelprices!=0) then begin
            t2 = 0;
          end else begin
            t2 = totfifo;
          end;
        end;
        t = t2/ProdOprw.OutQty;
        if (CheckTTRPerRow("ProdOperationVc",PAb.WorkInProg,objstr,dc1,taccnumber,0)) then begin end;
        AddEuroTrRowType(gTRp,PAb.WorkInProg,objstr,"",tstr,t,br1,br2,true,dc2,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
        
        GetProdStockAcc(CAb.ItemGroupAccounts,Locr.StockAcc,MSb.MainStock,INr.Group,ARb.ProdICostAcc,ARb.StockAcc,rowstockacc,locobjstr);
        objstr = AddObjectToObjectList(objstr,locobjstr);
        if (ProdOprw.InQty!=0) then begin
          GetConsigmentStockAcc(ProdOprw.Item,ProdOprw.SerialNr,rowstockacc);
        end;
        if (GetAccName(rowstockacc,tstr,60)==false) then begin
          res = 20597;
          goto LAddAcumulatedCostRows;
        end;
        res = CheckObjs(rowstockacc,objstr,errstr);
        if (res!=0) then begin
          goto LAddAcumulatedCostRows;
        end;
        if (CheckTTRPerRow("ProdOperationVc",rowstockacc,objstr,dc1,taccnumber,1)) then begin end;
        AddEuroTrRowType(gTRp,rowstockacc,objstr,"",tstr,t,br1,br2,true,dc1,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
      end;
    end;
  end;
LAddAcumulatedCostRows:;  
  AddAcumulatedCostRows = res;
  return;
end;

function Integer AddProdOperationCostRow(record TRVc gTRp,record ProdOperationVc ProdOpr,row ProdOperationVc ProdOprw,record LocationVc Locr,record MainStockBlock MSb,
                                record CostAccBlock CAb,record AccBlock ARb,record ProdAccBlock PAb,
                                Boolean accf,Boolean dcf,val baserate1,val baserate2,Boolean inqtyf,Boolean finalproductf,val qty,var val TotSum)
begin
  Integer res;
  string 10 prodwcost,prodicost,rowstockacc,compusageacc,prodcontrol;
  Boolean stockf;
  record INVc INr;
  string 255 objstr,tstr,ttstr,taccnumber,rowstockobjects,errstr,locobjstr;
  val t;

  prodwcost = ARb.ProdWCostAcc;
  prodicost = ARb.ProdICostAcc;
  stockf = false;
  if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin
    if (INr.ItemType==1) then begin
      stockf = true;
    end;
  end;
//  objstr = ProdOpr.Objects;
//  if (nonblank(objstr)) then begin objstr = objstr & ","; end;
  objstr = objstr & ProdOprw.Objects;
  rowstockobjects = objstr;
  if (stockf) then begin // stockfracc was used, and ProdOprw.FIFORowVal should be used when it is setup correctly
    t = qty*ProdOprw.ItemCost;
    switch (ProdOpr.RowsHoldActualQty) begin
      case 1: ;
      otherwise t = t*ProdOpr.ActualQty;
    end;
    
    t = Round(t,DefaultRoundMode);
    
    switch (ProdOpr.PRStatusFlag) begin
      case 3:
        if (ProdOprw.Discarded==1) then begin
          if (inqtyf) then begin
            GetProdStockAcc(CAb.ItemGroupAccounts,Locr.StockAcc,MSb.MainStock,INr.Group,ARb.ProdICostAcc,ARb.StockAcc,rowstockacc,locobjstr);
            rowstockobjects = AddObjectToObjectList(rowstockobjects,locobjstr);
          end else begin
            rowstockacc = ARb.DiscardedAccount;
          end;
        end else begin
          GetProdStockAcc(CAb.ItemGroupAccounts,Locr.StockAcc,MSb.MainStock,INr.Group,ARb.ProdICostAcc,ARb.StockAcc,rowstockacc,locobjstr);
          rowstockobjects = AddObjectToObjectList(rowstockobjects,locobjstr);
        end;
      case 5:
        if (inqtyf) then begin
          GetProdStockAcc(CAb.ItemGroupAccounts,Locr.StockAcc,MSb.MainStock,INr.Group,ARb.ProdICostAcc,ARb.StockAcc,rowstockacc,locobjstr);
          rowstockobjects = AddObjectToObjectList(rowstockobjects,locobjstr);
        end else begin
          rowstockacc = ARb.DiscardedAccount;
        end;
    end;
    if (GetAccName(rowstockacc,tstr,60)==false) then begin
      res = 2120;
      goto LAddProdOperationCostRow;
    end;
    res = CheckObjs(rowstockacc,rowstockobjects,errstr);
    if (res!=0) then begin
      goto LAddProdOperationCostRow;
    end;
    if (CheckTTRPerRow("ProdOperationVc",rowstockobjects,locobjstr,dcf,taccnumber,1)) then begin end;
    switch (ProdOpr.RowsHoldActualQty) begin
      case 1:
        AddEuroTrRowTypeQty(gTRp,rowstockacc,locobjstr,"",tstr,t,baserate1,baserate2,accf,dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock,qty);
      otherwise
        AddEuroTrRowTypeQty(gTRp,rowstockacc,locobjstr,"",tstr,t,baserate1,baserate2,accf,dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock,ProdOpr.Qty*qty);
    end;


    if (dcf==false) then begin
      GetProductionAccounts(CAb.ItemGroupAccounts,INr.CompUsage,INr.Group,PAb.CompUsage,PAb.ProdControl,compusageacc,prodcontrol);
      if (nonblank(compusageacc) and nonblank(prodcontrol)) then begin
        if (CheckTTRPerRow("ProdOperationVc",compusageacc,objstr,!dcf,taccnumber,1)) then begin end;
        if (GetAccName(compusageacc,tstr,60)==false) then begin
          res = 20785; // This string has to do with HansaWorld contracts
          goto LAddProdOperationCostRow;
        end;
        AddEuroTrRowType(gTRp,compusageacc,objstr,"",tstr,t,baserate1,baserate2,true,!dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
        if (CheckTTRPerRow("ProdOperationVc",prodcontrol,objstr,dcf,taccnumber,1)) then begin end;
        if (GetAccName(prodcontrol,tstr,60)==false) then begin
          res = 20786; // This string doesn't exist....
          goto LAddProdOperationCostRow;
        end;
        AddEuroTrRowType(gTRp,prodcontrol,objstr,"",tstr,t,baserate1,baserate2,true,dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
      end;
    end;
  end else begin
    GetProdWCostAcc(CAb.ItemGroupAccounts,INr.Group,ARb.ProdWCostAcc,prodwcost);

    if (GetAccName(prodwcost,tstr,60)==false) then begin
      res = 20597;
      goto LAddProdOperationCostRow;
    end;
    t = ProdOprw.FIFORowVal;
    t = Round(t,DefaultRoundMode);
    if (CheckTTRPerRow("ProdOperationVc",prodwcost,objstr,dcf,taccnumber,0)) then begin end;
    AddEuroTrRowType(gTRp,prodwcost,objstr,"",tstr,t,baserate1,baserate2,true,dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
/*  
    if (finalproductf) then begin
    end else begin
      t = qty*ProdOprw.ItemCost;
      t = Round(t,DefaultRoundMode);
      GetProdWCostAcc(CAb.ItemGroupAccounts,INr.Group,ARb.ProdWCostAcc,prodwcost);
      if (GetAccName(prodwcost,tstr,60)==false) then begin
        res = 2159;
        goto LAddProdOperationCostRow;
      end;
      if (CheckTTRPerRow("ProdOperationVc",prodwcost,objstr,dcf,taccnumber,1)) then begin end;
      AddEuroTrRow(gTRp,prodwcost,objstr,"",tstr,t,baserate1,baserate2,true,dcf,TotSum,false,taccnumber,"","");
    end;
*/    
  end;  
/*  
  t = 0;
//  t = ProdOprw.ExtraCost*ProdOpr.ActualQty;
//this is wrong,calc fifo works diffrently
//this is not  wrong, this must be muliplied
  if (t!=0) then begin
    GetProdWCostAcc(CAb.ItemGroupAccounts,INr.Group,ARb.ProdWCostAcc,prodwcost);
    if (GetAccName(prodwcost,tstr,60)==false) then begin
      res = 2159;
      goto LAddProdOperationCostRow;
    end;
    t = Round(t,DefaultRoundMode);
    if (CheckTTRPerRow("ProdOperationVc",prodwcost,objstr,dcf,taccnumber,1)) then begin end;
    AddEuroTrRowType(gTRp,prodwcost,objstr,"",tstr,t,baserate1,baserate2,accf,dcf,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
  end;
*/  
LAddProdOperationCostRow:; 
  AddProdOperationCostRow = res;
  return;
end;

procedure GetWorkInProgAcc(string itcode,Integer ItemGroupAccounts,string prodWorkInProg,var string res)
begin
  if (ItemGroupAccounts!=0) then begin
    GetITWIPAccAcc(itcode,res);
    if (nonblank(res)) then begin
      goto LGetWorkInProgAcc;
    end;
  end;
  res = prodWorkInProg;
LGetWorkInProgAcc:;  
  return;
end;

global
function Integer ProductionOperationTransaction(var record TRVc gTRp,record ProdOperationVc ProdOpr)
begin
  Integer res;
  Integer i,rwcnt;
  record LocationVc Locr;
  val baserate1,baserate2;
  val t,TotSum,qty;
  string 255 tstr,stockobjs,taccnumber,workinprog;
  row ProdOperationVc ProdOprw;
  Boolean atleastoneout;
  Boolean dc1,dc2,finalproductf;
  record AccBlock ARb;  
  record MainStockBlock MSb;  
  record CostAccBlock CAb;
  record ProdAccBlock PAb;
  record INVc INr;
  vector Boolean vaccf;

  BlockLoad(PAb);
  BlockLoad(CAb);
  BlockLoad(MSb);
  BlockLoad(ARb);

  dc1 = true;
  dc2 = false;
  Locr.Code = ProdOpr.Location;
  if (ReadFirstMain(Locr,1,true)==false) then begin
  end;
  GetFullCurncyRate(tstr,gTRp.TransDate,t,t,t,baserate1,baserate2);
  finalproductf = ProdOperationForFinalProduct(ProdOpr);
  vaccf["IN"] = false;  
  vaccf["OUT"] = false;  
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    if (ProdOprw.InQty!=0) then begin
       res = AddProdOperationCostRow(gTRp,ProdOpr,ProdOprw,Locr,MSb,CAb,ARb,PAb,vaccf["IN"],dc2,baserate1,baserate2,true,finalproductf,ProdOprw.InQty,TotSum);
       vaccf["IN"] = true;
       if (res!=0) then begin
         goto LProductionOperationTransaction;
       end;
    end;
    if (ProdOprw.OutQty!=0) then begin
       res = AddProdOperationCostRow(gTRp,ProdOpr,ProdOprw,Locr,MSb,CAb,ARb,PAb,vaccf["OUT"],dc1,baserate1,baserate2,false,finalproductf,ProdOprw.OutQty,TotSum);
       vaccf["OUT"] = true;
       if (res!=0) then begin
         goto LProductionOperationTransaction;
       end;
       atleastoneout = true;
    end;
  end;
  if (atleastoneout==false) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ProdOpr,i,ProdOprw);
      switch (ProdOprw.Discarded) begin
        otherwise
          if (ProdOprw.InQty!=0) then begin
            if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin end;
            GetWorkInProgAcc(INr.Group,CAb.ItemGroupAccounts,PAb.WorkInProg,workinprog);
            if (GetAccName(workinprog,tstr,60)==false) then begin
              res = 20597;
              goto LProductionOperationTransaction;
            end;
            t = ProdOprw.InQty*ProdOprw.ItemCost;
            switch (ProdOpr.RowsHoldActualQty) begin
              case 1: ;
              otherwise t = t*ProdOpr.ActualQty;
            end;
            t = Round(t,DefaultRoundMode);
            if (CheckTTRPerRow("ProdOperationVc",workinprog,stockobjs,dc1,taccnumber,0)) then begin end;
            AddEuroTrRowType(gTRp,workinprog,stockobjs,"",tstr,t,baserate1,baserate2,true,dc1,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
          end;
      end;
    end;
/*    
    t = TotSum;
    if (GetAccName(PAb.WorkInProg,tstr,60)==false) then begin
      res = 20597;
      goto LProductionOperationTransaction;
    end;
    if (CheckTTRPerRow("ProdOperationVc",PAb.WorkInProg,stockobjs,dc1,taccnumber,0)) then begin end;
    AddEuroTrRow(gTRp,PAb.WorkInProg,stockobjs,"",tstr,t,baserate1,baserate2,true,dc2,TotSum,false,taccnumber,"","");
*/    
  end else begin
//    res = AddAcumulatedCostRows(gTRp,ProdOpr,Locr,MSb,CAb);
  end;
  if (CAb.ObjOnStock!=0) then begin
//    stockobjs = ProdOpr.Objects;
  end else begin
    stockobjs = "";
  end;
  if (TotSum!=0) then begin
    if (ProdOpr.PRStatusFlag==5) then begin
      if (finalproductf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(ProdOpr,i,ProdOprw);
          switch (ProdOprw.Discarded) begin
            otherwise
              if (ProdOprw.InQty!=0) then begin
                qty = -ProdOprw.InQty;
              end;
              if (ProdOprw.OutQty!=0) then begin
                qty = ProdOprw.OutQty;
              end;
              if (qty!=0) then begin
                if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin end;
                GetWorkInProgAcc(INr.Group,CAb.ItemGroupAccounts,PAb.WorkInProg,workinprog);
                if (GetAccName(workinprog,tstr,60)==false) then begin
                  res = 20597;
                  goto LProductionOperationTransaction;
                end;
                t = qty*ProdOprw.ItemCost;
                switch (ProdOpr.RowsHoldActualQty) begin
                  case 1: ;
                  otherwise t = t*ProdOpr.ActualQty;
                end;
                if (CheckTTRPerRow("ProdOperationVc",workinprog,stockobjs,dc2,taccnumber,0)) then begin end;
                AddEuroTrRowType(gTRp,workinprog,stockobjs,"",tstr,t,baserate1,baserate2,true,dc2,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
              end;
          end;
        end;
      end;
    end else begin
      if (finalproductf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(ProdOpr,i,ProdOprw);
          switch (ProdOprw.Discarded) begin
            otherwise
              if (ProdOprw.InQty!=0) then begin
                qty = -ProdOprw.InQty;
              end;
              if (ProdOprw.OutQty!=0) then begin
                qty = ProdOprw.OutQty;
              end;
              if (qty!=0) then begin
                if (ReadFirstItem(ProdOprw.Item,INr,false,false)) then begin end;
                GetWorkInProgAcc(INr.Group,CAb.ItemGroupAccounts,PAb.WorkInProg,workinprog);
                if (GetAccName(workinprog,tstr,60)==false) then begin
                  res = 20597;
                  goto LProductionOperationTransaction;
                end;
                t = qty*ProdOprw.ItemCost;
                switch (ProdOpr.RowsHoldActualQty) begin
                  case 1: ;
                  otherwise t = t*ProdOpr.ActualQty;
                end;
                if (CheckTTRPerRow("ProdOperationVc",workinprog,stockobjs,dc2,taccnumber,0)) then begin end;
                AddEuroTrRowType(gTRp,workinprog,stockobjs,"",tstr,t,baserate1,baserate2,true,dc2,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
              end;
          end;
        end;      
      end else begin
        if (GetAccName(ARb.StockGainAcc,tstr,60)==false) then begin
          res = 2119;
          goto LProductionOperationTransaction;
        end;
        t = TotSum;
        if (CheckTTRPerRow("ProdOperationVc",ARb.StockGainAcc,stockobjs,dc2,taccnumber,0)) then begin end;
        AddEuroTrRowType(gTRp,ARb.StockGainAcc,stockobjs,"",tstr,t,baserate1,baserate2,true,dc2,TotSum,false,taccnumber,"","",kTransactionRowTypeStock);
      end;
    end;
  end;
//  AddTransAutoTransRows(gTRp);
LProductionOperationTransaction:;
  ProductionOperationTransaction = res;
  return;
end;

global
function Integer MakeTransFromProdOperation(record TRVc gTRp,record ProdOperationVc ProdOpr,Boolean rpt)
begin
  Integer res;
  record TRVc existsTRr;
  Boolean dc1,dc2;
  record TRGenBlock TRGb;
  val baserate1,baserate2;
  val t;
  transaction string 255 gRuniningMaint;

  BlockLoad(TRGb);  
  RecordNew(gTRp);
  if (rpt==false) then begin
    if (TRGb.ProdGenTrans==0) then begin
      res = 0;
      goto LMakeTransFromProdOperation;
    end;
    if (nonblankdate(TRGb.ProdStartDate)) then begin
      if (ProdOpr.ProdDate<TRGb.ProdStartDate) then begin
        res = 0;
        goto LMakeTransFromProdOperation;
      end;
    end;
  end;
  if (rpt==false) then begin
    gTRp.IntYc = ProdOperationYc;
    gTRp.Number = ProdOpr.SerNr;
    existsTRr.Number = gTRp.Number;
    existsTRr.IntYc = gTRp.IntYc;
    if (ReadFirstMain(existsTRr,0,true)) then begin
      switch (gRuniningMaint) begin    
        case "RecalcStockMn":  ;
        otherwise
          res = 1032;
          goto LMakeTransFromProdOperation;
      end;
    end;
  end;
  gTRp.RegDate = CurrentDate;
  gTRp.RegTime = CurrentTime;
  gTRp.TransDate = ProdOpr.ProdDate;
  if (TransInFiscal(gTRp.TransDate)==false) then begin
    res = 1075;
    goto LMakeTransFromProdOperation;
  end;
  gTRp.Comment = ProdOpr.Comment;
  res = ProductionOperationTransaction(gTRp,ProdOpr);
  if (res!=0) then begin
    goto LMakeTransFromProdOperation;
  end;

  res = 0;
LMakeTransFromProdOperation:;
  MakeTransFromProdOperation = res;
  return;
end;
