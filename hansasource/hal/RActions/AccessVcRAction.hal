external procedure ExtractObj(string,var Integer,var string);
external procedure SplitEclass(string,var Array string);

global
function LongInt AccessVcRecordDefaults(var record AccessVc Accessr,record AccessVc Access2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  Accessr.StartLevel = 1;
  Accessr.OneFuncFlag = 0;
  AccessVcRecordDefaults = res; 
  RETURN;
END;

function Boolean AddToCyclicArray(string code,var array string astr,var LongInt acnt)
begin
  Boolean res;
  LongInt i;
  
  res = true;
  for (i=0;i<acnt;i=i+1) begin
    if (astr[i]==code) then begin
      res = false;
      i = acnt;
    end;
  end;
  if (res) then begin
    astr[acnt] = code;
    acnt = acnt + 1;
  end;
  AddToCyclicArray = res;
  return;
end;

procedure RemoveCyclicArray(string code,var array string astr,var LongInt acnt)
begin
  LongInt i;
  
  for (i=0;i<acnt;i=i+1) begin
    if (astr[i]==code) then begin
      astr[i] = "";
      i = acnt;
    end;
  end;
  return;
end;

function Boolean CheckCyclicAccess(record AccessVc Accessr,var array string astr,var LongInt acnt)
begin
  record AccessVc locAccessr;
  Array string 20 ac;
  Integer i;
  Boolean res;
  
  i = 0;
  SplitEclass(Accessr.AccessGroup,ac);
  while (nonblank(ac[i])) begin
    locAccessr.Code = ac[i];
    if (ReadFirstMain(locAccessr,1,true)) then begin
      if (AddToCyclicArray(locAccessr.Code,astr,acnt)==false) then begin
        res = false;
        goto LCheckCyclicAccess;
      end;
      if (CheckCyclicAccess(locAccessr,astr,acnt)==false) then begin
        res = false;
        goto LCheckCyclicAccess;
      end;
      RemoveCyclicArray(locAccessr.Code,astr,acnt);
    end;
    i = i + 1;
  end;
  res = true;
LCheckCyclicAccess:;
  CheckCyclicAccess = res;
  return;
end;

function Boolean CheckAccessGroups(record AccessVc Accessr)
begin
  array string 40 astr;
  LongInt acnt;
  Boolean res;
  
  acnt = 0;
  if (AddToCyclicArray(Accessr.Code,astr,acnt)==false) then begin
    res = false;
    goto LCheckAccessGroups;
  end;
  res = CheckCyclicAccess(Accessr,astr,acnt);
LCheckAccessGroups:;
  CheckAccessGroups = res;
  return;
end;

global
function LongInt AccessVcRecordCheck(var record AccessVc Accessr,record AccessVc Access2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  string 255 ag;
  Integer pos;
  record AccessVc lAccessr;
  row AccessVc Accessrw;
  Integer i,rwcnt;

  res = 0;
  if (len(Accessr.Code)<=0) then begin
    RecordCheckError(1270,"",-1,"Code");      
    res = -1; 
    goto LAccessVcRecordCheck;
  end;
  if (SetInSet(Accessr.Code,Accessr.AccessGroup)) then begin
    RecordCheckError(20810,"",-1,"AccessGroup");      
    res = -1;
    goto LAccessVcRecordCheck;
  end;  
  pos = 0;
  ExtractObj(Accessr.AccessGroup,pos,ag);
  while (nonblank(ag)) begin
    lAccessr.Code = ag;
    if (ReadFirstMain(lAccessr,1,true)==false) then begin
      RecordCheckError(1290," " & ag,-1,"AccessGroup");      
      res = -1;
      goto LAccessVcRecordCheck;
    end;
    ExtractObj(Accessr.AccessGroup,pos,ag);  
  end;
  if (CheckAccessGroups(Accessr)==false) then begin
    RecordCheckError(20810,"",-1,"AccessGroup");      
    res = -1;
    goto LAccessVcRecordCheck;
  end;
  rwcnt = MatRowCnt(Accessr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Accessr,i,Accessrw);
    switch (Accessrw.AccType) begin
      case kAccessTypeModule:
      case kAccessTypeRegister:
      case kAccessTypeSetting:
      case kAccessTypeReport:
        if ((Accessrw.AccLevel!=kAccessLevelNone) and (Accessrw.AccLevel!=kAccessLevelFull) and (Accessrw.AccLevel!=kAccessLevelReadOnly) and (Accessrw.AccLevel!=kAccessLevelReportNoDD)) then begin
          RecordCheckError(20812,"",i,"AccLevel");      
          res = -1;
          goto LAccessVcRecordCheck;
        end;
      case kAccessTypeDocument:
        if (Accessrw.AccLevel!=kAccessLevelNone) and (Accessrw.AccLevel!=kAccessLevelFull) then begin
          RecordCheckError(20811,"",i,"AccLevel");      
          res = -1;
          goto LAccessVcRecordCheck;
        end;
      case kAccessTypeExport:
        if (Accessrw.AccLevel!=kAccessLevelNone) and (Accessrw.AccLevel!=kAccessLevelFull) then begin
          RecordCheckError(20811,"",i,"AccLevel");      
          res = -1;
          goto LAccessVcRecordCheck;
        end;
      case kAccessTypeImport:
        if (Accessrw.AccLevel!=kAccessLevelNone) and (Accessrw.AccLevel!=kAccessLevelFull) then begin
          RecordCheckError(20811,"",i,"AccLevel");      
          res = -1;
          goto LAccessVcRecordCheck;
        end;
      case kAccessTypeMaintenance:
        if (Accessrw.AccLevel!=kAccessLevelNone) and (Accessrw.AccLevel!=kAccessLevelFull) then begin
          RecordCheckError(20811,"",i,"AccLevel");      
          res = -1;
          goto LAccessVcRecordCheck;
        end;
      case kAccessTypeAction:
      case kAccessTypeDisplayGroup:
    end;
  end;
LAccessVcRecordCheck:; 
  AccessVcRecordCheck = res;
  RETURN;
END;

global 
function Boolean AccessVcRecordShouldBeSynchronised(record AccessVc Accessr,string tagstr)
begin
  Boolean res;
  
  res = true;
  AccessVcRecordShouldBeSynchronised = res;
  return;
end;

global 
function Boolean AccessVcRecordSync(record AccessVc Accessr,string tagstr)
begin
  Boolean res;
  
  res = true;
  AccessVcRecordSync = res;
  return;
end;
