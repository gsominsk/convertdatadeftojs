external procedure AutomatedSalesOrderly(string);
external function Boolean HasIntegratedNL();
external function string 255 StripCharacter(string,string);
external function Boolean IsCapitalLetter(string); 
external function Integer InString2(string,string);
external function string 255 UpdateOfficialSerNrSerie(Integer,Integer,Integer,string,boolean);
external function string 255 GetLegalInvoiceNrSerie(row LegalInvNrBlock,string);
external procedure GetLegalInvNrRow(string,var row LegalInvNrBlock);
external procedure B1ToB2ValRM(val,val,val,var val,roundmode);
external function roundmode GetCostRoundModeRB();
external function Boolean StockRecordForLocationAllowed(string,string,string,date,integer,var Integer,var string);
external procedure VerifyRowObjects(String,String,String,String,var Integer,var String,var Boolean,Array string,Array string,var Integer);
external updating function Integer RecordAction_raPasteRetInInv(var record IVVc,LongInt);
external function string 255 NextSerialNumber(string,string,record SerNrTrackBlock);
external function Boolean IsDigit(string);
forward updating procedure RetCreateTBIV(record RetVc,Integer,row RetVc,Boolean,Integer);
external function Integer GetItemType(LongInt,LongInt,string,Integer);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external function string 60 AddObjectToObjectList(string,string);
external function Integer CheckObjs(string,string,var string);
external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external function Boolean TestNextOfficialSerialNr_RetVc(row LegalInvNrBlock,string,record RetVc,Boolean);
external function Boolean ValidateOfficialSerialNrChronology(string,string,LongInt,Date,var Date);
external updating procedure DeleteOffSerNr(LongInt,string);
external updating procedure UpdateOffSerNr(LongInt,string,Integer,string,Boolean);
external procedure FindNextRetVcOfficialSerialNr(var record SHVc);
external function Boolean DisallowFutureDateCheck(Boolean,Date,string,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure Base1ToOther(var string,val,val,val,val,val,val,var val,roundmode);
external function Integer TypeOfCurncy(var string,var Integer);
external function val FindVAT(string,val,Integer,Integer);
external procedure CalcInCurtoTBIV(var record TBIVVc);
external function Boolean TBIVItemsUsage(record PRVc,record INVc,val);
external function Boolean CheckProjectMember(record PRVc);
external function Boolean IsPRPhaseLocked(string,Date,var string);
external updating procedure UpdateTrans_Stock(record TRVc);
external function Integer IsUnOKAllowed_RetVc(record RetVc);
external updating procedure UpdateRecalcStockNeeded(Integer);
external updating procedure DeleteTransaction(LongInt,Integer);
external function Boolean ItemHistExists(string,LongInt);
external updating procedure StoreUnOKHistory(string,LongInt,Date,Time,string);
external procedure CalcPrice(val,val,val,var val,Integer);
external function Integer MakeTransFromRet(record TRVc,record RetVc,Boolean);
external updating procedure RetRowInvalidateBuyBack(record RetVc,row RetVc);
external procedure RetUpdateFIFO(var record RetVc);
external procedure GetPRInvSep(string,var Integer,var Integer);
external function Integer GetItemTypeGroup(string,var string);
external procedure GetPRName(string, var string);
external function Boolean CanOKStockRecord(var Integer);
external updating procedure RetUpdateSerialNr(record RetVc,Boolean);
external updating procedure AddTTrans_RetVc(record TRVc,record RetVc);
external function Integer CheckRates(string,val,val,val,val,val,var string);
external function Integer CheckPosition(string,string,Integer,val,val,val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean IsSerialNrCorrect(string);
external updating procedure RetUpdateCostPrice(record RetVc);
external updating procedure RetUpdateItemHist(record RetVc);
external updating procedure RetUpdateStock(record RetVc,Boolean,Boolean,vector val);
external procedure SetORFlags(record ORVc);
external procedure ORSumup(var record ORVc);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure SwapM4Val(var val,var val);
external procedure ConvertToDualBase(var string,date,var val,var val,var val,var val,var val,var val,Boolean);
external procedure B1ToB2Val(val,val,val,var val);
external updating function val NextLocOKNr(string);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure RetSumUp(var record RetVc);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external procedure GetFullCurncyRateText(Boolean,var string,val,val,val,val,val);
external function Boolean ExistStockTrans(string,Date,var Integer,var string,string,LongInt,record MainStockBlock);
external function Integer SerialNrOnThisRet(record RetVc,string,string);
external function Boolean SerialNrAvail2(string,string,val);
external function Boolean SerialNrAvail(string,string,string,val);
external function Boolean Date2Test(string,Date,string,Integer);
external function Boolean SerNrTestRetVc(LongInt,Date,var Boolean);
external function LongInt GetCurUserLastNr(string);

function Integer ValidateBulkSerialNoRow(record SerNrTrackBlock SNrb,record RetVc Retr,row RetVc Retrw,Integer currow,var string gotofield,var Integer gotorow)
begin
  Integer res;
  Integer j,rwcnt;
  row RetVc Ret2rw;
  Boolean testf;
  string 255 serialnr;
  string 255 serialnr2;
  val qty,qty2;

  gotorow = -1;
  gotofield = "";  
  if (Retrw.Quant>1) then begin
    rwcnt = len(Retrw.SerialNr);
    for (j=0;j<rwcnt;j=j+1) begin
      if ((IsDigit(Mid(Retrw.SerialNr,j,1))==false) and (Mid(Retrw.SerialNr,j,1)!=":")) then begin
        res = 20434;
        gotorow = currow;
        gotofield = "SerialNr";
        goto LValidateBulkSerialNoRow;
      end;
    end;
  end;
  rwcnt = MatRowCnt(Retr);
  serialnr = FirstInRange(Retrw.SerialNr,60);
  while (nonblank(serialnr)) begin
    if (SerialNrAvail2(Retrw.ArtCode,serialnr,1.00)==true) then begin
      res = 1241;
      gotorow = currow;
      gotofield = "SerialNr";
      goto LValidateBulkSerialNoRow;
    end;

    for (j=0;j<currow;j=j+1) begin  
      MatRowGet(Retr,j,Ret2rw);
      if (Ret2rw.Quant!=0) then begin
        if (Retrw.ArtCode==Ret2rw.ArtCode) then begin
          qty2 = blankval;
          serialnr2 = FirstInRange(Ret2rw.SerialNr,60);
          while (nonblank(serialnr2)) begin
            if (serialnr==serialnr2) then begin
              res = 1241;
              gotorow = currow;
              gotofield = "SerialNr";
              goto LValidateBulkSerialNoRow;
            end;
            qty2 = qty2 + 1;
            serialnr2 = NextSerialNumber(Ret2rw.ArtCode,serialnr2,SNrb);
            if (qty2>=Ret2rw.Quant) then begin serialnr2 = ""; end;
          end;
        end;
      end;
    end;
    qty = qty + 1;
    serialnr = NextSerialNumber(Retrw.ArtCode,serialnr,SNrb);
    if (qty>=Retrw.Quant) then begin serialnr = ""; end;
  end;
LValidateBulkSerialNoRow:;  
  ValidateBulkSerialNoRow = res;
  return;
end;

global
updating function LongInt RetVcRecordCheck(var record RetVc Retp,record RetVc Ret2p,LongInt stat,LongInt check)
BEGIN
  LongInt res;
  record MainStockBlock MSb;
  record LocationVc LocRec;
  record SRBlock SRRec;
  record INVc INr;
  record ORVc ORr;
  record PRVc PRr;
  row ORVc ORrw;
  row RetVc Retrw;
  row RetVc Ret2rw;
  record RetVc locRetr;
  record TRVc gTRp;
  Integer i,j,rwcnt,orrwcnt;
  Integer insertmode,updatemode;
  Integer errcode;
  LongInt newnr,oldnr;
  Boolean transf,gentrans,testf,test2f;
  val t;
  LongInt sernr,dummyl;
  string 20 location,costacc,oldOfficialSerNr,tstr2,c;
  val w,h,d,m;
  record INVc IN2r;
  string 255 tstr,errstr;
  record SHVc SHr;
  row SHVc SHrw;
  Boolean unokf;
  transaction string 255 gRuniningMaint;
  record LegalInvNrBlock LINrb;
  row LegalInvNrBlock LINrbrw;
  Date td;
  record CUVc CUr;
  record AccBlock ARAb;
  record CostAccBlock CAb;
  record RetGoodsBlock RGb;
  record SVOVc SVOr;
  record WSVc WSr;
  row WSVc WSrw;
  record SerNrTrackBlock SNrb;
  string 255 gotofield;
  Integer gotorow;
  Array string 255 otcheckaccs;
  Array string 255 otcheckobjtyps;
  Integer otcheckcnt;
  Boolean initotcheckf;    
  
  res = 0;
  insertmode = 1;//Rs_insert
  updatemode = 2;//Rs_update
  oldnr = Retp.SerNr;
  oldOfficialSerNr = Retp.OfficialSerNr;
  gentrans = true;
  BlockLoad(SRRec);
  BlockLoad(MSb);
  BlockLoad(ARAb);
  BlockLoad(CAb);
  BlockLoad(RGb);
  BlockLoad(SNrb);
  transf = false;
  if (Retp.OKFlag==1) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if (Ret2p.OKFlag==0) then begin transf = true; end;
    end;
  end;
  if (stat==updatemode) then begin
    if (Retp.SerNr<=0) and (Ret2p.OKFlag==0) then begin
      Retp.SerNr = Ret2p.SerNr;
    end;
  end;      
  if (Retp.OKFlag==0) then begin
    if (stat==updatemode) then begin
      if (Ret2p.OKFlag==1) then begin unokf = true; end;
    end;
  end;
  if (unokf) then begin
    errcode = IsUnOKAllowed_RetVc(Retp);
    if (errcode!=0) then begin
      RecordCheckError(errcode,"",-1,"TransDate");      
      res = -1; 
    end;
    goto LRetVcRecordCheck;
  end;  
  if (stat==Rs_update) then begin
    if (Ret2p.OKFlag!=0) then begin
      goto LRetVcRecordCheck;
    end;
  end;
  if (Retp.SerNr<=0) then begin
    newnr = GetCurUserLastNr("RetVc");
    if (newnr!=-1) then begin
       newnr = SRRec.LastPurNr;
    end;
    Retp.SerNr = NextSerNr("RetVc",Retp.TransDate,newnr,false,"");  
  end;
  switch (stat) begin
    case Rs_update:
      if (Retp.OKFlag!=0) and (Ret2p.OKFlag==0) then begin
        Retp.RegDate = CurrentDate;
        Retp.RegTime = CurrentTime;
      end;
    otherwise
      if (Retp.OKFlag!=0) then begin
        Retp.RegDate = CurrentDate;
        Retp.RegTime = CurrentTime;
      end;
  end;
  if (check>0) then begin
  if (RGb.RetGoodsNotLinkedToOR==0) then begin
    ORr.SerNr = Retp.OrdNr;
    testf = ReadFirstMain(ORr,1,true);
    SVOr.SerNr = Retp.SVONr;
    test2f = ReadFirstMain(SVOr,1,true);
    if (testf==false) and (test2f==false) then begin
      RecordCheckError(1252,"",-1,"SerNr");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  if (nonblank(ORr.PRCode)) then begin
    if (IsPRPhaseLocked(ORr.PRCode,Retp.TransDate,tstr)) then begin
      RecordCheckError(20408," " & tstr,-1,"PRCode");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
    PRr.Code = ORr.PRCode;
    if ReadFirstMain(PRr,1,true) then begin  
      if (UserCanAction("DisallowPostPRActualsfornonPRMan",false)) then begin
        if (CheckProjectMember(PRr)==false) then begin 
          RecordCheckError(1274,StringFromStringSet(3,"DisallowPostPRActualsfornonPRMan"),-1,"PRCode");    
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;              
    end else begin
      RecordCheckError(1232,"",-1,"PRCode");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  if (MSb.ForceReason!=0 and blank(Retp.Reason)) then begin
    RecordCheckError(2210,"",-1,"Reason");      
    res = -1;
    goto LRetVcRecordCheck;
  end; 
  if (blank(Retp.CustCode)) then begin
    RecordCheckError(1058,"",-1,"CustCode");      
    res = -1;
    goto LRetVcRecordCheck;
  end;
  CUr.Code = Retp.CustCode;
  if (ReadFirstMain(CUr,1,true)==false) then begin
    RecordCheckError(1120,Retp.CustCode,-1,"CustCode");      
    res = -1;
    goto LRetVcRecordCheck;
  end;
  if (CUr.CUType==0) then begin
    RecordCheckError(1120,Retp.CustCode,-1,"CustCode");      
    res = -1; 
    goto LRetVcRecordCheck;
  end;
  if (CUr.blockedFlag!=0) then begin
    RecordCheckError(1265,Retp.CustCode,-1,"CustCode");      
    res = -1;
    goto LRetVcRecordCheck;
  end;
  if (blank(Retp.EMCode)) then begin
    RecordCheckError(1231,"",-1,"EMCode");      
    res = -1;
    goto LRetVcRecordCheck;
  end;

  orrwcnt = MatRowCnt(ORr);
  if ((stat==insertmode) or (Retp.SerNr!=Ret2p.SerNr)) then begin
    locRetr.SerNr = Retp.SerNr;
    if (ReadFirstMain(locRetr,1,true)) then begin
      RecordCheckError(1547,"",-1,"SerNr");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  end;
  if (SerNrTestRetVc(Retp.SerNr,Retp.TransDate,gentrans)==false) then begin
    if (check>0) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1;
    goto LRetVcRecordCheck;
  end;
  end;
  if (check==0) then begin
    goto LRetVcRecordCheck_GenTrans;
  end;   
  if (Date2Test("RetVc",Retp.TransDate,"TransDate",-1)==false) then begin
    res = -1;
    goto LRetVcRecordCheck;
  end; 
  if (DisallowFutureDateCheck(true,Retp.TransDate,"TransDate",-1)) then begin
    res = -1;
    goto LRetVcRecordCheck;
  end;
  if (blank(Retp.Location)) then begin
    if (MSb.requireLocation!=0) then begin
      RecordCheckError(1058,Retp.Location,-1,"Location");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  errcode = CheckRates(Retp.CurncyCode,Retp.FrRate,Retp.ToRateB1,Retp.ToRateB2,Retp.BaseRate1,Retp.BaseRate2,tstr);
  if (errcode!=0) then begin
    RecordCheckError(errcode,"",-1,tstr);      
    res = -1; 
    goto LRetVcRecordCheck;
  end;       
  BlockLoad(LINrb);  
  if (nonblank(Retp.OfficialSerNr)) then begin
    GetLegalInvNrRow(Retp.OfficialSerNr,LINrbrw);
    switch (LINrbrw.SelectionType) begin
      case kLegalInvNrSelectionTypeManual:
        if (blank(LINrbrw.Serie)) then begin
          Retp.OfficialSerNr = "";
        end;
      case kLegalInvNrSelectionTypeAtOK:
        if (transf) then begin
          Retp.OfficialSerNr = "";
        end;
      case kLegalInvNrSelectionTypeAtInsert:
        if (blank(LINrbrw.Serie)) or (stat==Rs_insert) then begin
          Retp.OfficialSerNr = "";
        end;
    end;
  end;
  if (blank(Retp.OfficialSerNr)) then begin
    if (HasLocalization("PRT") and Retp.Status!=kRecordStatusManual and Retp.Status!=kRecordStatusRecovered) then begin
      FindNextRetVcOfficialSerialNr(Retp);
    end;
  end;
  if (transf) then begin
    if (HasLocalization("PRT")) then begin
      if (blank(Retp.OfficialSerNr)) then begin
        RecordCheckError(1058,"",-1,"OfficialSerNr");  
        res = -1;
        goto LRetVcRecordCheck;
      end;
    end;
  end;
  if (ValidateOfficialSerialNrChronology("RetVc",Retp.OfficialSerNr,Retp.SerNr,Retp.TransDate,td)==false) then begin
    RecordCheckError(26201," " & td,-1,"TransDate");  
    res = -1;
    goto LRetVcRecordCheck;
  end;  
  if (nonblank(Retp.OfficialSerNr)) and (MatRowCnt(LINrb)>0) then begin    
    errcode = 0;
    rwcnt = MatRowCnt(LINrb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(LINrb,i,LINrbrw);
      test2f = true;
      if (Left(Retp.OfficialSerNr,len(LINrbrw.Serie))!=LINrbrw.Serie) then begin test2f = false; end;
      if (test2f) then begin
        testf = true;
        test2f = TestNextOfficialSerialNr_RetVc(LINrbrw,CUr.Classification,Retp,false);
        if (test2f==false) then begin
          errcode = 1557;
          testf = false;
        end else begin
          i = rwcnt;
        end;
      end;
    end;
    if (testf==false) then begin
      RecordCheckError(errcode," " & Retp.OfficialSerNr,-1,"OfficialSerNr");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  if (HasLocalization("PRT")) then begin 
    if (blank(Retp.OfficialSerNrSerie)) then begin 
      Retp.OfficialSerNrSerie = UpdateOfficialSerNrSerie(stat,Retp.OKFlag,Ret2p.OKFlag,Retp.OfficialSerNr,true);
    end;
    if (Retp.Status==kRecordStatusInvalidated or Retp.Status==kRecordStatusLost or Retp.Status==kRecordStatusNotUsed) then begin
      RecordCheckError(34430,"",-1,"Status");        
      res = -1; 
      goto LRetVcRecordCheck;
    end;  
    if (Retp.Status==kRecordStatusManual or Retp.Status==kRecordStatusRecovered) then begin
      if (HasLocalization("PRT")) then begin      
        if (blank(Retp.OfficialSerNr)) then begin
          RecordCheckError(2210,"",-1,"OfficialSerNr");        
          res = -1; 
          goto LRetVcRecordCheck;
        end;
      end;
      if (blank(Retp.OfficialSerNr2)) then begin   
        RecordCheckError(2210,"",-1,"OfficialSerNr2");   
        res = -1; 
        goto LRetVcRecordCheck;
      end;
      if (nonblank(Retp.OfficialSerNr2)) then begin   
//        Retp.OfficialSerNr2Serie = UpdateOfficialSerNrSerie(stat,Retp.OKFlag,IP2p.OKFlag,Retp.OfficialSerNr2,true);
        if (InString2(Retp.OfficialSerNr2,"/")<=0) then begin
          RecordCheckError(1059," " & Retp.OfficialSerNr2,-1,"OfficialSerNr2");   
          res = -1; 
          goto LRetVcRecordCheck;
        end;
        locRetr.OfficialSerNr2 = Retp.OfficialSerNr2;
        if (ReadFirstKey("OpenOfficialSerNr2",locRetr,1,true)) then begin
          if (locRetr.SerNr!=Retp.SerNr) then begin
            RecordCheckError(1391,Retp.OfficialSerNr2,-1,"OfficialSerNr2");   
            res = -1; 
            goto LRetVcRecordCheck;
          end;
        end;
        locRetr.OfficialSerNr = StripCharacter(Retp.OfficialSerNr2,"/");
        if (ReadFirstKey("OfficialSerNr",locRetr,1,true)) then begin
          if (locRetr.SerNr!=Retp.SerNr) then begin
            RecordCheckError(1391,Retp.OfficialSerNr2,-1,"OfficialSerNr2");   
            res = -1; 
            goto LRetVcRecordCheck;
          end;
        end;
        dummyl = 0;
        GetNextSubstring(Retp.OfficialSerNr2,dummyl,"/",tstr);
        GetNextSubstring(Retp.OfficialSerNr2,dummyl,"/",tstr2);
        for (i=0;i<len(tstr);i=i+1) begin
          c = Mid(tstr,i,1);
          if (IsDigit(c)==false and (IsCapitalLetter(c)==false)) then begin
            RecordCheckError(1059," " & Retp.OfficialSerNr2,-1,"OfficialSerNr2");   
            res = -1; 
            goto LRetVcRecordCheck;
          end;
        end;
        for (i=0;i<len(tstr2);i=i+1) begin
          c = Mid(tstr2,i,1);
          if (IsDigit(c)==false) then begin
            RecordCheckError(1059," " & Retp.OfficialSerNr2,-1,"OfficialSerNr2");   
            res = -1; 
            goto LRetVcRecordCheck;
          end;
        end;
        GetLegalInvNrRow(Retp.OfficialSerNr2,LINrbrw);
        if (LINrbrw.SelectionType!=kLegalInvNrSelectionTypeManual) then begin
          RecordCheckError(2246,"",-1,"Status");   
          res = -1; 
          goto LRetVcRecordCheck;
        end;
      end;
    end;
  end;
  rwcnt = MatRowCnt(Retp);
  if (transf) then begin
    if (rwcnt==0) then begin
      RecordCheckError(1030,"",0,"ArtCode");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
  end;
  if (Retp.WSNr>0) then begin
    WSr.SerNr = Retp.WSNr;
    ReadFirstMain(WSr,1,true);
  end;
  for (i = 0;i<rwcnt;i=i+1) begin
    MatRowGet(Retp,i,Retrw);
    if (nonblank(Retrw.ArtCode)) then begin
      location = Retrw.Location;
      if (blank(location)) then begin location = Retp.Location; end;
      if (blank(location)) then begin location = MSb.MainStock; end;
      if (nonblank(location)) then begin
        LocRec.Code = location;
        if (ReadFirstMain(LocRec,1,true)==false) then begin
          RecordCheckError(1120,Retp.Location,-1,"Location");      
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;  
      if (ReadFirstItem(Retrw.ArtCode,INr,true,true)==false) then begin
        RecordCheckError(1120,Retrw.ArtCode,i,"ArtCode");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
      if (StockRecordForLocationAllowed("RetVc",location,Retrw.ArtCode,Retp.TransDate,Retp.OKFlag,errcode,errstr)==false) then begin
        RecordCheckError(errcode,errstr,i,"ArtCode");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
      costacc = Retrw.CostAcc;
      if (blank(costacc)) then begin
        costacc = ARAb.ReturnedAcc;
      end;
      if (blank(costacc)) then begin
        if (GetCOSAcc(Retrw.CostAcc,Retp.CustCode,LocRec.Code,ARAb,INr,CAb.ItemGroupAccounts,false,0,costacc,tstr)==false) then begin
        end;
      end;
      VerifyRowObjects("SL",Retp.Objects,Retrw.Objects,costacc,errcode,errstr,initotcheckf,otcheckaccs,otcheckobjtyps,otcheckcnt);                          
      if (errcode!=0) then begin
        RecordCheckError(errcode,errstr,i,"Objects");      
        res = -1; 
        goto LRetVcRecordCheck;
      end;
    end;
    if (nonblank(Retrw.ArtCode)) then begin
      if (ReadFirstItem(Retrw.ArtCode,INr,true,true)==false) then begin
        RecordCheckError(1120,Retrw.ArtCode,i,"ArtCode");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
    end;  
    if (Retrw.Quant<0) then begin
      RecordCheckError(1574,"",i,"Quant");      
      res = -1; 
      goto LRetVcRecordCheck;
    end;    
    if (nonblank(Retrw.PosCode)) then begin
      w = 0;
      h = 0;
      d = 0;
      m = Retrw.Quant/INr.QtyonPallet;
      if (INr.PalletWidth!=0) then begin w = w + INr.PalletWidth*m; end;
      if (INr.PalletHeight!=0) then begin h = h + INr.PalletHeight*m; end;
      if (INr.PalletDepth!=0) then begin d = d + INr.PalletDepth*m; end;
      for (j=0;j<i;j=j+1) begin
        MatRowGet(Retp,j,Ret2rw);
        if (Ret2rw.PosCode==Retrw.PosCode) then begin
          if (ReadFirstItem(Ret2rw.ArtCode,IN2r,true,true)) then begin
            if (IN2r.PalletWidth!=0) then begin
              w = w + IN2r.PalletWidth*m;
            end;
            if (IN2r.PalletHeight!=0) then begin
              h = h + IN2r.PalletHeight*m;
            end;
            if (IN2r.PalletDepth!=0) then begin
              d = d + IN2r.PalletDepth*m;
            end;
          end;
        end;
      end;    
      errcode = CheckPosition(Retrw.PosCode,location,LocRec.RequirePos,w,h,d);
      if (errcode!=0) then begin
        RecordCheckError(1120,Retrw.PosCode,i,"PosCode");      
        res = -1;
        goto LRetVcRecordCheck;
      end;    
    end;
    
/*
    if (HasLocalization("EST")) then begin
      if (INr.ItemType!=1) then begin
        res = SetREFErr(1301,Retrw.ArtCode,offset(RetView,Math),i,offset(RetRowType,ArtCode));
        goto LRetVcRecordCheck;
      end;
    end;
    if (HasLocalization("POL")) then
      if (INr.ItemType!=1) then begin
        res = SetREFErr(1301,Retrw.ArtCode,offset(RetView,Math),i,offset(RetRowType,ArtCode));
        goto LRetVcRecordCheck;
      end;
*/
    if (nonblank(Retrw.ArtCode)) then begin
      if (Retrw.Quant==0) then begin
        RecordCheckError(1058,"",i,"Quant");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
    end;  
    if (transf) then begin
    if (((INr.SerNrf>0) and (INr.SerNrf<3)) and (MSb.NoSerOnPU==0)) then begin
      if (blank(Retrw.SerialNr)) then begin
        RecordCheckError(1239,"",i,"SerialNr");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
      if (SNrb.BulkSerialNos==0) then begin
        if (IsSerialNrCorrect(Retrw.SerialNr)==false) then begin
          RecordCheckError(24154,Retrw.SerialNr,i,"SerialNr");      
          res = -1; 
          goto LRetVcRecordCheck;
        end;        
      end;
      switch (INr.SerNrf) begin
        case 1:  // serial nr. 
          if (SNrb.BulkSerialNos!=0) then begin
            errcode = ValidateBulkSerialNoRow(SNrb,Retp,Retrw,i,gotofield,gotorow);
            if (errcode) then begin
              RecordCheckError(errcode,"",gotorow,gotofield);      
              res = -1;
              goto LRetVcRecordCheck;
            end;
          end else begin
            for (j=0;j<i;j=j+1) begin            
              MatRowGet(Retp,j,Ret2rw);
              if ((Retrw.ArtCode==Ret2rw.ArtCode) and
                  (Retrw.SerialNr==Ret2rw.SerialNr)) then begin
                RecordCheckError(1241,"",i,"SerialNr");      
                res = -1;
                goto LRetVcRecordCheck;
              end;
            end;
            if (Retrw.Quant!=1) then begin
              RecordCheckError(1242,"",i,"Quant");      
              res = -1;
              goto LRetVcRecordCheck;
            end;
//            if (SerialNrAvail(Retrw.ArtCode,Retrw.SerialNr,location,Retrw.Quant)==true) then begin
            if (SerialNrAvail2(Retrw.ArtCode,Retrw.SerialNr,Retrw.Quant)) then begin
              RecordCheckError(1243,"",i,"SerialNr");      
              res = -1;
              goto LRetVcRecordCheck;
            end;
            if (SerialNrOnThisRet(Retp,Retrw.ArtCode,Retrw.SerialNr)>1) then begin
              RecordCheckError(1242,"",i,"Quant");      
              res = -1;
              goto LRetVcRecordCheck;
            end;
          end;
        case 2:  // batch nr. 
      end;
    end;
    end;
    if (Retrw.OrdRow==-1) then begin 
// we should be allowed to return items, eg invoice, 
//or better order an structured item (no exploding)
//and return goods, we need to return parts into stock and it is not possible!
//      RecordCheckError(1326,Retrw.ArtCode,i,"ArtCode");
//      res = -1;
//      goto LRetVcRecordCheck;
      if (UserCanAction("AllowAddingINtoRet",true)==false) then begin
        RecordCheckError(1274,StringFromStringSet(3,"AllowAddingINtoRet"),i,"ArtCode");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
      if (nonblank(Retrw.ArtCode)) then begin
        if (Retrw.OrdRow<0) and (Retrw.SHRow<0) then begin 
          if (((INr.SerNrf>0) and (INr.SerNrf<3)) and (MSb.NoSerOnPU==0)) then begin
            if (blank(Retrw.SerialNr)) then begin
              RecordCheckError(1239,"",i,"SerialNr");      
              res = -1;
              goto LRetVcRecordCheck;
            end;
          end;
        end;
        if (nonblank(ORr.PRCode)) then begin
          switch (PRr.TBIVItemsUsage) begin
            case 0:
            case 1:
              if (TBIVItemsUsage(PRr,INr,Retrw.Quant)) then begin
               MessageBox(20409,"");
              end;
            case 2:
              if (TBIVItemsUsage(PRr,INr,Retrw.Quant)) then begin
                RecordCheckError(20409,"",i,"ArtCode");      
                res = -1;
                goto LRetVcRecordCheck;
              end;
          end;
        end;
      end;  
      if (Retrw.WSRow>=0) then begin 
        ClearRow(Retp,Ret2rw,1);
        ClearRow(WSr,WSrw,1);
        if (Retrw.WSNr>0) then begin
          WSr.SerNr = Retrw.WSNr;
          ReadFirstMain(WSr,1,true);
        end;
        if (Retrw.WSRow<MatRowCnt(WSr)) then begin
          MatRowGet(WSr,Retrw.WSRow,WSrw);
        end;
        if (stat==updatemode) then begin
          MatRowGet(Ret2p,i,Ret2rw);
        end;
        if ((Retrw.Quant-Ret2rw.Quant+WSrw.Returned)>WSrw.Quant) then begin
          RecordCheckError(1733,"",i,"Quant");      
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;
      if (Retp.SVONr>0) then begin 
        if (Retrw.WSIVType==0) then begin
          RecordCheckError(2279,"",i,"WSIVType");      
          res = -1;
          goto LRetVcRecordCheck;    
        end;
        if (blank(Retrw.MotherNr)) then begin
          RecordCheckError(1058,"",i,"MotherNr");      
          res = -1;
          goto LRetVcRecordCheck;    
        end;
      end;
      goto LSKIPROW;
    end;
    if (check>0) then begin
      if (Retrw.OrdRow<orrwcnt) then begin
        MatRowGet(ORr,Retrw.OrdRow,ORrw);
        if (ORrw.ArtCode!=Retrw.ArtCode) then begin
          RecordCheckError(1120,Retrw.ArtCode,i,"ArtCode");      
          res = -1;
          goto LRetVcRecordCheck;
        end;
        if (ORrw.Shipd2<Retrw.Quant) then begin
          RecordCheckError(1303," " & Retrw.Quant,i,"Quant");      
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;
      if (Retp.SHNr>0) and (Retrw.SHRow>=0) then begin
        SHr.SerNr = Retp.SHNr;
        if (ReadFirstMain(SHr,1,true)) then begin
          MatRowGet(SHr,Retrw.SHRow,SHrw);
          if (Retrw.SerialNr!=SHrw.SerialNr) then begin
            RecordCheckError(1132," " & SHrw.SerialNr,i,"SerialNr");      
            res = -1;
            goto LRetVcRecordCheck;
          end;
        end;      
      end;
      if (LocRec.RequirePos!=0) then begin
        if (Retrw.Quant>0) and (blank(Retrw.PosCode)) then begin
          RecordCheckError(1058,"",i,"PosCode"); 
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;
    end;
LSKIPROW:;
  end;
  if (Retp.UpdStockFlag==0) then begin//no transaction when not updating stock
    transf = false;
  end;
  if (check and Retp.UpdStockFlag!=0) then begin
    RetUpdateFIFO(Retp);
  end;
  if (transf and Retp.UpdStockFlag!=0) then begin
    if (stat==updatemode) then begin
      sernr = Ret2p.SerNr;
    end;
    if (check) then begin
      if (MSb.Chronology!=0) then begin 
        if (ExistStockTrans(Retp.Location,Retp.TransDate,errcode,errstr,"RetVc", sernr,MSb)) then begin
          RecordCheckError(errcode,errstr,-1,"TransDate");      
          res = -1;
          goto LRetVcRecordCheck;
        end;
      end;
    end;
    if (CanOKStockRecord(errcode)==false) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1; 
      goto LRetVcRecordCheck;
    end;
  end;
LRetVcRecordCheck_GenTrans:;
  if (gentrans==false) then begin transf = false; end;
  if (IsStandardProduct) then begin
    transf = HasIntegratedNL and transf;
  end;
  if (transf) then begin
    errcode = MakeTransFromRet(gTRp,Retp,false);
    if (errcode!=0) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1;
      goto LRetVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (gTRp.IntYc==RetYc)) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        RecordCheckError(1085,tstr,-1,"SerNr");      
        res = -1;
        goto LRetVcRecordCheck;
      end;
      switch (gRuniningMaint) begin    
        case "RecalcStockMn":
          UpdateTrans_Stock(gTRp);          
        otherwise
          SaveTrans(gTRp);
          AddTTrans_RetVc(gTRp,Retp);
      end;
    end;    
  end;
LRetVcRecordCheck:;  
  if (res!=0) then begin
    Retp.SerNr = oldnr;
    Retp.OfficialSerNr = oldOfficialSerNr;
    Retp.OfficialSerNrSerie = "";
  end;
  RetVcRecordCheck = res;
  RETURN;
END;

global
updating function LongInt RetVcRecordSave(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
BEGIN 
  LongInt res;

  if (blankdate(Retr.RegDate)) then begin
    Retr.RegDate = CurrentDate;
  end;
  if (blanktime(Retr.RegTime)) then begin
    Retr.RegTime = CurrentTime;
  end;
  if ((Retr.OKFlag!=0) and (Retr.UpdStockFlag!=0)) then begin
    Retr.LocOKNr = NextLocOKNr(Retr.Location);
  end;
  if (blank(Retr.OfficialSerNr)) then begin
    if (HasLocalization("PRT") and Retr.Status!=kRecordStatusManual and Retr.Status!=kRecordStatusRecovered) then begin
      FindNextRetVcOfficialSerialNr(Retr);
    end;
  end;
  RetVcRecordSave = res;
  RETURN;
END;

updating procedure UpdateOrderFromRet(record RetVc Retp,record RetVc Ret2p,Boolean sh2only)
BEGIN
  Integer i,rwcnt;
  row RetVc Retrw;
  record ORVc oldORr;
  record ORVc ORr;
  row ORVc ORrw;
  Integer orw,orcnt;
  val negqty,t;
  record GeneralOptionBlock GenOptr;
  
  BlockLoad(GenOptr);
  if (RecordValid(Retp)) then begin
    ORr.SerNr = Retp.OrdNr;
  end else begin
    ORr.SerNr = Ret2p.OrdNr;
  end;
  if (ReadFirstMain(ORr,1,true)) then begin
    RecordCopy(oldORr,ORr);
    orcnt = MatRowCnt(ORr);
    if (RecordValid(Ret2p)) then begin
      rwcnt = MatRowCnt(Ret2p);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Ret2p,i,Retrw);
        if (Retrw.OrdRow!=-1) then begin
          orw = Retrw.OrdRow;
          if (orw<orcnt) then begin
            MatRowGet(ORr,orw,ORrw);
            negqty = Retrw.Quant;
            if (sh2only==false) then begin
              if (Ret2p.OKFlag!=0) then begin
                ORrw.Shipd1 = ORrw.Shipd1 - negqty;
              end;
            end;
            if (Ret2p.OKFlag!=0) then begin
              ORrw.Shipd2 = ORrw.Shipd2 - negqty;
            end;
            if (Ret2p.Type==1) then begin
              if (Ret2p.OKFlag!=0) then begin            
                ORrw.Quant = ORrw.Quant - negqty;
              end;
            end;
            if (ORrw.Quant<=0) then begin ORrw.Quant = blankval; end;
            if (ORrw.Shipd1<=0) then begin ORrw.Shipd1 = blankval; end;
            if (ORrw.Shipd2<=0) then begin ORrw.Shipd2 = blankval; end;
//            p = ORrw.Price; 
//            CalcPrice(ORrw.BasePrice,ORrw.PriceFactor,ORrw.vRebate,p,UseDiscount);
//            ORrw.Price = p;  
            CalcSum(ORrw.Quant,ORrw.Price,ORrw.PriceFactor,ORrw.vRebate,t,GenOptr.UseDiscount);
            ORrw.Sum = t;
            MatRowPut(ORr,orw,ORrw);
          end;
        end;
      end;
    end;
    if (RecordValid(Retp)) then begin
    rwcnt = MatRowCnt(Retp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Retp,i,Retrw);
        if (Retrw.OrdRow!=-1) then begin
          orw = Retrw.OrdRow;
          if (orw<orcnt) then begin
            MatRowGet(ORr,orw,ORrw);
            negqty = -Retrw.Quant;
            if (sh2only==false) then begin
              if (Retp.OKFlag!=0) then begin
                ORrw.Shipd1 = ORrw.Shipd1 + negqty;
                ORrw.Shipd2 = ORrw.Shipd2 + negqty;
                if (Retp.Type==1) then begin
                  if (Retp.OKFlag!=0) then begin
                    ORrw.Quant = ORrw.Quant + negqty;
                  end;
                end;  
              end;
            end;
            ORrw.SerialNr = Retrw.SerialNr;
            if (ORrw.Quant<=0) then begin ORrw.Quant = blankval; end;
            if (ORrw.Shipd1<=0) then begin ORrw.Shipd1 = blankval; end;
            if (ORrw.Shipd2<=0) then begin ORrw.Shipd2 = blankval; end;
//            p = ORrw.Price; 
//            CalcPrice(ORrw.BasePrice,ORrw.PriceFactor,ORrw.vRebate,p,UseDiscount);
//            ORrw.Price = p;  
            CalcSum(ORrw.Quant,ORrw.Price,ORrw.PriceFactor,ORrw.vRebate,t,GenOptr.UseDiscount);
            ORrw.Sum = t;
            MatRowPut(ORr,orw,ORrw);
          end;
        end;
      end;
    end;
    ORSumup(ORr);            
    SetORFlags(ORr);
    if (RecordUpdate(oldORr,ORr,false)==0) then begin end;
  end;
  RETURN;
END;

global
updating procedure RetCreateWSIV(record RetVc Retp,Integer rownr,row RetVc Retrw,Integer UseDiscount)
begin
  record WSIVVc WSIVr;
  record WSIVVc oldWSIVr;
  Boolean found,wsrwf;
  val t;
  val cost;
  val vatv,t1;
  roundmode roundlines,rndtotal,rndvat;
  record SVOVc SVOr;
  row SVOVc SVOrw;
  row SVOVc retSVOrw;
  Integer i,rwcnt;
  record WSVc WSr;
  row WSVc WSrw;
  record INVc INr;
  
  if (Retp.SVONr<0) then begin
    goto LRetCreateWSIV;
  end;
  ClearRow(WSr,WSrw,1);
  if (Retrw.WSNr>0) then begin
    WSr.SerNr = Retrw.WSNr;
    if (ReadFirstMain(WSr,1,true)) then begin
      if (Retrw.WSRow>=0) then begin
        if (Retrw.WSRow<MatRowCnt(WSr)) then begin
          MatRowGet(WSr,Retrw.WSRow,WSrw);
          wsrwf = true;
        end;
      end;
    end;
  end else begin
    if (Retp.WSNr>0) then begin
      WSr.SerNr = Retp.WSNr;
      if (ReadFirstMain(WSr,1,true)) then begin
        if (Retrw.WSRow>=0) then begin
          if (Retrw.WSRow<MatRowCnt(WSr)) then begin
            MatRowGet(WSr,Retrw.WSRow,WSrw);
            wsrwf = true;
          end;
        end;
      end;
    end;
  end;
  ClearRow(SVOr,retSVOrw,1);
  SVOr.SerNr = Retp.SVONr;
  if (ReadFirstMain(SVOr,1,true)) then begin
    rwcnt = MatRowCnt(SVOr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SVOr,i,SVOrw);
      if (SVOrw.SerialNr==WSrw.MotherNr) then begin
        CopyRow(SVOr,SVOrw,retSVOrw);
      end;
    end;
  end;
  ReadFirstItem(Retrw.ArtCode,INr,false,false);

  GetCurncyRoundoff(WSIVr.CurncyCode,"","WSIVVc",rndtotal,roundlines,rndvat);
  WSIVr.Type = Retrw.WSIVType;
  WSIVr.Row = rownr;
  WSIVr.SerNr = Retp.SerNr;
  WSIVr.RecType = kWSIVRecTypeReturnGoods;
  WSIVr.SVONr = Retp.SVONr;
  WSIVr.WSNr = Retrw.WSNr;
  WSIVr.ContractNr = retSVOrw.ContractNr;
  WSIVr.CurncyCode = Retp.CurncyCode;
  WSIVr.FrRate = Retp.FrRate;
  WSIVr.ToRateB1 = Retp.ToRateB1;
  WSIVr.ToRateB2 = Retp.ToRateB2;
  WSIVr.BaseRate1 = Retp.BaseRate1;
  WSIVr.BaseRate2 = Retp.BaseRate2;
  WSIVr.TransDate = Retp.TransDate;
  WSIVr.MotherNr = Retrw.MotherNr;
  WSIVr.SerialNr = Retrw.SerialNr;
  WSIVr.InvoiceTo = SVOr.InvoiceToCode;
  WSIVr.WONr = WSr.WONr;
  WSIVr.EMCode = Retp.EMCode;
  WSIVr.CUCode = Retp.CustCode;
  WSIVr.ArtCode = Retrw.ArtCode;
  WSIVr.UsedQty = Retrw.Quant;
  WSIVr.Coefficient = Retrw.Coefficient;
  WSIVr.InvQty = Retrw.Quant;
  if (WSIVr.InvQty==0) then begin WSIVr.InvQty = Retrw.Quant; end;
  if (wsrwf) then begin
    WSIVr.Price = WSrw.Price;
    WSIVr.Discount = WSrw.vRebate;
    WSIVr.CostPrice = WSrw.FIFO;
  end else begin
    WSIVr.Price = INr.UPrice1;
    WSIVr.CostPrice = Retrw.CostPrice;
  end;
  CalcSum(WSIVr.InvQty,WSIVr.Price,blankval,WSIVr.Discount,WSrw.Sum,UseDiscount);
  WSIVr.Sum = Round(WSrw.Sum,rndtotal);
  
  WSIVr.Comment = Retrw.Spec;
  WSIVr.InvNr = -1;

//  WSIVr.ItemType = GetItemCost(Retp.EMCode,WSIVr.ArtCode,Retp.Location,Retrw.Quant,Retrw.FIFO,cost);
  WSIVr.ItemType = kItemTypeStocked;
  t = MulRateToBase1(WSIVr.CurncyCode,WSIVr.Sum,WSIVr.FrRate,WSIVr.ToRateB1,WSIVr.ToRateB2,WSIVr.BaseRate1,WSIVr.BaseRate2,rndtotal);      
  WSIVr.GP = t - WSIVr.CostPrice*WSIVr.InvQty;
  RecordCopy(oldWSIVr,WSIVr);
  if (ReadFirstMain(oldWSIVr,0,true)==false) then begin
    if (RecordStore(WSIVr,false)) then begin end;
  end;
LRetCreateWSIV:;
  return;
end;

updating procedure RetRowUpdateWS(record RetVc Retr,Integer rownr,row RetVc Retrw,Boolean negf)
begin
  record WSVc WSr;
  record WSVc oldWSr;
  row WSVc WSrw;
  Boolean updf;

  WSr.SerNr = Retrw.WSNr;
  if (WSr.SerNr<0) then begin
    WSr.SerNr = Retr.WSNr;
  end;
  if (WSr.SerNr>0) then begin
  if (ReadFirstMain(WSr,1,true)) then begin
    RecordCopy(oldWSr,WSr);
    if (Retrw.WSRow>=0) then begin
      if (Retrw.WSRow<MatRowCnt(WSr)) then begin
        MatRowGet(WSr,Retrw.WSRow,WSrw);
        if (negf) then begin
          WSrw.Returned = WSrw.Returned - Retrw.Quant;
        end else begin
          WSrw.Returned = WSrw.Returned + Retrw.Quant;
        end;
        MatRowPut(WSr,Retrw.WSRow,WSrw);
        updf = true;
      end;
    end;
    if (updf) then begin
      if (RecordUpdate(oldWSr,WSr,false)==0) then begin
      end;
    end;
  end;
  end;
  return;
end;

updating procedure UpdateWSFromRet(record RetVc Retr,Boolean negf)
begin
  row RetVc Retrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(Retr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retr,i,Retrw);
    if (Retrw.Quant!=0) then begin
      RetRowUpdateWS(Retr,i,Retrw,negf);
    end;
  end;
  return;
end;

updating procedure UpdateWSIVFromRetRow(record RetVc Retr,Integer rownr,row RetVc Retrw,LongInt invnr)
begin
  Boolean found;
  record WSIVVc WSIVr;
  record WSIVVc oldWSIVr;

  found = true;
  WSIVr.CUCode = Retr.CustCode;
  WSIVr.RecType = kWSIVRecTypeReturnGoods; 
  WSIVr.SerNr = Retr.SerNr;
  WSIVr.Row = rownr;
  WSIVr.ArtCode = Retrw.ArtCode;
  WSIVr.EMCode = Retr.EMCode;
  while (LoopMain(WSIVr,0,found)) begin 
    if (WSIVr.CUCode!=Retr.CustCode) then begin found = false; end;
    if (WSIVr.RecType!=kWSIVRecTypeReturnGoods) then begin found = false; end;
    if (WSIVr.SerNr!=Retr.SerNr) then begin found = false; end;
    if (WSIVr.Row!=rownr) then begin found = false; end;
    if (WSIVr.ArtCode!=Retrw.ArtCode) then begin found = false; end;
    if (WSIVr.EMCode!=Retr.EMCode) then begin found = false; end;
    if (found) then begin
      RecordCopy(oldWSIVr,WSIVr);
      WSIVr.InvNr = invnr;
      RecordUpdate(oldWSIVr,WSIVr,false);
    end;
  end;
  return;
end;

global
updating procedure UpdateWSIVFromRet(record RetVc Retr)
begin
  row RetVc Retrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(Retr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Retr,i,Retrw);
    if (Retrw.Quant!=0) then begin
      UpdateWSIVFromRetRow(Retr,i,Retrw,Retr.InvoiceNr);
    end;
  end;
  return;
end;

updating procedure RetOK(record RetVc Retp)
BEGIN
  row RetVc Retrw;
  Integer i,rwcnt;
  record GeneralOptionBlock GenOptr;
  
  if (Retp.OKFlag==0) then begin goto LRetOK; end;
  BlockLoad(GenOptr);
  if (RecordValid(Retp)) then begin
    rwcnt = MatRowCnt(Retp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Retp,i,Retrw);
      if (Retrw.Quant!=0) then begin
        RetCreateTBIV(Retp,i,Retrw,false,GenOptr.UseDiscount);
        RetRowInvalidateBuyBack(Retp,Retrw);
        RetCreateWSIV(Retp,i,Retrw,GenOptr.UseDiscount);
//      WSUpdateSVO(WSp,WSrw);  
      end;
    end;
  end;
LRetOK:;
  RETURN;
END;

updating procedure SaveReturn(record RetVc Retp,record RetVc Ret2p,Boolean saverec)
BEGIN  
  vector val dummy_retvc;

  if (Retp.OKFlag!=0) then begin
    RetUpdateStock(Retp,false,false,dummy_retvc);
    RetUpdateCostPrice(Retp);    
    RetUpdateItemHist(Retp);
    RetUpdateSerialNr(Retp,false);
    RetOK(Retp);
  end;
  if (Retp.OrdNr!=-1) then begin
    UpdateOrderFromRet(Retp,Ret2p,false);
  end;
  RETURN;
END;


global
updating function LongInt RetVcRecordSaveAfter(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
BEGIN 
  LongInt res;
  record UserVc Userr;

  Userr.Code = Retr.Sign;
  ReadFirstMain(Userr,1,true);
  Retr.SalesGroup = Userr.SalesGroup;  
  if (Retr.OrdNr!=-1) then begin
//    UpdateOrderFromRet(Retr,Ret2r,false); done in SaveReturn
  end;
  if (nonblank(Retr.OfficialSerNr)) then begin
    UpdateOffSerNr(Retr.SerNr,"RetVc",0,Retr.OfficialSerNr,false);
  end;
  SaveReturn(Retr,Ret2r,false);
  UpdateWSFromRet(Retr,false);
  RetVcRecordSaveAfter = res;
  RETURN;
END;

updating procedure RetCreateTBIV(record RetVc Retp,Integer rownr,row RetVc retrp,Boolean setinvd,Integer UseDiscount)
BEGIN
  record TBIVVc TBIVr;
  record ORVc ORr;
  row ORVc ORrw;
  record TBIVVc locTBIVr;
  record INVc INr;
  Integer i1,i2;
  val t;
  string 255 tstr;
  record PRVc PRr;
  Integer typeofcur,oldstyle;
  Boolean basecurf;

  ORr.SerNr = Retp.OrdNr;
  if (ReadFirstMain(ORr,1,true)==false) then begin goto LRetCreateTBIV; end;
  if (blank(ORr.PRCode)) then begin goto LRetCreateTBIV; end;
  ClearRow(ORr,ORrw,1);
  if (MatRowCnt(ORr)>=retrp.OrdRow) then begin
    MatRowGet(ORr,retrp.OrdRow,ORrw);
  end;
  TBIVr.oVc = 6;
  TBIVr.SerNr = Retp.SerNr;
  TBIVr.Row = rownr;
  TBIVr.TransDate = Retp.TransDate;
  TBIVr.EMCode = "";
  TBIVr.PRCode = ORr.PRCode;
  PRr.Code = TBIVr.PRCode;
  ReadFirstMain(PRr,1,true);
  TBIVr.PRName = PRr.Name;
  TBIVr.ArtCode = retrp.ArtCode;
  TBIVr.ItemType = GetItemTypeGroup(TBIVr.ArtCode,TBIVr.INGroup);
  if (TBIVr.ItemType==0) then begin TBIVr.ItemType = 5; end;
  TBIVr.Objects = ORr.Objects;
  TBIVr.Qty = -retrp.Quant;
  TBIVr.Comment = Retp.Comment;
  GetPRInvSep(ORr.PRCode,i1,i2);
  TBIVr.InvSeparately = i1;
  TBIVr.InvQty = -retrp.Quant;
  TBIVr.Invoice = -1;
  if (setinvd) then begin TBIVr.Invoice = -2; end;
  TBIVr.CurncyCode = PRr.CurncyCode;  

  TBIVr.CurncyCode = ORr.CurncyCode;  
  TBIVr.FrRate = ORr.FrRate;
  TBIVr.ToRateB1 = ORr.ToRateB1;
  TBIVr.ToRateB2 = ORr.ToRateB2;
  TBIVr.BaseRate1 = ORr.BaseRate1;
  TBIVr.BaseRate2 = ORr.BaseRate2;
  if (ORr.InclVAT>0) then begin
    t = FindVAT(ORrw.VATCode,ORrw.Price,ORr.InclVAT,ORr.NoTAXonVAT);
    t = ORrw.Price - t;
  end else begin
    t = ORrw.Price;
  end;
  TBIVr.Price = t;

//when price is zero, we use zero when creating Project Transactions from Deliveries so same should be from returned goods

  if (blank(TBIVr.Price)) then begin
    INr.Code = retrp.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin TBIVr.Price = INr.UPrice1; end;
  end;
  
  
  TBIVr.Discount = ORrw.vRebate;
  TBIVr.CostPrice = retrp.CostPrice;

  typeofcur = TypeOfCurncy(ORr.CurncyCode,oldstyle);   
  if (nonblank(PRr.CurncyCode)) then begin
    if (ORr.CurncyCode==PRr.CurncyCode) then begin //EUR USD
      switch (typeofcur) begin
        case 0://Foreign
          TBIVr.PriceInCur = t;
          if (ORrw.PriceFactor!=0) then begin
            TBIVr.PriceInCur = TBIVr.PriceInCur/ORrw.PriceFactor;
          end;
          CalcSum(TBIVr.InvQty,TBIVr.PriceInCur,0,TBIVr.Discount,t,UseDiscount);
          TBIVr.SumInCur = t;
          Base1ToOther(TBIVr.CurncyCode,TBIVr.CostPrice,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.CostPriceInCur,DefaultCurRoundOff);
          TBIVr.GPInCur = TBIVr.CostPriceInCur*TBIVr.Qty;
          TBIVr.GPInCur = TBIVr.SumInCur - TBIVr.GPInCur;

          TBIVr.GP = MulRateToBase1(TBIVr.CurncyCode,TBIVr.GPInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          TBIVr.Sum = MulRateToBase1(TBIVr.CurncyCode,TBIVr.SumInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          TBIVr.Price = MulRateToBase1(TBIVr.CurncyCode,TBIVr.PriceInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
        case 1://Base Curncy 1 
          basecurf = true;
        case 2://Base Curncy 2
          TBIVr.PriceInCur = t;
          if (ORrw.PriceFactor!=0) then begin
            TBIVr.PriceInCur = TBIVr.PriceInCur/ORrw.PriceFactor;
          end;
          CalcSum(TBIVr.InvQty,TBIVr.PriceInCur,0,TBIVr.Discount,t,UseDiscount);
          TBIVr.SumInCur = t;
          Base1ToOther(TBIVr.CurncyCode,TBIVr.CostPrice,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,TBIVr.CostPriceInCur,DefaultCurRoundOff);
          TBIVr.GPInCur = TBIVr.CostPriceInCur*TBIVr.Qty;
          TBIVr.GPInCur = TBIVr.SumInCur - TBIVr.GPInCur;

          TBIVr.GP = MulRateToBase1(TBIVr.CurncyCode,TBIVr.GPInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          TBIVr.Sum = MulRateToBase1(TBIVr.CurncyCode,TBIVr.SumInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          TBIVr.Price = MulRateToBase1(TBIVr.CurncyCode,TBIVr.PriceInCur,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
        case 3://Blank Currency, old style 
          basecurf = true;
      end;
    end else begin
      switch (typeofcur) begin
        case 0://Foreign
          TBIVr.Price = MulRateToBase1(TBIVr.CurncyCode,t,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          basecurf = true;
        case 1://Base Curncy 1 
          basecurf = true;
        case 2://Base Curncy 2
          TBIVr.Price = MulRateToBase1(TBIVr.CurncyCode,t,TBIVr.FrRate,TBIVr.ToRateB1,TBIVr.ToRateB2,TBIVr.BaseRate1,TBIVr.BaseRate2,DefaultCurRoundOff);    
          basecurf = true;
        case 3://Blank Currency, old style 
          basecurf = true;
      end;    
    end;
  end else begin
    basecurf = true;
  end;
  if (basecurf) then begin
    if (ORrw.PriceFactor!=0) then begin
      TBIVr.Price = TBIVr.Price/ORrw.PriceFactor;
    end;
    CalcSum(TBIVr.InvQty,TBIVr.Price,0,TBIVr.Discount,t,UseDiscount);
    TBIVr.Sum = t;
    TBIVr.GP = blankval;
    TBIVr.GP = TBIVr.CostPrice*TBIVr.Qty;
    TBIVr.GP = TBIVr.Sum - TBIVr.GP;
    CalcInCurtoTBIV(TBIVr);
  end;  
  RecordCopy(locTBIVr,TBIVr);  
  if (ReadFirstMain(locTBIVr,0,true)==false) then begin
    if (RecordInsert(TBIVr,false)) then begin
    end;
  end;
LRetCreateTBIV:;
  RETURN;
END;

global
updating function LongInt RetVcRecordUpdate(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
BEGIN 
  LongInt res;

  if ((Retr.OKFlag!=0) and (Ret2r.OKFlag==0)) then begin  
    if (Retr.UpdStockFlag!=0) then begin
      if (ItemHistExists("RetVc",Retr.SerNr)==false) then begin
        Retr.LocOKNr = NextLocOKNr(Retr.Location);
      end;
    end;
  end;
  RetVcRecordUpdate = res;
  RETURN;
END;

global
updating procedure UnOKCustomerReturn(record RetVc Retr,record RetVc Ret2r,Boolean deltrf)
begin
  vector val dummy_retvc;

  RetUpdateStock(Retr,true,false,dummy_retvc);
//  RetUpdateCostPrice(Retr);//JJRECALCSTOCK
  RetUpdateSerialNr(Retr,true);
//  RetOK(Retr);//JJRECALCSTOCK
  if (Retr.OrdNr!=-1) then begin
//    UpdateOrderFromRet(Retr,Ret2r,false);//JJRECALCSTOCK
  end;
  UpdateRecalcStockNeeded(1);
  StoreUnOKHistory("RetVc",Retr.SerNr,CurrentDate,CurrentTime,CurrentUser);    
  if (deltrf) then begin
    DeleteTransaction(Retr.SerNr,RetYc);
  end;
  return;
end;

global
updating function LongInt RetVcRecordUpdateAfter(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
BEGIN 
  LongInt res;
  Boolean ihef;
  record IVVc IVr;
  record IVVc oldIVr;
  Integer errcode;
  record OrdSettBlock OSb;
  vector val dummy_retvc;
  
  ihef = ItemHistExists("RetVc",Retr.SerNr);
  if ((Retr.OKFlag!=0) and (Ret2r.OKFlag!=0)) then begin
  end else begin
    if ((Retr.OKFlag!=0) and (Ret2r.OKFlag==0)) then begin
      BlockLoad(OSb);
      RetUpdateStock(Retr,false,false,dummy_retvc);
      if (ihef==false) then begin
        RetUpdateCostPrice(Retr);
        RetUpdateItemHist(Retr);
      end;
      RetUpdateSerialNr(Retr,false);
      if (ihef==false) then begin
        RetOK(Retr);
      end;
      AutomatedSalesOrderly("HasIntegratedNL");
    end;
    if (Retr.OrdNr!=-1) then begin
      UpdateOrderFromRet(Retr,Ret2r,false);
    end;
    UpdateWSFromRet(Ret2r,true);
    UpdateWSFromRet(Retr,false);
    if ((Retr.OKFlag!=0) and (Ret2r.OKFlag==0)) then begin
      if (ihef==false) then begin
        if (OSb.CreateIVonRetOK!=0) then begin
          if (RecordAction_raPasteRetInInv(IVr,Retr.SerNr)==1) then begin
            RecordCopy(oldIVr,IVr);
            IVr.OKFlag = 1;
            RecordUpdate(oldIVr,IVr,true);
          end;
        end;
      end;
    end;
  end;
//  if ((IVr.Invalid==0) and (IV2r.Invalid==0)) then begin
  if ((Retr.OKFlag==0) and (Ret2r.OKFlag!=0)) then begin//unok
    UnOKCustomerReturn(Retr,Ret2r,true);
  end;
  if (nonblank(Retr.OfficialSerNr)) then begin
    if (Retr.OfficialSerNr!=Ret2r.OfficialSerNr) then begin
      UpdateOffSerNr(Retr.SerNr,"RetVc",0,Retr.OfficialSerNr,true);
    end;
  end else begin
    if (nonblank(Ret2r.OfficialSerNr)) then begin
      DeleteOffSerNr(Ret2r.SerNr,"RetVc");
    end;
  end;
  RetVcRecordUpdateAfter = res;
  RETURN;
END;

global
function LongInt RetVcRecordRemoveTest(var record RetVc Retr,record RetVc Ret2r,LongInt long3,LongInt long4)
BEGIN
  LongInt res;
  record DBLockBlock DBLockRec;

  res = 1;
  BlockLoad(DBLockRec);
  if (Retr.TransDate<=DBLockRec.DeleteBeforeDate) then begin
    res = 1;
    goto LRetVcRecordRemoveTest;
  end;
  if (Retr.OKFlag!=0) then begin
    if (long3>0) then begin
      MessageBox(1544,"");
    end;
    res = 0;
  end;    
LRetVcRecordRemoveTest:;
  RetVcRecordRemoveTest = res; 
  RETURN;
END;

global
updating function LongInt RetVcRecordRemove(var record RetVc Retr,record RetVc Ret2r,LongInt long3,LongInt long4)
BEGIN
  LongInt res;
  vector val dummy_retvc;

  if (Retr.OrdNr!=-1) then begin
    UpdateOrderFromRet(Ret2r,Retr,false);
  end;
  if (Retr.OKFlag!=0) then begin
    RetUpdateStock(Retr,true,false,dummy_retvc);
  end;
  if (nonblank(Retr.OfficialSerNr)) then begin 
    DeleteOffSerNr(Retr.SerNr,"RetVc");
  end;
  UpdateWSFromRet(Retr,true);
LRetVcRecordRemove:;
  RetVcRecordRemove = res; 
  RETURN;
END;

global
updating function LongInt RetVcRecordImport(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  val t,fr,to1,to2,br1,br2;
  string 5 curncy;
  Boolean gBase1ToBase2,gToDualBase;
  record ConvMasterBlock cvm;
  Integer i,rwcnt;
  row RetVc Retrw;
  row LegalInvNrBlock LINrbrw;

  BlockLoad(cvm);
  if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
  if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
  if (gToDualBase) then begin
    curncy = Retr.CurncyCode;
    fr = Retr.FrRate;
    to1 = Retr.ToRateB1;
    to2 = Retr.ToRateB2;
    br1 = Retr.BaseRate1;
    br2 = Retr.BaseRate2;
    ConvertToDualBase(curncy,Retr.TransDate,fr,to1,to2,br1,br2,t,false);
    Retr.CurncyCode = curncy;
    Retr.FrRate = fr;
    Retr.ToRateB1 = to1;
    Retr.ToRateB2 = to2;
    Retr.BaseRate1 = br1;
    Retr.BaseRate2 = br2;
  end;
  if (gBase1ToBase2) then begin
    curncy = Retr.CurncyCode;
    fr = Retr.FrRate;
    to1 = Retr.ToRateB1;
    to2 = Retr.ToRateB2;
    br1 = Retr.BaseRate1;
    br2 = Retr.BaseRate2;
    SwapM4Val(br1,br2);
    SwapM4Val(to1,to2);
    rwcnt = MatRowCnt(Retr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Retr,i,Retrw);
      B1ToB2ValRM(Retrw.UPrice,br1,br2,t,GetCostRoundModeRB);
      Retrw.UPrice = t;
      if (Mid(Retrw.Extra,len(Retrw.Extra)-1,1)!="%") then begin
        t = StringToVal(Retrw.Extra,M45Val);
        B1ToB2ValRM(t,br1,br2,t,GetCostRoundModeRB);
        Retrw.Extra = t;
      end;
      B1ToB2ValRM(Retrw.CostPrice,br1,br2,t,GetCostRoundModeRB);
      Retrw.CostPrice = t;
      MatRowPut(Retr,i,Retrw);
    end;
    Retr.CurncyCode = curncy;
    Retr.FrRate = fr;
    Retr.ToRateB1 = to1;
    Retr.ToRateB2 = to2;
    Retr.BaseRate1 = br1;
    Retr.BaseRate2 = br2;
    RetSumUp(Retr);    
  end;  
  if (blank(Retr.OfficialSerNrSerie)) then begin
    GetLegalInvNrRow(Retr.OfficialSerNr,LINrbrw);
    Retr.OfficialSerNrSerie = GetLegalInvoiceNrSerie(LINrbrw,Retr.OfficialSerNr);
  end;
  RetVcRecordImport = res;
  RETURN;
END;

global
updating function LongInt RetVcRecordImportAfter(var record RetVc Retr,record RetVc Ret2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  Integer err;
  vector val dummy_retvc;
  
  if (Retr.OKFlag!=0) then begin
    RetUpdateSerialNr(Retr,false);
    if (ImportingTextBackup==false and CanOKStockRecord(err)==true) then begin
      RetUpdateStock(Retr,false,false,dummy_retvc);
      RetUpdateCostPrice(Retr);    
      RetUpdateItemHist(Retr);
    end;
  end;
  RetVcRecordImportAfter = res;
  RETURN;
END;
