external function LongInt GetCurUserLastNr(string);
external function Integer CreateCreditNoteIV(record IVVc,Integer,var record IVVc,string,Boolean);
external procedure IPVc_PasteRecCurncy(var record IPVc,Integer);
external procedure IPVc_PasteRecVal(var record IPVc,Integer);
external function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external updating procedure CancelStripeSubscriptionIfNeeded(string,string);

global
function LongInt SubscriptionVcRecordDefaults(var record SubscriptionVc Subr,record SubscriptionVc Sub2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  Subr.SerNr = -1;
  SubscriptionVcRecordDefaults = res; 
  return;
end;  

global
function LongInt SubscriptionVcRecordDuplicate(var record SubscriptionVc Subr,record SubscriptionVc Sub2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  Date bd;
  
  Subr.SerNr = -1;
  Subr.PaidUntilDate = bd;
  Subr.IssuedUntilDate = bd;
  Subr.Closed = 0;
  SubscriptionVcRecordDuplicate = res; 
  return;
end;  

global
function LongInt SubscriptionVcRecordCheck(var record SubscriptionVc Subr,record SubscriptionVc Sub2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  res = 0;
  if (Subr.SerNr<0) then begin
    Subr.SerNr = NextSerNr("SubscriptionVc",CurrentDate,-1,false,"");
  end;
  SubscriptionVcRecordCheck = res; 
  return;
end;  

global
function LongInt SubscriptionVcRecordInIndex(record SubscriptionVc Subr,string indexname)
begin
  LongInt res;
  
  res = 1;
  if (Subr.Closed!=0) then begin 
    if (indexname=="ActCUCode") then begin res = 0; end;
    if (indexname=="ActCUName") then begin res = 0; end;
    if (indexname=="ActPaidUntilDate") then begin res = 0; end;
    if (indexname=="ActSubIN") then begin res = 0; end;
    if (indexname=="ActSubINPackageCode") then begin res = 0; end;
  end;
  SubscriptionVcRecordInIndex = res;
  return;
end;  

global
updating function LongInt SubscriptionVcRecordUpdateAfter(record SubscriptionVc Subr,record SubscriptionVc Sub2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  record SubscriptionVc Sub3r;
  
  if (Subr.Closed!=0 and Sub2r.Closed==0) then begin
    Sub3r.CUCode = Subr.CUCode;
    if (ReadFirstKey("ActCUCode",Sub3r,1,true)==false) then begin
      CancelStripeSubscriptionIfNeeded(Subr.CUCode,Subr.Currency);
    end;
  end;
  
  SubscriptionVcRecordUpdateAfter = res; 
  return;
end;

global
function LongInt SubscriptionTransVcRecordDefaults(var record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  STr.SerNr = -1;
  STr.CreatedDate = CurrentDate;
  SubscriptionTransVcRecordDefaults = res; 
  return;
end;  

global
function LongInt SubscriptionTransVcRecordDuplicate(var record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  Date bd;
  
  STr.SerNr = -1;
  STr.CreatedDate = CurrentDate;
  STr.PaidDate = bd;
  STr.Paid = 0;
  SubscriptionTransVcRecordDuplicate = res; 
  return;
end;  

global
function LongInt SubscriptionTransVcRecordCheck(var record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  res = 0;
  if (STr.SerNr<0) then begin
    STr.SerNr = NextSerNr("SubscriptionTransVc",STr.CreatedDate,-1,false,"");
  end;
  SubscriptionTransVcRecordCheck = res; 
  return;
end;  

global
procedure SetSubscriptionTransFlags(record SubscriptionTransVc STr)
begin
  switch (STr.Paid) begin
    case 0: STr.PaidMark = 0;
    case 1: STr.PaidMark = 18;
    case 2: STr.PaidMark = 45;
  end;
  return;
end;

updating procedure SubscriptionTransUpdateAR(record SubscriptionTransVc STr,Boolean negf)
begin
  record ARVc ARr;
  record ARVc oldARr;
  Boolean found;
  Boolean delf,ratef;
  val bv,t;
  record BaseCurBlock bcur;
  record CUVc CUr;
  record IVVc IVr;
  val fr,br1,br2,to1,to2;
  string 255 curncy;

  if (STr.Amount!=0) then begin
    delf = false;
    ARr.InvoiceNr = STr.InvoiceNo;
    found = ReadFirstMain(ARr,1,true);
    if (found) then begin
      IVr.SerNr = STr.InvoiceNo;
      if (ReadFirstMain(IVr,1,true)) then begin
        if (IVr.Invalid!=0) then begin goto LSubscriptionTransUpdateAR; end;
        fr = IVr.FrRate;
        to1 = IVr.ToRateB1;
        to2 = IVr.ToRateB2;
        br1 = IVr.BaseRate1;
        br2 = IVr.BaseRate2;
        ratef = true;
      end;
    end;
    RecordCopy(oldARr,ARr);
    if (ratef) then begin
      bv = MulRateToBase1(STr.CurrencyCode,STr.Amount,fr,to1,to2,br1,br2,DefaultCurRoundOff);
    end else begin
      bv = MulWithRateToBase1(STr.CurrencyCode,STr.PaidDate,STr.Amount,DefaultCurRoundOff);
    end;
    if (negf) then begin
      ARr.RVal = ARr.RVal + STr.Amount;
      ARr.BookRVal = ARr.BookRVal + bv;
    end else begin
      ARr.RVal = ARr.RVal - STr.Amount;
      ARr.BookRVal = ARr.BookRVal - bv;
    end;
    if (ARr.RVal==0) then begin delf = true; end;    
    if (delf==false) then begin
      if (found) then begin
        if (ARr.InvoiceNr!=-1) then begin
          if (RecordUpdate(oldARr,ARr,false)==0) then begin end;
        end;
      end else begin
        if (ARr.InvoiceNr!=-1) then begin
          if (RecordStore(ARr,false)) then begin end;
        end;
      end;
    end else begin
      if (found==true) then begin
        RecordDelete(oldARr);
      end;
    end;
/*    
    BlockLoad(bcur);
    t = -CLInrw.Sum;
    CUr.Code = CLInrw.Company;
    if (ReadFirstMain(CUr,1,true)) then begin end;
    if ((blank(CUr.CurncyCode)) or (CUr.CurncyCode==bcur.BaseCur1)) then begin          
      IVr.SerNr = CLInrw.TransNr;
      if (ReadFirstMain(IVr,1,true)) then begin 
        t = -MulRateToBase1(IVr.CurncyCode,CLInrw.Sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);    
      end else begin    
        t = -MulRateToBase1(CLInr.CurncyCode,CLInrw.Sum,CLInr.FrRate,CLInr.ToRateB1,CLInr.ToRateB2,CLInr.BaseRate1,CLInr.BaseRate2,DefaultCurRoundOff);    
      end;
    end;
    CustStatUp("CLInVc",CLInr.SerNr,CLInrw.Company,CLInrw.Company,"","",CLInr.TransDate,0,0,t,0,bv,0,!negf);
*/    
  end;
LSubscriptionTransUpdateAR:;  
  return;
end;

updating procedure SubscriptionTransUpdateSubscriptions(record SubscriptionTransVc STr,Integer prevpaidstate,Boolean negf)
begin
  record SubscriptionVc Subr;
  record SubscriptionVc oldSubr;
  row SubscriptionTransVc STrw;
  Integer i,rwcnt,err;
  
  if (STr.Paid==1) then begin
    if (blankdate(STr.PaidDate)) then begin
      goto LSubscriptionTransUpdateSubscriptions;
    end;
  end;
  rwcnt = MatRowCnt(STr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(STr,i,STrw);
    Subr.SerNr = STrw.Subscription;
    if (ReadFirstMain(Subr,1,true)) then begin
      RecordCopy(oldSubr,Subr);
      switch (STr.Paid) begin
        case 1://paid
          switch (prevpaidstate) begin
            case 3://from HansaMail
              Subr.PaidUntilDate = STrw.PeriodEndDate;
            otherwise
              Subr.PaidUntilDate = STr.PaidDate;
              if (Subr.PaidUntilDate<STrw.PeriodEndDate) then begin
                Subr.PaidUntilDate = STrw.PeriodEndDate;
              end;
          end;
        case 2://payment Failed
          Subr.EndDate = CurrentDate;
          switch (prevpaidstate) begin
            case 3://from HansaMail
              if (STrw.PeriodEndDate>Subr.EndDate) then begin
                Subr.EndDate = STrw.PeriodEndDate;
              end;
            otherwise
              if (nonblankdate(Subr.PaidUntilDate)) then begin
                if (Subr.PaidUntilDate>=Subr.EndDate) then begin
                  Subr.EndDate = AddDay(Subr.PaidUntilDate,1);
                end;
              end;
          end;
      end;
      err = RecordUpdate(oldSubr,Subr,false);
    end;
  end;
LSubscriptionTransUpdateSubscriptions:;  
  return;
end;

updating procedure SubscriptionTransUpdateStats(record SubscriptionTransVc STr,Boolean negf)
begin
  if (STr.InvoiceNo>0) then begin
//    SubscriptionTransUpdateAR(STr,negf);
  end;
  return;
end;  

updating procedure SubscriptionTransCreateCreditNote(record SubscriptionTransVc STr)
begin
  record IVVc IVr;
  record IVVc IVCreditr;
  Integer oldcomp;
  Boolean nousersernr;
  LongInt newnr;
  record SRBlock SRb;
  
  oldcomp = CurrentCompany;
  if (SetCompanyCode(STr.InvoiceCompCode,false)) then begin
    BlockLoad(SRb);
    IVr.SerNr = STr.InvoiceNo;
    if (ReadFirstMain(IVr,1,true)) then begin
      CreateCreditNoteIV(IVr,kInvoiceTypeCredit,IVCreditr,"",false);      
      newnr = SRb.LastCredInvNr;
      nousersernr = true;
      if (newnr==-1) then begin
        newnr = GetCurUserLastNr("IVVc");
        nousersernr = false;
      end;
      IVCreditr.SerNr = NextSerNr("IVVc",IVCreditr.TransDate,newnr,nousersernr,IVCreditr.LangCode);
      if (IVCreditr.SerNr>0) then begin
        RecordStore(IVCreditr,false);
        RecordCopy(IVr,IVCreditr);
        IVCreditr.OKFlag = 1;
        RecordUpdate(IVr,IVCreditr,true);
      end;
    end;
  end;
  ResetCompany(oldcomp);
  return;
end;

global
updating procedure SubscriptionTransCreateIP(record SubscriptionTransVc STr)
begin
  record IPVc IPr;
  record IPVc oldIPr;
  row IPVc IPrw;
  Integer rownr;
  val chk;
  Boolean installmentf;
  Integer oldcomp;
  
  oldcomp = CurrentCompany;
  if (nonblank(STr.InvoiceCompCode)) then begin
    SetCompanyCode(STr.InvoiceCompCode,false);
  end;
  RecordNew(IPr);
  if (IPr.SerNr<0) then begin
    IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
  end;
  rownr = MatRowCnt(IPr);
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = STr.InvoiceNo;
  MatRowPut(IPr,rownr,IPrw);
  PasteInvIn2IPr(IPr,rownr,IPr.TransDate,chk,false,installmentf);
  MatRowGet(IPr,rownr,IPrw);
  IPrw.RecCurncy = STr.CurrencyCode;
  MatRowPut(IPr,rownr,IPrw);
  IPVc_PasteRecCurncy(IPr,rownr);
  MatRowGet(IPr,rownr,IPrw);
  IPrw.RecVal = STr.Amount;
  MatRowPut(IPr,rownr,IPrw);
  IPVc_PasteRecVal(IPr,rownr);
  MatRowGet(IPr,rownr,IPrw);
  RecordStore(IPr,false);
  RecordCopy(oldIPr,IPr);
  IPr.OKFlag = 1;
  RecordUpdate(oldIPr,IPr,true);
  ResetCompany(oldcomp);
  return;
end;  

global
function LongInt SubscriptionTransVcRecordSave(record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  if (STr.Paid!=0) then begin
    SetSubscriptionTransFlags(STr);
  end;
  SubscriptionTransVcRecordSave = res; 
  return;
end;  

global
updating function LongInt SubscriptionTransVcRecordSaveAfter(record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  if (STr.Paid==1) then begin//Paid
    SubscriptionTransUpdateSubscriptions(STr,-1,false);
    SubscriptionTransCreateIP(STr);
  end;
  if (STr.Paid==2) then begin//Payment Failed
    SubscriptionTransUpdateSubscriptions(STr,-1,false);
    SubscriptionTransCreateCreditNote(STr);
  end;
  SubscriptionTransVcRecordSaveAfter = res; 
  return;
end;  

global
function LongInt SubscriptionTransVcRecordUpdate(record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  if (STr.Paid!=0) and (ST2r.Paid!=STr.Paid) then begin
    SetSubscriptionTransFlags(STr);
  end;
  SubscriptionTransVcRecordUpdate = res; 
  return;
end;  

global
function LongInt SubscriptionTransVcRecordImport(record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  if (STr.Paid!=0) then begin
    SetSubscriptionTransFlags(STr);
  end;
  SubscriptionTransVcRecordImport = res; 
  return;
end;  

global
updating function LongInt SubscriptionTransVcRecordUpdateAfter(record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  if (STr.Paid==1) and (ST2r.Paid==0 or ST2r.Paid==3) then begin//Paid
    SubscriptionTransUpdateSubscriptions(STr,ST2r.Paid,false);
    if (ST2r.Paid!=3) then begin
      SubscriptionTransCreateIP(STr);
    end;
  end;
  if (STr.Paid==2) and (ST2r.Paid==0 or ST2r.Paid==3) then begin//Payment Failed
    SubscriptionTransUpdateSubscriptions(STr,ST2r.Paid,false);
    if (ST2r.Paid!=3) then begin
      SubscriptionTransCreateCreditNote(STr);
    end;
  end;
  SubscriptionTransVcRecordUpdateAfter = res; 
  return;
end;  

global
function LongInt SubscriptionTransVcRecordRemoveTest(var record SubscriptionTransVc STr,record SubscriptionTransVc ST2r,LongInt long3,LongInt long4)
begin
  LongInt res;

  res = 1;
  if (nonblank(STr.CUCode)) then begin
    if (STr.InvoiceNo>0) then begin res = 0; end;
    if (STr.Paid!=0) then begin res = 0; end;
  end;
  SubscriptionTransVcRecordRemoveTest = res;  
  return;
end;  
