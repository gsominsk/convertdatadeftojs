external function Boolean StockRecordForLocationAllowed(string,string,string,date,integer,var Integer,var string);
external function Boolean DisallowFutureDateCheck(Boolean,Date,string,Integer);
external function roundmode SetRoundModeD(Integer);
external updating procedure UpdateTrans_Stock(record TRVc);
external function Integer IsUnOKAllowed_ProdVc(record ProdVc);
external updating procedure DeleteTransaction(LongInt,Integer);
external function Boolean ItemHistExists(string,LongInt);
external updating procedure StoreUnOKHistory(string,LongInt,Date,Time,string);
external updating procedure UpdateRecalcStockNeeded(Integer);
external function Integer MakeTransFromProd(record TRVc,record ProdVc,Boolean);
//external updating procedure CreateQualConFromProdOnSave(record ProdVc);
external procedure SDSumUp(var record SDVc);
external function Integer CheckObjs(string,string,var string);
external function Boolean CanOKStockRecord(var Integer);
external updating procedure ProdUpdateItemHistory(record ProdVc,record ProdVc);
external updating procedure ProdUpdateSerialNr(record ProdVc,record ProdVc,Boolean);
external updating procedure AddTTrans_ProdVc(record TRVc,record ProdVc);
external updating procedure UpdatePosition(string,string,string,val,val,val);
external updating procedure UpdateProdOrd(record ProdOrderVc,Boolean,val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure CalcProdDuration(var record ProdOrderVc);
external function Boolean IsSerialNrCorrect(string);
external updating procedure ProdUpdateCostPrice(record ProdVc,Boolean);
external updating function val NextLocOKNr(string);
external function Boolean ShouldItemUpdateStock(string);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating procedure UpdatePlanned(string,string,string,LongInt,Date,val,Integer,val,val,Boolean);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external procedure ProdFillFIFO(record ProdVc,Boolean);
external function Boolean ExistStockTrans(string,Date,var Integer,var string,string,LongInt,record MainStockBlock);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external function Boolean SerialNrAvail(string,string,string,val);
external function Boolean SerialNrAvail2(string,string,val);
external function Integer CheckSerialStatus(string,string,var string);
external function Boolean CheckAllowedSize(record INVc,val,val,val);
external function Boolean Date2Test(string,Date,string,Integer);
external function Boolean SerNrTestProdVc(LongInt,Date,var Boolean);
external updating procedure ProdCalcItemCost(var record ProdVc,record ProdVc,Boolean);


function
Boolean CheckUnitCalcDimQty(record INVc INp)
BEGIN
  record UnitVc Unitr;
  Boolean res;

  Unitr.Code = INp.Unittext;
  if (ReadFirstMain(Unitr,1,true)) then begin
    if (Unitr.CalcDimQty!=0) then begin
      res = true;
    end;
  end;
  RETURN;
END;

function
Boolean ProdCheckVolume(record ProdVc Prodp,Integer currow)
BEGIN
/*if one has 2 items in it will not find volume mistakes if invol==outvol and 
  initem1
  outitem1
  initem2
  outitem2
  outitem1<- should be before initem2
*/
  Boolean res;
  row ProdVc Prodrwp;
  row ProdVc  Prodrw;
  Integer i,rwcnt;
  val t,invol,outvol;
  record INVc INr;
  
  MatRowGet(Prodp,currow,Prodrw);
  res = true;
  if (Prodrwp.InQty==0) then begin      
    goto LProdCheckVolume;
  end;
  t = Prodrwp.UnitXval*Prodrwp.UnitYval;
  invol = t*Prodrwp.UnitZval;
  rwcnt = MatRowCnt(Prodp);
  for (i=currow+1;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    if (ReadFirstItem(Prodrw.Item,INr,true,true)==false) then begin
      if (Prodrw.InQty!=0) then begin      
        goto L88ProdCheckVolume;
      end;
      if (INr.ItemType==1) then begin
        goto L88ProdCheckVolume;
      end;
    end;
    if (Prodrw.OutQty!=0) then begin
      t = Prodrw.UnitXval*Prodrw.UnitYval;
      t = t*Prodrw.UnitZval;
      if (CheckUnitCalcDimQty(INr)==false) then begin
        t = t*Prodrw.OutQty;
      end;
      outvol = outvol + t;      
    end;
  end;
L88ProdCheckVolume:;  
  outvol = Round(outvol,SetRoundModeD(3));
  invol = Round(invol,SetRoundModeD(3));
  if (invol<outvol) then begin
    res = false;
  end;
LProdCheckVolume:;
  ProdCheckVolume = res;
  RETURN;
END;

global
function Boolean IsRecipeClosed(string reccode)
BEGIN
  Boolean res;
  record RecVc Recr;
  
  res = false;
  if (nonblank(reccode)) then begin
    Recr.Code = reccode;
    res = ReadFIrstMain(Recr,1,true);
    if (Recr.Closed==0) then begin res = false; end;
  end;
  IsRecipeClosed = res;
  RETURN;
END;

function LongInt IsAnyProdOperationNotCancelled(LongInt ProdNr)
begin 
  LongInt res;
  record ProdOperationVc ProdOpr;
  
  ProdOpr.ProdNr = ProdNr;
  ProdOpr.PRStatusFlag = 0; 
  if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
    res = ProdOpr.SerNr;
  end;
  if (res<0) then begin
    ProdOpr.ProdNr = ProdNr;
    ProdOpr.PRStatusFlag = 1; 
    if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
      res = ProdOpr.SerNr;
    end;
  end;
  if (res<0) then begin
    ProdOpr.ProdNr = ProdNr;
    ProdOpr.PRStatusFlag = 2; 
    if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
      res = ProdOpr.SerNr;
    end;
  end;
  if (res<0) then begin
    ProdOpr.ProdNr = ProdNr;
    ProdOpr.PRStatusFlag = 3; 
    if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
      res = ProdOpr.SerNr;
    end;
  end;
  if (res<0) then begin
    ProdOpr.ProdNr = ProdNr;
    ProdOpr.PRStatusFlag = 5; 
    if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
      res = ProdOpr.SerNr;
    end;
  end;
  IsAnyProdOperationNotCancelled = res;
  return;
end;

function LongInt IsAnyProdOperationNotFinished(LongInt ProdNr)
begin 
  LongInt res;
  record ProdOperationVc ProdOpr;
  
  ProdOpr.ProdNr = ProdNr;
  ProdOpr.PRStatusFlag = 0; 
  if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
    res = ProdOpr.SerNr;
  end else begin
    ProdOpr.ProdNr = ProdNr;
    ProdOpr.PRStatusFlag = 2; 
    if (ReadFirstKey("ProdNrPRStatus",ProdOpr,2,true)) then begin
      res = ProdOpr.SerNr;
    end;
  end;
  IsAnyProdOperationNotFinished = res;
  return;
end;

global
procedure SetProdTime(record ProdVc Prodr,record ProdVc Prod2r,Boolean updatef)
begin
  if (Prodr.PRStatusFlag==2) then begin
    if (updatef) then begin
      if (Prod2r.PRStatusFlag<2) then begin
        if (blanktime(Prodr.StartTime)) then begin
          Prodr.StartTime = CurrentTime;
        end;
        if (blankdate(Prodr.StartDate)) then begin
          Prodr.StartDate = CurrentDate;
        end;
      end;
    end else begin
      if (blanktime(Prodr.StartTime)) then begin
        Prodr.StartTime = CurrentTime;
      end;
      if (blankdate(Prodr.StartDate)) then begin
        Prodr.StartDate = CurrentDate;
      end;
    end;
  end;
  if ((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) then begin
    if (updatef) then begin
      if (Prod2r.PRStatusFlag<3) then begin
        if (blanktime(Prodr.StartTime)) then begin
          Prodr.StartTime = AddMinutes(CurrentTime,-1);
        end;
        if (blanktime(Prodr.EndTime)) then begin
          Prodr.EndTime = CurrentTime;
        end;
        if (blankdate(Prodr.StartDate)) then begin
          Prodr.StartDate = CurrentDate;
        end;
      end;
    end else begin
      if (blanktime(Prodr.StartTime)) then begin
        Prodr.StartTime = AddMinutes(CurrentTime,-1);
      end;
      if (blanktime(Prodr.EndTime)) then begin
        Prodr.EndTime = CurrentTime;
      end;
      if (blankdate(Prodr.StartDate)) then begin
        Prodr.StartDate = CurrentDate;
      end;
    end;
  end;
  return;
end;

function Boolean AllStockedItemsareConsigStock(record ProdVc Prodp,Integer rownr)
begin
  record INVc INr;
  record BatchTextVc BTr;
  row ProdVc Prodrw;
  Boolean res;
  Integer i,rwcnt;
  
  res = true;
  rwcnt = MatRowCnt(Prodp);
  for (i=0;i<rwcnt;i=i+1) begin
    if (i!=rownr) then begin
      MatRowGet(Prodp,i,Prodrw);
      if (nonblank(Prodrw.Item)) then begin
        if (ReadFirstItem(Prodrw.Item,INr,true,false)) then begin
          if (INr.ItemType==kItemTypeStocked) then begin
            BTr.ArtCode = Prodrw.Item;
            BTr.SerialNr = Prodrw.SerialNr;
            if (ReadFirstMain(BTr,2,true)) then begin 
              if (BTr.ConsigStock==0) then begin
                res = false;
                goto LAllStockedItemsareConsigStock;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
LAllStockedItemsareConsigStock:;  
  AllStockedItemsareConsigStock = res;
  return;
end;


global
updating function LongInt DoProdVcRecordCheck(var record ProdVc Prodp,record ProdVc Prod2p,LongInt stat,LongInt check,Boolean donotcalctimecostf,var record TRVc gTRp,var Integer rowno,var string extracom,var string fieldnam)
BEGIN
  LongInt res;
  record MainStockBlock MainStockRec;
  record INVc INr;
  record ItemStatusVc ISr;
  row ProdVc Prodrw;
  row ProdVc Prod2rw;
  Integer i,rwcnt,j,cnt;
  Integer insertmode,updatemode;
  Integer errcode;
  LongInt sernr;
  LongInt oldnr,newnr;
  Boolean gentrans,relf;
  Boolean transf;
  string 255 location,tstr;
  val t,prev,qty;
  Integer totoutlines,totoutrellines;
  record StandProblemVc SPr;
  record LocationVc Locr;
  record UserVc Userr;
  record RecVc Recr;
  record AccBlock Accb;
  record ProdAccBlock PAb;
  record ProdOperationVc ProdOpr;
  record RoutingVc Routingr;
  record ProdVc orgProdr;
  record ProdClassVc ProdClassr;
  Boolean unokf;
  record BatchTextVc BTr;

  rowno = -1;
  extracom = "";
  fieldnam = "";
  totoutlines = 0;
  totoutrellines = 0;
  res = 0;
  insertmode = 1;//Rs_insert
  updatemode = 2;//Rs_update
  oldnr = Prodp.SerNr;
  BlockLoad(MainStockRec);
  BlockLoad(PAb);
  location = Prodp.Location;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  transf = false;
  if ((Prodp.PRStatusFlag==3) or (Prodp.PRStatusFlag==5)) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if ((Prod2p.PRStatusFlag!=3) and (Prod2p.PRStatusFlag!=5)) then begin transf = true; end;
    end;
  end;
   if (stat==updatemode) then begin
    if (Prodp.SerNr<=0) and (Prod2p.PRStatusFlag==0) then begin
      Prodp.SerNr = Prod2p.SerNr;
    end;
  end;   
  if (Prodp.PRStatusFlag==0) then begin
    if (stat==updatemode) then begin
      if (Prod2p.PRStatusFlag!=0) then begin unokf = true; end;
    end;
  end;
  if (Prodp.PRStatusFlag==2) then begin
    if (stat==updatemode) then begin
      if (Prod2p.PRStatusFlag>2) then begin unokf = true; end;
    end;
  end;
  if (unokf) then begin
    errcode = IsUnOKAllowed_ProdVc(Prodp);
    if (errcode!=0) then begin
      RecordCheckError(errcode,"",-1,"ProdDate");      
      res = -1; 
    end;
    goto LProdVcRecordCheck;
  end;  
  relf = true;  
  rwcnt = MatRowCnt(Prodp);
  if (Prodp.SerNr<=0) then begin
    Prodp.SerNr = NextSerNr("ProdVc",Prodp.ProdDate,-1,false,"");
  end;
  if (SerNrTestProdVc(Prodp.SerNr,Prodp.ProdDate,gentrans)==false) then begin
    fieldnam = "SerNr";
    res = 1557; 
    goto LProdVcRecordCheck;
  end;
  if (Date2Test("ProdVc",Prodp.ProdDate,"ProdDate",-1)==false) then begin // Should not call RecordCheckError really
    res = -1;
    goto LProdVcRecordCheck;
  end;
  if (DisallowFutureDateCheck(true,Prodp.ProdDate,"ProdDate",-1)) then begin
    res = -1;
    goto LProdVcRecordCheck;
  end;
  if (check!=0) and (transf) then begin
    rwcnt = MatRowCnt(Prodp);
    if (rwcnt==0) then begin
      RecordCheckError(1030,"",0,"ItemCode");      
      res = -1;
      goto LProdVcRecordCheck;
    end;
    if (Prodp.Qty==0) then begin
      fieldnam = "Qty";
      res = 1058; 
      goto LProdVcRecordCheck;
    end;
    if (Prodp.Disassemble!=0) then begin
      orgProdr.OrgProdNr = Prodp.SerNr;
      if (ReadFirstKey("OrgProdNr",orgProdr,1,true)) then begin
        fieldnam = "SerNr";
        res = 20879; 
        goto LProdVcRecordCheck;
      end;
    end;
  end;
  if (check!=0) then begin
    if (nonblank(Prodp.Inspector)) then begin
      Userr.Code = Prodp.Inspector;
      if (ReadFirstMain(Userr,1,true)==false) then begin
        extracom = Prodp.Inspector; 
        fieldnam = "Inspector";
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
    end;  
    if (nonblank(Prodp.Routing)) then begin
      Routingr.Code = Prodp.Routing;
      if (ReadFirstMain(Routingr,1,true)==false) then begin
        extracom = Prodp.Routing; 
        fieldnam = "Routing";
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
    end;
    if (nonblank(Prodp.Person)) then begin
      Userr.Code = Prodp.Person;
      if (ReadFirstMain(Userr,1,true)==false) then begin
        extracom = Prodp.Person; 
        fieldnam = "Person";
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
    end;  
    if (IsRecipeClosed(Prodp.Recepy)) then begin
      fieldnam = "Recepy";
      res = 2088; 
      goto LProdVcRecordCheck;
    end;
    if (nonblank(Prodp.Recepy)) then begin
      Recr.Code = Prodp.Recepy;
      if (ReadFirstMain(Recr,1,true)==false) then begin
        extracom = Prodp.Recepy; 
        fieldnam = "Recepy";
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
    end;
    if (Prodp.Qty<0) then begin
      extracom = ""; 
      fieldnam = "Qty";
      res = 1574; 
      goto LProdVcRecordCheck;
    end;

    if (nonblank(Prodp.StandProblem)) then begin
      SPr.Code = Prodp.StandProblem;
      if (ReadFirstMain(SPr,1,true)==false) then begin
        extracom = Prodp.StandProblem; 
        fieldnam = "StandProblem";
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
    end;

    errcode = CheckObjs("",Prodp.Objects,tstr);
    if (errcode!=0) then begin
      extracom = tstr; 
      fieldnam = "Objects";
      res = errcode; 
      goto LProdVcRecordCheck;
    end;
  end;
  if (Prodp.StartDate>Prodp.ProdDate) then begin
    fieldnam = "StartDate";
    res = 20851; 
    goto LProdVcRecordCheck;
  end;
  if (nonblank(location)) then begin
    Locr.Code = location;
    if (ReadFirstMain(Locr,1,true)==false) then begin
      extracom = location; 
      fieldnam = "Location";
      res = 1120; 
      goto LProdVcRecordCheck;
    end;
    if (Locr.RequirePos!=0) then begin
      extracom = " " & location; 
      fieldnam = "Location";
      res = 1748; 
      goto LProdVcRecordCheck;
    end;
  end;  
  if (nonblank(Prodp.ProdClass)) then begin
    ProdClassr.Code = Prodp.ProdClass;
    if (ReadFirstMain(ProdClassr,1,true)==false) then begin
      RecordCheckError(1290,"",-1,"ProdClass");      
      res = -1;
      goto LProdVcRecordCheck;
    end;
  end;
  for (i = 0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    if (nonblank(Prodrw.Item)) then begin
      if (ReadFirstItem(Prodrw.Item,INr,true,true)==false) then begin
        extracom = Prodrw.Item; 
        fieldnam = "Item";
        rowno = i;
        res = 1120; 
        goto LProdVcRecordCheck;
      end;
      if (INr.Terminated==1) then begin
        extracom = Prodrw.Item; 
        fieldnam = "Item";
        rowno = i;
        res = 1266; 
        goto LProdVcRecordCheck;
      end;
      errcode = CheckObjs("",Prodrw.Objects,tstr);
      if (errcode!=0) then begin
        extracom = tstr; 
        fieldnam = "Objects";
        rowno = i;
        res = errcode; 
        goto LProdVcRecordCheck;
      end;
      if (Prodrw.OutQty>0) then begin
        totoutlines = totoutlines + 1;
        if (Prodrw.RelVal!=0) then begin
          totoutrellines = totoutrellines + 1;
        end;
        if (relf) then begin
          relf = nonblank(Prodrw.RelVal);
        end;
        if (INr.ItemType==kItemTypeStructured) then begin
          extracom = " " & Prodrw.Item; 
          fieldnam = "Item";
          rowno = i;
          res = 1826; 
          goto LProdVcRecordCheck;
        end;
        if (Prodp.Disassemble==0) then begin
          if (INr.ItemType==kItemTypePlain) then begin
            extracom = ": " & Prodrw.Item; 
            fieldnam = "Item";
            rowno = i;
            res = 27353; 
            goto LProdVcRecordCheck;
          end;
          if (INr.ItemType==kItemTypeService) then begin
            extracom = ": " & Prodrw.Item; 
            fieldnam = "Item";
            rowno = i;
            res = 1954; 
            goto LProdVcRecordCheck;
          end;
        end;
      end;
      if (Prodrw.OutQty<0) then begin
        fieldnam = "OutQty";
        rowno = i;
        res = 1574; 
        goto LProdVcRecordCheck;
      end;
      if (Prodrw.InQty>0) then begin
        if (INr.ItemType==2) then begin
          extracom = Prodrw.Item; 
          fieldnam = "Item";
          rowno = i;
          res = 1826; 
          goto LProdVcRecordCheck;
        end;
        BTr.ArtCode = Prodrw.Item;
        BTr.SerialNr = Prodrw.SerialNr;
        if (ReadFirstMain(BTr,2,true)) then begin 
          if (BTr.ConsigStock!=0) then begin
/*CONSIGN in Prod
            if (AllStockedItemsareConsigStock(Prodp,i)==false) then begin
*/            
              extracom = " " & Prodrw.Item; 
              fieldnam = "Item";
              rowno = i;
              res = 20118; 
              goto LProdVcRecordCheck;
//            end;
          end;
        end;
      end;
      if (Prodrw.InQty<0) then begin
        fieldnam = "InQty";
        rowno = i;
        res = 1574; 
        goto LProdVcRecordCheck;
      end;
      if (CheckAllowedSize(INr,Prodrw.UnitXval,Prodrw.UnitYval,Prodrw.UnitZval)==false) then begin
        fieldnam = "UnitXval";
        rowno = i;
        res = 1480; 
        goto LProdVcRecordCheck;
      end;
      if (INr.ItemType==1) then begin
        if (ProdCheckVolume(Prodp,i)==false) then begin
          fieldnam = "Item";
          rowno = i;
          res = 2000; 
          goto LProdVcRecordCheck;
        end;        
        if (CheckSerialStatus(Prodrw.Item,Prodrw.SerialNr,tstr)==2) then begin
          extracom = tstr;
          fieldnam = "SerialNr";
          rowno = i;
          res = 2210; 
          goto LProdVcRecordCheck;
        end;
      end;

      if (StockRecordForLocationAllowed("ProdVc",Prodp.Location,Prodrw.Item,Prodp.ProdDate,Prodp.PRStatusFlag,errcode,extracom)==false) then begin
        res = errcode;
        fieldnam = "ArtCode";
        rowno = i;
        goto LProdVcRecordCheck;
      end;
      if ((Prodp.PRStatusFlag==3) or (Prodp.PRStatusFlag==5)) then begin
        if ((INr.SerNrf>0) and (INr.SerNrf<3)) then begin
          if (IsSerialNrCorrect(Prodrw.SerialNr)==false) then begin
            extracom = Prodrw.SerialNr;
            fieldnam = "SerialNr";
            rowno = i;
            res = 24154; 
            goto LProdVcRecordCheck;
          end;
          if (MainStockRec.NoSerOnPU==0) then begin
            if ((blank(Prodrw.SerialNr)) and (Prodrw.OutQty!=0)) then begin
              fieldnam = "SerialNr";
              rowno = i;
              res = 1239; 
              goto LProdVcRecordCheck;
            end;
          end;
          if (Prodrw.InQty!=0) then begin  // check if ser nr. exists 
            if (INr.SerNrf==1) then begin
              if (blank(Prodp.Routing)) then begin
                switch (Prodp.RowsHoldActualQty) begin
                  case 1: prev = Prodrw.InQty;
                  otherwise prev = Prodrw.InQty*Prodp.Qty;
                end;
                if (prev!=1) then begin
                  fieldnam = "SerialNr";
                  rowno = i;
                  res = 1242; 
                  goto LProdVcRecordCheck;
                end;
                for (j=0;j<i;j=j+1) begin
                  MatRowGet(Prodp,j,Prod2rw);
                  if ((Prodrw.Item==Prod2rw.Item) and (Prodrw.SerialNr==Prod2rw.SerialNr)) then begin
                    fieldnam = "SerialNr";
                    rowno = i;
                    res = 1242; 
                    goto LProdVcRecordCheck;
                  end;
                end;
                switch (Prodp.RowsHoldActualQty) begin
                  case 1: t = Prodrw.InQty;
                  otherwise t = Prodrw.InQty*Prodp.Qty;
                end;
                if (SerialNrAvail(Prodrw.Item,Prodrw.SerialNr,location,t)==false) then begin
                  fieldnam = "SerialNr";
                  rowno = i;
                  res = 1240; 
                  goto LProdVcRecordCheck;
                end;
              end;
            end else begin
              prev = 0;
              for (cnt=0;cnt<i;cnt=cnt+1) begin
                MatRowGet(Prodp,cnt,Prod2rw);
                if ((Prod2rw.Item==Prodrw.Item) and (Prod2rw.SerialNr==Prodrw.SerialNr)) then begin
                  switch (Prodp.RowsHoldActualQty) begin
                    case 1: prev = prev + Prod2rw.InQty;
                    otherwise prev = prev + Prod2rw.InQty*Prodp.Qty;
                  end;                  
                end;
              end;
              switch (Prodp.RowsHoldActualQty) begin
                case 1: prev = prev + Prodrw.InQty;
                otherwise prev = prev + Prodrw.InQty*Prodp.Qty;
              end;
              if (blank(Prodp.Routing)) then begin
                if (SerialNrAvail(Prodrw.Item,Prodrw.SerialNr,location,prev)==false) then begin
                  fieldnam = "SerialNr";
                  rowno = i;
                  res = 1240; 
                  goto LProdVcRecordCheck;
                end;
              end;
            end;   
            if (INr.SerNrf==1) then begin              
              switch (Prodp.RowsHoldActualQty) begin
                case 1: t = Prodrw.InQty;
                otherwise t = Prodrw.InQty*Prodp.Qty;
              end;      
              if (t!=1) then begin
                RecordCheckError(1242,"",i,"SerialNr");      
                fieldnam = "SerialNr";
                rowno = i;
                res = 1240; 
                goto LProdVcRecordCheck;
              end;
              if (blank(Prodp.Routing)) then begin
                if (SerialNrAvail(Prodrw.Item,Prodrw.SerialNr,location,t)==false) then begin
                  fieldnam = "SerialNr";
                  rowno = i;
                  res = 1240; 
                  goto LProdVcRecordCheck;
                end;
              end;
            end;
          end;
          if (Prodrw.OutQty!=0) then begin  // check if ser nr. exists 
            if (INr.SerNrf==1) then begin // serial nr checking 
//              if (Prodrw.InQty>0) then begin
//              if (SerialNrAvail(Prodrw.Item,Prodrw.SerialNr,Prodp.Location,Prodrw.InQty)==true) then begin
              if (SerialNrAvail2(Prodrw.Item,Prodrw.SerialNr,1)==true) then begin //We cannot produce a item if at least one exists in stock            
                fieldnam = "SerialNr";
                rowno = i;
                res = 1241; 
                goto LProdVcRecordCheck;
              end;
//            end;
              if (MainStockRec.NoSerOnPU==0) then begin   
                switch (Prodp.RowsHoldActualQty) begin
                  case 1: t = Prodrw.OutQty;
                  otherwise t = Prodrw.OutQty*Prodp.Qty;
                end;      
                if (t!=1) then begin
                  fieldnam = "SerialNr";
                  rowno = i;
                  res = 1242; 
                  goto LProdVcRecordCheck;
                end;
              end;
            end;
          end;
        end;
        if (check>0) then begin
        if (MainStockRec.dontAllowOvership==1) then begin
          if (Prodrw.InQty!=0) then begin
            if (INr.ItemType==1) and (blank(Prodp.Routing)) then begin
              qty = 0;
              for (j=0;j<i;j=j+1) begin
                MatRowGet(Prodp,j,Prod2rw);
                if (Prod2rw.Item==Prodrw.Item) then begin                  
                  switch (Prodp.RowsHoldActualQty) begin
                    case 1: qty = qty + Prod2rw.InQty;
                    otherwise qty = qty + Prod2rw.InQty*Prodp.Qty;
                  end;      
                end;
              end;
              switch (Prodp.RowsHoldActualQty) begin
                case 1: qty = qty + Prodrw.InQty;
                otherwise qty = qty + Prodrw.InQty*Prodp.Qty;
              end;                    
              FindStockValue(Prodrw.Item,location,ISr);
              if (ISr.Instock<qty) then begin
                fieldnam = "InQty";
                rowno = i;
                res = 1247; 
                goto LProdVcRecordCheck;
              end;
            end;
          end;
        end;
        end;
        if (MainStockRec.requireLocation!=0) then begin
          if (blank(Prodp.Location)) then begin
            extracom = Prodp.Location;
            fieldnam = "Location";
            res = 1058; 
            goto LProdVcRecordCheck;
          end;
        end;
      end;
    end else begin
      if (Prodrw.InQty!=0) then begin
        fieldnam = "Item";
        rowno = i;
        res = 1058; 
        goto LProdVcRecordCheck;
      end;
      if (Prodrw.OutQty!=0) then begin
        fieldnam = "Item";
        rowno = i;
        res = 1058; 
        goto LProdVcRecordCheck;
      end;
    end;
  end;
  if (Prodp.PRStatusFlag==3) then begin
    if (totoutlines>0) then begin
      if (Prodp.Disassemble==0) then begin
        if ((totoutlines>1) and (totoutrellines!=totoutlines)) then begin
          if (relf==false) then begin
            fieldnam = "SerNr";
            rowno = -1;
            res = 2177; 
            goto LProdVcRecordCheck;
          end;
        end;
      end;
    end else begin
      fieldnam = "OutQty";
      rowno = rwcnt - 1;
      if (rowno<0) then begin
        rowno = 0;
      end;
      res = 2165; 
      goto LProdVcRecordCheck;
    end;
  end;
  if (nonblank(Prodp.Routing)) then begin
    switch (Prodp.PRStatusFlag) begin
      case 2:
        if (blank(Prodp.Location)) then begin
          extracom = Prodp.Location;
          fieldnam = "Location";
          res = 1058; 
          goto LProdVcRecordCheck;
        end;
      case 4:
        if (IsAnyProdOperationNotCancelled(Prodp.SerNr)>0) then begin
          fieldnam = "SerNr";
          res = 20783; 
          goto LProdVcRecordCheck;
        end;
      case 5:
        ProdOpr.ProdNr = Prodp.SerNr;
        if (ReadFirstKey("ProdNr",ProdOpr,1,true)) then begin
          fieldnam = "SerNr";
          if (ProdOpr.PRStatusFlag==3) then begin
            res = 20784; 
          end else begin
            res = 20783; 
          end;
          goto LProdVcRecordCheck;
        end;
    end;
    if (transf) then begin
      ProdOpr.ProdNr = Prodp.SerNr;
      if (ReadFirstKey("ProdNr",ProdOpr,1,true)==false) then begin
        fieldnam = "SerNr";
        res = 20759; 
        goto LProdVcRecordCheck;
      end;
      sernr = IsAnyProdOperationNotFinished(Prodp.SerNr);      
      if (sernr>0) then begin
        fieldnam = "SerNr";
        extracom = " " & sernr;
        res = 20776; 
        goto LProdVcRecordCheck;
      end;
    end;
  end;
  if (check!=0) then begin
    if (blank(Prodp.Routing)) then begin
      if (donotcalctimecostf==false) then begin
        if (stat==updatemode) then begin
          SetProdTime(Prodp,Prod2p,true);
          ProdCalcItemCost(Prodp,Prod2p,true);
       end else begin
          SetProdTime(Prodp,Prod2p,false);
          ProdCalcItemCost(Prodp,Prod2p,false);
        end;
      end;
      ProdFillFIFO(Prodp,true);
    end;
  end;
  if (Prodp.PRStatusFlag==5) then begin
    if (blank(Prodp.StandProblem)) then begin
      fieldnam = "StandProblem";
      res = 1058; 
      goto LProdVcRecordCheck;
    end;
  end;

  if (transf) then begin
    if (stat==updatemode) then begin
      sernr = Prod2p.SerNr;
    end;
    if (check>0) then begin
      if (MainStockRec.Chronology!=0) then begin 
        if (ExistStockTrans(location,Prodp.ProdDate,errcode,extracom,"ProdVc",sernr,MainStockRec)) then begin
          fieldnam = "ProdDate";
          res = errcode; 
          goto LProdVcRecordCheck;
        end;
      end;
    end;
    if (CanOKStockRecord(errcode)==false) then begin
      fieldnam = "SerNr";
      res = errcode;
      goto LProdVcRecordCheck;
    end;
  end;
  if (gentrans==false) then begin transf = false; end;
  if (nonblank(Prodp.Routing)) and (PAb.ProdTransaction==0) then begin transf = false; end;
  if (transf) then begin
    errcode = MakeTransFromProd(gTRp,Prodp,false);
    if (errcode!=0) then begin
      fieldnam = "SerNr";
      res = errcode; 
      goto LProdVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (gTRp.IntYc==ProdYc)) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        extracom = tstr;
        fieldnam = "SerNr";
        res = 1085; 
        goto LProdVcRecordCheck;
      end;
    end;    
  end;
LProdVcRecordCheck:;
  if (res!=0) then begin
    Prodp.SerNr = oldnr;
  end;
  DoProdVcRecordCheck = res;
  RETURN;
END;

global
updating function LongInt ProdVcRecordCheck(var record ProdVc Prodp,record ProdVc Prod2p,LongInt stat,LongInt check)
begin
  LongInt res;
  record TRVc gTRp;
  string 100 extracom,fieldnam;
  Integer rowno;
  transaction string 255 gRuniningMaint;
  transaction Boolean gProdDoNotCalcTimeCostf;
  
  res = DoProdVcRecordCheck(Prodp,Prod2p,stat,check,gProdDoNotCalcTimeCostf,gTRp,rowno,extracom,fieldnam);
  if (res>0) then begin
    RecordCheckError(res,extracom,rowno,fieldnam);      
    res = -1;
    goto LProdVcRecChk;
  end;
  if (res==0) then begin
    if ((gTRp.Number>0) and (gTRp.IntYc==ProdYc)) then begin
      switch (gRuniningMaint) begin    
        case "RecalcStockMn":
          UpdateTrans_Stock(gTRp);          
        otherwise
          SaveTrans(gTRp);
          AddTTrans_ProdVc(gTRp,Prodp);
      end;
    end;
  end;
LProdVcRecChk:;
  ProdVcRecordCheck = res;
  RETURN;
END;

global
updating procedure UpdateProdPlanned(record ProdVc Prodp,string location,Boolean addf)
BEGIN
  row ProdVc Prodrw;
  Integer rwcnt,i;
  val theqty;
  Date thedat;
  
  rwcnt = MatRowCnt(Prodp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    if (Prodrw.InQty==0) then begin
      switch (Prodp.RowsHoldActualQty) begin
        case 1: theqty = Prodrw.OutQty;
        otherwise theqty = Prodrw.OutQty*Prodp.Qty;
      end;      
      thedat = Prodp.ProdDate;
// No handling for Quant2 
      UpdatePlanned(Prodrw.Item,location,"Fut2ProdInVc",Prodp.SerNr,thedat,theqty,i,theqty,Prodrw.FIFORowVal,addf);    
    end else begin
      switch (Prodp.RowsHoldActualQty) begin
        case 1: theqty = -Prodrw.InQty;
        otherwise theqty = -Prodrw.InQty*Prodp.Qty;
      end;      
      thedat = Prodp.StartDate;
// No handling for Quant2 
      UpdatePlanned(Prodrw.Item,location,"Fut2ProdOutVc",Prodp.SerNr,thedat,theqty,i,theqty,Prodrw.FIFORowVal,addf);    
    end;
  end;
  RETURN;
END;

global
updating procedure UpdateProdOut(record ProdVc Prodp,Boolean addf,Boolean futprodf)
BEGIN
  row ProdVc Prodrw;
  record INVc INr;
  record SHVc SHr;
  row SHVc SHrw;
  Integer i,rwcnt;
  Integer shi,shrwcnt;
  val t,q2;
  val t2,t3;
//  val t4,t5,t6;
  record MainStockBlock MainStockRec;
  string 255 location;
  Boolean instockf,outstockf,testf;
  
  switch (Prodp.PRStatusFlag) begin
    case 3:
      outstockf = true;
      instockf = true;
    case 4: 
      goto LUpdateProdOut;
    case 5:
      if (addf) then begin
        outstockf = true;
        instockf = false;
      end else begin
        outstockf = true;
        instockf = true;
      end;
  end;

  BlockLoad(MainStockRec);
  location = Prodp.Location;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(Prodp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodp,i,Prodrw);
    t2 = blankval;
    t3 = blankval;
//    t4 = blankval;
    q2 = blankval;

    if ((Prodp.PRStatusFlag!=3) and (Prodp.PRStatusFlag!=5)) then begin
      if (Prodp.ProdOrder<=0) then begin 
        switch (Prodp.RowsHoldActualQty) begin
          case 1: t2 = Prodrw.InQty;
          otherwise t2 = Prodrw.InQty*Prodp.Qty;
        end;              
      end;
//      t4 = Prodrw.OutQty*Prodp.Qty;
    end else begin
      if (blank(Prodp.Routing)) then begin
        t3 = Prodrw.OutQty - Prodrw.InQty;
        switch (Prodp.RowsHoldActualQty) begin
          case 1:
          otherwise t3 = Round(t3*Prodp.Qty,SetRoundModeD(3));
        end;
      end;
      if (MainStockRec.UnitConvCalc==0) then begin
        q2 = t3 * Prodrw.Coefficient;
      end else begin
        q2 = t3 / Prodrw.Coefficient;
      end;
    end;
    if (addf==false) then begin
      t2 = -t2;
      t3 = -t3;
//      t4 = -t4;
      q2 = -q2;
    end;
    testf = false;
    if ((t2!=0) or (t3!=0) /*or (t4!=0)*/ or (q2!=0)) then begin
      testf = true;
    end;
    if (testf) then begin
      if (Prodrw.OutQty>0) then begin
        testf = instockf;
      end;
      if (Prodrw.InQty>0) then begin
        testf = outstockf;
      end;
    end;
/*
      if ((Prodp.PRStatusFlag!=3) and (Prodp.PRStatusFlag!=5)) then begin
        t5 = t2;
      end else begin
        t5 = t3;
      end;
*/      
    if (testf) then begin
      if (ShouldItemUpdateStock(Prodrw.Item)==false) then begin t3 = blankval; end;
      UpdateInstock("ProdVc",Prodp.SerNr,Prodrw.Item,location,Prodp.ProdDate,t3,t,t,t,t,q2,t2,t,t);
      UpdatePosition(Prodrw.Item,location,Prodrw.PosCode,t2,q2,t);
    end;
  end;
  if (futprodf) then begin
    UpdateProdPlanned(Prodp,location,addf);
  end;
LUpdateProdOut:;
  RETURN;
END;

procedure SetProdFlags(record ProdVc Prodp,record ProdVc Prod2p)
BEGIN
  switch (Prodp.PRStatusFlag) begin
    case 0: Prodp.FinnishedFlag = 0;
    case 2: Prodp.FinnishedFlag = 0;
    case 3: Prodp.FinnishedFlag = 1;
    case 4: Prodp.FinnishedFlag = 1;
    case 5: Prodp.FinnishedFlag = 1;
  end;
  switch (Prodp.PRStatusFlag) begin
    case 0: Prodp.DoneFlag = 0;  // Created 
    case 2: Prodp.DoneFlag = 45; // Started 
    case 3: Prodp.DoneFlag = 18; // Finnished 
    case 4: Prodp.DoneFlag = 18; // Canceled 
    case 5: Prodp.DoneFlag = 18; // Finnished 
  end;
  return;
end;

global
updating function LongInt ProdVcRecordSave(var record ProdVc Prodr,record ProdVc Prod2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  SetProdFlags(Prodr,Prod2r);
//  SetProdTime(Prodr,Prod2r,false);, record check needs it and it is called before
//  ProdCalcItemCost(Prodr,Prod2r,false);
  if ((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) then begin
    Prodr.LocOKNr = NextLocOKNr(Prodr.Location);
  end;
  ProdVcRecordSave = res;
  RETURN;
END;

updating procedure UpdateProdOrdStarted(record ProdVc Prodr)
begin
  record ProdOrderVc prodordr;
  record ProdOrderVc oldprodordr;
  Integer ru;
  
  if (Prodr.ProdOrder!=-1) then begin
    prodordr.SerNr = Prodr.ProdOrder;
    if (ReadFirstMain(prodordr,1,true)) then begin
      RecordCopy(oldprodordr,prodordr);
    end;
    if ((prodordr.StatusFlag!=4) and (prodordr.StatusFlag!=3)) then begin
      prodordr.StatusFlag = 2;
      prodordr.StartDate = CurrentDate;
      prodordr.StartTime = CurrentTime;
      ru = RecordUpdate(oldprodordr,prodordr,false);
    end;
  end;
  RETURN;
END;

updating procedure UpdateProdOrdFinished(record ProdVc Prodr)
begin
  record ProdOrderVc prodordr;
  record ProdOrderVc oldprodordr;
  Integer ru;
  
  if (Prodr.ProdOrder!=-1) then begin
    prodordr.SerNr = Prodr.ProdOrder;
    if (ReadFirstMain(prodordr,1,true)) then begin
      RecordCopy(oldprodordr,prodordr);
      if (prodordr.StatusFlag==1) then begin
        prodordr.StatusFlag = 2;
      end;
      if (Prodr.PRStatusFlag==3) then begin
        if (Prodr.Disassemble!=0) then begin
          UpdateProdOrd(prodordr,false,prodordr.Finished);
          prodordr.Finished = prodordr.Finished - Prodr.Qty;//in rows we can have more qties I think
//          UpdateProdOrd(prodordr,true,prodordr.Finished);
        end else begin
          UpdateProdOrd(prodordr,false,prodordr.Finished);
          prodordr.Finished = prodordr.Finished + Prodr.Qty;//in rows we can have more qties I think
          UpdateProdOrd(prodordr,true,prodordr.Finished);
        end;
      end else begin
        UpdateProdOrd(prodordr,false,prodordr.Discarded);
        prodordr.Discarded = prodordr.Discarded + Prodr.Qty;
        UpdateProdOrd(prodordr,true,prodordr.Discarded);
      end;
      CalcProdDuration(prodordr);
      if (Prodr.Qty>0) then begin
        if (GetHour(prodordr.StartTime)==0) then begin
          prodordr.StartTime = Prodr.StartTime;
        end;
        if (blankdate(prodordr.StartDate)) then begin
          prodordr.StartDate = Prodr.StartDate;
        end;
        if (prodordr.EndDate<Prodr.ProdDate) then begin
          prodordr.EndDate = Prodr.ProdDate;
        end;
        if (prodordr.EndTime<Prodr.EndTime) then begin
          prodordr.EndTime = Prodr.EndTime;
        end;
      end;
      ru = RecordUpdate(oldprodordr,prodordr,false);
    end;
  end;    
LUpdateProdOrdFinished:;  
  RETURN;
end;

updating procedure ProdMakeSD(record ProdVc Prodr)
begin
  record SDVc SDr;
  record SDVc oldSDr;
  record StandProblemVc SPr;
  row SDVc SDrw;
  record ProdSettingsBlock PSb;
  record AccBlock Accb;
  row ProdVc Prodrw;
  Integer i,rwcnt;
  Integer curcomp;
  
  if (nonblank(Prodr.Routing)) then begin
    goto LProdMakeSD;
  end;
  if (Prodr.PRStatusFlag==5) then begin
    BlockLoad(PSb);
    BlockLoad(Accb);
    if ((PSb.MakeSDFromDiscard!=0) and (nonblank(Accb.DiscardedAccount))) then begin
      RecordNew(SDr);
      rwcnt = MatRowCnt(Prodr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Prodr,i,Prodrw);
        if (Prodrw.OutQty!=0) then begin
          ClearRow(SDr,SDrw,1);
          SDrw.ArtCode = Prodrw.Item;
          SDrw.Spec = Prodrw.Comment;
          switch (Prodr.RowsHoldActualQty) begin
            case 1: SDrw.Qty = Prodrw.OutQty;
            otherwise SDrw.Qty = Prodrw.OutQty * Prodr.Qty;
          end;                
          SDrw.SerialNr = Prodrw.SerialNr;
          SDrw.Coefficient = Prodrw.Coefficient;
          SDrw.BasePrice = Prodrw.ItemCost + Prodrw.ExtraCost;
          SDrw.Objects = Prodrw.Objects;
          SDrw.PosCode = Prodrw.PosCode;
          SDrw.UnitXval = Prodrw.UnitXval;
          SDrw.UnitYval = Prodrw.UnitYval;
          SDrw.UnitZval = Prodrw.UnitZval;
          SDrw.FIFORowVal = Prodrw.FIFORowVal;
          MatRowPut(SDr,MatRowCnt(SDr),SDrw);
        end;
      end;
      if (MatRowCnt(SDr)>0) then begin
        SDr.TransDate = CurrentDate;
        SDr.SerNr = NextSerNr("SDVc",SDr.TransDate,-1,false,"");  
        SDr.Location = Prodr.Location;
        SPr.Code = Prodr.StandProblem;
        if (ReadFirstMain(SPr,1,true)==false) then begin
          RecordNew(SPr);
        end;
        SDr.Comment = Left(SPr.Code & " " & Prodr.SerNr & " " & Prodr.RecName,60); // ShortDesc
        SDr.CostAcc = Accb.DiscardedAccount;
        if (SDr.SerNr>0) then begin
          SDSumUp(SDr);
          if (RecordStore(SDr,false)) then begin
          end;
          RecordCopy(oldSDr,SDr);
          SDr.OKFlag = 1;
          if (RecordUpdate(oldSDr,SDr,true)==0) then begin
          end;

          curcomp = CurrentCompany;          
          CreateRecordLink(SDr,curcomp,Prodr,curcomp);  
          CreateRecordLink(Prodr,curcomp,SDr,curcomp);  
        end;
      end;
    end;
  end;
LProdMakeSD:;  
  RETURN;
end;

global
updating function LongInt ProdVcRecordSaveAfter(var record ProdVc Prodr,record ProdVc Prod2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  UpdateProdOut(Prodr,true,(Prodr.PRStatusFlag!=3) and (Prodr.PRStatusFlag!=5));
  if ((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) then begin
    ProdUpdateSerialNr(Prodr,Prod2r,false);
    ProdUpdateCostPrice(Prodr,false);
    ProdUpdateItemHistory(Prodr,Prod2r);
    ProdMakeSD(Prodr);
    UpdateProdOrdFinished(Prodr);
  end;
  if (Prodr.PRStatusFlag==2) then begin
    UpdateProdOrdStarted(Prodr);
  end;
//  if (Prodr.PRStatusFlag==0) or (Prodr.PRStatusFlag==2) then begin
//    CreateQualConFromProdOnSave(Prodr);
//  end;
  ProdVcRecordSaveAfter = res;
  RETURN;
END;

global
updating function LongInt ProdVcRecordImportAfter(var record ProdVc Prodr,record ProdVc Prod2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  Integer err;

  SetProdFlags(Prodr,Prod2r);
  if ((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) then begin
    ProdUpdateSerialNr(Prodr,Prod2r,false);
  end;
  if (ImportingTextBackup==false and CanOKStockRecord(err)==true) then begin
    if ((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) then begin
      ProdUpdateCostPrice(Prodr,false);
      ProdUpdateItemHistory(Prodr,Prod2r);
    end;
  end;  
  ProdVcRecordImportAfter = res;
  RETURN;
END;

global
updating function LongInt ProdVcRecordUpdate(var record ProdVc Prodr,record ProdVc Prod2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  SetProdFlags(Prodr,Prod2r);
/*record check needs it and it is called before
  SetProdTime(Prodr,Prod2r,true);
  if ((Prod2r.PRStatusFlag<>3) and (Prod2r.PRStatusFlag<>5)) then begin
    ProdCalcItemCost(Prodr,Prod2r,true);
  end;
*/  
  if (((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) and ((Prod2r.PRStatusFlag!=3) and (Prod2r.PRStatusFlag!=5))) then begin
    if (ItemHistExists("ProdVc",Prodr.SerNr)==false) then begin
      Prodr.LocOKNr = NextLocOKNr(Prodr.Location);
    end;
  end;
  ProdVcRecordUpdate = res;
  RETURN;
END;

global
updating procedure UnOKProduction(record ProdVc Prodr,record ProdVc Prod2r,Boolean deltrf)
begin
  UpdateProdOut(Prod2r,false,false);
  ProdUpdateSerialNr(Prod2r,Prodr,true);
  if (Prodr.Disassemble==0) then begin
    ProdUpdateCostPrice(Prodr,true);
  end;
  
//  UpdateProdOrdStarted(Prodr);//JJRECALCSTOCK
//    ProdMakeSD(Prodr);//JJRECALCSTOCK
//    UpdateProdOrdFinished(Prodr);//JJRECALCSTOCK
  UpdateRecalcStockNeeded(1);
  StoreUnOKHistory("ProdVc",Prodr.SerNr,CurrentDate,CurrentTime,CurrentUser);    
  if (deltrf) then begin
    DeleteTransaction(Prodr.SerNr,ProdYc);
  end;
  return;
end;

global
updating function LongInt ProdVcRecordUpdateAfter(var record ProdVc Prodr,record ProdVc Prod2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  val LocOKNr;
  Boolean ihef;

  ihef = ItemHistExists("ProdVc",Prodr.SerNr);
  UpdateProdOut(Prod2r,false,(Prod2r.PRStatusFlag!=3) and (Prod2r.PRStatusFlag!=5));
  UpdateProdOut(Prodr,true,(Prodr.PRStatusFlag!=3) and (Prodr.PRStatusFlag!=5));
  ProdUpdateSerialNr(Prodr,Prod2r,false);
  if (((Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5)) and ((Prod2r.PRStatusFlag!=3) and (Prod2r.PRStatusFlag!=5))) then begin
    if (ihef==false) then begin
      if (Prodr.Disassemble==0) then begin
        ProdUpdateCostPrice(Prodr,false);
      end;
      ProdUpdateItemHistory(Prodr,Prod2r);
      ProdMakeSD(Prodr);
      UpdateProdOrdFinished(Prodr);
    end;
  end else begin
    if (Prodr.PRStatusFlag==2) and (Prod2r.PRStatusFlag!=2) then begin
      UpdateProdOrdStarted(Prodr);
    end;
  end;
//  if ((IVr.Invalid==0) and (IV2r.Invalid==0)) then begin
  if ((Prodr.PRStatusFlag==0) and (Prod2r.PRStatusFlag!=0)) then begin//unok
    UnOKProduction(Prodr,Prod2r,true);
  end;
  ProdVcRecordUpdateAfter = res;
  RETURN;
END;
