external updating procedure CreateIntercompanyTransactionsFromTR(record TRVc);
external updating procedure PurgeOPTRrsStats(record PurgeTRVc);
external updating procedure PurgeIPTRrsStats(record PurgeTRVc);
external function Integer GetIntYc(Date);
external procedure WarnFutureDate(Boolean,Date);
external function roundmode DefaultRoundMode();
external updating procedure StoreLiqInfoFromTR(record TRVc,row TRVc,Integer);
external updating procedure AddHistoryToArchive(string,string,string,Date,string,val,val,val,val,val,val);
external updating procedure AddTTrans_TRVc(var record TRVc);
external function Boolean DateLocked(Date,string);
external function Boolean DateWarned(Date,string);
external procedure AddObj(String, var string);
external procedure TRSumup(var record TRVc,var val);
external procedure B1ToB2Val(val,val,val,var val);
external procedure SwapM4Val(var val,var val);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external procedure ConvertToDualBase(var string,date,var val,var val,var val,var val,var val,var val,Boolean);
external procedure TRTestVATCode(record TRVc);
external updating function Boolean TRTestAccs(record TRVc);
external updating procedure VendStatUp(string,LongInt,string,string,Date,val,val,val,val,Boolean);
external updating procedure CustStatUp(string,LongInt,string,string,string,string,string,Date,val,val,val,val,val,val,Boolean);
external updating procedure APInstallmentAdd2(record APVc,Integer,val,val,Date,Boolean,string,Boolean);
external updating procedure ARInstallmentAdd2(record ARVc,string,Integer,val,val,Boolean);
external updating procedure UpdateQuantBal(var Date,string,string,val,Boolean,Boolean);
external updating procedure UpdateObjBal(string,string,Date,val,val,string,Boolean);
external function Integer TypeOfCurncy(var string,var Integer);
external procedure MockObjFromCompCode(string,var string,Integer);
external procedure MockObjFromVATCode(string,var string);
external updating procedure UpdateBal(var Date,string,string,val,val,string,string,Boolean);
external procedure NormalizeObjstr(var string);
external function LongInt GetCurUserLastNr(string);
external function Boolean DatePrel(Date);
external procedure ExtractObj(string,var Integer,var string);
external procedure SplitRiigiObjsNoCut(string,var string,var string,var string,var string);

global
procedure SplitRiigiObjsNoCut(string objstr,var string obj1,var string  obj2,var string  obj3,var string obj4)
begin
  record ObjVc Objr;
  record OTVc OTr;
  string 60 ostr,ostr2;
  Integer pos;

  pos = 0;
  obj1 = "";
  obj2 = "";
  obj3 = "";
  obj4 = "";
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr)) begin
    Objr.Code = ostr;
    if (ReadFirstMain(Objr,1,true)) then begin
      OTr.Code = Objr.OTCode;
      if (ReadFirstMain(OTr,1,true)) then begin
        ostr2 = ostr;
        if (OTr.Type==0) then begin
        end;  
        if (OTr.Type==1) then begin
          obj1 = ostr2;
        end;  
        if (OTr.Type==2) then begin
          obj2 = ostr2;
        end;  
        if (OTr.Type==3) then begin
          obj3 = ostr2;
        end; 
        if (OTr.Type==4) then begin
          obj4 = ostr2;
        end;  
      end;
    end;
    ExtractObj(objstr,pos,ostr);
  end;
  return;
end;

updating
procedure RemoveFromSupp(record TRVc TR2r,integer type)
begin
  row TRVc TR2rw;
  record ROHisVc RHr,oldRHr;
  integer i,rwcnt;
  string 20 obj1,obj2,obj3,obj4;
  boolean testf;
  
  rwcnt = MatRowCnt(TR2r);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TR2r,i,TR2rw);
    if (TR2rw.stp==1) then begin
      SplitRiigiObjsNoCut(TR2rw.Objects,obj1,obj2,obj3,obj4);
      RHr.AccNumber = TR2rw.AccNumber;
      RHr.Object1 = obj1;
      RHr.Object2 = obj2;
      RHr.Object3 = obj3;
      RHr.Object4 = obj4;
      RHr.Year = GetYear(TR2r.TransDate);
      RHr.Month = GetMonth(TR2r.TransDate);
      if ReadFirstMain(RHr,7,true) then begin
        RecordCopy(oldRHr,RHr);
        if (TR2rw.DebVal<>0) then begin
          if (TR2rw.ovst==1) then begin
            if (type == 1) then begin
              RHr.Deb = RHr.Deb + TR2rw.DebVal;
              RHr.Deb2 = RHr.Deb2 + TR2rw.DebVal2;
            end;
            if (type == 2) then begin
              RHr.Deb = RHr.Deb - TR2rw.DebVal;
              RHr.Deb2 = RHr.Deb2 - TR2rw.DebVal2;
            end;
          end;
          if (TR2rw.ovst==0) then begin
            RHr.Deb = RHr.Deb - TR2rw.DebVal;
            RHr.Deb2 = RHr.Deb2 - TR2rw.DebVal2;
          end;    
        end;
        if (TR2rw.CredVal<>0) then begin
          if (TR2rw.ovst==1) then begin
            if (type == 1) then begin
              RHr.Cred = RHr.Cred + TR2rw.CredVal;
              RHr.Cred2 = RHr.Cred2 + TR2rw.CredVal2;
            end; 
            if (type == 2) then begin
              RHr.Cred = RHr.Cred - TR2rw.CredVal;
              RHr.Cred2 = RHr.Cred2 - TR2rw.CredVal2;
            end;  
          end;
          if (TR2rw.ovst==0) then begin
            RHr.Cred = RHr.Cred - TR2rw.CredVal;
            RHr.Cred2 = RHr.Cred2 - TR2rw.CredVal2;
          end;
        end;
        if (RecordUpdate(oldRHr,RHr,false)==0) then begin
        end;
      end else begin
        RecordNew(RHr);
        RHr.AccNumber = TR2rw.AccNumber;
        RHr.Object1 = obj1;
        RHr.Object2 = obj2;
        RHr.Object3 = obj3;
        RHr.Object4 = obj4;
        RHr.Year = GetYear(TR2r.TransDate);
        RHr.Month = GetMonth(TR2r.TransDate);
        if (TR2rw.ovst==1) then begin
          if (TR2rw.DebVal<>0) and (type==1) then begin
            RHr.Deb = TR2rw.DebVal;
            RHr.Deb2 = TR2rw.DebVal2;
          end;
          if (TR2rw.CredVal<>0) and (type==1) then begin
            RHr.Cred = TR2rw.CredVal;
            RHr.Cred2 = TR2rw.CredVal2;
          end;
          if (TR2rw.DebVal<>0) and (type==2) then begin
            RHr.Deb = -TR2rw.DebVal;
            RHr.Deb2 = -TR2rw.DebVal2;
          end;
          if (TR2rw.CredVal<>0) and (type==2) then begin
            RHr.Cred = -TR2rw.CredVal;
            RHr.Cred2 = -TR2rw.CredVal2;
          end;
        end;
        if (TR2rw.ovst==0) then begin
          if (TR2rw.DebVal<>0) then begin
            RHr.Deb = -TR2rw.DebVal;
            RHr.Deb2 = -TR2rw.DebVal2;
          end;
          if (TR2rw.CredVal<>0) then begin
            RHr.Cred = -TR2rw.CredVal;
            RHr.Cred2 = -TR2rw.CredVal2;
          end;
        end;        
        testf = RecordStore(RHr,true);   
      end;
    end;
  end;
return;
end;            

global
updating procedure UpdateROHis(record TRVc TRr,record TRVc TR2r,integer uptype)
begin
  row TRVc TRrw;
  record ROHisVc RHr,oldRHr;
  integer i,rwcnt;
  string 20 obj1,obj2,obj3,obj4;
  boolean testf;

  if (uptype == 1) then begin
    RemoveFromSupp(TR2r,1);
  end;
  if (uptype == 2) then begin
    RemoveFromSupp(TRr,2);
  end;
  if ((uptype == 0) or (uptype == 1)) then begin //save or import
    rwcnt = MatRowCnt(TRr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      if (TRrw.stp==1)  then begin
        SplitRiigiObjsNoCut(TRrw.Objects,obj1,obj2,obj3,obj4);
        RHr.AccNumber = TRrw.AccNumber;
        RHr.Object1 = obj1;
        RHr.Object2 = obj2;
        RHr.Object3 = obj3;
        RHr.Object4  = obj4;
        RHr.Year = GetYear(TRr.TransDate);
        RHr.Month = GetMonth(TRr.TransDate);
        if ReadFirstMain(RHr,7,true) then begin
          RecordCopy(oldRHr,RHr);
          if (TRrw.DebVal<>0) then begin
            if (TRrw.ovst==0) then begin
              RHr.Deb = RHr.Deb + TRrw.DebVal;
              RHr.Deb2 = RHr.Deb2 + TRrw.DebVal2;
            end;
          end;
          if (TRrw.CredVal<>0) then begin
            if (TRrw.ovst==0) then begin
              RHr.Cred = RHr.Cred + TRrw.CredVal;
              RHr.Cred2 = RHr.Cred2 + TRrw.CredVal2;
            end;
          end;
          if (RecordUpdate(oldRHr,RHr,false)==0) then begin
          end;
        end else begin
          RecordNew(RHr);
          RHr.AccNumber = TRrw.AccNumber;
          RHr.Object1 = obj1;
          RHr.Object2 = obj2;
          RHr.Object3 = obj3;
          RHr.Object4 = obj4;
          RHr.Year = GetYear(TRr.TransDate);
          RHr.Month = GetMonth(TRr.TransDate);
          if (TRrw.ovst==0) then begin
            if (TRrw.DebVal<>0) then begin
              RHr.Deb = TRrw.DebVal;
              RHr.Deb2 = TRrw.DebVal2;
            end;
            if (TRrw.CredVal<>0) then begin
              RHr.Cred = TRrw.CredVal;
              RHr.Cred2 = TRrw.CredVal2;
            end;
          end;
          testf = RecordStore(RHr,true);   
        end;
      end;
    end;
  end;        
  return;
end;

global
function LongInt TRVcRecordRemoveTest(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  record DBLockBlock DBLockRec;
  Integer err;

  res = 1;
  err = 1560;
  if (DateLocked(TRr.TransDate,"TRVc")) then begin
    err = 1046;
    goto LTRVcRecordRemoveTest_NOTALLOWED;
  end;
  if (DatePrel(TRr.TransDate)) then begin
    goto LTRVcRecordRemoveTest;
  end;
  if (TRr.Number==-1) then begin
    goto LTRVcRecordRemoveTest;
  end;
  BlockLoad(DBLockRec);
  if (TRr.TransDate<=DBLockRec.DeleteBeforeDate) then begin
    goto LTRVcRecordRemoveTest;
  end;
LTRVcRecordRemoveTest_NOTALLOWED:;  
  res = 0;
  if (long3>0) then begin MessageBox(err,""); end;
LTRVcRecordRemoveTest:;
  TRVcRecordRemoveTest = res; 
  return;
end;

global
function LongInt TRVcRecordDefaults(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  LongInt newnr;

  TRr.Number = -1;
  TRr.IntYc = 0;
  TRr.RegDate = CurrentDate;
  TRr.RegTime = CurrentTime;
  TRr.TransDate = LastTransDate;
  TRr.LastChangeDate = CurrentDate;
  if (blankdate(TRr.TransDate)) then begin
    TRr.TransDate = CurrentDate;
  end;
  if (SingleUserMode) then begin
    newnr = GetCurUserLastNr("TRVc");    
    if (newnr==-1) then begin      
      TRr.Number = NextSerNr("TRVc",TRr.TransDate,newnr,false,"");
    end;
  end;
  if (Importing==false) then begin
    if (DateLocked(TRr.TransDate,"TRVc")) then begin
      MessageBox(1046,"");
    end else begin
      if (DateWarned(TRr.TransDate,"TRVc")) then begin
        MessageBox(1045,"");
      end;
    end;  
  end;
  TRVcRecordDefaults = res;  
  return;
end;

global
function LongInt TRVcRecordDuplicate(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  Integer im,i;
  row TRVc TRrw;
  Boolean putrowf;
  
  TRr.Number = -1;
  TRr.IntYc = 0;
  TRr.RegDate = CurrentDate;
  TRr.RegTime = CurrentTime;
  TRr.LastChangeDate = CurrentDate;
  if (SingleUserMode) then begin
    TRr.Number = NextSerNr("TRVc",TRr.TransDate,-1,false,"");
  end;
  TRr.RefStr = "";
  im = MatRowCnt(TRr);
  for (i=0;i<im;i=i+1) begin
    MatRowGet(TRr,i,TRrw);
    if ((TRrw.ovst!=0) or (TRrw.stp!=1)) then begin
      MatRowDelete(TRr,i);
      i = i - 1;
      im = MatRowCnt(TRr);
    end;
  end;
  im = MatRowCnt(TRr);
  for (i=im-1;i>=0;i=i-1) begin
    MatRowGet(TRr,i,TRrw);
    if ((TRrw.ovst==0) and (TRrw.stp==1)) then begin
      if (TRrw.Reconsf!=0) then begin
        TRrw.Reconsf = 0;
        putrowf = true;
      end;
      if (nonblankdate(TRrw.ReconDate)) then begin
        TRrw.ReconDate = "";
        putrowf = true;
      end;
      if (putrowf) then begin
        MatRowPut(TRr,i,TRrw);
      end;
    end;
  end;
  if (Importing==false) then begin
    if (DateLocked(TRr.TransDate,"TRVc")) then begin
      MessageBox(1046,"");
    end else begin
      if (DateWarned(TRr.TransDate,"TRVc")) then begin
        MessageBox(1045,"");
      end;
    end;  
  end;
  WarnFutureDate(true,TRr.TransDate);
  TRVcRecordDuplicate = res;  
  return;
end;

global
function LongInt TRVcRecordSave(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  row TRVc TRrw;
  Integer rwcnt,i;
  string 255 tstr;
      
  if (blankdate(TRr.RegDate)) then begin
    TRr.RegDate = CurrentDate;
  end;
  if (blanktime(TRr.RegTime)) then begin
    TRr.RegTime = CurrentTime;
  end;
  rwcnt = MatRowCnt(TRr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TRr,i,TRrw);
    tstr = TRrw.Objects;
    NormalizeObjstr(tstr);
    TRrw.Objects = tstr;    
    MatRowPut(TRr,i,TRrw);
  end;
  TRVcRecordSave = res;  
  return;
end; 

updating procedure DeleteTTrans(record TRVc TRr)
begin
  record TTRVc TTRr;
  Boolean found;

  found = true;
  TTRr.TRNumber = TRr.Number;
  TTRr.TRIntYc = TRr.IntYc;
  while (LoopKey("TRNumber",TTRr,2,found)) begin
    if (TTRr.TRNumber!=TRr.Number) then begin found = false; end;
    if (TTRr.TRIntYc!=TRr.IntYc) then begin found = false; end;
    if (found) then begin
      RecordDelete(TTRr);
      StepBack(TTRr);
    end;
  end;    
  return;
end;

global
updating procedure BatchMain(record TRVc TRp)
begin
  Integer i,j;
  Integer rwcnt;
  row TRVc TRrw;
  record MainVc mainr;
  Date otd;
  Boolean dof;
  
  rwcnt = MatRowCnt(TRp);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(TRp,i,TRrw);
    if (TRrw.stp==1) then begin
      mainr.AccNumber = TRrw.AccNumber;
      mainr.TransDate = TRp.TransDate;
      mainr.TransNr = TRp.Number;
      mainr.FileName = "TRVc";
      mainr.IntYc = TRp.IntYc;
      mainr.TransTime = TRp.RegTime;//Reg time from today is put as time 3 months ago ? 
      if (RecordStore(mainr,false)) then begin end;
    end;
  end;
  otd = TRp.TransDate;
  for (j=rwcnt-1;j>=0;j=j-1) begin
    MatRowGet(TRp,j,TRrw);
    dof = false;
    if (TRrw.stp==2) then begin
      if (otd!=TRrw.OldTransDate) then begin
        dof = true;
      end;
    end;
    if (dof) then begin
        otd = TRrw.OldTransDate;
        for (i=0; i<j;i=i+1) begin
          MatRowGet(TRp,i,TRrw);
          if (TRrw.stp==1) then begin
            mainr.AccNumber = TRrw.AccNumber;
            mainr.TransDate = otd;
            mainr.TransNr = TRp.Number;
            mainr.FileName = "TRVc";
            mainr.IntYc = TRp.IntYc;
            mainr.TransTime = TRp.RegTime;
            if (RecordStore(mainr,false)) then begin end;
          end;
      end;
    end;
  end;
  return;
end;

updating procedure BatchMainAccrual(record TRVc TRp,Boolean deletef)
begin
  Integer i,j;
  Integer rwcnt;
  row TRVc TRrw;
  record MainAccrualVc mainr;
  Date otd;
  Boolean dof;
  
  rwcnt = MatRowCnt(TRp);
  for (i=0; i<rwcnt;i=i+1) begin
    MatRowGet(TRp,i,TRrw);
    if (TRrw.stp==1) then begin
      mainr.AccNumber = TRrw.AccNumber;
      mainr.TransDate = TRp.TransDate;
      mainr.TransNr = TRp.Number;
      mainr.FileName = "TRVc";
      mainr.IntYc = TRp.IntYc;
      mainr.RowNr = i;
      if (deletef) then begin
        if (ReadFirstMain(mainr,0,true)) then begin
          RecordDelete(mainr);
        end;
      end else begin
        if (RecordStore(mainr,false)) then begin end;
      end;
    end;
  end;
  if (deletef) then begin goto LBatchMainAccrual; end;
  otd = TRp.TransDate;
  for (j=rwcnt-1;j>=0;j=j-1) begin
    MatRowGet(TRp,j,TRrw);
    dof = false;
    if (TRrw.stp==2) then begin
      if (otd!=TRrw.OldTransDate) then begin
        dof = true;
      end;
    end;
    if (dof) then begin
        otd = TRrw.OldTransDate;
        for (i=0; i<j;i=i+1) begin
          MatRowGet(TRp,i,TRrw);
          if (TRrw.stp==1) then begin
            mainr.AccNumber = TRrw.AccNumber;
            mainr.TransDate = otd;
            mainr.TransNr = TRp.Number;
            mainr.FileName = "TRVc";
            mainr.IntYc = TRp.IntYc;
           if (RecordStore(mainr,false)) then begin end;
          end;
      end;
    end;
  end;
LBatchMainAccrual:;  
  return;
end;

updating procedure ARAdd3(LongInt InvNr,val PV,Date dtp,string compcode,string compname,string curncy,val bvp)
begin
  record ARVc ARr;
  record ARVc oldARr;
  Boolean found;
  Boolean delf;
  record IVVc IVr;
  
  if (PV!=0) or (bvp!=0) then begin
    delf = false;
    ARr.InvoiceNr = InvNr;
    found = ReadFirstMain(ARr,1,true);
    RecordCopy(oldARr,ARr);
    if (found==false) then begin
      ARr.InvoiceNr = InvNr;
      ARr.RVal = 0;
      ARr.BookRVal = 0;
      IVr.SerNr = InvNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        ARr.CustCode = IVr.CustCode;
        ARr.CustName = IVr.Addr0;
        ARr.ARCurncyCode = IVr.CurncyCode;
        ARr.DueDate = IVr.PayDate;
        ARr.InvDate = IVr.InvDate;
        if (IVr.pdrdays==-1) then begin
          ARr.ARRebDate = IVr.PayDate;
        end else begin
          ARr.ARRebDate = AddDay(IVr.InvDate,IVr.pdrdays);
        end;
        if (IVr.pdrdays2==-1) then begin
          ARr.ARRebDate2 = IVr.PayDate;
        end else begin
          ARr.ARRebDate2 = AddDay(IVr.InvDate,IVr.pdrdays2);
        end;
      end else begin
        ARr.CustCode = compcode;
        ARr.CustName = compname;
        ARr.ARCurncyCode = curncy;
        ARr.DueDate = dtp;
        ARr.InvDate = dtp;
        ARr.ARRebDate = dtp;
      end;
    end;
    ARr.RVal = ARr.RVal + PV;
    ARr.BookRVal = ARr.BookRVal + bvp;
    if (nonblankdate(dtp)) then begin
      ARr.DueDate = dtp;
    end;
    ARInstallmentAdd2(ARr,IVr.PayDeal,-1,PV,bvp,false);
    if (ARr.RVal==0) then begin delf = true; end;
    if (ARr.RVal<0) then begin 
      ARr.DueDate = "";
      ARr.ARRebDate = "";
      ARr.ARRebDate2 = "";
    end;    
    if (delf==false) then begin
      if (found) then begin
        if (ARr.InvoiceNr!=-1) then begin
          if (RecordUpdate(oldARr,ARr,false)==0) then begin end;
        end;
      end else begin
        if (ARr.InvoiceNr!=-1) then begin
          if (RecordStore(ARr,false)) then begin end;
        end;
      end;
    end else begin
      if (found==true) then begin
        RecordDelete(oldARr);
      end;
    end;
  end;
  return;
end;

updating procedure APAdd3(LongInt InvNr,val PV,Date dtp,string compcode,string compname,string curncy,val bvp)
begin
  record APVc APr;
  record APVc oldAPr;
  Boolean found;
  Boolean delf;
  record VIVc VIr;
  record CUVc VEr;
  
  if (PV!=0) or (bvp!=0) then begin
    delf = false;
    APr.SerNr = InvNr;
    found = ReadFirstMain(APr,1,true);    
    RecordCopy(oldAPr,APr);
    if (found==false) then begin
      APr.SerNr = InvNr;
      APr.InvoiceNr = "";
      APr.RVal = 0;
      APr.BookRVal = 0;
      VIr.SerNr = InvNr;
      if (ReadFirstMain(VIr,1,true)) then begin
        APr.VECode = VIr.VECode;
        APr.VEName = VIr.VEName;
        APr.CurncyCode = VIr.CurncyCode;
        APr.DueDate = VIr.DueDate;
      end else begin
        VEr.Code = compcode;
        if (ReadFirstMain(VEr,1,true)) then begin
          APr.VECode = VEr.Code;
          APr.VEName = VEr.Name;
        end else begin
          APr.VECode = compcode;
          APr.VEName = compname;
        end;        
        APr.CurncyCode = curncy;
        APr.DueDate = dtp;
      end;
    end;
    APr.RVal = APr.RVal + PV;
    APr.BookRVal = APr.BookRVal + bvp;
    APInstallmentAdd2(APr,-1,PV,bvp,dtp,false,"",false);
    if (APr.RVal==0) then begin delf = true; end;
    if (delf==false) then begin
      if (found) then begin
        if (RecordUpdate(oldAPr,APr,false)==0) then begin end;
      end else begin
        if (RecordStore(APr,false)) then begin end;
      end;
    end else begin
      if (found==true) then begin
        RecordDelete(oldAPr);
      end;
    end;
  end;
  return;
end;

updating procedure TRrsStats(record TRVc TRp,row TRVc TRrwp)
begin
  record IPrsVc mainr;
  
  mainr.CustCode = TRrwp.CompCode;
  mainr.TransDate = TRp.TransDate;
  mainr.CustDate = TRp.TransDate;
  mainr.TransNr = TRp.Number;
  mainr.IntYc = TRp.IntYc;
  mainr.TransType = kIPrsTransTypeNLTransaction;
  mainr.AccNr = TRrwp.AccNumber;
  mainr.IVNr = TRrwp.SerNr;
  if (RecordStore(mainr,false)) then begin end;
  return;
end;

updating procedure TRrsStats2(record TRVc TRp,row TRVc TRrwp)
begin
  record OPrsVc mainr;
  string 255 tstr;
  
  mainr.VECode = TRrwp.CompCode;
  mainr.TransDate = TRp.TransDate;
  mainr.TransNr = TRp.Number;
  mainr.IntYc = TRp.IntYc;
  mainr.TransType = kOPrsTransTypeNLTransaction;
  mainr.VINr = TRrwp.SerNr;
  mainr.AccNr = TRrwp.AccNumber;
  if (RecordStore(mainr,false)) then begin end;
  return;
end;

updating procedure AddCorrMark(LongInt NewNr,Integer NewYc,Date td,row TRVc Trrwp)
begin
  Integer i;
  record TRVc oldTRr;
  record TRVc TRr;
  Boolean Trs;
  row TRVc TRrw;
  Integer rwcnt;

  TRr.IntYc = Trrwp.CorrYc;
  TRr.Number = Trrwp.CorrNr;
  Trs = ReadFirstMain(TRr,2,true);
  if ((Trs==true) and (MatRowCnt(TRr)>0)) then begin
    RecordCopy(oldTRr,TRr);
    rwcnt = MatRowCnt(TRr);    
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      if (TRrw.stp==3) then begin
        if ((TRrw.CorrNr==NewNr) and (TRrw.CorrYc==NewYc)) then begin
          goto LAddCorrMark;
        end;
      end;
    end;
    ClearRow(TRr,TRrw,3);
    TRrw.stp = 3;
    TRrw.ovst = 0;
    TRrw.CorrNr = NewNr;
    TRrw.CorrYc = NewYc;
    TRrw.CorrDate = td;
    MatRowPut(TRr,rwcnt,TRrw);
    if (RecordUpdate(oldTRr,TRr,false)==0) then begin end;
  end;
LAddCorrMark:;
  return;
end;

global
updating procedure AddTrans(record TRVc TRp,Boolean toarchive,Boolean importf,Boolean deletef)
begin
  record IVVc IVr;
  record VIVc VIr;
  record CUVc CUr;  
  record CUVc VEr;  
  Integer i,oldstyle;
  row TRVc TRrw;
  Integer rwcnt;
  string 255 balostr,tstr;
  Integer typofcur,pos;
  val t,sum,bv,v;
  val frrate,to1,to2,br1,br2;
  val curval,baseval;
  record BaseCurBlock bcur;
  record IPrsVc IPrsr;
  record OPrsVc OPrsr;
  Date rd;
  Boolean found;
  
  if (blankdate(TRp.TransDate)) then begin goto LAddTrans; end;
  BlockLoad(bcur);
  rwcnt = MatRowCnt(TRp);
  for (i=0;i<rwcnt;i=i+1)  begin
    MatRowGet(TRp,i,TRrw);
    switch (TRrw.stp) begin
      case 1: 
      if (TRrw.ovst==0) then begin
        UpdateBal(TRp.TransDate,TRrw.AccNumber,TRrw.Objects,TRrw.DebVal,TRrw.CredVal,"transdebit",TRrw.VATCode,toarchive);
        UpdateBal(TRp.TransDate,TRrw.AccNumber,TRrw.Objects,TRrw.DebVal2,TRrw.CredVal2,"transdebit2",TRrw.VATCode,toarchive);
        if (toarchive) Then begin
          AddHistoryToArchive("MainVc",TRrw.AccNumber,TRrw.Objects,TRp.TransDate,TRrw.Curncy,TRrw.DebVal,TRrw.CredVal,TRrw.DebVal2,TRrw.CredVal2,TRrw.CurDebVal,TRrw.CurCredVal);
        end;
        if (TRrw.Qty!=0) then begin
          if (TRrw.DebVal==0) then begin
            TRrw.Qty = -TRrw.Qty;
          end;          
          UpdateQuantBal(TRp.TransDate,TRrw.AccNumber,TRrw.Objects,TRrw.Qty,toarchive,deletef);
        end;                    
        if (TRrw.Reconsf!=0) then begin
          rd = TRrw.ReconDate;
          if (blankdate(rd)) then begin
            rd = TRp.TransDate;
          end;

          balostr = ";;;";
          UpdateObjBal(TRrw.AccNumber,balostr,rd,TRrw.DebVal,TRrw.CredVal,"transdebit",toarchive);
          UpdateObjBal(TRrw.AccNumber,balostr,rd,TRrw.DebVal2,TRrw.CredVal2,"transdebit2",toarchive);

          pos = 0;
          ExtractObj(TRrw.Objects,pos,balostr);
          while (nonblank(balostr)) begin
            balostr = balostr & ";;;";
            UpdateObjBal(TRrw.AccNumber,balostr,rd,TRrw.DebVal,TRrw.CredVal,"transdebit",toarchive);
            UpdateObjBal(TRrw.AccNumber,balostr,rd,TRrw.DebVal2,TRrw.CredVal2,"transdebit2",toarchive);
            ExtractObj(TRrw.Objects,pos,balostr);
          end;
        end;
        if (nonblank(TRrw.Curncy)) then begin
          MockObjFromVATCode(TRrw.Curncy,balostr);
          UpdateObjBal(TRrw.AccNumber,balostr,TRp.TransDate,TRrw.CurDebVal,TRrw.CurCredVal,"transdebit",toarchive);
        end;
        if (nonblank(TRrw.CompCode)) then begin          
          MockObjFromCompCode(TRrw.CompCode,balostr,TRrw.Typ);
          UpdateObjBal(TRrw.AccNumber,balostr,TRp.TransDate,TRrw.DebVal,TRrw.CredVal,"transdebit",toarchive);
          UpdateObjBal(TRrw.AccNumber,balostr,TRp.TransDate,TRrw.DebVal2,TRrw.DebVal2,"transdebit2",toarchive);
// The typofcur changes will make the SalesLedger different, this is correct though. 
          typofcur = TypeOfCurncy(TRrw.Curncy,oldstyle);
          if (TRrw.Typ==kTransactionRowTypeCustomer) then begin
            curval = TRrw.CurDebVal - TRrw.CurCredVal;
            baseval = TRrw.DebVal - TRrw.CredVal;
            if (typofcur==2) then begin
              curval = TRrw.DebVal2 - TRrw.CredVal2;
            end;
          end else begin
            curval = TRrw.CurCredVal - TRrw.CurDebVal;
            baseval = TRrw.CredVal - TRrw.DebVal;
            if (typofcur==2) then begin
              curval = TRrw.CredVal2 - TRrw.DebVal2;
            end;
          end;
          if ((blank(TRrw.CurDebVal)) and (blank(TRrw.CurCredVal)) and (typofcur!=2)) then begin
            curval = baseval; //cannot be?, foreign cur = base cur
          end;
          if (TRrw.Typ==kTransactionRowTypeCustomer) then begin              
            CUr.Code = TRrw.CompCode;
             if (ReadFirstMain(CUr,1,true)==false) then begin
               tstr = TRrw.Comment;
             end else begin
               tstr = CUr.Name;
             end;
            if (TRrw.SerNr!=-1) then  begin
              if (TRp.IntYc<201) then begin
                ARAdd3(TRrw.SerNr,curval,TRrw.DueDate,TRrw.CompCode,tstr,TRrw.Curncy,baseval); // ,toarchive
                if (importf==false) then begin
                  StoreLiqInfoFromTR(TRp,TRrw,i);
                end;
              end;
            end;
          end;
          if (TRrw.Typ==kTransactionRowTypeSupplier) then begin
            VEr.Code = TRrw.CompCode;
            if (ReadFirstMain(VEr,1,true)==false) then begin
              tstr = TRrw.Comment;
            end else begin
              tstr = VEr.Name;
            end;
            if (TRrw.SerNr!=-1) then begin
              if (TRp.IntYc<201) then begin
                APAdd3(TRrw.SerNr,curval,TRrw.DueDate,TRrw.CompCode,tstr,TRrw.Curncy,baseval); // ,toarchive
                if (importf==false) then begin
                  StoreLiqInfoFromTR(TRp,TRrw,i);
                end;
              end;
            end;
          end;
        end;
// What about Import and Update mark ,import works, update mark is "prohibited"
        if ((TRrw.Typ==kTransactionRowTypeCustomer) and (TRp.IntYc<201)) then begin//and (TRrw.SerNr!=-1) on account didn't work
          if (TRrw.SerNr!=-1) then begin
            sum = blankval;
            frrate = TRrw.FrRate;
            to1 = TRrw.ToRateB1;
            to2 = TRrw.ToRateB2;
            br1 = TRrw.BaseRate1;
            br2 = TRrw.BaseRate2;
            if (TRrw.DebVal!=0) then begin
              bv = TRrw.DebVal;
              v = TRrw.DebVal;
              if (nonblank(TRrw.CurDebVal)) then begin
                if (nonblank(CUr.CurncyCode)) then begin
                  v = TRrw.CurDebVal;
                end;
              end else begin
                if (typofcur==2) then begin
                  v = TRrw.DebVal2;
                end;
              end;
              t = blankval;
              CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","","",TRp.TransDate,blankval,blankval,v,blankval,bv,blankval,false); // ,toarchive, CustStatUp for Invoices
              if (nonblank(TRrw.Curncy)) and (TRrw.Curncy!=bcur.BaseCur1) then begin
                CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","",TRrw.Curncy,TRp.TransDate,blankval,blankval,TRrw.CurDebVal,blankval,bv,blankval,false); // ,toarchive, CustStatUp for Invoices
              end;
            end;
            if (TRrw.CredVal!=0) then begin
              bv = TRrw.CredVal;
              t = TRrw.CredVal;
              if (nonblank(TRrw.CurCredVal)) then begin
                if (nonblank(CUr.CurncyCode)) then begin
                  t = TRrw.CurCredVal;//multiply by invoice rate?
                end;
              end else begin
                if (typofcur==2) then begin
//                t = TRrw.CredVal2;
//multiply by invoice rate?
                  t = TRrw.CredVal;
                end;
              end;
              CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","","",TRp.TransDate,blankval,blankval,t,blankval,bv,blankval,true); // ,toarchive
              if (nonblank(TRrw.Curncy)) and (TRrw.Curncy!=bcur.BaseCur1) then begin
                CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","",TRrw.Curncy,TRp.TransDate,blankval,blankval,TRrw.CurCredVal,blankval,bv,blankval,true); // ,toarchive, CustStatUp for Invoices
              end;
            end;
          end else begin
            if (nonblank(TRrw.CompCode)) then begin
              bv = TRrw.DebVal - TRrw.CredVal;
              if ((blank(TRrw.CurDebVal)==false) or (blank(TRrw.CurCredVal)==false)) then begin
                v = TRrw.CurDebVal - TRrw.CurCredVal;
                if (typofcur==2) then begin
                  v = TRrw.DebVal2 - TRrw.CredVal2;
                end;
              end else begin
                v = TRrw.DebVal - TRrw.CredVal;
                if (typofcur==2) then begin
                  v = TRrw.DebVal2 - TRrw.CredVal2;
                end;
              end;
              t = blankval;

              bv = -bv;//interestinbg , same in recipts
              v = -v;
              CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","","",TRp.TransDate,t,t,v,t,bv,t,true); // ,toarchive //this is payemnt  and payemtns to negf true
              if (nonblank(TRrw.Curncy)) and (TRrw.Curncy!=bcur.BaseCur1) then begin
                CustStatUp("TRVc",TRp.Number,TRrw.CompCode,TRrw.CompCode,"","",TRrw.Curncy,TRp.TransDate,t,t,v,t,bv,t,true); // ,toarchive, CustStatUp for Invoices
              end;
            end;
          end;
          if (deletef) then begin
            ResetLoop(IPrsr);
            IPrsr.IVNr = TRrw.SerNr;
            IPrsr.TransType = kIPrsTransTypeNLTransaction;
            IPrsr.TransNr = TRp.Number;
            found = true;
            while (LoopKey("IVKey",IPrsr,3,found)) begin
              if (IPrsr.IVNr!=TRrw.SerNr) then begin found = false; end;
              if (IPrsr.TransType!=kIPrsTransTypeNLTransaction) then begin found = false; end;
              if (IPrsr.TransNr!=TRp.Number) then begin found = false; end;
              if (found) then begin
                if (IPrsr.IntYc==TRp.IntYc) then begin
                  RecordDelete(IPrsr);
                  found = false;
                end;
              end;
            end;
          end else begin
            TRrsStats(TRp,TRrw);
          end;
        end;
        if ((TRrw.Typ==kTransactionRowTypeSupplier) and (TRp.IntYc<201)) then begin//and (TRrw.SerNr!=-1)          
          if (deletef) then begin
            ResetLoop(OPrsr);
            OPrsr.VINr = TRrw.SerNr;
            OPrsr.TransType = kOPrsTransTypeNLTransaction;
            OPrsr.TransNr = TRp.Number;
            found = true;
            while (LoopKey("VIKey",OPrsr,3,found)) begin
              if (OPrsr.VINr!=TRrw.SerNr) then begin found = false; end;
              if (OPrsr.TransType!=kOPrsTransTypeNLTransaction) then begin found = false; end;
              if (OPrsr.TransNr!=TRp.Number) then begin found = false; end;
              if (found) then begin
                if (OPrsr.IntYc==TRp.IntYc) then begin
                  RecordDelete(OPrsr);
                  found = false;
                end;
              end;
            end;
          end else begin
            TRrsStats2(TRp,TRrw);
          end;
          if (TRrw.SerNr!=-1) then begin
            sum = blankval;
            frrate = TRrw.FrRate;
            to1 = TRrw.ToRateB1;
            to2 = TRrw.ToRateB2;
            br1 = TRrw.BaseRate1;
            br2 = TRrw.BaseRate2;
            if (TRrw.DebVal!=0) then begin//Payment
              bv = TRrw.DebVal;
              t = TRrw.DebVal;
              if (blank(TRrw.CurDebVal)==false) then begin
                if (nonblank(VEr.VECurncyCode)) then begin
                  t = TRrw.CurDebVal;
                end;
              end else begin
                if (typofcur==2) then begin
                  if (nonblank(VEr.VECurncyCode)) then begin
                    t = TRrw.DebVal2;
                  end;
                end;
              end;
              VendStatUp("TRVc",TRp.Number,TRrw.CompCode,"",TRp.TransDate,blankval,blankval,t,bv,true);
            end;
            if (TRrw.CredVal!=0) then begin//invoice 
              bv = TRrw.CredVal;
              t = TRrw.CurCredVal;
              if ((blank(VEr.VECurncyCode)) or (VEr.VECurncyCode==bcur.BaseCur1)) then begin
                t = TRrw.CredVal;
              end;
              VendStatUp("TRVc",TRp.Number,TRrw.CompCode,"",TRp.TransDate,t,t,blankval,bv,false); // ,toarchive
            end;
          end else begin
            if (nonblank(TRrw.CompCode)) then begin
              bv = TRrw.DebVal - TRrw.CredVal;
              if ((blank(TRrw.CurDebVal)==false) or (blank(TRrw.CurCredVal)==false)) then begin
                if (nonblank(VEr.VECurncyCode)) then begin
                  t = TRrw.CurDebVal - TRrw.CurCredVal;
                  if (typofcur==2) then begin
                    t = TRrw.DebVal2 - TRrw.CredVal2;
                  end;
                end else begin
                  t = TRrw.DebVal - TRrw.CredVal;
                end;
              end else begin
                t = TRrw.DebVal - TRrw.CredVal;
                if (typofcur==2) then begin
                  t = TRrw.DebVal2 - TRrw.CredVal2;
                end;
              end;
//multiply by invoice rate ?           
              VendStatUp("TRVc",TRp.Number,TRrw.CompCode,"",TRp.TransDate,sum,sum,t,bv,true); // ,toarchive
            end;
          end;
         end;
       end;
      case 4:
        if (toarchive==false) then begin
          AddCorrMark(TRp.Number,TRp.IntYc,TRp.TransDate,TRrw);
        end;
    end;
  end;
LAddTrans:;
  return;
end;

global
updating function LongInt TRVcRecordSaveAfter(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record SRBlock SRRec;
  record RTViiteNumBlock RTr;
      
  BlockLoad(SRRec);
  AddTrans(TRr,false,false,false);
  BatchMain(TRr);

//  BatchMainAccrual(TRr,false);
  SetLastTransDate(TRr.TransDate);
  if (SRRec.LastRegDate!=TRr.RegDate) then begin
    SRRec.LastRegDate = TRr.RegDate;
    BlockStore(SRRec);
  end;
  BlockLoad(RTr);
  if (RTr.RT==1) then begin
    UpdateROHis(TRr,TR2r,0);
  end;  
  if (TRr.IntYc<IVYc) then begin
    AddTTrans_TRVc(TRr);
  end;
  CreateIntercompanyTransactionsFromTR(TRr);
  TRVcRecordSaveAfter = res;  
  return;
end;

procedure ConvertTRtoDualBase(record TRVc TRp)
begin
  row TRVc TRrw;
  Integer rwcnt,i;
  val fr,to1,to2,br1,br2,temp;
  string 10 curncy;

  rwcnt = MatRowCnt(TRp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TRp,i,TRrw);
    if (TRrw.FrRate==0) then begin
//      if (TRrw.DebVal==0) then begin
      if (blank(TRrw.DebVal)) then begin     
        if (TRrw.CredVal==0) then begin
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.CredVal2 = TRrw.CredVal2*temp;          
          curncy = TRrw.Curncy;
          fr = TRrw.FrRate;
          to1 = TRrw.ToRateB1;
          to2 = TRrw.ToRateB2;
          br1 = TRrw.BaseRate1;
          br2 = TRrw.BaseRate2;
          temp = TRrw.CurCredVal;
          ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
          TRrw.Curncy = curncy;
          TRrw.FrRate = fr;
          TRrw.ToRateB1 = to1;
          TRrw.ToRateB2 = to2;
          TRrw.BaseRate1 = br1;
          TRrw.BaseRate2 = br2;
          TRrw.CurCredVal = temp;
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.CredVal2 = TRrw.CredVal2/temp;
        end else begin
          curncy = TRrw.Curncy;
          fr = TRrw.FrRate;
          to1 = TRrw.ToRateB1;
          to2 = TRrw.ToRateB2;
          br1 = TRrw.BaseRate1;
          br2 = TRrw.BaseRate2;
          temp = TRrw.CurCredVal;
          ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
          TRrw.Curncy = curncy;
          TRrw.FrRate = fr;
          TRrw.ToRateB1 = to1;
          TRrw.ToRateB2 = to2;
          TRrw.BaseRate1 = br1;
          TRrw.BaseRate2 = br2;
          TRrw.CurCredVal = temp;
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.CredVal2 = TRrw.CredVal/temp;
        end;
      end else begin
        if (TRrw.DebVal==0) then begin
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.DebVal2 = TRrw.DebVal2*temp;          
          curncy = TRrw.Curncy;
          fr = TRrw.FrRate;
          to1 = TRrw.ToRateB1;
          to2 = TRrw.ToRateB2;
          br1 = TRrw.BaseRate1;
          br2 = TRrw.BaseRate2;
          temp = TRrw.CurDebVal;
          ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
          TRrw.Curncy = curncy;
          TRrw.FrRate = fr;
          TRrw.ToRateB1 = to1;
          TRrw.ToRateB2 = to2;
          TRrw.BaseRate1 = br1;
          TRrw.BaseRate2 = br2;
          TRrw.CurDebVal = temp;
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.DebVal2 = TRrw.DebVal2/temp;
        end else begin
          curncy = TRrw.Curncy;
          fr = TRrw.FrRate;
          to1 = TRrw.ToRateB1;
          to2 = TRrw.ToRateB2;
          br1 = TRrw.BaseRate1;
          br2 = TRrw.BaseRate2;
          temp = TRrw.CurDebVal;
          ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
          TRrw.Curncy = curncy;
          TRrw.FrRate = fr;
          TRrw.ToRateB1 = to1;
          TRrw.ToRateB2 = to2;
          TRrw.BaseRate1 = br1;
          TRrw.BaseRate2 = br2;
          TRrw.CurDebVal = temp;
          temp = TRrw.BaseRate1/TRrw.BaseRate2;
          TRrw.DebVal2 = TRrw.DebVal/temp;
        end;
      end;
      TRrw.DebVal2 = Round(TRrw.DebVal2,DefaultRoundMode);
      TRrw.CredVal2 = Round(TRrw.CredVal2,DefaultRoundMode);
    end else begin
      if (TRrw.DebVal==0) then begin
        curncy = TRrw.Curncy;
        fr = TRrw.FrRate;
        to1 = TRrw.ToRateB1;
        to2 = TRrw.ToRateB2;
        br1 = TRrw.BaseRate1;
        br2 = TRrw.BaseRate2;
        temp = TRrw.CurCredVal;
        ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
        TRrw.Curncy = curncy;
/*
        TRrw.FrRate = fr;
        TRrw.ToRateB1 = to1;
        TRrw.ToRateB2 = to2;
*/        
        TRrw.BaseRate1 = br1;
        TRrw.BaseRate2 = br2;
        TRrw.CurCredVal = temp;
        temp = TRrw.BaseRate1/TRrw.BaseRate2;
        TRrw.CredVal2 = TRrw.CredVal/temp;
      end else begin
        curncy = TRrw.Curncy;
        fr = TRrw.FrRate;
        to1 = TRrw.ToRateB1;
        to2 = TRrw.ToRateB2;
        br1 = TRrw.BaseRate1;
        br2 = TRrw.BaseRate2;
        temp = TRrw.CurCredVal;
        ConvertToDualBase(curncy,TRp.TransDate,fr,to1,to2,br1,br2,temp,false);
        TRrw.Curncy = curncy;
/*
        TRrw.FrRate = fr;
        TRrw.ToRateB1 = to1;
        TRrw.ToRateB2 = to2;
*/        
        TRrw.BaseRate1 = br1;
        TRrw.BaseRate2 = br2;
        TRrw.CurCredVal = temp;      
        temp = TRrw.BaseRate1/TRrw.BaseRate2;
        TRrw.DebVal2 = TRrw.DebVal/temp;
      end;
      TRrw.DebVal2 = Round(TRrw.DebVal2,DefaultRoundMode);
      TRrw.CredVal2 = Round(TRrw.CredVal2,DefaultRoundMode);
    end;
    MatRowPut(TRp,i,TRrw);
  end;
  if (CheckTrans(TRp,1,false)=="") then begin end;
  return;
end;

procedure TRVcConvertB1ToB2Date(record TRVc TRp,Date datp)
begin
  val br1,br2,t;
  row TRVc TRrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(TRp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TRp,i,TRrw);
    br1 = TRrw.ToRateB1;
    br2 = TRrw.ToRateB2;
    SwapM4Val(br1,br2);
    TRrw.ToRateB1 = br1;
    TRrw.ToRateB2 = br2;
    br1 = TRrw.BaseRate1;
    br2 = TRrw.BaseRate2;
    SwapM4Val(br1,br2);
    TRrw.BaseRate1 = br1;
    TRrw.BaseRate2 = br2;
    br1 = TRrw.DebVal;
    br2 = TRrw.DebVal2;
    SwapM4Val(br1,br2);
    TRrw.DebVal = br1;
    TRrw.DebVal2 = br2;
    br1 = TRrw.CredVal;
    br2 = TRrw.CredVal2;
    SwapM4Val(br1,br2);
    TRrw.CredVal = br1;
    TRrw.CredVal2 = br2;
    B1ToB2Val(TRrw.NomVal,TRrw.BaseRate1,TRrw.BaseRate2,t);
    TRrw.NomVal = t;
    MatRowPut(TRp,i,TRrw);
  end;
  TRSumup(TRp,t);
  return;
end;

global
function LongInt TRVcRecordImportTest(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  row TRVc TRrw;
  Integer i,rwcnt;
  record YearBlock Yb;
  row YearBlock Ybrw;
  Boolean found;
  
  res = 1;
/*  
  BlockLoad(Yb);
  rwcnt = MatRowCnt(Yb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Yb,i,Ybrw);
    if (Ybrw.IntYc==TRr.IntYc) then begin
      found = true;
      i = rwcnt;
    end;
  end;
  if (found==false) then begin
LogText(0,"found " & found & " TRr.Number " & TRr.Number & " TRr.IntYc " & TRr.IntYc & " TRr.TransDate " & TRr.TransDate);  
  end;
*/  
  rwcnt = MatRowCnt(TRr);
/*  
  if (rwcnt==0) then begin 
    res = 0; 
    goto LTRVcRecordImportTest;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TRr,i,TRrw);
    if (blank(TRrw.AccNumber)) then begin      
      res = 0;
      goto LTRVcRecordImportTest;
    end;
  end;
*/  
LTRVcRecordImportTest:;  
  TRVcRecordImportTest = res;
  return;
end;

global
updating function LongInt TRVcRecordImport(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record TRVc lTRr;
  record TRVc fakeTRr;
  Boolean gBase1ToBase2,gToDualBase;
  record ConvMasterBlock cvm;
  
  lTRr.Number = TRr.Number;
  lTRr.IntYc = TRr.IntYc;  
  if ((ReadFirstMain(lTRr,2,true)==false) or (Importing==false)) then begin//Importing==false??????
    BlockLoad(cvm);  
    if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
    if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
    if (gToDualBase) then begin
      ConvertTRtoDualBase(TRr);
    end;
    if (gBase1ToBase2) then begin
      TRVcConvertB1ToB2Date(TRr,TRr.TransDate);
    end;
    if (TRTestAccs(TRr)) then begin end;
    TRTestVATCode(TRr);
    res = TRVcRecordSave(TRr,fakeTRr,-1,-1);
    if (TRr.Number<=0) then begin
      TRr.Number = NextSerNr("TRVc",TRr.TransDate,-1,false,"");            
    end;
  end;
  if (CheckTrans(TRr,0,false)=="") then begin end;
  TRVcRecordImport = res;  
  return;
end;

global
updating function LongInt TRVcRecordImportAfter(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record SRBlock SRRec;
  record RTViiteNumBlock RTr;
      
  BlockLoad(SRRec);
  AddTrans(TRr,false,true,false);
  BatchMain(TRr);
//  BatchMainAccrual(TRr,false);
  if (LastTransDate<TRr.TransDate) then begin
    SetLastTransDate(TRr.TransDate);
  end;
  if (SRRec.LastRegDate!=TRr.RegDate) then begin
    SRRec.LastRegDate = TRr.RegDate;
    BlockStore(SRRec);
  end;
  BlockLoad(RTr);
  if (RTr.RT==1) then begin
    UpdateROHis(TRr,TR2r,0);
  end;    
  TRVcRecordImportAfter = res;  
  return;
end;

global
procedure NegateTrans(Integer frr,var record TRVc TRp)
begin
  row TRVc TRrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(TRp);
  for (i=frr;i<rwcnt;i=i+1) begin
    MatRowGet(TRp,i,TRrw);
    switch (TRrw.stp) begin
      case 1:
        if (TRrw.ovst==0) then begin
          TRrw.DebVal = -TRrw.DebVal;
          TRrw.CredVal = -TRrw.CredVal;
          TRrw.DebVal2 = -TRrw.DebVal2;
          TRrw.CredVal2 = -TRrw.CredVal2;
          TRrw.CurDebVal = -TRrw.CurDebVal;
          TRrw.CurCredVal = -TRrw.CurCredVal;
          TRrw.Qty = -TRrw.Qty;
          MatRowPut(TRp,i,TRrw);
        end;
    end;
  end;
  return;
end;

global
updating function LongInt TRVcRecordUpdate(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record TRVc lTRr;
      
  RecordCopy(lTRr,TR2r);
  NegateTrans(0,lTRr);
  AddTrans(lTRr,false,false,true);
  TRr.LastChangeDate = CurrentDate;
  TRVcRecordUpdate = res;  
  return;
end;

global
updating function LongInt TRVcRecordUpdateAfter(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record RTViiteNumBlock RTr;
      
  BatchMain(TRr);
//  BatchMainAccrual(TRr,false);
  AddTrans(TRr,false,false,false);
  BlockLoad(RTr);
  if (RTr.RT==1) then begin
    UpdateROHis(TRr,TR2r,1);
  end;
//  DeleteTTrans(TR2r);
  TRVcRecordUpdateAfter = res;  
  return;
end;

global
updating function LongInt TRVcRecordRemove(var record TRVc TRr,record TRVc TR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record TRVc lTRr;
  record RTViiteNumBlock RTr;
      
  RecordCopy(lTRr,TRr);
  NegateTrans(0,lTRr);
  AddTrans(lTRr,false,false,true);
  BlockLoad(RTr);
  if (RTr.RT==1) then begin
    UpdateROHis(TRr,TR2r,2);
  end;  
//  BatchMainAccrual(TRr,true);
  TRVcRecordRemove = res;  
  return;
end;


procedure PurgeTRVcConvertB1ToB2Date(record PurgeTRVc PurgeTRp,Date datp)
begin
  val br1,br2,t;

  br1 = PurgeTRp.ToRateB1;
  br2 = PurgeTRp.ToRateB2;
  SwapM4Val(br1,br2);
  PurgeTRp.ToRateB1 = br1;
  PurgeTRp.ToRateB2 = br2;
  br1 = PurgeTRp.BaseRate1;
  br2 = PurgeTRp.BaseRate2;
  SwapM4Val(br1,br2);
  PurgeTRp.BaseRate1 = br1;
  PurgeTRp.BaseRate2 = br2;
  br1 = PurgeTRp.DebVal;
  br2 = PurgeTRp.DebVal2;
  SwapM4Val(br1,br2);
  PurgeTRp.DebVal = br1;
  PurgeTRp.DebVal2 = br2;
  br1 = PurgeTRp.CredVal;
  br2 = PurgeTRp.CredVal2;
  SwapM4Val(br1,br2);
  PurgeTRp.CredVal = br1;
  PurgeTRp.CredVal2 = br2;
  return;
end;

global
updating function LongInt PurgeTRVcRecordImport(var record PurgeTRVc PurgeTRr,record PurgeTRVc PurgeTR2r,LongInt long3,LongInt long4)
begin
  LongInt res;  
  record PurgeTRVc lPurgeTRr;
  record PurgeTRVc fakePurgeTRr;
  Boolean gBase1ToBase2,gToDualBase;
  record ConvMasterBlock cvm;
  
  lPurgeTRr.Number = PurgeTRr.Number;
  lPurgeTRr.IntYc = PurgeTRr.IntYc;  
  lPurgeTRr.TransRow = PurgeTRr.TransRow;  
  if ((ReadFirstMain(lPurgeTRr,3,true)==false) or (Importing==false)) then begin//Importing==false??????
    BlockLoad(cvm);  
    if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
    if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
/*    
    if (gToDualBase) then begin
      ConvertTRtoDualBase(TRr);
    end;
*/    
    if (gBase1ToBase2) then begin
      PurgeTRVcConvertB1ToB2Date(PurgeTRr,PurgeTRr.TransDate);
    end;
  end;
  PurgeTRVcRecordImport = res;  
  return;
end;

global
updating function LongInt PurgeTRVcRecordImportAfter(var record PurgeTRVc PurgeTRr,record PurgeTRVc PurgeTR2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  record CUVc CUr;
  record CUVc VEr; 
  string 255 tstr;
  Integer typofcur,oldstyle;
  val t;
  val curval,baseval;
  
  switch (PurgeTRr.Typ) begin
    case kTransactionRowTypeCustomer:
      PurgeIPTRrsStats(PurgeTRr);
      CUr.Code = PurgeTRr.CompCode;
      if (ReadFirstMain(CUr,1,true)==false) then begin
        tstr = PurgeTRr.CompCode;
      end else begin
        tstr = CUr.Name;
      end;
      if (PurgeTRr.SerNr!=-1) then  begin
        if (PurgeTRr.IntYc<201) then begin
          typofcur = TypeOfCurncy(PurgeTRr.Curncy,oldstyle);
          curval = PurgeTRr.CurDebVal - PurgeTRr.CurCredVal;
          baseval = PurgeTRr.DebVal - PurgeTRr.CredVal;
          if (typofcur==2) then begin
            curval = PurgeTRr.DebVal2 - PurgeTRr.CredVal2;
          end;
          if ((blank(PurgeTRr.CurDebVal)) and (blank(PurgeTRr.CurCredVal)) and (typofcur!=2)) then begin
            curval = baseval; //cannot be?, foreign cur = base cur
          end;          
          ARAdd3(PurgeTRr.SerNr,curval,PurgeTRr.DueDate,PurgeTRr.CompCode,tstr,PurgeTRr.Curncy,-PurgeTRr.CredVal); // ,toarchive
        end;
      end;
    case kTransactionRowTypeSupplier:
      PurgeOPTRrsStats(PurgeTRr);
      VEr.Code = PurgeTRr.CompCode;
      if (ReadFirstMain(VEr,1,true)==false) then begin
        tstr = PurgeTRr.CompCode;
      end else begin
        tstr = VEr.Name;
      end;
      if (PurgeTRr.SerNr!=-1) then begin
        if (PurgeTRr.IntYc<201) then begin
          curval = PurgeTRr.CurCredVal - PurgeTRr.CurDebVal;
          baseval = PurgeTRr.CredVal - PurgeTRr.DebVal;
          if (typofcur==2) then begin
            curval = PurgeTRr.CredVal2 - PurgeTRr.DebVal2;
          end;
          if ((blank(PurgeTRr.CurDebVal)) and (blank(PurgeTRr.CurCredVal)) and (typofcur!=2)) then begin
            curval = baseval; //cannot be?, foreign cur = base cur
          end;               
          APAdd3(PurgeTRr.SerNr,curval,PurgeTRr.DueDate,PurgeTRr.CompCode,tstr,PurgeTRr.Curncy,baseval); // ,toarchive
        end;
      end;
  end;
  PurgeTRVcRecordImportAfter = res;
  return;
end;
