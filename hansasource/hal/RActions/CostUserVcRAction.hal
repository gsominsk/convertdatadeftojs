external procedure SwapM4Val(var val,var val);
external procedure ConvertToDualBase(var string,date,var val,var val,var val,var val,var val,var val,Boolean);
external function Integer IsUnOKAllowed_CostUserVc(record CostUserVc);

global
function LongInt CostUserVcRecordDefaults(var record CostUserVc CostUserr,record CostUserVc CostUser2r,LongInt long3,LongInt long4)
begin
  record UserVc Userr;
  
  CostUserr.Person = CurrentUser;
  Userr.Code = CostUserr.Person;
  if (ReadFirstMain(Userr,1,true)) then begin
    CostUserr.PersonName = Userr.Name;
  end;
  CostUserr.TransDate = CurrentDate;
  CostUserr.OKFlag = 0;
  CostUserVcRecordDefaults = -1;
  return;
end;

global
function LongInt CostUserVcRecordDuplicate(var record CostUserVc CostUserr,record CostUserVc CostUser2r,LongInt long3,LongInt long4)
begin
  CostUserr.TransDate = CurrentDate;
  CostUserr.OKFlag = 0;
  CostUserr.SerNr = -1;
  CostUserVcRecordDuplicate = -1;
  return;
end;

global
function LongInt CostUserVcRecordCheck(var record CostUserVc CostUserr,record CostUserVc CostUser2r,LongInt stat,LongInt check)
begin
  LongInt res;
  record UserVc Userr;
  record ObjVc Objr;
  record CostUserVc lCostUserr;
  Boolean transf,unokf,checkf,TrHs;
  Integer insertmode,updatemode,error;
  Integer i,rwcnt;
  row CostUserVc CostUserrw;
  Date td;

  res = 0;
  insertmode = 1;//Rs_insert
  updatemode = 2;//Rs_update
  if (check>0) then begin
    checkf = true;
  end else begin
    checkf = false;
  end;
  transf = false;
  if (CostUserr.OKFlag==1) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if (CostUser2r.OKFlag==0) then begin transf = true; end;
    end;
  end;
  if (CostUserr.OKFlag==0) then begin
    if (stat==updatemode) then begin
      if (CostUser2r.OKFlag==1) then begin unokf = true; end;
    end;
  end;
  if (unokf) then begin
    error = IsUnOKAllowed_CostUserVc(CostUserr);
    if (error!=0) then begin
      RecordCheckError(error,"",-1,"TransDate");      
      res = -1; 
    end;    
    goto LCostUserVcRecordCheck;
  end;
  if (stat==updatemode) then begin
    if (CostUserr.SerNr<=0) and (CostUser2r.OKFlag==0) then begin
      CostUserr.SerNr = CostUser2r.SerNr;
    end;
  end;    
  if (CostUserr.SerNr<=0) then begin
    CostUserr.SerNr = NextSerNr("CostUserVc",CostUserr.TransDate,-1,true,"");
  end;
  if (CostUserr.SerNr==-1) then begin
    RecordCheckError(1033,"",-1,"Person");
    res = -1;
    goto LCostUserVcRecordCheck;
  end;
  if (blankdate(CostUserr.TransDate)) then begin
    RecordCheckError(1058,"",-1,"TransDate");      
    res = -1;
    goto LCostUserVcRecordCheck;
  end;
  Userr.Code = CostUserr.Person;
  if (ReadFirstMain(Userr,1,true)==false) then begin
    RecordCheckError(1290,"",-1,"Person");      
    res = -1;
    goto LCostUserVcRecordCheck;
  end;
  lCostUserr.Person = CostUserr.Person;
  lCostUserr.TransDate = CostUserr.TransDate;
  TrHs = true;
  while (LoopBackKey("PersonDate",lCostUserr,2,TrHs)) begin
    if (CostUserr.SerNr!=lCostUserr.SerNr) then begin
      if (CostUserr.Person==lCostUserr.Person) then begin
        if (GetMonth(CostUserr.TransDate)==GetMonth(lCostUserr.TransDate)) then begin
          RecordCheckError(20010,"",-1,"TransDate");      
          res = -1;
          goto LCostUserVcRecordCheck;
        end;
      end;
    end;
    if (GetMonth(lCostUserr.TransDate)<GetMonth(CostUserr.TransDate)) then begin
     TrHs = false;
    end;
  end;
  rwcnt = MatRowCnt(CostUserr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CostUserr,i,CostUserrw);
    if (nonblank(CostUserrw.Object)) then begin
      Objr.Code = CostUserrw.Object;
      if (ReadFirstMain(Objr,1,true)==false) then begin
        RecordCheckError(1290,"",i,"Object");      
        res = -1;
        goto LCostUserVcRecordCheck;
      end;
    end;
  end;
LCostUserVcRecordCheck:;  
  CostUserVcRecordCheck = res;
  return;
end;

procedure CostUserVcConvertB1ToB2(var val to1p,var val to2p,var val br1p,var val br2p)
BEGIN    
  SwapM4Val(br1p,br2p);
  SwapM4Val(to1p,to2p);
  RETURN;
END;

global
function LongInt CostUserVcRecordImport(var record CostUserVc CostUserr,record CostUserVc CostUser2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  val t,fr,to1,to2,br1,br2;
  string 5 curncy;
  Boolean gToDualBase,gBase1ToBase2;
  record ConvMasterBlock cvm;
      
  BlockLoad(cvm);
  if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
  if (gToDualBase) then begin
    curncy = CostUserr.CurncyCode;
    fr = CostUserr.FrRate;
    to1 = CostUserr.ToRateB1;
    to2 = CostUserr.ToRateB2;
    br1 = CostUserr.BaseRate1;
    br2 = CostUserr.BaseRate2;
    ConvertToDualBase(curncy,CostUserr.TransDate,fr,to1,to2,br1,br2,t,true);
    CostUserr.CurncyCode = curncy;
    CostUserr.FrRate = fr;
    CostUserr.ToRateB1 = to1;
    CostUserr.ToRateB2 = to2;
    CostUserr.BaseRate1 = br1;
    CostUserr.BaseRate2 = br2;
  end;
  if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
  if (gBase1ToBase2) then begin
    curncy = CostUserr.CurncyCode;
    to1 = CostUserr.ToRateB1;
    to2 = CostUserr.ToRateB2;
    br1 = CostUserr.BaseRate1;
    br2 = CostUserr.BaseRate2;
    CostUserVcConvertB1ToB2(to1,to2,br1,br2);
    CostUserr.ToRateB1 = to1;
    CostUserr.ToRateB2 = to2;
    CostUserr.BaseRate1 = br1;
    CostUserr.BaseRate2 = br2;
  end;
  CostUserVcRecordImport = res;
  return;
end;
