external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external function Boolean TransInFiscal(Date);
external function Boolean GetAccName(string,var string,Integer);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure AddEuroTrRow(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string);
external function Boolean CheckTTRPerRow(string,string,string,Boolean,var string,Integer);
external function string 255 FindPurchaseInvoiceNrForSerialNr(string,string,var LongInt,var LongInt);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val GetINCostPrice(string,string,Boolean);

global
updating procedure CreateBuyBack(string vecode,string custcode,string custname,string pricelist,string artcode,string artname,val qty,string serialnr,
                                 string pbbvaracc,string vatcode,val bbprice,val orgprice,
                                 LongInt ornr,LongInt shnr,LongInt ivnr,LongInt shrownr,LongInt ivrownr,
                                 record AccBlock ARAccb)
begin
  record BuyBackVc BBr;
  string 255 bbvaracc;
  LongInt orgvir,orgvirow;
  
  BBr.TransDate = CurrentDate;
  BBr.SerNr = NextSerNr("BuyBackVc",BBr.TransDate,-1,false,"");
  if (BBr.SerNr>0) then begin
    bbvaracc = pbbvaracc;
    if (blank(bbvaracc)) then begin
      bbvaracc = ARAccb.BBVarAcc;
    end;

    BBr.VECode = vecode;
    BBr.CustCode = custcode;
    BBr.CustName = custname;
    BBr.ArtCode = artcode;
    BBr.ArtName = artname;
    BBr.VATCode = vatcode;
    BBr.Quant = qty;
    BBr.SerialNr = serialnr;
    BBr.IVNr = ivnr;
    BBr.IVRow = ivrownr;
    BBr.ORNr = ornr;
    BBr.SHNr = shnr;
    BBr.SHRow = shrownr;
    BBr.BuyBackPrice = bbprice;
    BBr.OrgPrice = orgprice;
    BBr.BBVarAcc = bbvaracc;
    BBr.OrgInvoiceNr = FindPurchaseInvoiceNrForSerialNr(artcode,serialnr,orgvir,orgvirow);
    BBr.OrgVINr = orgvir;
    BBr.OrgVIRow = orgvirow;
    BBr.PriceList = pricelist;
    if ((BBr.OrgPrice-BBr.BuyBackPrice-BBr.Commision)==0) then begin
      BBr.Reconciled = 1;
    end;
    RecordStore(BBr,false);
  end;
  return;
end;

global
updating procedure SHRowCreateBuyBack(record SHVc SHp,Integer rownr,record PLDefVc PLDefr,record ORVc ORr,record AccBlock ARAccb)
begin
  record PLVc PLr;
  row SHVc SHrw;
  row ORVc ORrw;
  Boolean bbtrf,plf;
  string 255 bbvaracc;

  MatRowGet(SHp,rownr,SHrw);

  if (SHrw.Ship!=0) then begin
    switch (PLDefr.DepPrice) begin
      case 2: 
        PLr.PLCode = PLDefr.Code;
        PLr.ArtCode = SHrw.ArtCode;
        PLr.CustCode = SHp.CustCode;
        plf = ReadFirstMain(PLr,3,true);
        if (!plf) then begin
          PLr.PLCode = PLDefr.Code;
          PLr.ArtCode = SHrw.ArtCode;
          plf = ReadFirstMain(PLr,2,true);
        end;
        if (plf) then begin
          bbvaracc = PLr.BBVarAcc;
          if (PLr.BBGenTrans!=0) then begin
            if (SHrw.BBCostPrice!=0) then begin
              bbtrf = true;
            end;
          end;
        end;
        if (blank(bbvaracc)) then begin
          bbvaracc = PLDefr.BBVarAcc;
        end;
    end;
    if (bbtrf) then begin
      if (SHrw.OrdRow<MatRowCnt(ORr)) then begin
        MatRowGet(ORr,SHrw.OrdRow,ORrw);
      end;
      CreateBuyBack(PLDefr.BBVECode,SHp.CustCode,SHp.Addr0,ORr.PriceList,SHrw.ArtCode,SHrw.Spec,SHrw.Ship,SHrw.SerialNr,bbvaracc,ORrw.VATCode,SHrw.BBCostPrice,SHrw.FIFO,SHp.OrderNr,SHp.SerNr,-1,rownr,-1,ARAccb);
    end;
  end;
  return;
end;

updating procedure SHRowUpdateBuyBack(LongInt shnr,LongInt shrownr,LongInt ivnr)
begin
  record BuyBackVc oBBr;
  record BuyBackVc BBr;
  Boolean found;
  
  found = true;
  BBr.SHNr = shnr;
  BBr.SHRow = shrownr;
  while (LoopKey("SHNr",BBr,2,found)) begin
    if (BBr.SHNr!=shnr) then begin found = false; end;
    if (BBr.SHRow!=shrownr) then begin found = false; end;
    if (found) then begin
      if (BBr.IVNr!=ivnr) then begin
        RecordCopy(oBBr,BBr);
        BBr.IVNr = ivnr;
        RecordUpdate(oBBr,BBr,false);
      end;
    end;
  end;
  return;
end;

global
updating procedure UpdateBuyBackFromSH(record SHVc SHp)
begin
  Integer i,rwcnt;
  row SHVc SHrw;

  if (SHp.OKFlag!=0) then begin
    rwcnt = MatRowCnt(SHp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(SHp,i,SHrw);
      SHRowUpdateBuyBack(SHp.SerNr,i,SHp.InvoiceNr);
    end;
  end;
  return;
end;

global
updating procedure RetRowInvalidateBuyBack(record RetVc Retp,row RetVc Retrw)
begin
  record BuyBackVc BBr;
  record BuyBackVc oBBr;
  record BuyBackVc nBBr;
  Array record BuyBackVc aBBr;
  Integer i,acnt;
  Boolean found;
  
  found = true;
  if (Retp.SHNr>0) then begin
    BBr.SHNr = Retp.SHNr;
    BBr.SHRow = Retrw.SHRow;
    while (LoopKey("SHNr",BBr,2,found)) begin
      if (BBr.SHNr!=Retp.SHNr) then begin found = false; end;
      if (BBr.SHRow!=Retrw.SHRow) then begin found = false; end;
      if (found) then begin
        if (BBr.Invalid==0) and (blank(BBr.BuyBackNr)) then begin
          RecordCopy(nBBr,BBr);
          nBBr.Quant = nBBr.Quant - Retrw.Quant;
          if (nBBr.Quant>0) then begin
            aBBr[acnt] = nBBr;
            acnt = acnt + 1;
          end;          
          RecordCopy(oBBr,BBr);
          BBr.Invalid = 1;
          RecordUpdate(oBBr,BBr,false);
        end;
      end;
    end;
    for (i=0;i<acnt;i=i+1) begin
      nBBr = aBBr[i];
      nBBr.SerNr = NextSerNr("BuyBackVc",nBBr.TransDate,-1,false,"");
      RecordStore(nBBr,false);
    end;
    
  end else begin
/*
which ones returned ?   
    foundsh = true;
    SHr.OrderNr = 1;
    while (LoopKey("OrderKey",SHr,1,foundsh)) begin
    end;
*/    
  end;
  return;
end;

updating procedure IVRowCreateBuyBack(record IVVc IVp,Integer rownr,record PLDefVc PLDefr,record TRGenBlock TRGb,record AccBlock ARAccb)
begin
  record PLVc PLr;
  row IVVc IVrw;
  Boolean bbtrf,plf,testf;
  record INVc INr;
  string 255 bbvaracc;

  MatRowGet(IVp,rownr,IVrw);

  if (IVrw.Quant!=0) then begin
    switch (PLDefr.DepPrice) begin
      case 2:
        testf = true;
        ReadFirstItem(IVrw.ArtCode,INr,true,false);
        if (INr.ItemType!=1) then begin
          testf = false;
        end;
        if (TRGb.SHGenTrans!=0) then begin
          if ((IVrw.OrdRow!=-1) and (IVp.OrderNr!=-1)) then begin
            testf = false;//this or check if Transactions already from Deliery exist?
          end;  
        end;
        if (testf) then begin
          PLr.PLCode = PLDefr.Code;
          PLr.ArtCode = IVrw.ArtCode;
          PLr.CustCode = IVp.CustCode;
          plf = ReadFirstMain(PLr,3,true);
          if (!plf) then begin
            PLr.PLCode = PLDefr.Code;
            PLr.ArtCode = IVrw.ArtCode;
            plf = ReadFirstMain(PLr,2,true);
          end;
          if (plf) then begin
            bbvaracc = PLr.BBVarAcc;
            if (PLr.BBGenTrans!=0) then begin
              if (IVrw.BasePrice!=GetINCostPrice(IVp.PriceList,IVrw.ArtCode,false)) then begin
                bbtrf = true;
              end;
            end;
          end;
          if (blank(bbvaracc)) then begin
            bbvaracc = PLDefr.BBVarAcc;
          end;
        end;
    end;
    if (bbtrf) then begin
      CreateBuyBack(PLDefr.BBVECode,IVp.CustCode,IVp.Addr0,IVp.PriceList,IVrw.ArtCode,IVrw.Spec,IVrw.Quant,IVrw.SerialNr,bbvaracc,IVrw.VATCode,IVrw.BasePrice,IVrw.FIFO,IVp.OrderNr,-1,IVp.SerNr,-1,rownr,ARAccb);
    end;
  end;
  return;
end;

updating procedure CredIVRowInvalidateBuyBack(record IVVc IVp,Integer rownr)
begin
  record BuyBackVc BBr;
  record BuyBackVc oBBr;
  record BuyBackVc nBBr;
  Array record BuyBackVc aBBr;
  Integer i,acnt;
  Boolean found;
  row IVVc IVrw;
  
  MatRowGet(IVp,rownr,IVrw);
  found = true;
  if (IVp.CredInv>0) then begin
    BBr.IVNr = IVp.CredInv;
    BBr.IVRow = IVrw.CreditedRow;
    while (LoopKey("IVNr",BBr,2,found)) begin
      if (BBr.IVNr!=IVp.CredInv) then begin found = false; end;
      if (BBr.IVRow!=IVrw.CreditedRow) then begin found = false; end;
      if (found) then begin
        if (BBr.Invalid==0) and (blank(BBr.BuyBackNr)) then begin
          RecordCopy(nBBr,BBr);
          nBBr.Quant = nBBr.Quant - IVrw.Quant;
          if (nBBr.Quant>0) then begin
            aBBr[acnt] = nBBr;
            acnt = acnt + 1;
          end;

          RecordCopy(oBBr,BBr);
          BBr.Invalid = 1;
          RecordUpdate(oBBr,BBr,false);
        end;
      end;
    end;
    for (i=0;i<acnt;i=i+1) begin
      nBBr = aBBr[i];
      nBBr.SerNr = NextSerNr("BuyBackVc",nBBr.TransDate,-1,false,"");
      RecordStore(nBBr,false);
    end;
  end;
  return;
end;

global
updating procedure IVCreateBuyBack(record IVVc IVp)
begin
  record PLDefVc PLDefr;
  Integer i,rwcnt;
  record TRGenBlock TRGb;
  record AccBlock ARAccb;

  if (nonblank(IVp.PriceList)) then begin
    PLDefr.Code = IVp.PriceList;
    if (ReadFirstMain(PLDefr,1,true)) then begin
    end;
  end;
  if (PLDefr.DepPrice==2) then begin
    BlockLoad(TRGb);
    BlockLoad(ARAccb);
    rwcnt = MatRowCnt(IVp);
    for (i=0;i<rwcnt;i=i+1) begin
      if (IVp.InvType==kInvoiceTypeCredit or IVp.InvType==kInvoiceTypeCreditSpecialSales) then begin
        CredIVRowInvalidateBuyBack(IVp,i);
      end else begin
        IVRowCreateBuyBack(IVp,i,PLDefr,TRGb,ARAccb);
      end;
    end;
  end;
  return;
end;

global
function Integer MakeReconTransFromBuyBack(var record TRVc gTRp,var record BuyBackVc BBr,Boolean rpt)
begin
  Integer res;  
  Boolean dc1,dc2;
  val frrate,torate1,torate2,baserate1,baserate2;
  string 255 taccnumber,tstr;
  val TotSum;
  record AccBlock ARb;
  record TRVc lTRr;
  val t;
  
  t = BBr.OrgPrice-BBr.BuyBackPrice-BBr.Commision;
  
  if (t!=0) then begin
    BlockLoad(ARb);
/*
    if (rpt==false) then begin
      if (TRGenRec.IPGenTrans==0) then begin
        res = 0;
        goto LMakeTransFromIP2;
      end;
    end;      
    if (rpt==false) then begin
      if (nonblankdate(TRGenRec.IPStartDate) and
          (IPp.TransDate<TRGenRec.IPStartDate)) then begin
        res = 0;
        goto LMakeTransFromIP2;
      end;
    end;  
*/      
    
    RecordNew(gTRp);
    gTRp.IntYc = BuyBackReconYc;
    gTRp.Number = BBr.SerNr;
    gTRp.RefStr = BBr.BuyBackNr;
    if (rpt==false) then begin
      lTRr.IntYc = gTRp.IntYc;
      lTRr.Number = gTRp.Number;
      if (ReadFirstMain(lTRr,2,true)) then begin
        res = 1032;
        goto LMakeReconTransFromBuyBack;
      end;
    end;    
    gTRp.RegDate = CurrentDate;
    gTRp.RegTime = CurrentTime;
    gTRp.TransDate = BBr.TransDate;  
    if (rpt==false) then begin
      if (TransInFiscal(gTRp.TransDate)==false) then begin
        res = 1075;
        goto LMakeReconTransFromBuyBack;
      end;
    end;

//    gTRp.Comment = BBr.Comment;


    GetFullCurncyRate(tstr,BBr.TransDate,frrate,torate1,torate2,baserate1,baserate2);

    dc1 = false;
    dc2 = true;
    if (GetAccName(BBr.BBVarAcc,tstr,60)==false) then begin
      res = 20104;
      goto LMakeReconTransFromBuyBack;
    end;    
    if (CheckTTRPerRow("BuyBackVc",BBr.BBVarAcc,"",dc2,taccnumber,0)) then begin end;      
    AddEuroTrRow(gTRp,BBr.BBVarAcc,"","",tstr,t*BBr.Quant,baserate1,baserate2,true,dc1,TotSum,false,taccnumber,"","");

    if (GetAccName(ARb.SRVarAcc,tstr,60)==false) then begin
      res = 20086;
      goto LMakeReconTransFromBuyBack;
    end;
    if (CheckTTRPerRow("BuyBackVc",ARb.SRVarAcc,"",dc2,taccnumber,0)) then begin end;      
    AddEuroTrRow(gTRp,ARb.SRVarAcc,"","",tstr,t*BBr.Quant,baserate1,baserate2,true,dc2,TotSum,false,taccnumber,"","");

    if (TotSum!=0) then begin
      if (GetAccName(ARb.RateRndOffAcc,tstr,60)==false) then begin
        res = 1904;
        goto LMakeReconTransFromBuyBack;
      end;
      AddEuroTrRow(gTRp,ARb.RateRndOffAcc,"","",tstr,TotSum,baserate1,baserate2,true,dc1,TotSum,false,"","","");
    end;  

  end;
LMakeReconTransFromBuyBack:;  
  MakeReconTransFromBuyBack = res;
  return;
end;


global
updating function LongInt BuyBackVcRecordCheck(var record BuyBackVc BuyBackp,record BuyBackVc BuyBack2p,LongInt stat,LongInt long4)
begin
  LongInt res;  
  record TRVc gTRp;
  Integer errcode;
  string 255 tstr;
  Boolean gentrans,recontransf,check;
  
  res = 0;
  if (long4>0) then begin
    check = true;
  end else begin
    check = false;
  end;
  gentrans = true;
  recontransf = false;
  if (BuyBackp.Reconciled!=0) then begin
    if (stat==Rs_insert) then begin recontransf = true; end;
    if (stat==Rs_update) then begin
      if (BuyBack2p.Reconciled==0) then begin recontransf = true; end;
    end;
  end;
  if (gentrans==false) then begin recontransf = false; end;
  if (recontransf) then begin  
    errcode = MakeReconTransFromBuyBack(gTRp,BuyBackp,false);
    if (errcode!=0) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1; 
      goto LBuyBackVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (gTRp.IntYc==BuyBackReconYc)) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        RecordCheckError(1085,tstr,-1,"SerNr");      
        res = -1;
        goto LBuyBackVcRecordCheck;
      end;
      SaveTrans(gTRp);
//      AddTTrans_BuyBackVc(gTRp,BuyBackp);
    end;
  end;
LBuyBackVcRecordCheck:;  
  BuyBackVcRecordCheck = res;
  return;
end;
