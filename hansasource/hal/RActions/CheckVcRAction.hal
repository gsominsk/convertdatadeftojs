external updating procedure UpdateChequeStatusHistory(record CheckVc,string,LongInt,Boolean);
external function Boolean DisallowFutureDateCheck(Boolean,Date,string,Integer);
external function Integer CheckVATNrMask(string,string,Integer,var string);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external function Boolean AccInRange(string,string);
external function Boolean Date2Test(string,Date,string,Integer);
external function Boolean GetFullCurncyRateDate(var string,Date,var val,var val,var val,var val,var val,var Date);
external function Integer MakeTransFromCheck(record TRVc,var record CheckVc,Boolean);
external function Boolean SerNrTestCheckVc(LongInt,Date,var Boolean);

global
procedure ReconcileTRRow(record TRVc TRp,Integer rownr)
begin
  Row TRVc TRrw;
  Integer rwcnt;

  rwcnt = MatRowCnt(TRp);
  if (rwcnt>rownr) then begin
    MatRowGet(TRp,rownr,TRrw);
    if (TRrw.stp==1) then begin
      TRrw.Reconsf = 1;
      MatRowPut(TRp,rownr,TRrw);
    end;
  end;
  return;
end;

global
updating procedure ReconcileCheck(record CheckVc Checkp)
BEGIN
  record TRVc TRr;
  record TRVc oldTRr;

  TRr.IntYc = CheckYc;
  TRr.Number = Checkp.SerNr;
  if (ReadFirstMain(TRr,2,true)) then begin
    RecordCopy(oldTRr,TRr);
    ReconcileTRRow(TRr,0);
    if (RecordUpdate(oldTRr,TRr,true)==0) then begin
    end;
  end;
  RETURN;
END;

global
function Integer CheckIntYc(record CheckVc Checkp)
begin
  Integer intyc;
 
  intyc = 0;  
  switch (Checkp.Openf) begin
    case kCheckTypeAccepted : intyc  = Check0Yc; 
    case kCheckTypeDeposited : intyc  = CheckYc;  
  //LO  case 4: intyc  = CheckYc;     
    case kCheckTypeCancelled: intyc  = CheckYc;  
    case kCheckTypeBounced: intyc  = Check2Yc; 
    case kCheckTypeBouncedfromEndorsed: intyc  = Check2Yc;
  end;
  CheckIntYc = intyc;
  return;
end;

global
procedure AddCheckAccount(var string AcNr,Integer type)
begin
  Record CheckTargetAccBlock chqacnts;
  Row CheckTargetAccBlock chqacntsrw;
  Integer rows,j;
   
  AcNr = ""; 
  Blockload(chqacnts);
  rows = MatRowCnt(chqacnts);
  for (j=0;j<rows;j=j+1) begin
    MatRowGet(chqacnts,j,chqacntsrw);
    if (chqacntsrw.TargetTyp==type) then begin
      AcNr = chqacntsrw.AccNr;
    end;
  end;
  return;
end;

global
Function Boolean CheckAccount(String AcNr,Integer type)
begin
  Record CheckTargetAccBlock chqacnts;
  Row CheckTargetAccBlock chqacntsrw;
  Integer rows,j;
  Boolean res;
  
  res = true;
  if (blank(AcNr)) then begin
    goto LCheckAccount;
  end;
  res = false; 
  Blockload(chqacnts);
  rows = MatRowCnt(chqacnts);
  for (j=0;j<rows;j=j+1) begin
    MatRowGet(chqacnts,j,chqacntsrw);
    if (AccInRange(AcNr,chqacntsrw.AccNr)) then begin
      if (chqacntsrw.TargetTyp==type) then begin
        res = true;
        goto LCheckAccount;
      end;
    end;
  end;
LCheckAccount:;  
  CheckAccount = res;
  return;
end;


global
function LongInt CheckVcRecordDefaults(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  Record BaseCurBlock BaseCurRec;
  Val to1,to2,fr,br1,br2;
  Date ed;
  Boolean testf;
  string 50 crncycode,tstr;
      
  crncycode = Checkr.CurncyCode;
  testf = GetFullCurncyRateDate(crncycode,Checkr.TransDate,fr,to1,to2,br1,br2,ed);
  Checkr.CurncyCode = crncycode;  
  Checkr.SerNr         = -1;
  Checkr.TransDate     = CurrentDate;
  Checkr.Openf         = kCheckTypeRegistered;
  Checkr.Amount        = BlankVal;
  Checkr.BankFee       = BlankVal;
  Checkr.ClearedAmount = BlankVal;
  AddCheckAccount(tstr,4);
  Checkr.TargetAccNr = tstr;
  AddCheckAccount(tstr,6);
  Checkr.TempAccNr = tstr;
  return;
end;


global
function LongInt CheckVcRecordDuplicate(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  Date ed;
  Boolean testf;
  string 5 crncycode;
  val to1,to2,fr,br1,br2;
      
  crncycode = Checkr.CurncyCode;
  testf = GetFullCurncyRateDate(crncycode,Checkr.TransDate,fr,to1,to2,br1,br2,ed);
  Checkr.CurncyCode = crncycode;  
  Checkr.SerNr = -1;
  Checkr.Openf = kCheckTypeRegistered;
  Checkr.TransDate = CurrentDate;
  Checkr.AcceptedDate = "";
  Checkr.BouncedDate = "";
  Checkr.CancelledDate = "";
  Checkr.EndorsedDate = "";
  Checkr.BankFee = BlankVal;
  Checkr.ClearedAmount = BlankVal;
  return;
end;

global
function LongInt CheckVcRecordSave(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  
  if (Checkr.SerNr==-1) then begin       
    Checkr.SerNr = NextSerNr("CheckVc",Checkr.TransDate,-1,false,"");
  end;
  CheckVcRecordSave = res;
  return;
end;

global
updating function LongInt CheckVcRecordUpdate(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  LongInt res;
   
  if (Checkr.SerNr==-1) then begin       
    Checkr.SerNr = NextSerNr("CheckVc",Checkr.TransDate,-1,false,"");
  end;
  if blankdate(Checkr.TransDate) then begin
    Checkr.TransDate = CurrentDate;
  end;
  if ((Checkr.Openf==kCheckTypeDeposited) and (Check2r.Openf==kCheckTypeAccepted)) then begin
    if blankdate(Checkr.ClearingDate) then begin
      Checkr.ClearingDate = CurrentDate;
    end;      
  end;        
  if ((Check2r.Openf==kCheckTypeDeposited) and (Checkr.Openf==kCheckTypeReconciled)) then begin 
    ReconcileCheck(Checkr);
  end;

  if ((Checkr.Openf==kCheckTypeCancelled) and (Check2r.Openf!=kCheckTypeCancelled)) then begin
    if (blankdate(Checkr.CancelledDate)) then begin
      Checkr.CancelledDate = CurrentDate;
    end;    
  end;
  if ((Checkr.Openf==kCheckTypeBounced) and (Check2r.Openf!=kCheckTypeBounced)) then begin
    if (blankdate(Checkr.BouncedDate)) then begin
      Checkr.BouncedDate = CurrentDate;
    end;    
  end;
  CheckVcRecordUpdate = res;
  return;
end;

global
updating function LongInt CheckVcRecordUpdateAfter(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  
  if (Checkr.Openf==kCheckTypeCancelled) and (Check2r.Openf!=kCheckTypeCancelled) then begin
    UpdateChequeStatusHistory(Checkr,"CheckVc",Checkr.SerNr,false);
  end;
  if (Checkr.Openf==kCheckTypeReconciled) and (Check2r.Openf!=kCheckTypeReconciled) then begin
    UpdateChequeStatusHistory(Checkr,"CheckVc",Checkr.SerNr,false);
  end;
  if (Checkr.Openf==kCheckTypeBounced) and (Check2r.Openf!=kCheckTypeBounced) then begin
    UpdateChequeStatusHistory(Checkr,"CheckVc",Checkr.SerNr,false);
  end;
  if (Checkr.Openf==kCheckTypeBouncedfromEndorsed) and (Check2r.Openf!=kCheckTypeBouncedfromEndorsed) then begin
    UpdateChequeStatusHistory(Checkr,"CheckVc",Checkr.SerNr,false);
  end;
  if (Checkr.Openf==kCheckTypeEndorsedfromReconciled) and (Check2r.Openf!=kCheckTypeEndorsedfromReconciled) then begin
    UpdateChequeStatusHistory(Checkr,"CheckVc",Checkr.SerNr,false);
  end;
  CheckVcRecordUpdateAfter = res;
  return;
end;

global
updating function LongInt CheckVcRecordCheck(var record CheckVc Checkr,record CheckVc Check2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  Integer i,rows,s;
  Boolean Cond,gentrans;
  LongInt oldnr;  
  Integer insertmode,updatemode,intyc;
  Integer errcode;
  record CheckVc locCheckr;
  Boolean transf;
  record TRVc gTRp;
  string 255 tstr;
  record CUVc CUr;
  Date td;
    
  res = 0;
  insertmode = 1;
  updatemode = 2;
  oldnr = Checkr.SerNr;
  if (Checkr.SerNr<=0) then begin
    Checkr.SerNr = NextSerNr("CheckVc",Checkr.TransDate,-1,false,"");
  end;
  if (stat==updatemode) then begin
    if (Checkr.SerNr<=0) and (Check2r.Openf==kCheckTypeRegistered) then begin
      Checkr.SerNr = Check2r.SerNr;
    end;
  end;  
  if ((stat==insertmode) and (Checkr.Openf==kCheckTypeDeposited)) then begin
    locCheckr.SerNr = Checkr.SerNr;
    if (ReadFirstMain(locCheckr,1,true)) then begin
      RecordCheckError(1115,"",-1,"SerNr");
      res = -1;
      goto LCheckVcRecordCheck;
    end;
  end;  
  if (SerNrTestCheckVc(Checkr.SerNr,Checkr.TransDate,gentrans)==false) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  switch(Checkr.Openf) begin
    case kCheckTypeDeposited:
      td = Checkr.ClearingDate;
      if (blank(td)) then begin
        td = CurrentDate;
      end;
      if (Date2Test("CheckVc",td,"TransDate",-1)==false) then begin
        res = -1;
        goto LCheckVcRecordCheck;
      end;  
    otherwise
      if (Date2Test("CheckVc",Checkr.TransDate,"TransDate",-1)==false) then begin
        res = -1;
        goto LCheckVcRecordCheck;
      end;  
  end;
  if (DisallowFutureDateCheck(true,Checkr.TransDate,"TransDate",-1)) then begin
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (blank(Checkr.CheckNr)) then begin
    RecordCheckError(1058,Checkr.CheckNr,-1,"CheckNr");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (Checkr.Amount==BlankVal) then begin
    RecordCheckError(1058,Checkr.Amount,-1,"Amount");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (blankdate(Checkr.EffectDate)) then begin
    RecordCheckError(1058,Checkr.EffectDate,-1,"EffectDate");
    res = -1;
    goto LCheckVcRecordCheck;
  end; 
  if (Checkr.Openf==kCheckTypeDeposited) then begin
    if (CurrentDate<Checkr.EffectDate) then begin
      RecordCheckError(1940," " & Checkr.EffectDate,-1,"EffectDate");
      res = -1;
      goto LCheckVcRecordCheck;
    end;
  end;

  if (Checkr.EffectDate<Checkr.EmissionDate) then begin
    RecordCheckError(20870," " & Checkr.EffectDate,-1,"EffectDate");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (CheckAccount(Checkr.TargetAccNr,0)==false) then begin
    RecordCheckError(1276," " & Checkr.TargetAccNr,-1,"TargetAccNr");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (CheckAccount(Checkr.OrigAccNr,1)==false) then begin
    RecordCheckError(1276," " & Checkr.OrigAccNr,-1,"OrigAccNr");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  if (CheckAccount(Checkr.TempAccNr,2)==false) then begin
    RecordCheckError(1276," " & Checkr.TempAccNr,-1,"TempAccNr");
    res = -1;
    goto LCheckVcRecordCheck;
  end;
  CUr.Code = Checkr.CUCode;
  if (ReadFirstMain(CUr,1,true)==false) then begin
    RecordCheckError(1120,Checkr.CUCode,-1,"CUCode");      
    res = -1; 
    goto LCheckVcRecordCheck;
  end;
  res = CheckVATNrMask(Checkr.VATNr,CUr.CountryCode,CUr.CustType,tstr);
  if (res!=0) then begin
    RecordCheckError(res,tstr,-1,"VATNr");      
    res = -1; 
    goto LCheckVcRecordCheck;
  end;

  if (Checkr.Openf<>Check2r.Openf) then begin
    if (UserCanAction("IssueChk",true)==false) then begin
      RecordCheckError(1878,Checkr.CheckNr,-1,"CheckNr");
      res = -1;
      goto LCheckVcRecordCheck;
    end;
  end;
  intyc = CheckIntYc(Checkr);
  
  if (intyc==CheckYc) then begin
    if (blankdate(Checkr.TransDate)) then begin
      Checkr.TransDate = CurrentDate;
    end;
    if (Checkr.ClearedAmount==blankval) then begin
      Checkr.ClearedAmount = Checkr.Amount - Checkr.BankFee;
    end;
  end;
  transf = false;
  if (Checkr.Openf!=kCheckTypeRegistered) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if (Check2r.Openf!=Checkr.Openf) then begin transf = true; end;
    end;
  end;  
  if (gentrans==false) then begin transf = false; end;
  if (transf) then begin 
    errcode = MakeTransFromCheck(gTRp,Checkr,false);
    if (errcode>0) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1;
      goto LCheckVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (Checkr.Openf>kCheckTypeRegistered) and ((gTRp.IntYc==CheckYc) or (gTRp.IntYc==Check2Yc))) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        RecordCheckError(1085,tstr,-1,"SerNr");      
        res = -1;
        goto LCheckVcRecordCheck;
      end;
      SaveTrans(gTRp);
      if (gTRp.IntYc==Check2Yc) then begin
        CreateRecordLink(Checkr,CurrentCompany,gTRp,CurrentCompany);  
      end;
    end;        
  end;
LCheckVcRecordCheck:;  
  if (res!=0) then begin
    Checkr.SerNr = oldnr;
  end;
  CheckVcRecordCheck = res;
  RETURN;
END;

global
function LongInt CheckVcRecordRemoveTest(var record CheckVc Checkr,record CheckVc Check2r,LongInt long3,LongInt long4)
begin
  LongInt res;

  res = 1;
  if (Checkr.Openf>kCheckTypeAccepted) then begin
    res = 0;
  end;
  CheckVcRecordRemoveTest = res;  
  return;
end;

global
function LongInt CheckVcRecordInIndex(record CheckVc Checkr,string indexname)
BEGIN
  LongInt res;
  
  res = 1;
  switch (indexname) begin
    case "RegSerNr": if (Checkr.Openf!=kCheckTypeRegistered) then begin res = 0; end;
    case "RegCheckNr": if (Checkr.Openf!=kCheckTypeRegistered) then begin res = 0; end;
    case "RegCUCode": if (Checkr.Openf!=kCheckTypeRegistered) then begin res = 0; end;
    case "RegAmount": if (Checkr.Openf!=kCheckTypeRegistered) then begin res = 0; end;
    
    case "OpenSerNr": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenEffectDate": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenECDate": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenfCUName": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenfCUCode": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenfCheckNr": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;
    case "OpenfAmount": if (Checkr.Openf!=kCheckTypeAccepted) then begin res = 0; end;

    case "OpenDepECDate": if ((Checkr.Openf!=kCheckTypeAccepted) and (Checkr.Openf!=kCheckTypeDeposited)) then begin res = 0; end;

    case "DepECDate": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepEffectDate": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepSerNr": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepositedDate": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepCUName": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepAmount": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
    case "DepCheckNr": if (Checkr.Openf!=kCheckTypeDeposited) then begin res = 0; end;
  end;
  CheckVcRecordInIndex = res;
  RETURN;
END;

global
function Integer CheckVcDoSearch(var record CheckVc Checkr,string indexname,string searchstr)
begin
  Integer keys;
  
  keys = -1;
  switch (indexname) begin
    case "OpenfCheckNr": 
      Checkr.Openf = kCheckTypeAccepted;
      Checkr.CheckNr = searchstr;
      keys = 2;
    case "OpenfCUName": 
      Checkr.Openf = kCheckTypeAccepted;
      Checkr.CUName = searchstr;
      keys = 2;
    case "OpenfAmount": 
      Checkr.Openf = kCheckTypeAccepted;
      Checkr.Amount = StringToVal(searchstr,M4Val);
      keys = 2;
    case "OpenEffectDate": 
      Checkr.Openf = kCheckTypeAccepted;
      Checkr.EffectDate = StringToDate(searchstr);
      keys = 2;

    case "RegCheckNr": 
      Checkr.Openf = kCheckTypeRegistered;
      Checkr.CheckNr = searchstr;
      keys = 2;
    case "RegCUCode": 
      Checkr.Openf = kCheckTypeRegistered;
      Checkr.CUCode = searchstr;
      keys = 2;
    case "RegAmount": 
      Checkr.Openf = kCheckTypeRegistered;
      Checkr.Amount = StringToVal(searchstr,M4Val);
      keys = 2;

    case "DepSerNr": 
      Checkr.Openf = kCheckTypeDeposited;
      Checkr.SerNr = StringToLongInt(searchstr);
      keys = 2;
    case "DepEffectDate": 
      Checkr.Openf = kCheckTypeDeposited;
      Checkr.EffectDate = StringToDate(searchstr);
      keys = 2;
    case "DepCheckNr": 
      Checkr.Openf = kCheckTypeDeposited;
      Checkr.CheckNr = searchstr;
      keys = 2;
    case "DepCUName": 
      Checkr.Openf = kCheckTypeDeposited;
      Checkr.CUName = searchstr;
      keys = 2;
    case "DepAmount": 
      Checkr.Openf = kCheckTypeDeposited;
      Checkr.Amount = StringToVal(searchstr,M4Val);
      keys = 2;
      
  end;
  CheckVcDoSearch = keys;
  return;
end;
