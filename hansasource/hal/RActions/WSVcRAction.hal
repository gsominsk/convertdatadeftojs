external function Boolean AllowedToTakeFromThisLoc(record LocationVc);
external procedure FindTempStockRow(LongInt,string,Boolean,record TempStockVc,var row TempStockVc);
external function Boolean StockRecordForLocationAllowed(string,string,string,date,integer,var Integer,var string);
external procedure VerifyRowObjects(String,String,String,String,var Integer,var String,var Boolean,Array string,Array string,var Integer);
external function Boolean UseTaxTemplatesforTaxCalc();
external function Boolean UseTaxTemplatesforTaxCalc();
external function Integer VerifyTaxTemplateCode(string,var string);
external function Integer CheckObjs(string,string,var string);
external function string 60 AddObjectToObjectList(string,string);
external function Boolean DisallowFutureDateCheck(Boolean,Date,string,Integer);
external function Boolean Date2Test(string,Date,string,Integer);
external function roundmode DefaultRoundMode();
external updating procedure UpdateTrans_Stock(record TRVc);
external function Integer IsUnOKAllowed_WSVc(record WSVc);
external procedure GetConsigmentStockAcc(string,string,var string);
external procedure GetCurUser(var record UserVc);
external function Boolean GetCOSAcc(string,string,string,record AccBlock,record INVc,Integer,Boolean,Integer,var string,var string);
external function Integer TRVc_AddRoundOffRow(var record TRVc,val,val,string,Boolean,Boolean,Boolean,val,var val);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean CanOKStockRecord(var Integer);
external procedure CombineStructure(var record SHVc);
external updating procedure WSUpdateSerialNr(record WSVc,Boolean,Boolean);
external updating procedure WSUpdateItemHistory(record WSVc);
external function string 255 FindINObjects(string,string);
external function Integer CheckSerialStatus(string,string,var string);
external function Integer CheckRates(string,val,val,val,val,val,var string);
external function Boolean IsRecipeClosed(string);
external function Integer GetItemType(LongInt,LongInt,string,Integer);
external function Boolean IsSerialNrCorrect(string);
external updating procedure WSUpdatePErs(record WSVc);
external updating procedure WSUpdateSVO(record WSVc,row WSVc);
external updating procedure WSCreateWSIV(record WSVc,Integer,row WSVc);
external function Boolean ShouldItemUpdateStock(string);
external updating procedure UpdateInstock(string,string,string,string,date,val,val,val,val,val,val,val,val,val);
external updating function val NextLocOKNr(string);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external procedure GetITStockAcc(string,var string);
external procedure GetITCostAcc(string,var string);
external function val FindCostPrice(string,string,string,val,val,Boolean);
external function Boolean ExpandStructItem(string,string,val,var record SHVc);
external function Boolean GetAccName(string,var string,Integer);
external procedure AddEuroTrRowType(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string,Integer);
external procedure AddEuroTrRowTypeQty(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string,Integer,val);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function Boolean SerialNrAvail(string,string,string,val);
external procedure FindStockValue(string,string,var record ItemStatusVc);
external function Boolean CheckStructureItemsLevel(string,string,string,val);
external function Boolean ExistStockTrans(string,Date,var Integer,var string,string,LongInt,record MainStockBlock);
external procedure WSUpdateFIFO(record WSVc);
external function Boolean SerNrTestWSVc(LongInt,Date,var Boolean);
external procedure GetLocationAcc(string,var string,var string);

procedure GetWSStockAcc(Integer ItemGroupAccounts,string location,string MainStock,string itcode,string accusageacc,var string stockacc,var string locobjstr)
begin  
  string 10 loccode;
  
  stockacc = "";
  locobjstr = "";
  loccode = location;
  if (blank(loccode)) then begin
    loccode = MainStock;    
  end;
  GetLocationAcc(location,stockacc,locobjstr);
  if (nonblank(stockacc)) then begin
    goto LGetWSStockAcc;
  end;
  if (ItemGroupAccounts!=0) then begin
    GetITStockAcc(itcode,stockacc);
    if (nonblank(stockacc)) then begin
      goto LGetWSStockAcc;
    end;
  end;
  stockacc = accusageacc;
  if (nonblank(stockacc)) then begin
    goto LGetWSStockAcc;
  end;
LGetWSStockAcc:;  
  return;
end;

procedure GetWSCostAcc(Integer ItemGroupAccounts,string headercostacc,string rowcostacc,string inacc,string itcode,string accusageacc,var string costacc)
begin
  costacc = "";
  costacc = rowcostacc;
  if (nonblank(costacc)) then begin
    goto LGetWSCostAcc;
  end;
  costacc = headercostacc;
  if (nonblank(costacc)) then begin
    goto LGetWSCostAcc;
  end;
  costacc = inacc;
  if (nonblank(costacc)) then begin
    goto LGetWSCostAcc;
  end;
  if (ItemGroupAccounts!=0) then begin
    GetITCostAcc(itcode,costacc);
    if (nonblank(costacc)) then begin
      goto LGetWSCostAcc;
    end;
  end;
  costacc = accusageacc;
  if (nonblank(costacc)) then begin
    goto LGetWSCostAcc;
  end;
LGetWSCostAcc:;  
  return;
end;

function
Integer AddWSTransRow(record TRVc gTRp,string artcode,string serialnr,val qty,record CostAccBlock CAb,record AccBlock ARAccRecp,string MainStock,string custcode,string headercostacc,
                      string rowcostacc,
                      string location,string topobj,string rowobj,Integer ItemType,Boolean dc1,Boolean dc2,val rowcostp,val baserate1,val baserate2,var val totsump)
begin
  record INVc INr;
  string 255 objstr;
  string 255 stockobjs,locobjstr;
  string 10 costacc,stockacc;
  string 255 tstr,lrowcostacc,errstr;
  Integer errstrno;
  
  if (rowcostp==0) then begin
    goto LAddWSTransRow;
  end;  
  lrowcostacc = rowcostacc;
  INr.Code = artcode;
  if (ReadFirstMain(INr,1,true)==false) then begin
    INr.Objects = "";
  end;
  if (INr.ItemType!=1) then begin 
    if (CAb.CostAccForNonStocked==0) then begin
      goto LAddWSTransRow;
    end;
  end;
//  objstr = FindINObjects(INr.Objects,INr.Group);
  objstr = AddObjectToObjectList(objstr,rowobj);
  if (ARAccRecp.SkipObjectsOnIVFromHeader==0) then begin
    objstr = AddObjectToObjectList(objstr,topobj);
  end;
  if (CAb.ObjOnStock!=0) then begin
    stockobjs = objstr;
  end else begin
    stockobjs = "";
  end;
  costacc = "";
//  GetWSCostAcc(CAb.ItemGroupAccounts,headercostacc,rowcostacc,INr.CostAcc,INr.Group,ARAccRecp.StockCostAcc,costacc);
//to make it consistent with Delivery
  if (blank(lrowcostacc)) then begin
    lrowcostacc = headercostacc;
  end;
  if (GetCOSAcc(lrowcostacc,custcode,location,ARAccRecp,INr,CAb.ItemGroupAccounts,false,0,costacc,tstr)==false) then begin
  end;
  if (GetAccName(costacc,tstr,60)==false) then begin
    errstrno = 2138;
    goto LAddWSTransRow;
  end;
  AddEuroTrRowType(gTRp,costacc,objstr,"",tstr,rowcostp,baserate1,baserate2,false,dc1,totsump,false,"","","",kTransactionRowTypeStock);

  GetWSStockAcc(CAb.ItemGroupAccounts,location,MainStock,INr.Group,ARAccRecp.StockAcc,stockacc,locobjstr);
  stockobjs = AddObjectToObjectList(stockobjs,locobjstr);
  GetConsigmentStockAcc(artcode,serialnr,stockacc);
  if (GetAccName(stockacc,tstr,60)==false) then begin
    errstrno = 2120;
    goto LAddWSTransRow;
  end;
  errstrno = CheckObjs(stockacc,stockobjs,errstr);
  if (errstrno!=0) then begin
    goto LAddWSTransRow;
  end;

  AddEuroTrRowTypeQty(gTRp,stockacc,stockobjs,"",tstr,rowcostp,baserate1,baserate2,true,dc2,totsump,false,"","","",kTransactionRowTypeStock,qty);
  errstrno = 0;
LAddWSTransRow:;
  AddWSTransRow = errstrno;
  return;
end;

function Integer AddWSCostRow(record TRVc gTRp,record MainStockBlock MainStockRec,record CostAccBlock CAb,record AccBlock ARAccRec,
                              record WSVc WSp,row WSVc WSrw,Boolean dc1,Boolean dc2,val baserate1,val baserate2,var val TotSum)
begin
  Integer res;
  val t1;
  record INVc INr;
  
  t1 = Round(WSrw.FIFORowVal,DefaultRoundMode);
  res = AddWSTransRow(gTRp,WSrw.ArtCode,WSrw.SerialNr,WSrw.Quant,CAb,ARAccRec,MainStockRec.MainStock,WSp.CustCode,WSp.CostAcc,WSrw.CostAcc,WSp.Location,WSp.Objects,WSrw.Objects,WSrw.ItemType,
                      dc1,dc2,t1,baserate1,baserate2,TotSum);
  AddWSCostRow = res;
  return;
end;

global
function Integer MakeTransFromWS(record TRVc gTRp,record WSVc WSp,Boolean rpt)
begin
  Integer res;
  record MainStockBlock MainStockRec;
  record CostAccBlock CAb;
  record TRGenBlock TRGenRec;
  record AccBlock ARAccRec;
  record SHVc recSHr;
  record INVc INr;
  Integer rwcnt,rwcnt2;
  Integer i,j;
  string 255 ftxt;
  string 255 tstr;
  string 255 firstVAT;
  val VATSum;
  val t1;
  row WSVc WSrw;
  row SHVc SH2rw;
  Boolean dc1,dc2;
  val TotSum;
  string 255 mainstockacc;
  Boolean isstruct;
  val baserate1,baserate2,temp,t;
  string 10 location;  
  string 20 curncy;
  record TRVc lTRr;
  Integer primary,queuecostmodel;
  record ITVc ITr;
  transaction string 255 gRuniningMaint;

  res = 1085;
  BlockLoad(CAb);
  BlockLoad(ARAccRec);
  BlockLoad(TRGenRec);
  BlockLoad(MainStockRec);
  RecordNew(gTRp);
  if (rpt==false) then begin
    if (TRGenRec.WSGenTrans==0) then begin
      res = 0;
      goto LMakeTransFromWS;
    end;
  end;
  if (rpt==false) then begin
    if ((nonblankdate(TRGenRec.WSStartDate)) and
        (WSp.TransDate<TRGenRec.WSStartDate)) then begin
      res = 0;
      goto LMakeTransFromWS;
    end;
  end;
  if (true) then begin
    gTRp.IntYc = WSYc;
    gTRp.Number = WSp.SerNr;
    gTRp.RefStr = "";
  end;
  if (rpt==false) then begin
    lTRr.Number = gTRp.Number;
    lTRr.IntYc = gTRp.IntYc;
    if (ReadFirstMain(lTRr,0,true)) then begin
      switch (gRuniningMaint) begin    
        case "RecalcStockMn":  ;
        otherwise
          res = 1032;
          goto LMakeTransFromWS;
      end;
    end;
  end;  
  gTRp.RegDate = CurrentDate;
  gTRp.RegTime = CurrentTime;
  gTRp.TransDate = WSp.TransDate;
  curncy = "";
  ftxt = "";
  GetFullCurncyRate(curncy,gTRp.TransDate,temp,temp,temp,baserate1,baserate2);
  ftxt = ftxt & " ";
  ftxt = ftxt & WSp.Addr0;
  gTRp.Comment = ftxt;
  dc1 = true;
  dc2 = false;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    isstruct = false;
    if (WSrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
      isstruct = ExpandStructItem(WSrw.ArtCode,WSrw.Recepy,WSrw.Quant,recSHr);
    end;
    if (isstruct==false) then begin
      res = AddWSCostRow(gTRp,MainStockRec,CAb,ARAccRec,WSp,WSrw,dc1,dc2,baserate1,baserate2,TotSum);
      if (res!=0) then begin
        goto LMakeTransFromWS;
      end;
    end else begin
      CombineStructure(recSHr);
      recSHr.Location = location;
      rwcnt2 = MatRowCnt(recSHr);
      for (j=0;j<rwcnt2;j=j+1) begin
        MatRowGet(recSHr,j,SH2rw);
        SH2rw.Location = location;
        MatRowPut(recSHr,j,SH2rw);
      end;
      for (j=0;j<rwcnt2;j=j+1) begin
        MatRowGet(recSHr,j,SH2rw);
        t1 = FindCostPrice(SH2rw.ArtCode,location,SH2rw.SerialNr,SH2rw.Ship,0,false);
        t1 = Round(t1,DefaultRoundMode);
        res = AddWSTransRow(gTRp,SH2rw.ArtCode,SH2rw.SerialNr,SH2rw.Ship,CAb,ARAccRec,MainStockRec.MainStock,WSp.CustCode,WSp.CostAcc,WSrw.CostAcc,WSp.Location,WSp.Objects,WSrw.Objects,WSrw.ItemType,
                            dc1,dc2,t1,baserate1,baserate2,TotSum);
        if (res!=0) then begin
          goto LMakeTransFromWS;
        end;
      end;
    end;
  end;


  res = TRVc_AddRoundOffRow(gTRp,baserate1,baserate2,"",false,false,false,TotSum,TotSum);
  if (res!=0) then begin
    goto LMakeTransFromWS;
  end;
  res = 0;
LMakeTransFromWS:;
  MakeTransFromWS = res;
  return;
end;

function
Boolean CheckWOFinished(LongInt WONr)
begin
  Boolean res;
  record WOVc WOp;

  res = true;
  WOp.SerNr = WONr;
  if (ReadFirstMain(WOp,1,true)) then begin
    if (WOp.Closed!=3) then begin
      res = false;
    end;
  end;
  CheckWOFinished = res;
  return;
end;

function
Boolean CheckSerialNoMaxCost(string mothernr,val costp,record SVOVc SVOp)
begin
  row SVOVc SVOrw;
  Integer i,rwcnt,rownr;
  Boolean res;
  val t;

  rownr = -1;
  rwcnt = MatRowCnt(SVOp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SVOp,i,SVOrw);
    if (SVOrw.SerialNr==mothernr) then begin
      t = SVOrw.Cost + costp;
      rownr = i;
      goto LCheckSerialNoMaxCostBREAK;
    end;
  end;       
LCheckSerialNoMaxCostBREAK:;   
  if ((t!=0) and (rownr!=-1)) then begin
    MatRowGet(SVOp,rownr,SVOrw);
    if (SVOrw.MaxCost!=0) then begin
      if (t>SVOrw.MaxCost) then begin
        res = true;
      end;
    end;
  end;
  CheckSerialNoMaxCost = res;
  return;
end;

/*
global
function Integer PasteWOItemType(LongInt wonr,string mothernr)
begin
  record WOVc WOr;
  row WOVc WOrw;
  Integer rwcnt,i;
  Integer res;

  WOr.SerNr = wonr;
  if (ReadFirstMain(WOr,1,true)) then begin
    rwcnt = MatRowCnt(WOr);
    for (i=0;i<rwcnt;i=i+1) begin
       MatRowGet(WOr,i,WOrw);
       if (nonblank(mothernr)) then begin
         if (WOrw.SerialNr==mothernr) then begin
           res = WOrw.ItemType;
           goto LPasteWOItemType;
         end;
       end;
    end;
  end;
LPasteWOItemType:;
  PasteWOItemType = res;    
  return;
end;
*/
global
updating function LongInt WSVcRecordCheck(var record WSVc WSp,record WSVc WS2p,LongInt stat,LongInt check)
begin
  LongInt res;
  record MainStockBlock MainStockRec;
  record SVOVc SVOr;
  record INVc INr;
  record ItemStatusVc ISr;
  row WSVc WSrw,WS2rw;
  Integer rwcnt,i,errcode,j;
  Integer insertmode,updatemode;
  LongInt oldnr,sernr;
  Boolean found,gentrans,transf,testf,okf;
  string 255 location;
  string 255 tstr,objstr,accstr,errstr;
  record TRVc gTRp;
  val prev;
  Boolean unokf;
  transaction string 255 gRuniningMaint;
  Array string 255 otcheckaccs;
  Array string 255 otcheckobjtyps;
  Integer otcheckcnt;
  Boolean initotcheckf;
  record AccVc Accr;
  record LocationVc Locationr;
    
  res = 0;
  BlockLoad(MainStockRec);
  insertmode = 1;//Rs_insert
  updatemode = 2;//Rs_update
  transf = false;
  oldnr = WSp.SerNr;
  if (WSp.OKFlag==1) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if (WS2p.OKFlag==0) then begin transf = true; end;
    end;
  end;
  okf = true;
  if ((WS2p.OKFlag==0) and (WSp.OKFlag==0)) then begin okf = false; end;
  if ((WS2p.PrelOK==0) and (WSp.PrelOK==0)) then begin okf = false; end;
  if (WSp.OKFlag==0) then begin
    if (stat==updatemode) then begin
      if (WS2p.OKFlag==1) then begin unokf = true; end;
    end;
  end;
  if (unokf) then begin
    errcode = IsUnOKAllowed_WSVc(WSp);
    if (errcode!=0) then begin
      RecordCheckError(errcode,"",-1,"TransDate");      
      res = -1; 
    end;
    goto LWSVcRecordCheck;
  end;  
  if (Date2Test("WSVc",WSp.TransDate,"TransDate",-1)==false) then begin
    res = -1;
    goto LWSVcRecordCheck;
  end;
  if (WSp.SerNr<=0) then begin
    WSp.SerNr = NextSerNr("WSVc",WSp.TransDate,-1,false,"");
  end;
  if (SerNrTestWSVc(WSp.SerNr,WSp.TransDate,gentrans)==false) then begin
    if (check>0) then begin
      RecordCheckError(1557,"",-1,"SerNr");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
  end;
  if (check==0) then begin
    goto LWSVcRecordCheck_GenTrans;
  end;

  if (DisallowFutureDateCheck(true,WSp.TransDate,"TransDate",-1)) then begin
    res = -1;
    goto LWSVcRecordCheck;
  end;

  if (blank(WSp.EMCode)) then begin
    RecordCheckError(1058,"",-1,"EMCode");      
    res = -1;
    goto LWSVcRecordCheck;
  end;
  if ((WSp.PrelOK==0) and (WS2p.PrelOK!=0) and (WSp.OKFlag==0)) then begin
    RecordCheckError(1794,WSp.SerNr,-1,"SerNr");      
    res = -1;
    goto LWSVcRecordCheck;
  end;
  if ((WSp.PrelOK==1) or (WSp.OKFlag==1)) then begin
    testf = true;
  end;
  if ((WSp.PrelOK==0) and (WS2p.PrelOK!=0) and (WSp.OKFlag==0)) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1;
    goto LWSVcRecordCheck;
  end;
  if ((WSp.WONr==-1) and (WSp.SVONr==-1)) then begin
    RecordCheckError(1058,WSp.WONr,-1,"WONr");      
    res = -1;
    goto LWSVcRecordCheck;
  end;
  errcode = CheckRates(WSp.CurncyCode,WSp.FrRate,WSp.ToRateB1,WSp.ToRateB2,WSp.BaseRate1,WSp.BaseRate2,tstr);
  if (errcode!=0) then begin
    RecordCheckError(errcode,"",-1,tstr);      
    res = -1; 
    goto LWSVcRecordCheck;
  end;          
  SVOr.SerNr = WSp.SVONr;
  if (ReadFirstMain(SVOr,1,true)==false) then begin
    RecordCheckError(1252,"",-1,"WONr");      
    res = -1;
    goto LWSVcRecordCheck;  
  end else begin
    if (SVOr.DoneMark!=0) then begin
      RecordCheckError(1977,"",-1,"WONr");      
      res = -1;
      goto LWSVcRecordCheck;  
    end;
  end;
  if (transf) then begin
    if (UserCanAction("WorkSheetOK",true)==false) then begin
      RecordCheckError(1274,StringFromStringSet(3,"WorkSheetOK"),-1,"SerNr");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
  end;
  if (WSp.WONr>-1) then begin
    if (CheckWOFinished(WSp.WONr)) then begin
      RecordCheckError(1971,"",-1,"WONr");      
      res = -1;
      goto LWSVcRecordCheck;  
    end;
  end;
  if (nonblank(WSp.Objects)) then begin
    errcode = CheckObjs("",WSp.Objects,errstr);
    if (errcode!=0) then begin
      RecordCheckError(errcode,errstr,-1,"Objects");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
  end;   
  location = WSp.Location;
  if (check!=0) then begin
   if (MainStockRec.requireLocation!=0) then begin
     if (blank(WSp.Location)) then begin
       RecordCheckError(1058,WSp.Location,-1,"Location");      
       res = -1;
       goto LWSVcRecordCheck;
     end;
   end;
  end;
  if (nonblank(location)) then begin
    Locationr.Code = location;
    if (ReadFirstMain(Locationr,1,true)==false) then begin
      RecordCheckError(1290,": " & location,-1,"Location");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
    if (AllowedToTakeFromThisLoc(Locationr)==false) then begin
      RecordCheckError(1768,": " & location,-1,"Location");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
  end;    
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (nonblank(WSrw.ArtCode)) then begin
      INr.Code = WSrw.ArtCode;
      found = ReadFirstMain(INr,1,true);
      if (found==false) then begin
        RecordCheckError(1120,WSrw.ArtCode,i,"ArtCode");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
      if (INr.ItemType==1) then begin
        if (WSrw.Quant<0) then begin
          RecordCheckError(1574,"",i,"Quant");      
          res = -1;
          goto LWSVcRecordCheck;
        end;      
      end;
      if (CheckSerialStatus(WSrw.ArtCode,WSrw.SerialNr,tstr)==2) then begin
        RecordCheckError(2210," " & tstr,i,"SerialNr");      
        res = -1; 
        goto LWSVcRecordCheck;
      end;
      if (WSrw.Quant<=0) then begin
        RecordCheckError(1574,"",i,"Quant");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
      if (check!=0) then begin
        if (IsRecipeClosed(INr.Recepy)) then begin
          RecordCheckError(2088,"",i,"ArtCode");      
          res = -1; 
          goto LWSVcRecordCheck;
        end;
      end;
    end;
    if (WSrw.Sum!=0) then begin
      if (UseTaxTemplatesforTaxCalc) then begin
        if (blank(WSrw.TaxTemplateCode)) then begin
          RecordCheckError(24201,"",i,"TaxTemplateCode");      
          res = -1;
          goto LWSVcRecordCheck;
        end;
        errcode = VerifyTaxTemplateCode(WSrw.TaxTemplateCode,tstr);
        if (errcode!=0) then begin
          RecordCheckError(errcode,tstr,i,"TaxTemplateCode");          
          res = -1; 
          goto LWSVcRecordCheck;
        end;
      end else begin
        if (blank(WSrw.VATCode)) then begin
          RecordCheckError(1134,"",i,"VATCode");      
          res = -1;
          goto LWSVcRecordCheck;
        end;
      end;
    end;
    if (nonblank(WSrw.ArtCode)) then begin
      if (blank(WSrw.MotherNr)) then begin
        RecordCheckError(1132,"",i,"MotherNr");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
    end;
    if (okf) then begin
      if (CheckSerialNoMaxCost(WSrw.MotherNr,WSrw.Sum,SVOr)) then begin
        RecordCheckError(1976,WSrw.ArtCode,i,"ArtCode");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
    end;
    if (nonblank(WSrw.ArtCode)) then begin
      if (GetItemType(WSp.SVONr,WSp.WONr,WSrw.MotherNr,WSrw.ItemType)==0) then begin
        RecordCheckError(2279,"",i,"ItemType");      
        res = -1;
        goto LWSVcRecordCheck;    
      end;
    if (StockRecordForLocationAllowed("WSVc",location,WSrw.ArtCode,WSp.TransDate,WSp.OKFlag,errcode,errstr)==false) then begin
      RecordCheckError(errcode,errstr,i,"ArtCode");      
      res = -1;
      goto LWSVcRecordCheck;
    end;
//    if (nonblank(WSrw.Objects)) then begin 
      accstr = WSrw.CostAcc;
      if (blank(accstr)) then begin
        accstr = WSp.CostAcc;
      end;
      VerifyRowObjects("SL",WSp.Objects,WSrw.Objects,accstr,errcode,errstr,initotcheckf,otcheckaccs,otcheckobjtyps,otcheckcnt);                    
      if (errcode!=0) then begin
        RecordCheckError(errcode,errstr,i,"Objects");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
    end;
    if (nonblank(WSrw.SalesAcc)) then begin
      if (GetAccName(WSrw.SalesAcc,tstr,60)==false) then begin
        RecordCheckError(1947,WSrw.SalesAcc,i,"SalesAcc");
        res = -1;
        goto LWSVcRecordCheck;
      end;
      Accr.AccNumber = WSrw.SalesAcc;
      if (ReadFirstMain(Accr,1,true)==false) then begin
        RecordCheckError(1007,WSrw.SalesAcc,i,"SalesAcc");
        res = -1;
        goto LWSVcRecordCheck;
      end else begin
        if ((Accr.blockedFlag!=0) or (Accr.GroupAcc!=0)) then begin
          RecordCheckError(1084,WSrw.SalesAcc,i,"SalesAcc");
          res = -1;
          goto LWSVcRecordCheck;
        end;
      end;
    end;
    if (nonblank(WSrw.CostAcc)) then begin
      if (GetAccName(WSrw.CostAcc,tstr,60)==false) then begin
        RecordCheckError(1947,WSrw.CostAcc,i,"CostAcc");
        res = -1;
        goto LWSVcRecordCheck;
      end;
      Accr.AccNumber = WSrw.CostAcc;
      if (ReadFirstMain(Accr,1,true)==false) then begin
        RecordCheckError(1007,WSrw.CostAcc,i,"CostAcc");
        res = -1;
        goto LWSVcRecordCheck;
      end else begin
        if ((Accr.blockedFlag!=0) or (Accr.GroupAcc!=0)) then begin
          RecordCheckError(1084,WSrw.CostAcc,i,"CostAcc");
          res = -1;
          goto LWSVcRecordCheck;
        end;
      end;
    end;
    if (nonblank(WSrw.ArtCode)) then begin
    if (check!=0 and testf) then begin
      if (MainStockRec.dontAllowOvership==1) then begin
        if ((INr.ItemType==1) or (nonblank(WSrw.Recepy))) then begin
          if (WSp.UpdStockFlag!=0) then begin
            if (nonblank(WSrw.Recepy)) then begin
              if (CheckStructureItemsLevel(WSrw.ArtCode,WSrw.Recepy,location,WSrw.Quant)==false) then begin
                RecordCheckError(1247,"",i,"Quant");      
                res = -1;
                goto LWSVcRecordCheck;
              end;
            end else begin                    
              prev = 0;
              for (j=0;j<i;j=j+1) begin
                MatRowGet(WSp,j,WS2rw);
                if (WS2rw.ArtCode==WSrw.ArtCode) then begin
                  prev = prev + WS2rw.Quant;
                end;
              end;
              prev = prev + WSrw.Quant;
              FindStockValue(WSrw.ArtCode,location,ISr);
              if (ISr.Instock<prev) then begin
                RecordCheckError(1247,"",i,"Quant");      
                res = -1;
                goto LWSVcRecordCheck;
              end;
            end;
          end;
        end;  
      end;
      if ((INr.SerNrf>0) and (INr.SerNrf<3)) then begin
        if (IsSerialNrCorrect(WSrw.SerialNr)==false) then begin
          RecordCheckError(24154,WSrw.SerialNr,i,"SerialNr");      
          res = -1; 
          goto LWSVcRecordCheck;
        end;        
        if (blank(WSrw.SerialNr)) then begin
          if (WSrw.Quant>0) then begin
            RecordCheckError(1239,"",i,"SerialNr");      
            res = -1;
            goto LWSVcRecordCheck;
          end;
        end;
          // is the serial number available at given location 
        if (WSrw.Quant>0) then begin
          if (WSp.UpdStockFlag!=0) then begin
            if (INr.SerNrf==1) then begin
              if (SerialNrAvail(WSrw.ArtCode,WSrw.SerialNr,location,WSrw.Quant)==false) then begin
                RecordCheckError(1240,"",i,"SerialNr");      
                res = -1;
                goto LWSVcRecordCheck;
              end;
            end else begin
              prev = 0;
              for (j=0;j<i;j=j+1) begin
                MatRowGet(WSp,j,WS2rw);
                if ((WS2rw.ArtCode==WSrw.ArtCode) and (WS2rw.SerialNr==WSrw.SerialNr)) then begin
                  prev = prev + WS2rw.Quant;
                end;
              end;
              prev = prev + WSrw.Quant;
              if (SerialNrAvail(WSrw.ArtCode,WSrw.SerialNr,location,prev)==false) then begin
                RecordCheckError(1240,"",i,"SerialNr");      
                res = -1;
                goto LWSVcRecordCheck;
              end;
            end;
          end;
        end;
        if (INr.SerNrf==1) then begin 
          if (WSrw.Quant!=1) then begin
            RecordCheckError(1242,"",i,"SerialNr");      
            res = -1;
            goto LWSVcRecordCheck;
          end;
        end;
      end;
    end;
    end;
  end;
  if (check!=0) then begin
    WSUpdateFIFO(WSp);
  end;
  if (transf) then begin
    if (stat==updatemode) then begin
      sernr = WS2p.SerNr;
    end;

    if (check>0) then begin
      if (MainStockRec.Chronology!=0) then begin 
        if (ExistStockTrans(WSp.Location,WSp.TransDate,errcode,errstr,"WSVc",sernr,MainStockRec)) then begin
          RecordCheckError(errcode,errstr,-1,"TransDate");      
          res = -1;
          goto LWSVcRecordCheck;
        end;
      end;
    end;
    if (CanOKStockRecord(errcode)==false) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1; 
      goto LWSVcRecordCheck;
    end;
  end;
LWSVcRecordCheck_GenTrans:;
  if (gentrans==false) then begin transf = false; end;
  if (WSp.UpdStockFlag==0) then begin transf = false; end;
  if (transf) then begin
//    if (CheckIfUpdateLockOKNr(WSp)) then begin //not neccesery I think
      errcode = MakeTransFromWS(gTRp,WSp,false);
      if (errcode!=0) then begin
        RecordCheckError(errcode,"",-1,"SerNr");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
//    end;
  end;
  if ((gTRp.Number>0) and (gTRp.IntYc==WSYc)) then begin
    if (MatRowCnt(gTRp)>0) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        RecordCheckError(1085,tstr,-1,"SerNr");      
        res = -1;
        goto LWSVcRecordCheck;
      end;
      switch (gRuniningMaint) begin    
        case "RecalcStockMn":
          UpdateTrans_Stock(gTRp);          
        otherwise
          SaveTrans(gTRp);
      end;
    end;
  end;  
LWSVcRecordCheck:;
  if (res!=0) then begin
    WSp.SerNr = oldnr;
  end;
  WSVcRecordCheck = res;
  return;
end;

global
function LongInt WSVcRecordRemoveTest(var record WSVc WSr,record WSVc WS2r,LongInt long3,LongInt long4)
begin
  LongInt res;

  res = 1;
  if (WSr.OKFlag!=0) then begin
    res = 0;
  end;
LWSVcRecordRemoveTest:;
  WSVcRecordRemoveTest = res; 
  return;
end;

global
function Boolean CheckIfUpdateLockOKNr(record WSVc WSp)
begin
  record INVc INr;
  row WSVc WSrw;
  Integer i,rwcnt;
  Boolean res;

  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    INr.Code = WSrw.ArtCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType==1 ) then begin
        res = true;
        goto LCheckIfUpdateLockOKNr;
      end;// only stockeditems, structured are not allowd right now
    end;
  end;  
LCheckIfUpdateLockOKNr:;
  CheckIfUpdateLockOKNr = res;
  return;
end;

global
procedure SetWSFlags(record WSVc WSp)
begin
/* // WHAT??
  switch (WSp.OKFlag) begin
    case 0: WSp.OKFlag = 0;
    otherwise WSp.OKFlag = 18;
  end;
  switch (WSp.PrelOK) begin
    case 0: WSp.PrelOK = 0;
    otherwise WSp.PrelOK = 18;
  end;
  switch (WSp.InvFlag) begin
    case 0: WSp.InvFlag = 0;
    otherwise WSp.InvFlag = 18;
  end;
*/
  return;
end;

global
updating procedure WSPrelOK(record WSVc WSp,Boolean addf)
begin
  row WSVc WSrw;
  row SHVc SHrw;
  record SHVc SHr;
  Integer rwcnt,i,shrwcnt,j;
  record MainStockBlock MSb;
  string 255 location;
  Boolean isstruct;
  val t3,t,q2;

  BlockLoad(MSb);
  location = WSp.Location;
  if (blank(location)) then begin
    location = MSb.MainStock;
  end;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (WSrw.stp==1) then begin
      isstruct = false;
      if (WSrw.stp!=kInvoiceRowTypeStructuredItemComponent) then begin
        isstruct = ExpandStructItem(WSrw.ArtCode,WSrw.Recepy,WSrw.Quant,SHr);
      end;
      if (isstruct==false) then begin
        t3 = WSrw.Quant;
        if (addf==false) then begin
          t3 = -t3;
        end;
        if (t3!=0) then begin
          UpdateInstock("WSVc",WSp.SerNr,WSrw.ArtCode,location,WSp.TransDate,t,t,t3,t,t,t,t,t,t);
        end;
      end else begin
        t3 = WSrw.Quant;
        if (addf==false) then begin
          t3 = -t3;
        end;
        if (t3!=0) then begin
          UpdateInstock("WSVc",WSp.SerNr,WSrw.ArtCode,location,WSp.TransDate,t,t,t3,t,t,t,t,t,t);
        end;
        shrwcnt = MatRowCnt(SHr);
        for (j=0;j<shrwcnt;j=j+1) begin
          MatRowGet(SHr,j,SHrw);
          t3 = SHrw.Ship;
          if (addf==false) then begin
            t3 = -t3;
          end;
          if (t3!=0) then begin
            UpdateInstock("WSVc",WSp.SerNr,SHrw.ArtCode,location,WSp.TransDate,t,t,t3,t,t,t,t,t,t);
          end;
        end;  
      end;
    end;
  end;  
  SetWSFlags(WSp);
LWSPrelOK:;
  return;
end;

global
updating function LongInt WSVcRecordSave(var record WSVc WSr,record WSVc WS2r,LongInt stat,LongInt long4)
begin
  LongInt res;

  if (WSr.OKFlag==1) then begin
    if (CheckIfUpdateLockOKNr(WSr)) then begin
      WSr.LocOKNr = NextLocOKNr(WSr.Location);
    end;
  end;
  WSVcRecordSave = res; 
  return;
end;

global
updating procedure WSUpdateSVOWSMark(record WSVc WSp)
begin
  record WSVc lWSr;
  record SVOVc oldSVOr;
  record SVOVc SVOr;

  SVOr.SerNr = WSp.SVONr;
  if (ReadFirstMain(SVOr,1,true)) then begin
    RecordCopy(oldSVOr,SVOr);    
    lWSr.SVONr = SVOr.SerNr;
    lWSr.OKFlag = 0;
    if (ReadFirstKey("SVONr",lWSr,2,true)) then begin
      SVOr.WSMark = 45;       
    end else begin
      SVOr.WSMark = 18;       
    end;
    if (RecordUpdate(oldSVOr,SVOr,false)==0) then begin end;
  end;  
  return;
end;

updating procedure WSRemoveUpdateSVOWSFlag(LongInt svonr)
begin
  record WSVc WSr;
  record SVOVc SVOr,oldSVOr;

  SVOr.SerNr = svonr;
  if (ReadFirstMain(SVOr,1,true)) then begin
    WSr.SVONr = svonr;
    if (ReadFirstKey("SVONr",WSr,1,true)==false) then begin
      RecordCopy(oldSVOr,SVOr); 
      SVOr.WSMark = 0;
      if (RecordUpdate(oldSVOr,SVOr,false)==0) then begin end;
    end;
  end;  
  return;
end;

global
updating function LongInt WSVcRecordRemoveAfter(var record WSVc WSr,record WSVc WS2r,LongInt stat,LongInt long4)
begin
  LongInt res;

  WSRemoveUpdateSVOWSFlag(WSr.SVONr);
  WSVcRecordRemoveAfter = res;
  return;
end;

global
updating procedure WSUpdateStockTool2(record WSVc WSp,Boolean negf,Boolean unokf,record TempStockVc TSr,Boolean usetmpstkf)
begin
  Integer i,rwcnt;
  row WSVc WSrw;
  val t,t2,q2,wq;
  record SHVc SHr;
  Boolean isstruct;
  row SHVc SH2rw;
  Integer j,shrwcnt;
  string 10 location;
  record MainStockBlock MainStockRec;
  record INVc INr;
  Boolean testf;
  row TempStockVc TSrw;
  
  if (WSp.UpdStockFlag==0) then begin
    goto LWSUpdateStockTool;
  end;
  BlockLoad(MainStockRec);
  location = WSp.Location;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;
  rwcnt = MatRowCnt(WSp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(WSp,i,WSrw);
    if (nonblank(WSrw.ArtCode)) then begin
      if (ShouldItemUpdateStock(WSrw.ArtCode)==false) then begin goto L22WSUpdateStockTool; end;
      if (usetmpstkf) then begin
        FindTempStockRow(i,WSrw.ArtCode,blank(WSrw.Recepy),TSr,TSrw);
        if (TSrw.StockAffectf==0) then begin goto L22WSUpdateStockTool; end;
        if (TSrw.ItemType!=kItemTypeStocked) then begin goto L22WSUpdateStockTool; end;
      end;
      isstruct = ExpandStructItem(WSrw.ArtCode,WSrw.Recepy,WSrw.Quant,SHr);
      if (isstruct==false) then begin
        t2 = -WSrw.Quant;
        if (ShouldItemUpdateStock(WSrw.ArtCode)==false) then begin t2 = 0; end;
        if (t2!=0) then begin
          if (MainStockRec.UnitConvCalc==0) then begin
            q2 = t2 * WSrw.Coefficient;
          end else begin
            q2 = t2 / WSrw.Coefficient;
          end;
          if (WSp.OKFlag!=0) then begin
            wq = -WSrw.Quant;
          end else begin
            if (unokf==false) then begin
              t2 = blankval;
              q2 = blankval;
            end else begin
              t2 = -t2;
              q2 = -q2;
            end;
            if (negf) then begin
              wq = -WSrw.Quant;
            end else begin
              wq = WSrw.Quant;
            end;
          end;
          UpdateInstock("WSVc",WSp.SerNr,WSrw.ArtCode,location,WSp.TransDate,t2,t,t,t,t,q2,t,t,wq);
        end;
      end else begin
        shrwcnt = MatRowCnt(SHr);
        for (j=0;j<shrwcnt;j=j+1) begin
          MatRowGet(SHr,j,SH2rw);
          t2 = -SH2rw.Ship;
          if (ShouldItemUpdateStock(WSrw.ArtCode)==false) then begin t2 = 0; end;
          if (t2!=0) then begin
            if (MainStockRec.UnitConvCalc==0) then begin
              q2 = t2 * WSrw.Coefficient;
            end else begin
              q2 = t2 / WSrw.Coefficient;
            end;
            if (WSp.OKFlag!=0) then begin
              wq = -SH2rw.Ship;
            end else begin
              t2 = blankval;
              q2 = blankval;
              if (negf) then begin
                wq = -SH2rw.Ship;
              end else begin
                wq = SH2rw.Ship;
              end;                
            end;
            UpdateInstock("WSVc",WSp.SerNr,SH2rw.ArtCode,location,WSp.TransDate,t2,t,t,t,t,q2,t,t,wq);
          end;
        end;
      end;
    end;
L22WSUpdateStockTool:;
  end;
LWSUpdateStockTool:;  
  return;
end;

global
updating procedure WSUpdateStockTool(record WSVc WSp,Boolean negf,Boolean unokf)
begin
  record TempStockVc TSr;
  
  WSUpdateStockTool2(WSp,negf,unokf,TSr,false);
  return;
end;

global
updating procedure WSUpdateStock(record WSVc WSp,Boolean wsf,record WSVc WS2p,Boolean ws2f,Boolean unokf)
begin
  
  if (ws2f) then begin
    WSUpdateStockTool(WS2p,true,unokf);
  end;
  if (wsf) then begin
    WSUpdateStockTool(WSp,false,unokf);
  end;
  return;
end;

global
updating procedure WSOK(record WSVc WSp)
begin
  row WSVc WSrw;
  Integer i,rwcnt;

  if (WSp.OKFlag==0) then begin goto LWSOK; end;
  if (RecordValid(WSp)) then begin
    rwcnt = MatRowCnt(WSp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(WSp,i,WSrw);
      WSCreateWSIV(WSp,i,WSrw);
      WSUpdateSVO(WSp,WSrw);  
    end;
    SetWSFlags(WSp);
    WSUpdatePErs(WSp);    
  end;
LWSOK:;
  return;
end;

global
updating function LongInt WSVcRecordSaveAfter(var record WSVc WSr,record WSVc WS2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  
  WSUpdateSVOWSMark(WSr);
  WSUpdateStock(WSr,true,WS2r,false,false);
  if (WSr.OKFlag!=0) then begin
    WSUpdateItemHistory(WSr);
    WSUpdateSerialNr(WSr,false,true);
    WSOK(WSr);
  end;
  if ((WSr.PrelOK!=0) and (WSr.OKFlag==0)) then begin 
    WSPrelOK(WSr,true);
  end;
  WSVcRecordSaveAfter = res; 
  return;
end;

global
function LongInt WSVcRecordProtectFields(var record WSVc WSr,record WSVc WS2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  Integer i,rwcnt;
  row WSVc WSrw;
  row WSVc WS2rw;
  Integer rwcnt2;
  
  WS2r.InvFlag = WSr.InvFlag;
  rwcnt = MatRowCnt(WSr);
  rwcnt2 = MatRowCnt(WS2r);
  for (i=0;i<rwcnt2;i=i+1) begin
    if (i<rwcnt) then begin
      MatRowGet(WSr,i,WSrw);
      MatRowGet(WS2r,i,WS2rw);
      WS2rw.Returned = WSrw.Returned;
      WS2rw.Invd = WSrw.Invd;
      MatRowPut(WS2r,i,WS2rw);
    end;
  end;
  WSVcRecordProtectFields = res;
  return;
end;
