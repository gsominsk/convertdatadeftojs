external procedure SwapM4Val(var val,var val);
external procedure ConvertToDualBase(var string,date,var val,var val,var val,var val,var val,var val,Boolean);
external function Integer CheckObjs(string,string,var string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetORProgCurncy(var record ORProgVc);

global
function LongInt ORProgVcRecordDefaults(record ORProgVc ORProgr,record ORProgVc ORProg2r,LongInt stat,LongInt long4)
begin
  record AccBlock ARAccRec;
  LongInt res;
  
  BlockLoad(ARAccRec);  
  ORProgr.OrdDate = CurrentDate;
  ORProgr.ChangedDate = CurrentDate;
  ORProgr.SalesMan = CurrentUser;
  ORProgr.InclVAT = ARAccRec.BasePriceInclVAT;
  ORProgr.SerNr = -1;
  GetORProgCurncy(ORProgr);
  if (SingleUserMode) then begin
    ORProgr.SerNr = NextSerNr("ORProgVc",ORProgr.OrdDate,-1,false,"");
  end;
  ORProgVcRecordDefaults = res;
  return;
end;  

global
function LongInt ORProgVcRecordDuplicate(record ORProgVc ORProgr,record ORProgVc ORProg2r,LongInt stat,LongInt long4)
begin
  record AccBlock ARAccRec;
  LongInt res;
  
  BlockLoad(ARAccRec);  
//  ORProgr.OrdDate = CurrentDate;
  ORProgr.ChangedDate = CurrentDate;
  ORProgr.SalesMan = CurrentUser;
  ORProgr.InclVAT = ARAccRec.BasePriceInclVAT;
  ORProgr.SerNr = -1;
  GetORProgCurncy(ORProgr);
  if (SingleUserMode) then begin
    ORProgr.SerNr = NextSerNr("ORProgVc",ORProgr.OrdDate,-1,false,"");
  end;
  ORProgVcRecordDuplicate = res;
  return;
end;  

global
function LongInt ORProgVcRecordUpdate(record ORProgVc ORProgr,record ORProgVc ORProg2r,LongInt stat,LongInt long4)
begin
  LongInt res;

  ORProgr.ChangedDate = CurrentDate;
  ORProgVcRecordUpdate = res;
  return;
end;

global
function LongInt ORProgVcRecordCheck(record ORProgVc ORProgr,record ORProgVc ORProg2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  Integer insertmode,updatemode;
  record INVc INr;
  record CUVc VEr;
  row ORProgVc ORProgrw;
  Integer i,rwcnt,errcode;
  LongInt oldnr;
  record LocationVc Locr;
  string 255 errstr;
  

  res = 0;
  insertmode = 1;
  updatemode = 2;
  oldnr = ORProgr.SerNr;

  if (ORProgr.SerNr==-1) then begin
    ORProgr.SerNr = NextSerNr("ORProgVc",ORProgr.OrdDate,-1,false,"");
  end;
  if (ORProgr.SerNr==-1) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1;
    goto LORProgVcRecordCheck;
  end;
  VEr.Code = ORProgr.VECode;
  if (ReadFirstMain(VEr,1,true)==false) then begin
    RecordCheckError(1205,"",-1,"VECode");      
    res = -1; 
    goto LORProgVcRecordCheck;
  end;
  if (nonblank(ORProgr.Objects)) then begin     
    errcode = CheckObjs("",ORProgr.Objects,errstr);
    if (errcode!=0) then begin
      RecordCheckError(errcode,errstr,-1,"Objects");      
      res = -1; 
      goto LORProgVcRecordCheck;
    end;
  end;  
  if (nonblank(ORProgr.Location)) then begin
    Locr.Code = ORProgr.Location;
    if (ReadFirstMain(Locr,1,true)==false) then begin
      RecordCheckError(1058,"",-1,"Location");      
      res = -1; 
      goto LORProgVcRecordCheck;
    end;
  end;
  rwcnt = MatRowCnt(ORProgr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORProgr,i,ORProgrw);
    switch (ORProgrw.stp) begin
      case 1:
        if (nonblank(ORProgrw.ArtCode)) then begin
          if (ReadFirstItem(ORProgrw.ArtCode,INr,true,false)==false) then begin
            RecordCheckError(1120,ORProgrw.ArtCode,i,"ArtCode");      
            res = -1; 
            goto LORProgVcRecordCheck;
          end;
          if (INr.Terminated!=0) then begin
            RecordCheckError(1266,ORProgrw.ArtCode,i,"ArtCode");      
            res = -1; 
            goto LORProgVcRecordCheck;
          end;
          if (INr.ItemType==2) then begin
            RecordCheckError(1826,ORProgrw.ArtCode,i,"ArtCode");      
            res = -1; 
            goto LORProgVcRecordCheck;
          end;
        end;      
    end;
  end;  
LORProgVcRecordCheck:;
  if (res!=0) then begin ORProgr.SerNr = oldnr; end;
  ORProgVcRecordCheck = res;
  return;
end;

procedure ORProgVcConvertB1ToB2(var val to1p,var val to2p,var val br1p,var val br2p)
BEGIN    
  SwapM4Val(br1p,br2p);
  SwapM4Val(to1p,to2p);
  RETURN;
END;

global
function LongInt ORProgVcRecordImport(var record ORProgVc ORProgr,record ORProgVc ORProg2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  val t,fr,to1,to2,br1,br2;
  string 5 curncy;
  Boolean gToDualBase,gBase1ToBase2;
  record ConvMasterBlock cvm;
      
  BlockLoad(cvm);
  if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
  if (gToDualBase) then begin
    curncy = ORProgr.CurncyCode;
    fr = ORProgr.FrRate;
    to1 = ORProgr.ToRateB1;
    to2 = ORProgr.ToRateB2;
    br1 = ORProgr.BaseRate1;
    br2 = ORProgr.BaseRate2;
    ConvertToDualBase(curncy,ORProgr.MaintDate,fr,to1,to2,br1,br2,t,true);
    ORProgr.CurncyCode = curncy;
    ORProgr.FrRate = fr;
    ORProgr.ToRateB1 = to1;
    ORProgr.ToRateB2 = to2;
    ORProgr.BaseRate1 = br1;
    ORProgr.BaseRate2 = br2;
  end;
  if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
  if (gBase1ToBase2) then begin
    curncy = ORProgr.CurncyCode;
    to1 = ORProgr.ToRateB1;
    to2 = ORProgr.ToRateB2;
    br1 = ORProgr.BaseRate1;
    br2 = ORProgr.BaseRate2;
    ORProgVcConvertB1ToB2(to1,to2,br1,br2);
    ORProgr.ToRateB1 = to1;
    ORProgr.ToRateB2 = to2;
    ORProgr.BaseRate1 = br1;
    ORProgr.BaseRate2 = br2;
  end;
  ORProgVcRecordImport = res;
  RETURN;
END;
