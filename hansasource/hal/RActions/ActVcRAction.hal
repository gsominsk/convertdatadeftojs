external function Boolean FindAcceptanceRulesAndAmountForActivity(record ActVc,var record AcceptanceRulesVc,var val);
external function val GetAcceptanceSum_SDVc(record SDVc);
external function val GetAcceptanceSum_OPVc(record OPVc);
external function Boolean FindTheUser(var record UserVc);
external updating function Integer TestLinkedRecordCanBeOKed(record ActVc);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ReadAcceptanceRules(Integer,string,var record AcceptanceRulesVc);
external updating procedure InvalidateTR(Integer,LongInt);
external function Boolean TBIVItemsUsage(record PRVc,record INVc,val);
external function Boolean CheckProjectMember(record PRVc);
external function Boolean IsPRPhaseLocked(string,Date,var string);
external function Boolean Date2Test(string,Date,string,Integer);
external procedure GetProjectWIPAcc(record PRAccBlock,string,var string,var string);
external procedure GetFullCurncyRate(var string,Date,var val,var val,var val,var val,var val);
external updating procedure SaveTrans(record TRVc);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure DeleteAlarm(record ActVc);
external updating procedure UpdateAlarm(record ActVc);
external updating procedure CreateAlarm(record ActVc);
external function Integer CheckResources(string,var string);
external procedure ExtractObj(string,var Integer,var string);
external function GetPRName(string, var string);
external function Integer CountObjects(string);
external updating procedure CreateConsequences(record ActVc);
external procedure GetItemGroup(string,var string);
external function Integer ActLenClass(Date,Date);
external function Boolean SerNrTestTSVc(LongInt,Date,var Boolean);
external function Boolean GetAccName(string,var string,Integer);
external procedure AddEuroTrRow(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string);
external function Boolean TransInFiscal(Date);
external procedure GetPRItemCost(string,string,string,string,Integer,var val);
external function Integer CheckUsers(string,string,var string,Boolean);
external function Boolean GetTSAcc(string,string,var string,var string,var string);
external function Integer GetINType(string);
external function val TimeToVal2(Time);
external updating procedure ActOK(record ActVc);
external function Boolean ActivityIsForAbsence(record ActVc);
external function Boolean DateLocked(Date,string);
external function Boolean DateWarned(Date,string);

procedure ActNLTSer(Date td,var LongInt tserstart,var LongInt tserend)
begin
  LongInt res;
  record ActNLSerBlock ANLSerb;
  row ActNLSerBlock ANLSerbrw;
  Integer i,rwcnt;

  BlockLoad(ANLSerb);
  rwcnt = MatRowCnt(ANLSerb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ANLSerb,i,ANLSerbrw);
    if (DateInRange(td,ANLSerbrw.StartDate,ANLSerbrw.EndDate)) then begin
      tserstart = ANLSerbrw.TSerStart;
      tserend = ANLSerbrw.TSerEnd;
      goto LActNLTSer;
    end;
  end;
LActNLTSer:;  
  return;
end;

updating function Integer MakeTransFromAct(record TRVc gTRp,var record ActVc Actr,Boolean rpt)
BEGIN
  Integer errstr;
  Integer i,rwcnt;
  record TRGenBlock TRGenRec;
  string 10 wipacc,balacc,costacc;
  string 255 accname,curcode;
  val fr,to1,to2,base1,base2,cost;
  val TotSum;
  record PRAccBlock PRAb;
  record INVc INr;  
  record PRVc PRr;
  Integer itemtype;
  record ActVc lastNLActr;
  val Qty;
  LongInt nltserstart,nltserend;

  PRr.Code = Actr.PRCode;
  if (ReadFirstMain(PRr,1,true)) then begin
    if (PRr.UseWIP==0) then begin
      goto LMakeTransFromAct;
    end;
  end;
  GetFullCurncyRate(curcode,Actr.TransDate,fr,to1,to2,base1,base2);
  
  BlockLoad(TRGenRec);
  BlockLoad(PRAb);
  errstr = 0;
  if (rpt==false) then begin
    if (TRGenRec.ActGenTrans==0) then begin
      errstr = 0;
      goto LMakeTransFromAct;
    end;
  end;
  if (rpt==false) then begin
    if ((nonblankdate(TRGenRec.ActStartDate)) and
        (Actr.TransDate<TRGenRec.ActStartDate)) then begin
      errstr = 0;
      goto LMakeTransFromAct;
    end;  
  end;  
  
  ActNLTSer(Actr.TransDate,nltserstart,nltserend);
  if (nltserend>0) then begin
    lastNLActr.TRSerNr = nltserend;
  end else begin
    lastNLActr.TRSerNr = 1000000000000;
  end;
  ReadLastKey("TRSerNr",lastNLActr,1,false);  
  if (nltserend>0) then begin
    if ((lastNLActr.TRSerNr<nltserstart) or (lastNLActr.TRSerNr>nltserend)) then begin
      lastNLActr.TRSerNr = nltserstart - 1;
    end;
  end;
  Actr.TRSerNr = lastNLActr.TRSerNr + 1;
  if (Actr.TRSerNr<=0) then begin
    Actr.TRSerNr = 1;
  end;
  RecordNew(gTRp);
  gTRp.IntYc = ActYc;
  gTRp.Number = Actr.TRSerNr;
  gTRp.RefStr = "";
  gTRp.RegDate = CurrentDate;
  gTRp.RegTime = CurrentTime;
  gTRp.TransDate = Actr.TransDate;
  if (rpt==false) then begin
    if (TransInFiscal(gTRp.TransDate)==false) then begin
      errstr = 1075;
      goto LMakeTransFromAct;
    end;
  end;
  gTRp.Comment = Actr.Comment;
  gTRp.Comment = gTRp.Comment & ", ";
  gTRp.Comment = gTRp.Comment & USetStr(1829) & ": " & Actr.PRCode;
/*  
  if (GetTSAcc(Actr.ItemCode,Actr.MainPersons,wipacc,balacc,costacc)==false) then begin        
    errstr = 1233;
    goto LMakeTransFromAct;
  end;
*/  
 GetProjectWIPAcc(PRAb,Actr.ItemCode,wipacc,balacc);      
 INr.Code = Actr.ItemCode;
 ReadFirstMain(INr,1,true);
  if (INr.ItemType==3) then begin
    itemtype = 3;
  end else begin
    if (INr.ItemMaterial!=0) then begin
      itemtype = 5;
    end else begin
      itemtype = 0;
    end;
  end;
  GetPRItemCost(Actr.PRCode,Actr.MainPersons,Actr.ItemCode,Actr.TimeClass,itemtype,cost);
  Qty = TimeToVal(Actr.CostTime);
  cost = Qty*cost;
  
  if (GetAccName(wipacc,accname,60)==false) then  begin
    errstr = 1909;      
    goto LMakeTransFromAct;
  end;
  AddEuroTrRow(gTRp,wipacc,"","",accname,cost,base1,base2,true,true,TotSum,false,"","","");

  if (GetAccName(balacc,accname,60)==false) then  begin
    errstr = 1910;      
    goto LMakeTransFromAct;
  end;
  AddEuroTrRow(gTRp,balacc,"","",accname,cost,base1,base2,true,false,TotSum,false,"","","");
LMakeTransFromAct:;
  MakeTransFromAct = errstr;
  RETURN;
END;

global 
function Boolean GenActProjTrans(string acttype)
BEGIN
  Boolean res;
  record ActTypeVc ATr;
  record ActTypeGrVc ATGrr;
  
  res = false;
  if (nonblank(acttype)) then begin
    ATr.Code = acttype;
    if (ReadFirstMain(ATr,1,true)) then begin
      ATGrr.Code = ATr.ActTypeGr;
      if (ReadFirstMain(ATGrr,1,true)) then begin
        if (ATGrr.CreateTBIV!=0) then begin 
          res = true;
        end;
      end;
    end;
  end;
  GenActProjTrans = res;
  RETURN;
END;

global 
function Boolean GenActWSTrans(string acttype)
BEGIN
  Boolean res;
  record ActTypeVc ATr;
  record ActTypeGrVc ATGrr;
  
  res = false;
  if (nonblank(acttype)) then begin
    ATr.Code = acttype;
    if (ReadFirstMain(ATr,1,true)) then begin
      ATGrr.Code = ATr.ActTypeGr;
      if (ReadFirstMain(ATGrr,1,true)) then begin
        if (ATGrr.CreateWSIV!=0) then begin 
          res = true;
        end;
      end;
    end;
  end;
  GenActWSTrans = res;
  RETURN;
END;
  
function Boolean CheckIfPRCodeAllowedForUser(string user,string prcode)
BEGIN  
  Boolean res;
  record UserVc Userr;
  row UserVc Userrw;
  Integer i,rwcnt,pos;
  
  res = true;
  Userr.Code = user;
  if (ReadFirstMain(Userr,1,true)) then begin
    if (Userr.DisAllowOther!=0) then begin       
      rwcnt = MatRowCnt(Userr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(Userr,i,Userrw);
        if (Userrw.PRCode==prcode) then begin
          goto LCheckIfPRCodeAllowedForUser;
        end;  
      end;
      res = false;
    end;
  end;
LCheckIfPRCodeAllowedForUser:;      
  CheckIfPRCodeAllowedForUser = res;
  RETURN;
END;
    
function string 20 CheckIfPRCodeAllowedForAllUsers(string users,string prcode)
BEGIN  
  string 20 res;
  Integer pos;
  string 20 usercode;
  
  pos = 0;
  ExtractObj(users,pos,usercode);
  while (nonblank(usercode)) begin
    if (CheckIfPRCodeAllowedForUser(usercode,prcode)==false) then begin
      res = usercode;
      goto LCheckIfPRCodeAllowedForAllUsers;
    end;
    ExtractObj(users,pos,usercode);
  end;
LCheckIfPRCodeAllowedForAllUsers:;  
  CheckIfPRCodeAllowedForAllUsers = res;
  RETURN;
END;

function Boolean TimeInRangeUserCheck(Time tt,Time st,Time et)
BEGIN
  Boolean res;
  
  res = true;
  if (nonblanktime(st)) then begin
    if (tt<=st) then begin res = false; end;
  end;
  if (nonblanktime(et)) then begin
    if (tt>=et) then begin res = false; end;
  end;
  if (blanktime(tt)) then begin
    res = true;
  end;
  TimeInRangeUserCheck = res;
  RETURN;
END;

function Boolean CheckIfTimeRegistered(record ActVc newActr,Integer NoActwithSameTime,var Integer wherecoursor,var string resstr)
BEGIN
  Boolean res;
  record ActVc oldActr;
  Boolean foundf,testf;
  string 255 ukey,usercode;
  Integer pos;
    
  if (NoActwithSameTime==0) then begin goto LCheckIfTimeRegistered; end;
  wherecoursor = 0;
  pos = 0;
  ExtractObj(newActr.MainPersons,pos,usercode);
  while (nonblank(usercode)) begin
    ResetLoop(oldActr);
    oldActr.TransDate = newActr.TransDate;
    oldActr.TodoFlag = 0; // Calendar
    foundf = true;
    ukey = "UserMain:" & usercode;
    while (LoopKey(ukey,oldActr,3,foundf)) begin
      if (oldActr.TodoFlag!=0) then begin foundf = false; end;
      if (oldActr.TransDate>newActr.TransDate) then begin foundf = false; end;      
      if (foundf) then begin
        testf = false;
        if (TimeInRangeUserCheck(newActr.StartTime,oldActr.StartTime,oldActr.EndTime)) then begin
          testf = true;
        end;
        if (newActr.EndDate<=oldActr.TransDate) then begin
          if (TimeInRangeUserCheck(newActr.EndTime,oldActr.StartTime,oldActr.EndTime)) then begin
            testf = true;          
          end;
        end;
        if (newActr.EndDate<=oldActr.TransDate) then begin
          if (newActr.StartTime==oldActr.StartTime) and (newActr.EndTime==oldActr.EndTime) then begin
            testf = true;
          end;
        end;
        if (oldActr.EndDate==newActr.TransDate) or (oldActr.TransDate==newActr.TransDate) then begin        
          if (newActr.StartTime<oldActr.StartTime) then begin
            if (newActr.EndTime>oldActr.EndTime) then begin
              if (newActr.EndDate==oldActr.EndDate) then begin
                testf = true;
              end;
            end;
          end;
        end;
        if (oldActr.SerNr==newActr.SerNr) then begin testf = false; end;
        if (oldActr.CalTimeFlag!=newActr.CalTimeFlag) then begin testf = false; end;
        if (oldActr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          resstr = oldActr.Comment;
          wherecoursor = 1;
          res = true;
          goto LCheckIfTimeRegistered;
        end;
      end;
    end;

    ResetLoop(oldActr);
    oldActr.EndDate = newActr.TransDate;
    oldActr.TodoFlag = 0; // Calendar
    foundf = true;
    ukey = "EndDateUserMain:" & usercode;
    while (LoopKey(ukey,oldActr,3,foundf)) begin
      if (oldActr.TodoFlag!=0) then begin foundf = false; end;
      if (oldActr.TransDate>newActr.EndDate) then begin foundf = false; end;      
      if (foundf) then begin
        testf = false;
        if (TimeInRangeUserCheck(newActr.StartTime,oldActr.StartTime,oldActr.EndTime)) then begin
          testf = true;
        end;        
        if (newActr.EndDate<=oldActr.TransDate) then begin
          if (TimeInRangeUserCheck(newActr.EndTime,oldActr.StartTime,oldActr.EndTime)) then begin
            testf = true;          
          end;
        end;
        if (newActr.EndDate<=oldActr.TransDate) then begin
          if (newActr.StartTime==oldActr.StartTime) and (newActr.EndTime==oldActr.EndTime) then begin
            testf = true;
          end;
        end;
        if (oldActr.EndDate==newActr.TransDate) then begin        
          if (newActr.StartTime<oldActr.EndTime) then begin
            if (newActr.EndTime>oldActr.StartTime) then begin 
//(old start time 23 old end time 09:45, new start time 09:00 must be blocked)
// Yes, it does, but this blocks also: old start 09:00 old end 10:00, new start time 07:00 new end 08:00 as well... BAD.
              testf = true;
            end;
          end;
        end;
        if (oldActr.TransDate==newActr.TransDate) then begin        
          if (newActr.StartTime<oldActr.StartTime) then begin
            if (newActr.EndTime>oldActr.EndTime) then begin
              if (newActr.EndDate==oldActr.EndDate) then begin
                testf = true;
              end;
            end;
          end;
        end;
        if (oldActr.SerNr==newActr.SerNr) then begin testf = false; end;
        if (oldActr.CalTimeFlag!=newActr.CalTimeFlag) then begin testf = false; end;
        if (oldActr.Invalid!=0) then begin testf = false; end;
        if (testf) then begin
          resstr = oldActr.Comment;
          wherecoursor = 2;
          res = true;
          goto LCheckIfTimeRegistered;
        end;
      end;
    end;
    ExtractObj(newActr.MainPersons,pos,usercode);
  end;
  
LCheckIfTimeRegistered:;  
  CheckIfTimeRegistered = res;
  RETURN;
END;

global
function Boolean CheckMultipleIndexField(string s,Integer elemlen,Integer maxlen)
begin
  Boolean res;
  string 255 class;
  Integer pos;
  
  res = true;
  if (nonblank(s)) then begin
    if (InString(s,";")!=0) then begin //only coma is allowed
      res = false;
      goto LCheckMultipleIndexField;
    end;
    if (len(s)>maxlen) then begin
      ExtractObj(s,pos,class);
      while (nonblank(class)) begin
        if (len(class)>elemlen) then begin
          res = false;
          goto LCheckMultipleIndexField;
        end;
        ExtractObj(s,pos,class);
      end;
    end;
  end;
LCheckMultipleIndexField:;
  CheckMultipleIndexField = res;
  return;
end;

global
function Boolean ActStateSeqAllowed(string fromstate,string tostate)
begin
  record ActStateSeqVc ASSr;
  Boolean res;

  res = true;
  if (fromstate!=tostate) then begin
    if (CountRecords("ActStateSeqVc")>0) then begin
      res = false;
      ASSr.FromState = fromstate;
      if (ReadFirstMain(ASSr,1,true)) then begin
        if (nonblank(tostate)) then begin
          if (SetInSet(tostate,ASSr.AllowedState)) then begin
            res = true;
          end;
        end;
      end;
    end;
  end;
  ActStateSeqAllowed = res;
  return;
end;

global
updating function LongInt ActVcRecordCheck(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record ActVc oldActr;
  record ActTypeVc ActTyper;
  record ActTypeGrVc ATGrr;
  record INVc INr;
  record PRVc PRr;
  record EGVc EGr;
  row EGVc EGrw;
  record UserVc EMr;
  Boolean acttypgrf;
  Integer j,jrwcnt;
  Boolean transf,gentrans,smalldevicesf,found;
  Integer errstr;
  string 255 tstr;
  Integer wherecoursor,NoActwithSameTime;
  record CUVc CUr;
  record CRMBlock CRMb;
  record ProdVc Prodr;
  record ProdOperationVc ProdOpr;
  record ActSeqVc ActSeqr;
  record PRAccBlock PRAb;
  record TRVc gTRp;
  val Qty;
  LongInt oldnr;
  record AcceptanceRulesVc Acptr;
  row AcceptanceRulesVc Acptrw;
  Integer i,rwcnt;
  transaction Boolean gActVcRecordUpdateAfterf;
  record CompanyTimezoneBlock CTb;
  val bc1v;
  Date td;
  
  BlockLoad(CTb);  
  BlockLoad(CRMb);
  BlockLoad(PRAb);  
  switch (ProgramType) begin
    case typTimeLog: smalldevicesf = true;
  end;
  if (stat==Rs_update) then begin
    if (Actr.SerNr<=0) and (Act2r.OKFlag==0) then begin
      Actr.SerNr = Act2r.SerNr;
    end;
  end;
  oldnr = Actr.SerNr;  
  td = Actr.TransDate;
  if (blankdate(td)) then begin
    td = CurrentDate;
  end;
  if (Actr.SerNr==-1) then begin
    Actr.SerNr = NextSerNr("ActVc",td,-1,false,"");
  end;
  
  gentrans = true;
  transf = false;
  if (Actr.OKFlag==1) then begin
    if (stat==Rs_insert) then begin transf = true; end;
    if (stat==Rs_update) then begin
      if (Act2r.OKFlag==0) then begin transf = true; end;
    end;  
  end;
/*  
  if (SerNrTestActVc(Actr.SerNr,Actr.TransDate,gentrans)==false) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1; 
    goto LActVcRecordCheck;
  end;
*/
  if (Date2Test("ActVc",td,"TransDate",-1)==false) then begin
    res = -1;
    goto LActVcRecordCheck;
  end;
  acttypgrf = false;
  if (nonblank(Actr.PRCode)) then begin
    PRr.Code = Actr.PRCode;
    if (ReadFirstMain(PRr,1,true)==false) then begin
      RecordCheckError(1232,"",-1,"PRCode");      
      res = -1;
      goto LActVcRecordCheck;
    end;
    if (PRr.Terminated!=0) then begin
      RecordCheckError(1232,"",-1,"PRCode");      
      res = -1;
      goto LActVcRecordCheck;
    end;        
    if (IsPRPhaseLocked(Actr.PRCode,Actr.TransDate,tstr)) then begin
      RecordCheckError(20408," " & tstr,-1,"PRCode");      
      res = -1;
      goto LActVcRecordCheck;
    end;
    if (UserCanAction("DisallowPostPRActualsfornonPRMan",false)) then begin
      if (CheckProjectMember(PRr)==false) then begin 
        RecordCheckError(1274,StringFromStringSet(3,"DisallowPostPRActualsfornonPRMan"),-1,"PRCode");      
        res = -1;
        goto LActVcRecordCheck;
      end;  
    end;
  end;        
  if (nonblank(Actr.ActResult)) then begin
    ActTyper.Code = Actr.ActResult;
    if (ReadFirstMain(ActTyper,1,true)==false) then begin
      RecordCheckError(1120," " & Actr.ActResult,-1,"ActResult");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
  end;
  if (nonblank(Actr.ActState)) then begin
    switch (stat) begin
      case Rs_update:
        if (ActStateSeqAllowed(Act2r.ActState,Actr.ActState)==false) then begin
          RecordCheckError(38454," " & Actr.ActState,-1,"ActState");      
          res = -1; 
          goto LActVcRecordCheck;
        end;
    end;
  end;
  if (nonblank(Actr.Supervisor)) then begin
    EMr.Code = Actr.Supervisor;
    if (FindTheUser(EMr)==false) then begin
      RecordCheckError(1120,Actr.Supervisor,-1,"Supervisor");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
  end;
  if (nonblank(Actr.ArtCode)) then begin
    INr.Code = Actr.ArtCode;
    if (ReadFirstMain(INr,1,true)==false) then begin
      RecordCheckError(1120,Actr.ArtCode,-1,"ArtCode");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
  end;
  if (Actr.ProdSerNr>0) then begin
    Prodr.SerNr = Actr.ProdSerNr;
    if (ReadFirstMain(Prodr,1,true)==false) then begin
      RecordCheckError(1290," " & Actr.ProdSerNr,-1,"ProdSerNr");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
  end;
  if (Actr.ProdOpSerNr>0) then begin
    ProdOpr.SerNr = Actr.ProdOpSerNr;
    if (ReadFirstMain(ProdOpr,1,true)==false) then begin
      RecordCheckError(1290," " & Actr.ProdOpSerNr,-1,"ProdOpSerNr");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
  end;
  if (CheckMultipleIndexField(Actr.MainPersons,10,10)==false) then begin
    RecordCheckError(2246,"",-1,"MainPersons");      
    res = -1; 
    goto LActVcRecordCheck;
  end;
  if (CheckMultipleIndexField(Actr.CCPersons,10,10)==false) then begin
    RecordCheckError(2246,"",-1,"CCPersons");      
    res = -1; 
    goto LActVcRecordCheck;
  end;
  if (CheckMultipleIndexField(Actr.Resources,10,10)==false) then begin
    RecordCheckError(2246,"",-1,"Resources");      
    res = -1; 
    goto LActVcRecordCheck;
  end;
  ActSeqr.ActType = Actr.ActType;
  ActSeqr.ActResult = Actr.ActResult;
  if (ReadFirstMain(ActSeqr,2,true)) then begin
    if (ActSeqr.RequireSerialNr!=0) then begin
      if (blank(Actr.SerialNr)) then begin
        RecordCheckError(20108,"",-1,"SerialNr");      
        res = -1; 
        goto LActVcRecordCheck;
      end;
    end;
  end;
  if (Actr.ApprovalFwdPersons!=Act2r.ApprovalFwdPersons) then begin
    if (SetInSet(CurrentUser,Actr.MainPersons)==false) then begin
      if (ActivityIsForAbsence(Actr)) then begin
        RecordCheckError(21334,"",-1,"ApprovalFwdPersons");      
        res = -1; 
        goto LActVcRecordCheck;
      end;
    end;
  end;
  if (transf) then begin
    if (Actr.TodoFlag==kTodoFlagApproval) then begin
      if (FindAcceptanceRulesAndAmountForActivity(Actr,Acptr,bc1v)) then begin  
        if (stat==Rs_update) then begin
          if (SetInSet(CurrentUser,Act2r.MainPersons)==false and Actr.MainPersons!=Act2r.MainPersons) then begin
            RecordCheckError(21331,"",-1,"MainPersons");      
            res = -1; 
            goto LActVcRecordCheck;
          end;
        end;
        if (gActVcRecordUpdateAfterf==false) then begin
          if (SetInSet(CurrentUser,Actr.MainPersons)==false) then begin
            if (Actr.ActResult!=Acptr.NotNeededActType and Actr.ActResult!=Acptr.CancelledActType and Actr.ActResult!=Acptr.ForwardedActType) then begin
              RecordCheckError(21331,"",-1,"MainPersons");      
              res = -1; 
              goto LActVcRecordCheck;
            end;
          end;
        end;
        if (nonblank(Actr.ActResult)) then begin   
          if (gActVcRecordUpdateAfterf) then begin
            if (Actr.ActResult!=Acptr.AcceptedActType) and (Actr.ActResult!=Acptr.RejectedActType) and (Actr.ActResult!=Acptr.NotNeededActType) and (Actr.ActResult!=Acptr.CancelledActType) and (Actr.ActResult!=Acptr.ForwardedActType) then begin
              RecordCheckError(21332,"",-1,"ActResult");      
              res = -1; 
              goto LActVcRecordCheck;
            end;
          end else begin
            if (Actr.ActResult!=Acptr.AcceptedActType) and (Actr.ActResult!=Acptr.RejectedActType) and (Actr.ActResult!=Acptr.CancelledActType) and (Actr.ActResult!=Acptr.ForwardedActType) then begin
              RecordCheckError(21332,"",-1,"ActResult");      
              res = -1; 
              goto LActVcRecordCheck;
            end;
          end;
        end;
        if (Actr.ActResult==Acptr.ForwardedActType and nonblank(Actr.ActResult)) then begin
          rwcnt = MatRowCnt(Acptr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(Acptr,i,Acptrw);
            if (SetInSet(Actr.MainPersons,Acptrw.AcceptanceBy)) then begin
              if (bc1v<=Acptrw.Limit) or (blank(Acptrw.Limit)) then begin //is this needed if we have MainPersons ? 
                switch (Acptrw.ApproverSelection) begin
                  case kAcceptanceApproverSelectionAutomatic:
                    RecordCheckError(21333,"",-1,"ActResult");      
                    res = -1; 
                    goto LActVcRecordCheck;
                end;
                i = rwcnt;
              end;
            end;
          end;
        end;
      end else begin
        RecordCheckError(21331,"",-1,"MainPersons");      
        res = -1; 
        goto LActVcRecordCheck;
      end;
    end;
  end;
  
  if (GenActProjTrans(Actr.ActType)) then begin
    if (CountObjects(Actr.MainPersons)>1) then begin
      RecordCheckError(1968,"",-1,"MainPersons");      
      res = -1;
      goto LActVcRecordCheck;
    end else begin
      EMr.Code = Actr.MainPersons;
      if (ReadFirstMain(EMr,1,true)) then begin      
        EGr.Code = EMr.JobGroup;
        if (ReadFirstMain(EGr,1,true)) then begin
          if (EGr.DisAllowItems!=0) then begin      
            jrwcnt = MatRowCnt(EGr);
            for (j=0;j<jrwcnt;j=j+1) begin
              MatRowGet(EGr,j,EGrw);
              if (EGrw.ArtCode==Actr.ItemCode) then begin
                goto L44;
              end;  
            end;
            RecordCheckError(1238,"",-1,"ItemCode");      
            res = -1;
            goto LActVcRecordCheck;
L44:;            
          end;
        end;
      end;  
    end;
/*
    if (nonblank(Actr.PRCode)) then begin
      if (blank(Actr.ItemCode)) then begin
        RecordCheckError(1058,"",-1,"ItemCode");      
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;
*/
  end;

  if (blank(Actr.MainPersons)) then begin
    RecordCheckError(1058,"",-1,"MainPersons");      
    res = -1;
    goto LActVcRecordCheck;
  end;
  tstr = CheckIfPRCodeAllowedForAllUsers(Actr.MainPersons,Actr.PRCode);
  if (nonblank(tstr)) then begin
    RecordCheckError(1237," " & tstr,-1,"PRCode");      
    res = -1;
    goto LActVcRecordCheck;
  end;  
  if (smalldevicesf==false) then begin
    errstr = CheckUsers(Actr.MainPersons,"",tstr,true);  
    if (errstr!=0) then begin
      RecordCheckError(errstr,tstr,-1,"MainPersons");      
      res = -1;
      goto LActVcRecordCheck;
    end;
    errstr = CheckUsers(Actr.CCPersons,"",tstr,true);  
    if (errstr!=0) then begin
      RecordCheckError(errstr,tstr,-1,"CCPersons");      
      res = -1;
      goto LActVcRecordCheck;
    end;    
  end;
  errstr = CheckResources(Actr.Resources,tstr);  
  if (errstr!=0) then begin
    RecordCheckError(errstr,tstr,-1,"Resources");      
    res = -1;
    goto LActVcRecordCheck;
  end;
  
  if (nonblank(Actr.ItemCode)) then begin
    INr.Code = Actr.ItemCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (INr.ItemType<>3) then begin
        RecordCheckError(1285,"",-1,"ItemCode");      
        res = -1;
        goto LActVcRecordCheck;
      end;
    end else begin
      RecordCheckError(1120,Actr.ItemCode,-1,"ItemCode");      
      res = -1; 
      goto LActVcRecordCheck;
    end;
    if (nonblank(Actr.PRCode)) then begin
      Qty = TimeToVal(Actr.CostTime);
/*      
      if (INr.Unittext=="DAY") then begin
        if (Qty<=4.00) then begin
          Qty = 0.50;
        end;
        if (Qty>4.00) then begin
          Qty = 1.00;
        end;
      end;
*/      
      switch (PRr.TBIVItemsUsage) begin
        case 0:
        case 1:
          if (TBIVItemsUsage(PRr,INr,Qty)) then begin
            MessageBox(20409,"");
          end;
        case 2:
          if (TBIVItemsUsage(PRr,INr,Qty)) then begin
            RecordCheckError(20409,"",-1,"PRCode");      
            res = -1;
            goto LActVcRecordCheck;
          end;
      end;
    end;
  end;
  if (blankdate(Actr.EndDate)) then begin
    Actr.EndDate = Actr.TransDate;
  end;  
  RecordNew(ATGrr);
  if (nonblank(Actr.ActType)) then begin
    ActTyper.Code = Actr.ActType;
    if (ReadFirstMain(ActTyper,1,true)) then begin
      ATGrr.Code = ActTyper.ActTypeGr;
      acttypgrf = ReadFirstMain(ATGrr,1,true);
    end else begin
      RecordCheckError(1969,"",-1,"ActType");      
      res = -1;
      goto LActVcRecordCheck;
    end;
  end else begin
    if (CRMb.NoCalActWithoutType!=0) then begin
      if (Actr.TodoFlag==0) and (Actr.CalTimeFlag==1) then begin
        RecordCheckError(1058,"",-1,"ActType");      
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;  
    acttypgrf = true;
  end;
  if ((Actr.CalTimeFlag!=0) and (Actr.TodoFlag==0)) then begin
    if (blanktime(Actr.EndTime)) then begin
      RecordCheckError(1058,"",-1,"EndTime");      
      res = -1;
      goto LActVcRecordCheck;
    end;
  end;
  if (acttypgrf) then begin
    if ((ATGrr.SelEntryforSelType==0) or (Actr.CalTimeFlag==1)) then begin    
      if (ATGrr.ForceProj!=0) then begin
        if (blank(Actr.PRCode)) then begin
          RecordCheckError(1058,"",-1,"PRCode");      
          res = -1;
          goto LActVcRecordCheck;
        end;
        if (blank(Actr.ItemCode)) then begin
          RecordCheckError(1058,"",-1,"ItemCode");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
      if (ATGrr.ForceCust!=0) then begin
        if (blank(Actr.CUCode)) then begin
          RecordCheckError(1058,"",-1,"CUCode");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
      if (ATGrr.ForceItem!=0) then begin
        if (blank(Actr.ItemCode)) then begin
          RecordCheckError(1058,"",-1,"ItemCode");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
      if (ATGrr.ForceSVO!=0) then begin
        if (Actr.SVOSerNr<=0) then begin
          RecordCheckError(1058,"",-1,"SVOSerNr");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
      if (ATGrr.ForceRes!=0) then begin
        if ((blank(Actr.ActResult)) and (Actr.OKFlag!=0)) then begin
          RecordCheckError(1058,"",-1,"ActResult");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
    end;
    if ((Actr.CalTimeFlag!=0) and (Actr.TodoFlag==0)) then begin
      if (blanktime(Actr.CostTime)) then begin
        RecordCheckError(1058,"",-1,"CostTime");      
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;
    if (Actr.TodoFlag!=kTodoFlagRecurring and Actr.TodoFlag!=kTodoFlagProject) then begin
      if (ATGrr.ForceTime!=0) or (blank(Actr.ActType)) and (Actr.TodoFlag==0) then begin
        if ((blanktime(Actr.StartTime)) and (Actr.OKFlag!=0)) then begin
          RecordCheckError(1058,"",-1,"StartTime");      
          res = -1;
          goto LActVcRecordCheck;
        end;
        if (blanktime(Actr.EndTime)) then begin
          RecordCheckError(1058,"",-1,"EndTime");      
          res = -1;
          goto LActVcRecordCheck;
        end;
        if (blanktime(Actr.CostTime)) then begin
          RecordCheckError(1058,"",-1,"CostTime");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
    end;
    if (Actr.TodoFlag==0) then begin
      NoActwithSameTime = ATGrr.NoActwithSameTime;
      if (blank(Actr.ActType)) then begin
        NoActwithSameTime = 1;
      end;
      if (CheckIfTimeRegistered(Actr,NoActwithSameTime,wherecoursor,tstr)) then begin
        if (wherecoursor==1) then begin
          RecordCheckError(1547," " & tstr & " ",-1,"StartTime");      
        end else begin
          RecordCheckError(1547," " & tstr & " ",-1,"EndTime");      
        end;
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;
  end;
  if (Actr.TodoFlag==0) then begin
    if (Actr.EndDate==Actr.TransDate) then begin
      if (ATGrr.ForceTime!=0 or (nonblanktime(Actr.StartTime) and nonblanktime(Actr.EndTime))) then begin
        if (Actr.StartTime>Actr.EndTime) then begin
          RecordCheckError(2242,"",-1,"EndTime");      
          res = -1;
          goto LActVcRecordCheck;
        end;
      end;
    end;
    if (Actr.EndDate<Actr.TransDate) then begin
      RecordCheckError(1058,"",-1,"EndDate");      
      res = -1;
      goto LActVcRecordCheck;
    end;
  end;  
  if (transf) then begin
    if (ATGrr.ForceTextInMatrix!=0) then begin
      if (MatRowCnt(Actr)==0) then begin
        RecordCheckError(1058,"",0,"Text");      
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;
    if (UserCanAction("ActOK",true)==false) then begin
      RecordCheckError(1274,StringFromStringSet(3,"ActOK"),-1,"SerNr");      
      res = -1;
      goto LActVcRecordCheck;
    end;
    errstr = TestLinkedRecordCanBeOKed(Actr);
    if (errstr!=0) then begin
      RecordCheckError(errstr,"",-1,"ActResult");      
      res = -1;
      goto LActVcRecordCheck;
    end;
  end;
  if (Actr.CalTimeFlag==kCalTimeFlagTime) then begin
  if (GenActProjTrans(Actr.ActType) and nonblank(Actr.PRCode)) then begin
    if (gentrans==false) then begin transf = false; end;// no gentrans
    if (transf) then begin
      errstr = MakeTransFromAct(gTRp,Actr,false);
    end;  
    if (errstr>0) then begin
      RecordCheckError(errstr,"",-1,"SerNr");      
      res = -1;
      goto LActVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (gTRp.IntYc==ActYc)) then begin
      tstr = CheckTrans(gTRp,2,true);
      if (nonblank(tstr)) then begin
        Actr.TRSerNr = -1;
        RecordCheckError(1085,tstr,-1,"SerNr");      
        res = -1;
        goto LActVcRecordCheck;
      end;
      SaveTrans(gTRp);
    end else begin
      if (Actr.Invalid==0) then begin
        Actr.TRSerNr = -1;
      end;
    end;
  end;  
  end;  
  if ((stat==Rs_insert) or (Actr.SerNr!=Act2r.SerNr)) then begin
    if (Actr.SerNr>0) then begin
      oldActr.SerNr = Actr.SerNr;
      if (ReadFirstMain(oldActr,1,true)) then begin
        RecordCheckError(1547,oldActr.SerNr,-1,"SerNr");
        Actr.SerNr = -1;
        res = -1;
        goto LActVcRecordCheck;
      end;
    end;
  end;  
  res = 0;
LActVcRecordCheck:;  
  if (res!=0) then begin Actr.SerNr = oldnr; end;
  ActVcRecordCheck = res;
  RETURN;
END;

global
function LongInt ActVcRecordDefaults(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  Time blankt;
  record TLSettingBlock TLSb;
  
  switch (ProgramType) begin
    case typTimeLog:   
      BlockLoad(TLSb);
      Actr.MainPersons = TLSb.UserCode;
    otherwise      
      Actr.MainPersons = CurrentUser;
  end;
  Actr.SerNr = -1;  
  Actr.TransDate = CurrentDate;
  if (Actr.TodoFlag!=kTodoFlagRecurring and Actr.TodoFlag!=kTodoFlagProject) then begin
    Actr.EndDate = CurrentDate;
    Actr.StartTime = CurrentTime;
  end;
  Actr.EndTime = blankt;
  Actr.CostTime = blankt;
  Actr.PrioLevel = -1;
  Actr.Invalid = 0;
  if (Actr.TodoFlag==kTodoFlagProject) then begin
    Actr.Supervisor = CurrentUser;
  end;
  if (SingleUserMode) then begin
//    Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
// not good, if u do 2 actiities and save 2nd one first u have problem
  end;
  if (IsStandardProduct) then begin
    Actr.CalTimeFlag = kCalTimeFlagTime;
  end;
  ActVcRecordDefaults = res; 
  RETURN;
END;

global
procedure ActVcRecordDefServer(var record ActVc Actr)
begin
  Actr.TransDate = CurrentDate;
  if (Actr.TodoFlag!=kTodoFlagRecurring and Actr.TodoFlag!=kTodoFlagProject) then begin
    Actr.EndDate = CurrentDate;
    Actr.StartTime = CurrentTime;
  end;
  return;
end;

global
procedure ActDEndActivityServer(var record ActVc Actr)
begin
  Actr.EndDate = CurrentDate;
  Actr.EndTime = CurrentTime;
  return;
end;

global
function LongInt ActVcRecordDuplicate(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  Date blankd;

  Actr.OKFlag = 0;
  Actr.SerNr = -1;
  Actr.EndDate = blankd;
  Actr.Invalid = 0;
  if (Actr.TodoFlag==kTodoFlagApproval) then begin
    Actr.TodoFlag = kTodoFlagTodo;
  end;
  if (SingleUserMode) then begin
    Actr.SerNr = NextSerNr("ActVc",Actr.TransDate,-1,false,"");
  end;
/*  
  Actr.FromFileName = "";
  Actr.FromSerNr = "";
*/  
  if (Actr.TodoFlag==kTodoFlagProject) then begin
    Actr.Supervisor = CurrentUser;
  end;
  if (DateLocked(Actr.TransDate,"ActVc")) then begin
    MessageBox(1046,"");
  end else begin
    if (DateWarned(Actr.TransDate,"ActVc")) then begin
      MessageBox(1045,"");
    end;
  end;
  
  ActVcRecordDuplicate = res; 
  RETURN;
END;

global
function LongInt ActVcRecordImport(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  Boolean testf;

  Actr.LengthClass = ActLenClass(Actr.TransDate,Actr.EndDate);
/*  
cannot find proper acttypes
  if (Actr.TodoFlag==kTodoFlagTodo) then begin
    testf = true;
    switch (Actr.FromFileName) begin
      case "POVc":
      case "PUVc":
      case "VIVc":
      case "OPVc":
      case "ExpVc":
      case "IntORVc":
      case "QTVc":
      case "ORVc":
      case "IVVc":
      case "SDVc":
      case "TBBUVc":
      case "LeaveApplicationVc":
      case "LeaveTransferVc":
      case "HMTravelLogVc":
      case "MarginExceptVc":
      otherwise
        testf = false;
    end;
    if (testf) then begin
      if (nonblank(Actr.FromSerNr)) then begin
        Actr.TodoFlag = kTodoFlagApproval;
      end;
    end;
  end;
*/  
  ActVcRecordImport = res;
  return;
end;

global
function LongInt ActVcRecordImportTest(var record ActVc Actr,record ActVc Act2r,LongInt long3,LongInt long4)
begin
  LongInt res;
  string 255 class;
  Integer pos;
  
  res = 1;
  if (CheckMultipleIndexField(Actr.MainPersons,10,10)==false) then begin
    Actr.MainPersons = "";
  end;
  if (CheckMultipleIndexField(Actr.CCPersons,10,10)==false) then begin
    Actr.CCPersons = "";
  end;
  if (CheckMultipleIndexField(Actr.Resources,10,10)==false) then begin
    Actr.Resources = "";
  end;
LActVcRecordImportTest:;
  ActVcRecordImportTest = res;
  RETURN;
END;

function Boolean TestForRemoveAct(record ActVc Actp)
BEGIN
  Boolean res;
  row ActVc Actrw;
  Integer rwcnt,i;
  string 255 tstr,t2;
  
  res = true;
  if (Actp.OKFlag!=0) then begin
    if (Actp.Invalid==0) then begin
      if (GenActProjTrans(Actp.ActType)) then begin
        res = false;
      end;
    end;
    rwcnt = MatRowCnt(Actp);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Actp,i,Actrw);
      if ((Actrw.TextCode=="CS") and (rwcnt>=i+2)) then begin
        MatRowGet(Actp,i+1,Actrw);
        if (Actrw.TextCode=="CC") then begin
          MatRowGet(Actp,i+2,Actrw);
          if (Actrw.TextCode=="KEY") then begin
            tstr = CurrentUser;
            tstr = tstr & " tried to remove activity number ";
            tstr = tstr & Actp.SerNr;
//            LogText(0,tstr);
            res = false;
          end;
        end;
      end;
    end;
  end;
  TestForRemoveAct = res;
  RETURN;
END;

global
function LongInt ActVcRecordRemoveTest(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record DBLockBlock DBLb;

  res = 1;
  BlockLoad(DBLb);
  if (Actr.OKFlag!=0) then begin
    if (nonblankdate(DBLb.DeleteBeforeDate)) then begin
      if (Actr.TransDate>DBLb.DeleteBeforeDate) then begin
        if (stat>0) then begin
          MessageBox(1560,"");
        end;
        res = 0;
        goto LActVcRecordRemoveTest;
      end;
    end else begin
      if (stat>0) then begin
        MessageBox(1560,"");
      end;
      res = 0;
      goto LActVcRecordRemoveTest;
    end;
  end;
  if (res>0) then begin
    if (TestForRemoveAct(Actr)==false) then begin
      res = 0;
    end;
  end;
LActVcRecordRemoveTest:;
  ActVcRecordRemoveTest = res;
  RETURN;
END;

global
updating function LongInt ActVcRecordRemoveAfter(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
begin
  LongInt res;

  DeleteAlarm(Actr);  
  ActVcRecordRemoveAfter = res;
  RETURN;
END;

global
updating procedure UpdateActPErs(record ActVc Actp)
BEGIN
  record PErsVc oldPErsr;
  record PErsVc PErsr;
  string 255 tstr;
  
  if (Actp.Invalid==0) and (nonblank(Actp.PRCode)) then begin  
    PErsr.Person = Actp.MainPersons;
    PErsr.Date = Actp.TransDate;
    PErsr.Item = Actp.ItemCode;
    PErsr.PRCode = Actp.PRCode;
    PErsr.TSSerNr = Actp.SerNr;
    PErsr.FileName = "ActVc";
    GetItemGroup(Actp.ItemCode,tstr);
    PErsr.INGroup = tstr;
    RecordCopy(oldPErsr,PErsr);
    if (ReadFirstMain(oldPErsr,0,true)==false) then begin
      if (RecordStore(PErsr,false)) then begin end;
    end;
  end;
  RETURN;
END;

updating procedure ActVcUpdatePRrs(record ActVc Actp)
BEGIN
  record PRrsVc PRrsr;  
  
  if (Actp.Invalid==0) then begin
    if (nonblank(Actp.PRCode)) then begin
      if (GenActProjTrans(Actp.ActType)) then begin
        PRrsr.PRCode = Actp.PRCode;
        PRrsr.Date = Actp.TransDate;
        PRrsr.RecType = 4;
        PRrsr.SerNr = Actp.SerNr;
        if (RecordStore(PRrsr,false)) then begin
        end;
      end;
    end;
  end;
  RETURN;
END;

global
updating function LongInt ActVcRecordImportAfter(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  if (Actr.OKFlag!=0) then begin
    if (Actr.CalTimeFlag==1) then begin
      if (GenActProjTrans(Actr.ActType)) then begin
        UpdateActPErs(Actr);
      end;
    end;
    ActVcUpdatePRrs(Actr);
  end;
  ActVcRecordImportAfter = res;
  RETURN;
END;

global
function LongInt ActVcRecordSave(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  Actr.LengthClass = ActLenClass(Actr.TransDate,Actr.EndDate);
  Actr.CreationDate = CurrentDate;
  Actr.LastChangedDate = CurrentDate;
  ActVcRecordSave = res;
  RETURN;
END;

global
updating function LongInt ActVcRecordSaveAfter(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  if (Actr.OKFlag!=0) then begin
    ActOK(Actr);        // Swapped to fix order of operation with approval rules.
    CreateConsequences(Actr);
//    ActOK(Actr);
  end;
  if (Actr.OKFlag==0) then begin
    CreateAlarm(Actr);  
  end;
  ActVcRecordSaveAfter = res;
  RETURN;
END;

global
updating function LongInt ActVcRecordUpdate(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  Actr.LengthClass = ActLenClass(Actr.TransDate,Actr.EndDate);
  Actr.LastChangedDate = CurrentDate;
  if (Act2r.OKFlag==0) then begin
    switch (Actr.TodoFlag) begin
      case kTodoFlagTimedTodo:
        if (blankdate(Actr.EndDate)) then begin
          Actr.EndDate = CurrentDate;
        end;
        if (blanktime(Actr.EndTime)) then begin
          Actr.EndTime = CurrentTime;
        end;
      case kTodoFlagProject:
        if (Actr.EndDate==Act2r.EndDate) then begin//when no manual amendmends
          Actr.EndDate = CurrentDate;
        end;
        if (Actr.EndTime==Act2r.EndTime) then begin//when no manual amendmends
          Actr.EndTime = CurrentTime;
        end;
    end;
  end;
  ActVcRecordUpdate = res;
  RETURN;
END;

global
updating function LongInt ActVcRecordUpdateAfter(var record ActVc Actr,record ActVc Act2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  transaction Boolean gActVcRecordUpdateAfterf;

  gActVcRecordUpdateAfterf = true;
  if ((Actr.OKFlag!=0) and (Act2r.OKFlag==0)) then begin
    ActOK(Actr);   // Swapped to fix order of operation with approval rules.
    CreateConsequences(Actr);
//    ActOK(Actr);
    DeleteAlarm(Actr);  
  end;
  if ((Actr.OKFlag==0) and (Act2r.OKFlag==0)) then begin
    if (Actr.TransDate!=Act2r.TransDate) or
       (Actr.StartTime!=Act2r.StartTime) or 
       (Actr.MainPersons!=Act2r.MainPersons) or
       (Actr.CCPersons!=Act2r.CCPersons) or
       (Actr.Comment!=Act2r.Comment) or
       (Actr.AlarmType!=Act2r.AlarmType) or
       (Actr.AlarmUnits!=Act2r.AlarmUnits) or
       (Actr.AlarmWhen!=Act2r.AlarmWhen) then begin
      UpdateAlarm(Actr);  
    end;
  end;
  if ((Act2r.Invalid==0) and (Actr.Invalid!=0)) then begin
    if (Act2r.OKFlag!=0) then begin
      InvalidateTR(ActYc,Actr.TRSerNr);
    end;
  end;
  gActVcRecordUpdateAfterf = false;
  ActVcRecordUpdateAfter = res;
  RETURN;
END;

updating function Boolean ActDeleteTBIV(record ActVc Actp)
BEGIN
  record TBIVVc TBIVr;
  Boolean res;

  TBIVr.oVc = 5;
  TBIVr.SerNr = Actp.SerNr;
  TBIVr.PRCode = Actp.PRCode;
  TBIVr.TransDate = Actp.TransDate;
  TBIVr.Row = -1;
  TBIVr.EMCode = Actp.MainPersons;
  TBIVr.ArtCode = Actp.ItemCode;
  if (ReadFirstMain(TBIVr,6,true)) then begin
    if (TBIVr.Invoice==-1) then begin
      res = true;
      RecordDelete(TBIVr);
    end;   
  end else begin
    res = true;
  end;
  ActDeleteTBIV = res;
  RETURN;
END;

updating procedure DeleteActPErs(record ActVc Actp)
BEGIN
  record PErsVc PErsr;
  
  PErsr.Person = Actp.MainPersons;
  PErsr.Date = Actp.TransDate;
  PErsr.Item = Actp.ItemCode;
  PErsr.PRCode = Actp.PRCode;
  PErsr.TSSerNr = Actp.SerNr;
  PErsr.FileName = "ActVc";
  if (ReadFirstMain(PErsr,6,true)) then begin
    RecordDelete(PErsr);
  end;
L99:;
  RETURN;
END;

updating function Boolean ActDeleteWSIV(record ActVc Actp)
BEGIN
  record WSIVVc WSIVr;
  Boolean res;

  WSIVr.RecType = 1;
  WSIVr.CUCode = Actp.CUCode;
  WSIVr.SerNr = Actp.SerNr;
  WSIVr.Row = -1;
  WSIVr.ArtCode = Actp.ItemCode;
  WSIVr.EMCode = FirstInRange(Actp.MainPersons,10);
  if (ReadFirstKey("RecType",WSIVr,6,true)) then begin
    if (WSIVr.InvNr==-1) then begin
      res = true;
      RecordDelete(WSIVr);
    end;   
  end else begin
    res = true;
  end;
  ActDeleteWSIV = res;
  RETURN;
END;

updating function Boolean InvalidActOK(record ActVc Actp,LongInt long3)
BEGIN
  Boolean res;
  record DBLockBlock DBLb;

//  if (Actp.OKFlag==0) then begin goto LInvalidActOK; end;
  res = true;
  if (nonblank(Actp.PRCode)) then begin
    if (Actp.OKFlag!=0) then begin
      if (ActDeleteTBIV(Actp)) then begin
        DeleteActPErs(Actp);
      end else begin
        MessageBox(34500,"");
        res = false;
      end;
    end;
  end;
  if (Actp.SVOSerNr>0) then begin
    if (Actp.OKFlag!=0) then begin
      if (ActDeleteWSIV(Actp)) then begin
      end else begin
        MessageBox(34500,"");
        res = false;
      end;
    end;
  end;
  BlockLoad(DBLb);
  if (Actp.OKFlag!=0) then begin
    if (Actp.TransDate<=DBLb.ActLock) then begin
      if (long3>0) then begin
        MessageBox(1560,"");
      end else begin
        MessageBox(34500,"");
      end;
      res = 0;
      goto LInvalidActOK;
    end;
    if (Actp.TransDate<=DBLb.ActWarn) then begin
      if (long3>0) then begin
        MessageBox(1560,"");
      end;
    end;
  end;
LInvalidActOK:;
  InvalidActOK = res;
  RETURN;
END;

global
updating function LongInt ActVcRecordInvalidateTest(var record ActVc Actr,record ActVc Act2r,LongInt long3,LongInt long4)
BEGIN
  LongInt res;

  res = 0;
  if (UserCanAction("ActInvalid",true)) then begin
    if (Actr.Invalid==0) then begin
      if (InvalidActOK(Actr,long3)) then begin
        Actr.Invalid = 1;
        res = 1;
      end;
    end;
  end;
LActVcRecordInvalidateTest:;
  ActVcRecordInvalidateTest = res;  
  RETURN;
END;

global
function LongInt ActVcRecordInIndex(record ActVc Actr,string indexname)
begin
  LongInt res;
  
  res = 1;
  if (Actr.OKFlag!=0) then begin 
    if (indexname=="ActComment")  then begin res = 0; end;
    if (indexname=="ActActType")  then begin res = 0; end;
    if (indexname=="ActDateTypeUserMain")  then begin res = 0; end;
    if (indexname=="ActUserMain")  then begin res = 0; end;
  end;
  ActVcRecordInIndex = res;
  return;
end;

global
function LongInt ActVcRecordProtectFields(var record ActVc Actr,record ActVc Act2r,LongInt long3,LongInt long4)
begin
  LongInt res;

  Act2r.NextApprovers = Actr.NextApprovers;
  Act2r.NextFYIPersons = Actr.NextFYIPersons;
  ActVcRecordProtectFields = res;
  return;
end;
