external procedure B1ToB2StrValRM(string,val,val,var string,roundmode);
external procedure B1ToB2ValRM(val,val,val,var val,roundmode);
external function roundmode GetCostRoundModeRB();
external function Boolean StockRecordForLocationAllowed(string,string,string,date,integer,var Integer,var string);
external function Boolean CanOKStockRecord(var Integer);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean DateWarned(Date,string);
external function Boolean IsSerialNrCorrect(string);
external updating procedure InvalidateTR(Integer,LongInt);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external updating procedure SaveTrans(record TRVc);
external function Integer MakeTransFromPU(record TRVc,record PUVc,record LocationVc,Boolean);
external updating function Boolean UpdatePOFromPU(record PUVc,record PUVc,Boolean);
external procedure ConvertToDualBase(var string,date,var val,var val,var val,var val,var val,var val,Boolean);
external updating function val NextLocOKNr(string);
external function Boolean ExistStockTrans(string,Date,var Integer,var string,string,LongInt,record MainStockBlock);
external function Integer SerialNrOnThisPU(record PUVc,string,string);
external function Boolean SerialNrAvail2(string,string,val);
external function Boolean CheckAllowedSize(record INVc,val,val,val);
external function Integer CheckPosition(string,string,Integer,val,val,val);
external function Boolean IsOffice(Boolean);
external function Integer CheckObjs(string,string,var string);
external function Boolean Date2Test(string,Date,string,Integer);
external function LongInt GetCurUserLastNr(string);
external procedure PUSumUp(var record PUVc);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure GetCurUser(var record UserVc);
external procedure SwapM4Val(var val,var val);
external procedure B1ToB2Val(val,val,val,var val);
external procedure B1ToB2StrVal(string,val,val,var string);

procedure SPLVcConvertB1ToB2(var record SPLVc PUp,string curp,val frp,var val to1p,var val to2p,var val br1p,var val br2p)
BEGIN
  row SPLVc PUrw;
  Integer rwcnt,i;
  val fr,to1,to2,br1,br2;
  string 20 curncy;
  Boolean base2inv;
  Boolean treated;
  Date curdate;
  val t;
  string 255 tstr;

  curdate = CurrentDate;
  curncy = curp;
  GetFullCurncyRate(curncy,curdate,fr,to1,to2,br1,br2);
  if (curncy==curp) then begin base2inv = true; end;
  SwapM4Val(br1p,br2p);
  SwapM4Val(to1p,to2p);
  rwcnt = MatRowCnt(PUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUp,i,PUrw);
    B1ToB2StrValRM(PUrw.Extra,br1p,br2p,tstr,GetCostRoundModeRB);
    PUrw.Extra = tstr;
    B1ToB2ValRM(PUrw.CostPrice,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.CostPrice = t;
    B1ToB2ValRM(PUrw.ShipCost,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.ShipCost = t;
    B1ToB2ValRM(PUrw.RowCost1,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.RowCost1 = t;
    B1ToB2ValRM(PUrw.RowCost2,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.RowCost2 = t;
    B1ToB2ValRM(PUrw.RowCost3,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.RowCost3 = t;
    B1ToB2ValRM(PUrw.RowCost4,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.RowCost4 = t;
    B1ToB2ValRM(PUrw.RowCost5,br1p,br2p,t,GetCostRoundModeRB);
    PUrw.RowCost5 = t;
    B1ToB2StrValRM(PUrw.CustomsCost,br1p,br2p,tstr,GetCostRoundModeRB);
    PUrw.CustomsCost = tstr;
    MatRowPut(PUp,i,PUrw);
  end;
  RETURN;
END;

function Boolean SerNrTestSPLVc(LongInt sernr,Date tdp,var Boolean gentrans)
BEGIN
  Boolean res;
  record PUSerBlock PUSerRec;
  row PUSerBlock PUSerrw;
  Integer i,rwcnt;

  gentrans = true;
  if (sernr==-1) then begin
    res = false;
    goto LSerNrTestSPLVc;
  end;
  BlockLoad(PUSerRec);
  rwcnt = MatRowCnt(PUSerRec);
  if (rwcnt==0) then begin
    res = true;
    goto LSerNrTestSPLVc;
  end;
  for (i=0; i<rwcnt ;i=i+1) begin
    MatRowGet(PUSerRec,i,PUSerrw);
    if ((sernr<PUSerrw.TSerStart) or (sernr>PUSerrw.TSerEnd)) then begin
      goto LFORSPLVc;
    end;  
    if (nonblankdate(PUSerrw.StartDate)) then begin
      if (tdp<PUSerrw.StartDate) then begin goto LFORSPLVc; end;
    end;  
    if (nonblankdate(PUSerrw.EndDate)) then begin
      if (tdp>PUSerrw.EndDate) then begin goto LFORSPLVc; end;
    end;  
    if (PUSerrw.DonotGenTrans==1) then begin gentrans = false; end;
    res = true;
    goto LSerNrTestSPLVc;
LFORSPLVc:;
  end;
LSerNrTestSPLVc:;
  SerNrTestSPLVc = res;
  RETURN;
END;

global
function LongInt SPLVcRecordDefaults(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
begin
  LongInt res;
  record UserVc Userr;
  string 10 curcode;
  val fr,to1,to2,br1,br2;
    
  PUr.SerNr = -1;  
  PUr.RegDate = CurrentDate;
  PUr.TransDate = CurrentDate;
  PUr.Invalid = 0;
  if (SingleUserMode) then begin
    PUr.SerNr = NextSerNr("SPLVc",PUr.TransDate,-1,false,"");
  end;
  PUr.PONr = -1;
  PUr.POCOSerNr = -1;
  curcode = PUr.CurncyCode;
  GetFullCurncyRate(curcode,PUr.TransDate,fr,to1,to2,br1,br2);
  PUr.CurncyCode = curcode;
  PUr.FrRate = fr;
  PUr.ToRateB1 = to1; 
  PUr.ToRateB2 = to2;
  PUr.BaseRate1 = br1;
  PUr.BaseRate2 = br2;
  PUr.Cost1 = blankval;
  PUr.Cost2 = blankval;
  PUr.Cost3 = blankval;
  PUr.Cost4 = blankval;
  PUr.Cost5 = blankval;
  PUr.SumQuant = blankval;
  PUr.ShipCost = blankval;
  PUr.CustomsCost = blankval;
  PUr.SumCostPrice = blankval;
  PUr.SubTotal = blankval;
  PUr.VATVal = blankval;
  PUr.PayVal = blankval;
  GetCurUser(Userr);
  PUr.Location = Userr.Location;
  SPLVcRecordDefaults = res; 
  RETURN;
END;

global
function LongInt SPLVcRecordDuplicate(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  row SPLVc PUrw;   
  Integer rwcnt,i;
  string 10 curcode;
  val fr,to1,to2,br1,br2;
      
  PUr.SerNr = -1;
  PUr.PONr = -1;
  PUr.OKFlag = 0;
  PUr.Invalid = 0;
  rwcnt = MatRowCnt(PUr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(PUr,i,PUrw);
    if ((PUrw.ovst!=0) or (PUrw.stp==3)) then begin
      MatRowDelete(PUr,i);
      rwcnt = MatRowCnt(PUr);
      i = i - 1;
    end else begin
      PUrw.OrdRow = -1;
      PUrw.SerialNr = "";
      MatRowPut(PUr,i,PUrw);
    end;
  end;
  if (SingleUserMode) then begin
    PUr.SerNr = NextSerNr("SPLVc",PUr.TransDate,-1,false,"");
  end;
  curcode = PUr.CurncyCode;
  GetFullCurncyRate(curcode,PUr.TransDate,fr,to1,to2,br1,br2);
  PUr.CurncyCode = curcode;
  PUr.FrRate = fr;
  PUr.ToRateB1 = to1; 
  PUr.ToRateB2 = to2;
  PUr.BaseRate1 = br1;
  PUr.BaseRate2 = br2;
  PUr.LocOKNr = blankval;
  PUSumUp(PUr); 
  SPLVcRecordDuplicate = res; 
  RETURN;
END;

global
function LongInt SPLVcRecordRemoveTest(var record SPLVc PUr,record SPLVc PU2r,LongInt long3,LongInt long4)
BEGIN
  LongInt res;
  record DBLockBlock DBLockRec;

  res = 1;
  BlockLoad(DBLockRec);
  if (PUr.TransDate<=DBLockRec.DeleteBeforeDate) then begin
    res = 1;
    goto LSPLVcRecordRemoveTest;
  end;
  if (PUr.OKFlag!=0) then begin
    if (long3>0) then begin
      MessageBox(1544,"");
    end;
    res = 0;
  end;    
LSPLVcRecordRemoveTest:;
  SPLVcRecordRemoveTest = res; 
  RETURN;
END;

global
function LongInt SPLVcRecordReset(var record SPLVc PUr,record SPLVc PU2r,LongInt long3,LongInt long4)
BEGIN
  LongInt res;
  
  PUr.OKFlag = 0;
  SPLVcRecordReset = res; 
  RETURN;
END;

global
updating function LongInt SPLVcRecordSave(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  if (PUr.OKFlag!=0) then begin
    PUr.LocOKNr = NextLocOKNr(PUr.Location);
  end;

  SPLVcRecordSave = res;
  RETURN;
END;

global
updating function LongInt SPLVcRecordSaveAfter(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  SPLVcRecordSaveAfter = res;
  RETURN;
END;

global
updating function LongInt SPLVcRecordUpdate(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  if ((PUr.OKFlag!=0) and (PU2r.OKFlag==0)) then begin
    PUr.LocOKNr = NextLocOKNr(PUr.Location);
  end;
  if ((PU2r.Invalid==0) and (PUr.Invalid!=0)) then begin
    if (PU2r.OKFlag!=0) then begin
      //InvalidateTR(PUYc,PUr.SerNr);
    end;
  end;  
  SPLVcRecordUpdate = res;
  RETURN;
END;

global
updating function LongInt SPLVcRecordRemove(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;

  SPLVcRecordRemove = res;
  RETURN;
END;

global
updating function LongInt SPLVcRecordCheck(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record SPLVc localPUr;
  record INVc INr;
  record LocationVc LocRec;
  record MainStockBlock MainStockRec;
  record SRBlock SRRec;
  row SPLVc PUrw;
  row SPLVc PU2rw;
  Integer rwcnt;
  Integer i,j;
  LongInt oldnr;
  LongInt newnr;
  Boolean transf,gentrans;
  val t;
  Integer insertmode,updatemode;
  Integer errcode;
  LongInt sernr;
  record TRVc gTRp;
  string 255 errstr;
  string 20 location;

  res = 0;
  insertmode = 1;//Rs_insert
  updatemode = 2;//Rs_update
  transf = false;
  if (PUr.OKFlag==1) then begin
    if (stat==insertmode) then begin transf = true; end;
    if (stat==updatemode) then begin
      if (PU2r.OKFlag==0) then begin transf = true; end;
    end;
  end;
  BlockLoad(SRRec);
  BlockLoad(MainStockRec);
  oldnr = PUr.SerNr;
  if (PUr.SerNr<=0) then begin
    PUr.SerNr = NextSerNr("SPLVc",PUr.TransDate,-1,false,"");
  end;
  
  if ((stat==insertmode) or (PUr.SerNr!=PU2r.SerNr)) then begin
    localPUr.SerNr = PUr.SerNr;
    if (ReadFirstMAin(localPUr,1,true)) then begin
      RecordCheckError(1547,"",-1,"SerNr");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
  end;
  if (SerNrTestSPLVc(PUr.SerNr,PUr.TransDate,gentrans)==false) then begin
    RecordCheckError(1557,"",-1,"SerNr");      
    res = -1;
    goto L99SPLVcRecordCheck;
  end;
  if (Date2Test("SPLVc",PUr.TransDate,"TransDate",-1)==false) then begin
    res = -1;
    goto L99SPLVcRecordCheck;
  end;
  if (transf) then begin
    if (UserCanAction("PUOK",true)==false) then begin
      RecordCheckError(1274,StringFromStringSet(3,"PUOK"),-1,"SerNr");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
  end;  
  if (blank(PUr.Location)) then begin
    if (MainStockRec.requireLocation!=0) then begin
      RecordCheckError(1058,PUr.Location,-1,"Location");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
  end;
  location = PUr.Location;
  if (blank(location)) then begin
    location = MainStockRec.MainStock;
  end;  
  if (nonblank(location)) then begin
    LocRec.Code = location;
    if (ReadFirstMain(LocRec,1,true)==false) then begin
      RecordCheckError(1120,PUr.Location,-1,"Location");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
  end;
  if (nonblank(PUr.Objects)) then begin     
    errcode = CheckObjs("",PUr.Objects,errstr);
    if (errcode!=0) then begin
      RecordCheckError(errcode,errstr,-1,"Objects");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
  end;    
  rwcnt = MatRowCnt(PUr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PUr,i,PUrw);
  if (PUrw.stp==1) then begin
    if (IsOffice(false)) then begin
      if (PUrw.Quant<0) then begin
        RecordCheckError(1574,"",i,"Quant");      
        res = -1;
        goto L99SPLVcRecordCheck;
      end;
    end;
    if (blank(PUrw.ArtCode)) then begin
      RecordCheckError(1130,"",i,"ArtCode");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if (ReadFirstItem(PUrw.ArtCode,INr,true,true)==false) then begin
      RecordCheckError(1120,"",i,"ArtCode");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if ((HasLocalization("EST")) or (HasLocalization("POL"))) then begin//vatEstonian,vatPolish
      if (INr.ItemType!=1) then begin
        RecordCheckError(1301,"",i,"ArtCode");      
        res = -1;
        goto L99SPLVcRecordCheck;
      end;
    end;
    if (CheckAllowedSize(INr,PUrw.UnitXval,PUrw.UnitYval,PUrw.UnitZval)==false) then begin
      RecordCheckError(1480,"",i,"UnitXval");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if (nonblank(PUrw.Objects)) then begin 
      errcode = CheckObjs("",PUrw.Objects,errstr);
      if (errcode!=0) then begin
        RecordCheckError(errcode,errstr,i,"Objects");      
        res = -1;
        goto L99SPLVcRecordCheck;
      end;
    end;
    if (blank(PUrw.Quant)) then begin
      RecordCheckError(1058,"",i,"Quant");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if (INr.ItemType==2) then begin
      RecordCheckError(1826,"",i,"ArtCode");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    errcode = CheckPosition(PUrw.PosCode,location,LocRec.RequirePos,INr.Width*PUrw.Quant,INr.Height*PUrw.Quant,INr.Depth*PUrw.Quant);
    if (errcode!=0) then begin
      RecordCheckError(errcode,PUrw.PosCode,i,"PosCode");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;    
    if (nonblank(LocRec.Code)) then begin
      if (LocRec.RequirePos!=0) then begin
        if (blank(PUrw.PosCode)) then begin
          RecordCheckError(1854,"",i,"PosCode");      
          res = -1;
          goto L99SPLVcRecordCheck;
        end;
      end;
    end;
    if (StockRecordForLocationAllowed("SPLVc",location,PUrw.ArtCode,PUr.TransDate,PUr.OKFlag,errcode,errstr)==false) then begin
      RecordCheckError(errcode,errstr,i,"ArtCode");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if (transf) then begin
      if (((INr.SerNrf>0) and (INr.SerNrf<3)) and (MainStockRec.NoSerOnPU==0)) then begin
        if (PUrw.Quant!=0) then begin
          if (blank(PUrw.SerialNr)) then begin
            RecordCheckError(1239,"",i,"SerialNr");      
            res = -1;
            goto L99SPLVcRecordCheck;
          end;
        end;
        if (Mid(PUrw.SerialNr,len(PUrw.SerialNr),1)==" ") then begin
          RecordCheckError(1239,"",i,"SerialNr");      
          res = -1;
          goto L99SPLVcRecordCheck;
        end;
        if (IsSerialNrCorrect(PUrw.SerialNr)==false) then begin
          RecordCheckError(24154,PUrw.SerialNr,i,"SerialNr");      
          res = -1; 
          goto L99SPLVcRecordCheck;
        end;        
        switch (INr.SerNrf) begin
          case 1:  // serial nr. 
            // is the serial number available at any location 
            for (j=0;j<i;j=j+1) begin              
              MatRowGet(PUr,j,PU2rw);
              if ((PUrw.ArtCode==PU2rw.ArtCode) and
                  (PUrw.SerialNr==PU2rw.SerialNr)) then begin
                RecordCheckError(1241,"",i,"SerialNr");
                res = -1;
                goto L99SPLVcRecordCheck;
              end;
            end;
            if (SerialNrAvail2(PUrw.ArtCode,PUrw.SerialNr,PUrw.Quant)==true) then begin
              RecordCheckError(1241,"",i,"SerialNr");
              res = -1;
              goto L99SPLVcRecordCheck;
            end;
            if (PUrw.Quant>1) then begin
              RecordCheckError(1242,"",i,"Quant");
              res = -1;
              goto L99SPLVcRecordCheck;
            end;
            if (SerialNrOnThisPU(PUr,PUrw.ArtCode,PUrw.SerialNr)>1) then begin
              RecordCheckError(1242,"",i,"Quant");
              res = -1;
              goto L99SPLVcRecordCheck;
            end;
          case 2:  ;// batch nr.
            for (j=0;j<i;j=j+1) begin
              MatRowGet(PUr,j,PU2rw);
              if ((PUrw.ArtCode==PU2rw.ArtCode) and
                  (PUrw.SerialNr==PU2rw.SerialNr)) then begin
                RecordCheckError(1242,"",i,"SerialNr");      
                res = -1;
                goto L99SPLVcRecordCheck;
              end;
            end;          
        end;
      end;
    end;
  end;
  end;
  if (DateWarned(PUr.TransDate,"SPLVc")) then begin
    MessageBox(1045,"");
  end;    
  if (transf) then begin
    if (stat==updatemode) then begin
      sernr = PU2r.SerNr;
    end;
    if (long4>0) then begin
      if (MainStockRec.Chronology!=0) then begin
        if (ExistStockTrans(location,PUr.TransDate,errcode,errstr,"SPLVc",sernr,MainStockRec)==true) then begin
          RecordCheckError(errcode,errstr,-1,"TransDate");      
          res = -1;
          goto L99SPLVcRecordCheck;
        end;
      end;
    end;
    if (CanOKStockRecord(errcode)==false) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1; 
      goto L99SPLVcRecordCheck;
    end;
  end;
  if (gentrans==false) then begin transf = false; end;
  if (transf) then begin
    errcode = MakeTransFromPU(gTRp,PUr,LocRec,false);
    if (errcode>0) then begin
      RecordCheckError(errcode,"",-1,"SerNr");      
      res = -1;
      goto L99SPLVcRecordCheck;
    end;
    if ((gTRp.Number>0) and (gTRp.IntYc==PUYc)) then begin
      errstr = CheckTrans(gTRp,2,true);
      if (nonblank(errstr)) then begin
        RecordCheckError(1085,errstr,-1,"SerNr");      
        res = -1;
        goto L99SPLVcRecordCheck;
      end;
      SaveTrans(gTRp);
    end;    
  end;  
L99SPLVcRecordCheck:;
  if (res!=0) then begin PUr.SerNr = oldnr; end;
  SPLVcRecordCheck = res;
  RETURN;
END;
  
global
function LongInt SPLVcRecordImport(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
  record ConvMasterBlock cvm;
  Boolean gToDualBase,gBase1ToBase2;
  val fr,to1,to2,br1,br2,t;
  string 10 curncy;

  BlockLoad(cvm);
  if (cvm.DualBaseCurrencyFlag!=0) then begin gToDualBase = true; end;
  if (cvm.Base1ToBase2Flag!=0) then begin gBase1ToBase2 = true; end;
  if (gToDualBase) then begin
    curncy = PUr.CurncyCode;
    fr = PUr.FrRate;
    to1 = PUr.ToRateB1;
    to2 = PUr.ToRateB2;
    br1 = PUr.BaseRate1;
    br2 = PUr.BaseRate2;
    ConvertToDualBase(curncy,PUr.TransDate,fr,to1,to2,br1,br2,t,false);
    PUr.CurncyCode = curncy;
    PUr.FrRate = fr;
    PUr.ToRateB1 = to1;
    PUr.ToRateB2 = to2;
    PUr.BaseRate1 = br1;
    PUr.BaseRate2 = br2;
  end;
  if (gBase1ToBase2) then begin
    to1 = PUr.ToRateB1;
    to2 = PUr.ToRateB2;
    br1 = PUr.BaseRate1;
    br2 = PUr.BaseRate2;
    SPLVcConvertB1ToB2(PUr,PUr.CurncyCode,PUr.FrRate,to1,to2,br1,br2);
    PUr.ToRateB1 = to1;
    PUr.ToRateB2 = to2;
    PUr.BaseRate1 = br1;
    PUr.BaseRate2 = br2;
    PUSumUp(PUr);
  end;
  SPLVcRecordImport = res;
  RETURN;
END;

global
updating function LongInt SPLVcRecordImportAfter(var record SPLVc PUr,record SPLVc PU2r,LongInt stat,LongInt long4)
BEGIN
  LongInt res;
    
  SPLVcRecordImportAfter = res; 
  RETURN;
END;
