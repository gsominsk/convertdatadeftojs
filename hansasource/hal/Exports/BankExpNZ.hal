/**********************************************************************
/* Name        : BankExpNZ.hal 
/* Created     : 14/06/2010
/* Author      : EDS
/*
/* Description : HAL unit containing routines to aid / export purchase ledgers payments to New Zealand Bank files
/*
/* BANKS SUPPORTED : ANZ, ASB, BNZ, KIWI, NATIONAL AND WESTPAC
/*
/* Notes       : RcVc.sm1       - Is used to store which bankid field is used. 
/*                                Can be Banktransfer.Bank or PaymentMode.Bank 
/*               RcVc.em1       - Is used to store bankid to compare to.    
/*               RcVc.long1     - Is used to created seq numbers
/*               RcVc.long2     - Is used to count payment lines exported
/*               RcVc.vals4     - Is used to add up payment lines exported
/*               RcVc.f11       - is used to hold CompanyName Bank Account
/*               RcVc.f12       - CompanyName
/*               PMBlock.BankNr - Company Bank Account
/*               BankVc.Sorting - Company Bank User ID
/*               RcVc.flag29    - Used to control if oayments are exported 
/* 
/* EXTERNAL NOTES :
/*
/* Most if not all banks talk about having CRLF to seperate each line in file. Hansaworld i believe will only do that on windows machine,  
/* Kiwibank files should have extension .KBB. ( < 3000 records)
/* BNZ file names can only be of lenght 8 and extension should be AFI
/* national bank bank accounts are in format 2-4-8-3 whereas others are 2-4-7-2(3)
/*
/* New Zealand Bank account validation information (Curently not implemented)
/* ===============================================
/* 
/* NZ Bank & Branch Ranges 
/* ========================
/* The table below lists the valid bank-branch combinations, by combining this with the check digit, it is possible to validate the Bank-Branch-
/* Account Number entirely. Branches are allocated in blocks of 50 by the New Zealand Bankers Association (NZBA). 
/* 
/* ANZ National Bank Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 01    0001 Ð 0999 
/*       1100 Ð 1199 
         1800 Ð 1899 
/* 06    0001 Ð 0999 
/*       1400 Ð 1499 
/* 11    5000 Ð 5149 
/*       5200 Ð 5949 
/*       6000 Ð 6049 
/*       6100 Ð 6249 
/*       6300 Ð 6349 
/*       6400 Ð 6499 
/*       6600 Ð 6699 
/*      6800 Ð 7049 
/*       7100 Ð 7149 
/*       7200 Ð 7349 
/*       7400 Ð 7549 
/*       7600 Ð 7749 
/*       7800 Ð 8049 
/*       8100 Ð 8149 
/*       8200 Ð 8249 
/*       8300 Ð 8449 
/*       8500 Ð 8599 
/*       8750 Ð 8799 
/*       8950 Ð 8999 
/* 25    2400 Ð 2599 

/* ASB Bank Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 12    3000 Ð 3299 
/*       3400 Ð 3499 
/*       3600 Ð 3699 
/*       3850 Ð 3899 
/* 
/* Bank of New Zealand Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 02    0001 Ð 0999 
/*       1200 Ð 1299 
/* 
/* Citibank NA 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 31    2800 Ð 2849 
/* 
/* Kiwibank Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 38    9000 Ð 9499 
/* 
/* The Hong Kong & Shanghai Banking Corporation 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 30    2900 Ð 2999 
/* 
/* TSB Bank Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 15    3900 Ð 3999 
/* 
/* Westpac New Zealand Limited 
/* 
/* BANK# BRANCH RANGE  
/* ==================
/* 03    0001 Ð 0999 
/*       1300 Ð 1399 
/*       1500 Ð 1599 
/*       1700 Ð 1799 
/* 13    4900 Ð 4999 
/* 14    4700 Ð 4799 
/* 16    4400 Ð 4499 
/* 17    3300 Ð 3399 
/* 18    3500 Ð 3599 
/* 19    4600 Ð 4649 
/* 20    4100 Ð 4199 
/* 21    4800 Ð 4899 
/* 22    4000 Ð 4099 
/* 23    3700 Ð 3799 
/* 24    4300 Ð 4349 
/* 27    3800 Ð 3849 
/* 
/* NZ BANK ACCOUNT VALIDATION
/* ==========================
/* Check Digit Calculation for All Banks (Except 25)
/* 
/* The check digit is calculated differently for customer accounts and general ledger accounts. Customer accounts can be identified with an account number below 0990000.
/*
/* Customer account check digits are performed over the four digits of the branch number and the low order six digits of the account number. 
/* The high order account digit and the two/three digit suffix are ignored. The weightings for the calculations are (from left to right, branch first): 
/* 6,3,7,9,10,5,8,4,2,1. These products are added together and the sums divided by 11, if the remainder is zero the account check digits
/* 
/* For example Ð is account 02-0902-0068389-000 a valid account?
/* 
/* A) Acc # digits as is     : 02-0902-0068389-000 
/* B) Acc # digits validated :    0902  068389
/* C) x Weighting                 6379  158421      
/*                                      0
/* Sum of (BxC)              : 176  
/* Is valid                  : 176 / 11 = 16 Remainder = 0 = Valid Account number                                          
/* 
/* Check Digit Calculation for General Ledger Accounts
/* 
/* General Ledger accounts have a check digit over the low order six digits of the account number only.
/* The weightings for the calculations are (from left to right): 10,5,8,4,2,1. These products are added together and the sum divided by 11.
/* If the remainder is zero the account check digits.
/*
/* Check Digit Calculation For Bank 25
/* 
/* These accounts have a check digit over the seven digits of the account number only. 
/* The weightings for the calculations are (from left to right): 1,7,3,1,7,3,1. These products are added together and the sum divided by 11. If the remainder is zero the account check digits.
/*
/* Credit Card Number Validation
/*
/* The LUHN formula (also known as Mod 10) is a simple algorithm used to validate the number on a credit card. 
/* All the major credit card companies, including American Express, Diners Club, MasterCard and Visa, use this algorithm.
/* The weightings for the calculations are (from left to right): 2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1. 
/* The products are added together (which includes any addition for products that are greater than 9) and the sum is divided by 10. 
/* If the remainder is zero the card check digits.
/*
/***********************************************************************/

external procedure NewLineExport();
external function Boolean IsDigit(string);
external function Boolean GetPMRow(string,var row PMBlock);

function boolean IntToBoolean (Integer anInt)
begin
  boolean res;

  res = False;
  if (anInt == 1) then
  begin
    res = True;
  end;

  IntToBoolean = res;
  return;
end;

global
function boolean IsNewZealandBank(integer BankID)
begin
  IsNewZealandBank = ((BankID >= 120) and (BankID <= 125));
  return;
end;

function Integer CheckIfSupplierPaidinArray(string vecode,string sortcode,string sortcoderow,string bankacc,string bankaccrow,string invoicenr,val recval,string comment,
	                                array string avecode,array string avesortcode,array string avesortcoderow,array string avebankacc,
	                                array string avebankaccrow,array string aveinvoicenr,array val averecval,array string avecomment,Integer acnt)
begin
  Integer res;
  Integer i;
  Boolean testf
  
  res = -1;
  for (i=0;i<acnt;i=i+1) begin
    testf = true;
    if ((vecode!=avecode[i]) or (sortcode!=avesortcode[i]) or (sortcoderow!=avesortcoderow[i]) or (bankacc!=avebankacc[i]) or (bankaccrow!=avebankaccrow[i])) then begin
      testf = false;
    end;
    if (testf) then begin
      res = i;
      goto LCheckIfSupplierPaidinArray;
    end;
  end;

LCheckIfSupplierPaidinArray:;  
  CheckIfSupplierPaidinArray = res;

  return;
end;

procedure AddToSupplierPaidArray(string vecode,string vename,string sortcode,string sortcoderow,string bankacc,string bankaccrow,string invoicenr,val recval,string comment, string aref,
	                     array string avecode,array string avename,array string avesortcode,array string avesortcoderow,array string avebankacc,
	                     array string avebankaccrow,array string aveinvoicenr,array val averecval,array string avecomment,array string ref,var Integer acnt)
begin
  avecode[acnt] = vecode;
  avename[acnt] = vename;
  avesortcode[acnt] = sortcode;
  avesortcoderow[acnt] = sortcoderow;
  avebankacc[acnt] = bankacc;
  avebankaccrow[acnt] = bankaccrow;
  aveinvoicenr[acnt] = invoicenr;
  averecval[acnt] = recval;
  avecomment[acnt] = Comment;
  ref[acnt] = aref;
  acnt = acnt + 1;
  return;
end;

function string 1 _DBLQUOTE ()
begin
  _DBLQUOTE = chr(34);
  return
end;

function string 2 _CRLF ()
begin
  _CRLF = chr(13) & chr(10);
  return
end;

function string 2 _NONCSVCHARS ()
begin
  _NONCSVCHARS = _DBLQUOTE & ",";
  return
end;

function string 1 _COMMA ()
begin
  _COMMA = ",";
  return
end;

function string 255 PadString (string istring ,string padchar, integer length, boolean RightJustified)
begin
  string 255 res;
  integer x, ln;
  
  res = Trim(istring);
  ln = len(res);

  if (len(res) < length) then begin
    if (RightJustified == true) then begin
      for (x=1;x<=ln;x=x+1) begin
        res = padchar & res;
      end; 
    end
    else begin
      for (x=1;x<=ln;x=x+1) begin
        res = res & padchar;
      end; 
    end; 
  end;
 
  PadString = res;
  return;
end;


function Integer GetBankSubscriberID (record OPVc OPr, var String SubscriberID)
begin
  integer res; 
  row PMBlock PMrw;
  record BankVc Bankr;
 
  res = 0; 
  SubscriberID = "";
  
  GetPMRow(OPr.PayMode,PMrw);
  Bankr.Code = PMrw.BankCode;
  ReadFirstMain(Bankr,1,true);
  
  SubscriberID = Bankr.Sorting;

  GetBankSubscriberID = res;
  return;
end;

function Integer GetBankAccNumber(record OPVc OPr, var String BankAccNumber)
begin
  integer res; 
  row PMBlock PMrw;
  record BankVc Bankr;
 
  res = 0; 
  BankAccNumber = "";
  
  GetPMRow(OPr.PayMode,PMrw);
  BankAccNumber = PMrw.BankNr; 

  GetBankAccNumber = res;
  return;
end;

function string 255 StripCharactersFromString(string istring,string CharsToRemove)
begin
  LongInt i, j;
  string 255 res;
  boolean FoundInvalidChar;
  
  res = istring;
  if nonblank (CharsToRemove) then begin
    res = "";
    for (i=0;i<=len(istring);i=i+1) begin
      FoundInvalidChar = false; 
      for (j=0;j<=len(CharsToRemove);j=j+1) begin
         if (Mid(istring,i,1) == Mid(CharsToRemove,j,1)) then begin
           FoundInvalidChar =  true;
         end; 
      end;
      if (FoundInvalidChar != true) then begin  
        res = res &  Mid(istring,i,1);
      end;
    end; 
  end;
    
  StripCharactersFromString = res;
  return;
end;

function string 255 StringtoCSVString (string aString,string CSVCharsToRemove)
begin
  string 255 res;

  if blank (CSVCharsToRemove) then begin
    res = StripCharactersFromString (aString,_NONCSVCHARS);
  end
  else begin
    res = StripCharactersFromString (aString,CSVCharsToRemove);
  end;

  StringtoCSVString = res; 
  return;
end;

function boolean IsStringNumeric(string s)
begin
  integer i;
  boolean res;
  
  res = true;
  for (i=0;i<len(s);i=i+1) begin
    if (IsDigit(mid(s,i,1))==false) then begin
      res = false;
      i = len(s)+1;
    end;
  end;
  
  IsStringNumeric = res;
  return;
end;

function boolean CheckNoteforSettings(record NotepadVc Noter,string argumentstr)
begin
  Integer i,rwcnt;
  string 255 tstr;
  boolean res;

  res = false;
  rwcnt = LineTextCnt(Noter);
  for (i=0;i<rwcnt;i=i+1) begin
    tstr = LineTextGet(Noter,i);
    if (tstr == argumentstr) then begin
      res = true;
      goto LExitCheck;
    end; 
  end;  

LExitCheck:;  
  CheckNoteforSettings = res;
  return;
end;

procedure ExportStringEx (string StringToExport, integer MaxLength, string PadCharacter, boolean RightAlligned, boolean PaddedExport, string Delimiter, string CharsToRemove)
begin
  string  255 LStringtoExport;
  integer LMaxLength, lCurLength;

  LMaxLength = MaxLength;
  LStringtoExport = Trim (StripCharactersFromString (StringToExport,CharsToRemove));
  LCurLength = Len(LStringtoExport);
 
  if LCurLength >= LMaxLength then begin
    LStringtoExport = left (LStringtoExport,LMaxLength);
  end
  else begin
    if PaddedExport == false then begin
      LMaxLength = LCurLength; 
    end;
  end;
   
  ExportPadString (LStringtoExport,LMaxLength,PadCharacter,RightAlligned); 
  if nonblank (Delimiter) then begin
    ExportPadString (Delimiter,1,"",false); 
  end;

  return;
end;

procedure ExportFixedLengthString (string StringToExport, integer MaxLength, string PadCharacter, boolean RightAlligned, string CharsToRemove)
begin
  ExportStringEx (StringToExport, MaxLength,PadCharacter,RightAlligned,true,"",CharsToRemove);
  return;
end;

procedure ExportDelimitedString (string StringToExport, integer MaxLength, string PadCharacter, boolean RightAlligned, string Delimiter, string CharsToRemove)
begin
  ExportStringEx (StringToExport, MaxLength,PadCharacter,RightAlligned,false,Delimiter,CharsToRemove);
  return;
end;

function boolean ParseNewZealandBankAccounts (record RcVc RepSpec, string InBankAccStr, var string BankID, var string BankBranch, var string BankAccount, var string BankSuffix)
begin
  string 255 lBankAccString;
  boolean res;
  integer strlen;
  
  res = true;
  BankID = "";
  BankBranch = "";
  BankAccount = "";
  BankSuffix = "";

  lBankAccString = StripCharactersFromString(InBankAccStr," :-/");  
  strlen = len(lBankAccString);

  switch (strlen) begin  
    case 15 : 
      switch (RepSpec.em1) begin  
        case 124 :  // national bank
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,7);
          BankSuffix = "**";
        otherwise 
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,7);
          BankSuffix = Mid(lBankAccString,13,len(lBankAccString)-13);
      end;
    case 16 : 
      switch (RepSpec.em1) begin  
        case 124 :  // national bank
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,7);
          BankSuffix = "**";
        otherwise 
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,7);
          BankSuffix = Mid(lBankAccString,13,len(lBankAccString)-13);
      end;
    case 17 : 
      switch (RepSpec.em1) begin  
        case 124 :  // national bank
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,8);
          BankSuffix = Mid(lBankAccString,14,len(lBankAccString)-14);
        otherwise 
          BankID = Mid(lBankAccString,0,2);
          BankBranch = Mid(lBankAccString,2,4);
          BankAccount = Mid(lBankAccString,6,7);
          //BankSuffix = Mid(lBankAccString,13,len(lBankAccString)-13);
          BankSuffix = "**";
      end;
    otherwise  
      BankID = Mid(lBankAccString,0,2);
      BankBranch = Mid(lBankAccString,2,4);
      BankAccount = Mid(lBankAccString,6,7);
      //BankSuffix = Mid(lBankAccString,13,len(lBankAccString)-13);
      BankSuffix = "**";
  end;
 
  switch (RepSpec.em1) begin  
    case 124 :  // national bank
      BankAccount =  PadString(BankAccount,"0",8,true);
      BankSuffix =  PadString(BankSuffix,"0",3,true);
  end;

  ParseNewZealandBankAccounts = res; 
  return;
end; 

global
procedure CheckNewZealandBankSettings(record BankFileBlock bfr,record RcVc RepSpec)
begin
  record NotepadVc Noter;
  record RLinkVc RLr;
  record BankVc Bankr;
  Integer notenr;
  boolean foundf;

  notenr = 1;
  RepSpec.UsedOnly = 1;
 
  foundf = true;
  while LoopMain(Bankr,1,foundf) begin
    if (Bankr.Bank == bfr.Bank) then begin
      while (ReadRecordLink(Bankr,notenr,Noter,RLr)) begin
        if (RLr.Comment=="SETTINGS") then begin
          if (CheckNoteforSettings (Noter,"STRICTBANKACCOUNTS=FALSE") == true) then begin
            RepSpec.UsedOnly = 0;
          end;   
          goto LExitNote;
        end;
        notenr = notenr + 1;
      end;
      goto LExitNote;
    end;
  end;

LExitNote:;  
  return;
end;

global function boolean IncludePaymentInNewZealandBankFile(record BankFileBlock bfr, record RcVc RepSpec, record OPVc Opr, boolean IsWrittenToFileYet)
begin
  boolean res;
  row PMBlock PMrw;
  record BankVc Bankr, Bankr2;
  record CYBlock CompYear;
  string 255 BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;

  res = false;
 
  if (RepSpec.sm1 == 0) then begin  
    // BankIDMode is not determined yet so work it out  
    RepSpec.sm1 = 1; // BankIDMode = use Bank Transfer Block Bankid 
    RepSpec.em1 = bfr.Bank; // Compare all payments to banktransfer.bank
    GetPMRow(OPr.PayMode,PMrw);
    if nonblank (PMrw.BankCode) then begin
      Bankr.Code = PMrw.BankCode;
      if (ReadFirstMain(Bankr,1,true) == true) then begin
        RepSpec.sm1 = 2; // BankIDMode = use Bankid on paymentmode.Bank
        RepSpec.em1 = Bankr.Bank; // Compare all payments to paymentmode.Bank
      end;  
    end;
  end;
 
 // Now that bankingmode is initialized determine if this paymnt should be exported 
  if ((RepSpec.sm1 >= 1) and (RepSpec.sm1 <= 2)) then begin 
    if (RepSpec.sm1 == 1) then begin
      res = true; // In mode 1 all payments with blank / invalid PaymentMode.Bankcode are included    
    end;
    GetPMRow(OPr.PayMode,PMrw);
    if nonblank (PMrw.BankCode) then begin
      Bankr2.Code = PMrw.BankCode;
      if (ReadFirstMain(Bankr2,1,true) == true) then begin
        res = Bankr2.Bank == RepSpec.em1;
      end;  
    end;
  end; 
  
  if ((res == true) and (IsWrittenToFileYet == false)) then begin
    // Nothing Written yet but about to write a payment so initialize
    RepSpec.long2 = 0;
    RepSpec.vals4 = 0;
  
    BlockLoad(CompYear);
    RepSpec.long1 = RepSpec.long1 + 1;
    RepSpec.f12 = StringtoCSVString (CompYear.CompName,"");
    GetBankAccNumber (OPr,RepSpec.f11);
 
    res =  ParseNewZealandBankAccounts (RepSpec,RepSpec.f11,BankID,BankBranch,BankAccount,BankSuffix);
    RepSpec.f11 = BankID & BankBranch & BankAccount & BankSuffix;
    
    if (res == false) then begin
      LogText(0,"Invalid company bank account format");
    end;
  end;
  
  IncludePaymentInNewZealandBankFile = res;
  return;
end;

procedure NewZealandBankVal(var string tstr,val vp, boolean valincents)
begin
  val nv;
  
  nv = vp;
  if (valincents == true) then begin
    nv = vp*100;
    tstr = ValToString(nv,M4Val,"","",0);
    tstr = Left(tstr,len(tstr)-2);
  end
  else begin
    tstr = ValToString(nv,M4Val,"",".",0);
  end; 
  return;
end;

function string 255 NewZealandHashString(record RcVc RepSpec)
begin
  string 255 res;

  res = ValToString(RepSpec.vals1,M4Val,"","",1); 
  res = Left(res,len(res)-2);
  res = Right(PadString (res,'0',11,true),11);
 
  NewZealandHashString = res;
  return;
end;

function Date PaymentDueDate(Date inDate, record RcVc RepSpec) 
begin
  Date res;
  
  res = CurrentDate;
  if IntToBoolean(RepSpec.flags[0]) then begin
    if (inDate>CurrentDate) then begin
      res = Indate;
    end;
  end;

  PaymentDueDate = res;
  return;
end;

function string 255 PayeeReference (string sortcode, string ref)
begin
  string 255 res;
  
  res = sortcode;
  if blank (res) then begin
    res = ref;
  end;
  
  PayeeReference = res;
  return;
end;

function string 255 PayerReference (string sortcode, string ref)
begin
  string 255 res;
  
  res = sortcode;
  if blank (res) then begin
    res = ref;
  end;
  
  PayerReference = res;
  return;
end;

// ANZ Format
procedure BankExpNewZealandANZHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  string 255 SubscriberID;
  
  GetBankSubscriberID (OPr,SubscriberID);
  if (IsStringNumeric(SubscriberID) == false) then begin
    SubscriberID = ""; 
  end;

  ExportDelimitedString("1",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString(SubscriberID,16,"",false,_COMMA,_NONCSVCHARS);  // Subscriber ID 
  ExportDelimitedString("",1,"",false,_COMMA,_NONCSVCHARS);   // Batch Number
  ExportDelimitedString("",1,"",false,_COMMA,_NONCSVCHARS);   // Null 
  ExportDelimitedString("",1,"",false,_COMMA,_NONCSVCHARS);  // Subscriber Acc No
  ExportDelimitedString("",1,"",false,_COMMA,_NONCSVCHARS);   // BatchType
  ExportDelimitedString(DateToString(PaymentDueDate(OPr.PayDate,RepSpec),"YYYYMMDD"),8,"",false,_COMMA,_NONCSVCHARS); // Due Date *
  ExportDelimitedString(DateToString(CurrentDate,"YYYYMMDD"),8,"",false,"",_NONCSVCHARS); // Creation Date *
  NewLineExport;
  
  return;
end;

function string 255 BankExpNewZealandANZPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin
  string 255 valstr;
  string 255 invoicestr;
  string 255 BankID, BankAccount, BankBranch, BankSuffix;
  
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix);
  invoicestr = StringtoCSVString(invoicenr,"");

  ExportDelimitedString("2",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString(BankID & BankBranch & BankAccount & BankSuffix,16,"",false,_COMMA,_NONCSVCHARS); // Supplier Acc Number *
  ExportDelimitedString("50",2,"",false,_COMMA,_NONCSVCHARS); // Transaction Code * : 50 = Credit , 00 = Debit
  NewZealandBankVal(valstr, recval, true);
  ExportDelimitedString(valstr,11,"",false,_COMMA,_NONCSVCHARS & "$.");    // Amount * 
  ExportDelimitedString(vename,20,"",false,_COMMA,_NONCSVCHARS);  // Other Party Name *
  ExportDelimitedString(PayeeReference(sortcode,ref),12,"",false,_COMMA,_NONCSVCHARS); // Other Party Reference
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS); // Other Party Analysis
  ExportDelimitedString("",12,"",false,_COMMA,_NONCSVCHARS);        // Other Party Alpha
  ExportDelimitedString(comment,12,"",false,_COMMA,_NONCSVCHARS);  // Other Party Particulars
  ExportDelimitedString(RepSpec.f12,20,"",false,_COMMA,_NONCSVCHARS);  // Company Name
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS);  // Analysis
  ExportDelimitedString(PayerReference(sortcoderow,ref),12,"",false,_COMMA,_NONCSVCHARS);  // Reference
  ExportDelimitedString(comment,12,"",false,"",_NONCSVCHARS);  // Particulars
  NewLineExport;
 
  BankExpNewZealandANZPaymentLine =  BankBranch & BankAccount;
  return;
end;

procedure BankExpNewZealandANZSummaryLine(record RcVc RepSpec)
begin
  string 255 valstr;

  ExportDelimitedString("3",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  NewZealandBankVal(valstr, RepSpec.vals4,true);
  ExportDelimitedString(valstr,11,"",false,_COMMA,_NONCSVCHARS); // Total * 
  ExportDelimitedString(RepSpec.long2,5,"",false,_COMMA,_NONCSVCHARS); // # of payment lines * 
  ExportDelimitedString(NewZealandHashString(RepSpec),11,"",false,"",_NONCSVCHARS); // hash * 
  NewLineExport;

  return;
end;

// ASB Format 
procedure BankExpNewZealandASBHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  string 255 BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;

  ExportFixedLengthString("12",2,"0",true,_NONCSVCHARS); // File Type * 
  ParseNewZealandBankAccounts (RepSpec,RepSpec.f11,BankID,BankBranch,BankAccount,BankSuffix);
  ExportFixedLengthString(BankID,2,"0",true,_NONCSVCHARS);  // Bank Number *  
  ExportFixedLengthString(BankBranch,4,"0",true,_NONCSVCHARS);  // Branch Number * 
  ExportFixedLengthString(BankAccount,7,"0",true,_NONCSVCHARS); // Uniq Sequence number *
  ExportFixedLengthString(BankSuffix,3,"0",false,_NONCSVCHARS);  // Suffix Number * 
  ExportFixedLengthString(DateToString(PaymentDueDate(OPr.PayDate,RepSpec),"DDMMYY"),13," ",false,_NONCSVCHARS);  // Due Date *
  ExportFixedLengthString(RepSpec.f12,20," ",false,_NONCSVCHARS); // Company Name
  ExportFixedLengthString("",109," ",false,_NONCSVCHARS);   // filler
  NewLineExport;
 
  return;  
end;

function string 255 BankExpNewZealandASBPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin
  string 255 invoicestr, valstr, BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;

  invoicestr = StringtoCSVString(invoicenr,"");

  ExportFixedLengthString("13",2,"0",true,_NONCSVCHARS); // Header Type * 
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix); // parse payee
  ExportFixedLengthString(BankID,2,"0",true,_NONCSVCHARS);  // Bank Number *  
  ExportFixedLengthString(BankBranch,4,"0",true,_NONCSVCHARS);  // Branch Number * 
  ExportFixedLengthString(BankAccount,7,"0",true,_NONCSVCHARS);  // Account Number * 
  ExportFixedLengthString(BankSuffix,3,"0",true,_NONCSVCHARS);  // Suffix Number * 
  ExportFixedLengthString("051",3,"0",true,_NONCSVCHARS); // Trans Type * 
  NewZealandBankVal(valstr, recval,true);
  ExportFixedLengthString(valstr,10,"0",true,_NONCSVCHARS & "$.");    // Amount * 
  ExportFixedLengthString(vename,20," ",false,_NONCSVCHARS);  // Other Party Name *
  ExportFixedLengthString(ref,12," ",false,_NONCSVCHARS);  // Internal Reference
  ExportFixedLengthString(invoicestr,12," ",false,_NONCSVCHARS);  // Other Party code
  ExportFixedLengthString(PayeeReference(sortcode,ref),12," ",false,_NONCSVCHARS); // Other Party Reference
  ExportFixedLengthString(comment,12," ",false,_NONCSVCHARS);  // Other Party Particulars
  ExportFixedLengthString("",1," ",false,_NONCSVCHARS);   // filler
  ExportFixedLengthString(RepSpec.f12,20," ",false,_NONCSVCHARS);  // Company Name 
  ExportFixedLengthString(invoicestr,12," ",false,_NONCSVCHARS);  // Payer Code 
  ExportFixedLengthString(PayerReference(sortcoderow,ref),12," ",false,_NONCSVCHARS); // Reference
  ExportFixedLengthString(comment,12," ",false,_NONCSVCHARS);  // Other Party Particulars
  ExportFixedLengthString("",4," ",false,_NONCSVCHARS);   // filler
  NewLineExport;
   
  BankExpNewZealandASBPaymentLine =  BankBranch & BankAccount;
  return;
end;

procedure BankExpNewZealandASBSummaryLine(record RcVc RepSpec)
begin
  string 255 valstr;

  ExportFixedLengthString("13",2,"0",true,_NONCSVCHARS); // Header Type * 
  ExportFixedLengthString("99",2,"0",true,_NONCSVCHARS); // Header Type * 
  ExportFixedLengthString(NewZealandHashString(RepSpec),11,"0",true,_NONCSVCHARS); // hash * 
  ExportFixedLengthString("",6," ",false,_NONCSVCHARS);   // filler
  NewZealandBankVal(valstr, RepSpec.vals4,true);
  ExportFixedLengthString(valstr,10,"0",true,_NONCSVCHARS); // Total * 
  ExportFixedLengthString("",129," ",false,_NONCSVCHARS);   // filler
  NewLineExport;

  return;
end;

// BNZ Format
procedure BankExpNewZealandBNZHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  string 255 SubscriberID;
 
  GetBankSubscriberID (OPr,SubscriberID);
  if (IsStringNumeric(SubscriberID) == false) then begin
    SubscriberID = ""; 
  end;

  ExportDelimitedString("1",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString(SubscriberID,7,"",false,_COMMA,_NONCSVCHARS);  // Subscriber ID 
  ExportDelimitedString("",2,"",false,_COMMA,_NONCSVCHARS);   // Batch Number
  ExportDelimitedString("",4,"",false,_COMMA,_NONCSVCHARS);   // Seq number 
  ExportDelimitedString(RepSpec.f11,15,"",false,_COMMA,_NONCSVCHARS);  // Subscriber Acc No
  ExportDelimitedString("7",1,"",false,_COMMA,_NONCSVCHARS);   // BatchType
  ExportDelimitedString(DateToString(PaymentDueDate(OPr.PayDate,RepSpec),"YYMMDD"),6,"",false,_COMMA,_NONCSVCHARS); // Due Date *
  ExportDelimitedString(DateToString(CurrentDate,"YYMMDD"),6,"",false,_COMMA,_NONCSVCHARS); // Creation Date *
  ExportDelimitedString("",1,"",false,"",_NONCSVCHARS); // Indicator *

  NewLineExport;
  return;
end;

function string 255 BankExpNewZealandBNZPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin
  string 255 valstr;
  string 255 invoicestr;
  string 255 BankID, BankAccount, BankBranch, BankSuffix;

  invoicestr = StringtoCSVString(invoicenr,"");
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix);  

  ExportDelimitedString("2",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString(BankID & BankBranch & BankAccount & BankSuffix,16,"",false,_COMMA,_NONCSVCHARS); // Supplier Acc Number *
  ExportDelimitedString("50",2,"",false,_COMMA,_NONCSVCHARS); // Transaction Code * : 50 = Credit 
  NewZealandBankVal(valstr, recval,true);
  ExportDelimitedString(valstr,12,"",false,_COMMA,_NONCSVCHARS & "$.");    // Amount * 
  ExportDelimitedString(vename,20,"",false,_COMMA,_NONCSVCHARS);  // Other Party Name *
  ExportDelimitedString(PayeeReference(sortcode,ref),12,"",false,_COMMA,_NONCSVCHARS); // Other Party Reference
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS); // Other Party Analysis
  ExportDelimitedString("",12,"",false,_COMMA,_NONCSVCHARS);        // Other Party Alpha
  ExportDelimitedString(comment,12,"",false,_COMMA,_NONCSVCHARS);  // Other Party Particulars
  ExportDelimitedString(RepSpec.f12,20,"",false,_COMMA,_NONCSVCHARS);  // Company Name *
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS);  // Analysis
  ExportDelimitedString(PayerReference(sortcoderow,ref),12,"",false,_COMMA,_NONCSVCHARS);  // Reference
  ExportDelimitedString(comment,12,"",false,"",_NONCSVCHARS);  // Particulars
  NewLineExport;

  BankExpNewZealandBNZPaymentLine =  BankBranch & BankAccount;
  return;
end;

procedure BankExpNewZealandBNZSummaryLine(record RcVc RepSpec)
begin
  string 255 valstr;

  ExportDelimitedString("3",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  NewZealandBankVal(valstr, RepSpec.vals4,true);
  ExportDelimitedString(valstr,20,"",false,_COMMA,_NONCSVCHARS); // Total * 
  ExportDelimitedString(RepSpec.long2,6,"",false,_COMMA,_NONCSVCHARS); // # of payment lines * 
  ExportDelimitedString(NewZealandHashString(RepSpec),11,"",false,"",_NONCSVCHARS); // hash * 
  NewLineExport;

  return;
end;

// Kiwi Bank Format

procedure BankExpNewZealandKiwiHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  string 255 SubscriberID;
  
  GetBankSubscriberID (OPr,SubscriberID);
  if (IsStringNumeric(SubscriberID) == false) then begin
    SubscriberID = ""; 
  end;

  ExportDelimitedString("1",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString("",7,"",false,_COMMA,_NONCSVCHARS);  // Subscriber ID 
  ExportDelimitedString("",2,"",false,_COMMA,_NONCSVCHARS);   // Batch Number
  ExportDelimitedString("",4,"",false,_COMMA,_NONCSVCHARS);   // Seq number 
  ExportDelimitedString(RepSpec.f11,16,"",false,_COMMA,_NONCSVCHARS);  // Subscriber Acc No
  ExportDelimitedString("7",1,"",false,_COMMA,_NONCSVCHARS);   // BatchType
  ExportDelimitedString(DateToString(PaymentDueDate(OPr.PayDate,RepSpec),"YYMMDD"),6,"",false,_COMMA,_NONCSVCHARS); // Due Date *
  ExportDelimitedString(DateToString(CurrentDate,"YYMMDD"),6,"",false,_COMMA,_NONCSVCHARS); // Creation Date *
  ExportDelimitedString("",12,"",false,"",_NONCSVCHARS); // Indicator *
  NewLineExport;

  return;
end;

function string 255 BankExpNewZealandKiwiPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin
  string 255 valstr;
  string 255 invoicestr;
  string 255 BankID, BankAccount, BankBranch, BankSuffix;

  invoicestr = StringtoCSVString(invoicenr,"");
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix);  

  ExportDelimitedString("2",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  ExportDelimitedString(BankID & BankBranch & BankAccount & BankSuffix,16,"",false,_COMMA,_NONCSVCHARS); // Supplier Acc Number *
  ExportDelimitedString("50",2,"",false,_COMMA,_NONCSVCHARS); // Transaction Code * : 50 = Credit , 52 = Payroll
  NewZealandBankVal(valstr, recval, true);
  ExportDelimitedString(valstr,12,"",false,_COMMA,_NONCSVCHARS & "$.");    // Amount * 
  ExportDelimitedString(vename,20,"",false,_COMMA,_NONCSVCHARS);  // Other Party Name *
  ExportDelimitedString(PayeeReference(sortcode,ref),12,"",false,_COMMA,_NONCSVCHARS); // Other Party Reference
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS); // Other Party Analysis
  ExportDelimitedString("",12,"",false,_COMMA,_NONCSVCHARS);        // Other Party Alpha
  ExportDelimitedString(comment,12,"",false,_COMMA,_NONCSVCHARS);  // Other Party Particulars
  ExportDelimitedString(RepSpec.f12,20,"",false,_COMMA,_NONCSVCHARS);  // Company Name
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS);  // Analysis
  ExportDelimitedString(PayerReference(sortcoderow,ref),12,"",false,_COMMA,_NONCSVCHARS);  // Reference
  ExportDelimitedString(comment,12,"",false,"",_NONCSVCHARS);  // Particulars
  NewLineExport;
 
  BankExpNewZealandKiwiPaymentLine =  BankBranch & BankAccount;  
  return;
end;

procedure BankExpNewZealandKiwiSummaryLine(record RcVc RepSpec)
begin
  string 255 valstr;

  ExportDelimitedString("3",1,"",false,_COMMA,_NONCSVCHARS); // Header Type * 
  NewZealandBankVal(valstr, RepSpec.vals4,true);
  ExportDelimitedString(valstr,20,"",false,_COMMA,_NONCSVCHARS); // Total * 
  ExportDelimitedString(RepSpec.long2,6,"",false,_COMMA,_NONCSVCHARS); // # of payment lines * 
  ExportDelimitedString(NewZealandHashString(RepSpec),11,"",false,"",_NONCSVCHARS); // hash * 
  NewLineExport;

  return;
end;

// National Format
procedure BankExpNewZealandNationalHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  // Does not have Header Line
  return;
end;

procedure BankExpNewZealandNationalPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin

  string 255 valstr;
  string 255 BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;
  string 255 invoicestr;

  //TODO Check valstr not in cents mode
  invoicestr = StringtoCSVString(invoicenr,"");

  NewZealandBankVal(valstr, recval,false);
  ExportDelimitedString(valstr,10,"",false,_COMMA,_NONCSVCHARS & "$");    // Amount * 
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix);  
  ExportDelimitedString(BankID & BankBranch & BankAccount & BankSuffix,17,"",false,_COMMA,_NONCSVCHARS); // Supplier Acc Number *
  ExportDelimitedString(vename,20,"",false,_COMMA,_NONCSVCHARS);  // Other Party Name *
  ExportDelimitedString(PayerReference(sortcoderow,ref),12,"",false,_COMMA,_NONCSVCHARS);  // Reference
  ExportDelimitedString(invoicestr,12,"",false,",",_NONCSVCHARS);  // Analysis
  ExportDelimitedString(comment,12,"",false,_COMMA,_NONCSVCHARS);  // Particulars
  ExportDelimitedString(PayeeReference(sortcode,ref),12,"",false,_COMMA,_NONCSVCHARS); // Other Party Reference
  ExportDelimitedString(invoicestr,12,"",false,_COMMA,_NONCSVCHARS); // Other Party Analysis
  ExportDelimitedString(comment,12,"",false,"",_NONCSVCHARS);  // Other Party Particulars
  NewLineExport;

  return;
end;

procedure BankExpNewZealandNationalSummaryLine(record RcVc RepSpec)
begin
  // Does not have Summary Line
  return;
end;

// Westpac format
procedure BankExpNewZealandWestpacHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  string 255 BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;

  ExportFixedLengthString("A",1,"",false,_NONCSVCHARS); // Header Type * 
  ExportFixedLengthString(RepSpec.long1,6,"0",true,_NONCSVCHARS); // Uniq Seqence number *
  ParseNewZealandBankAccounts (RepSpec,RepSpec.f11,BankID,BankBranch,BankAccount,BankSuffix);
  ExportFixedLengthString(BankID,2,"",false,_NONCSVCHARS);  // Bank Number *  
  ExportFixedLengthString(BankBranch,4,"0",true,_NONCSVCHARS);  // Branch Number * 
  ExportFixedLengthString("",30," ",false,_NONCSVCHARS); // Customer Name
  ExportFixedLengthString("",6," ",true,_NONCSVCHARS);   // Customer number
  ExportFixedLengthString("",20," ",false,_NONCSVCHARS); // Description UC
  ExportFixedLengthString(DateToString(PaymentDueDate(OPr.PayDate,RepSpec),"DDMMYY"),6,"",false,_NONCSVCHARS);  // Due Date *
  ExportFixedLengthString("",105," ",false,_NONCSVCHARS);  // Spare *
  NewLineExport;
  
  return;
end;

procedure BankExpNewZealandWestpacPaymentLine(string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename,string ref,record RcVc RepSpec)
begin
  string 255 invoicestr, valstr, BankAccStr, BankID, BankAccount, BankBranch, BankSuffix;

  invoicestr = StringtoCSVString(invoicenr,"");

  ExportFixedLengthString("D",1,"",false,_NONCSVCHARS); // Header Type * 
  ExportFixedLengthString(RepSpec.long1,6,"0",true,_NONCSVCHARS); // Uniq Seqence number *
  ParseNewZealandBankAccounts (RepSpec,bankaccrow,BankID,BankBranch,BankAccount,BankSuffix); // parse payee
  ExportFixedLengthString(BankID,2,"",false,_NONCSVCHARS);  // Bank Number *  
  ExportFixedLengthString(BankBranch,4,"0",true,_NONCSVCHARS);  // Branch Number * 
  ExportFixedLengthString(BankAccount,8,"0",true,_NONCSVCHARS);  // Account Number * 
  ExportFixedLengthString(BankSuffix,4,"0",true,_NONCSVCHARS);  // Suffix Number * 
  ExportFixedLengthString("50",2,"",false,_NONCSVCHARS);  // Transaction Code *
  ExportFixedLengthString("DC",2,"",false,_NONCSVCHARS);  // MTS CODE *
  NewZealandBankVal(valstr, recval,true);
  ExportFixedLengthString(valstr,15,"0",true,_NONCSVCHARS & "$.");    // Amount * 
  ExportFixedLengthString(vename,20," ",false,_NONCSVCHARS);  // Other Party Name *
  ExportFixedLengthString(comment,12," ",false,_NONCSVCHARS); // Other Party Reference
  ExportFixedLengthString(invoicestr,12," ",false,_NONCSVCHARS); // Other Party Analysis
  ExportFixedLengthString(ref,12," ",true,_NONCSVCHARS);  // Other Party Reference
  ParseNewZealandBankAccounts (RepSpec,RepSpec.f11,BankID,BankBranch,BankAccount,BankSuffix); // parse payer
  ExportFixedLengthString(BankID,2,"",false,_NONCSVCHARS);  // Bank Number *  
  ExportFixedLengthString(BankBranch,4,"0",true,_NONCSVCHARS);  // Branch Number * 
  ExportFixedLengthString(BankAccount,8,"0",true,_NONCSVCHARS);  // Account Number * 
  ExportFixedLengthString(BankSuffix,4,"0",true,_NONCSVCHARS);  // Suffix Number * 
  ExportFixedLengthString(RepSpec.f12,20," ",false,_NONCSVCHARS);  // Company Name 
  ExportFixedLengthString("",42," ",false,_NONCSVCHARS);  // Spare *
  NewLineExport;

  return;
end;

procedure BankExpNewZealandWestpacSummaryLine(record RcVc RepSpec)
begin
  // Does not have Summary Line
  return;
end;

// Common Mew Zealand Bank File export routines

procedure BankExportOnePaymemt(record RcVc RepSpec, string sortcode,string sortcoderow,string bankacc,string bankaccrow,val recval,string invoicenr,string comment,string vename, string ref)
begin
  string 255 hash;
 
  RepSpec.long1 = RepSpec.long1 + 1;
  RepSpec.long2 = RepSpec.long2 + 1;
  RepSpec.vals4  = RepSpec.vals4 + recval;

  switch (RepSpec.em1) begin  
    case 120 : 
      hash = BankExpNewZealandANZPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
      RepSpec.vals1 = RepSpec.vals1 +  StringToVal(hash,M4UVal);     
    case 121 : 
      hash = BankExpNewZealandASBPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
      RepSpec.vals1 = RepSpec.vals1 +  StringToVal(hash,M4UVal);     
    case 122 : 
      hash = BankExpNewZealandBNZPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
      RepSpec.vals1 = RepSpec.vals1 +  StringToVal(hash,M4UVal);     
    case 123 : 
      hash = BankExpNewZealandKiwiPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
      RepSpec.vals1 = RepSpec.vals1 +  StringToVal(hash,M4UVal);     
    case 124 : BankExpNewZealandNationalPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
    case 125 : BankExpNewZealandWestpacPaymentLine(sortcode,sortcoderow,bankacc,bankaccrow,recval,invoicenr,comment,vename,ref,RepSpec);
  end; 
  return;
end;

procedure BankExpNewZealandPayment(record RcVc RepSpec,record OPVc OPr)
begin
  row OPVc OPrw;
  Integer i,rwcnt;
  record VIVc VIr;
  Boolean TrHs;
  string 255 InvoiceNr;  
  Boolean PayperSupplier;
  Boolean ValidPaymentRow;
  Boolean found;
  string 20 supplaccnr;
  string 100 suppliername;
  string 20 sortcode;
  record CUVc VEr,VE2r;
  Integer acnt,ai;
  Array string 255 avecode;
  Array string 255 avename;
  Array string 255 avesortcode;
  Array string 255 avesortcoderow;
  Array string 255 avebankacc;
  Array string 255 avebankaccrow;
  Array string 255 aveinvoicenr;
  Array string 255 avecomment;
  Array string 255 averef;
  Array val averecval;
  string 255 comm;
   
  PayperSupplier = IntToBoolean(OPr.PayperSupplier);
  if (PayperSupplier==False) then begin
    PayperSupplier = IntToBoolean (RepSpec.flags[5]);
  end;
  rwcnt = MatRowCnt(OPr);
  if (PayperSupplier == False) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(OPr,i,OPrw);
      ValidPaymentRow = (OPrw.ovst == 0);
      if ((ValidPaymentRow==true) and (nonblank(RepSpec.CurncyCode))) then begin
        ValidPaymentRow = (OPrw.BankCurncy==RepSpec.CurncyCode);
      end;    
      if (ValidPaymentRow == True) then begin
        VIr.SerNr = OPrw.VISerNr;
        found = ReadFirstMain(VIr,1,true);
        InvoiceNr = VIr.InvoiceNr;
        supplaccnr = OPrw.BankAcc;
        sortcode = OPrw.SortCode;
        VEr.Code = OPrw.VECode;
        comm = OPrw.Comment;
        suppliername =  OPrw.VECode;
        if ReadFirstMain(VEr,1,true) then begin
          suppliername = VEr.Name;
          if blank(VEr.VEFactoring) then begin 
            supplaccnr = VEr.BankAccount;
            sortcode = VEr.SortCode;
          end else begin
            VE2r.Code = VEr.VEFactoring;
            if ReadFirstMain(VE2r,1,true) then begin 
              supplaccnr = VE2r.BankAccount;
              sortcode = VE2r.SortCode;
              suppliername = VE2r.Name;
            end;
          end;  
        end;
        suppliername = StringtoCSVString (suppliername,"");
        BankExportOnePaymemt(RepSpec,OPr.SortCode,sortcode,OPr.BankAcc,supplaccnr,OPrw.RecVal,InvoiceNr,comm,suppliername,OPr.PayNumber);
      end;	  
    end;
  end
  else begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(OPr,i,OPrw);
      ValidPaymentRow = (OPrw.ovst == 0);
      if ((ValidPaymentRow==true) and (nonblank(RepSpec.CurncyCode))) then begin
        ValidPaymentRow = (OPrw.BankCurncy==RepSpec.CurncyCode);
      end;    
      if (ValidPaymentRow==true) then begin
        VIr.SerNr = OPrw.VISerNr;
        Found = ReadFirstMain(VIr,1,true);
        InvoiceNr = VIr.InvoiceNr;
        supplaccnr = OPrw.BankAcc;
        sortcode = OPrw.SortCode;
        suppliername =  OPrw.VECode;
        VEr.Code = OPrw.VECode;
        if ReadFirstMain(VEr,1,true) then begin
          suppliername = VEr.Name;
          if blank(VEr.VEFactoring) then begin 
            supplaccnr = VEr.BankAccount;
            sortcode = VEr.SortCode;
          end else begin
            VE2r.Code = VEr.VEFactoring;
            if ReadFirstMain(VE2r,1,true) then begin 
              supplaccnr = VE2r.BankAccount;
              sortcode = VE2r.SortCode;
              suppliername = VE2r.Name;
            end;
          end;  
        end;
        ai = CheckIfSupplierPaidinArray(OPrw.VECode,OPr.SortCode,sortcode,OPr.BankAcc,supplaccnr,InvoiceNr,OPrw.RecVal,comm,
                             avecode,avesortcode,avesortcoderow,avebankacc,avebankaccrow,aveinvoicenr,averecval,avecomment,acnt);
        if (ai>-1) then begin
          averecval[ai] = averecval[ai] + OPrw.RecVal;
          InvoiceNr = VIr.InvoiceNr;
          if (nonblank(aveinvoicenr[ai])) then begin
            aveinvoicenr[ai] = aveinvoicenr[ai] & "_";
          end;
          aveinvoicenr[ai] = aveinvoicenr[ai] & InvoiceNr;
          if (nonblank(avecomment[ai])) then begin
            avecomment[ai] = avecomment[ai] & "_";
          end;
          avecomment[ai] = avecomment[ai] & OPrw.Comment;
        end else begin
          suppliername = StringtoCSVString (suppliername,"");
          AddToSupplierPaidArray(OPrw.VECode,suppliername,OPr.SortCode,sortcode,OPr.BankAcc,supplaccnr,InvoiceNr,OPrw.RecVal,comm,OPr.PayNumber,
                      avecode,avename,avesortcode,avesortcoderow,avebankacc,avebankaccrow,aveinvoicenr,averecval,avecomment,averef,acnt);
        end;
     end;  
    end;
    for (ai=0;ai<acnt;ai=ai+1) begin	      
      BankExportOnePaymemt(RepSpec,avesortcode[ai],avesortcoderow[ai],avebankacc[ai],avebankaccrow[ai],averecval[ai],aveinvoicenr[ai],avecomment[ai],avename[ai],averef[ai]);
    end;
  end;  
  return;
end;

global
procedure BankExpNewZealandHeaderLine(record RcVc RepSpec, record OPVc OPr)
begin
  switch (RepSpec.em1) begin  
    case 120 : BankExpNewZealandANZHeaderLine(RepSpec,OPr);
    case 121 : BankExpNewZealandASBHeaderLine(RepSpec,OPr);
    case 122 : BankExpNewZealandBNZHeaderLine(RepSpec,OPr);
    case 123 : BankExpNewZealandKiwiHeaderLine(RepSpec,OPr);
    case 124 : BankExpNewZealandNationalHeaderLine(RepSpec,OPr);
    case 125 : BankExpNewZealandWestpacHeaderLine(RepSpec,OPr);
  end; 
  return;
end;

global
procedure BankExpNewZealandPayments(record RcVc RepSpec,record OPVc OPr)
begin
  BankExpNewZealandPayment (RepSpec,Opr); 
  return;
end;

global
procedure BankExpNewZealandSummaryLine(record RcVc RepSpec)
begin
  longint lines;
  string 255 tstr;

  RepSpec.long1 = RepSpec.long1 + 1;

  switch (RepSpec.em1) begin  
    case 120 : BankExpNewZealandANZSummaryLine(RepSpec);
    case 121 : BankExpNewZealandASBSummaryLine(RepSpec);
    case 122 : BankExpNewZealandBNZSummaryLine(RepSpec);
    case 123 : BankExpNewZealandKiwiSummaryLine(RepSpec);
    case 124 : BankExpNewZealandNationalSummaryLine(RepSpec);
    case 125 : BankExpNewZealandWestpacSummaryLine(RepSpec);
  end; 
  return;
end;
