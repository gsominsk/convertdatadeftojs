external procedure GetConsolidationRate(string,string,Date,var val,var val,var val,var val,var val);
external procedure MulM4OneRate(val,val,var val,roundmode,Boolean);
external procedure GetAccDCBalance(string,string,Date,record ObjBalVc,Integer,Integer,Integer,string,var val,var val,Integer);
external procedure GetFullCurncyPLConsolidationRate(var string,Date,var val,var val,var val,var val,var val);
external procedure GetFullCurncyBalConsolidationRate(var string,Date,var val,var val,var val,var val,var val);
external procedure NewLineExport();

procedure ConsTriaPerAccount_Company(Boolean motherf,record RcVc RepSpec,record AccVc Accr,Boolean printaccf,record SysFormatBlock SFb,vector val vTotDeb,vector val vTotCred,vector val vTotDebConsCur,vector val vTotCredConsCur)
begin
  Date sbd;
  record ObjBalVc ObjBalr;
  val PerDeb,PerCred,t;
  val PerDebConsCur,PerCredConsCur,tConsCur;
  Boolean posdebf;
  val plfrom,plto1,plto2,plbase1,plbase2;
  val bsfrom,bsto1,bsto2,bsbase1,bsbase2;
  string 255 curcode;
  record BaseCurBlock BCb;
  record ConsolidationBlock Consb;

  BlockLoad(BCb);
  BlockLoad(Consb);
  ObjBalr.AccNumber = Accr.AccNumber;
  ObjBalr.Object = RepSpec.ObjStr;
  if (ReadFirstMain(ObjBalr,2,true)) then begin
    sbd = RepSpec.d1;
    GetAccDCBalance(Accr.AccNumber,RepSpec.ObjStr,sbd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,0,RepSpec.CurncyCode,PerDeb,PerCred,RepSpec.flags[6]);
    if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeLiability) or (Accr.AccType==kAccTypeEquity) then begin
      posdebf = true;
    end;
    if (Accr.AccType==kAccTypeIncome) or (Accr.AccType==kAccTypeExpense) then begin
      posdebf = false;
    end;
  end;
  t = PerDeb - PerCred;
  
  if (t!=0) then begin
    if (printaccf) then begin
      ExportString(Accr.AccNumber);
      ExportString(Accr.Comment);
    end else begin
      if (motherf) then begin
        ExportString("");
        ExportString("");
      end;
    end;
    if (posdebf) then begin
      if (t>=0) then begin
        ExportString(ValToString(t,M4Val,SFb.thousSep,SFb.decimalPt,0));
        ExportString("");
        vTotDeb[CurrentCompany] = vTotDeb[CurrentCompany] + t;
      end else begin
        ExportString("");
        ExportString(ValToString(t,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
        vTotCred[CurrentCompany] = vTotCred[CurrentCompany] - t;
      end;
    end else begin
      if (t>=0) then begin
        ExportString("");
        ExportString(ValToString(t,M4Val,SFb.thousSep,SFb.decimalPt,0));
        vTotDeb[CurrentCompany] = vTotDeb[CurrentCompany] + t;
      end else begin
        ExportString(ValToString(t,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
        ExportString("");
        vTotCred[CurrentCompany] = vTotCred[CurrentCompany] - t;
      end;
    end;
  
    switch (Consb.ConsCrncy) begin
      case 0: curcode = BCb.BaseCur1;
      case 1: curcode = BCb.BaseCur2;
    end;        
    if (nonblank(BCb.BaseCur2)) and (motherf==false) then begin
      curcode = BCb.BaseCur1;
      GetConsolidationRate(Accr.AccNumber,curcode,RepSpec.sStartDate,plfrom,plto1,plto2,plbase1,plbase2);
      if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeLiability) or (Accr.AccType==kAccTypeEquity) then begin
        MulM4OneRate(PerDeb,(plto1/plfrom)*100,PerDebConsCur,DefaultCurRoundOff,true);
        MulM4OneRate(PerCred,(plto1/plfrom)*100,PerCredConsCur,DefaultCurRoundOff,true);
      end;
      if (Accr.AccType==kAccTypeIncome) or (Accr.AccType==kAccTypeExpense) then begin
        MulM4OneRate(PerDeb,(plto1/plfrom)*100,PerDebConsCur,DefaultCurRoundOff,true);
        MulM4OneRate(PerCred,(plto1/plfrom)*100,PerCredConsCur,DefaultCurRoundOff,true);
      end;
  
      tConsCur = PerDebConsCur - PerCredConsCur;
      if (tConsCur==0) then begin tConsCur = blankval; end;
      if (posdebf) then begin
        if (tConsCur>=0) then begin
          ExportString(ValToString(tConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
          ExportString("");
          vTotDebConsCur[CurrentCompany] = vTotDebConsCur[CurrentCompany] + tConsCur;
        end else begin
          ExportString("");
          ExportString(ValToString(tConsCur,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
          vTotCredConsCur[CurrentCompany] = vTotCredConsCur[CurrentCompany] - tConsCur;
        end;
      end else begin
        if (tConsCur>=0) then begin
          ExportString("");
          ExportString(ValToString(tConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
          vTotDebConsCur[CurrentCompany] = vTotDebConsCur[CurrentCompany] + tConsCur;
        end else begin
          ExportString(ValToString(tConsCur,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
          ExportString("");
          vTotCredConsCur[CurrentCompany] = vTotCredConsCur[CurrentCompany] - tConsCur;
        end;
      end;
    end;
    ExportString("");
  end;
  return;
end;
            
procedure ConsTriaPerAccount(record RcVc RepSpec)
begin
  record AccVc Accr;
  Boolean found;
  record BaseCurBlock BCb;
  record SysFormatBlock SFb;
  record CompaniesBlock Cb;
  row CompaniesBlock Cbrw;
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCbrw;
  Integer i,rwcnt;
  Integer oldcomp;
  val plfrom,plto1,plto2,plbase1,plbase2;
  val bsfrom,bsto1,bsto2,bsbase1,bsbase2;
  string 255 curcode;
  record ConsolidationBlock Consb;
  vector val vTotDeb,vTotCred,vTotDebConsCur,vTotCredConsCur;

  BlockLoad(SFb);
  BlockLoad(DCb);
  BlockLoad(Cb);

  oldcomp = CurrentCompany;
  
  rwcnt = MatRowCnt(Cb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Cb,i,Cbrw);
    if ((i+1)==CurrentCompany) then begin
      i = rwcnt;
    end;
  end;

  ExportString("");
  ExportString(USetStr(32029) & ": " & Cbrw.CompCode);
  ExportString("");
  ExportString("");
  ExportString("");
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCbrw);
    SetCompanyCode(DCbrw.CompCode,false);
    BlockLoad(BCb);
    ExportString(USetStr(32029) & ": " & DCbrw.CompCode);
    ExportString("");
    if (nonblank(BCb.BaseCur2)) then begin
      ExportString(USetStr(32026) & ": " & BCb.BaseCur1);
      ExportString("");
    end;
    ExportString("");
  end;
  NewLineExport;

  ResetCompany(oldcomp);
  ExportString("");
  ExportString(Cbrw.CompName);
  ExportString("");
  ExportString("");
  ExportString("");
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCbrw);
    SetCompanyCode(DCbrw.CompCode,false);
    BlockLoad(BCb);
    ExportString(DCbrw.CompName);
    ExportString("");
    if (nonblank(BCb.BaseCur2)) then begin
      BlockLoad(Consb);
      curcode = BCb.BaseCur1;
      SetCompanyCode(Consb.MotherCode,false);    
      GetFullCurncyBalConsolidationRate(curcode,RepSpec.d1,bsfrom,bsto1,bsto2,bsbase1,bsbase2);
      ExportString(USetStr(32028) & ": " & bsfrom & ":" & bsto1);
      ExportString("");
    end;
    ExportString("");
  end;
  NewLineExport;

  ResetCompany(oldcomp);
  BlockLoad(BCb);
  ExportString("Account");
  ExportString("");
  ExportString(BCb.BaseCur1 & " DR");
  ExportString(BCb.BaseCur1 & " CR");
  ExportString("");
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCbrw);
    SetCompanyCode(DCbrw.CompCode,false);
    BlockLoad(BCb);
    ExportString(BCb.BaseCur1 & " DR");
    ExportString(BCb.BaseCur1 & " CR");
    if (nonblank(BCb.BaseCur2)) then begin
      BlockLoad(Consb);
      curcode = BCb.BaseCur1;
      SetCompanyCode(Consb.MotherCode,false);    
      GetFullCurncyPLConsolidationRate(curcode,RepSpec.d1,plfrom,plto1,plto2,plbase1,plbase2);
      ExportString(USetStr(32027) & ": " & plfrom & ":" & plto1);
      ExportString("");
    end;
    ExportString("");
  end;
  NewLineExport;
  
  found = true;
  while (LoopMain(Accr,1,found)) begin
    if (found) then begin
      ResetCompany(oldcomp);
      ConsTriaPerAccount_Company(true,RepSpec,Accr,true,SFb,vTotDeb,vTotCred,vTotDebConsCur,vTotCredConsCur);
      
      rwcnt = MatRowCnt(DCb);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(DCb,i,DCbrw);
        SetCompanyCode(DCbrw.CompCode,false);
        ConsTriaPerAccount_Company(false,RepSpec,Accr,false,SFb,vTotDeb,vTotCred,vTotDebConsCur,vTotCredConsCur);
      end;
      NewLineExport;
    end;
  end;
  
  ExportString("");
  ExportString("");
  ExportString(vTotDeb[oldcomp]);
  ExportString(vTotCred[oldcomp]);
  ExportString("");
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCbrw);
    SetCompanyCode(DCbrw.CompCode,false);
    BlockLoad(BCb);
//    ExportString(USetStr(32030));
    ExportString(vTotDeb[StringToInt(DCbrw.CompCode)]);
    ExportString(vTotCred[StringToInt(DCbrw.CompCode)]);
    if (nonblank(BCb.BaseCur2)) then begin
      ExportString(vTotDebConsCur[StringToInt(DCbrw.CompCode)]);
      ExportString(vTotCredConsCur[StringToInt(DCbrw.CompCode)]);
    end;
    ExportString("");
  end;
  NewLineExport;
  
  ResetCompany(oldcomp);
  return;
end;

procedure ExportHeader()
begin
  ExportString(USetStr(32020));
  ExportString(USetStr(32021));
  ExportString(USetStr(32022));
  ExportString(USetStr(32023));
  ExportString(USetStr(32024));
  ExportString(USetStr(32025));
  NewLineExport;
  return;
end;

procedure CompanyTrialEn(record RcVc cRepSpec,string CompCode,string CompName,
                        var val TotPerDeb,var val TotPerCred,var val TotAccDeb,var val TotAccCred,
                        var val TotPerDebConsCur,var val TotPerCredConsCur,var val TotAccDebConsCur,var val TotAccCredConsCur)
begin
  record ConsolidationBlock Consb;
  record BaseCurBlock BCb;
  record SysFormatBlock SFb;
  val plfrom,plto1,plto2,plbase1,plbase2;
  val bsfrom,bsto1,bsto2,bsbase1,bsbase2;
  string 255 curcode;
  val PerDeb,PerCred,AccDeb,AccCred;
  val PerDebConsCur,PerCredConsCur,AccDebConsCur,AccCredConsCur;
  val CompPerDeb,CompPerCred,CompAccDeb,CompAccCred;
  val CompPerDebConsCur,CompPerCredConsCur,CompAccDebConsCur,CompAccCredConsCur;
  val t,tConsCur;
  Date sbd;
  Boolean found,posdebf;
  record AccVc Accr;
  record ObjBalVc ObjBalr;
  Integer oldcomp;
  
  BlockLoad(Consb);
  BlockLoad(SFb);
  BlockLoad(BCb);
  
  ExportString(CompCode);
  ExportString(CompName);
  ExportString(USetStr(32026) & ": " & BCb.BaseCur1);
  if (nonblank(BCb.BaseCur2)) then begin
    ExportString("");
    ExportString(USetStr(32026) & ": " & BCb.BaseCur2);

    oldcomp = CurrentCompany;  
    SetCompanyCode(Consb.MotherCode,false);    
    curcode = BCb.BaseCur1;
    GetFullCurncyPLConsolidationRate(curcode,cRepSpec.d1,plfrom,plto1,plto2,plbase1,plbase2);
    curcode = BCb.BaseCur1;
    GetFullCurncyBalConsolidationRate(curcode,cRepSpec.d1,bsfrom,bsto1,bsto2,bsbase1,bsbase2);
    ResetCompany(oldcomp);
    ExportString(USetStr(32027) & ": " & plfrom & ":" & plto1);
    ExportString(USetStr(32028) & ": " & bsfrom & ":" & bsto1);
  end else begin
    ExportString("");
    ExportString("");
    ExportString("");
  end;
  NewLineExport;

  found = true;
  while (LoopMain(Accr,1,found)) begin     
    if (found) then begin
      PerDeb = blankval;
      PerCred = blankval;
      AccDeb = blankval;
      AccCred = blankval;
      PerDebConsCur = blankval;
      PerCredConsCur = blankval;
      AccDebConsCur = blankval;
      AccCredConsCur = blankval;
      ObjBalr.AccNumber = Accr.AccNumber;
      ObjBalr.Object = cRepSpec.ObjStr;
      if (ReadFirstMain(ObjBalr,2,true)) then begin
        sbd = cRepSpec.d1;
        GetAccDCBalance(Accr.AccNumber,cRepSpec.ObjStr,sbd,ObjBalr,cRepSpec.SimVerf,cRepSpec.basecurncy,0,cRepSpec.CurncyCode,PerDeb,PerCred,cRepSpec.flags[6]);
//        GetAccDCBalance(Accr.AccNumber,cRepSpec.ObjStr,cRepSpec.sEndDate,ObjBalr,cRepSpec.SimVerf,cRepSpec.basecurncy,0,cRepSpec.CurncyCode,AccDeb,AccCred,cRepSpec.flags[6]);

        t = PerDeb - PerCred;
        switch (Consb.ConsCrncy) begin
          case 0: curcode = BCb.BaseCur1;
          case 1: curcode = BCb.BaseCur2;
        end;        
        if (nonblank(BCb.BaseCur2)) then begin
          curcode = BCb.BaseCur1;
          GetConsolidationRate(Accr.AccNumber,curcode,cRepSpec.sStartDate,plfrom,plto1,plto2,plbase1,plbase2);
          if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeLiability) or (Accr.AccType==kAccTypeEquity) then begin
            MulM4OneRate(PerDeb,(plto1/plfrom)*100,PerDebConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(PerCred,(plto1/plfrom)*100,PerCredConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(AccDeb,(plto1/plfrom)*100,AccDebConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(AccCred,(plto1/plfrom)*100,AccCredConsCur,DefaultCurRoundOff,true);
          end;
          if (Accr.AccType==kAccTypeIncome) or (Accr.AccType==kAccTypeExpense) then begin
            MulM4OneRate(PerDeb,(plto1/plfrom)*100,PerDebConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(PerCred,(plto1/plfrom)*100,PerCredConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(AccDeb,(plto1/plfrom)*100,AccDebConsCur,DefaultCurRoundOff,true);
            MulM4OneRate(AccCred,(plto1/plfrom)*100,AccCredConsCur,DefaultCurRoundOff,true);
          end;
        end;
        if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeLiability) or (Accr.AccType==kAccTypeEquity) then begin
          posdebf = true;
        end;
        if (Accr.AccType==kAccTypeIncome) or (Accr.AccType==kAccTypeExpense) then begin
          posdebf = false;
        end;


        ExportString(Accr.AccNumber);
        ExportString(Accr.Comment);
        if (posdebf) then begin
          if (t>=0) then begin
            ExportString(ValToString(t,M4Val,SFb.thousSep,SFb.decimalPt,0));
            ExportString("");
          end else begin
            ExportString("");
            ExportString(ValToString(t,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
          end;
        end else begin
          if (t>=0) then begin
            ExportString("");
            ExportString(ValToString(t,M4Val,SFb.thousSep,SFb.decimalPt,0));
          end else begin
            ExportString(ValToString(t,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
            ExportString("");
          end;
        end;
        tConsCur = PerDebConsCur - PerCredConsCur;
        if (nonblank(BCb.BaseCur2)) then begin  
          if (posdebf) then begin
            if (tConsCur>=0) then begin
              ExportString(ValToString(tConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
              ExportString("");
            end else begin
              ExportString("");
              ExportString(ValToString(tConsCur,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
            end;
          end else begin
            if (tConsCur>=0) then begin
              ExportString("");
              ExportString(ValToString(tConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
            end else begin
              ExportString(ValToString(tConsCur,M4NegVal,SFb.thousSep,SFb.decimalPt,0));
              ExportString("");
            end;
          end;

        end else begin
          ExportString("");
          ExportString("");
        end;
        NewLineExport;
        
        
        CompPerDeb = CompPerDeb + PerDeb;
        CompPerCred = CompPerCred + PerCred;
        CompAccDeb = CompAccDeb + AccDeb;
        CompAccCred = CompAccCred + AccCred;

        CompPerDebConsCur = CompPerDebConsCur + PerDebConsCur;
        CompPerCredConsCur = CompPerCredConsCur + PerCredConsCur;
        CompAccDebConsCur = CompAccDebConsCur + AccDebConsCur;
        CompAccCredConsCur = CompAccCredConsCur + AccCredConsCur;
      end;
    end;
  end;
  ExportString("");
  ExportString("");
  ExportString(ValToString(CompPerDeb,M4Val,SFb.thousSep,SFb.decimalPt,0));
  ExportString(ValToString(CompPerCred,M4Val,SFb.thousSep,SFb.decimalPt,0));
  if (nonblank(BCb.BaseCur2)) then begin
    ExportString(ValToString(CompPerDebConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
    ExportString(ValToString(CompPerCredConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
  end;
  NewLineExport;


  TotPerDeb = TotPerDeb + CompPerDeb;
  TotPerCred = TotPerCred + CompPerCred;
  TotAccDeb = TotAccDeb + CompAccDeb;
  TotAccCred = TotAccCred + CompAccCred;

  TotPerDebConsCur = TotPerDebConsCur + CompPerDebConsCur;
  TotPerCredConsCur = TotPerCredConsCur + CompPerCredConsCur;
  TotAccDebConsCur = TotAccDebConsCur + CompAccDebConsCur;
  TotAccCredConsCur = TotAccCredConsCur + CompAccCredConsCur;

  return;
end;

global
procedure ConsTrialEn(record RcVc RepSpec)
begin
  record RcVc cRepSpec;
  record SysFormatBlock SFb;
  record CompaniesBlock Cb;
  row CompaniesBlock Cbrw;
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCbrw;
  Integer i,rwcnt;
  Integer oldcomp;
  Boolean testf;
  val TotPerDeb,TotPerCred,TotAccDeb,TotAccCred;
  val TotPerDebConsCur,TotPerCredConsCur,TotAccDebConsCur,TotAccCredConsCur;
    
  if (RepSpec.flags[0]!=0) then begin
    ConsTriaPerAccount(RepSpec);
  end else begin
    BlockLoad(SFb);
    BlockLoad(Cb);

    ExportHeader;
    rwcnt = MatRowCnt(Cb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Cb,i,Cbrw);
      if ((i+1)==CurrentCompany) then begin
        i = rwcnt;
      end;
    end;
    CompanyTrialEn(RepSpec,Cbrw.CompCode,Cbrw.CompName,TotPerDeb,TotPerCred,TotAccDeb,TotAccCred,TotPerDebConsCur,TotPerCredConsCur,TotAccDebConsCur,TotAccCredConsCur);
    NewLineExport;
  
    oldcomp = CurrentCompany;
    BlockLoad(DCb);
    rwcnt = MatRowCnt(DCb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(DCb,i,DCbrw);
      testf = true;
      cRepSpec = RepSpec;
      if (testf) then begin
        SetCompanyCode(DCbrw.CompCode,false);
        CompanyTrialEn(cRepSpec,DCbrw.CompCode,DCbrw.CompName,TotPerDeb,TotPerCred,TotAccDeb,TotAccCred,TotPerDebConsCur,TotPerCredConsCur,TotAccDebConsCur,TotAccCredConsCur);
        NewLineExport;
      end;
    end;
    ExportString("");
    ExportString("");
    ExportString(ValToString(TotPerDeb,M4Val,SFb.thousSep,SFb.decimalPt,0));
    ExportString(ValToString(TotPerCred,M4Val,SFb.thousSep,SFb.decimalPt,0));
    ExportString(ValToString(TotPerDebConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
    ExportString(ValToString(TotPerCredConsCur,M4Val,SFb.thousSep,SFb.decimalPt,0));
    NewLineExport;
    ResetCompany(oldcomp);
  end;
  return;
end;