external function string 255 FindINObjects(string,string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external updating procedure AddtoPrelORPUStock(LongInt,Integer,Date,Date,string,string,string,val,string,Integer);
external function Boolean GetPurchaseItem(string,string,var record PIVc);
external function Boolean PasteVEInPO(var record POVc,Boolean);
external procedure GetItemVATCode(string,Integer,var string,Boolean);
external procedure DivPIFactor(val,val,var val);
external function Boolean GetItemNameStr(Integer,var string,string,string,string);
external procedure GetINCostAcc(record INVc,var string);
external procedure RoundRowSum(string,string,string,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure POSumup(var record POVc);
external procedure POMultiLineText(record POVc,record INVc,string,Integer);
external function Boolean GetFirstItem(var string,var record INVc);
external updating procedure PurchProg(record RcVc,Integer);
external procedure HTItem(string,var string);

global
updating procedure StorePO(Array record POVc aPOr,Integer pocnt)
BEGIN
  Integer poi;
  record POVc POr;
  row POVc POrw;
  Integer i,rwcnt;
  record MainStockBlock MainStockRec;
  
  BlockLoad(MainStockRec);
  for (poi=0;poi<pocnt;poi=poi+1) begin
    POr = aPOr[poi];
    POr.SerNr = NextSerNr("POVc",POr.TransDate,-1,false,"");
    if (POr.SerNr>0) then begin
//      DBFlush;
//      DBHold;
      if (RecordStore(POr,false)) then begin
        rwcnt = MatRowCnt(POr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(POr,i,POrw);
          if ((POrw.Shipd2<POrw.Quant) and (nonblank(POrw.ArtCode))) then begin
            AddtoPrelORPUStock(POr.SerNr,i+1,POr.TransDate,StringToDate(POr.PlanShip),POr.Location,"POVc",POrw.ArtCode,POrw.Quant-POrw.Shipd2,MainStockRec.MainStock,0);
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

global
function val GetPOQty(string ItemCode,Date frEventDate,Date toEventDate,string Location,Boolean printf)
begin
  record PrelORPUStockVc POPrelORPUStockr;
  record INVc INr;
  Boolean TrHs;
  val res;
  
  TrHs = true;
  if (printf) then begin
    if (ReadFirstItem(ItemCode,INr,true,true)) then begin
      StartFormat(15);
      OutString(0,0,INr.Code,false);
      OutString(80,0,INr.Name,false);
      OutString(480,0,INr.Group,true);
      EndFormat;
    end;
  end;
  POPrelORPUStockr.FileName = "POVc";
  POPrelORPUStockr.ItemCode = ItemCode;
  POPrelORPUStockr.EventDate = frEventDate;
//  POPrelORPUStockr.Location = Location;
  while (LoopMain(POPrelORPUStockr,3,TrHs)) begin
    if (POPrelORPUStockr.FileName!="POVc") then begin TrHs = false;end;
    if (POPrelORPUStockr.ItemCode!=ItemCode) then begin TrHs = false;end;
    if (POPrelORPUStockr.EventDate>toEventDate) then begin TrHs = false;end;
//    if (POPrelORPUStockr.Location!=Location) then begin TrHs = false;end;
    if (TrHs) then begin
      res = res + POPrelORPUStockr.Qty;
      if (printf) then begin
        StartFormat(15);
        OutStringID(60,"DblPurchProgPO",ValToString(POPrelORPUStockr.Qty,M4UVal,"","",0),true,POPrelORPUStockr.ItemCode & ":" & POPrelORPUStockr.EventDate);
        OutString(70,0,INr.Unittext,false);
        OutString(130,0,USetStr(13779) & POPrelORPUStockr.OrderedDate,false);
        OutString(280,0,USetStr(13780) & POPrelORPUStockr.EventDate,false);
        EndFormat;
      end;
    end;
  end;
  GetPOQty = res;
  return;
end;

// loc could be used if we wanted to use "Per Location" feature, we are not at the moment  //loc;
global
function val GetPurchProgInStock(string sellocation,string item,string loc)
begin
  record PrelStockVc PrelStockr;
  val res;
  Boolean foundf;

  PrelStockr.ItemCode = item;
  PrelStockr.Location = "";
  res = BlankVal;
  foundf = true;
  while (LoopMain(PrelStockr,1,foundf)) begin
    if (PrelStockr.ItemCode<>item) then begin
      foundf = false;
    end;
    if (nonblank(sellocation)) then begin
      if (sellocation<>PrelStockr.Location) then begin
        foundf = false;
      end;
    end;
    if (foundf) then begin
      res = res + PrelStockr.Qty;
    end;
  end;
  GetPurchProgInStock = res;
  return;
end;

procedure PasteIteminPO(string artcode,val ordqty,var record POVc POr,Integer rownr,Boolean chrsum)
BEGIN
  record GeneralOptionBlock GenOptRec;
  Boolean itemfound,chsum;
  row POVc POrw;
  record INVc INr;
  record PIVc PIr;
  val price,t;
  string 255 vatcode,tstr,costacc;
  Integer rwcnt,i;
  row PIVc PIrw;

  BlockLoad(GenOptRec);
  if (rownr<0) then begin goto LPasteIteminPO;end;
  ClearRow(POr,POrw,1);
  POrw.Quant = ordqty;
  itemfound = GetFirstItem(artcode,INr);
  POrw.ArtCode = artcode;
  if (itemfound) then begin
    POrw.PriceFactor = INr.PriceFactor;
  end else begin
    POrw.PriceFactor = blankval;
  end;
  PIr.VECode = POr.VECode;
  PIr.Location = POr.Location;
  PIr.ItemCode = POrw.ArtCode;
  if (GetPurchaseItem(artcode,POr.Location,PIr)) then begin
    POr.VECode = PIr.VECode;
    if (PasteVEInPO(POr,false)) then begin end;
    price = PIr.PurPrice;
    if (PIr.CurncyCode!=POr.CurncyCode) then begin
      t = MulWithRateToBase1(PIr.CurncyCode,POr.TransDate,PIr.PurPrice,DefaultCurRoundOff);
      price = DivRateToBase1(POr.CurncyCode,t,POr.FrRate,POr.ToRateB1,POr.ToRateB2,POr.BaseRate1,POr.BaseRate2,DefaultCurRoundOff);
    end;
    vatcode = "";;
    GetItemVATCode(POrw.ArtCode,POr.ExportFlag,vatcode,false);
    POrw.Price = price;
    POrw.VEArtCode = PIr.VEItemCode;
    POrw.Spec = PIr.Comment;
    POrw.VATCode = vatcode;
    if (itemfound) then begin 
      if (blank(POrw.Objects)) then begin
        POrw.Objects = FindINObjects(INr.Objects,INr.Group);
      end;
    end;
    POrw.PIFactor = PIr.PIFactor;
    DivPIFactor(POrw.Quant,POrw.PIFactor,t);
    POrw.VEQuant = t;
    INr.Code = POrw.ArtCode;
/*    
    rwcnt = MatRowCnt(PIr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(PIr,i,PIrw);
      POrw.Spec = PIrw.Text;
      MatRowInsert(POr,rownr+i+1,POrw);
    end;
*/    
  end else begin  
    if (itemfound) then begin
      price = DivRateToBase1(POr.CurncyCode,INr.InPrice,POr.FrRate,POr.ToRateB1,POr.ToRateB2,POr.BaseRate1,POr.BaseRate2,DefaultCurRoundOff);

      vatcode = "";
      GetItemVATCode(POrw.ArtCode,POr.ExportFlag,vatcode,false);
      if (GetItemNameStr(1,tstr,POr.LangCode,INr.Name,INr.Code)) then begin end;
      POrw.Price = price;
      POrw.VEArtCode = "";
      POrw.Spec = tstr;
      POMultiLineText(POr,INr,POr.LangCode,rownr);
      POrw.VATCode = vatcode;
      POrw.PIFactor = blankval;
      POrw.VEQuant = POrw.Quant;
      INr.Code = POrw.ArtCode;
    end else begin
      Beep;
    end;
  end;
  POrw.Objects = FindINObjects(INr.Objects,INr.Group);
  GetINCostAcc(INr,costacc);
  POrw.CostAcc = costacc;
  MatRowPut(POr,rownr,POrw);
  if (chrsum) then begin
    CalcSum(POrw.VEQuant,POrw.Price,POrw.PriceFactor,POrw.vRebate,t,GenOptRec.UseDiscount);
    RoundRowSum(POr.CurncyCode,POr.PayDeal,"POVc",t);
    if (t!=POrw.Sum) then begin
      chsum = true;
      POrw.Sum = t;
      MatRowPut(POr,rownr,POrw);
    end;
    chsum = true;
  end;
  if (chsum) then begin
    POSumup(POr);
  end;
LPasteIteminPO:;
  RETURN;
END;

global
procedure AddToPO(Array record POVc aPOr,var Integer pocnt,string artcode,string location,Date podate,val levdays,val ordqty)
BEGIN
  record GeneralOptionBlock GenOptRec;
  Integer poi;
  Integer i,rwcnt;
  record PIVc PIr;
  record POVc POr;
  row POVc POrw;
  val t;
  Date planship;

  BlockLoad(GenOptRec);
  planship = AddDay(podate,levdays);
  for (poi=0;poi<pocnt;poi=poi+1) begin
    POr = aPOr[poi];
    if ((POr.Location==location) and (POr.TransDate==podate)/* and (POr.PlanShip==planship)*/) then begin
      rwcnt = MatRowCnt(POr);
      if (rwcnt<200) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(POr,i,POrw);
          if (POrw.ArtCode==artcode) then begin
            POrw.Quant = POrw.Quant + ordqty;
            CalcSum(POrw.VEQuant,POrw.Price,POrw.PriceFactor,POrw.vRebate,t,GenOptRec.UseDiscount);
            RoundRowSum(POr.CurncyCode,POr.PayDeal,"POVc",t);
            if (t!=POrw.Sum) then begin
              POrw.Sum = t;
              MatRowPut(POr,i,POrw);
              POSumup(POr);
              aPOr[poi] = POr;
              goto LAddToPO;
            end;
          end;
        end;
        if (GetPurchaseItem(artcode,POr.Location,PIr)) then begin
          if (PIr.VECode==POr.VECode) then begin
            PasteIteminPO(artcode,ordqty,POr,rwcnt,true);
            aPOr[poi] = POr;
            goto LAddToPO;
          end;
        end;
      end;
    end;
  end;
  RecordNew(POr);
  POr.Location = location;
  POr.TransDate = podate;
  POr.PlanShip = planship;
  PasteIteminPO(artcode,ordqty,POr,0,true);
  aPOr[pocnt] = POr;
  pocnt = pocnt + 1;
LAddToPO:;
  RETURN;
END;

global
Function Boolean TestPrognosis(string filename,record INProgVc INProgr,record RcVc RepSpec,var record INVc INr,string fritem,string toitem,var Boolean TrHs,Boolean bydate)
begin
  Boolean testf;

  testf = true;
  if (INProgr.FileName<>filename) then begin
    TrHs = false;
  end;
  if (RepSpec.sStartDate>INProgr.OrderDate) or (RepSpec.sEndDate<INProgr.OrderDate) then begin
    if (bydate) then begin
      TrHs = false;
    end else begin
      testf = false;
    end;
  end;
  if (TrHs==false) then begin
    testf = false;
  end;
  if (nonblank(RepSpec.f1)) then begin
    if (INProgr.ItemCode < fritem) then begin
      testf = false;
    end;
    if (INProgr.ItemCode > toitem) then begin
      testf = false;
    end;
  end;
  if (nonblank(RepSpec.f3)) then begin
    if (INProgr.Location <> RepSpec.f3) then begin
      testf = false;
    end;
  end;
  if (testf) then begin
    INr.Code = INProgr.ItemCode;
    if (ReadFirstMain(INr,1,true)) then begin
      if (nonblank(RepSpec.f2)) and (INr.Group<>RepSpec.f2) then begin
        testf=false;
      end;
    end;
  end;
  TestPrognosis = testf;
  return;
end;

global
updating procedure PurchProgRn(record RcVc RepSpec)
BEGIN
  PurchProg(RepSpec,0);
  return;
end;

global
updating procedure PurchProgMn(record RcVc RepSpec)
BEGIN
  DBFlush;
  DBHold;
  PurchProg(RepSpec,1);
  return;
end;

global
updating procedure PurchProgEn(record RcVc RepSpec)
BEGIN
  ExportString(USetStr(13760));
  ExportString(USetStr(13761));
  ExportString(USetStr(13762));
  ExportString(USetStr(13763));
  ExportString(USetStr(13764));
  ExportString(USetStr(13765));
  ExportString(USetStr(13766));
  ExportString(USetStr(13767));
  ExportString(USetStr(13768));
  ExportString(USetStr(13769));
  ExportString(USetStr(13770));
  ExportString(USetStr(13771));
  ExportString(USetStr(13772));
  ExportString(USetStr(13773));
  ExportString(USetStr(13774));
  NewLine;
  PurchProg(RepSpec,2);
  return;
end;
