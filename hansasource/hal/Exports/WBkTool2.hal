external function Integer CountObjects(string);
external function val FindAccTurnover(string,string,date,date,record ObjBalVc,Integer,Integer,string,Integer);
external procedure ExtractObj(string,var Integer,var string);
external function LongInt CalcCombination(Integer,Integer);

function Boolean FindStringInString(string a, string b)
BEGIN
  Boolean res,l99f;
  Integer i,j,l;
  string 255 a1,b1,tstr;
  
  res = false;
  b1 = b;
  a1 = a;
  l = len(a) - len(b);
  tstr = a1;
  l99f = false;
  for (i=0;i<=l;i=i+1) begin
    if (len(a1)>=len(b)) then begin 
      tstr = Left(a1,len(b)); 
    end else begin
      l99f = false;
      i = l+1;        
    end;   
    if (tstr==b) then begin 
      res = true; 
      l99f = true;
      i = l+1;
    end;
    a1 = Right(a1,len(a1)-1);
  end;
  if (l99f==false) then begin
    a1 = a;
    l = len(a) - len(b);
    tstr = a1;
    for (i=0;i<=l;i=i+1) begin
      if (len(a1)>=len(b)) then begin 
        tstr = Right(a1,len(a)-len(b)); 
      end else begin
        l99f = false;
        i = l+1;        
      end;  
      if (tstr==b) then begin 
        res = true;
        l99f = false;
        i = l+1;        
      end;
      a1 = Left(a1,len(a1)-1);    
    end;      
  end;
  FindStringInString = res;
  RETURN;
END;

global
function Boolean CheckWBobjstreq(string objs,string teststr)
BEGIN
  Boolean res;
  string 255 oneobj;
  Integer i,ocnt,pos;
  
  i = 1;
  res = true;
  ocnt = CountObjects(teststr);
  while ((i<=ocnt) and (res)) begin
    ExtractObj(teststr,pos,oneobj);
    if (SetInSet(oneobj,objs)==false) then begin   
      res = false;
    end;
    i = i + 1;
  end;
  CheckWBobjstreq = res;
  RETURN;
END;

global
procedure ExportWB1AHeader(Record RcVc RepSpec)
BEGIN
  record BaseCurBlock bascur;
  record CYBlock CompYear;
  string 255 tstr;
  
  BlockLoad(CompYear);
  BlockLoad(bascur);
  tstr ="Reporting Currency";

  ExportString(CompYear.CompName);
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("");
  ExportString("Report 1 - A");
  NewLine;
  ExportString("Project Sources & Uses of Funds");
  NewLine;
  ExportPadString("For the Period : ", len("For the Period")+1," ", false);
  ExportPadString(RepSpec.Period2Str,len(RepSpec.Period2Str)+2," ",false);
  NewLine;
  if (RepSpec.basecurncy == 0) then begin
    ExportPadString(tstr & " : ", len(tstr)+1," ", false);
    ExportPadString(bascur.BaseCur1,len(bascur.BaseCur1)+2," ",false);
  end;
  if (RepSpec.basecurncy == 1) then begin
    ExportPadString(tstr & " : ", len(tstr)+1," ", false);
    ExportPadString(bascur.BaseCur2,len(bascur.BaseCur2)+2," ",false);
  end;
  NewLine;
  NewLine;
  ExportString("");
  ExportString("");
  ExportString("Actual");
  ExportString("");
  ExportString("");
  ExportString("Planned");
  ExportString("");
  ExportString("");
  ExportString("Variance");
  ExportString("");
  NewLine;
  ExportString("");
  ExportString("Current");
  ExportString("Year");
  ExportString("Cumulative");
  ExportString("Current");
  ExportString("Year");
  ExportString("Cumulative");
  ExportString("Current");
  ExportString("Year");
  ExportString("Cumulative");
  ExportString("Life of");
  NewLine; 
  ExportString("");
  ExportString("Quarter");
  ExportString("To-Date");
  ExportString("To-Date");
  ExportString("Quarter");
  ExportString("To-Date");
  ExportString("To-Date");
  ExportString("Quarter");
  ExportString("To-Date");
  ExportString("To-Date");
  ExportString("Project");
  NewLine;
  NewLine;

  RETURN;
END;

/*e.g. I have 3 objects in objs. Number of combination of 2 objects from 3 {(3over2) = 3!/[(3-2)!2! = 1*2*3/1*1*2] } = 3.
 objcnt = 3, 
 i = 1 - I get 1st and 2nd object;nothing in mod; comapos loop finds first coma in instr
 i = 2 - I get 1st and 3rd object; nothing in mod; comapos loop finds second coma in instr
 i = 3 - I get 2nd and 3rd object; mod==0, I change instr - remove first object, now I have 2 objects in instr; comapos loop finds first coma in instr
 */
 /*
 A,B,C,D
 e.g. I have 4 objects in objs. Number of combination of 2 objects from 4 [(4over2)] = 6.
 objcnt = 4, combnr = 6 
 i = 1 - I get 1st and 2nd object(A,B);nothing in mod; comapos loop finds first coma in instr
 i = 2 - I get 1st and 3rd object(A,C); nothing in mod; comapos loop finds second coma in instr
 i = 3 - I get 1st and 4th object(A,D); nothing in mod; comapos loop finds third coma in instr
 i = 4 - I get 2nd and 3rd object(B,C); mod==0, I change instr - remove first object, now I have 3 objects in instr; comapos loop finds first coma in instr;
 B,C,D
 combi = 2, objcnt = 3, combnr = 3
 i = 2 - I get 1st and 3rd object(B,D); nothing in mod; comapos loop finds first coma in instr;
 i = 3 - I get 2nd and 3rd object(C,D); mod==0, I change instr - remove first object, now I have 2 objects in instr; comapos loop finds first coma in instr
 C,D
 combi = 2, objcnt = 2, combnr = 1
 */ 
/*e.g. I have 5 objects in objs. Number of combination of 2 objects from 5 [(5over2)] = 10.

 A,B,C,D,E
 objcnt = 5,  
 i = 1 - I get 1st and 2nd object(A,B);nothing in mod; comapos loop finds first coma in instr; 
 i = 2 - I get 1st and 3rd object(A,C); nothing in mod; comapos loop finds second coma in instr;
 i = 3 - I get 1st and 4th object(A,D); nothing in mod; comapos loop finds third coma in instr;
 i = 4 - I get 1st and 5th object(A,E); nothing in mod; comapos loop finds fourth coma in instr; 
 i = 5 - I get 2nd and 3rd object(B,C); mod==0, I change instr - remove first object, now I have 4 objects in instr; comapos loop finds first coma in instr;modifyobjcnt = 1;objcnt - modifyobjcnt= 4;
 B,C,D,E
 combi = 2, objcnt = 4, combnr = 6 
 i = 2 - I get 1st and 3rd object(B,D); nothing in mod; comapos loop finds first coma in instr
 i = 3 - I get 1st and 4th object(B,E); nothing in mod; comapos loop finds second coma in instr
 i = 4 - I get 2nd and 3rd object(C,D); mod==0, I change instr - remove first object, now I have 3 objects in instr; comapos loop finds first coma in instr;
 C,D,E
 combi = 2, objcnt = 3, combnr = 3 
 i = 2 - I get 1st and 3rd object(C,E); nothing in mod; comapos loop finds first coma in instr;
 i = 3 - I get 2nd and 3rd object(D,E); mod==0, I change instr - remove first object, now I have 2 objects in instr; comapos loop finds first coma in instr
 D,E
 combi = 2, objcnt = 2, combnr = 1 
 */ 
  
/*e.g. I have 5 objects in objs. Number of combination of 3 objects from 5 [(5over3)] = 10.
no procedure right now, not needed right now
 A,B,C,D,E
 objcnt = 5,  
 i = 1 - I get 1st and 2nd and 3rd object(A,B,C);nothing in mod; comapos loop finds first coma in instr; 
 i = 2 - I get 1st and 2rd and 4th object(A,B,D); nothing in mod; comapos loop finds second coma in instr;
 i = 3 - I get 1st and 2th and 5th object(A,B,E); nothing in mod; comapos loop finds third coma in instr;
 object(A,C,D)
 object(A,C,E)
 object(A,D,E)
 B,C,D,E
 object(B,C,D)
 object(B,C,E)
 object(B,D,E)
 C,D,E
 object(C,D,E)
 */  
global
procedure WBGetObjectPair(var string instr,var string pairstr,var Integer objslen,var LongInt combnr,var Integer combi,var Integer objcnt,var Integer comapos,var Integer pos)
BEGIN
  Boolean testf;
  Integer i,j;
  string 255 ostr,tstr;
   
  testf = false; 
  for (i=combi;i<=combnr;i=i+1) begin
    if (Mod(i,objcnt)==0) then begin
      pos = 0;
      ExtractObj(instr,pos,tstr);
      instr = Right(instr,len(instr)-pos);
      comapos = 0;
      objslen = len(instr);
      testf = true; 
      objcnt = CountObjects(instr);  
      combnr = CalcCombination(objcnt,2);
    end;
    for (j=(comapos+1);j<=objslen;j=j+1) begin
      if (CharacterMatch(instr,",",j)) then begin
        comapos = j;
        j = objslen + 1;//the end of for loop
      end;      
    end;
    pos = 0;
    ExtractObj(instr,pos,tstr);
    ostr = ostr & tstr & ",";
    pos = comapos;
    ExtractObj(instr,pos,tstr);
    ostr = ostr & tstr;
    combi = i+1; 
    goto L88;
  end;    
L88:; 
  if (testf) then begin combi = 2; end;
  pairstr = ostr;
  RETURN;
END;

global
procedure FindobjstrBudgetKey(Date sStartDate,string objstr,var val bkey)
BEGIN
  record Bud1Vc Bud1r;
  record BFVc BFr;
  Boolean TrHs,testf;
  
  bkey = 0;
  TrHs = true;
  Bud1r.Objects = objstr;
  while (LoopKey("ObjAccKey",Bud1r,1,TrHs)) begin    
    if (Bud1r.Objects<>objstr) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
      if (DateInRange(sStartDate,Bud1r.StartDate,Bud1r.EndDate)==false) then begin testf = false; end;
      if (testf) then begin
        if (nonblank(Bud1r.BFCode)) then begin
          BFr.BFCode = Bud1r.BFCode;
          if (ReadFirstMain(BFr,1,true)) then begin
            bkey = BFr.Sum;
          end;
          TrHs = false;
        end;
      end;      
    end;
  end;
  RETURN;  
END;

global
procedure FindWB1DobjstrFwdBalance(string accnumber,string objstr,Date sStartDate,Integer basecurncy,var val fwd)
BEGIN
  record TRVc TRr;
  row TRVc TRrw;
  Integer i,rwcnt;
  Boolean TrHs;
  
  fwd = 0;
  TrHs = true;
  while (LoopKey("TransDate",TRr,1,TrHs)) begin
    if (TRr.TransDate>=sStartDate) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      rwcnt = MatRowCnt(TRr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(TRr,i,TRrw);
        if (CheckWBobjstreq(TRrw.Objects,objstr)) then begin
          if (basecurncy==0) then begin
            fwd = fwd + TRRw.DebVal;
            fwd = fwd - TRRw.CredVal;
          end else begin
            fwd = fwd + TRRw.DebVal2;
            fwd = fwd - TRRw.CredVal2;
          end;          
        end;
      end;
    end;
  end;  
  RETURN;
END;

global
function Boolean CheckObjInObjs(string objcode,string objstr)
BEGIN
  record ObjVc Objr;
  Boolean found;
  Boolean res,TrHs;
  string 255 ostr;
  Integer pos;
  
  res = false;
  TrHs = true;
  pos = 0;  
  ExtractObj(objstr,pos,ostr);
  while (nonblank(ostr) and TrHs) begin
    if (objcode==ostr) then begin
      res = true;
      TrHs = false;
    end;
    ExtractObj(objstr,pos,ostr);
  end;
  CheckObjInObjs = res;
  RETURN; 
END;

global
procedure GetObjectName(string objcode,var string name)
BEGIN
  record ObjVc Objr;
  
  name = "";
  Objr.Code = objcode;
  if (ReadFirstMain(Objr,1,true)) then begin
    name = Objr.Comment;
  end;
  RETURN;
END;

global
procedure AddWBTotVals(val accv1,val accv2,val accv3,val b1,val b2,val b3,var val taccv1,var val taccv2,var val taccv3,var val tb1,var val tb2,var val tb3)
BEGIN
  taccv1 = taccv1 + accv1;
  taccv2 = taccv2 + accv2;
  taccv3 = taccv3 + accv3;
  tb1 = tb1 + b1;
  tb2 = tb2 + b2;
  tb3 = tb3 + b3;
  RETURN;
END;

global
procedure FindOneObjectBalance(record RcVc RepSpec,string objstr,var val resv)
BEGIN
  record ObjBalVc ObjBalr;
  Boolean TrHs;
  val t;
  
  resv = 0;
  ObjBalr.Object = objstr;
  TrHs = true;
  while (LoopKey("ObjAccKey",ObjBalr,1,TrHs)) begin    
    if (ObjBalr.Object<>objstr) then begin TrHs = false; end;
    if (TrHs) then begin
      t = FindAccTurnover(ObjBalr.AccNumber,objstr,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,
                           0,RepSpec.basecurncy,"",0);
      resv = resv + t;
    end;
  end;
  RETURN;  
END;

global
procedure WB1DExportObjTotals(string objstr,var val ototdebval,var val otott1,var val ototdkey,var val ototfwd,var val otott2,var val otott3)
BEGIN
  val diff,fwd;
  string 255 tstr;
 
  if (objstr == "Total") then begin
 	tstr = "Total";
 end else begin 	
 	 GetObjectName(objstr,tstr);
  end;
  ExportString(tstr);
  ExportVal(ototdebval,M4Val);
  ExportVal(otott1,M4Val);
  diff = ototdebval - otott1;
  ExportVal(diff,M4Val);
  ExportString("");
  ExportVal(ototdkey,M4Val);
  ExportVal(ototfwd,M4Val);
  fwd = ototdkey + ototfwd;
  ExportVal(fwd,M4Val);
  ExportVal(otott2,M4Val);
  ExportVal(otott3,M4Val);

  ExportVal(fwd-otott2-otott3,M4Val);
  ExportVal(ototdebval-ototdkey,M4Val);
  ExportVal(0,M4Val);
  ExportVal(ototdebval-ototdkey-0,M4Val);
  NewLine; 
  NewLine; 
/*  ototdebval = 0;
  otott1 = 0;
  ototdkey = 0;
  ototfwd = 0;
  otott2 = 0;
  otott3 = 0;  */
  RETURN;  
END;
