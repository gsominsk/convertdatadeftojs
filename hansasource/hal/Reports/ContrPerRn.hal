external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);

procedure CalcPeriodic(val newmonth,val cSum,var val m1,var val m2,
    var val m3,var val m4,var val m5,var val m6,var val m7,var val m8,var val m9,
    var val m10,var val m11,var val m12)
begin

  if (newmonth == 1) then begin
    m1 = m1 + cSum;
  end;
 if (newmonth == 2) then begin
    m2 = m2 + cSum;
  end;
 if (newmonth == 3) then begin
    m3 = m3 + cSum;
  end;
 if (newmonth == 4) then begin
    m4 = m4 + cSum;
  end;
 if (newmonth == 5) then begin
    m5 = m5 + cSum;
  end;
 if (newmonth == 6) then begin
    m6 = m6 + cSum;
  end;
 if (newmonth == 7) then begin
    m7 = m7 + cSum;
  end;
 if (newmonth == 8) then begin
    m8 = m8 + cSum;
  end;
 if (newmonth == 9) then begin
    m9 = m9 + cSum;
  end;
 if (newmonth == 10) then begin
    m10 = m10 + cSum;
  end;
 if (newmonth == 11) then begin
    m11 = m11 + cSum;
  end;
 if (newmonth == 12) then begin
    m12 = m12 + cSum;
  end;

  return;
end;

procedure FindContracts(string Class,var val m1,var val m2,var val m3,
   var val m4,var val m5,var val m6,var val m7,var val m8,var val m9,var val m10,
   var val m11,var val m12)
begin
  record COVc COr;
  Boolean TrHs, testf;
  val tcola1;
  string 2 newmonth;
  string 255 newdate;
  val nnewmonth;
  val CSum;
  Integer i;
  
  TrHs = true;
  COr.ContractClass = Class;
  while (LoopKey("ContractClass",COr,1,TrHs)) begin
    if (TrHs) then begin
      if (COr.ContractClass <> Class) then begin
        TrHs = false;
      end;
    end;  
    if (TrHs) then begin
      testf = true;
      if (COr.OKFlag == 0) then begin
        testf = false;
      end;
      if (testf) then begin
        if (COr.invDtype == 0) then begin
          newdate = AddDay(COr.startDate,-COr.invDays);
        end;
        if (COr.invDtype == 1) then begin
          newdate = AddDay(COr.startDate,COr.invDays);
        end;
        newmonth = GetMonth(newdate);
        nnewmonth = StringToVal(newmonth,M40Val);
        if (nonblank(COr.CurncyCode)) then begin
          CSum = MulRateToBase1(COr.CurncyCode,COr.Sum1,COr.FrRate,COr.ToRateB1,COr.ToRateB2,COr.BaseRate1,COr.BaseRate2,DefaultCurRoundOff);
        end else begin
          CSum = COr.Sum1;
        end;
        switch (COr.perType) begin
          case 0:
            i = GetMonth(newdate);
            while (i<=12) begin
              CalcPeriodic(i,CSum,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);  
              i = i + 1;
              if (GetMonth(AddMonth(newdate,i-1))>GetMonth(COr.endDate)) then begin
                i = 13;
              end;
            end;
          case 1:
            CalcPeriodic(nnewmonth,CSum,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);  
        end;
      end; //testf
    end; //TrHs
  end; //while
 return;
end;

procedure PrintOut(string CClass,val m1,val m2,val m3,val m4,val m5,val m6,val m7,
   val m8,val m9,val m10,val m11,val m12)
begin

  StartFormat(15);
  OutString(0,0,USetStr(8186),false);
  OutString(120,0,CClass,true);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(2781),false);
  OutString(120,0,m1,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2782),false);
  OutString(120,0,m2,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2783),false);
  OutString(120,0,m3,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2784),false);
  OutString(120,0,m4,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2785),false);
  OutString(120,0,m5,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2786),false);
  OutString(120,0,m6,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2787),false);
  OutString(120,0,m7,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2788),false);
  OutString(120,0,m8,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2789),false);
  OutString(120,0,m9,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2790),false);
  OutString(120,0,m10,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2791),false);
  OutString(120,0,m11,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2792),false);
  OutString(120,0,m12,true);
  EndFormat;
  Gray_Divider(0,1);
  return;
end;

procedure PrintOut2(string CClass,val m1,val m2,val m3,val m4,val m5,val m6,val m7,
   val m8,val m9,val m10,val m11,val m12)
begin

  StartFormat(15);
  OutString(0,0,CClass,false);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(2781),false);
  OutString(120,0,m1,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2782),false);
  OutString(120,0,m2,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2783),false);
  OutString(120,0,m3,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2784),false);
  OutString(120,0,m4,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2785),false);
  OutString(120,0,m5,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2786),false);
  OutString(120,0,m6,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2787),false);
  OutString(120,0,m7,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2788),false);
  OutString(120,0,m8,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2789),false);
  OutString(120,0,m9,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2790),false);
  OutString(120,0,m10,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2791),false);
  OutString(120,0,m11,true);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2792),false);
  OutString(120,0,m12,true);
  EndFormat;
  Gray_Divider(0,1);
  return;
end;
 

 
procedure AddToTotals(val m1,val m2,val m3,val m4,val m5,val m6,val m7,val m8,val m9,val m10,val m11,
  val m12,var val tm1,var val tm2,var val tm3,var val tm4,var val tm5,var val tm6,var val tm7,
  var val tm8,var val tm9,var val tm10,var val tm11,var val tm12) 
begin
   tm1 = tm1 + m1;
   tm2 = tm2 + m2;
   tm3 = tm3 + m3;
   tm4 = tm4 + m4;
   tm5 = tm5 + m5;
   tm6 = tm6 + m6;
   tm7 = tm7 + m7;
   tm8 = tm8 + m8;
   tm9 = tm9 + m9;
   tm10 = tm10 + m10;
   tm11 = tm11 + m11;
   tm12 = tm12 + m12;

  return;
end;
 
procedure BlankValues(var val m1,var val m2,var val m3,
   var val m4,var val m5,var val m6,var val m7,var val m8,var val m9,var val m10,
   var val m11,var val m12)
begin
  m1 = blankval;
  m2 = blankval;
  m3 = blankval;
  m4 = blankval;
  m5 = blankval;
  m6 = blankval;
  m7 = blankval;
  m8 = blankval;
  m9 = blankval;
  m10 = blankval;
  m11 = blankval;
  m12 = blankval;
  
  return;
end;

global
procedure ContrPer2Rn(record RcVc RepSpec) 
begin
  record ContractClassBlock CClassr;
  row ContractClassBlock CClassrw;
  val m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12;
  val tm1,tm2,tm3,tm4,tm5,tm6,tm7,tm8,tm9,tm10,tm11,tm12;
  integer i, rwcnt;
  string 255 tstr;
  
  StartReportJob("Contract Invoicing per month");
  if (nonblank(RepSpec.f2)) then begin
    tstr = USetStr(8186);
    tstr = tstr & RepSpec.f2; 
    Header(1,tstr,1)
  end else begin
    tstr = USetStr(8317);
    Header(1,tstr,1);
  end;
  EndHeader;
  
  if (blank(RepSpec.f2)) then begin
    BlockLoad(CClassr);
    rwcnt = MatRowCnt(CClassr);
    for (i=0;i<=rwcnt;i=i+1) begin
      MatRowGet(CClassr,i,CClassrw);
      if (nonblank(CClassrw.Code)) then begin
        FindContracts(CClassrw.Code,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);
        PrintOut(CClassrw.Code,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);
        AddToTotals(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,tm1,tm2,tm3,tm4,tm5,tm6,tm7,tm8,tm9,tm10,tm11,tm12);
        BlankValues(m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);
      end;
    end;
    PrintOut2(USetStr(3560),tm1,tm2,tm3,tm4,tm5,tm6,tm7,tm8,tm9,tm10,tm11,tm12);
  end;
  if (nonblank(RepSpec.f2)) then begin
    FindContracts(RepSpec.f2,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);
    PrintOut(RepSpec.f2,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12);
  end;
  EndJob;
  return;
end;
