external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure HTSuppGroup(string,var string);
external procedure HTLocations(string, string, var string);
external procedure HTItems(string,var string);
external procedure HTITs(string,string,var string);
external procedure HTVends(string, string, var string);
external procedure HT2Per(Date, Date , var string);

procedure VEAnaHeader(record RcVc RepSpec)
begin
  Integer rw;
  string 255 tstr;
  string 255 frloc,toloc;
  string 255 frit,toit;
  string 255 frve,tove;
  
  frloc = FirstInRange(RepSpec.f3,20);
  toloc = LastInRange(RepSpec.f3,20);
  frit = FirstInRange(RepSpec.LastAcc,20);
  toit = LastInRange(RepSpec.LastAcc,20);
  frve = FirstInRange(RepSpec.f1,20);
  tove = LastInRange(RepSpec.f1,20);

  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;  
  HTVends(frve,tove,tstr);
  Header(rw,tstr,0);
  HTSuppGroup(RepSpec.FirstAcc,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTItems(RepSpec.f2,tstr);
  Header(rw,tstr,0);  
  HTITs(frit,toit,tstr);
  Header(rw,tstr,1);
  rw = rw + 1; 
  if (nonblank(RepSpec.LastAcc)) then begin
    HTLocations(frloc,toloc,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  return;
end;

procedure PurchaseOrdersInPeriod(record RcVc RepSpec,string vecode,string artcode,var val poqty,var val posum)
begin
  Boolean found;
  record POVc POr;
  row POVc POrw;
  Integer i,rwcnt;
//can be improved with index over matrix rows  
  
  poqty = blankval;
  posum = blankval;
  found = true;
  POr.VECode = vecode;
  POr.TransDate = RepSpec.sStartDate;
  while (LoopKey("VECodeTransDate",POr,2,found)) begin
    if (POr.VECode!=vecode) then begin found = false; end;
    if (POr.TransDate>RepSpec.sEndDate) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(POr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(POr,i,POrw);
        if (POrw.ArtCode==artcode) then begin
          poqty = poqty + POrw.Quant;
          posum = posum + MulRateToBase1(POr.CurncyCode,POrw.Sum,POr.FrRate,POr.ToRateB1,POr.ToRateB2,POr.BaseRate1,POr.BaseRate2,DefaultCurRoundOff);
        end;
      end;
    end;
  end;
  return;
end;

procedure GoodsReceiptsInPeriod(record RcVc RepSpec,string vecode,string artcode,var val puqty,var val pusum)
begin
  val res;
  record PUVc PUr;
  row PUVc PUrw;
  Integer i,rwcnt;
  Boolean found;
//can be improved with index over matrix rows or adding suuplier to ItemHistVc
  
  puqty = blankval;
  pusum = blankval;
  found = true;
  PUr.VECode = vecode;
  PUr.TransDate = RepSpec.sStartDate;
  while (LoopKey("VECodeTransDate",PUr,2,found)) begin
    if (PUr.VECode!=vecode) then begin found = false; end;
    if (PUr.TransDate>RepSpec.sEndDate) then begin found = false; end;
    if (found) then begin
      rwcnt = MatRowCnt(PUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(PUr,i,PUrw);
        if (PUrw.ArtCode==artcode) then begin
          puqty = puqty + PUrw.Quant;
          pusum = pusum + PUrw.Quant*PUrw.CostPrice;
        end;
      end;
    end;
  end;
  return;
end;

procedure FindSourceSource(record ItemHistVc sourceIHr)
begin
  record ItemHistVc IHr;
  record ItemHistVc IH2r;
  Boolean found,TrHs;
  LongInt source;
  
  source = sourceIHr.Source;
  found = true;
  while (found) begin
    IHr.SerNr = source;
    if (ReadFirstMain(IHr,1,true)) then begin
      switch (IHr.FileName) begin
        case "PUVc":
          RecordCopy(IHr,sourceIHr);
          found = false;
        case "ProdVc":
          RecordCopy(IHr,sourceIHr);
          found = false;
        otherwise
          source = IHr.Source;
          if (source<=0) then begin
            ResetLoop(IH2r);
            TrHs = true;
            IH2r.FileName = IHr.FileName;
            IH2r.TransNr = IHr.TransNr;
            IH2r.Row = IHr.Row;
            while (LoopKey("FNTransNr",IH2r,1,TrHs)) begin
              if (IH2r.FileName!=IHr.FileName) then begin TrHs = false; end;
              if (IH2r.TransNr!=IHr.TransNr) then begin TrHs = false; end;
              if (IH2r.Row!=IHr.Row) then begin TrHs = false; end;
              if (TrHs) then begin
                if (IH2r.Source>0) then begin
                  TrHs = false;
                  source = IH2r.Source;
                  found = false;
                end;
              end;
            end;
          end;
      end;
    end else begin
      found = false;
    end;
  end;
  return;
end;

procedure FindCostPriceSource(LongInt Source,record PUVc PUr,record ItemHistVc sourceIHr)
begin
  record ItemHistVc IHr;
  record ProdVc Prodr;

  RecordNew(PUr);
  sourceIHr.SerNr = Source;
  if (ReadFirstMain(sourceIHr,1,true)) then begin
    switch (sourceIHr.FileName) begin
      case "PUVc": ;
      case "ProdVc": ;
      otherwise
        FindSourceSource(sourceIHr);
    end;
    switch (sourceIHr.FileName) begin
      case "PUVc":
        PUr.SerNr = sourceIHr.TransNr;
        if (ReadFirstMain(PUr,1,true)) then begin end;
      case "ProdVc":
        Prodr.SerNr = sourceIHr.TransNr;
        if (ReadFirstMain(Prodr,1,true)) then begin end;
//what to do with Productions        
    end;
  end else begin
  end;
  return;
end;

procedure FindCostPriceSource_Deliveries(string vecode,LongInt OrderNr,LongInt OrdRow,record PUVc PUr,record ItemHistVc combinedsourceIHr)
begin
  record ItemHistVc IHr;
  record ItemHistVc sourceIHr;
  record ProdVc Prodr;
  record SHVc SHr;
  row SHVc SHrw;
  Boolean found,testf,foundIH;
  Integer shrow,shrwcnt;

  if (OrderNr<=0) then begin
    goto LFindCostPriceSource_Deliveries;
  end;
  RecordNew(PUr);
  RecordNew(combinedsourceIHr);
  found = true;
  SHr.OrderNr = OrderNr;
  while (LoopKey("OrderKey",SHr,1,found)) begin
    if (SHr.OrderNr!=OrderNr) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (SHr.OKFlag==0) then begin testf = false; end;
      if (testf) then begin
        shrwcnt = MatRowCnt(SHr);
        for (shrow=0;shrow<shrwcnt;shrow=shrow+1) begin
          MatRowGet(SHr,shrow,SHrw);
          ResetLoop(IHr);
          foundIH = true;
          IHr.FileName = "SHVc";
          IHr.TransNr = SHr.SerNr;
          IHr.Row = shrow;
          while (LoopKey("FNTransNr",IHr,3,foundIH)) begin
            if (IHr.FileName!="SHVc") then begin foundIH = false; end;
            if (IHr.TransNr!=SHr.SerNr) then begin foundIH = false; end;
            if (IHr.Row!=shrow) then begin foundIH = false; end;
            if (foundIH) then begin
              testf = true;
              if (IHr.Invalid!=0) then begin testf = false; end;
              if (testf) then begin
                sourceIHr.SerNr = IHr.Source;
                if (ReadFirstMain(sourceIHr,1,true)) then begin
                  RecordNew(PUr);
                  switch (sourceIHr.FileName) begin
                    case "PUVc": ;
                    case "ProdVc": ;
                    otherwise
                      FindSourceSource(sourceIHr);
                  end;
                  switch (sourceIHr.FileName) begin
                    case "PUVc":
                      PUr.SerNr = sourceIHr.TransNr;
                      if (ReadFirstMain(PUr,1,true)) then begin end;
                    case "ProdVc":
                      Prodr.SerNr = sourceIHr.TransNr;
                      if (ReadFirstMain(Prodr,1,true)) then begin end;
              //what to do with Productions        
                  end;
                  if (PUr.VECode==vecode) then begin
                    combinedsourceIHr.TotCostPrice = combinedsourceIHr.TotCostPrice + sourceIHr.TotCostPrice;
                    combinedsourceIHr.Qty = combinedsourceIHr.Qty + sourceIHr.Qty;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;  
LFindCostPriceSource_Deliveries:;  
  return;
end;

procedure SalesInPeriod(record RcVc RepSpec,string vecode,record INVc INr,record OrdSettBlock OSb,var val ivqty,var val ivsum,var val costofsales)
begin
  record ItemHistVc sourceIHr;
  record ItemHistVc IHr;
  record IVVc IVr;
  row IVVc IVrw;
  record PUVc PUr;
  Boolean found,testf,ivrowreadf;
  val v;
  
  ivqty = blankval;
  ivsum = blankval;
  costofsales = blankval;

  found = true;
  IHr.FileName = "IVVc";
  IHr.ArtCode = INr.Code;
  IHr.TransDate = RepSpec.sStartDate;
  while (LoopKey("FNArtCode",IHr,3,found)) begin
    if (IHr.FileName!="IVVc") then begin found = false; end;
    if (IHr.ArtCode!=INr.Code) then begin found = false; end;
    if (IHr.TransDate>RepSpec.sEndDate) then begin found = false; end;
    if (found) then begin
      ivrowreadf = false;
      testf = true;
      if (testf) then begin
        ClearRow(IVr,IVrw,1);
        if (IHr.Source>0) then begin
          FindCostPriceSource(IHr.Source,PUr,sourceIHr);
        end else begin
          IVr.SerNr = IHr.TransNr;
          if (ReadFirstMain(IVr,1,true)) then begin
            if (IHr.Row<MatRowCnt(IVr)) then begin
              MatRowGet(IVr,IHr.Row,IVrw);
              ivrowreadf = true;
            end;
            if (IVr.OrderNr>0) and (IVrw.OrdRow>=0) then begin
              FindCostPriceSource_Deliveries(vecode,IVr.OrderNr,IVrw.OrdRow,PUr,sourceIHr);
            end else begin
              FindCostPriceSource(IHr.Source,PUr,sourceIHr);
            end;
          end;
        end;

//StopAlert("sourceIHr.SerNr " & sourceIHr.SerNr & " sourceIHr.File " & sourceIHr.FileName);
        if (vecode==PUr.VECode) then begin
          if (ivrowreadf==false) then begin
            IVr.SerNr = IHr.TransNr;
            if (ReadFirstMain(IVr,1,true)) then begin
              if (IHr.Row<MatRowCnt(IVr)) then begin
                MatRowGet(IVr,IHr.Row,IVrw);
              end;
            end;
          end;

          v = MulRateToBase1(IVr.CurncyCode,IVrw.Sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
          v = (v*(-IHr.Qty))/IVrw.Quant;

          ivqty = ivqty - IHr.Qty;
          ivsum = ivsum + v;
          
          switch (RepSpec.flags[2]) begin
            case 0:
              costofsales = costofsales + INr.InPrice*(-IHr.Qty);
            case 1:
              costofsales = costofsales + ((sourceIHr.CPTotCost / INr.PriceFactor)*(-IHr.Qty))/sourceIHr.Qty;
            case 2:          
              costofsales = costofsales + (sourceIHr.TotCostPrice*(-IHr.Qty))/sourceIHr.Qty;
          end;
        end;
LSKIPItemHistRecord:;
      end;
    end;
  end;
  return;
end;

procedure PrintItemGroupResults(Integer values,record CUVc VEr,var Boolean veheadf,string itgroup,val poqty,val posum,val puqty,val pusum,val ivqty,val ivsum,val costofsales)
begin
  Boolean printf;
  
  printf = true;
  switch (values) begin
    case 0:
      if (poqty==0) and (puqty==0) and (ivqty==0) then begin
        printf = false;
      end;
    case 1:
      if (posum==0) and (pusum==0) and (ivsum==0) then begin
        printf = false;
      end;
  end;
  if (printf) then begin
    if (veheadf) then begin
      StartFormat(15);
       OutString(0,"DblCUVc",VEr.Code,false);
       OutString(100,0,VEr.Name,false);
      EndFormat;
      StartFormat(15);
        OutString(15,0,USetStr(16627),false);
        OutString(200,0,USetStr(16622),true);
        OutString(270,0,USetStr(16623),true);
        OutString(340,0,USetStr(16624),true);
        switch (values) begin
          case 1:
            OutString(410,0,USetStr(16625),true);
            OutString(480,0,USetStr(16626),true);
        end;
      EndFormat;
      Gray_Divider(0,1);
      veheadf = false;
    end;
    StartFormat(15);
     OutString(15,"DblITVc",itgroup,false);
     switch (values) begin
       case 0:
         OutVal(200,0,poqty,M4Val,true);
         OutVal(270,0,puqty,M4Val,true);
         OutVal(340,0,ivqty,M4Val,true);
       case 1:
         OutVal(200,0,posum,M4Val,true);
         OutVal(270,0,pusum,M4Val,true);
         OutVal(340,0,ivsum,M4Val,true);
         OutVal(410,0,costofsales,M4Val,true);
         OutVal(480,0,ivsum-costofsales,M4Val,true);
     end;
    EndFormat;
  end;
  return;
end;

procedure PrintItemResults(Integer values,record CUVc VEr,var Boolean veheadf,record INVc INr,val poqty,val posum,val puqty,val pusum,val ivqty,val ivsum,val costofsales)
begin
  Boolean printf;
  
  printf = true;
  switch (values) begin
    case 0:
      if (poqty==0) and (puqty==0) and (ivqty==0) then begin
        printf = false;
      end;
    case 1:
      if (posum==0) and (pusum==0) and (ivsum==0) then begin
        printf = false;
      end;
  end;
  if (printf) then begin
    if (veheadf) then begin
      StartFormat(15);
       OutString(0,"DblCUVc",VEr.Code,false);
       OutString(100,0,VEr.Name,false);
      EndFormat;
      StartFormat(15);
        OutString(15,0,USetStr(16621),false);
        OutString(200,0,USetStr(16622),true);
        OutString(270,0,USetStr(16623),true);
        OutString(340,0,USetStr(16624),true);
        switch (values) begin
          case 1:
            OutString(410,0,USetStr(16625),true);
            OutString(480,0,USetStr(16626),true);
        end;
      EndFormat;
      Gray_Divider(0,1);
      veheadf = false;
    end;
    StartFormat(15);
     OutString(15,"DblINVc",INr.Code,false);
     switch (values) begin
       case 0:
         OutVal(200,0,poqty,M4Val,true);
         OutVal(270,0,puqty,M4Val,true);
         OutVal(340,0,ivqty,M4Val,true);
       case 1:
         OutVal(200,0,posum,M4Val,true);
         OutVal(270,0,pusum,M4Val,true);
         OutVal(340,0,ivsum,M4Val,true);
         OutVal(410,0,costofsales,M4Val,true);
         OutVal(480,0,ivsum-costofsales,M4Val,true);
     end;
    EndFormat;
  end;
  return;
end;

procedure PrinTotals(Integer values,Integer s,val poqty,val posum,val puqty,val pusum,val ivqty,val ivsum,val costofsales)
begin
  Boolean printf;
  
  printf = true;
  switch (values) begin
    case 0:
      if (poqty==0) and (puqty==0) and (ivqty==0) then begin
        printf = false;
      end;
    case 1:
      if (posum==0) and (pusum==0) and (ivsum==0) then begin
        printf = false;
      end;
  end;
  if (printf) then begin
    Gray_Divider(s,1);
    StartFormat(15);
     switch (values) begin
       case 0:
         OutVal(200,0,poqty,M4Val,true);
         OutVal(270,0,puqty,M4Val,true);
         OutVal(340,0,ivqty,M4Val,true);
       case 1:
         OutVal(200,0,posum,M4Val,true);
         OutVal(270,0,pusum,M4Val,true);
         OutVal(340,0,ivsum,M4Val,true);
         OutVal(410,0,costofsales,M4Val,true);
         OutVal(480,0,ivsum-costofsales,M4Val,true);
     end;
    EndFormat;
  end;
  return;
end;

procedure ItemsLoop(record RcVc RepSpec,record CUVc VEr,record OrdSettBlock OSb,var val totpoqty,var val totposum,var val totpuqty,var val totpusum,var val totivqty,var val totivsum,var val totcostofsales)
begin
  record INVc INr;
  Boolean found,testf,veheadf;
  Integer sort,keys;
  string 255 index;
  string 255 frit,toit;
  string 255 frin,toin;
  string 255 frloc,toloc;
  val poqty,posum;
  val puqty,pusum;
  val ivqty,ivsum,costofsales;
  val itpoqty,itposum;
  val itpuqty,itpusum;
  val itivqty,itivsum;
  val itcostofsales;
  val vepoqty,veposum;
  val vepuqty,vepusum;
  val veivqty,veivsum;
  val vecostofsales;
  string 255 lastitgroup;

  frit = FirstInRange(RepSpec.LastAcc,20);
  toit = LastInRange(RepSpec.LastAcc,20);
  frin = FirstInRange(RepSpec.f2,20);
  toin = LastInRange(RepSpec.f2,20);
  frloc = FirstInRange(RepSpec.f3,20);
  toloc = LastInRange(RepSpec.f3,20);
  veheadf = true;
  
  index = "Code";
  sort = 0;
  keys = 1;
  INr.Code = frin;
  if (blank(RepSpec.f2)) then begin
    if (nonblank(RepSpec.LastAcc)) then begin
      index = "Group";
      sort = 1;
      keys = 1;
      INr.Group = frit;
    end;
  end;
  switch (RepSpec.flags[1]) begin
    case 1:
      index = "Group";
      sort = 2;
      keys = 2;
      INr.Group = frit;
  end;

  found = true;
  while (LoopKey(index,INr,keys,found)) begin
    switch (sort) begin
      case 0:
        if (nonblank(RepSpec.f2)) then begin
          if (INr.Code>toin) then begin found = false; end;
        end;
      case 1:
        if (nonblank(RepSpec.LastAcc)) then begin
          if (INr.Group>toit) then begin found = false; end;
        end;
      case 2:
        if (nonblank(RepSpec.LastAcc)) then begin
          if (INr.Group>toit) then begin found = false; end;
        end;
        if (nonblank(RepSpec.f2)) then begin
          if (INr.Code>toin) then begin found = false; end;
        end;
    end;
    if (found) then begin
      testf = true;
      if (nonblank(RepSpec.f2)) then begin
        if (INr.Code<frin) then begin testf = false; end;
        if (INr.Code>toin) then begin testf = false; end;
      end;
      if (nonblank(RepSpec.LastAcc)) then begin
        if (INr.Group<frit) then begin testf = false; end;
        if (INr.Group>toit) then begin testf = false; end;
      end;
      if (SetInSet(RepSpec.AccStr,INr.DispGroups)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        switch (RepSpec.ArtMode) begin
          case 0:
            PurchaseOrdersInPeriod(RepSpec,VEr.Code,INr.Code,poqty,posum);
            GoodsReceiptsInPeriod(RepSpec,VEr.Code,INr.Code,puqty,pusum);
            SalesInPeriod(RepSpec,VEr.Code,INr,OSb,ivqty,ivsum,costofsales);

            vepoqty = vepoqty + poqty;
            veposum = veposum + posum;
            vepuqty = vepuqty + puqty;
            vepusum = vepusum + pusum;
            veivqty = veivqty + ivqty;
            veivsum = veivsum + ivsum;
            vecostofsales = vecostofsales + costofsales;
            switch (RepSpec.flags[1]) begin
              case 0:
                PrintItemResults(RepSpec.flags[3],VEr,veheadf,INr,poqty,posum,puqty,pusum,ivqty,ivsum,costofsales);
              case 1:
                if (lastitgroup!=INr.Group) then begin
                  PrintItemGroupResults(RepSpec.flags[3],VEr,veheadf,lastitgroup,itpoqty,itposum,itpuqty,itpusum,itivqty,itivsum,itcostofsales);
                  itpoqty = blankval; itposum = blankval; itpuqty = blankval; itpusum = blankval; itivqty = blankval; itivsum = blankval;
                  itcostofsales = blankval;
                end;
                itpoqty = itpoqty + poqty;
                itposum = itposum + posum;
                itpuqty = itpuqty + puqty;
                itpusum = itpusum + pusum;
                itivqty = itivqty + ivqty;
                itivsum = itivsum + ivsum;
                itcostofsales = itcostofsales + costofsales;
            end;
            lastitgroup = INr.Group;
        end;
      end;
    end;
  end;
  switch (RepSpec.flags[1]) begin
    case 1:
      switch (RepSpec.ArtMode) begin
        case 0:
          PrintItemGroupResults(RepSpec.flags[3],VEr,veheadf,lastitgroup,itpoqty,itposum,itpuqty,itpusum,itivqty,itivsum,itcostofsales);
      end;
  end;
  switch (RepSpec.ArtMode) begin
    case 0:
      PrinTotals(RepSpec.flags[3],150,vepoqty,veposum,vepuqty,vepusum,veivqty,veivsum,vecostofsales);

      totpoqty = totpoqty + vepoqty;
      totposum = totposum + veposum;
      totpuqty = totpuqty + vepuqty;
      totpusum = totpusum + vepusum;
      totivqty = totivqty + veivqty;
      totivsum = totivsum + veivsum;
      totcostofsales = totcostofsales + vecostofsales;
  end;
  return;
end;

global
procedure VEAnaRn(record RcVc RepSpec)
begin
  record CUVc VEr;
  Boolean found,testf;
  Integer sort,keys;
  string 255 frve,tove;
  string 40 index;
  val totpoqty,totposum,totpuqty,totpusum,totivqty,totivum,totcostofsales;
  record OrdSettBlock OSb;

  BlockLoad(OSb);

  frve = FirstInRange(RepSpec.f1,20);
  tove = LastInRange(RepSpec.f1,20);

  
  StartReportJob(USetStr(16620));
   VEAnaHeader(RepSpec);
  EndHeader;
  
  index = "VEActCode";
  sort = 0;
  keys = 2;
  VEr.Code = frve;
  if (blank(RepSpec.f1)) then begin
    if (nonblank(RepSpec.FirstAcc)) then begin
      index = "VEActGroup";
      sort = 1;
      keys = 1;
      VEr.VECat = RepSpec.FirstAcc;
    end;
  end;
  found = true;
  while (LoopKey(index,VEr,keys,found)) begin
    switch (sort) begin
      case 0:
        if (nonblank(RepSpec.f1)) then begin
          if (VEr.Code>tove) then begin found = false; end;
          if (VEr.VEType==0) then begin found = false; end;
        end;
      case 1:
        if (VEr.VECat!=RepSpec.FirstAcc) then begin
          found = false;
        end;
    end;
    if (found) then begin
      testf = true;
      if (VEr.VEType==0) then begin testf = false; end;
      if (nonblank(RepSpec.TransStr)) then begin
        if (SetInSet(RepSpec.TransStr,VEr.Classification)==false) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        ItemsLoop(RepSpec,VEr,OSb,totpoqty,totposum,totpuqty,totpusum,totivqty,totivum,totcostofsales);
      end;
    end;
  end;
  VEr.Code = "";
  VEr.Name = USetStr(16628);
  ItemsLoop(RepSpec,VEr,OSb,totpoqty,totposum,totpuqty,totpusum,totivqty,totivum,totcostofsales);

  switch (RepSpec.ArtMode) begin
    case 0:
      PrinTotals(RepSpec.flags[3],0,totpoqty,totposum,totpuqty,totpusum,totivqty,totivum,totcostofsales);
  end;

  EndJob;
  
  return;
end;