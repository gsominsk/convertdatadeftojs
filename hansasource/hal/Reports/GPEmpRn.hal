/* HAL File by Staffan PalopŠŠ */
/*
	
      Report: GP Employees

      Purpose of report:    
      To see per employee, how much the employee has invoiced, how much he costs and how big                                                                                                                                                                                                  
      his profit are. And to show this information split up on projects or on items.
                     	              
*/


external procedure HTArtGroup(string, var string);
external procedure HTItemClass(string,var string);
external function Boolean HasItemClassification();
external function Boolean HasItemGroups();
external function Boolean ItemInItemGroupOrClass(string,string,string);
external procedure HTEmployees(string,string,var string);
external procedure HTProjects(string,string,var string);
external procedure HTDetailLevel(integer,var string);
external procedure HT2Per(date,date,var string);
external procedure HTArts(string,string,var string); 


/*
    Description:
    Prints out a output line in the report.

    input args:
    name       -  the first string that is printed on the line
    invoiced   -  the value printed in the fist column below "Invoived"
    cost       -                           second column below "cost"       
    diff       -  decides what will be printed in columns and in what order
                  
    boolean doformat  -  if true start with begin format and end with end format
                         if false the calling procedure must perform start/end format  
                     
*/
procedure PrintItem(string name,val invoiced,val cost,val diff, boolean doformat) 
begin
  val inv,gpl,outvalue;
  val GP;
  GP = invoiced - cost;
  if(doformat == true) then begin
    StartFormat(15);
  end;
  OutString(200,0,name,true);
  OutVal(300,0,invoiced,M4Val,true);
  if(diff ==0) then begin
    inv = invoiced;
    gpl = GP;
    if(invoiced <> 0) then begin
      outvalue = (gpl * 100) / invoiced;
    end;
    OutVal(380,0,GP,M4Val,true);
    OutVal(460,0,outvalue,M4Prcnt,true);
  end;

  if(diff == 1) then begin	
    outvalue = invoiced - GP;
    OutVal(380,0,outvalue,M4Val,true);
    OutVal(460,0,GP,M4Val,true);
  end;
  if(diff == 2) then begin 
    outvalue = invoiced - GP;
    OutVal(380,0,GP,M4Val,true);
    OutVal(460,0,outvalue,M4Val,true);
  end;

  if(doformat == true) then begin
    EndFormat;
  end;
end;

/*
    Description:
    Takes an item code and finds its item group.

    input args:
    itemcode      -  item code

    in/output args:
    itemgroup     -  returns the item group of the item code given 
*/
procedure GetItemGroup(string itemcode, var string itemgroup)
begin
  boolean foundf;
  record INVc INr;
  foundf = true;
  INr.Code = itemcode;
  if(LoopKey("Code",INr,1,foundf)) then begin
    itemgroup = INr.Group;
  end;
  return;
end;

/*
    Description:
    Takes an item code and finds its item type.
    
    input args:
    itemcode     -  item code

    in/output args:
    itemtype     -  returns the item type of the item code given 
*/
procedure GetItemType(string itemcode, var integer itemtype)
begin
  boolean foundf;
  record INVc INr;
  foundf = true;
  INr.Code = itemcode;
  if(LoopKey("Code",INr,1,foundf)) then begin
    itemtype = INr.ItemType;
  end;
  return;
end;


/*
    Description:
    Takes an array of project transactions (stored in budget row format) and group them together.

    input args:
    TBBr         -  Record of budget type that contains project transactions and budgets in its rows
    grouping     -  The requested grouping
                    0 -> group on emplyee,   1 -> group on item,  2 -> group on item group
                
    in/output args: 
    TBBr2        -  Record of budget type that will contain the grouped project transactions after
                    the call of this method.

*/
procedure GroupRecords(var record TBBUVc TBBr, var record TBBUVc TBBr2, integer grouping)
begin
  integer rwcnt,rwcnt2,i,i2;
  row TBBUVc TBBrw, TBBrw2;
  string 20 itemgroup;
  string 20 itemgroup2;
  boolean record_inserted;
   
  rwcnt = MatRowCnt(TBBr);
  for(i=0; i<rwcnt; i=i+1) begin
    MatRowGet(TBBr, i, TBBrw);
    record_inserted = false;
    rwcnt2 = MatRowCnt(TBBr2);
    for(i2=0; i2<rwcnt2; i2=i2+1) begin
      MatRowGet(TBBr2,i2,TBBrw2);
      
        if(grouping == 0) then begin      
          /* Group on employee */
          if(TBBrw2.EMCode == TBBrw.EMCode) then begin
            TBBrw2.Sum = TBBrw2.Sum + TBBrw.Sum;
            TBBrw2.Cost = TBBrw2.Cost + TBBrw.Cost;
            MatRowPut(TBBr2,i2,TBBrw2);
            record_inserted = true;
          end;
        end;
        if(grouping == 1) then begin
          /* Group on item */
          if(TBBrw2.ArtCode == TBBrw.ArtCode) then begin
            TBBrw2.Sum = TBBrw2.Sum + TBBrw.Sum;
            TBBrw2.Cost = TBBrw2.Cost + TBBrw.Cost;
            MatRowPut(TBBr2,i2,TBBrw2);
            record_inserted = true;
          end;
        end;
        if(grouping == 2) then begin
          /* Group on item group */
          GetItemGroup(TBBrw.ArtCode, itemgroup);
          GetItemGroup(TBBrw2.ArtCode, itemgroup2);
          if(itemgroup == itemgroup2) then begin
            TBBrw2.Sum = TBBrw2.Sum + TBBrw.Sum;
            TBBrw2.Cost = TBBrw2.Cost + TBBrw.Cost;
            MatRowPut(TBBr2,i2,TBBrw2);
            record_inserted = true;
          end;
        end;
    end;
    if(not record_inserted) then begin
      MatRowPut(TBBr2,rwcnt2,TBBrw); 
    end;
  end;
end;


/*
    Description:
    Adds a row to a record of type Budget, the row can come from either a project transaction row or     
    from a budget. Also check if a line belongs to a budget that already was added, in that case
    we don't create a new row but just add the cost to the already added budget.

    input args:
    EMCode  -  Employee
    PRCode  -  Project code
    ArtCode -  Item code
    Invoice -  Invoived amount
    Cost    -  Cost
    has_fixed_cost_budget  -  indicates that we are sending in a project transaction that has a fixed     
    cost budget

    in/output args:
    TBBr   -  Record of budget type that will store the transactions and budgets in its rows
*/

procedure AddToTransList(var record TBBUVc TBBr, String EMCode, String PRCode, String ArtCode, val Invoice, val Cost, boolean has_fixed_cost_budget)
begin
  row TBBUVc TBBrw;
  integer rwcnt,i;
  boolean insert_newline;
  insert_newline = true;
  
  if(has_fixed_cost_budget) then begin
    rwcnt = MatRowCnt(TBBr);    
    for(i=0; i<rwcnt; i=i+1) begin
      MatRowGet(TBBr,i,TBBrw);
      if(TBBrw.EMCode == EMCode and TBBrw.Recepy == PRCode and TBBrw.ArtCode == ArtCode) then begin
        /* This transaction belongs to a "fixed cost" budget that are already included in the list,                               
           only add the cost from the p.transaction */
        TBBrw.Cost = TBBrw.Cost + Cost; 
        MatRowPut(TBBr,i,TBBrw);
        insert_newline = false;
        i=rwcnt; // break loop
      end;
    end;
  end;
  if(insert_newline) then begin
    TBBrw.EMCode = EMCode;
    TBBrw.Recepy = PRCode;
    TBBrw.ArtCode = ArtCode;
    TBBrw.Sum = Invoice;
    TBBrw.Cost = Cost;
    i = MatRowCnt(TBBr);
    MatRowPut(TBBr,i,TBBrw);
  end;  
end;


/*
    Description:
	Takes a project transaction, checks if the transaction has a fixed cost budget, if it has
	a budget it exchanges the transaction values with the values from the budget. Then it saves
	the data by calling the procedure "AddToTransList". 
	
	input args:
	TBr          - input project transaction
	specify      - decides which transactions we want, all/invoiceable/invoiced
	detaillevel  - decides which grouping we want, overview/item group/all
	include      - decides if we should include no budgets/budgets/budgets for finished proj.
	
	in/output args:
    TBBr2        -  The record that stores the transactions and budgets temporarily. 
*/
procedure HandleProjectTransaction(var record TBIVVc TBr, var record TBBUVc TBBr2, integer specify, integer detaillevel, integer include)
begin
  record TBBUVc TBBr;
  record PRVc PRVr;
  row  TBBUVc TBBrw;
  integer rwcnt,i;
  boolean foundf, insert_line, testf;
  val cost,acc_bud_sum;
  insert_line = false;
  acc_bud_sum = 0;
  /*Search for fixed cost budget */
  testf = true;
  TBBr.PRCode = TBr.PRCode;
  foundf = ReadFirstMain(TBBr,1,true);
  if(foundf and include<>0) then begin
    /* transaction has a budget */
    
    PRVr.Code = TBr.PRCode;
    foundf = ReadFirstMain(PRVr,1,true);
    if((PRVr.Terminated == 1 and include == 2) or include == 1) then begin
      /* if include is set to 2 we only want budgets from finished projects, if include is set to 1 we want all budgets */
      cost = TBr.CostPrice*TBr.Qty;
      rwcnt = MatRowCnt(TBBr);
      /* loop over budget rows */
      for(i=0; i<rwcnt; i=i+1) begin
        MatRowGet(TBBr,i,TBBrw)
        if(TBBrw.ArtCode == TBr.ArtCode and TBBrw.EMCode == TBr.EMCode and (TBBr.BudTime==1 or                            
           TBBrw.BudType==2)) then begin
          if (specify == 1) then begin
            /* only invoiced, reject those without invoice number */
            if(TBBrw.Invoiced < 1) then begin
              testf = false;
            end;
          end;
        
          if (specify == 2) then begin /* only invoiceable */
            if(TBBrw.Invoiced > 0) then begin
              testf = false;
            end;
          end;
   	      
          if(testf) then begin
            // Add sum of budgetlines
            acc_bud_sum = acc_bud_sum + TBBrw.Sum;
            insert_line = true;
          end;   	      
        end;
      end; /* for */
    end;
  end;

  if(insert_line) then begin
    AddToTransList(TBBr2,TBr.EMCode,TBBr.PRCode,TBr.ArtCode,acc_bud_sum, cost, true);
  end;

  if((not insert_line) and testf) then begin /* transaction line has no budget specified or we have                                                     
                                                choosen not to include budgets*/  
    if (specify == 1) then begin 
    /* only invoiced, reject those without invoice number */
      if(TBr.Invoice < 1) then begin
        testf = false;
      end;
    end;
    if (specify == 2) then begin /* only invoiceable */
      if(TBr.Invoice > 0) then begin 
        testf = false;
      end;
    end;
    if(testf) then begin
      AddToTransList(TBBr2,TBr.EMCode,TBr.PRCode, TBr.ArtCode, TBr.Sum, TBr.CostPrice*TBr.Qty, false);
    end;
  end;
end;


/*
    Description:
    Loops over project transactions, checks each project transaction if it satisfies the given conditions
    and in that case it adds the transactions to an array by calling "HandleProjectTransaction". Then 
    group the transactions together and print them.
     
	input args:
	EMCode       -  Employee code
    EMName       -  Employee name
    frpr         -  from project
    topr         -  to project
    frit         -  from item
    toit         -  to item 
    frgr         -  from item group
    togr         -  to item group  
    detaillevel  -  decides which grouping we want, overview/item group/all
    specify      -  decides which transactions we want, all/invoiceable/invoiced
    diff         -  decides what should be displayed in the last column GP%/GP/Cost
    StartDate    -  from date for transactions
    EndDate      -  to date for transactions
    include      -  decides if we should include no budgets/budgets/budgets for finished proj.
    
	in/output args:
    totalCost    -  accumulated cost, to be printed later on "Report Total"
    totalInv     -  accumulated invoiced, to be printed later on "Report Total"
*/
procedure ProjectTransLoop(string EMCode,
                      string EMName,
                      string frpr,
                      string topr,
                      string frit,
                      string toit, 
                      string frgr,
                      string togr, 
                      integer detaillevel, 
                      integer specify,
                      integer diff,
                      var val totalCost,
                      var val totalInv,
                      Date StartDate,
                      Date EndDate,
                      integer include,
                      record RcVc RepSpec)
begin
  /* Declare Variables */
  record TBIVVc TBr;  /* TBr is used for reading data */ 
  record TBBUVc TBBr2; /* TBBr2 used for storing temporary data */
  record TBBUVc TBBr3; /* record for assembeling temporary data */
  row TBBUVc TBBrw;
  boolean foundf,testf,firstf;
  val suminvoiced,sumCost,sumiteminvoiced,sumitemCost,sumgroupinvoiced,sumgroupCost;
  string 20 lastitem;
  string 20 currentitem;
  string 20 lastitemgroup;
  string 20 currentitemgroup;
  string 20 itemgroup;
  val gp,inv,gpp;
  integer rwcnt,i,itemtype;

  /* Initialize all Variables */
 	
  testf = false;
  foundf = true;
  firstf = true;

  suminvoiced = 0;
  sumCost = 0;
  sumiteminvoiced = 0;
  sumitemCost = 0;
  sumgroupinvoiced = 0;
  sumgroupCost =0;

  TBr.EMCode = EMCode;
  /* Loop over Project transactions */
  while (LoopKey("EMCode",TBr,1,true)) begin

    /* Test to see if the Loop should break */
    if(TBr.EMCode > EMCode) then begin
      foundf = false;
    end;
    testf = true;
    
    /* Test to see if the found record should be skipped */
    if(DateInRange(TBr.TransDate,StartDate,EndDate)==false) then begin
      testf = false;  // Date not in range
    end;
    
    if (nonblank(frpr) and TBr.PRCode < frpr) then begin
      testf = false;  // project not in range
    end;
    if (nonblank(topr) and TBr.PRCode > topr) then begin
      testf = false;  // project not in range
    end;
    if (nonblank(frit) and TBr.ArtCode < frit) then begin
      testf = false;  // item not in range
    end;
    if (nonblank(toit) and TBr.ArtCode > toit) then begin
      testf = false;  // item not in range
    end;
    if (testf) then begin
      if (nonblank(frgr)) then begin
        GetItemGroup(TBr.ArtCode,itemgroup);
        if(itemgroup < frgr) then begin
          testf = false;  // itemgroup not in range
        end;
      end;
    end;
    if (testf) then begin
      if (nonblank(togr)) then begin
        GetItemGroup(TBr.ArtCode,itemgroup);
        if(itemgroup > togr) then begin
          testf = false; // item not in range
        end;
      end;
    end;
    if (testf) then begin
      testf = ItemInItemGroupOrClass(TBr.ArtCode,"",RepSpec.f5);
    end;
    if (testf) then begin
      /* check that it is a service item */
      GetItemType(TBr.ArtCode,itemtype);
      if(itemtype <> 3) then begin
        testf = false;  // Not service item
      end;
    end;

    if(foundf == false) then begin
      testf = false;
    end;
    if (specify==2) then begin
      if (nonblankdate(Tbr.InvAfter)) then begin
        if (Tbr.InvAfter>EndDate) then begin testf = false; end;
      end;
    end;
    if(testf) then begin
      HandleProjectTransaction(Tbr, TBBr2,specify,detaillevel,include);
    end;
  end;
  
  /* group records and put the result in TBBr3 */ 
  GroupRecords(TBBr2,TBBr3, detaillevel);
  
  
  /* print records */
  rwcnt = MatRowCnt(TBBr3);
  
  if (firstf and detaillevel>0 and rwcnt>0) then begin
    StartFormat(15);
    OutString(20,0,EMCode,false);
    OutString(60,0,EMName,false);
    EndFormat;
    firstf = false;
  end;
  
  for(i=0; i<rwcnt; i=i+1) begin
    MatRowGet(TBBr3,i,TBBrw);
    suminvoiced = suminvoiced + TBBrw.Sum;
    sumCost = sumCost + TBBrw.Cost;
    totalInv = totalInv + TBBrw.Sum;
    totalCost = totalCost + TBBrw.Cost;
    
    if(detaillevel==1) then begin
      PrintItem(TBBrw.ArtCode,TBBrw.Sum,TBBrw.Cost,diff,true);
    //  Black_Divider(200,460);
    end;
    if(detaillevel==2) then begin
	  GetItemGroup(TBBrw.ArtCode,itemgroup);
      PrintItem(itemgroup,TBBrw.Sum,TBBrw.Cost,diff,true); 
      
    end;

    if(detaillevel==0) then begin
      StartFormat(15);
      OutString(20,0,EMCode,false);
      OutString(70,0,left(EMName,30),false);
      PrintItem("",TBBrw.Sum,TBBrw.Cost,diff,false);
      EndFormat;
    end;
    
  end;
  if(detaillevel>0 and rwcnt>0) then begin
    Black_Divider(200,460);
  end;
  if(detaillevel>0 and rwcnt>0) then begin
    /* print the totals for this employee */
    PrintItem("",suminvoiced,sumCost,diff,true);  
  end;      
  //Gray_Divider(0,1);
  /* End the Report */
end;


/*
    Description:
    Entry point for the execution of the report. Prints all the headers of the report.
    Loops over Employees and calls ProjTransLoop for each employee.

	input args:
	RepSpec      - record that contains all data callected in the specify window.
*/
global 
procedure GPEmpRn(record RcVc RepSpec)
begin
  /* Declare Variables */
  record UserVc EMr;
  boolean foundf, testf;
  integer rw,specify,detaillevel,diff;
  string 20 frda,toda;
  string 20 frem,toem,frpr,topr;
  string 20 frit,toit,frgr,togr;
  string 60 tstr;
  val totalCost,totalInv;
  

  /* Initialize all Variables */
  frem = FirstInRange(RepSpec.f1,20);
  toem = LastInRange(RepSpec.f1,20);
  frpr = FirstInRange(RepSpec.f2,20);
  topr = LastInRange(RepSpec.f2,20);
  frit = FirstInRange(RepSpec.f3,20);
  toit = LastInRange(RepSpec.f3,20);
  frgr = FirstInRange(RepSpec.f4,20);
  togr = LastInRange(RepSpec.f4,20);
  specify = RepSpec.flags[11];
  detaillevel = RepSpec.ArtMode;
  totalCost = 0;
  totalInv = 0;

  /* Start the Job */
  StartReportJob(USetStr(11340));
  /* Print the Header */
  rw = 1;
  diff = RepSpec.flags[8];
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);    // Period

  rw = rw + 1;
  HTEmployees(frem,toem,tstr);
  Header(rw,tstr,1);  // Employees
 
  if(RepSpec.ArtMode==0) begin
    HTDetailLevel(0,tstr); 
  end;

  if(RepSpec.ArtMode==1) then begin
    tstr = USetStr(4888);   // Item
  end;
  if(RepSpec.ArtMode==2) then begin
    tstr = USetStr(4894);   // Item group
  end;
  Header(rw,tstr,0);  // Detail level

  rw = rw + 1;
  HTProjects(frpr,topr,tstr);
  Header(rw,tstr,1);   // project range

  rw = rw + 1;
  HTArts(RepSpec.f3,RepSpec.f3,tstr);
  Header(rw,tstr,1);   // item range
  rw = rw + 1;
  if (HasItemGroups) then begin
    HTArtGroup(RepSpec.f4,tstr);  // item group range
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;
  if (HasItemClassification) then begin
    HTItemClass(RepSpec.f5,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end; 
  if(specify == 0) then begin	// All
    //Header(rw,USetStr(8545),1); // Just to write all on the screen doesn't make sense
  end;
  if(specify == 1) then begin	// Invoiced
    Header(rw,USetStr(7003),1);
  end;
  if(specify == 2) then begin	// Invoiceable
  	Header(rw,USetStr(7761),1);
  end;
  EndHeader;

  StartFormat(15);
  OutString(50,0,USetStr(3559),true);    // Employee

  if(detaillevel == 1) then begin
    OutString(200,0,USetStr(2463),true);   // Item
  end;
 
  if(detaillevel == 2) then begin
    OutString(200,0,USetStr(2474),true);   // Item group
  end;

  OutString(300,0,USetStr(6786),true);    // "Invd."
  if(diff == 0) then begin
    OutString(380,0,USetStr(6787),true);	// "GP"
    OutString(460,0,USetStr(6788),true);	// "GP%"
  end;
  if(diff == 1) then begin
    OutString(380,0,USetStr(6826),true);    // "Cost"
    OutString(460,0,USetStr(6787),true);    // "GP"
  end;
  if(diff == 2) then begin
    OutString(380,0,USetStr(6787),true);    // "GP"
    OutString(460,0,USetStr(6826),true);    // "Cost"
  end;
  EndFormat;
  Gray_Divider(0,1);

/* Start the Loop */

  foundf = true;
  if(nonblank(frem)) then begin
    EMr.Code = frem;
  end;
  /* Loop over employees */
  while (LoopMain(EMr,1,true)) begin
    testf = true; 
    /* Test to see if the Loop should break */
    if(nonblank(toem) and EMr.Code>toem) then begin
      foundf = false;
    end;

    /* Test to see if the found record should be skipped */
    if (foundf==false) then begin 
      testf = false; 
    end;

    if (testf) then begin
      /* Loop over all project transactions for this employee and print*/
      ProjectTransLoop(EMr.Code,EMr.Name,frpr,topr,frit,toit,frgr,togr,detaillevel,specify,diff,totalCost,totalInv,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.flags[9],RepSpec);
    end;
  end;	
  Gray_Divider(0,1);
  /* Print the Totals */
  PrintItem(USetStr(11341),totalInv,totalCost,diff,true);

  /* End the Report */
  EndJob;
  return;
end;
