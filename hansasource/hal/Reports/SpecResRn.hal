external function Integer GetLocalCompanyNr(string,Boolean);
external procedure ListPerTrans(record RcVc);
external procedure FindAccSD(Date,var Date,var Boolean);
external procedure FindRepDefHeader(string,string,var string);
external procedure AGrHeader(record RcVc,Boolean,Boolean,Date);
external procedure AGrSumLine(record RcVc,Integer,string,string,string,
                              val,val,val,val,val,val,Boolean,val,Boolean,Boolean,string,LongInt,Boolean,Boolean);
external procedure GetUserDefRepDescription(record UserDefRepLinesVc,string,var string);
external procedure Get2WholePeriods(record RcVc,Date,Date,var string,var string);
external procedure GetNotStr(Integer,var string);
external procedure GetNext2Sep(string,var Integer,var string);
external procedure GetNextToken(string,var Integer,var string);
external function Boolean GetNextTokenReturn(string,var Integer,var string);
external procedure GetAccountDescription2(string,string,var string);
external function Boolean AccRuPerBal(record RcVc,Boolean,string,string,var val,var val,var val,var val,var val,var val,
                                      Integer,Boolean,Date,Date,Date);
external procedure SumLine2(record RcVc,Boolean,string,string,string,var val,var val,var val,var val,var val,
                            var val,Boolean,val,Boolean,Date,Integer,LongInt,Boolean);

procedure ALPB2ResGr(record RcVc RepSpec,Boolean PLf,record UserDefRepLinesVc UserDefRepLinesr,record AccVc Accp,string anru,
                var val S3bp,var val Pbp,var val Ebp,var val S4bp,var val S5bp,var val S6bp,
                Boolean addflag,val goms,var Boolean headflagp,Boolean resUseAccum,Date AccumStartDate,string compname,Boolean negf)
BEGIN
  Boolean usedf;
  val S3b1,Pb1,Eb1,S4b1,S5b1,S6b1;
  string 255 nru;
  string 255 tstr,tstr2;
  Date budsd,buded;
/*
  budsd = StringToDate(FirstInRange(RepSpec.Stext,10));
  if (blankdate(budsd)) then begin budsd = RepSpec.sStartDate; end;    
  buded = StringToDate(LastInRange(RepSpec.Stext,10));
  if (blankdate(buded)) then begin buded = RepSpec.sEndDate; end;    
*/
  budsd = RepSpec.d1;
  buded = RepSpec.d2;
  nru = anru;//??
  nru = RepSpec.ObjStr;//??
  usedf = AccRuPerBal(RepSpec,PLf,Accp.AccNumber,nru,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,UserDefRepLinesr.DCSide,resUseAccum,AccumStartDate,budsd,buded);
  switch (RepSpec.Comparison) begin
    case 0:
      if (UserDefRepLinesr.DCSaldo==1) then begin
        if (S3b1<0) then begin goto LALPB2ResGr; end;
      end;
      if (UserDefRepLinesr.DCSaldo==2) then begin
        if (S3b1>=0) then begin goto LALPB2ResGr; end;
      end;
    otherwise
      if (UserDefRepLinesr.DCSaldo==1) then begin
        if (Pb1<0) then begin goto LALPB2ResGr; end;
      end;
      if (UserDefRepLinesr.DCSaldo==2) then begin
        if (Pb1>=0) then begin goto LALPB2ResGr; end;
      end;
  end;                
  GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr2);  
  if (nonblank(tstr2)) then begin// UserDefRepLinesr->Comment
    if ((((RepSpec.AccSpec==1) or (RepSpec.AccSpec==4)) and ((Pb1!=0) or (S3b1!=0) or (S4b1!=0) or (S5b1!=0) or (S6b1!=0) or(Eb1!=0) or (usedf))) 
        or (RepSpec.AccSpec==0) or (nonblank(RepSpec.ObjType))) then begin
      if (headflagp==false) then begin
        Gray_Divider(0,1);
        StartFormat(15);
        OutString(0,0,compname,false);
        EndFormat;
        Gray_Divider(0,1);
        StartFormat(15);
        OutString(0,0,tstr2,false); 
        EndFormat;
        Gray_Divider(0,1);
      end;
      GetAccountDescription2(Accp.AccNumber,RepSpec.Language,tstr);            
      if (blank(RepSpec.ObjType)) then begin
        if (RepSpec.IncDaughter==0) then begin
          AGrSumLine(RepSpec,0,Accp.AccNumber,tstr,UserDefRepLinesr.SpecCode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,PLf,resUseAccum,"DblNL",UserDefRepLinesr.IdKey,usedf,true);
        end else begin
          AGrSumLine(RepSpec,0,Accp.AccNumber,tstr,UserDefRepLinesr.SpecCode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,PLf,resUseAccum,"DblNL",UserDefRepLinesr.IdKey,usedf,true);
        end;
      end else begin
        SumLine2(RepSpec,PLf,Accp.AccNumber,tstr,UserDefRepLinesr.SpecCode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,resUseAccum,AccumStartDate,UserDefRepLinesr.DCSide,UserDefRepLinesr.IdKey,true);
      end;      
      if (headflagp==false) then begin
        StartFormat(15);
        EndFormat;
      end;
      headflagp = true;
    end;
  end;
  if (addflag==true) then begin
    S3bp = S3bp + S3b1;
    S4bp = S4bp + S4b1;
    S5bp = S5bp + S5b1;
    S6bp = S6bp + S6b1;
    Pbp = Pbp + Pb1;
    Ebp = Ebp + Eb1;
  end else begin
    S3bp = S3bp - S3b1;
    S4bp = S4bp - S4b1;
    S5bp = S5bp - S5b1;
    S6bp = S6bp - S6b1;
    Pbp = Pbp - Pb1;
    Ebp = Ebp - Eb1;
  end;
LALPB2ResGr:;
  RETURN;
END;

procedure ALPBEnd(record RcVc RepSpec,Boolean PLf,string Comment,string extracode,val S3bp,val Pbp,val Ebp,
                  val S4bp,val S5bp,val S6bp,Boolean negf,val goms,Boolean aheadflag,Boolean resUseAccum,LongInt idkey)
BEGIN
  string 255 tstr;
  if ((RepSpec.AccSpec==0) or (RepSpec.AccSpec==1) or (RepSpec.AccSpec==4)) then begin
    if (aheadflag==true) then begin
      tstr = USetStr(3143) & Comment;
      if (nonblank(Comment)) then begin
        Gray_Divider(0,1);
        AGrSumLine(RepSpec,0,tstr,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,true);
        StartFormat(15);
        EndFormat;
      end;
    end;
  end;
  if (RepSpec.AccSpec==2) then begin
    if (nonblank(Comment)) then begin
      AGrSumLine(RepSpec,0,Comment,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,true);
    end;
  end;
  if (RepSpec.AccSpec==3) then begin
    if ((S3bp!=0) or (S4bp!=0) or (S5bp!=0) or (S6bp!=0) or (Pbp!=0)) then begin
      if (nonblank(Comment)) then begin
        AGrSumLine(RepSpec,0,Comment,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,true);
      end;
    end;
  end;
  RETURN;
END;


procedure AccListPerBalResGr(record RcVc RepSpec,Boolean PLf,record UserDefRepLinesVc UserDefRepLinesr,var val S3bp,var val Pbp,
                        var val Ebp,var val S4bp,var val S5bp,var val S6bp,Boolean negf,val goms,Boolean resUseAccum,
                        Date AccumStartDate,string compname,Boolean negf)
BEGIN
  record AccVc Accr;
  Boolean addflag;
  string 255 Nitem;
  string 255 Nitem2;
  string 255 NRu;
  string 5 nsep;
  Boolean Accs;
  Integer np;
  Boolean headflag;
  string 255 tstr;

  S3bp = 0;
  S4bp = 0;
  S5bp = 0;
  S6bp = 0;
  Pbp = 0;
  Ebp = 0;
  headflag = false;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;
    GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
      end;
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,2,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;
          if ((Accs) and (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;  
          Accs = LoopBackKey("AccNumber",Accr,1,true);//Accs = m4_ReadLogicalMain(AccVc,LLoop1--,&Accr);
        end;
      end;
    end;
  end;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc2,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc2,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc2,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and  (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
      end;    
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,2,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;  
          Accs = LoopBackKey("AccNumber",Accr,1,true);//Accs = m4_ReadLogicalMain(AccVc,LLoop1--,&Accr);
        end;
      end;
    end;
  end;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc3,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc3,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc3,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and  (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
      end;
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,2,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;  
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin
              Accs = false;
            end;  
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,compname,negf);
          end;
          Accs = LoopBackKey("AccNumber",Accr,1,true);
        end;
      end;
    end;
  end;
//  GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);
  ALPBEnd(RepSpec,PLf,tstr,UserDefRepLinesr.SpecCode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,headflag,resUseAccum,UserDefRepLinesr.IdKey);// UserDefRepLinesr.Comment
  RETURN;
END;

procedure ConsResRep2(var record RcVc RepSpec,record UserDefRepLinesVc UserDefRepLinesr,string compname,Date AccumStartDate,Boolean PLf,Boolean resUseAccum,
                      var val S3ba,var val S4ba,var val S5ba,var val S6ba,var val Pba,var val Eba,Boolean negf,val Goms)
BEGIN
  val tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba;

  if (UserDefRepLinesr.RsType==1) then begin//RsRange
    UserDefRepLinesr.Desc = RepSpec.f5;    
    UserDefRepLinesr.Desc2 = "";    
    UserDefRepLinesr.Desc3 = "";    
    AccListPerBalResGr(RepSpec,PLf,UserDefRepLinesr,tmpS3ba,tmpPba,tmpEba,tmpS4ba,tmpS5ba,tmpS6ba,negf,Goms,resUseAccum,AccumStartDate,compname,negf);
    S3ba = S3ba + tmpS3ba;
    S4ba = S4ba + tmpS4ba;
    S5ba = S5ba + tmpS5ba;
    S6ba = S6ba + tmpS6ba;
    Pba = Pba + tmpPba;
    Eba = Eba + tmpEba;
  end;
  RETURN;
END;

procedure ConsResRep(var record RcVc RepSpec,record UserDefRepLinesVc UserDefRepLinesr,string compname,Date AccumStartDate,Boolean PLf,Boolean resUseAccum,
                     var val S3ba,var val S4ba,var val S5ba,var val S6ba,var val Pba,var val Eba,Boolean negf,val Goms)
BEGIN
  record AccVc Accr;
  Boolean Accs;
  string 10 accstr;
  
  accstr = RepSpec.f5;
  Accr.AccNumber = accstr;
  if (ReadFirstMain(Accr,1,true)) then begin 
    if (blank(Accr.ConsAccNumber)) then begin
      RepSpec.f5 = Accr.AccNumber;
      ConsResRep2(RepSpec,UserDefRepLinesr,compname,AccumStartDate,PLf,resUseAccum,S3ba,S4ba,S5ba,S6ba,Pba,Eba,negf,Goms);
    end;
  end;

  Accr.ConsAccNumber = accstr;
  Accr.AccNumber = "";
  Accs = true;
  while (LoopKey("ConsAccNumber",Accr,1,Accs)) begin
    if (Accr.ConsAccNumber<>accstr) then begin Accs = false; end;
    if (Accs) then begin
      RepSpec.f5 = Accr.AccNumber;
      ConsResRep2(RepSpec,UserDefRepLinesr,compname,AccumStartDate,PLf,resUseAccum,S3ba,S4ba,S5ba,S6ba,Pba,Eba,negf,Goms);
    end;
  end;
  RepSpec.f5 = accstr;
  RETURN;
END;

procedure DaughterConsResRn(var record RcVc RepSpec,record UserDefRepLinesVc UDRLr,Date AccumStartDate,Boolean PLf,Boolean resUseAccum,
                      var val S3ba,var val S4ba,var val S5ba,var val S6ba,var val Pba,var val Eba,Boolean negf,val Goms)
begin
  record RcVc theRepSpec;
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCbrw;
  Integer i,rwcnt;
  Integer oldcomp;
  Integer newcomp,oldincd;
  record ConsolidationBlock cr;
  Boolean testf;
  val tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba;
  
  oldincd = RepSpec.IncDaughter;
  RepSpec.IncDaughter = 0;

  RecordCopy(theRepSpec,RepSpec);
  BlockLoad(DCb);
  rwcnt = MatRowCnt(DCb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DCb,i,DCbrw);
    newcomp = GetLocalCompanyNr(DCbrw.CompCode,false);
    if (newcomp!=-1) then begin
      if (SetCompany(newcomp,false)) then begin
        BlockLoad(cr);
        RecordCopy(RepSpec,theRepSpec);
        RepSpec.basecurncy = cr.ConsCrncy;  
        RepSpec.flags[29] = newcomp;

        if (nonblankdate(DCbrw.StartDate)) then begin
          if (RepSpec.sStartDate<DCbrw.StartDate) then begin RepSpec.sStartDate = DCbrw.StartDate; end;
        end;
        if (nonblankdate(DCbrw.EndDate)) then begin
          if (RepSpec.sEndDate>DCbrw.EndDate) then begin RepSpec.sEndDate = DCbrw.EndDate; end;
        end;
        testf = true;
        if (RepSpec.sStartDate>theRepSpec.sEndDate) then begin testf = false; end;
        if (RepSpec.sEndDate<theRepSpec.sStartDate) then begin testf = false; end;
        if (RepSpec.sStartDate>RepSpec.sEndDate) then begin testf = false; end;
        if (RepSpec.sEndDate<RepSpec.sStartDate) then begin testf = false; end;
/*
        RepSpec.Stext = mcbudsd;
        RepSpec.Stext = RepSpec.Stext & ":";
        RepSpec.Stext = RepSpec.Stext & mcbuded;
*/
        if (testf) then begin
          ConsResRep(RepSpec,UDRLr,DCbrw.CompName,AccumStartDate,PLf,resUseAccum,tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba,negf,Goms);
          S3ba = S3ba + tmpS3ba;
          S4ba = S4ba + tmpS4ba;
          S5ba = S5ba + tmpS5ba;
          S6ba = S6ba + tmpS6ba;
          Pba = Pba + tmpPba;
          Eba = Eba + tmpEba;
          
          tmpS3ba = blankval; tmpS4ba = blankval; tmpS5ba = blankval; tmpS6ba = blankval; tmpPba = blankval; tmpEba = blankval;
          DaughterConsResRn(RepSpec,UDRLr,AccumStartDate,PLf,resUseAccum,S3ba,S4ba,S5ba,S6ba,Pba,Eba,negf,Goms);
        end;
      end;  
    end;
  end;
  RepSpec.IncDaughter = oldincd;
  return;
end;

global
procedure ConsResRn(var record RcVc argRepSpec)
BEGIN
  record CYBlock CompYear;
  record DaughterCompBlock DCb;
  row DaughterCompBlock DCbrw;

  record ConsolidationBlock cr;
  record UserDefRepVc UserDefRepr;
  record UserDefRepLinesVc UserDefRepLinesr;
  val S3ba,S4ba,S5ba,S6ba,Pba,Eba;
  Integer i,rwcnt,nr;
  Integer oldcomp;
  Integer newcomp;
  string 255 tstr,notstr,per1,per2;
  Boolean headerf,PLf,resUseAccum;
  Array Integer Sym_hash;
  Array val gKey_sp;
  Array string 10 gKey_spcode;
  Date AccumStartDate;
  Integer oldincd;
  Boolean agrfound;
  Boolean negf,testf;
  val Goms;
  Date mcbudsd,mcbuded;
  string 60 ckey;
  record RcVc RepSpec;
  record RcVc theRepSpec;

  S3ba = 0;
  S4ba = 0;
  S5ba = 0;
  S6ba = 0;
  Pba = 0;
  Eba = 0;
  PLf = true;
  RepSpec = argRepSpec;
  BlockLoad(CompYear);
  if (RepSpec.critname=="ConsResRClass") then begin    
    BlockLoad(cr);
    RepSpec.basecurncy = cr.ConsCrncy;  
  end;
  resUseAccum = false;
  if ((PLf==true) and (RepSpec.Comparison==0)) then begin
    FindAccSD(RepSpec.sStartDate,AccumStartDate,resUseAccum);
  end;
  if (RepSpec.CalledFromHAL==0) then begin
    FindRepDefHeader(RepSpec.repname,RepSpec.shortname,tstr);
    if (nonblank(RepSpec.f1)) then begin
      tstr = RepSpec.f1;
    end;  
    headerf = true;
    if (RepSpec.flags[5]!=0) then begin 
      headerf = false;
    end;  
    StartReportJob(tstr);//StartReportTJob(tstr,headerf,0);
    if (headerf) then begin
      AGrHeader(RepSpec,PLf,resUseAccum,AccumStartDate);
    end;  
    EndHeader;
    SetRepCol(2,50);
    SetRepCol(3,288);
    SetRepCol(4,384);
    SetRepCol(5,480);
    SetRepCol(6,15);
  end;

  if (RepSpec.CalledFromHAL==0) then begin
    if (PLf==false) then begin
      GetNotStr(RepSpec.Notation,notstr);
      StartFormat(20);
      tstr = "";
      OutString(11,0,tstr,true); // To make export to file look better 
      OutString(20,0,tstr,true);
      if (RepSpec.Comparison==0) then begin
        tstr = USetStr(3147);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3148);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        tstr = USetStr(3149);
        tstr = tstr & notstr;
        OutString(5,0,tstr,true);
      end;
      if (RepSpec.Comparison==2) then begin
        tstr = USetStr(3150);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3151);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        tstr = USetStr(3152);
        tstr = tstr & notstr;
        OutString(5,0,tstr,true);
      end;
      if (RepSpec.Comparison==3) then begin
        tstr = USetStr(3153);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3154);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        tstr = USetStr(3155);
        tstr = tstr & notstr;
        OutString(5,0,tstr,true);
      end;
      if (RepSpec.Comparison==4) then begin
        Get2WholePeriods(RepSpec,RepSpec.sStartDate,RepSpec.sEndDate,per1,per2);
        tstr = "";
        OutString(3,0,tstr,true);
        OutString(4,0,per1,true);
        OutString(5,0,per2,true);
      end;
      if (RepSpec.Comparison==5) then begin
        tstr = USetStr(3173);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3147);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        tstr = USetStr(3149);
        tstr = tstr & notstr;
        OutString(5,0,tstr,true);
      end;
      EndFormat;
    end else begin
      GetNotStr(RepSpec.Notation,notstr);
      StartFormat(20);
      tstr = "";
      OutString(11,0,tstr,true); // To make export to file look better 
      OutString(20,0,tstr,true);
      if (RepSpec.Comparison==0) then begin
        tstr = USetStr(3156);
        tstr = tstr & notstr;
//        if (resUseAccum==true) then begin //I don't think this is needed here at all
          OutString(4,0,tstr,true);
//        end;  
        tstr = USetStr(3157);
        tstr = tstr & notstr;
        OutString(5,0,tstr,true);
      end;
      if (RepSpec.Comparison==1) then begin
        tstr = USetStr(3158);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3159);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        OutString(5,0,USetStr(3160),true);
      end;
      if (RepSpec.Comparison==2) then begin
        tstr = USetStr(3161);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3162);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        OutString(5,0,USetStr(3163),true);
      end;
      if (RepSpec.Comparison==3) then begin
        tstr = USetStr(3164);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3165);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
        OutString(5,0,USetStr(3166),true);
      end;
      if (RepSpec.Comparison==4) then begin
        Get2WholePeriods(RepSpec,RepSpec.sStartDate,RepSpec.sEndDate,per1,per2);
        tstr = USetStr(3173);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        OutString(4,0,per1,true);
        OutString(5,0,per2,true);
      end;
      EndFormat;
    end;
  end;
  if (RepSpec.Notation==3) then begin
  // Find some way to calculate Turnover... Using some hardcoded TURNO in main Key Financial Ratios is a crap idea...
  end;
  Goms = 1;
  UserDefRepr.shortname = RepSpec.shortname;
  if (ReadFirstMain(UserDefRepr,1,true)) then begin
    ckey = "ShortIDKey:" & UserDefRepr.shortname;
    UserDefRepLinesr.IdKey = RepSpec.LastVer; 
    agrfound = ReadFirstKey(ckey,UserDefRepLinesr,1,false);
  end;
  negf = true;
  if (UserDefRepLinesr.AccType==0) then begin
    if (CompYear.NS0[0]==0) then begin
      negf = false;
    end;
  end;
  if (UserDefRepLinesr.AccType==1) then begin
    if (CompYear.NS0[1]==0) then begin
      negf = false;
    end;
  end;
  if (UserDefRepLinesr.AccType==2) then begin
    if (CompYear.NS0[2]==0) then begin
      negf = false;
    end;
  end;
  if (UserDefRepLinesr.AccType==3) then begin
    if (CompYear.NS0[3]==0) then begin
     negf = false;
    end;
  end;
  if (UserDefRepLinesr.AccType==4) then begin
    if (CompYear.NS0[4]==0) then begin
      negf = false;
    end;
  end;              
  if (agrfound==false) then begin
    StartFormat(20);
    OutString(0,0,USetStr(3167),false);
    EndFormat;
  end;  
  if ((nonblank(RepSpec.ObjType)) and (RepSpec.AccSpec==2)) then begin
    StartFormat(20);
    OutString(0,0,USetStr(1565),false);
    EndFormat;
    goto L88ConsResRn;
  end;
  mcbudsd = StringToDate(FirstInRange(RepSpec.Stext,10));
  if (blankdate(mcbudsd)) then begin mcbudsd = RepSpec.sStartDate; end;    
  mcbuded = StringToDate(LastInRange(RepSpec.Stext,10));
  if (blankdate(mcbuded)) then begin mcbuded = RepSpec.sEndDate; end;    
  RepSpec.d1 = mcbudsd;
  RepSpec.d2 = mcbuded;
  
  oldcomp = CurrentCompany;  
  RepSpec.flags[29] = CurrentCompany;
  oldincd = RepSpec.IncDaughter;
  RepSpec.IncDaughter = 0;
  ConsResRep2(RepSpec,UserDefRepLinesr,"Mother Company",AccumStartDate,PLf,resUseAccum,S3ba,S4ba,S5ba,S6ba,Pba,Eba,negf,Goms);
  RepSpec.IncDaughter = oldincd;

  DaughterConsResRn(RepSpec,UserDefRepLinesr,AccumStartDate,PLf,resUseAccum,S3ba,S4ba,S5ba,S6ba,Pba,Eba,negf,Goms);

  
  ALPBEnd(RepSpec,PLf,tstr,UserDefRepLinesr.SpecCode,S3ba,Pba,Eba,S4ba,S5ba,S6ba,negf,goms,true,resUseAccum,UserDefRepLinesr.IdKey);// UserDefRepLinesr.Comment
  ResetCompany(oldcomp);
         
  if (RepSpec.flags[4]!=0) then begin
    ListPerTrans(RepSpec);
  end;  
  if (RepSpec.Notation==3) then begin
//    Goms = Goms*100;
    StartFormat(15);
    OutString(0,0,USetStr(3170),false);
//    OutVal(340,0,Goms,M4Val,true);
    EndFormat;
  end;
L88ConsResRn:; 
  if (RepSpec.CalledFromHAL==0) then begin
    EndJob;
  end;
  RETURN;
END;

