external procedure NIghtAuditCashupRn(record RcVc,string);
external procedure HT2Per(Date, Date , var string);
external procedure HTAccs(string,string,Integer, var string);
external procedure HTObj(string,var string);
external procedure HTOT(string,var string);
external procedure HTLocations(string, string, var string);
external procedure SalesTimeRealFunction(date,date,string,Boolean,Integer,string,string);
external procedure GetAccTurnover(string,string,Date,Date,record ObjBalVc,string,Integer,Integer,Integer,var val,var val);
external procedure GetAccStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val);
external procedure ExtractObj(string,var Integer,var string);
external procedure DoHotelStatRn(date,date,string,string,boolean);
external procedure DoArtSTRn(integer,date,date,string,string,string,string,integer,string,string,integer,boolean,boolean,string,string,string,string,boolean,boolean);

procedure AddTokenToString(string token,var string result)
begin
  if blank(token) then begin
    goto LAddTokenToString;
  end;
  if nonblank(result) then begin
    result = result & ",";
  end;
  result = result & token;
LAddTokenToString:;
  return;
end;

procedure HTSalesGroup(string SalesGroup,var string Result)
begin
  record SalesGroupVc SalesGroupr;
  
  Result = USetStr(19158) & " ";
  if blank(SalesGroup) then begin
    Result = Result & USetStr(12727);
  end else begin
    SalesGroupr.SGroupCode = SalesGroup;
    if (ReadFirstMain(SalesGroupr,1,true)) then begin
      Result = Result & SalesGroup;
      if (nonblank(SalesGroupr.SGroupName)) then begin
        Result = Result & " " & SalesGroupr.SGroupName;
      end;
    end else begin
      Result = Result & SalesGroup;
    end;
  end;
  return;
end;

procedure HTLocationsLocal(string Location,var string Result)
begin
  record LocationVc Locationr;
  
  Result = USetStr(19159) & " ";
  if blank(Location) then begin
    Result = Result & USetStr(12727);
  end else begin
    Locationr.Code = Location;
    if (ReadFirstMain(Locationr,1,true)) then begin
      Result = Result & Location;
      if (nonblank(Locationr.Name)) then begin
        Result = Result & " " & Locationr.Name;
      end;
    end else begin
      Result = Result & Location;
    end;
  end;
  return;
end;

procedure PrintHeaderLine(string HeaderText,var integer hrw)
begin
  Header(hrw,HeaderText,1);
  hrw = hrw+1;
  return;
end;

function date GetCalendarYearStartDate(date dt)
begin
  date res;
  
  res.year = GetYear(dt);
  res.month = 1;
  res.day = 1;
  GetCalendarYearStartDate = res;
  return;
end;

function date GetCalendarMonthStartDate(date dt)
begin
  date res;

  res.year = GetYear(dt);
  res.month = GetMonth(dt);
  res.day = 1;
  GetCalendarMonthStartDate = res;
  return;
end;

procedure PrintRevenueLine(integer acccol,integer namecol,integer sbcol,integer todaycol,integer mtdcol,integer ytdcol,integer linetype,
                           string accnumber,string accname,string dblclk,val sbv,val todayv,val mtdv,val ytdv)
begin
  StartFormat(15);
  OutString(acccol,0,accnumber,false);
  OutString(namecol,0,accname,false);
  OutVal(sbcol,0,sbv,M4Val,true);
  OutVal(todaycol,0,todayv,M4Val,true);
  OutVal(mtdcol,0,mtdv,M4Val,true);
  OutVal(ytdcol,0,ytdv,M4Val,true);
  EndFormat;
  if (linetype==4) then begin
    Gray_Divider(0,1);
  end;
  return;
end;

function boolean GetRevenueValues(string acc,string obj,date TodayStart,date YTDStart,date MTDStart,date ed,var val sbv,var val todayv,var val mtdv,var val ytdv)
begin
  record ObjBalVc ObjBalr;
  boolean res;
  val tmpsb;
  
  ObjBalr.AccNumber = acc;
  ObjBalr.Object = obj;
  ReadFirstMain(ObjBalr,2,true);
  sbv = blankval; 
  GetAccStartBalance(acc,obj,YTDStart,ObjBalr,0,0,"",0,sbv);
  todayv = blankval;
  GetAccTurnover(acc,obj,TodayStart,TodayStart,ObjBalr,"",0,0,0,tmpsb,todayv);
  mtdv = blankval;
  GetAccTurnover(acc,obj,MTDStart,ed,ObjBalr,"",0,0,0,tmpsb,mtdv);
  ytdv = blankval;
  GetAccTurnover(acc,obj,YTDStart,ed,ObjBalr,"",0,0,0,tmpsb,ytdv);
  
  res = (sbv<>blankval) or (todayv<>blankval) or (mtdv<>blankval) or (ytdv<>blankval);
  GetRevenueValues = res;
  return;
end;

procedure SetRevenueValues(integer accindex,
                           var array val asbv,var array val atodayv,var array val amtdv,var array val aytdv,
                           val sbv,val todayv,val mtdv,val ytdv)
begin
  if blank(sbv) then begin
    asbv[accindex] = 0;
  end else begin
    asbv[accindex] = -sbv;
  end;
  if blank(todayv) then begin
    atodayv[accindex] = 0;
  end else begin
    atodayv[accindex] = -todayv;
  end;
  if blank(mtdv) then begin
    amtdv[accindex] = 0;
  end else begin
    amtdv[accindex] = -mtdv;
  end;
  if blank(ytdv) then begin
    aytdv[accindex] = 0;
  end else begin
    aytdv[accindex] = -ytdv;
  end;
  return;
end;

procedure UpdateTotals(val sbv,val todayv,val mtdv,val ytdv,var val totsbv,var val tottodayv,var val totmtdv,var val totytdv)
begin
  totsbv = totsbv+sbv;
  tottodayv = tottodayv+todayv;
  totmtdv = totmtdv+mtdv;
  totytdv = totytdv+ytdv;
  return;
end;

function string 255 GetObjectsFromType(string ObjType)
begin
  record ObjVc Objr;
  string 255 res;
  boolean TrHs;
  
  TrHs = true;
  Objr.OTCode = ObjType;
  while LoopKey("OTCode",Objr,1,TrHs) begin
    if (Objr.OTCode<>ObjType) then begin
      TrHs = false;
    end else begin
      if nonblank(res) then begin
        res = res & ",";
      end;
      res = res & Objr.Code;
    end;
  end;
  GetObjectsFromType = res;
  return;
end;

function boolean GetFiscalYearStartDate(date ReportDate,var date sd,var string yearcode)
begin
  record YearBlock Yearr;
  row YearBlock Yearrw;
  integer i, rowcnt;
  boolean res;
  
  BlockLoad(Yearr);
  rowcnt = MatRowCnt(Yearr);
  for (i=0;i<rowcnt;i=i+1) begin
    MatRowGet(Yearr,i,Yearrw);
    if (ReportDate>=Yearrw.StartDate) and (ReportDate<=Yearrw.EndDate) then begin
      yearcode = Yearrw.YearCode;
      sd = Yearrw.StartDate;
      res = true;
      i = rowcnt;
    end;
  end;
  GetFiscalYearStartDate = res;
  return;
end;

function boolean GetFiscalPeriodStartDate(date ReportDate,string YearCode,var date sd)
begin
  record AccPeriodVc AccPeriodr;
  row AccPeriodVc AccPeriodrw;
  integer i, rowcnt;
  boolean res;
  
  AccPeriodr.Code = YearCode;
  if ReadFirstMain(AccPeriodr,1,true) then begin
    rowcnt = MatRowCnt(AccPeriodr);
    for (i=0;i<rowcnt;i=i+1) begin
      MatRowGet(AccPeriodr,i,AccPeriodrw);
      if (ReportDate>=AccPeriodrw.StartDate) and (ReportDate<=AccPeriodrw.EndDate) then begin
      sd = AccPeriodrw.StartDate;
      res = true;
      i = rowcnt;
      end;
    end;
  end;
  GetFiscalPeriodStartDate = res;
  return;
end;


procedure DoRevenueAccounts(integer PeriodType,date sd,string objtype,string objs,string fracc,string toacc)
begin
  record AccVc Accr;
  record ObjVc Objr;
  record OTVc OTr;
  boolean TrHs;
  val tmpsb,v,totrev;
  val sbv,todayv,mtdv,ytdv;
  val totsbv,tottodayv,totmtdv,totytdv;
  val objtotsbv,objtottodayv,objtotmtdv,objtotytdv;
  val acctotsbv,acctottodayv,acctotmtdv,acctotytdv;
  record ObjBalVc ObjBalr;
  date MTDStart,YTDStart;
  integer i,acccnt,acccol,namecol,sbcol,todaycol,mtdcol,ytdcol,pos,mainaccix;
  array string 255 aaccname,aaccnumber;
  array val asbv,atodayv,amtdv,aytdv;
  array integer alinetype;
  string 255 acc,curdatestr,lobjs,addobj,curobj,yearcode;
  boolean doobjf,doobjtotal,continuef,mainaccvalid,fiscalyearok,fiscalperiodok;
  
  //Line Types (alinetype)
  //1 - Normal account line
  //2 - Header account line (when doing objects)
  //3 - Object line (when doing objects)
  //4 - Object total line (when doing objects)
  
  //PeriodType
  //0 - Calender Years
  //1 - Fiscal Years
  
  namecol = 60;
  sbcol = 240;
  todaycol = 320;
  mtdcol = 400;
  ytdcol = 480;
  curdatestr = DateToString(sd,"DD MMM");
  if (PeriodType==1) then begin
    if GetFiscalYearStartDate(sd,YTDStart,yearcode) then begin
      fiscalyearok = true;
      if GetFiscalPeriodStartDate(sd,yearcode,MTDStart) then begin
        fiscalperiodok = true;
      end;
    end;
  end;
  if (PeriodType==0) or (not fiscalyearok) then begin
    YTDStart = GetCalendarYearStartDate(sd);
  end;
  if (PeriodType==0) or (not fiscalperiodok) then begin
    MTDStart = GetCalendarMonthStartDate(sd);
  end;
  StartFormat(15);
  OutString(sbcol,0,DateToString(YTDStart,"DD MMM") & "-" & curdatestr,true);
  OutString(todaycol,0,curdatestr,true);
  OutString(mtdcol,0,DateToString(MTDStart,"DD MMM") & "-" & curdatestr,true);
  OutString(ytdcol,0,DateToString(YTDStart,"DD MMM") & "-" & curdatestr,true);
  EndFormat;
  StartFormat(15);
  OutString(acccol,0,USetStr(2407),false);
  OutString(namecol,0,USetStr(12026),false);
  OutString(sbcol,0,USetStr(4144),true);
  OutString(todaycol,0,USetStr(8962),true);
  OutString(mtdcol,0,USetStr(19145),true);
  OutString(ytdcol,0,USetStr(19146),true);
  EndFormat;
  Gray_Divider(0,1);
  if nonblank(objtype) then begin
    OTr.Code = objtype;
    if ReadFirstMain(OTr,1,True)==false then begin
      goto LDoRevenueAccounts;
    end;
  end;
  TrHs = true;
  while LoopMain(Accr,1,TrHs) begin
    continuef = true;
    if (Accr.AccType<>kAccTypeIncome) then begin
      continuef = false;
    end;
    if continuef then begin
      if (nonblank(fracc) and (Accr.AccNumber<fracc)) then begin
        continuef = false;
      end;
    end;
    if continuef then begin
      if (nonblank(toacc) and (Accr.AccNumber>toacc)) then begin
        continuef = false;
        TrHs = false;
      end;
    end;
    if continuef then begin
      pos = 0;
      curobj = "";
      addobj = "";
      acctotsbv = 0;
      acctottodayv = 0;
      acctotmtdv = 0;
      acctotytdv = 0;
      objtotsbv = 0;
      objtotmtdv = 0;
      objtotytdv = 0;
      doobjtotal = false;
      acc = Accr.AccNumber;
      ObjBalr.AccNumber = acc;
      if nonblank(objtype) then begin
        lobjs = GetObjectsFromType(objtype);
        addobj = objs;
      end else begin
        lobjs = objs;
      end;
      doobjf = nonblank(objtype);
      if (doobjf==true) then begin
        //Add main account row
        alinetype[acccnt] = 2;
        aaccnumber[acccnt] = acc;
        aaccname[acccnt] = Accr.Comment;    
        mainaccix = acccnt;
        acccnt = acccnt+1;
        //Process objects for this account
        ExtractObj(lobjs,pos,curobj);
        while nonblank(curobj) begin
          Objr.Code = curobj;
          ReadFirstMain(Objr,1,True);
          alinetype[acccnt] = 3;
          aaccnumber[acccnt] = "";
          if nonblank(addobj) then begin
            curobj = curobj & "," & addobj;
          end;
          aaccname[acccnt] = "    " & curobj & " - " & Objr.Comment;
          if GetRevenueValues(acc,curobj,sd,YTDStart,MTDStart,sd,sbv,todayv,mtdv,ytdv) then begin
            SetRevenueValues(acccnt,asbv,atodayv,amtdv,aytdv,sbv,todayv,mtdv,ytdv);
            UpdateTotals(sbv,todayv,mtdv,ytdv,objtotsbv,objtottodayv,objtotmtdv,objtotytdv); //Object totals
            UpdateTotals(sbv,todayv,mtdv,ytdv,acctotsbv,acctottodayv,acctotmtdv,acctotytdv); //Account totals            
            UpdateTotals(sbv,todayv,mtdv,ytdv,totsbv,tottodayv,totmtdv,totytdv); //Grand total
            acccnt = acccnt+1;
            doobjtotal = true;
          end;
          ExtractObj(lobjs,pos,curobj);
        end;
        //Finalize account
        if doobjtotal then begin
          aaccnumber[acccnt] = "";
          aaccname[acccnt] = USetStr(6203) & " " & USetStr(14594);
          alinetype[acccnt] = 4;
          SetRevenueValues(acccnt,asbv,atodayv,amtdv,aytdv,objtotsbv,objtottodayv,objtotmtdv,objtotytdv);
          SetRevenueValues(mainaccix,asbv,atodayv,amtdv,aytdv,acctotsbv,acctottodayv,acctotmtdv,acctotytdv);
          acccnt = acccnt+1;
        end else begin
          acccnt = mainaccix;
        end;
      end else begin        
        alinetype[acccnt] = 1;
        aaccnumber[acccnt] = acc;
        aaccname[acccnt] = Accr.Comment;    
        if GetRevenueValues(acc,lobjs,sd,YTDStart,MTDStart,sd,sbv,todayv,mtdv,ytdv) then begin
          SetRevenueValues(acccnt,asbv,atodayv,amtdv,aytdv,sbv,todayv,mtdv,ytdv);
          UpdateTotals(sbv,todayv,mtdv,ytdv,totsbv,tottodayv,totmtdv,totytdv);
          acccnt = acccnt+1;
        end;
      end;
    end;
  end;
  //Set Grand Total
  alinetype[acccnt] = 1;
  aaccnumber[acccnt] = USetStr(12922) & ":";
  aaccname[acccnt] = "";
  SetRevenueValues(acccnt,asbv,atodayv,amtdv,aytdv,totsbv,tottodayv,totmtdv,totytdv);
  //Print array rows
  for (i=0;i<=acccnt;i=i+1) begin
    if (i==acccnt) then begin
      Gray_Divider(0,1);
    end;
    PrintRevenueLine(acccol,namecol,sbcol,todaycol,mtdcol,ytdcol,alinetype[i],aaccnumber[i],aaccname[i],"",asbv[i],atodayv[i],amtdv[i],aytdv[i]);
  end;
LDoRevenueAccounts:;
  return;
end;

function boolean ReservationCheckedIn(record JobVc Jobr)
begin
  boolean res;

  ReservationCheckedIn = res;
  return;
end;

function string 255 GetContactName(string cucode,string defstr)
begin
  string 255 res;
  record CUVc CUr;
  
  if nonblank(defstr) then begin
    res = defstr;
  end else begin
    CUr.Code = cucode;
    if ReadFirstMain(CUr,1,true) then begin
      res = CUr.Name;
    end;
  end;
  GetContactName = res;
  return;
end;

procedure PrintReservation(integer roomcol,integer rescol,integer inoutcol,integer statcol,integer typecol,
                           integer packcol,integer namecol,record JobVc Jobr)
begin
  string 255 cidate,codate;
  
  StartFormat(15);
  if blank(Jobr.ResCode) then begin
    OutString(roomcol,0,USetStr(11172),false);
  end else begin
    OutStringID(roomcol,"DblJobVcID",Jobr.ResCode,false,Jobr.SerNr);
  end;
  OutString(rescol,0,Jobr.SerNr,false);
  cidate = DateToString(Jobr.TransDate,"D MMM YY");
  codate = DateToString(Jobr.EndDate,"D MMM YY");
  OutString(inoutcol,0,cidate & " - " & codate,false);
  OutString(statcol,0,Jobr.ResStatus,false);
  OutString(typecol,0,Jobr.Type,false);
  OutString(packcol,0,Jobr.ResUsage,false);
  OutString(namecol,0,GetContactName(Jobr.CUCode,Jobr.CUName),false);
  EndFormat;
  return;
end;

procedure PrintPerson(integer namecol,string persontype,string cucode,string cclass,string defstr)
begin
  string 255 tstr;
  
  if blank(cucode) then begin
    goto LPrintGuest;
  end;
  StartFormat(15);
  tstr = "  " & persontype & ": " & GetContactName(cucode,defstr);
  if nonblank(cclass) then begin
    tstr = tstr & " (" & cclass & ")" ;
  end;
  OutString(namecol,0,tstr,false);
  EndFormat;
LPrintGuest:;
  return;
end;

function boolean ReservationHasSpecialStatus(record HotelBlock Hotelr,record JobVc Jobr)
begin
  record ReservationStatusVc RSr;
  boolean res;
  
  res = (Jobr.ResStatus==Hotelr.NoshowStatus)
    or (Jobr.ResStatus==Hotelr.BlockStatus)
    or (Jobr.ResStatus==Hotelr.AllotmentSt);
  if (res==false) then begin
    RSr.Code = Jobr.ResStatus;
    if ReadFirstMain(RSr,1,true) then begin
      res = (RSr.StatType==2); //Cancelled
    end;
  end;
  return;
end;

function boolean ResHasFinalInvoice(record JobVc Jobr)
begin
  record ShopBaskVc ShopBaskr;
  boolean res,continuef;
  
  res = true;
  continuef = true;
  ShopBaskr.OwnerSerNr = Jobr.SerNr;
  ShopBaskr.Owner = kShopBaskOwnerReservation;
  while LoopKey("OwnerSerNr",ShopBaskr,2,continuef) begin
    if (ShopBaskr.OwnerSerNr<>Jobr.SerNr) then begin continuef = false; end;
    if (ShopBaskr.Owner<>kShopBaskOwnerReservation) then begin continuef = false; end;
    if continuef then begin
      res = (ShopBaskr.DestinationNr<>-1);
      if (res==false) then begin
        continuef = false;
      end;
    end;
  end;
  ResHasFinalInvoice = res;
  return;
end;

function boolean ResFullyPaid(record JobVc Jobr)
begin
  record ARVc ARr;
  record ShopBaskVc ShopBaskr;
  boolean res,continuef;
  longint invnr;
  
  res = true;
  continuef = true;
  ShopBaskr.OwnerSerNr = Jobr.SerNr;
  ShopBaskr.Owner = kShopBaskOwnerReservation;
  while LoopKey("OwnerSerNr",ShopBaskr,2,continuef) begin
    if (ShopBaskr.OwnerSerNr<>Jobr.SerNr) then begin continuef = false; end;
    if (ShopBaskr.Owner<>kShopBaskOwnerReservation) then begin continuef = false; end;
    if continuef then begin
      if (ShopBaskr.DestinationNr<>-1) then
      begin
        ARr.InvoiceNr = ShopBaskr.DestinationNr; 
        if ReadFirstMain(ARr,1,true) then begin
          res = false;
          continuef = false;
        end;
      end else begin
        res = false;
        continuef = false;
      end;
    end;
  end;
  ResFullyPaid = res;
  return;
end;

procedure ProcessProperlyCheckedIn(record HotelBlock Hotelr,date d,string ResStatus,var array record JobVc aJobr,var integer cnt)
begin
  record JobVc Jobr;
  boolean foundresf;
  
  foundresf = true;
  Jobr.ResStatus = ResStatus;
  while LoopKey("ResStatus",Jobr,1,foundresf) begin
    foundresf = (Jobr.ResStatus==ResStatus);
    if (foundresf==true) then begin
      if (Jobr.TransDate<=d) and (Jobr.EndDate>=d) then begin
        aJobr[cnt] = Jobr;
        cnt = cnt+1;       
      end;
    end;
  end;
  return;
end;

procedure ProcessFullyPaidNotCheckedOut(record HotelBlock Hotelr,date d,string ResStatus,var array record JobVc aJobr,var integer cnt)
begin
  record JobVc Jobr;
  boolean foundresf;
  
  foundresf = true;
  Jobr.ResStatus = ResStatus;
  while LoopKey("ResStatus",Jobr,1,foundresf) begin
    foundresf = (Jobr.ResStatus==ResStatus);
    if (foundresf==true) then begin
      if (Jobr.EndDate<=d) then begin
        if ResFullyPaid(Jobr) then begin
          aJobr[cnt] = Jobr;
          cnt = cnt+1;       
        end;
      end;
    end;
  end;
  return;
end;

procedure ProcessCheckedOutNoFinalInvoice(record HotelBlock Hotelr,date d,string ResStatus,var array record JobVc aJobr,var integer cnt)
begin
  record JobVc Jobr;
  boolean foundresf;
  
  foundresf = true;
  Jobr.ResStatus = ResStatus;
  while LoopKey("ResStatus",Jobr,1,foundresf) begin
    foundresf = (Jobr.ResStatus==ResStatus);
    if (foundresf==true) then begin
      if (Jobr.EndDate<=d) and (not ResHasFinalInvoice(Jobr)) then begin
        aJobr[cnt] = Jobr;
        cnt = cnt+1;       
      end;
    end;
  end;
  return;
end;

procedure ProcessCheckedOutNotPaid(record HotelBlock Hotelr,date d,string ResStatus,var array record JobVc aJobr,var integer cnt)
begin
  record JobVc Jobr;
  boolean foundresf;
  
  foundresf = true;
  Jobr.ResStatus = ResStatus;
  while LoopKey("ResStatus",Jobr,1,foundresf) begin
    foundresf = (Jobr.ResStatus==ResStatus);
    if (foundresf==true) then begin
      if (Jobr.EndDate<=d)
      and ResHasFinalInvoice(Jobr)
      and (not ResFullyPaid(Jobr)) then begin
        aJobr[cnt] = Jobr;
        cnt = cnt+1;       
      end;
    end;
  end;
  return;
end;

procedure ProcessNotProperlyCheckedIn(record HotelBlock Hotelr,date d,string ResStatus,var array record JobVc aJobr,var integer cnt)
begin
  record JobVc Jobr;
  boolean foundresf;
  
  foundresf = true;
  Jobr.ResStatus = ResStatus;
  while LoopKey("ResStatus",Jobr,1,foundresf) begin
    foundresf = (Jobr.ResStatus==ResStatus);
    if (foundresf==true) then begin
      if (Jobr.TransDate<=d)
      and (Jobr.EndDate>=d)
      and (not ReservationHasSpecialStatus(Hotelr,Jobr)) then begin
        aJobr[cnt] = Jobr;
        cnt = cnt+1;       
      end;
    end;
  end;
  return;
end;

procedure PrintReservations(integer roomcol,integer rescol,integer inoutcol,integer statcol,integer typecol,integer packcol,integer namecol,
                            array record JobVc aJobr,integer cnt,integer HeaderStr,boolean graydivf,boolean agentf,boolean guestf)
begin
  record JobVc Jobr;
  row JobVc Jobrw;
  integer i,j,guestcnt;
  string 255 tstr;
  
  if (cnt>0) then begin
    StartFormat(15);
    OutString(0,0,USetStr(HeaderStr),false);
    EndFormat;
    for (i=0;i<cnt;i=i+1) begin
      Jobr = aJobr[i];
      PrintReservation(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,Jobr);
      if (agentf) or (guestf) then begin
        if (agentf) then begin
          PrintPerson(namecol,"A",Jobr.Source,"",Jobr.SourceName);
        end;
        if (guestf==true) then begin
          guestcnt = MatRowCnt(Jobr);
          for (j=0;j<guestcnt;j=j+1) begin
            MatRowGet(Jobr,j,Jobrw);
            PrintPerson(namecol,"G",Jobrw.GuestCode,Jobrw.CClass,Jobrw.CUName);
          end;
        end;
      end;
    end;
    if graydivf then begin
      Gray_Divider(0,1);
    end;
  end;
  return;
end;

procedure DoCustomerAndGuestLedger(date d,boolean agentf,boolean guestf)
begin
  record JobVc Jobr;
  row JobVc Jobrw;
  record HotelBlock Hotelr;
  record ReservationStatusVc RSr;
  boolean foundstf,foundresf,graydivf;
  integer roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol;
  integer resix,guestix,respropcicnt,resnotcicnt,resconotpaidcnt,resconoinvcnt,respaidnotcocnt,rowcnt;
  array record JobVc arespropci,aresnotci,aresconotpaid,aresconoinv,arespaidnotco;
  
  roomcol = 0;
  rescol = 40;
  inoutcol = 90;
  statcol = 180;
  typecol = 240;
  packcol = 280;
  namecol = 330;
  StartFormat(15);
  OutString(roomcol,0,USetStr(12122),false);
  OutString(rescol,0,USetStr(11156) & " " & USetStr(12071),false);
  OutString(inoutcol,0,USetStr(11157),false);
  OutString(statcol,0,USetStr(11156) & " " & USetStr(16720),false);
  OutString(typecol,0,USetStr(20734),false);
  OutString(packcol,0,USetStr(16905),false);
  OutString(namecol,0,USetStr(12026),false);
  EndFormat;
  Gray_Divider(0,1);
  BlockLoad(Hotelr);
  foundstf = true;
  while LoopMain(RSr,1,foundstf) begin
    //Checked-out reservations
    if (RSr.Code==Hotelr.ChOutSt) then begin
      ProcessCheckedOutNoFinalInvoice(Hotelr,d,RSr.Code,aresconoinv,resconoinvcnt);
      ProcessCheckedOutNotPaid(Hotelr,d,RSr.Code,aresconotpaid,resconotpaidcnt);
    end;
    //Normal (not checked-in)
    if (RSr.StatType==0) then begin
      ProcessNotProperlyCheckedIn(Hotelr,d,RSr.Code,aresnotci,resnotcicnt);
    end else begin
      //Unconfirmed
      if (RSr.StatType==1) then begin
        ProcessNotProperlyCheckedIn(Hotelr,d,RSr.Code,aresnotci,resnotcicnt);
      end else begin
        //Normal (checked-in)
        if (RSr.StatType==3) then begin
          ProcessProperlyCheckedIn(Hotelr,d,RSr.Code,arespropci,respropcicnt);
          ProcessFullyPaidNotCheckedOut(Hotelr,d,RSr.Code,arespaidnotco,respaidnotcocnt);
        end;
      end;
    end;
  end;
  //Currently checked-in
  PrintReservations(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,arespaidnotco,respaidnotcocnt,19156,true,agentf,guestf);
  //Not properly checked-in
  PrintReservations(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,aresnotci,resnotcicnt,19157,true,agentf,guestf);
  //Not checked out - paid
  PrintReservations(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,arespaidnotco,respaidnotcocnt,19153,true,agentf,guestf);
  //Checked-out - no final invoice
  PrintReservations(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,aresconoinv,resconoinvcnt,19154,true,agentf,guestf);
  //Checked-out - outstanding
  PrintReservations(roomcol,rescol,inoutcol,statcol,typecol,packcol,namecol,aresconotpaid,resconotpaidcnt,19155,false,agentf,guestf);
  return;
end;

procedure PrintUnOKedRecord(string type,longint number,date transdate,string customer,string salesman,string drilldown,val total)
begin
  record UserVc Userr;
  transaction integer gnumbercol,gtransdatecol,gcustcol,gtypecol,gsalesmancol,gtotalcol;
  
  StartFormat(15);
  OutString(gtypecol,0,type,false);
  OutString(gnumbercol,drilldown,number,false);
  OutDate(gtransdatecol,0,transdate,false);
  OutString(gcustcol,0,customer,false);
  OutString(gsalesmancol,0,salesman,false);
  OutVal(gtotalcol,0,total,M4Val,true);
  EndFormat;
  return;
end;

procedure DoUnOKedInvoies(string SalesGroups)
begin
  record IVVc IVr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key;
  boolean TrHs; 

  pos = 0;
  grandtot = 0;
  if blank(SalesGroups) then begin
    cursg = "All";
  end else begin
    ExtractObj(SalesGroups,pos,cursg);
  end;
  while nonblank(cursg) begin
    key = "OKFlag";
    if nonblank(SalesGroups) then begin
      key = key & ":" & cursg;
    end;
    TrHs = true;
    IVr.OKFlag = 0;
    ResetLoop(IVr);
    while LoopKey(key,IVr,1,TrHs) begin
      if (IVr.OKFlag<>0) then begin
        TrHs = false;
      end else begin
        recordtot = IVr.Sum1+IVr.Sum3;
        if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
          recordtot = -recordtot;
        end;
        PrintUnOKedRecord(USetStr(22417),IVr.SerNr,IVr.InvDate,IVr.Addr0,IVr.SalesMan,"DblCustPS2",recordtot);
        grandtot = grandtot+recordtot;
      end;
    end;
    ExtractObj(SalesGroups,pos,cursg);
  end;
  return;
end;

procedure DoUnOKedCashIns(string SalesGroups)
begin
  record CLInVc CLInr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key;
  boolean TrHs; 

  pos = 0;
  grandtot = 0;
  if blank(SalesGroups) then begin
    cursg = "All";
  end else begin
    ExtractObj(SalesGroups,pos,cursg);
  end;
  while nonblank(cursg) begin
    key = "OKFlag";
    if nonblank(SalesGroups) then begin
      key = key & ":" & cursg;
    end;
    TrHs = true;
    CLInr.OKFlag = 0;
    ResetLoop(CLInr);
    while LoopKey(key,CLInr,1,TrHs) begin
      if (CLInr.OKFlag<>0) then begin
        TrHs = false;
      end else begin
        recordtot = CLInr.NetVal+CLInr.VATVal;
        PrintUnOKedRecord(USetStr(8401),CLInr.SerNr,CLInr.TransDate,CLInr.CUName,CLInr.Person,"DblCLInVc",recordtot);
        grandtot = grandtot+recordtot;
      end;
    end;
    ExtractObj(SalesGroups,pos,cursg);
  end;
  return;
end;

procedure DoUnOKedCashOuts(string SalesGroups)
begin
  record CLOutVc CLOutr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key;
  boolean TrHs; 
   
  pos = 0;
  grandtot = 0;
  if blank(SalesGroups) then begin
    cursg = "All";
  end else begin
    ExtractObj(SalesGroups,pos,cursg);
  end;
  while nonblank(cursg) begin
    key = "OKFlag";
    if nonblank(SalesGroups) then begin
      key = key & ":" & cursg;
    end;
    TrHs = true;
    CLOutr.OKFlag = 0;
    ResetLoop(CLOutr);
    while LoopKey(key,CLOutr,1,TrHs) begin
      if (CLOutr.OKFlag<>0) then begin
        TrHs = false;
      end else begin
        recordtot = CLOutr.NetVal+CLOutr.VATVal;
        PrintUnOKedRecord(USetStr(16760),CLOutr.SerNr,CLOutr.TransDate,CLOutr.CUName,CLOutr.Person,"DblCLOutVc",recordtot);
        grandtot = grandtot+recordtot;
      end;
    end;
    ExtractObj(SalesGroups,pos,cursg);
  end;
  return;
end;

procedure DoUnOKedReceipts
begin
  record IPVc IPr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key,tstr;
  boolean TrHs; 
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  IPr.OKFlag = 0;
  while LoopKey("OKFlagTransDate",IPr,1,TrHs) begin
    if (IPr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      tstr = IPr.RecNumber;
      if nonblank(IPr.Comment) then begin
        if nonblank(tstr) then begin
          tstr = tstr & " (" & IPr.Comment & ")";
        end else begin
          tstr = IPr.Comment;
        end;
      end;
      PrintUnOKedRecord(USetStr(8772),IPr.SerNr,IPr.TransDate,tstr,IPr.Sign,"DblCuPerIP",IPr.CurPayVal);
      grandtot = grandtot+IPr.CurPayVal;
    end;
  end;
  return;
end;

procedure DoUnOKedPayments(string SalesGroups)
begin
  record OPVc OPr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key,tstr;
  boolean TrHs; 
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  OPr.DoneFlag = 0;
  while LoopKey("DoneFlag",OPr,1,TrHs) begin
    if (OPr.DoneFlag<>0) then begin
      TrHs = false;
    end else begin
      tstr = OPr.PayNumber;
      if nonblank(OPr.BankName) then begin
        if nonblank(tstr) then begin
          tstr = tstr & " (" & OPr.BankName & ")";
        end else begin
          tstr = OPr.BankName;
        end;
      end;
      PrintUnOKedRecord(USetStr(16022),OPr.SerNr,OPr.TransDate,tstr,OPr.Sign,"DblOPVc",OPr.CurPayVal);
      grandtot = grandtot+OPr.CurPayVal;
    end;
  end;
  return;
end;

procedure DoUnOKedBarTabs(string SalesGroups)
begin
  record RestAccVc RestAccr;
  record UserVc Userr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key,tstr;
  boolean TrHs,testf; 
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  RestAccr.Closed = 0;
  while LoopKey("ClosedTransDate",RestAccr,1,TrHs) begin
    if (RestAccr.Closed<>0) then begin
      TrHs = false;
    end else begin
      Userr.Code = RestAccr.Cashier;
      testf = true;
      if nonblank(SalesGroups) then begin
        if ReadFirstMain(Userr,1,true) then begin
          if blank(Userr.SalesGroup) then begin
            testf = false;
          end else begin
            testf = SetInSet(Userr.SalesGroup,SalesGroups);
          end;
        end;
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(11190),RestAccr.SerNr,RestAccr.TransDate,RestAccr.Comment,RestAccr.Cashier,"DblRestAccVc",RestAccr.Sum4);
        grandtot = grandtot+RestAccr.Sum4;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedPurchaseInvoices(string SalesGroups)
begin
  record VIVc VIr;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key;
  boolean TrHs; 
   
  pos = 0;
  grandtot = 0;
  if blank(SalesGroups) then begin
    cursg = "All";
  end else begin
    ExtractObj(SalesGroups,pos,cursg);
  end;
  while nonblank(cursg) begin
    key = "OKFlag";
    if nonblank(SalesGroups) then begin
      key = key & ":" & cursg;
    end;
    TrHs = true;
    VIr.OKFlag = 0;
    ResetLoop(VIr);
    while LoopKey(key,VIr,1,TrHs) begin
      if (VIr.OKFlag<>0) then begin
        TrHs = false;
      end else begin
        recordtot = VIr.PayVal+VIr.VATVal;
        PrintUnOKedRecord(USetStr(4161),VIr.SerNr,VIr.TransDate,VIr.VEName,VIr.SalesMan,"DblVIVc",recordtot);
        grandtot = grandtot+recordtot;
      end;
    end;
    ExtractObj(SalesGroups,pos,cursg);
  end;
  return;
end;

procedure DoUnOKedPOSBalanceRecords
begin
  record POSBalanceVc POSBalancer;
  integer pos;
  val recordtot,grandtot;
  string 255 cursg,key;
  boolean TrHs; 
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  POSBalancer.NLTransDone = 0;
  ResetLoop(POSBalancer);
  while LoopKey("NLTransDone",POSBalancer,1,TrHs) begin
    if (POSBalancer.NLTransDone<>0) then begin
      TrHs = false;
    end else begin
      recordtot = POSBalancer.Bal;
      PrintUnOKedRecord(USetStr(4161),POSBalancer.SerNr,POSBalancer.TransDate,"","","DblPOSBalanceVc",recordtot);
      grandtot = grandtot+recordtot;
    end;
  end;
  return;
end;

procedure DoUnOKedStockTransfers(string locations)
begin
  record INTransferVc INTransferr;
  row INTransferVc INTransferrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  INTransferr.OKFlag = 0;
  while LoopKey("OKFlag",INTransferr,1,TrHs) begin
    if (INTransferr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(INTransferr.FrLocation) then begin
        AddTokenToString(INTransferr.FrLocation,locstring);
      end;
      if nonblank(INTransferr.Location) then begin
        AddTokenToString(INTransferr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(INTransferr.FrLocation) and SetInSet(INTransferr.FrLocation,locations));
      end;
      if (testf==false) then begin
        testf = (nonblank(INTransferr.Location) and SetInSet(INTransferr.Location,locations));
      end;
      rowcnt = MatRowCnt(INTransferr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(INTransferr,i,INTransferrw);
        if (nonblank(INTransferrw.Location) and SetInSet(INTransferrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(INTransferrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(4999),INTransferr.SerNr,INTransferr.TransDate,"",locstring,"DblINTransferVc",INTransferr.SumQuant);
        grandtot = grandtot+INTransferr.SumQuant;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedGoodsReceipts(string locations)
begin
  record PUVc PUr;
  row PUVc PUrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  PUr.OKFlag = 0;
  while LoopKey("OKFlag",PUr,1,TrHs) begin
    if (PUr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(PUr.Location) then begin
        AddTokenToString(PUr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(PUr.Location) and SetInSet(PUr.Location,locations));
      end;
      rowcnt = MatRowCnt(PUr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(PUr,i,PUrw);
        if (nonblank(PUrw.Location) and SetInSet(PUrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(PUrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(10755),PUr.SerNr,PUr.TransDate,PUr.VEName,locstring,"DblPUVc",PUr.SumQuant);
        grandtot = grandtot+PUr.SumQuant;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedReturnedGoodsToSupplier(string locations)
begin
  record RetPUVc RetPUr;
  row RetPUVc RetPUrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  RetPUr.OKFlag = 0;
  while LoopKey("OKFlag",RetPUr,1,TrHs) begin
    if (RetPUr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(RetPUr.Location) then begin
        AddTokenToString(RetPUr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(RetPUr.Location) and SetInSet(RetPUr.Location,locations));
      end;
      rowcnt = MatRowCnt(RetPUr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        if (nonblank(RetPUrw.Location) and SetInSet(RetPUrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(RetPUrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(11698),RetPUr.SerNr,RetPUr.TransDate,RetPUr.VEName,locstring,"DblRetPUVc",RetPUr.SumQuant);
        grandtot = grandtot+RetPUr.SumQuant;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedReturnedGoods(string locations)
begin
  record RetVc Retr;
  row RetVc Retrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  Retr.OKFlag = 0;
  while LoopKey("OKFlag",Retr,1,TrHs) begin
    if (Retr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(Retr.Location) then begin
        AddTokenToString(Retr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(Retr.Location) and SetInSet(Retr.Location,locations));
      end;
      rowcnt = MatRowCnt(Retr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(Retr,i,Retrw);
        if (nonblank(Retrw.Location) and SetInSet(Retrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(Retrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(14582),Retr.SerNr,Retr.TransDate,Retr.CustName,locstring,"DblRetVc",Retr.SumQuant);
        grandtot = grandtot+Retr.SumQuant;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedStockDepreciations(string locations)
begin
  record SDVc SDr;
  row SDVc SDrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  SDr.OKFlag = 0;
  while LoopKey("OKFlag",SDr,1,TrHs) begin
    if (SDr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(SDr.Location) then begin
        AddTokenToString(SDr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(SDr.Location) and SetInSet(SDr.Location,locations));
      end;
      rowcnt = MatRowCnt(SDr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(SDr,i,SDrw);
        if (nonblank(SDrw.Location) and SetInSet(SDrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(SDrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(22425),SDr.SerNr,SDr.TransDate,"",locstring,"DblSDVc",SDr.TotQty);
        grandtot = grandtot+SDr.TotQty;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedDeliveries(string locations)
begin
  record SHVc SHr;
  row SHVc SHrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  SHr.OKFlag = 0;
  while LoopKey("OKFlag",SHr,1,TrHs) begin
    if (SHr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(SHr.Location) then begin
        AddTokenToString(SHr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(SHr.Location) and SetInSet(SHr.Location,locations));
      end;
      rowcnt = MatRowCnt(SHr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(SHr,i,SHrw);
        if (nonblank(SHrw.Location) and SetInSet(SHrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(SHrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(3504),SHr.SerNr,SHr.ShipDate,SHr.Addr0,locstring,"DblSHVc",SHr.TotQty);
        grandtot = grandtot+SHr.TotQty;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedStockRevaluations(string locations)
begin
  record SRVc SRr;
  row SRVc SRrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  SRr.OKFlag = 0;
  while LoopKey("OKFlag",SRr,1,TrHs) begin
    if (SRr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(SRr.Location) then begin
        AddTokenToString(SRr.Location,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(SRr.Location) and SetInSet(SRr.Location,locations));
      end;
      rowcnt = MatRowCnt(SRr);
      for (i=0;i<rowcnt;i=i+1) begin
        MatRowGet(SRr,i,SRrw);
        if (nonblank(SRrw.Location) and SetInSet(SRrw.Location,locations) )then begin
          testf = true;
        end;
        AddTokenToString(SRrw.Location,locstring);
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(17558),SRr.SerNr,SRr.TransDate,"",locstring,"DblSRVc",SRr.TotQty);
        grandtot = grandtot+SRr.TotQty;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedStockMovements(string locations)
begin
  record StockMovVc StockMovr;
  row StockMovVc StockMovrw;
  integer pos;
  val recordtot,grandtot;
  string 255 locstring;
  boolean TrHs,testf; 
  integer i,rowcnt;
   
  pos = 0;
  grandtot = 0;
  TrHs = true;
  StockMovr.OKFlag = 0;
  while LoopKey("OKFlag",StockMovr,1,TrHs) begin
    if (StockMovr.OKFlag<>0) then begin
      TrHs = false;
    end else begin
      locstring = "";
      if nonblank(StockMovr.FrLocation) then begin
        AddTokenToString(StockMovr.FrLocation,locstring);
      end;
      if nonblank(StockMovr.ThrouLocation) then begin
        AddTokenToString(StockMovr.ThrouLocation,locstring);
      end;
      if nonblank(StockMovr.ToLocation) then begin
        AddTokenToString(StockMovr.ToLocation,locstring);
      end;
      testf = blank(locations);
      if (testf==false) then begin
        testf = (nonblank(StockMovr.FrLocation) and SetInSet(StockMovr.FrLocation,locations));
      end;
      if (testf==false) then begin
        testf = (nonblank(StockMovr.ThrouLocation) and SetInSet(StockMovr.ThrouLocation,locations));
      end;
      if (testf==false) then begin
        testf = (nonblank(StockMovr.ToLocation) and SetInSet(StockMovr.ToLocation,locations));
      end;
      if testf then begin
        PrintUnOKedRecord(USetStr(1827),StockMovr.SerNr,StockMovr.SentTransDate,"",locstring,"DblStockMovVc",StockMovr.TotSentQty);
        grandtot = grandtot+StockMovr.TotSentQty;
      end;
    end;
  end;
  return;
end;

procedure DoUnOKedNonStockRecords(string SalesGroups)
begin
  transaction integer gnumbercol,gtransdatecol,gcustcol,gtypecol,gsalesmancol,gtotalcol;
  string 255 key;
  
  gtypecol = 0;
  gnumbercol = 70;
  gtransdatecol = 140;
  gcustcol = 210;
  gsalesmancol = 340;
  gtotalcol = 480;
  StartFormat(15);
  OutString(0,0,USetStr(19158),false);
  EndFormat;
  StartFormat(15);
  OutString(gtypecol,0,USetStr(2358),false);
  OutString(gnumbercol,0,USetStr(7273),false);
  OutString(gtransdatecol,0,USetStr(12947),false);
  OutString(gcustcol,0,USetStr(13822) & "/" & USetStr(12594),false); 
  OutString(gsalesmancol,0,USetStr(16709),false);
  OutString(gtotalcol,0,USetStr(13798),true);
  EndFormat;
  Gray_Divider(0,1);
  DoUnOKedInvoies(SalesGroups);
  DoUnOKedCashIns(SalesGroups);
  DoUnOKedCashOuts(SalesGroups);
  DoUnOKedReceipts;
  DoUnOKedPayments(SalesGroups);  
  DoUnOKedBarTabs(SalesGroups);  
  DoUnOKedPurchaseInvoices(SalesGroups);
  DoUnOKedPOSBalanceRecords;
  return;
end;

procedure DoUnOKedStockRecords(string locations)
begin
  transaction integer gnumbercol,gtransdatecol,gcustcol,gtypecol,gsalesmancol,gtotalcol;
  string 255 key;
  
  gtypecol = 0;
  gnumbercol = 70;
  gtransdatecol = 140;
  gcustcol = 210;
  gsalesmancol = 340;
  gtotalcol = 480;
  StartFormat(15);
  OutString(0,0,USetStr(19159),false);
  EndFormat;
  StartFormat(15);
  OutString(gtypecol,0,USetStr(2358),false);
  OutString(gnumbercol,0,USetStr(7273),false);
  OutString(gtransdatecol,0,USetStr(12947),false);
  OutString(gcustcol,0,USetStr(13822) & "/" & USetStr(12594),false); 
  OutString(gsalesmancol,0,USetStr(7604),false); //locations
  OutString(gtotalcol,0,USetStr(14558),true); //qty
  EndFormat;
  Gray_Divider(0,1);
  DoUnOKedStockTransfers(locations);
  DoUnOKedGoodsReceipts(locations);
  DoUnOKedReturnedGoodsToSupplier(locations);
  DoUnOKedReturnedGoods(locations);
  DoUnOKedStockDepreciations(locations);
  DoUnOKedDeliveries(locations);
  DoUnOKedStockRevaluations(locations);
  DoUnOKedStockMovements(locations);
  return;
end;

global
procedure NightAuditRn(Record RcVc RepSpec)
begin
  integer hrw;
  date sd,ed;
  string 255 tstr,fracc,toacc;

  StartReportJob(USetStr(12459));
  
  /*---------- Header ----------*/
  hrw = 1;
  PrintHeaderLine(USetStr(12463) & ": " & RepSpec.sStartDate,hrw);
  //Section 1
  if (RepSpec.flags[0]==1) then begin
    PrintHeaderLine(USetStr(23642) & " " & USetStr(19130),hrw);
    if (RepSpec.flags[1]==1) then begin
      PrintHeaderLine(USetStr(19137),hrw);
    end;
  end;
  //Section 2
  if (RepSpec.flags[2]==1) then begin
    PrintHeaderLine(USetStr(23642) & " " & USetStr(19131),hrw);
    if (nonblank(RepSpec.AccStr)) then begin
      fracc = FirstInRange(RepSpec.AccStr,10);
      toacc = LastInRange(RepSpec.AccStr,10);
      HTAccs(fracc,toacc,0,tstr);
      PrintHeaderLine(tstr,hrw);
    end;
    if (nonblank(RepSpec.ObjType)) then begin
      HTOT(RepSpec.ObjType,tstr);
      PrintHeaderLine(tstr,hrw);
    end;
    if (nonblank(RepSpec.ObjStr)) then begin
      HTObj(RepSpec.ObjStr,tstr);
      PrintHeaderLine(tstr,hrw);
    end;
    if (RepSpec.flags[17]==0) then begin
      tstr = USetStr(19149);
    end else begin
      tstr = USetStr(19150);
    end;
    PrintHeaderLine(USetStr(19148) & ": " & tstr,hrw);
  end;
  //Section 3
  if (RepSpec.flags[4]==1) then begin
    PrintHeaderLine(USetStr(23642) & " " & USetStr(19132),hrw);
    if (RepSpec.flags[5]==1) then begin
      PrintHeaderLine(USetStr(19151),hrw);
    end;
    if (RepSpec.flags[6]==1) then begin
      PrintHeaderLine(USetStr(19152),hrw);
    end;
  end;
  //Section 4
  if (RepSpec.flags[7]==1) then begin
    PrintHeaderLine(USetStr(23642) & " " & USetStr(19133),hrw);
    if (RepSpec.flags[8]==1) then begin
      PrintHeaderLine(USetStr(19141),hrw);
    end;
    if nonblank(RepSpec.f1) then begin
      HTLocations(FirstInRange(RepSpec.f1,10),LastInRange(RepSpec.f1,10),tstr);
      PrintHeaderLine(tstr,hrw);
    end;
  end;
  
  //Section 5 - To be done by Jarek
  
  //Section 6 //Leave out for now, will do later.
  
  //Section 7
  if (RepSpec.flags[13]==1) then begin
    PrintHeaderLine(USetStr(23642) & " " & USetStr(19136),hrw);
    if (RepSpec.flags[15]==1) then begin
      HTSalesGroup(RepSpec.f3,tstr);
      PrintHeaderLine(tstr,hrw);
    end;
    if (RepSpec.flags[16]==1) then begin
      HTLocationsLocal(RepSpec.f4,tstr);
      PrintHeaderLine(tstr,hrw);
    end;
  end;
  EndHeader;
  
  /*---------- Report ----------*/
  
  //Section 1
  if (RepSpec.flags[0]==1) then begin
    StartFormat(15);
    sd = AddDay(RepSpec.sStartDate,-7);
    OutString(0,0,USetStr(19130) & " (" & DateToString(sd,"DD MMM") & "-" & DateToString(RepSpec.sStartDate,"DD MMM") & ")",false);
    EndFormat;
    Black_Divider(0,1);
    SalesTimeRealFunction(sd,RepSpec.sStartDate,"",true,0,"","");
    if (RepSpec.flags[1]==1) then begin
      Gray_Divider(0,1);
      DoHotelStatRn(sd,RepSpec.sStartDate,"","",true);
    end;
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  
  //Section 2  
  if (RepSpec.flags[2]==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(19131),false);
    EndFormat;
    Black_Divider(0,1);
    DoRevenueAccounts(RepSpec.flags[17],RepSpec.sStartDate,RepSpec.ObjType,RepSpec.ObjStr,fracc,toacc);
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  
  //Section 3
  if (RepSpec.flags[4]==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(19132),false);
    EndFormat;
    Black_Divider(0,1);
    DoCustomerAndGuestLedger(RepSpec.sStartDate,RepSpec.flags[5]==1,RepSpec.flags[6]==1);
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  

  //Section 4
  if (RepSpec.flags[7]==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(19133),false);
    EndFormat;
    Black_Divider(0,1); 
    DoArtSTRn(0,RepSpec.sStartDate,RepSpec.sStartDate,"","","","",RepSpec.Media,"","",1,true,false,"",RepSpec.f1,"","",RepSpec.flags[8]==1,false);
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  
  //Section 5
  if (RepSpec.flags[9]==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(19134),false);
    EndFormat;
    Black_Divider(0,1);    
    NIghtAuditCashupRn(RepSpec,RepSpec.f2);
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  
  //Section 7
  if (RepSpec.flags[13]==1) then begin
    StartFormat(15);
    OutString(0,0,USetStr(19136),false);
    EndFormat;
    Black_Divider(0,1);    
    if (RepSpec.flags[15]==1) then begin    
      DoUnOKedNonStockRecords(RepSpec.f3);
      Gray_Divider(0,1);
    end;
    if (RepSpec.flags[16]==1) then begin
      DoUnOKedStockRecords(RepSpec.f4);
    end;
    StartFormat(15);
    Gray_Divider(0,1);
    EndFormat;
    StartFormat(15);
    EndFormat;
  end;
  
  EndJob;
  
  return;
end;