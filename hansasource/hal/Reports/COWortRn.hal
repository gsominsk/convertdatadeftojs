external function val MulWithRateToBase2(var string,Date,val,roundmode);
external function val MulWithRateToBase1(var string,Date,val,roundmode);
external procedure HT2Per(Date,Date,var string);

procedure GetPer(Date a,Date b, var string tstr)
begin
  string 255 tstr2;

  tstr = "";
  tstr2 = a;
  tstr = tstr & tstr2;
  tstr = tstr & " : ";
  tstr2 = b;
  tstr = tstr & tstr2;
  return;
end;

global
procedure COworthRn(record RcVc RepSpec)
BEGIN
  record COVc COr;
  row COVc COrw;
  Integer rwcnt,i;
  record BaseCurBlock bascur;
  Boolean TrHs,testf;
  LongInt afr,ato;
  String 10 afrclass;
  String 10 atoclass;
  Integer d,m,y;
  val t,t2,ct,temp,sum1,tot2;
  val Tot1Sum,Tot2Sum;
  val sub1tot,sub2tot;
  Integer rw;
  string 255 tstr;
  Date enddat,startdat;
  val factor;
  
  BlockLoad(bascur);
  afr = FirstInRange(RepSpec.f1,11);
  ato = LastInRange(RepSpec.f1,11);
  afrclass = FirstInRange(RepSpec.FirstAcc,5);
  atoclass = LastInRange(RepSpec.FirstAcc,5);
  sub1tot = 0;
  sub2tot = 0;
  Tot1Sum = 0;
  Tot2Sum = 0;
  StartReportJob(USetStr(8255));
   rw = 1;
   HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
   Header(rw,tstr,1);
  EndHeader;
  StartFormat(15);
   OutString(0,0,USetStr(8256),false);
   OutString(50,0,USetStr(8257),false);   
   OutString(260,0,USetStr(8258),true);   
   OutString(330,0,USetStr(8259),true);   
   OutString(370,0,USetStr(8260),false);   
  EndFormat;
  Gray_Divider(0,1);
  COr.SerNr = afr;
  TrHs = true;
  while (LoopMain(COr,1,TrHs)) begin
    if (ato<>-1) then begin
      if (COr.SerNr>ato) then begin
        TrHs = false;
      end;
    end;
    testf = true;
    if (TrHs==false) then begin
      testf = false;
    end;
    if (COr.startDate>RepSpec.sEndDate) then begin
      testf = false;
    end;    
    if (COr.OKFlag==0) then begin
      testf = false;
    end;
    if (NonBlankDate(COr.endDate)) then begin
      if (COr.endDate<RepSpec.sStartDate) then begin
        testf = false;
      end;
    end;
    if (nonblank(RepSpec.FirstAcc)) then begin
      if ((afrclass>COr.ContractClass) or (atoclass<COr.ContractClass)) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      startdat = COr.startDate;
      if (COr.startDate<RepSpec.sStartDate) then begin
        startdat = RepSpec.sStartDate;
      end;
      enddat = RepSpec.sEndDate;
      if (NonBlankDate(COr.endDate)) then begin
        enddat = COr.endDate;
      end;
      if (COr.endDate>RepSpec.sEndDate) then begin
        enddat = RepSpec.sEndDate;
      end;
      t = 0;
      y = GetYear(enddat) - GetYear(startdat);
      m = GetMonth(enddat) - GetMonth(startdat);
      d = GetDay(enddat) - GetDay(startdat);
      if (DaysInMonth(GetYear(enddat),GetMonth(enddat))==30) then begin
        d = d + 1;
      end;
      if (d<>0) then begin
        t2 = d/30;
      end;
      if (y<>0) then begin
        t = y*12;
      end;
      ct = t2 + t + m;
// Only works for Months !!!!
      t = ct/COr.perLength;
      sum1 = 0;
      tot2 = 0;
      rwcnt = MatRowCnt(COr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(COr,i,COrw);
        sum1 = sum1 + COrw.Sum;
        if (COrw.RowType==1) then begin
          if (nonblankdate(COrw.InvoiceAfter)) then begin
            if (DateInRange(COrw.InvoiceAfter,RepSpec.sStartDate,RepSpec.sEndDate)) then begin
              tot2 = tot2 + COrw.Sum;
            end;
          end else begin
            tot2 = tot2 + COrw.Sum;
          end;
        end else begin
          tot2 = tot2 + (t * COrw.Sum);
        end;
      end;
      factor = 1;
      if (COr.normalFactor!=0) then begin
        factor = COr.normalFactor;
      end;
      sum1 = sum1*factor;
      tot2 = tot2*factor;
      StartFormat(15);
       OutStringID(0,"DblCOVc",COr.SerNr,false,COr.ChildSerNr);
       OutString(50,0,COr.CustCode & ", " & COr.Addr0,false);
       OutVal(260,0,sum1,M4Val,true);
//       t = t * sum1;
       OutVal(330,0,tot2,M4Val,true);
       OutString(335,0,COr.CurncyCode,false);
       GetPer(startdat,enddat,tstr);
       OutString(370,0,tstr,false);
      EndFormat;  
      temp = MulWithRateToBase1(COr.CurncyCode,CurrentDate,tot2,DefaultCurRoundOff);
      Tot1Sum = Tot1Sum + temp;
      temp = MulWithRateToBase1(COr.CurncyCode,CurrentDate,sum1,DefaultCurRoundOff);
      sub1tot = sub1tot + temp;
      if (RepSpec.flags[12]==1) then begin
        temp = MulWithRateToBase2(COr.CurncyCode,CurrentDate,tot2,DefaultCurRoundOff);
        Tot2Sum = Tot2Sum + temp;
        temp = MulWithRateToBase2(COr.CurncyCode,CurrentDate,sum1,DefaultCurRoundOff);
        sub2tot = sub2tot + temp;
      end;
    end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(100,0,USetStr(8330),false);
  OutVal(260,0,sub1tot,M4Val,true);
  OutVal(330,0,Tot1Sum,M4Val,true);
  OutString(335,0,bascur.BaseCur1,false);
  EndFormat;
  if ((bascur.BaseCur1<>bascur.BaseCur2) and (RepSpec.flags[12]==1)) then begin
    StartFormat(15);
    OutString(100,0,USetStr(8330),false);
    OutVal(260,0,sub2tot,M4Val,true);
    OutVal(330,0,Tot2Sum,M4Val,true);
    OutString(335,0,bascur.BaseCur2,false);
    EndFormat;
  end;
  EndJob;
  return;
END;
