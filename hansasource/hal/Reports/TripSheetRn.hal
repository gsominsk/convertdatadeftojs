external procedure HT2Per(Date,Date,var string);
external procedure HTRoute(string,var string);
external procedure HTOKF(Integer,Integer,var string);
external procedure M4PadString(string,Integer,string,Boolean,var string);
external function string 255 AddStr(string,string,string);

function Boolean GetNextSH(record RcVc RepSpec,var record SHVc SHr)
begin
  Boolean res,TrHs,testf;
  
  TrHs = true;
  while (LoopKey("SortingDate",SHr,2,TrHs)) begin
    if (SHr.ShipDate>RepSpec.sEndDate) then begin
      TrHs = false;
    end;
    testf = TrHs;
    if (RepSpec.flags[0]==0 and SHr.OKFlag==0) then begin
      testf = false;
    end;
    if (RepSpec.flags[1]==0 and SHr.OKFlag!=0) then begin
      testf = false;
    end;
    if (nonblank(RepSpec.f2) and SHr.FreightCode!=RepSpec.f2) then begin
      testf = false;
    end;
    if (testf) then begin
      res = true;
      TrHs = false;
    end;
  end;
  
  GetNextSH = res;
  return;
end;

function Boolean GetNextRetPU(record RcVc RepSpec,var record RetPUVc RetPUr)
begin
  Boolean res,TrHs,testf;
  
  TrHs = true;
  while (LoopKey("SortingDate",RetPUr,2,TrHs)) begin
    if (RetPUr.TransDate>RepSpec.sEndDate) then begin
      TrHs = false;
    end;
    testf = TrHs;
    if (RepSpec.flags[0]==0 and RetPUr.OKFlag==0) then begin
      testf = false;
    end;
    if (RepSpec.flags[1]==0 and RetPUr.OKFlag!=0) then begin
      testf = false;
    end;
    if (nonblank(RepSpec.f2) and RetPUr.FreightCode!=RepSpec.f2) then begin
      testf = false;
    end;
    if (testf) then begin
      res = true;
      TrHs = false;
    end;
  end;
  
  GetNextRetPU = res;
  return;
end;

function Boolean GetNextStockMov(record RcVc RepSpec,var record StockMovVc StockMovr)
begin
  Boolean res,TrHs,testf;
  
  TrHs = true;
  while (LoopKey("SortingDate",StockMovr,2,TrHs)) begin
    if (StockMovr.SentTransDate>RepSpec.sEndDate) then begin
      TrHs = false;
    end;
    testf = TrHs;
    if (StockMovr.OKFlag!=0) then begin
      testf = false;
    end;
    if (RepSpec.flags[0]==0 and StockMovr.SentOKFlag==0) then begin
      testf = false;
    end;
    if (RepSpec.flags[1]==0 and StockMovr.SentOKFlag!=0) then begin
      testf = false;
    end;
    if (nonblank(RepSpec.f2) and StockMovr.FreightCode!=RepSpec.f2) then begin
      testf = false;
    end;
    if (testf) then begin
      res = true;
      TrHs = false;
    end;
  end;
  
  GetNextStockMov = res;
  return;
end;

procedure PrintSH(record RcVc RepSpec,record SHVc SHr,var val TotVolume,var val TotWeight)
begin
  row SHVc SHrw;
  Integer i,rwcnt;
  record INVc INr;
  val Volume,Weight;
  
  switch (RepSpec.ArtMode) begin
    case 0:
      rwcnt = MatRowCnt(SHr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SHr,i,SHrw);
        INr.Code = SHrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          Volume = Volume + SHrw.Ship * INr.Volume;
          Weight = Weight + SHrw.Ship * INr.Weight;
        end;
      end;
      StartFormat(15);
      OutString(0,0,USetStr(5003),false);
      OutString(2,"DblSHVc",SHr.SerNr,false);
      OutString(3,0,SHr.Sorting,false);
      OutString(4,0,SHr.CustCode,false);
      OutString(5,0,SHr.Addr0,false);
      OutVal(6,0,Volume,M45Val,true);
      OutVal(7,0,Weight,M45Val,true);
      EndFormat;
    case 1:
      StartFormat(15);
      OutString(0,0,USetStr(5003),false);
      OutString(2,"DblSHVc",SHr.SerNr,false);
      OutString(3,0,SHr.Sorting,false);
      OutString(4,0,SHr.CustCode,false);
      OutString(5,0,SHr.Addr0,false);
      EndFormat;
      StartFormat(15);
      OutString(11,0,USetStr(26310),false);
      OutString(80,0,USetStr(26311),false);
      OutString(280,0,USetStr(26312),true);
      OutString(290,0,USetStr(26313),false);
      OutString(330,0,USetStr(26314),false);
      OutString(6,0,USetStr(26307),true);
      OutString(7,0,USetStr(26308),true);
      EndFormat;
      Gray_Divider(11,1);
      rwcnt = MatRowCnt(SHr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SHr,i,SHrw);
        INr.Code = SHrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          StartFormat(15);
          OutString(11,"DblINVc",SHrw.ArtCode,false);
          OutString(80,0,SHrw.Spec,false);
          OutVal(280,0,SHrw.Ship,M4UVal,true);
          OutString(290,0,INr.Unittext,false);
          OutString(330,0,SHrw.SerialNr,false);
          OutVal(6,0,SHrw.Ship * INr.Volume,M45Val,true);
          OutVal(7,0,SHrw.Ship * INr.Weight,M45Val,true);
          EndFormat;
          Volume = Volume + SHrw.Ship * INr.Volume;
          Weight = Weight + SHrw.Ship * INr.Weight;
        end;
      end;
      if (Volume!=blankval or Weight!=blankval) then begin
        Gray_Divider(11,1);
        StartFormat(15);
        OutVal(6,0,Volume,M45Val,true);
        OutVal(7,0,Weight,M45Val,true);
        EndFormat;
      end;
  end;
  TotVolume = TotVolume + Volume;
  TotWeight = TotWeight + Weight;
  
  return;
end;

procedure PrintRetPU(record RcVc RepSpec,record RetPUVc RetPUr,var val TotVolume,var val TotWeight)
begin
  row RetPUVc RetPUrw;
  Integer i,rwcnt;
  record INVc INr;
  val Volume,Weight;
  
  switch (RepSpec.ArtMode) begin
    case 0:
      rwcnt = MatRowCnt(RetPUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        INr.Code = RetPUrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          Volume = Volume + RetPUrw.Quant * INr.Volume;
          Weight = Weight + RetPUrw.Quant * INr.Weight;
        end;
      end;
      StartFormat(15);
      OutString(0,0,USetStr(5058),false);
      OutString(2,"DblRetPU",RetPUr.SerNr,false);
      OutString(3,0,RetPUr.Sorting,false);
      OutString(4,0,RetPUr.VECode,false);
      OutString(5,0,RetPUr.VEName,false);
      OutVal(6,0,Volume,M45Val,true);
      OutVal(7,0,Weight,M45Val,true);
      EndFormat;
    case 1:
      StartFormat(15);
      OutString(0,0,USetStr(5058),false);
      OutString(2,"DblRetPU",RetPUr.SerNr,false);
      OutString(3,0,RetPUr.Sorting,false);
      OutString(4,0,RetPUr.VECode,false);
      OutString(5,0,RetPUr.VEName,false);
      EndFormat;
      StartFormat(15);
      OutString(11,0,USetStr(26310),false);
      OutString(80,0,USetStr(26311),false);
      OutString(280,0,USetStr(26312),true);
      OutString(290,0,USetStr(26313),false);
      OutString(330,0,USetStr(26314),false);
      OutString(6,0,USetStr(26307),true);
      OutString(7,0,USetStr(26308),true);
      EndFormat;
      Gray_Divider(11,1);
      rwcnt = MatRowCnt(RetPUr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(RetPUr,i,RetPUrw);
        INr.Code = RetPUrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          StartFormat(15);
          OutString(11,"DblINVc",RetPUrw.ArtCode,false);
          OutString(80,0,RetPUrw.Spec,false);
          OutVal(280,0,RetPUrw.Quant,M4UVal,true);
          OutString(290,0,INr.Unittext,false);
          OutString(330,0,RetPUrw.SerialNr,false);
          OutVal(6,0,RetPUrw.Quant * INr.Volume,M45Val,true);
          OutVal(7,0,RetPUrw.Quant * INr.Weight,M45Val,true);
          EndFormat;
          Volume = Volume + RetPUrw.Quant * INr.Volume;
          Weight = Weight + RetPUrw.Quant * INr.Weight;
        end;
      end;
      if (Volume!=blankval or Weight!=blankval) then begin
        Gray_Divider(11,1);
        StartFormat(15);
        OutVal(6,0,Volume,M45Val,true);
        OutVal(7,0,Weight,M45Val,true);
        EndFormat;
      end;
  end;
  TotVolume = TotVolume + Volume;
  TotWeight = TotWeight + Weight;
  
  return;
end;

procedure PrintStockMov(record RcVc RepSpec,record StockMovVc StockMovr,var val TotVolume,var val TotWeight)
begin
  row StockMovVc StockMovrw;
  Integer i,rwcnt;
  record INVc INr;
  val Volume,Weight;
  record LocationVc Locationr;
  
  Locationr.Code = StockMovr.ToLocation;
  ReadFirstMain(Locationr,1,true);

  switch (RepSpec.ArtMode) begin
    case 0:
      rwcnt = MatRowCnt(StockMovr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(StockMovr,i,StockMovrw);
        INr.Code = StockMovrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          Volume = Volume + StockMovrw.OrdQuant * INr.Volume;
          Weight = Weight + StockMovrw.OrdQuant * INr.Weight;
        end;
      end;
      StartFormat(15);
      OutString(0,0,USetStr(5012),false);
      OutString(2,"DblStockMov",StockMovr.SerNr,false);
      OutString(3,0,StockMovr.Sorting,false);
      OutString(4,0,StockMovr.ToLocation,false);
      OutString(5,0,Locationr.Name,false);
      OutVal(6,0,Volume,M45Val,true);
      OutVal(7,0,Weight,M45Val,true);
      EndFormat;
    case 1:
      StartFormat(15);
      OutString(0,0,USetStr(5012),false);
      OutString(2,"DblStockMov",StockMovr.SerNr,false);
      OutString(3,0,StockMovr.Sorting,false);
      OutString(4,0,StockMovr.ToLocation,false);
      OutString(5,0,Locationr.Name,false);
      EndFormat;
      StartFormat(15);
      OutString(11,0,USetStr(26310),false);
      OutString(80,0,USetStr(26311),false);
      OutString(280,0,USetStr(26312),true);
      OutString(290,0,USetStr(26313),false);
      OutString(330,0,USetStr(26314),false);
      OutString(6,0,USetStr(26307),true);
      OutString(7,0,USetStr(26308),true);
      EndFormat;
      Gray_Divider(11,1);
      rwcnt = MatRowCnt(StockMovr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(StockMovr,i,StockMovrw);
        INr.Code = StockMovrw.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin
          StartFormat(15);
          OutString(11,"DblINVc",StockMovrw.ArtCode,false);
          OutString(80,0,StockMovrw.Spec,false);
          OutVal(280,0,StockMovrw.OrdQuant,M4UVal,true);
          OutString(290,0,INr.Unittext,false);
          OutString(330,0,StockMovrw.SerialNr,false);
          OutVal(6,0,StockMovrw.OrdQuant * INr.Volume,M45Val,true);
          OutVal(7,0,StockMovrw.OrdQuant * INr.Weight,M45Val,true);
          EndFormat;
          Volume = Volume + StockMovrw.OrdQuant * INr.Volume;
          Weight = Weight + StockMovrw.OrdQuant * INr.Weight;
        end;
      end;
      if (Volume!=blankval or Weight!=blankval) then begin
        Gray_Divider(11,1);
        StartFormat(15);
        OutVal(6,0,Volume,M45Val,true);
        OutVal(7,0,Weight,M45Val,true);
        EndFormat;
      end;
  end;
  TotVolume = TotVolume + Volume;
  TotWeight = TotWeight + Weight;
  
  return;
end;

function string 100 PrintWhat(Boolean LoopSH,record SHVc SHr,Boolean LoopRetPU,record RetPUVc RetPUr,Boolean LoopStockMov,record StockMovVc StockMovr,var string Sorting)
begin
  string 100 res,tstr,Priority;
  Integer pos;
  
  if (LoopSH) then begin
    M4PadString(SHr.Sorting,20," ",false,tstr);
    tstr = tstr & DateToString(SHr.ShipDate,"YYYYMMDD") & "0|SHVc";
    if (blank(Priority) or tstr<Priority) then begin
      Priority = tstr;
    end;
  end;
  if (LoopRetPU) then begin
    M4PadString(RetPUr.Sorting,20," ",false,tstr);
    tstr = tstr & DateToString(RetPUr.TransDate,"YYYYMMDD") & "1|RetPUVc";
    if (blank(Priority) or tstr<Priority) then begin
      Priority = tstr;
    end;
  end;
  if (LoopStockMov) then begin
    M4PadString(StockMovr.Sorting,20," ",false,tstr);
    tstr = tstr & DateToString(StockMovr.SentTransDate,"YYYYMMDD") & "2|StockMovVc";
    if (blank(Priority) or tstr<Priority) then begin
      Priority = tstr;
    end;
  end;
  if (nonblank(Priority)) then begin
    pos = Len(Priority);
    while (pos>0 and Mid(Priority,pos,1)!="|") begin
      res = Mid(Priority,pos,1) & res;
      pos = pos - 1;
    end;
  end;
  switch (res) begin
    case "SHVc": Sorting = SHr.Sorting;
    case "RetPUVc": Sorting = RetPUr.Sorting;
    case "StockMovVc": Sorting = StockMovr.Sorting;
  end;
  
  PrintWhat = res;
  return;
end;

global
procedure TripSheetRn(record RcVc RepSpec)
begin
  record SHVc SHr;
  record StockMovVc StockMovr;
  record RetPUVc RetPUr;
  Boolean LoopGlobal,LoopSH,LoopStockMov,LoopRetPU,Test,SortingPrinted,FirstRecord;
  string 20 CurSorting,NewSorting,PrintWhatRes;
  string 255 tstr;
  Integer rw;
  val TotVolume,TotWeight;
  
  StartReportJob(USetStr(26300));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f1)) then begin
    HTRoute(RepSpec.f1,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  tstr = "";
  if (RepSpec.flags[2]!=0) then begin
    tstr = AddStr(tstr,USetStr(1334),", ");
  end;
  if (RepSpec.flags[3]!=0) then begin
    tstr = AddStr(tstr,USetStr(11698),", ");
  end;
  if (RepSpec.flags[4]!=0) then begin
    tstr = AddStr(tstr,USetStr(1336),", ");
  end;
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  HTOKF(RepSpec.flags[0],RepSpec.flags[1],tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  EndHeader;
  
  SetRepCol(2,50);
  SetRepCol(3,100);
  SetRepCol(4,150);
  SetRepCol(5,200);
  switch (RepSpec.ArtMode) begin
    case 0:
      SetRepCol(6,380);
      SetRepCol(7,430);
      SetRepCol(8,330);
    case 1:
      SetRepCol(6,430);
      SetRepCol(7,480);
      SetRepCol(8,380);
  end;
  
  LoopGlobal = true;
  CurSorting = FirstInRange(RepSpec.f1,20);
  
  StartFormat(15);
  OutString(0,0,USetStr(26302),false);
  OutString(2,0,USetStr(26303),false);
  OutString(3,0,USetStr(26304),false);
  OutString(4,0,USetStr(26305),false);
  OutString(5,0,USetStr(26306),false);
  if (RepSpec.ArtMode==0) then begin
    OutString(6,0,USetStr(26307),true);
    OutString(7,0,USetStr(26308),true);
    OutString(1,0,USetStr(26309),true);
  end;
  EndFormat;
  Black_Divider(0,1);
  
  while (LoopGlobal) begin
    LoopGlobal = false;
    SortingPrinted = false;
    FirstRecord = true;
    
    if (RepSpec.flags[2]!=0) then begin
      ResetLoop(SHr);
      SHr.Sorting = CurSorting;
      SHr.ShipDate = RepSpec.sStartDate;
      LoopSH = GetNextSH(RepSpec,SHr);
    end;
    if (RepSpec.flags[3]!=0) then begin
      ResetLoop(RetPUr);
      RetPUr.Sorting = CurSorting;
      RetPUr.TransDate = RepSpec.sStartDate;
      LoopRetPU = GetNextRetPU(RepSpec,RetPUr);
    end;
    if (RepSpec.flags[4]!=0) then begin
      ResetLoop(StockMovr);
      StockMovr.Sorting = CurSorting;
      StockMovr.SentTransDate = RepSpec.sStartDate;
      LoopStockMov = GetNextStockMov(RepSpec,StockMovr);
    end;
    
    while (LoopSH or LoopStockMov or LoopRetPU) begin
      PrintWhatRes = PrintWhat(LoopSH,SHr,LoopRetPU,RetPUr,LoopStockMov,StockMovr,NewSorting);
      if (NewSorting==CurSorting) then begin
        SortingPrinted = true;
        if (nonblank(PrintWhatRes) and RepSpec.ArtMode==1) then begin
          if (!FirstRecord) then begin
            Gray_Divider(0,1);
          end;
          FirstRecord = false;
        end;
        switch (PrintWhatRes) begin
          case "SHVc":
            PrintSH(RepSpec,SHr,TotVolume,TotWeight);
            LoopSH = GetNextSH(RepSpec,SHr);
          case "RetPUVc":
            PrintRetPU(RepSpec,RetPUr,TotVolume,TotWeight);
            LoopRetPU = GetNextRetPU(RepSpec,RetPUr);
          case "StockMovVc":
            PrintStockMov(RepSpec,StockMovr,TotVolume,TotWeight);
            LoopStockMov = GetNextStockMov(RepSpec,StockMovr);
          otherwise
            LoopSH = false;
            LoopRetPU = false;
            LoopStockMov = false;
        end;
      end else begin
        LoopSH = false;
        LoopRetPU = false;
        LoopStockMov = false;
        CurSorting = NewSorting;
        if (blank(RepSpec.f1) or NewSorting<=LastInRange(RepSpec.f1,20)) then begin
          LoopGlobal = true;
        end;
      end;
    end;
  end;
  
  Black_Divider(0,1);
  StartFormat(15);
  OutString(8,0,USetStr(26315),true);
  OutVal(6,0,TotVolume,M45Val,true);
  OutVal(7,0,TotWeight,M45Val,true);
  EndFormat;
  
  EndJob;
  return;
end;
