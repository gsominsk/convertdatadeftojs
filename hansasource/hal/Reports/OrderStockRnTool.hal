external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetStockValue(string,string,var record ItemStatusVc);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);

global
procedure SetupOrder_OrderStockRn(record ORVc ORp,Integer amounts,record MainStockBlock MainStockRec)
BEGIN
  record INVc INr;
  record ItemStatusVc ISr;
  row ORVc ORrw;
  Integer i,rwcnt;
  val qty,t,rowv;
  record GeneralOptionBlock GenOptRec;
  record TaxMatrixVc TMr;

  BlockLoad(GenOptRec);
  rwcnt = MatRowCnt(ORp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    ORrw.rowGP = blankval;
    if (ORrw.stp==1) then begin
      if (nonblank(ORrw.ArtCode)) then begin
        if (ReadFirstItem(ORrw.ArtCode,INr,false,false)) then begin
          if (amounts==0) then begin
            if (ORp.InvBeforeShip==0) then begin
              qty = ORrw.Quant - ORrw.Invd;
            end else begin
              qty = ORrw.Quant - ORrw.Shipd2;
            end;  
            CalcSum(qty,ORrw.Price,ORrw.PriceFactor,ORrw.vRebate,rowv,GenOptRec.UseDiscount);
//            rowv = qty*ORrw.Price; it is just calculated abpove
            UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
            FindSalesExVat(TMr,ORrw.VATCode,rowv,ORp.InclVAT,ORp.NoTAXonVAT,rowv);
            t = qty*ORrw.BasePrice;
            if (ORrw.PriceFactor!=0) then begin
              t = t/ORrw.PriceFactor;
              rowv = rowv/ORrw.PriceFactor;
            end;
            ORrw.rowGP = rowv - t;
          end else begin
            if (INr.ItemType==1) then begin
              GetStockValue(ORrw.ArtCode,ORp.Location,ISr);
              ORrw.rowGP = ISr.Instock; /* ugly, but rowGP is never used, so no it is stock level */
            end;
          end;
        end;
      end;
    end;
    MatRowPut(ORp,i,ORrw);
  end;
  RETURN;
END;

