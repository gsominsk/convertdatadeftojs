external function Boolean HasExtraNLComment();
external procedure FindFiscalYear(Date,var Date,var Date);
external function Integer TypeOfCurncy(var string,var Integer);
external procedure TransRnHeader(record RcVc);
external procedure AddToVAT2Sum(record SMVc,string,val,val);
external procedure AddToVATSum(record SMVc,string,val);
external function Boolean GetAccName(string,var string,Integer);
external procedure ClearAcums();
external procedure TRExtYc(record TRVc,var string);
external procedure GetFullCurncyRateText(Boolean,var string,val,val,val,val,val);
external procedure PrintTrrCurrency(string,val,val,Integer,val,val,val,val,val);
external procedure HT2Per(Date, Date , var string);
external procedure HTDetailLevel(Integer, var string);
external procedure HTAccs(string,string,Integer, var string);
external procedure HTObj(string,var string);
external procedure HTValuesIn(Integer,var string);


procedure ListPerSM(record RcVc RepSpec,array record SMVc aSMr)
begin
  record SMVc SMr;
  row SMVc SMrw;
  Boolean TrHs;
  val csum,dsum,totcsum,totdsum;
  Integer hit,i,rwcnt,j;

  StartFormat(20);
   OutString(0,0,USetStr(36253),false);
   OutStringAdjustBiDi(380,0,USetStr(3187),true,M4Val,430);
   OutStringAdjustBiDi(5,0,USetStr(3188),true,M4Val,520);
  EndFormat;
  TrHs = true;
  for (i=0;i<aSMr.length;i=i+1) begin
    SMr = aSMr[i];
    switch (RepSpec.basecurncy) begin
      case 0:
        dsum = dsum + SMr.DSum;
        csum = csum - SMr.CSum;
      case 1:
        rwcnt = MatRowCnt(SMr);
        for (j=0;j<rwcnt;j=j+1) begin
          MatRowGet(SMr,i,SMrw);
          dsum = dsum + SMrw.DebVal2;
          csum = csum - SMrw.CredVal2;
        end;
    end;
    StartFormat(15);
    OutString(0,0,SMr.Comment,false);
    OutValBiDi(380,0,dsum,M4Val,true,430);
    OutValBiDi(5,0,csum,M4Val,true,520);
    EndFormat;
  end;
  totdsum = totdsum + dsum;
  totcsum = totcsum + csum;
  Gray_Divider(200,480);
  StartFormat(15);
  OutString(15,0,USetStr(3196),false);
  OutValBiDi(380,0,totdsum,M4Val,true,430);
  OutValBiDi(5,0,totcsum,M4Val,true,520);
  EndFormat;
  return;
end;

procedure FormSMr(record RcVc RepSpec,record SMVc SMr,Integer smrow,var val transump,record SMVc SMaccr,Boolean printf,var array val aGroupd,var array val aGroupc)
begin
  string 255 tstr,tstr2;
  record AccVc Accr;
  row AccVc Accrw;
  row SMVc SMrw;
  Integer i,rwcnt;  
  Boolean Accs;
  val sv;

  MatRowGet(SMr,smrow,SMrw);
  if (printf) then begin
    StartFormat(15);
  end;
  if (RepSpec.basecurncy==0) then begin
    aGroupd[SMrw.RowSimStat] = aGroupd[SMrw.RowSimStat] + SMrw.DebVal;
    aGroupc[SMrw.RowSimStat] = aGroupc[SMrw.RowSimStat] + SMrw.CredVal;
  end else begin
    aGroupd[SMrw.RowSimStat] = aGroupd[SMrw.RowSimStat] + SMrw.DebVal2;
    aGroupc[SMrw.RowSimStat] = aGroupc[SMrw.RowSimStat] + SMrw.CredVal2;
  end;
  Accr.AccNumber = SMrw.AccNumber;
  Accs = ReadFirstMain(Accr,1,true);
  tstr = Accr.Comment;
  if (nonblank(SMrw.Comment)) then begin
    tstr2 = Left(Accr.Comment,len(SMrw.Comment));
    if (SMrw.Comment<>tstr2) then begin tstr = SMrw.Comment; end;
    if (nonblank(RepSpec.Language)) then begin           
      rwcnt = MatRowCnt(Accr);
      for (i=0; i<rwcnt; i=i+1) begin
        MatRowGet(Accr,i,Accrw);
        if (Accrw.LangCode==RepSpec.Language) then begin
          if (nonblank(Accrw.Text)) then begin
            tstr = Accrw.Text;
          end;  
          i = rwcnt;               
        end;
      end;  
    end;                  
  end;
  if (RepSpec.basecurncy==0) then begin
    transump = SMrw.DebVal + transump;
  end else begin
    transump = SMrw.DebVal2 + transump;
  end;  
  if (printf) then begin
    OutString(20,0,SMrw.AccNumber,false);
    OutString(80,0,SMrw.Objects,false);
    OutString(150,0,SMrw.TransDate,false);
    OutString(190,0,tstr,false);
    if (HasExtraNLComment) and (nonblank(SMrw.ExtraComment)) then begin
      OutString(190,0,SMrw.ExtraComment,false);
    end;
  end;
  if (RepSpec.basecurncy==0) then begin
    if (printf) then begin
      OutVal(380,0,SMrw.DebVal,M4Val,true);
      OutVal(5,0,SMrw.CredVal,M4Val,true);
      AddToAccumulator(0,SMrw.DebVal);
      AddToAccumulator(1,SMrw.CredVal);
      AddToAccumulator(2,SMrw.DebVal);
      AddToAccumulator(3,SMrw.CredVal);
    end else begin
      AddToAccumulator(4,SMrw.DebVal);
      AddToAccumulator(5,SMrw.CredVal);
      AddToAccumulator(2,SMrw.DebVal);
      AddToAccumulator(3,SMrw.CredVal);
    end;
  end else begin
    if (printf) then begin
      OutVal(380,0,SMrw.DebVal2,M4Val,true);
      OutVal(5,0,SMrw.CredVal2,M4Val,true);
      AddToAccumulator(0,SMrw.DebVal2);
      AddToAccumulator(1,SMrw.CredVal2);      
      AddToAccumulator(2,SMrw.DebVal2);
      AddToAccumulator(3,SMrw.CredVal2);
    end else begin
      AddToAccumulator(4,SMrw.DebVal2);
      AddToAccumulator(5,SMrw.CredVal2);
      AddToAccumulator(2,SMrw.DebVal2);
      AddToAccumulator(3,SMrw.CredVal2);
    end;
  end;  
  if (RepSpec.flags[29]==0) then begin
    if (printf) then begin
      OutString(1,0,SMrw.VATCode,true);
    end;
  end;    
  if (RepSpec.basecurncy==0) then begin          
    sv = SMrw.DebVal - SMrw.CredVal;
  end else begin
    sv = SMrw.DebVal2 - SMrw.CredVal2;
  end;  
  if (printf) then begin
    EndFormat;
    PrintTrrCurrency(SMrw.CurncyCode,SMrw.CurDebVal,SMrw.CurCredVal,0,SMrw.FrRate,SMrw.ToRateB1,SMrw.ToRateB2,SMrw.BaseRate1,SMrw.BaseRate2);
  end;
  return;
end;

function Integer GetCurrentNumberSeries(record SMSerBlock Serbl,Integer scnt,Longint sernr,var string sercom)
begin
  Integer res;
  Integer i;
  row SMSerBlock Serrw;
  
  for (i=0;i<scnt;i=i+1) begin
    MatRowGet(Serbl,i,Serrw);
    if (sernr>=Serrw.TSerStart and sernr<=Serrw.TSerEnd) then begin
      res = i;
      sercom = Serrw.TSerCom;
      i = scnt;
    end;
  end;

  GetCurrentNumberSeries = res;
  return;
end;

procedure DisplayGroupTotals(record RCVc RepSpec,array val aGroupd,array val aGroupc,val dsum,val csum,Boolean printf,string sercom,Boolean groupf)
begin
  Integer i;

  if (RepSpec.flags[19]==1 and groupf) then begin
    StartFormat(1);
    Gray_divider(0,1);
    EndFormat;
    for (i=0;i<5;i=i+1) begin
      if (aGroupd[i]!=0 or aGroupc[i]!=0) then begin
        StartFormat(15);
        OutString(0,0,UsetStr(36254) & ": " & UsetStr(36260+i),false);
        if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
          OutString(260,0,"",false);
          OutString(260,0,"",false);
        end;
        OutVal(380,0,aGroupd[i],M4Val,true);
        OutVal(5,0,aGroupc[i],M4Val,true);
        EndFormat;
      end;
    end;
  end;
  if (printf) then begin
    StartFormat(15);
    if (blank(sercom)) then begin
      OutString(0,0,UsetStr(36254) & sercom,false);
    end else begin
      OutString(0,0,UsetStr(36254) & " : " & sercom,false);
    end;
    if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
      OutString(260,0,"",false);
      OutString(260,0,"",false);
    end;
    OutValBiDi(380,0,dsum,M4Val,true,430);
    OutVal(5,0,csum,M4Val,true);
    EndFormat;
  end;

  return;
end;

procedure RunTransRn1(record RcVc RepSpec,Boolean printf,var val TransSum,var record SMVc SMaccr,integer type,var array record SMVc aSMr)
begin
  record SMVc SMr;
  row SMVc SMrw;
  row SMVc tSMrw;
  Integer i,j,rwcnt;
  Boolean TrHs;
  string 255 tstr;
  string 40 ckey;
  Boolean testf;
  Integer yc1,yc2;
  LongInt n1,n2;
  val sv;
  val pdsum,pcsum;
  val totdeb,totcred;  
  Integer keys,hit;
  val dsum,csum;
  LongInt oldno,newNoSer;
  LongInt oldYc;
  val groupdeb,groupcred;
  string 60 groupcom;
  string 60 newgroupcom;
  Boolean valf,typef;
  array val aGroupd,aGroupc;
  record SMSerBlock Serbl;
  Longint curser,lastser;
  Integer scnt;
  string 100 sercom,newsercom;
  
  BlockLoad(Serbl);
  scnt = MatRowCnt(Serbl);
  n1 = StringToLongInt(FirstInRange(RepSpec.f1,20));
  n2 = StringToLongInt(LastInRange(RepSpec.f1,20));
  TrHs = true;
  SMr.SerNr = n1;
  while (LoopMain(SMr,1,TrHs)) begin
    if (nonblank(RepSpec.f1) and SMr.SerNr>n2) then begin 
      TrHs = false; 
    end else begin
      testf = true;
      if (DateInRange(SMr.TransDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin testf = false; end;
      if (testf) then begin 
        testf = false;      
        rwcnt = MatRowCnt(SMr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SMr,i,SMrw);
          typef = false; valf = false;
          if ((blank(RepSpec.f2) or SMrw.AccNumber==RepSpec.f2) and (blank(RepSpec.f3) or (SetInSet(RepSpec.f3,SMrw.Objects)))) then begin 
            valf = true; 
          end;
          switch (SMrw.RowSimStat) begin
            case 0: if (RepSpec.flags[20]==1) then begin typef = true; end;
            case 1: if (RepSpec.flags[21]==1) then begin typef = true; end;
            case 2: if (RepSpec.flags[22]==1) then begin typef = true; end;
            case 3: if (RepSpec.flags[23]==1) then begin typef = true; end;
            case 4: if (RepSpec.flags[24]==1) then begin typef = true; end;
          end;
          if (valf and typef) then begin
            testf = true;
            i = rwcnt;
          end;
        end;
      end;
      
      if (testf) then begin
        curser = GetCurrentNumberSeries(Serbl,scnt,SMr.SerNr,newsercom);
        if (lastser!=curser and lastser!=-1) then begin
          DisplayGroupTotals(RepSpec,aGroupd,aGroupc,dsum,csum,printf,sercom,false);
          dsum = 0;
          csum = 0;
        end;
        lastser = curser;
        sercom = newsercom;
      
        if (printf) and (RepSpec.ArtMode==1) then begin        
          Gray_Divider(0,1);
          StartFormat(15);
          OutString(0,"DblSMVc",SMr.SerNr,false);
          OutDate(80,0,SMr.TransDate,false);
          OutString(140,0,SMr.RefStr,false);
          OutString(200,0,SMr.Comment,false);
          OutString(1,0,SMr.Sign,true);        
          EndFormat;
        end;
        rwcnt = MatRowCnt(SMr);
        pdsum = 0;
        pcsum = 0;
        aSMr[aSMr.length] = SMr;
        for (i=0 ;i<rwcnt; i=i+1) begin
          MatRowGet(SMr,i,SMrw);
          testf = false;
          typef = false; valf = false;
          if ((blank(RepSpec.f2) or SMrw.AccNumber==RepSpec.f2) and (blank(RepSpec.f3) or (SetInSet(RepSpec.f3,SMrw.Objects)))) then begin 
            valf = true; 
          end;
          switch (SMrw.RowSimStat) begin
            case 0: if (RepSpec.flags[20]==1) then begin typef = true; end;
            case 1: if (RepSpec.flags[21]==1) then begin typef = true; end;
            case 2: if (RepSpec.flags[22]==1) then begin typef = true; end;
            case 3: if (RepSpec.flags[23]==1) then begin typef = true; end;
            case 4: if (RepSpec.flags[24]==1) then begin typef = true; end;
          end;
          if (valf and typef) then begin
            testf = true;
          end;
          if (testf) then begin
            FormSMr(RepSpec,SMr,i,TransSum,SMaccr,printf and RepSpec.ArtMode==1,aGroupd,aGroupc);
            if (RepSpec.basecurncy==0) then begin
              pdsum = pdsum + SMrw.DebVal;
              pcsum = pcsum + SMrw.CredVal;
              dsum = dsum + SMrw.DebVal;
              csum = csum + SMrw.CredVal;
              AddToVAT2Sum(SMaccr,SMrw.AccNumber,SMrw.DebVal,SMrw.CredVal);
            end else begin
              pdsum = pdsum + SMrw.DebVal2;
              pcsum = pcsum + SMrw.CredVal2;
              dsum = dsum + SMrw.DebVal2;
              csum = csum + SMrw.CredVal2;
              AddToVAT2Sum(SMaccr,SMrw.AccNumber,SMrw.DebVal2,SMrw.CredVal2);
            end;
          end;
        end;
        if (printf) and (RepSpec.ArtMode==1) then begin
          Black_Divider(300,480);
        end;
        if (printf) and (RepSpec.ArtMode==0) then begin    
          if (dsum!=0) or (csum!=0) then begin
            StartFormat(15);
            OutString(0,"DblSMVc",SMr.SerNr,false);
            OutDate(80,0,SMr.TransDate,false);
            OutString(140,0,SMr.RefStr,false);
            OutString(200,0,SMr.Comment,false);
            OutString(1,0,SMr.Sign,true);        
            EndFormat;
          end;
        end;
        DisplayGroupTotals(RepSpec,aGroupd,aGroupc,pdsum,pcsum,printf,sercom,false);
      end;
    end;
    if (printf) then begin
      StartFooter(45,true);
        Black_Divider(0,1);
        OutString(200,0,USetStr(2412),false)
        OutAccumulator(380,4,M4Val,true);
        OutAccumulator(5,5,M4Val,true);
        OutString(200,0,USetStr(2413),false)
        OutAccumulator(380,0,M4Val,true);
        OutAccumulator(5,1,M4Val,true);
        ClearAccumulator(0);
        ClearAccumulator(1);
        OutString(200,0,USetStr(2414),false)
        OutAccumulator(380,2,M4Val,true);
        OutAccumulator(5,3,M4Val,true);
        CopyAccumulator(4,2);
        CopyAccumulator(5,3);
      EndFooter;    
    end;
  end;
  DisplayGroupTotals(RepSpec,aGroupd,aGroupc,dsum,csum,printf,sercom,true);

  return;
end;  

procedure RunSimRn(var record RcVc RepSpec,Boolean printf)
begin
  record SMVc SMr;
  row SMVc SMrw;
  record SMVc SMaccr;
  Integer i,j,rwcnt,vatrows,prwcnt;
  Boolean TrHs;
  string 255 tstr;
  string 40 ckey;
  Boolean testf;
  Integer yc1,yc2;
  LongInt n1,n2;
  val TransSum,sv;
  val pdsum,pcsum;
  val totdeb,totcred;  
  Integer keys,hit;
  record VATCodeBlock VATCodeRec;
  row VATCodeBlock VATCoderw;
  val dsum,csum;
  LongInt oldno,newNoSer;
  LongInt oldYc;
  val groupdeb,groupcred;
  string 60 groupcom;
  string 60 newgroupcom;
  array record SMVc aSMr;
 
  RepSpec.long1 = FirstTransInRange(RepSpec.f1);
  RepSpec.long2 = LastTransInRange(RepSpec.f1);
  RepSpec.flags[0] = FirstTransTypeInRange(RepSpec.f1);
  RepSpec.flags[1] = LastTransTypeInRange(RepSpec.f1);  

  RecordNew(SMaccr);
  RunTransRn1(RepSpec,printf,TransSum,SMaccr,0,aSMr);
  
  if (printf) then begin        
    Gray_Divider(0,1);
    StartFormat(15);
    OutString(0,0,USetStr(36252),false);
    if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
      OutString(260,0,"",false);
      OutString(260,0,"",false);
    end;
    OutValBiDi(380,0,TransSum,M4Val,true,430);
    OutVal(5,0,TransSum,M4Val,true);
    EndFormat;
    StartFormat(15);
    EndFormat;
    StartFormat(15);
    OutString(0,0,USetStr(3079),false);
    OutLongInt(70,0,aSMr.length,false);
    EndFormat;
  end;    
  if (RepSpec.flags[5]==1) then begin
    vatrows = MatRowCnt(SMaccr);
    if (vatrows>0) then begin
      totdeb = 0;
      totcred = 0;
      if (printf) then begin
        StartFormat(15);
        EndFormat;
        StartFormat(15);
        OutString(100,0,USetStr(2407),false);
        OutStringAdjustBiDi(380,0,USetStr(3187),true,M4Val,430);
        OutStringAdjust(5,0,USetStr(3188),true,M4Val);
        EndFormat;
        Gray_Divider(100,1);
      end;
      for (i=0;i<vatrows;i=i+1) begin
        MatRowGet(SMaccr,i,SMrw);
        if (GetAccName(SMrw.AccNumber,tstr,60)) then begin end;
        if (printf) then begin
          StartFormat(15);
          OutString(100,0,SMrw.AccNumber,false);
          OutString(150,0,tstr,false);
          if (RepSpec.basecurncy==0) then begin               
            OutValBiDi(380,0,SMrw.DebVal,M4Val,true,430);
            OutVal(5,0,SMrw.CredVal,M4Val,true);
          end else begin
            OutValBiDi(380,0,SMrw.DebVal2,M4Val,true,430);
            OutVal(5,0,SMrw.CredVal2,M4Val,true);
          end;          
          EndFormat;
        end;
        if (RepSpec.basecurncy==0) then begin               
          totdeb = totdeb + SMrw.DebVal;
          totcred = totcred + SMrw.CredVal;
        end else begin
          totdeb = totdeb + SMrw.DebVal2;
          totcred = totcred + SMrw.CredVal2;
        end;
      end;
      if (printf) then begin
        Gray_Divider(100,1);
        StartFormat(15);
        OutValBiDi(380,0,totdeb,M4Val,true,430);
        OutVal(5,0,totcred,M4Val,true);
        EndFormat;
      end;
    end;
  end;
  if (printf) then begin
    if (RepSpec.flags[4]<>0) then begin 
      ListPerSM(RepSpec,aSMr); 
    end;  
  end;
  return;
end;

procedure BuildSimTypeString(record RCVc RepSpec,var string tstr)
begin
  Integer i;
  string 2 tmp;
  
  tstr = "";
  for (i=0;i<6;i=i+1) begin
    tmp = GetFieldValueByName(RepSpec,"flags[2" & i & "]",-1);
    if (tmp=="1") then begin
      if (nonblank(tstr)) then begin
        tstr = tstr & ", ";
      end;
      tstr = tstr & UsetStr(36260+i);
    end;
  end;

  return;
end;

global
procedure SMJRn(var record RcVc RepSpec)
begin
  Date FStartDate,FEndDate,blankd;
  Date sd,ed;
  string 255 tstr;
  Integer rw;

  StartReportJob(USetStr(3061));
  rw = 1;  
  if (blank(RepSpec.f1)) then begin
    tstr = UsetStr(36256);
  end else begin
    tstr = UsetStr(36257) & RepSpec.f1;
  end;
  Header(rw,tstr,1);
  rw = rw + 1;  
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTAccs(RepSpec.f2,RepSpec.f2,0,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f3)) then begin
    tstr = USetStr(3015) & RepSpec.f3;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  HTValuesIn(RepSpec.basecurncy+1,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  BuildSimTypeString(RepSpec,tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  EndHeader;
  SetRepCol(2,80);
  SetRepCol(3,288);
  SetRepCol(4,384);
  SetRepColBiDi(5,465,515);
  SetRepCol(8,413);
  SetRepCol(9,221);
  SetRepCol(6,130);
  SetRepCol(7,140);
  StartFormat(15);
  OutString(0,0,USetStr(36255),false);
  OutString(80,0,USetStr(3070),false);
  OutString(140,0,USetStr(3080),false);
  OutString(190,0,USetStr(3072),false);
  OutString(1,0,USetStr(3071),true);
  EndFormat;
  if (RepSpec.ArtMode==1) then begin
    StartFormat(15);
      OutString(20,0,USetStr(3073),false);
      OutString(80,0,USetStr(3074),false);
      OutString(150,0,USetStr(3070),false);
      OutString(200,0,USetStr(3075),false);
      OutStringAdjustBiDi(380,0,USetStr(3076),true,M4Val,430);
      OutStringAdjust(5,0,USetStr(3077),true,M4Val);
    EndFormat;
  end else begin
    Gray_Divider(0,1);
  end;
  RunSimRn(RepSpec,true);
  EndJob; 
  return;
end;
