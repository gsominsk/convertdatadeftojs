external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure HTDetailLevel(Integer, var string);
external procedure HTNr(Integer,Integer,LongInt,LongInt,var string);

global
procedure PrintProdOrdInfo(record ProdOrderVc ProdOrderr, val divby)
begin
  string 20 queposstr;
 
  StartFormat(15);
  OutLongInt(0,"DblProdOrder",ProdOrderr.SerNr,false);
  OutDate(110,0,ProdOrderr.DueDate,true);
  if (ProdOrderr.QueuePos!=-1) then begin
    queposstr = ProdOrderr.QueuePos;
  end;
  OutString(120,0,queposstr,false);
  OutString(155,0,ProdOrderr.Machine,false);
  OutString(220,0,ProdOrderr.Recipe,false);
  OutString(280,0,Left(ProdOrderr.RecName,25),false);
  OutVal(1,0,ProdOrderr.Qty*divby,M4Qty,true);
  EndFormat;
  return;
end;

procedure RepProdOrder2(record ProdOrderVc ProdOrderr,record RcVc RepSpec,var val totcost,val divby)
begin
  Integer i,rwcnt;
  Row ProdOrderVc ProdOrderrw;
  
  PrintProdOrdInfo(ProdOrderr,divby);
  StartFormat(15);
  OutString(300,0,USetStr(12433),false);
  OutVal(1,0,ProdOrderr.Finished*divby,M4Qty,true);
  EndFormat;
  StartFormat(15);
  OutString(300,0,USetStr(12434),false);
  OutVal(1,0,ProdOrderr.Discarded*divby,M4Qty,true);
  EndFormat;
  Gray_Divider(300,1);
  StartFormat(15);
  OutString(300,0,USetStr(12435),false);
  OutVal(1,0,(ProdOrderr.Qty*divby)-(ProdOrderr.Finished*divby),M4Qty,true);
  EndFormat;
  return;
end;

procedure RepProdOrder(record ProdOrderVc ProdOrderr,record RcVc RepSpec,var val totcost,val divby)
begin
  Integer i,rwcnt;
  Row ProdOrderVc ProdOrderrw;
  val t;
  
  PrintProdOrdInfo(ProdOrderr,divby);
  if ((nonblank(ProdOrderr.Comment1)) or (nonblank(ProdOrderr.Instr0))) then begin
    StartFormat(15);
    OutString(15,0,ProdOrderr.Comment1,false);
    OutString(270,0,ProdOrderr.Instr0,false);
    EndFormat;
  end;
  if ((nonblank(ProdOrderr.Comment2)) or (nonblank(ProdOrderr.Instr1))) then begin
    StartFormat(15);
    OutString(15,0,ProdOrderr.Comment2,false);
    OutString(270,0,ProdOrderr.Instr1,false);
    EndFormat;
  end;
  if ((nonblank(ProdOrderr.Comment3)) or (nonblank(ProdOrderr.Instr2))) then begin
    StartFormat(15);
    OutString(15,0,ProdOrderr.Comment3,false);
    OutString(270,0,ProdOrderr.Instr2,false);
    EndFormat;
  end;
  Gray_Divider(20,1);
  StartFormat(15);
  OutString(20,0,USetStr(12426),false);
  OutString(170,0,USetStr(12427),true);
  OutString(240,0,USetStr(12428),true);
  OutString(250,0,USetStr(12430),false);
  EndFormat;
  t = 1;
  if (RepSpec.flags[8]!=0) then begin
    t = ProdOrderr.Qty - ProdOrderr.Finished;
  end;
  Gray_Divider(20,1);
  rwcnt = MatRowCnt(ProdOrderr);
  for (i = 0 ; i<rwcnt ;i=i+1) begin
    MatRowGet(ProdOrderr,i,ProdOrderrw);
    StartFormat(15);
    OutString(20,0,ProdOrderrw.Item,false);
    OutVal(170,0,ProdOrderrw.InQty*t,M4UVal,true);
    OutVal(240,0,ProdOrderrw.OutQty*t,M4UVal,true);
    OutString(250,0,ProdOrderrw.Comment,false);
    EndFormat;
  end;
  StartFormat(15);
  EndFormat;
  return;
end;

global
procedure FindProdOrdOutItem(record ProdOrderVc ProdOrderr,var string outitem,var val divby)
begin
  row ProdOrderVc ProdOrderrw;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(ProdOrderr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOrderr,i,ProdOrderrw);
    if (ProdOrderrw.OutQty!=0) then begin
      outitem = ProdOrderrw.Item;
      divby = ProdOrderrw.OutQty;
      i = rwcnt;
    end;
  end;
  return;
end;

procedure FindProdOutQty(record ProdVc Prodr,var val prodqty)
begin

  row ProdVc Prodrw;
  Integer i,rwcnt;
  
  prodqty = blankval;
  rwcnt = MatRowCnt(Prodr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Prodr,i,Prodrw);
    if (Prodrw.OutQty!=0) begin
      if (Prodr.RowsHoldActualQty!=0) begin
        prodqty = Prodrw.OutQty;
      end else begin 
        prodqty = Prodrw.OutQty * Prodr.Qty;
      end;
      i = rwcnt;
    end;
  end;
end;

procedure PrintProductions(record ProdOrderVc ProdOrderr)
begin
  record ProdVc Prodr;
  boolean TrHs, testf,firstf;
  val prodqty;
  
  firstf = true;
  Prodr.ProdOrder = ProdOrderr.SerNr;
  TrHs = true;
  while (LoopKey("ProdOrder",Prodr,1,TrHs)) begin
    if (TrHs) then begin
      if (Prodr.ProdOrder > ProdOrderr.SerNr) then begin
        TrHs = false;
      end;
    end;
    if (TrHs) then begin
      if (firstf) then begin
        StartFormat(15);
        OutString(15,0,USetStr(14530),false);
        OutString(80,0,USetStr(14531),false);
        OutString(170,0,USetStr(14532),false);
        OutString(400,0,USetStr(14533),true);
        OutString(1,0,USetStr(14534),true);
        EndFormat;
        Gray_Divider(0,1);
        firstf = false;
      end;
      StartFormat(15);
      OutStringID(15,"DblProdVcID",Prodr.SerNr,false,Prodr.SerNr);
      OutString(80,0,Prodr.StartDate,false);
      OutString(170,0,Prodr.Person,false);
      if (Prodr.PRStatusFlag==5) then begin
        OutString(270,0,USetStr(15187),true);
      end;
      if (Prodr.Disassemble!=0) then begin
        OutString(270,0,USetStr(15169),true);
      end;
      OutVal(400,0,Prodr.TotOutWeight,M4Qty,true);
      FindProdOutQty(Prodr,prodqty);
      OutVal(1,0,prodqty,M4UVal,true);
      EndFormat;
    end; 
  end;
  if (firstf==false) then begin
    StartFormat(15);
    EndFormat;
  end;
  return;
end;
 
procedure PrintProdOrder(record RcVc RepSpec,record ProdOrderVc ProdOrderr,LongInt afr,LongInt ato,var val totcost)
BEGIN
  Boolean testf;
  record INVc INr;
  string 20 outitem;
  string 40 frin,toin;
  val divby;
  
  frin = FirstInRange(RepSpec.f2,30);
  toin = LastInRange(RepSpec.f2,30);  
  testf = true;
  if (nonblank(RepSpec.f1)) then begin
    if ((ProdOrderr.SerNr<afr) or (ProdOrderr.SerNr>ato)) then begin
      testf = false;
    end;
  end;
  testf = false;
  if (RepSpec.flags[3]!=0) then begin
    if (ProdOrderr.StatusFlag==0) then begin testf = true; end;
  end;
  if (RepSpec.flags[4]!=0) then begin
    if (ProdOrderr.StatusFlag==4) then begin testf = true; end;
  end;
  if (RepSpec.flags[5]!=0) then begin
    if (ProdOrderr.StatusFlag==1) then begin testf = true; end;
  end;
  if (RepSpec.flags[6]!=0) then begin
    if (ProdOrderr.StatusFlag==2) then begin testf = true; end;
  end;
  if (RepSpec.flags[7]!=0) then begin
    if (ProdOrderr.StatusFlag==3) then begin testf = true; end;
  end;
  if (nonblank(RepSpec.f4)) then begin
    if (RepSpec.f4<>ProdOrderr.Recipe) then begin testf = false; end;
  end;
  if (nonblank(RepSpec.f5)) then begin
    if (RepSpec.f5<>ProdOrderr.Machine) then begin testf = false; end;
  end;
  if (testf) then begin
    FindProdOrdOutItem(ProdOrderr,outitem,divby);
    if (nonblank(outitem)) then begin
      if (nonblank(RepSpec.f2)) then begin
        if ((outitem<frin) or (outitem>toin)) then begin
          testf = false;
        end;
      end;
      if (ReadFirstItem(outitem,INr,false,false)) then begin
        if (nonblank(RepSpec.f3)) then begin
          if (RepSpec.f3!=INr.Group) then begin
            testf = false;
          end;
        end;
      end;
    end;
  end;
  if (testf) then begin
    if (RepSpec.ArtMode==2) then begin
      Black_Divider(0,1);
      RepProdOrder2(ProdOrderr,RepSpec,totcost,divby);
    end;
    if (RepSpec.ArtMode==1) then begin
      Black_Divider(0,1);
      RepProdOrder(ProdOrderr,RepSpec,totcost,divby);
    end;
    if (RepSpec.ArtMode==0) then begin
      PrintProdOrdInfo(ProdOrderr,divby);
    end;
    Gray_Divider(0,1);
    PrintProductions(ProdOrderr);
   end;
  return;
end;
    
global
procedure ProdOrdRn(record RcVc RepSpec)
begin
  record ProdOrderVc ProdOrderr;
  Boolean TrHs;
  Val TotSum,totcost;
  Boolean testf;
  LongInt afr,ato;
  Integer rw;
  string 255 tstr;
  Date blankd;

  afr = FirstInRange(RepSpec.f1,30);
  ato = LastInRange(RepSpec.f1,30);
  TotSum = 0;
  StartReportJob(USetStr(12420));
  rw = 1;
  if (nonblank(RepSpec.f1)) then begin
    HTNr(12437,12438,afr,ato,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  HTDetailLevel(RepSpec.ArtMode,tstr);
  if (RepSpec.ArtMode!=2) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  EndHeader;
  StartFormat(15);
  OutString(0,0,USetStr(12421),false);
  OutString(110,0,USetStr(12422),true);
  OutString(120,0,USetStr(12429),false);
  OutString(155,0,USetStr(12432),false);
  OutString(220,0,USetStr(12425),false);
  OutString(280,0,USetStr(12423),false);
  OutString(1,0,USetStr(12431),true);
  EndFormat;
  if (RepSpec.ArtMode==0) then begin
    Black_Divider(0,1);
  end;
  ProdOrderr.SerNr = afr;
  ProdOrderr.DueDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopMain(ProdOrderr,1,TrHs)) begin
    if (TrHs) then begin
      if (ato>0) then begin
        if (Prodorderr.SerNr > ato) then begin
          TrHs = false;
        end;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      if (ProdOrderr.StatusFlag==2) then begin
        if (nonblankdate(ProdOrderr.StartDate)) then begin
          if (DateInRange(ProdOrderr.StartDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin testf = false; end;
        end;
      end else begin
        if (nonblankdate(ProdOrderr.DueDate)) then begin
          if (DateInRange(ProdOrderr.DueDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin testf = false; end;
        end;
      end;
      if (testf) then begin
        PrintProdOrder(RepSpec,ProdOrderr,afr,ato,totcost);
      end;
    end;    
  end;
/*  
what for?
  Black_Divider(0,1);
  StartFormat(15);
  EndFormat;
  ResetLoop(ProdOrderr);
  ProdOrderr.SerNr = afr;
  ProdOrderr.DueDate = blankd;
  TrHs = true;
  while (LoopKey("DueDate",ProdOrderr,1,TrHs)) begin
    if (ProdOrderr.DueDate!=blankd) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      PrintProdOrder(RepSpec,ProdOrderr,afr,ato,totcost);
    end;    
  end;
*/  
  Black_Divider(0,1);
  if (RepSpec.flags[0]==1) then begin
    StartFormat(15);
    OutVal(460,0,totcost,M45Val,true);    
    EndFormat;
  end;
  EndJob;
return;
end;
