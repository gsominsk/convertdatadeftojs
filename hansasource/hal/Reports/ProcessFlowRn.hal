external function string 255 HTProds(LongInt, LongInt);
external function string 255 HTProdOperations(LongInt, LongInt);
external function Integer Nr_SequenceProdOperations(record ProdOperationVc);
external function Time TimeDiff(Time,Time);
external function LongInt DateDiff(Date,Date);
external function LongInt TimeToMinutes(Time);

procedure PrintOperation(record ProdOperationVc ProdOpr,Integer cursequenceoperations,
                         var string finalitem)
begin
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  val totincost;
  LongInt days;
  Time t;
  string 20 item;
  Boolean outf;
    
  outf = true;
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
	  if (ProdOprw.OutQty!=0) then begin
	    item = ProdOprw.Item;
	    outf = true;
	    if (blank(finalitem)) then begin
	      finalitem = item;
	    end;
	  end;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
  	if (ProdOprw.InQty!=0) then begin
      if (blank(item)) then begin
//	      item = finalitem;
	      outf = false;
	    end;
      totincost = totincost + ProdOprw.ItemCost;
    end;
  end;
  if (blank(item)) then begin
    item = finalitem;
  end;
  switch (ProdOpr.PRStatusFlag) begin
    case 3:
      days = DateDiff(ProdOpr.EndDate,ProdOpr.StartDate);
      t = TimeDiff(ProdOpr.StartTime,ProdOpr.EndTime);
    case 5:
      days = DateDiff(ProdOpr.EndDate,ProdOpr.StartDate);
      t = TimeDiff(ProdOpr.StartTime,ProdOpr.EndTime);
    otherwise
      days = ProdOpr.PlanDurDays;
      t = ProdOpr.PlanDurTime;
  end;
  if (cursequenceoperations>1) then begin
    outf = false;
  end;
  if (outf) then begin
	  StartFormat(15);
     OutStringID(0,"DblProdOperationVc",ProdOpr.Comment,false,ProdOpr.SerNr);
     OutString(200,0,ProdOpr.Sequence,false);
     OutString(300,0,USetStr(16443),false);
	   OutString(350,"DblMaxprodRn",item,false);
	   OutString(420,0,USetStr(16410+ProdOpr.PRStatusFlag),false);
	  EndFormat;
	  StartFormat(15);
     OutString(300,0,USetStr(16439),false);
	   OutString(350,0,totincost,false);
	  EndFormat;
    if (days>=0) then begin
  	  StartFormat(15);
      OutString(300,0,USetStr(16440),false);
   	  OutString(350,0,days,false);
      OutString(400,0,USetStr(16441),false);
      EndFormat;
    end;
    if (nonblanktime(t)) then begin
  	  StartFormat(15);
      OutString(300,0,USetStr(16440),false);
      OutString(350,0,TimeToMinutes(t),false);
      OutString(400,0,USetStr(16442),false);
      EndFormat;
    end;
  end else begin
    StartFormat(15);
     OutStringID(0,"DblProdOperationVc",ProdOpr.Comment,false,ProdOpr.SerNr);
     OutString(200,0,ProdOpr.Sequence,false);
     OutString(300,0,USetStr(16443),false);
     if (blank(item)) then begin
	     OutString(350,0,item,false);
	   end else begin
  	   OutString(350,"DblMaxprodRn",finalitem,false);
	   end;
	   OutString(420,0,USetStr(16410+ProdOpr.PRStatusFlag),false);
    EndFormat;    
	  StartFormat(15);
     OutString(300,0,USetStr(16439),false);
	   OutString(350,0,totincost,false);
	  EndFormat;
    if (days>=0) then begin
  	  StartFormat(15);
      OutString(300,0,USetStr(16440),false);
   	  OutString(350,0,days,false);
      OutString(400,0,USetStr(16441),false);
      EndFormat;
    end;
    if (nonblanktime(t)) then begin
  	  StartFormat(15);
      OutString(300,0,USetStr(16440),false);
      OutString(350,0,TimeToMinutes(t),false);
      OutString(400,0,USetStr(16442),false);
      EndFormat;
    end;
  end;
  Gray_Divider(0,1);
  return;
end;

procedure PrintOperations(record ProdVc Prodr)
begin
  record ProdOperationVc ProdOpr;
  Boolean found;
  string 255 finalitem;
  Integer cursequenceoperations;
  
  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.Sequence = 1000;
  ProdOpr.SubSequence = 1000;
  found = true;
  while (LoopBackKey("ProdNrSeq",ProdOpr,3,found)) begin
    if (ProdOpr.ProdNr!=Prodr.SerNr) then begin found = false; end;
    if (found) then begin
      cursequenceoperations = Nr_SequenceProdOperations(ProdOpr);
      PrintOperation(ProdOpr,cursequenceoperations,finalitem);
    end;
  end;
  return;
end;

procedure ProcessFlowHeader(LongInt frprod,LongInt toprod)
begin
  Integer rw;
  string 255 tstr;
  
  rw = 1;
  Header(rw,HTProds(frprod,toprod),1);
  return;
end;

global
procedure ProcessFlowRn(record RcVc RepSpec)
begin
  record ProdVc Prodr;
  LongInt lastprod;
    
  Prodr.SerNr = FIrstInRange(RepSpec.f1,10);
  StartReportJob(USetStr(16430));
   ProcessFlowHeader(Prodr.SerNr,Prodr.SerNr);
  EndHeader;
  if (blank(RepSpec.f1)) then begin
	  StartFormat(15);
	   OutString(0,0,USetStr(16444),false);
	  EndFormat;
	  goto LProcessFlowRn;
  end;
  StartFormat(15);
   OutString(0,0,USetStr(16431),false);
   OutString(200,0,USetStr(16432),false);
  EndFormat;
  Gray_Divider(0,1);
  if (ReadFirstMain(Prodr,1,true)) then begin
    if (lastprod!=Prodr.SerNr) then begin
      StartFormat(15);
       OutStringID(0,"DblProdVcID",USetStr(16463) & " " & Prodr.SerNr,false,Prodr.SerNr);
   	   OutString(420,0,USetStr(16410+Prodr.PRStatusFlag),false);
      EndFormat;
      Gray_Divider(0,1);
    end;
    PrintOperations(Prodr);
    lastprod = Prodr.SerNr;
  end;
LProcessFlowRn:;  
  EndJob;
  return;
end;