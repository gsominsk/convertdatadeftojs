external procedure HTArtGroup(string, var string);
external procedure HTItemClass(string,var string);
external function Boolean HasItemClassification();
external function Boolean HasItemGroups();
external function Boolean ItemInItemGroupOrClass(string,string,string);
external function roundmode SetRoundModeD(Integer);
external procedure HTITs(string,string,var string);
external procedure HTItem(string,var string);
external procedure HT2Per(Date, Date , var string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);

global
procedure AddLineToPlan(var record ProdVc ProdCollectionr,record ProdVc Prodr,row ProdVc Prodrw,Integer grouping)
begin
  record INVc INr;
  row ProdVc ProdCollectionrw;
  row ProdVc ProdCollection2rw;
  Integer i,rwcnt;
  Boolean treatedf,testf;
  val q;
  
  treatedf = false;
  rwcnt = MatRowCnt(ProdCollectionr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdCollectionr,i,ProdCollectionrw);
//    if (((ProdCollectionrw.PosCode==Prodr.Recepy) or (grouping==1)) and (ProdCollectionrw.Item==Prodrw.Item) and 
//       ((ProdCollectionrw.InQty!=0 and Prodrw.InQty!=0) or (ProdCollectionrw.InQty==0 and Prodrw.InQty==0))
//       ) then begin
    testf = true;

    switch (grouping) begin
      case 2:
        if (ProdCollectionrw.Objects==Prodr.Objects) then begin
        end else begin
          testf = false;
        end;
      case 1:
        if (ProdCollectionrw.Item==Prodrw.Item) then begin
        end else begin
          testf = false;
        end;
      case 0:
        if (ProdCollectionrw.PosCode==Prodr.Recepy) then begin
        end else begin
          testf = false;
        end;
        if (ProdCollectionrw.Item==Prodrw.Item) then begin
        end else begin
          testf = false;
        end;
    end;
    if ((ProdCollectionrw.InQty!=0 and Prodrw.InQty!=0) or (ProdCollectionrw.InQty==0 and Prodrw.InQty==0)) then begin
    end else begin
      testf = false;
    end;
    if (testf) then begin        
      switch (Prodr.RowsHoldActualQty) begin
        case 1: q = 1;
        otherwise q = Prodr.Qty;
      end;                      
      ProdCollectionrw.InQty = ProdCollectionrw.InQty + (q * Prodrw.InQty);
      ProdCollectionrw.OutQty = ProdCollectionrw.OutQty + (q * Prodrw.OutQty);
      if (Prodrw.InQty!=0) then begin
        ProdCollectionrw.ItemCost = ProdCollectionrw.ItemCost + (q * Prodrw.InQty * Prodrw.ItemCost);
      end else begin
        ProdCollectionrw.ItemCost = ProdCollectionrw.ItemCost + (q * Prodrw.OutQty * Prodrw.ItemCost);
      end;
      ProdCollectionrw.ExtraCost = ProdCollectionrw.ExtraCost + Prodrw.ExtraCost;
      ProdCollectionrw.Weight = ProdCollectionrw.Weight + Prodrw.Weight;
      ProdCollectionrw.Coefficient = ProdCollectionrw.Coefficient + Prodrw.Coefficient;
      MatRowPut(ProdCollectionr,i,ProdCollectionrw);
      treatedf = true;
    end;
  end;
  if (treatedf==false) then begin
    ClearRow(ProdCollectionr,ProdCollectionrw,1);
    switch (grouping) begin
      case 2:
        ProdCollectionrw.Objects = Prodr.Objects;
      otherwise
        ProdCollectionrw.PosCode = Prodr.Recepy;
        ProdCollectionrw.Item = Prodrw.Item;
        ProdCollectionrw.Objects = Prodr.Objects;
        if (nonblank(Prodrw.Objects)) then begin
          if (nonblank(ProdCollectionrw.Objects)) then begin
            ProdCollectionrw.Objects = ProdCollectionrw.Objects & ",";
          end;
          ProdCollectionrw.Objects = ProdCollectionrw.Objects & Prodrw.Objects;
        end;
        if (ReadFirstItem(ProdCollectionrw.Item,INr,false,false)) then begin
          ProdCollectionrw.Comment = INr.Name;
        end;
    end;
    switch (Prodr.RowsHoldActualQty) begin
      case 1: q = 1;
      otherwise q = Prodr.Qty;
    end;                      

    ProdCollectionrw.InQty = q * Prodrw.InQty;
    ProdCollectionrw.OutQty = q * Prodrw.OutQty;
    if (Prodrw.InQty!=0) then begin
      ProdCollectionrw.ItemCost = q * Prodrw.InQty * Prodrw.ItemCost;
    end else begin
      ProdCollectionrw.ItemCost = q * Prodrw.OutQty * Prodrw.ItemCost;
    end;
    ProdCollectionrw.ExtraCost = Prodrw.ExtraCost;
    ProdCollectionrw.Weight = Prodrw.Weight;
    ProdCollectionrw.Coefficient = Prodrw.Coefficient;
    if (grouping==1) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(ProdCollectionr,i,ProdCollection2rw);
        if (ProdCollectionrw.Item<ProdCollection2rw.Item) then begin
          MatRowInsert(ProdCollectionr,i,ProdCollectionrw);
          treatedf = true;
          i = rwcnt;
        end;
      end;
      if (treatedf==false) then begin
        MatRowPut(ProdCollectionr,MatRowCnt(ProdCollectionr),ProdCollectionrw);
      end;
    end else begin
      MatRowPut(ProdCollectionr,MatRowCnt(ProdCollectionr),ProdCollectionrw);
    end;
  end;
  return;
end;

procedure CreateTheAllocPlan(var record ProdVc ProdCollectionr,record Rcvc RepSpec)
begin
  record ProdVc Prodr;
  row ProdVc Prodrw;
  row ProdVc ProdOutrw;
  record MachineGroupsBlock MGb;
  row MachineGroupsBlock MGbrw;
  record INVc INr;
  Integer i,oi,rwcnt;
  Boolean foundf,testf;
  String 255 macgrlist;
  Integer highestline;
  val totsum,totqty,t,t2,prc,totcomp,prckey,highval;
  val totrel;
  
  macgrlist = "";
  if (nonblank(RepSpec.f3)) then begin
    BlockLoad(MGb);
    rwcnt = MatRowCnt(MGb);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(MGb,i,MGbrw);
      if (RepSpec.f3==MGbrw.Code) then begin
        macgrlist = MGbrw.DefStr;
      end;
    end;
  end;

  foundf = true;
  Prodr.ProdDate = RepSpec.sStartDate;
  while (LoopKey("ProdDate",Prodr,1,foundf)) begin
    if (Prodr.ProdDate>RepSpec.sEndDate) then begin
      foundf = false;
    end;
    testf = foundf;
    if (nonblank(macgrlist)) then begin
      if (SetInSet(Prodr.FixAssCode,macgrlist)==false) then begin
        testf = false;
      end;
    end;
    if (nonblank(RepSpec.f4)) then begin
      if (RepSpec.f4!=Prodr.FixAssCode) then begin
        testf = false;
      end;
    end;
    if ((Prodr.PRStatusFlag!=3) and (Prodr.PRStatusFlag!=5)) then begin
      testf = false;
    end;
    if (Prodr.SerNr!=40) then begin
//      testf = false;
    end;
    if (testf) then begin
      rwcnt = MatRowCnt(Prodr);
      switch (RepSpec.flags[3]) begin
        case 2:
          totrel = 0;
          for (oi=0;oi<rwcnt;oi=oi+1) begin
            MatRowGet(Prodr,oi,ProdOutrw);
            if (ProdOutrw.OutQty!=0) then begin
              totrel = totrel + ProdOutrw.OutQty*ProdOutrw.RelVal;
            end;
          end;
          for (oi=0;oi<rwcnt;oi=oi+1) begin
            MatRowGet(Prodr,oi,ProdOutrw);
            if (ProdOutrw.OutQty!=0) then begin
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(Prodr,i,Prodrw);
                testf = false;
                if (nonblank(RepSpec.f2)) then begin
                  if (RepSpec.f2==Prodrw.Item) then begin
                    testf = true;
                  end;
                end;
                testf = ItemInItemGroupOrClass(Prodrw.Item,RepSpec.f1,RepSpec.f5);
                if (testf) then begin
                  Prodr.Objects = ProdOutrw.Objects;
                  t2 = ProdOutrw.OutQty*ProdOutrw.RelVal;   
                  if (t2!=0) then begin   
                    Prodrw.OutQty = (Prodrw.OutQty*t2)/totrel;
                    Prodrw.InQty = (Prodrw.InQty*t2)/totrel;
                  end;                  
                  AddLineToPlan(ProdCollectionr,Prodr,Prodrw,RepSpec.flags[3]);
                end;
              end;
            end;
          end;
        otherwise
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(Prodr,i,Prodrw);
            testf = false;
            if (nonblank(RepSpec.f2)) then begin
              if (RepSpec.f2==Prodrw.Item) then begin
                testf = true;
              end;
            end;
            testf = ItemInItemGroupOrClass(Prodrw.Item,RepSpec.f1,RepSpec.f5);
            if (testf) then begin
              AddLineToPlan(ProdCollectionr,Prodr,Prodrw,RepSpec.flags[3]);
            end;
          end;
      end;
    end;
  end;
  totsum = 0;
  totqty = 0;
  totcomp = 0;
  rwcnt = MatRowCnt(ProdCollectionr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdCollectionr,i,Prodrw);
    totsum = totsum + Prodrw.ItemCost + Prodrw.ExtraCost;
    totqty = totqty + Prodrw.InQty + Prodrw.OutQty;
  end;
  highestline = 0;
  rwcnt = MatRowCnt(ProdCollectionr);

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdCollectionr,i,Prodrw);
    t = Prodrw.ItemCost + Prodrw.ExtraCost;
    switch (RepSpec.flags[1]) begin
      case 0: prckey = t / totsum;
      case 1: prckey = (Prodrw.InQty + Prodrw.OutQty) / totqty;
    end;
    t2 = prckey * RepSpec.vals0;
    totcomp = totcomp + t2;
    if (t2>highval) then begin
      highval = t2;
      highestline = i;
    end;
    Prodrw.ItemCost = t;
    Prodrw.ExtraCost = t2;
    Prodrw.Weight = prckey;
    MatRowPut(ProdCollectionr,i,Prodrw);
  end;

  t = RepSpec.vals0 - totcomp;
  if (t!=0) then begin
    MatRowGet(ProdCollectionr,highestline,Prodrw);
    Prodrw.ExtraCost = Prodrw.ExtraCost + t;
    MatRowPut(ProdCollectionr,highestline,Prodrw);
  end;

  return;
end;

procedure PrintThePlan(record ProdVc ProdCollectionr,record RcVc RepSpec,Boolean outqtyf)
begin
  row ProdVc Prodrw;
  Integer i,rwcnt;
  val prc,totin,totout,totcost,totcomp,prctot,difftot;
  Boolean testf,firstf;
  string 255 lastrecipe;
  val lastrecitemcost,lastrecextracost,lastrecweight;

  firstf = true;
  totin = 0;
  totout = 0;
  totcost = 0;
  totcomp = 0;
  prctot = 0;
  difftot = 0;
  rwcnt = MatRowCnt(ProdCollectionr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdCollectionr,i,Prodrw);
    testf = true;
    if (outqtyf and Prodrw.InQty!=0) then begin
      testf = false;
    end;
    if (outqtyf==false and Prodrw.OutQty!=0) then begin
      testf = false;
    end;
    if (testf) then begin
      if (firstf) then begin
        StartFormat(15);
        if (outqtyf) then begin
          OutString(0,0,USetStr(4995),false);
        end else begin
          OutString(0,0,USetStr(4994),false);
        end;
        EndFormat;
        StartFormat(15);
        switch (RepSpec.flags[3]) begin
          case 0:
            OutString(0,0,USetStr(5387),false);
            OutString(2,0,USetStr(5386),false);
            switch (RepSpec.flags[2]) begin
              case 0:
                OutString(3,0,USetStr(5393),false);
              case 1:
                OutString(3,0,USetStr(5392),false);
            end;
          case 1:
            OutString(0,0,USetStr(5386),false);
            switch (RepSpec.flags[2]) begin
              case 0:
                OutString(2,0,USetStr(5393),false);
              case 1:
                OutString(2,0,USetStr(5392),false);
            end;
          case 2:
        end;
        OutString(4,0,USetStr(5115),true);
        OutString(5,0,USetStr(5117),true);
        OutString(6,0,USetStr(5118),true);
        OutString(7,0,USetStr(5138),true);
        OutString(1,0,USetStr(5139),true);
        EndFormat;
        Gray_Divider(0,1);
        firstf = false;
      end;
      totin = totin + Prodrw.InQty;
      totout = totout + Prodrw.OutQty;
      totcost = totcost + Prodrw.ItemCost;
      totcomp = totcomp + Prodrw.ExtraCost;
      prc = Prodrw.ItemCost / Prodrw.ExtraCost * 100;
      prctot = prctot + Round(Prodrw.Weight * 100,SetRoundModeD(2));
      difftot = difftot + Prodrw.ExtraCost - Prodrw.ItemCost;
      switch (RepSpec.flags[3]) begin
        case 0:
          if (nonblank(lastrecipe)) then begin
            if (Prodrw.PosCode!=lastrecipe) then begin
              Gray_Divider(200,1);
              StartFormat(15);
              OutVal(4,0,lastrecitemcost,M45Val,true);
              OutVal(5,0,lastrecextracost,M45Val,true);
              prc = lastrecitemcost / lastrecextracost * 100;
              OutString(6,0,"" & Round(prc,SetRoundModeD(2))  & "%",true);
              OutVal(7,0,lastrecextracost - lastrecitemcost,M45Val,true);
              OutString(1,0,"" & Round(lastrecweight * 100,SetRoundModeD(2)) & "%",true);
              EndFormat;
              Gray_Divider(200,1);
              StartFormat(5);
              EndFormat;
              lastrecitemcost = blankval;
              lastrecextracost = blankval;
              lastrecweight = blankval;
            end;
          end;
      end;
      StartFormat(15);
      switch (RepSpec.flags[3]) begin
        case 0:
          OutString(0,"DblRecVc",Prodrw.PosCode,false);
          OutString(2,"DblINVc",Prodrw.Item,false);
          if (RepSpec.flags[2]==0) then begin
            OutString(3,0,Prodrw.Comment,false);
          end else begin
            OutString(3,0,Prodrw.Objects,false);
          end;
          lastrecipe = Prodrw.PosCode;
          lastrecitemcost = lastrecitemcost + Prodrw.ItemCost;
          lastrecextracost = lastrecextracost + Prodrw.ExtraCost;
          lastrecweight = lastrecweight + Prodrw.Weight;
        case 1:
          OutString(0,"DblINVc",Prodrw.Item,false);
          if (RepSpec.flags[2]==0) then begin
            OutString(2,0,Prodrw.Comment,false);
          end else begin
            OutString(2,0,Prodrw.Objects,false);
          end;
        case 2:
          OutString(0,0,Prodrw.Objects,false);
//          OutString(2,"DblINVc",Prodrw.Item,false);
      end;
      OutVal(4,0,Prodrw.ItemCost,M45Val,true);
      OutVal(5,0,Prodrw.ExtraCost,M45Val,true);
      OutString(6,0,"" & Round(prc,SetRoundModeD(2))  & "%",true);
      OutVal(7,0,Prodrw.ExtraCost - Prodrw.ItemCost,M45Val,true);
      OutString(1,0,"" & Round(Prodrw.Weight * 100,SetRoundModeD(2)) & "%",true);
      EndFormat;
    end;
  end;
  switch (RepSpec.flags[3]) begin
    case 0:
      Gray_Divider(200,1);
      StartFormat(15);
      OutVal(4,0,lastrecitemcost,M45Val,true);
      OutVal(5,0,lastrecextracost,M45Val,true);
      prc = lastrecitemcost / lastrecextracost * 100;
      OutString(6,0,"" & Round(prc,SetRoundModeD(2))  & "%",true);
      OutVal(7,0,lastrecextracost - lastrecitemcost,M45Val,true);
      OutString(1,0,"" & Round(lastrecweight * 100,SetRoundModeD(2)) & "%",true);
      EndFormat;
  end;

  if (totcost!=0) then begin
    prc = totcost / totcomp * 100;
    Gray_Divider(0,1);
    StartFormat(15);
    OutVal(4,0,totcost,M45Val,true);
    OutVal(5,0,totcomp,M45Val,true);
    OutString(6,0,"" & Round(prc,SetRoundModeD(2))  & "%",true);
    OutVal(7,0,difftot,M45Val,true);
    OutString(1,0,"" & Round(prctot,SetRoundModeD(2)) & "%",true);
    EndFormat;
  end;
  return;
end;

global
procedure CostAllocPlanRn(record RcVc RepSpec)
begin
  record ProdVc ProdCollectionr;
  String 255 tstr;
  Integer rw;
  
  StartReportJob(USetStr(8706));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTItem(RepSpec.f2,tstr);  
  Header(rw,tstr,1);
  rw = rw + 1;
  if (HasItemGroups) then begin
    HTITs(RepSpec.f1,RepSpec.f1,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (HasItemClassification) then begin
    HTItemClass(RepSpec.f5,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;  
  EndHeader;
  SetRepCol(2,50);
  SetRepCol(3,100);
  SetRepCol(4,240);
  SetRepCol(5,300);
  SetRepCol(6,360);
  SetRepCol(7,420);
  
  if (blank(RepSpec.f1) and blank(RepSpec.f2) and blank(RepSpec.f5)) then begin
    StartFormat(15);
    OutString(0,0,USetStr(8718),false);
    EndFormat;
    goto L98;
  end;
  CreateTheAllocPlan(ProdCollectionr,RepSpec);
  
  PrintThePlan(ProdCollectionr,RepSpec,false);
  PrintThePlan(ProdCollectionr,RepSpec,true);
L98:;
  EndJob;
  return;
end;

