external procedure AutomatedSalesOrderly(string);
external procedure CorspAccSums(record RcVc,record AccVc,string,var val,var val);
external procedure CalcRsTypeSum(vector val,vector val,vector val,
                        vector val,vector val,vector val,
                        vector Boolean,Array record UserDefRepLinesVc,Integer,LongInt);external function Integer DateGetIntMonth(Date);
external procedure CalcKeyRn(string,string,Integer,Integer,string,Integer,Integer,Integer,Integer,string,string,string,var val);
external function Integer CountLinesInUserDefRep(record UserDefRepVc);
external procedure ListPerTrans(record RcVc);
external procedure FindAccSD(Date,var Date,var Boolean);
external procedure FindRepDefHeader(string,string,var string);
external function Boolean GetNextSep(string,var Integer,var string);
external function Boolean GetNextItem(string,var Integer,var string);
external procedure AGrHeader(record RcVc,Boolean,Boolean,Date);
external procedure SumListPerBal(string,Integer,var Array val,var Array val,var Array val,
                                 var Array val,var Array val,var Array val,Integer,var Array LongInt,Boolean);
external procedure AGrSumLine2(record RcVc,Integer,string,string,string,
                              val,val,val,val,val,val,Boolean,val,Boolean,Boolean,string,LongInt,Boolean,Boolean,Boolean);
external procedure GetUserDefRepDescription(record UserDefRepLinesVc,string,var string);
external procedure GetPreviousPeriods(record RcVc,Date,Date,var string,var string);
external procedure GetNotStr(Integer,var string);
external procedure GetNext2Sep(string,var Integer,var string);
external procedure GetNextToken(string,var Integer,var string);
external function Boolean GetNextTokenReturn(string,var Integer,var string);
external procedure GetAccountDescription2(string,string,var string);
external function Boolean AccRuPerBal(record RcVc,Boolean,string,string,var val,var val,var val,var val,var val,var val,
                                      Integer,Boolean,Date,Date,Date);
external procedure InitValArray(Integer,var Array val);
external procedure InitLongArray(Integer,var Array LongInt);
external procedure SumLine2(record RcVc,Boolean,string,string,string,var val,var val,var val,var val,var val,
                            var val,Boolean,val,Boolean,Date,Integer,LongInt,Boolean);

procedure ALPB2ResGr(record RcVc RepSpec,Boolean PLf,record UserDefRepLinesVc UserDefRepLinesr,record AccVc Accp,string anru,
                var val S3bp,var val Pbp,var val Ebp,var val S4bp,var val S5bp,var val S6bp,
                Boolean addflag,val goms,var Boolean headflagp,Boolean resUseAccum,Date AccumStartDate,Boolean printf)
BEGIN
  Boolean negf,usedf;
  val S3b1,Pb1,Eb1,S4b1,S5b1,S6b1;
  string 255 nru;
  record CYBlock CompYear;
  string 255 tstr,tstr2;
  Date budsd,buded;
  
  budsd = StringToDate(FirstInRange(RepSpec.Stext,10));
  if (blankdate(budsd)) then begin budsd = RepSpec.sStartDate; end;    
  buded = StringToDate(LastInRange(RepSpec.Stext,10));
  if (blankdate(buded)) then begin buded = RepSpec.sEndDate; end;    
//  if (AccBlockedTest((AccessView*)appSlotArr[gCurSlot].ast_Accessp,Accp->AccNumber)) then goto LALPB2;
  BlockLoad(CompYear);
  nru = anru;//??
  nru = RepSpec.ObjStr;//??
  if (blank(UserDefRepLinesr.CorspAcc)) then begin
    usedf = AccRuPerBal(RepSpec,PLf,Accp.AccNumber,nru,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,UserDefRepLinesr.DCSide,resUseAccum,AccumStartDate,budsd,buded);
  end else begin
    CorspAccSums(RepSpec,Accp,UserDefRepLinesr.CorspAcc,S3b1,S4b1);
    switch (UserDefRepLinesr.DCSide) begin
      case 0:
        Pb1 = S3b1 - S4b1;
        Eb1 = S3b1 - S4b1 + Pb1;
      case 1:
        Pb1 = S3b1;
        Eb1 = S3b1 + Pb1;
      case 2:
        S3b1 = S4b1;
        Pb1 = S3b1;
        Eb1 = S3b1 + Pb1;
    end;
  end;
/*  
  if (UserDefRepLinesr.DCSaldo==1) then begin
    if (Eb1<0) then begin goto LALPB2ResGr; end;
  end;
  if (UserDefRepLinesr.DCSaldo==2) then begin
    if (Eb1>=0) then begin goto LALPB2ResGr; end;
  end;
*/  
  switch (RepSpec.Comparison) begin
    case 0:
      if (UserDefRepLinesr.DCSaldo==1) then begin
        if (Eb1<0) then begin goto LALPB2ResGr; end;//S3b1
      end;
      if (UserDefRepLinesr.DCSaldo==2) then begin
        if (Eb1>0) then begin goto LALPB2ResGr; end;//S3b1
      end;
      if (Eb1==0) then begin
        if (UserDefRepLinesr.DCSaldo==1) then begin
          if (Pb1>0) then begin goto LALPB2ResGr; end;
        end;
        if (UserDefRepLinesr.DCSaldo==2) then begin
          if (Pb1<0) then begin goto LALPB2ResGr; end;
        end;
      end;            
    otherwise
      if (UserDefRepLinesr.DCSaldo==1) then begin
        if (Pb1<0) then begin goto LALPB2ResGr; end;
      end;
      if (UserDefRepLinesr.DCSaldo==2) then begin
        if (Pb1>=0) then begin goto LALPB2ResGr; end;
      end;
  end;              
  GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr2);  
  if ((nonblank(tstr2)) and (printf)) then begin// UserDefRepLinesr->Comment
    if ((((RepSpec.AccSpec==1) or (RepSpec.AccSpec==4)) and ((Pb1!=0) or (S3b1!=0) or (S4b1!=0) or (S5b1!=0) or (S6b1!=0) or(Eb1!=0) or (usedf))) 
        or (RepSpec.AccSpec==0)) then begin
      if (headflagp==false) then begin
        StartFormat(15);
        OutString(0,0,tstr2,false); 
        EndFormat;
        headflagp = true;
        Gray_Divider(0,1);
      end;
      negf = true;
      if (Accp.AccType==0) then begin
        if (CompYear.NS0[0]==0) then begin
          negf = false;
        end;
      end;
      if (Accp.AccType==1) then begin
        if (CompYear.NS0[1]==0) then begin
          negf = false;
        end;
      end;
      if (Accp.AccType==2) then begin
        if (CompYear.NS0[2]==0) then begin
          negf = false;
        end;
      end;
      if (Accp.AccType==3) then begin
        if (CompYear.NS0[3]==0) then begin
          negf = false;
        end;
      end;
      if (Accp.AccType==4) then begin
        if (CompYear.NS0[4]==0) then begin
          negf = false;
        end;
      end;                    
      GetAccountDescription2(Accp.AccNumber,RepSpec.Language,tstr);            
      if (blank(RepSpec.ObjType)) then begin 
        AGrSumLine2(RepSpec,0,Accp.AccNumber,tstr,UserDefRepLinesr.SpecCode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,PLf,resUseAccum,"DblNL",UserDefRepLinesr.IdKey,usedf,printf,RepSpec.flags[1]!=3);
      end else begin      
        SumLine2(RepSpec,PLf,Accp.AccNumber,tstr,UserDefRepLinesr.SpecCode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,resUseAccum,AccumStartDate,UserDefRepLinesr.DCSide,UserDefRepLinesr.IdKey,printf);
      end;            
    end;
  end;
  if (addflag==true) then begin
    S3bp = S3bp + S3b1;
    S4bp = S4bp + S4b1;
    S5bp = S5bp + S5b1;
    S6bp = S6bp + S6b1;
    Pbp = Pbp + Pb1;
    Ebp = Ebp + Eb1;
  end else begin
    S3bp = S3bp - S3b1;
    S4bp = S4bp - S4b1;
    S5bp = S5bp - S5b1;
    S6bp = S6bp - S6b1;
    Pbp = Pbp - Pb1;
    Ebp = Ebp - Eb1;
  end;
LALPB2ResGr:;
  RETURN;
END;

procedure ALPBEnd(record RcVc RepSpec,Boolean PLf,string Comment,string extracode,val S3bp,val Pbp,val Ebp,
                  val S4bp,val S5bp,val S6bp,Boolean negf,val goms,Boolean aheadflag,Boolean resUseAccum,LongInt idkey,Boolean printf)
BEGIN
  string 255 tstr;
  
  if ((RepSpec.AccSpec==0) or (RepSpec.AccSpec==1) or (RepSpec.AccSpec==4)) then begin
    if (aheadflag==true) then begin
      tstr = USetStr(3143) & Comment;
      if (nonblank(Comment)) then begin
        Gray_Divider(0,1);
        AGrSumLine2(RepSpec,0,tstr,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,printf,RepSpec.flags[1]!=3);
        StartFormat(15);
        EndFormat;
      end;
    end;
  end;
  if (RepSpec.AccSpec==2) then begin
    if (nonblank(Comment)) then begin
      AGrSumLine2(RepSpec,0,Comment,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,printf,RepSpec.flags[1]!=3);
    end;
  end;
  if (RepSpec.AccSpec==3) then begin
    if ((S3bp!=0) or (S4bp!=0) or (S5bp!=0) or (S6bp!=0) or (Pbp!=0)) then begin
      if (nonblank(Comment)) then begin
        AGrSumLine2(RepSpec,0,Comment,"",extracode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,PLf,resUseAccum,"",idkey,false,printf,RepSpec.flags[1]!=3);
      end;
    end;
  end;
  RETURN;
END;

global
procedure AccListPerBalResGr(record RcVc RepSpec,Boolean PLf,record UserDefRepLinesVc UserDefRepLinesr,var val S3bp,var val Pbp,
                        var val Ebp,var val S4bp,var val S5bp,var val S6bp,Boolean negf,val goms,Boolean resUseAccum,
                        Date AccumStartDate,Boolean printf)
BEGIN
  record AccVc Accr;
  Boolean addflag;
  string 255 Nitem;
  string 255 Nitem2;
  string 255 NRu;
  string 5 nsep;
  Boolean Accs;
  Integer np;
  Boolean headflag;
  string 255 tstr;

  S3bp = 0;
  S4bp = 0;
  S5bp = 0;
  S6bp = 0;
  Pbp = 0;
  Ebp = 0;
  headflag = false;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;
    GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
      end;
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,1,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;
          if ((Accs) and (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;  
          Accs = LoopBackKey("AccNumber",Accr,1,true);//Accs = m4_ReadLogicalMain(AccVc,LLoop1--,&Accr);
        end;
      end;
    end;
  end;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc2,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc2,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc2,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc2,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and  (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
      end;    
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,2,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;  
          Accs = LoopBackKey("AccNumber",Accr,1,true);//Accs = m4_ReadLogicalMain(AccVc,LLoop1--,&Accr);
        end;
      end;
    end;
  end;
  np = 0;
  GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
  while (GetNextTokenReturn(UserDefRepLinesr.Desc3,np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    if (nsep==".") then begin
      GetNextToken(UserDefRepLinesr.Desc3,np,NRu);
      GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    end else begin
      NRu = "";
    end;    
    if (nsep==":") then begin
      GetNextToken(UserDefRepLinesr.Desc3,np,Nitem2);
      GetNext2Sep(UserDefRepLinesr.Desc3,np,nsep);
    end else begin
      Nitem2 = "";
    end;    
    Accr.AccNumber = Nitem;
    if (blank(Nitem2)) then begin
      Accs = ReadFirstMain(Accr,1,true);
      if ((Accs) and  (Accr.GroupAcc==0)) then begin
        ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
      end;
    end else begin
      if (Nitem<Nitem2) then begin
        ResetLoop(Accr);
        Accs = true;
        while (LoopMain(Accr,2,Accs)) begin
          if (Accs==true) then begin
            if (Accr.AccNumber>Nitem2) then begin Accs = false; end;
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;  
        end;
      end else begin
        ResetLoop(Accr);
        Accr.AccNumber = Nitem;
        Accs = LoopBackKey("AccNumber",Accr,1,true);
        while (Accs) begin
          if (Accs==true) then begin
            if (Accr.AccNumber<Nitem2) then begin
              Accs = false;
            end;  
          end;  
          if ((Accs) and  (Accr.GroupAcc==0)) then begin
            ALPB2ResGr(RepSpec,PLf,UserDefRepLinesr,Accr,NRu,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,addflag,goms,headflag,resUseAccum,AccumStartDate,printf);
          end;
          Accs = LoopBackKey("AccNumber",Accr,1,true);
        end;
      end;
    end;
  end;
  GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);
  ALPBEnd(RepSpec,PLf,tstr,UserDefRepLinesr.SpecCode,S3bp,Pbp,Ebp,S4bp,S5bp,S6bp,negf,goms,headflag,resUseAccum,UserDefRepLinesr.IdKey,printf);// UserDefRepLinesr.Comment
  RETURN;
END;

function string 255 GetKeyCodeNr(string a)
begin
  string 255 res;
  record UserDefRepVc UserDefRepr;
  row UserDefRepVc UserDefReprw;
  Integer gKsprwcnt,i;

  res = "";
  UserDefRepr.shortname = "KeyRn";
  if (ReadFirstMain(UserDefRepr,1,true)) then begin
    gKsprwcnt = MatRowCnt(UserDefRepr);
    for (i=0; i<gKsprwcnt; i=i+1) begin
      MatRowGet(UserDefRepr,i,UserDefReprw);
      if (UserDefReprw.Code==a) then begin
        res = UserDefReprw.defstr;
        goto LGetKeyCodeNr;
      end;
    end;
LGetKeyCodeNr:;
  end;
  GetKeyCodeNr = res;
  return;
end;

procedure ResRn_Old(record RcVc RepSpec)
BEGIN
  record UserDefRepVc UserDefRepr;
  record UserDefRepLinesVc UserDefRepLinesr;
  record CYBlock CompYear;
  record ConsolidationBlock cr;
  Array val S3ba;
  Array val S4ba;
  Array val S5ba;
  Array val S6ba;
  Array val Pba;
  Array val Eba;  
  Array LongInt aida;
  val tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba;
  string 255 tstr,notstr,per1,per2;
  val Goms;
  Boolean negf,AGrs;
  Boolean PLf,headerf,resUseAccum;
  Integer i,aid,nr;
  Integer aidn,maxrsums;
  Date AccumStartDate;
  Array Integer Sym_hash;
  string 60 ckey,KeyDefinifion;
  transaction record RcVc KeyRepSpec;
  record RcVc tmpKeyRepSpec;
  record RcVc newRepSpec;
  
  PLf = true;
  headerf = true;
  if (RepSpec.CalledFromHAL==0) then begin
    if (((RepSpec.AccSpec==2) or (RepSpec.AccSpec==3)) and (nonblank(RepSpec.ObjType))) then begin
      MessageBox(1072,"");
      goto LResRn;
    end;
  end;
  BlockLoad(CompYear);

  if (blank(RepSpec.shortname)) then begin
    UserDefRepr.shortname = RepSpec.repname;
  end else begin
    UserDefRepr.shortname = RepSpec.shortname;
  end;
  if (ReadFirstMain(UserDefRepr,1,true)==false) then begin
    UserDefRepr.shortname = RepSpec.repname;
    if (ReadFirstMain(UserDefRepr,1,true)==false) then begin
      MessageBox(3167,"");
      goto LResRn;
    end;
  end;
  
  maxrsums = CountLinesInUserDefRep(UserDefRepr);
  InitValArray(maxrsums,S3ba);
  InitValArray(maxrsums,S4ba);
  InitValArray(maxrsums,S5ba);
  InitValArray(maxrsums,S6ba);
  InitValArray(maxrsums,Pba);
  InitValArray(maxrsums,Eba);
  InitLongArray(maxrsums,aida);
  if (RepSpec.critname=="ConsResRClass") then begin    
    BlockLoad(cr);
    RepSpec.basecurncy = cr.ConsCrncy;  
  end;
  resUseAccum = false;
  if ((PLf==true) and (RepSpec.Comparison==0)) then begin
    FindAccSD(RepSpec.sStartDate,AccumStartDate,resUseAccum);
  end;  

  if (RepSpec.CalledFromHAL==0) then begin
    FindRepDefHeader(RepSpec.repname,RepSpec.shortname,tstr);
    if (nonblank(RepSpec.f1)) then begin
      tstr = RepSpec.f1;
    end;  
  
    if (RepSpec.flags[5]!=0) then begin 
      headerf = false;
    end;  
    if (headerf) then begin
      StartReportJob(tstr);
      AGrHeader(RepSpec,PLf,resUseAccum,AccumStartDate);
      EndHeader;
    end else begin
      StartReportNoHeaderJob(tstr);
    end;
    SetRepCol(2,50);
    SetRepCol(3,288);
    SetRepCol(4,384);
    SetRepCol(5,480);
    SetRepCol(6,15);
  end;
  aidn = -1; 
  Goms = 1.00;
  if (RepSpec.Notation==3) then begin
    tstr = USetStr(3146);
    KeyDefinifion = GetKeyCodeNr(tstr);
    if (nonblank(KeyDefinifion)) then begin
      RecordCopy(tmpKeyRepSpec,KeyRepSpec);
      RecordCopy(KeyRepSpec,RepSpec);
      CalcKeyRn(tstr,KeyDefinifion,RepSpec.IncDaughter,RepSpec.basecurncy,"",0,0,0,0,"","","",Goms);
      Goms = Goms/100.00;
      RecordCopy(KeyRepSpec,tmpKeyRepSpec);
    end else begin
      Goms = blankval;
    end;
  end;
  if (RepSpec.CalledFromHAL==0) then begin
    GetNotStr(RepSpec.Notation,notstr);
    StartFormat(20);
    tstr = "";
    if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
      OutString(11,0,tstr,true); // To make export to file look better 
      OutString(20,0,tstr,true);
    end;
    if (RepSpec.Comparison==0) then begin
      tstr = USetStr(3156);
      tstr = tstr & notstr;
//        if (resUseAccum==true) then begin //I don't think this is needed here at all
        OutStringAdjust(4,0,tstr,true,M4Val);
//        end;  
      tstr = USetStr(3157);
      tstr = tstr & notstr;
      OutStringAdjust(5,0,tstr,true,M4Val);
    end;
    if (RepSpec.Comparison==1) then begin
      tstr = USetStr(3158);
      tstr = tstr & notstr;
      OutString(3,0,tstr,true);
      tstr = USetStr(3159);
      tstr = tstr & notstr;
      OutString(4,0,tstr,true);
      OutString(5,0,USetStr(3160),true);
    end;
    if (RepSpec.Comparison==2) then begin
      tstr = USetStr(3161);
      tstr = tstr & notstr;
      OutString(3,0,tstr,true);
      tstr = USetStr(3162);
      tstr = tstr & notstr;
      OutString(4,0,tstr,true);
      OutString(5,0,USetStr(3163),true);
    end;
    if (RepSpec.Comparison==3) then begin
      tstr = USetStr(3164);
      tstr = tstr & notstr;
      OutString(3,0,tstr,true);
      tstr = USetStr(3165);
      tstr = tstr & notstr;
      OutString(4,0,tstr,true);
      OutString(5,0,USetStr(3166),true);
    end;
    if (RepSpec.Comparison==4) then begin
      GetPreviousPeriods(RepSpec,RepSpec.sStartDate,RepSpec.sEndDate,per1,per2);      
      tstr = "";
      if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
        OutString(3,0,tstr,true);
      end;
      OutString(365,0,per1,true);
      OutString(5,0,per2,true);
    end;
    EndFormat;
end;
  if ((nonblank(RepSpec.ObjType)) and (RepSpec.AccSpec==2)) then begin
    StartFormat(20);
    OutString(0,0,USetStr(1565),false);
    EndFormat;
    goto L88LResRn;
  end;
  
  ckey = "ShortIDKey:" & UserDefRepr.shortname;
  UserDefRepLinesr.IdKey = 0; 
  AGrs = ReadFirstKey(ckey,UserDefRepLinesr,1,false);
  if (AGrs==false) then begin
    StartFormat(20);
    OutString(0,0,USetStr(3167),false);
    EndFormat;
  end;
  UserDefRepLinesr.IdKey = 0; 
  AGrs = true;
  while (LoopKey(ckey,UserDefRepLinesr,1,AGrs)) begin
    if (AGrs) then begin
      if (UserDefRepLinesr.RsType==3) then begin//RsHead
        GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);        
        StartFormat(15);
        OutString(0,0,tstr,false);// UserDefRepLinesr.Comment
        EndFormat;
      end;
      if (UserDefRepLinesr.RsType==2) then begin//RsSum
        if (aidn<maxrsums) then begin
          aidn = aidn + 1;
        end; 
        aida[aidn] = UserDefRepLinesr.IdKey;
        aid = aidn;
        SumListPerBal(UserDefRepLinesr.Desc,aid,S3ba,Pba,Eba,S4ba,S5ba,S6ba,maxrsums,aida,true);
        SumListPerBal(UserDefRepLinesr.Desc2,aid,S3ba,Pba,Eba,S4ba,S5ba,S6ba,maxrsums,aida,false);
        SumListPerBal(UserDefRepLinesr.Desc3,aid,S3ba,Pba,Eba,S4ba,S5ba,S6ba,maxrsums,aida,false);
        negf = false;
        if (UserDefRepLinesr.AccType==0) then begin
          if (CompYear.NS0[0]!=0) then begin
            negf = true;
          end;
        end;
        if (UserDefRepLinesr.AccType==1) then begin
          if (CompYear.NS0[1]!=0) then begin
            negf = true;
          end;
        end;
        if (UserDefRepLinesr.AccType==2) then begin
          if (CompYear.NS0[2]!=0) then begin
            negf = true;
          end;
        end;
        if (UserDefRepLinesr.AccType==3) then begin
          if (CompYear.NS0[3]!=0) then begin
            negf = true;
          end;
        end;
        if (UserDefRepLinesr.AccType==4) then begin
          if (CompYear.NS0[4]!=0) then begin
            negf = true;
          end;
        end;              
        
        if (nonblank(UserDefRepLinesr.Comment)) then begin
          GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);        
          AGrSumLine2(RepSpec,0,tstr,"",UserDefRepLinesr.SpecCode,S3ba[aid],Pba[aid],Eba[aid],
                     S4ba[aid],S5ba[aid],S6ba[aid],negf,Goms,PLf,resUseAccum,"",UserDefRepLinesr.IdKey,false,true,RepSpec.flags[1]!=3);
        end;
      end;
      if (UserDefRepLinesr.RsType==1) then begin//RsRange
        negf = true;
        if (UserDefRepLinesr.AccType==0) then begin
          if (CompYear.NS0[0]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==1) then begin
          if (CompYear.NS0[1]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==2) then begin
          if (CompYear.NS0[2]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==3) then begin
          if (CompYear.NS0[3]==0) then begin
           negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==4) then begin
          if (CompYear.NS0[4]==0) then begin
            negf = false;
          end;
        end;              
        if (aidn<maxrsums) then begin
          aidn = aidn + 1;
        end;  
        aida[aidn] = UserDefRepLinesr.IdKey;
        aid = aidn;
        
//this is not working like IVr.Sum4 passed to procedure
//        AccListPerBalResGr(RepSpec,PLf,UserDefRepLinesr,S3ba[aid],Pba[aid],Eba[aid],S4ba[aid],S5ba[aid],S6ba[aid],negf,Goms,resUseAccum);

        AccListPerBalResGr(RepSpec,PLf,UserDefRepLinesr,tmpS3ba,tmpPba,tmpEba,tmpS4ba,tmpS5ba,tmpS6ba,negf,Goms,resUseAccum,AccumStartDate,true);
        S3ba[aid] = tmpS3ba;
        S4ba[aid] = tmpS4ba;
        S5ba[aid] = tmpS5ba;
        S6ba[aid] = tmpS6ba;
        Pba[aid] = tmpPba;
        Eba[aid] = tmpEba;        
      end;
      if (UserDefRepLinesr.RsType==4) then begin//RsNewPage
        if (RepSpec.Media!=mtScreen) then begin
          NewPage(false);
        end;  
      end;
    end;
  end;
  if (RepSpec.flags[4]!=0) then begin
    newRepSpec = RepSpec;
    newRepSpec.f1 = "";
    ListPerTrans(newRepSpec);
  end;  
  if (RepSpec.Notation==3) then begin
    Goms = Goms*100;
    StartFormat(15);
    OutString(0,0,USetStr(3170),false);
    OutVal(340,0,Goms,M4Val,true);
    EndFormat;
  end;
L88LResRn:;
  if (RepSpec.CalledFromHAL==0) then begin
    EndJob;
  end;  
LResRn:;  
  RETURN;
END;

global
procedure ResRnCalcRsTypeAccounts(record RcVc RepSpec,string shortname,Boolean PLf,Boolean negf,val Goms,Boolean resUseAccum,date AccumStartDate,
                        vector val S3ba,vector val Pba,vector val Eba,
                        vector val S4ba,vector val S5ba,vector val S6ba,
                        vector Boolean sumsv,
                        Array record UserDefRepLinesVc aUserDefRepLinesr,var Integer udrlcnt)
begin
  record UserDefRepLinesVc UserDefRepLinesr;
  Boolean AGrs;
  string 255 ckey;
  val tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba;
  
  ckey = "ShortIDKey:" & shortname;
  UserDefRepLinesr.IdKey = 0; 
  AGrs = ReadFirstKey(ckey,UserDefRepLinesr,1,false);
  if (AGrs==false) then begin
    StartFormat(20);
    OutString(0,0,USetStr(3167),false);
    EndFormat;
  end;
  UserDefRepLinesr.IdKey = 0; 
  AGrs = true;
  while (LoopKey(ckey,UserDefRepLinesr,1,AGrs)) begin
    if (AGrs) then begin
      switch (UserDefRepLinesr.RsType) begin
        case kRsTypeAccounts:
          AccListPerBalResGr(RepSpec,PLf,UserDefRepLinesr,tmpS3ba,tmpPba,tmpEba,tmpS4ba,tmpS5ba,tmpS6ba,negf,Goms,resUseAccum,AccumStartDate,false);
          S3ba[UserDefRepLinesr.IdKey] = tmpS3ba;
          S4ba[UserDefRepLinesr.IdKey] = tmpS4ba;
          S5ba[UserDefRepLinesr.IdKey] = tmpS5ba;
          S6ba[UserDefRepLinesr.IdKey] = tmpS6ba;
          Pba[UserDefRepLinesr.IdKey] = tmpPba;
          Eba[UserDefRepLinesr.IdKey] = tmpEba; 
          sumsv[UserDefRepLinesr.IdKey] = true;       
        case kRsTypeSum:
          sumsv[UserDefRepLinesr.IdKey] = false;       
        case kRsTypeText:
          sumsv[UserDefRepLinesr.IdKey] = true;       
        case kRsTypePageBreak:
          sumsv[UserDefRepLinesr.IdKey] = true;       
      end;
      aUserDefRepLinesr[udrlcnt] = UserDefRepLinesr;
      udrlcnt = udrlcnt + 1;
    end;
  end;
  
  return;
end;

procedure ResRn_New(record RcVc RepSpec)
BEGIN
  record UserDefRepVc UserDefRepr;
  record UserDefRepLinesVc UserDefRepLinesr;
  record CYBlock CYb;
  Boolean PLf,headerf,resUseAccum,testf;
  record ConsolidationBlock cr;
  string 255 tstr,notstr,per1,per2;
  val Goms;
  Date AccumStartDate;
  val tmpS3ba,tmpS4ba,tmpS5ba,tmpS6ba,tmpPba,tmpEba;
  vector val S3ba;
  vector val S4ba;
  vector val S5ba;
  vector val S6ba;
  vector val Pba;
  vector val Eba;  
  vector Boolean sumsv;
  Array record UserDefRepLinesVc aUserDefRepLinesr;
  Integer udrli,udrlcnt;

  Boolean negf,AGrs;
  Integer i,aid,nr;
  Integer aidn,maxrsums;
  Array Integer Sym_hash;
  string 60 ckey,KeyDefinifion;
  transaction record RcVc KeyRepSpec;
  record RcVc tmpKeyRepSpec;
  record RcVc newRepSpec;
  
//  RepSpec.Stext = RepSpec.sStartDate2 & ":" & RepSpec.sEndDate2;
//only when reportnigperiods on
  PLf = true;
  headerf = true;
  if (RepSpec.CalledFromHAL==0) then begin
    if (((RepSpec.AccSpec==2) or (RepSpec.AccSpec==3)) and (nonblank(RepSpec.ObjType))) then begin
      MessageBox(1072,"");
      goto LResRn;
    end;
  end;
  BlockLoad(CYb);

  if (blank(RepSpec.shortname)) then begin
    UserDefRepr.shortname = RepSpec.repname;
  end else begin
    UserDefRepr.shortname = RepSpec.shortname;
  end;
  if (ReadFirstMain(UserDefRepr,1,true)==false) then begin
    UserDefRepr.shortname = RepSpec.repname;
    if (ReadFirstMain(UserDefRepr,1,true)==false) then begin
      MessageBox(3167,"");
      goto LResRn;
    end;
  end;
  
  if (RepSpec.critname=="ConsResRClass") then begin    
    BlockLoad(cr);
    RepSpec.basecurncy = cr.ConsCrncy;  
  end;
  resUseAccum = false;
  if ((PLf==true) and (RepSpec.Comparison==0)) then begin
    FindAccSD(RepSpec.sStartDate,AccumStartDate,resUseAccum);
  end;  

  if (RepSpec.CalledFromHAL==0) then begin
    FindRepDefHeader(RepSpec.repname,RepSpec.shortname,tstr);
    if (nonblank(RepSpec.f1)) then begin
      tstr = RepSpec.f1;
    end;  
  
    if (RepSpec.flags[5]!=0) then begin 
      headerf = false;
    end;  
    if (headerf) then begin
      StartReportJob(tstr);
      AGrHeader(RepSpec,PLf,resUseAccum,AccumStartDate);
      EndHeader;
    end else begin
      StartReportNoHeaderJob(tstr);
    end;
    SetRepCol(2,50);
    if (RepSpec.Comparison==4) then begin
      if (RepSpec.flags[1]!=3) then begin
        SetRepCol(3,320);
        SetRepCol(4,400);
        SetRepCol(5,480);
      end else begin
        SetRepCol(3,400);
        SetRepCol(4,480);
      end;
    end else begin
      if (RepSpec.flags[1]!=3 or RepSpec.Comparison==0) then begin
        SetRepCol(3,288);
        SetRepCol(4,384);
        SetRepCol(5,480);
      end else begin
        SetRepCol(3,384);
        SetRepCol(4,480);
      end;
    end;
    SetRepCol(6,15);
  end;
  aidn = -1; 
  Goms = 1.00;
  if (RepSpec.Notation==3) then begin
    tstr = USetStr(3146);
    KeyDefinifion = GetKeyCodeNr(tstr);
    if (nonblank(KeyDefinifion)) then begin
      RecordCopy(tmpKeyRepSpec,KeyRepSpec);
      RecordCopy(KeyRepSpec,RepSpec);
      CalcKeyRn(tstr,KeyDefinifion,RepSpec.IncDaughter,RepSpec.basecurncy,"",0,0,0,0,"","","",Goms);
      Goms = Goms/100.00;
      RecordCopy(KeyRepSpec,tmpKeyRepSpec);
    end else begin
      Goms = blankval;
    end;
  end;
  if (RepSpec.CalledFromHAL==0) then begin
    GetNotStr(RepSpec.Notation,notstr);
    StartFormat(20);
    tstr = "";
    if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
      OutString(11,0,tstr,true); // To make export to file look better 
      OutString(20,0,tstr,true);
    end;
    if (RepSpec.Comparison==0) then begin
      tstr = USetStr(3156);
      tstr = tstr & notstr;
//        if (resUseAccum==true) then begin //I don't think this is needed here at all
        OutStringAdjust(4,0,tstr,true,M4Val);
//        end;  
      tstr = USetStr(3157);
      tstr = tstr & notstr;
      OutStringAdjust(5,0,tstr,true,M4Val);
    end;
    if (RepSpec.Comparison==1) then begin
      if (HasLocalization("FIN")) then begin
        tstr = USetStr(3159);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3158);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
      end else begin
        tstr = USetStr(3159);
        tstr = tstr & notstr;
        OutString(3,0,tstr,true);
        tstr = USetStr(3158);
        tstr = tstr & notstr;
        OutString(4,0,tstr,true);
      end;
      if (RepSpec.flags[1]!=3) then begin
        OutString(5,0,USetStr(3160),true);
      end;
    end;
    if (RepSpec.Comparison==2) then begin
      tstr = USetStr(3161);
      if (nonblank(RepSpec.FirstAcc)) then begin
        tstr = tstr & notstr & " " & USetStr(3176) & " """ & RepSpec.FirstAcc &  """";
      end else begin
        tstr = tstr & notstr;
      end;
      OutString(3,0,tstr,true);
      tstr = USetStr(3162);
      tstr = tstr & notstr;
      OutString(4,0,tstr,true);
      if (RepSpec.flags[1]!=3) then begin
        OutString(5,0,USetStr(3163),true);
      end;
    end;
    if (RepSpec.Comparison==3) then begin
      tstr = USetStr(3164);
      if (nonblank(RepSpec.FirstAcc)) then begin
        tstr = tstr & notstr & " " & USetStr(3176) & " """ & RepSpec.FirstAcc &  """";
      end else begin
        tstr = tstr & notstr;
      end;
      OutString(3,0,tstr,true);
      tstr = USetStr(3165);
      tstr = tstr & notstr;
      OutString(4,0,tstr,true);
      if (RepSpec.flags[1]!=3) then begin
        OutString(5,0,USetStr(3166),true);
      end;
    end;
    if (RepSpec.Comparison==4) then begin
      GetPreviousPeriods(RepSpec,RepSpec.sStartDate,RepSpec.sEndDate,per1,per2);      
      tstr = "";
      if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
        OutString(3,0,tstr,true);
      end;
      if (HasLocalization("FIN")) then begin
        OutString(3,0,per1,true);
        OutString(4,0,per2,true);
      end else begin
        OutString(3,0,per2,true);
        OutString(4,0,per1,true);
      end;
      if (RepSpec.flags[1]!=3) then begin
        OutString(5,0,USetStr(3166),true);
      end;
    end;
    EndFormat;
end;
  if ((nonblank(RepSpec.ObjType)) and (RepSpec.AccSpec==2)) then begin
    StartFormat(20);
    OutString(0,0,USetStr(1565),false);
    EndFormat;
    goto L88LResRn;
  end;
  
  ckey = "ShortIDKey:" & UserDefRepr.shortname;
  UserDefRepLinesr.IdKey = 0; 
  AGrs = ReadFirstKey(ckey,UserDefRepLinesr,1,false);
  if (AGrs==false) then begin
    StartFormat(20);
    OutString(0,0,USetStr(3167),false);
    EndFormat;
  end;
//calculate  
  ResRnCalcRsTypeAccounts(RepSpec,UserDefRepr.shortname,PLf,negf,Goms,resUseAccum,AccumStartDate,
    S3ba,Pba,Eba,S4ba,S5ba,S6ba,sumsv,aUserDefRepLinesr,udrlcnt);
//sums
  CalcRsTypeSum(S3ba,Pba,Eba,S4ba,S5ba,S6ba,sumsv,aUserDefRepLinesr,udrlcnt,-1);


//print
  for (udrli=0;udrli<udrlcnt;udrli=udrli+1) begin
    UserDefRepLinesr = aUserDefRepLinesr[udrli];
    switch (UserDefRepLinesr.RsType) begin
      case kRsTypeAccounts:
        negf = true;
        if (UserDefRepLinesr.AccType==kAccTypeAsset) then begin
          if (CYb.NS0[0]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==kAccTypeLiability) then begin
          if (CYb.NS0[1]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==kAccTypeEquity) then begin
          if (CYb.NS0[2]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==kAccTypeIncome) then begin
          if (CYb.NS0[3]==0) then begin
            negf = false;
          end;
        end;
        if (UserDefRepLinesr.AccType==kAccTypeExpense) then begin
          if (CYb.NS0[4]==0) then begin
            negf = false;
          end;
        end;              
        AccListPerBalResGr(RepSpec,PLf,UserDefRepLinesr,tmpS3ba,tmpPba,tmpEba,tmpS4ba,tmpS5ba,tmpS6ba,negf,Goms,resUseAccum,AccumStartDate,true);
      case kRsTypeSum:
        testf = true;
        
        if (RepSpec.AccSpec==3 and HasLocalization("FIN")) then begin
          if (S3ba[UserDefRepLinesr.IdKey]==0 and
              Pba[UserDefRepLinesr.IdKey]==0 and
              Eba[UserDefRepLinesr.IdKey]==0 and
              S4ba[UserDefRepLinesr.IdKey]==0 and
              S5ba[UserDefRepLinesr.IdKey]==0 and
              S6ba[UserDefRepLinesr.IdKey]==0) then begin
            testf = false;
          end;
        end;
        
        if (testf) then begin
          negf = false;
          if (UserDefRepLinesr.AccType==kAccTypeAsset) then begin
            if (CYb.NS0[0]!=0) then begin
              negf = true;
            end;
          end;
          if (UserDefRepLinesr.AccType==kAccTypeLiability) then begin
            if (CYb.NS0[1]!=0) then begin
              negf = true;
            end;
          end;
          if (UserDefRepLinesr.AccType==kAccTypeEquity) then begin
            if (CYb.NS0[2]!=0) then begin
              negf = true;
            end;
          end;
          if (UserDefRepLinesr.AccType==kAccTypeIncome) then begin
            if (CYb.NS0[3]!=0) then begin
              negf = true;
            end;
          end;
          if (UserDefRepLinesr.AccType==kAccTypeExpense) then begin
            if (CYb.NS0[4]!=0) then begin
              negf = true;
            end;
          end;                        
          if (nonblank(UserDefRepLinesr.Comment)) then begin
            GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);        
            AGrSumLine2(RepSpec,0,tstr,"",UserDefRepLinesr.SpecCode,S3ba[UserDefRepLinesr.IdKey],Pba[UserDefRepLinesr.IdKey],Eba[UserDefRepLinesr.IdKey],
                       S4ba[UserDefRepLinesr.IdKey],S5ba[UserDefRepLinesr.IdKey],S6ba[UserDefRepLinesr.IdKey],negf,Goms,PLf,resUseAccum,"",UserDefRepLinesr.IdKey,false,true,RepSpec.flags[1]!=3);
          end;
        end;
      case kRsTypeText:
        GetUserDefRepDescription(UserDefRepLinesr,RepSpec.Language,tstr);        
        StartFormat(15);
        OutString(0,0,tstr,false);// UserDefRepLinesr.Comment
        EndFormat;
      case kRsTypePageBreak:
        if (RepSpec.Media!=mtScreen) then begin
          NewPage(false);
        end;  
    end;
  end;


  if (RepSpec.flags[4]!=0) then begin
    newRepSpec = RepSpec;
    newRepSpec.f1 = "";
    ListPerTrans(newRepSpec);
  end;  
  if (RepSpec.Notation==3) then begin
    Goms = Goms*100;
    StartFormat(15);
    OutString(0,0,USetStr(3170),false);
    OutVal(340,0,Goms,M4Val,true);
    EndFormat;
  end;
L88LResRn:;
  if (RepSpec.CalledFromHAL==0) then begin
    EndJob;
  end;  
LResRn:;  
  RETURN;
END;

global
procedure ResRn(record RcVc RepSpec)
begin
//  ResRn_Old(RepSpec);
  ResRn_New(RepSpec);
  AutomatedSalesOrderly("HasIntegratedNL+Run_ResRn");
  return;
end;
