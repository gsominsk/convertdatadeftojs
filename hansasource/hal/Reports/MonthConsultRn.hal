external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external procedure ExtractObj(string,var Integer,var string);
external function val TimeToVal2(Time);
external procedure HT2Per(Date, Date , var string);
external procedure FindTargetTimeForType(record RcVc,string,string,string,var val);

procedure PrintNote(record NotepadVc Noter)
BEGIN
  Integer i,rwcnt;
  string 255 tstr;
  
  StartFormat(15);
   OutString(0,0,USetStr(13420),false);
  EndFormat;
  rwcnt = LineTextCnt(Noter);
  for (i=0;i<rwcnt;i=i+1) begin
    tstr = LineTextGet(Noter,i);
    StartFormat(15);
     OutString(15,0,tstr,false);
    EndFormat;
  end;  
  RETURN;
END;

global
procedure ForecastPrintNote(record ForecastUserVc ForecastUserr,string argumentstr)
BEGIN
  record NotepadVc Noter;
  record RLinkVc RLr;
  Integer notenr;

  notenr = 1;
  while (ReadRecordLink(ForecastUserr,notenr,Noter,RLr)) begin
    if ((argumentstr==RLr.Comment) or (blank(argumentstr))) then begin
      PrintNote(Noter);
      goto LForecastPrintNote;
    end;
    notenr = notenr + 1;
  end;
LForecastPrintNote:;  
  RETURN;
END;

global
function val FindTargetTimeForTypes(record RcVc RepSpec,string user,string acttypes)
BEGIN
  val res,t;
  string 10 acttype;
  Integer pos;
  
  pos = 0;
  ExtractObj(acttypes,pos,acttype);
  while (nonblank(acttype)) begin
    FindTargetTimeForType(RepSpec,user,acttype,"",t);
    res = res + t;
    ExtractObj(acttypes,pos,acttype);
  end;  
  FindTargetTimeForTypes = res;
  RETURN;
END;

function val UserActTypeHours(string person,string acttype,Date startd,Date endd)
BEGIN
  string 255 tstr,keystr;
  record ActVc Actr;
  Boolean TrHs,testf;
  val res;
  Date enddate;

  TrHs = true;
  keystr = "DateTypeUserMain:" & person;
  Actr.CalTimeFlag = 1;
  Actr.TransDate = startd;
  Actr.ActType = acttype;
  while (LoopKey(keystr,Actr,3,TrHs)) begin
    if (Actr.ActType!=acttype) then begin TrHs = false; end;
    if (DateInRange(Actr.TransDate,startd,endd)==false) then begin 
      TrHs = false; 
    end;
    if (SetInSet(person,Actr.MainPersons)==false) then begin
      if (SetInSet(person,Actr.CCPersons)==false) then begin
        TrHs = false;
      end;
    end;
    if (Actr.CalTimeFlag!=1) then begin TrHs = false; end;    
    if (TrHs) then begin
      testf = true;
      if (Actr.TodoFlag!=0) then begin testf = false; end;
      if (testf) then begin
        if (nonblanktime(Actr.CostTime)) then begin
          res = res + TimeToVal2(Actr.CostTime);
        end else begin
          res = res + (TimeToVal2(Actr.EndTime)-TimeToVal2(Actr.StartTime));
        end;
      end;
    end;
  end;
  UserActTypeHours = res;
  RETURN;
END;

global
function val UserActTypesHours(string person,string acttypes,Date startd,Date endd)
BEGIN
  val res;
  string 10 acttype;
  Integer pos;
  
  pos = 0;
  ExtractObj(acttypes,pos,acttype);
  while (nonblank(acttype)) begin
    res = res + UserActTypeHours(person,acttype,startd,endd);
    ExtractObj(acttypes,pos,acttype);
  end;
  UserActTypesHours = res;
  RETURN;
END;

function val UserActTypeNumber(string person,string acttype,Date startd,Date endd)
BEGIN
  string 255 tstr,keystr;
  record ActVc Actr;
  Boolean TrHs,testf;
  val res;
  Date enddate;

  TrHs = true;
  keystr = "DateTypeUserMain:" & person;
  Actr.CalTimeFlag = 1;
  Actr.TransDate = startd;
  Actr.ActType = acttype;
  while (LoopKey(keystr,Actr,3,TrHs)) begin
    if (Actr.ActType!=acttype) then begin TrHs = false; end;
    if (DateInRange(Actr.TransDate,startd,endd)==false) then begin 
      TrHs = false; 
    end;
    if (SetInSet(person,Actr.MainPersons)==false) then begin
      if (SetInSet(person,Actr.CCPersons)==false) then begin
        TrHs = false;
      end;
    end;
    if (Actr.CalTimeFlag!=1) then begin TrHs = false; end;    
    if (TrHs) then begin
      testf = true;
      if (Actr.TodoFlag!=0) then begin testf = false; end;
      if (testf) then begin
        res = res + 1;
      end;
    end;
  end;
  UserActTypeNumber = res;
  RETURN;
END;

global
function val UserActTypesNumber(string person,string acttypes,Date startd,Date endd)
BEGIN
  val res;
  string 10 acttype;
  Integer pos;
  
  pos = 0;
  ExtractObj(acttypes,pos,acttype);
  while (nonblank(acttype)) begin
    res = res + UserActTypeNumber(person,acttype,startd,endd);
    ExtractObj(acttypes,pos,acttype);
  end;
  UserActTypesNumber = res;
  RETURN;
END;

function val UserHours2(string person,string acttype,Date startd,Date endd)
BEGIN
  string 255 tstr,keystr;
  record ActVc Actr;
  Boolean TrHs,testf;
  val res;

  TrHs = true;
  keystr = "ActTypeUserMain:" & person;
  Actr.ActType = acttype;
  Actr.TodoFlag = 0;
  while (LoopKey(keystr,Actr,2,TrHs)) begin
    if (Actr.ActType!=acttype) then begin TrHs = false; end;
    if (Actr.TodoFlag!=0) then begin TrHs = false; end;
    if (SetInSet(person,Actr.MainPersons)==false) then begin
      if (SetInSet(person,Actr.CCPersons)==false) then begin
        TrHs = false;
      end;
    end;
    if (TrHs) then begin
      testf = true;
      if (Actr.CalTimeFlag!=1) then begin testf = false; end;
      if (DateInRange(Actr.TransDate,startd,endd)==false) then begin 
        testf = false;
      end;
      if (testf) then begin
        if (blanktime(Actr.CostTime)) then begin
          res = res + TimeToVal2(Actr.CostTime);
        end else begin
          res = res + (TimeToVal2(Actr.EndTime)-TimeToVal2(Actr.StartTime));
        end;
      end;
    end;
  end;
  UserHours2 = res;
  RETURN;
END;

procedure PrintRowHeader(Integer col1,Integer col3,Integer col5,Integer col7,Integer adjhead,
                              Integer id1,Integer id2,Integer id3,Integer id4)
BEGIN
  StartFormat(15);
  if (id1>0) then begin
    OutString(col1+adjhead,0,USetStr(id1),false);
  end;
  if (id2>0) then begin
    OutString(col3+adjhead,0,USetStr(id2),false);
  end;
  if (id3>0) then begin
    OutString(col5+adjhead,0,USetStr(id3),false);
  end;
  if (id4>0) then begin
    OutString(col7+adjhead,0,USetStr(id4),false);
  end;
  EndFormat;
  RETURN;
END;

procedure PrintForecastResultText(Integer col1,Integer col2,Integer col3,Integer col4,Integer col5,Integer col6,Integer col7,Integer col8)
BEGIN
  StartFormat(15);
  OutString(col1,0,USetStr(13404),false);
  OutString(col2,0,USetStr(13405),false);
  if (col3>0) then begin
    OutString(col3,0,USetStr(13404),false);
  end;
  if (col4>0) then begin
    OutString(col4,0,USetStr(13405),false);
  end;
  if (col5>0) then begin
    OutString(col5,0,USetStr(13404),false);
  end;
  if (col6>0) then begin
    OutString(col6,0,USetStr(13405),false);
  end;
  if (col7>0) then begin
    OutString(col7,0,USetStr(13404),false);
  end;
  if (col8>0) then begin
    OutString(col8,0,USetStr(13405),false);
  end;
  EndFormat;
  RETURN;
END;

procedure PrintRowResult(Integer col1,Integer col2,Integer col3,Integer col4,Integer col5,Integer col6,Integer col7,Integer col8,
                         val v1,val v2,val v3,val v4,val v5,val v6,val v7,val v8)
BEGIN                 
  StartFormat(15);
  OutVal(col1,0,v1,M4Val,false);
  OutVal(col2,0,v2,M4Val,false);
  if (col3>0) then begin
    OutVal(col3,0,v3,M4Val,false);
  end;
  if (col4>0) then begin
    OutVal(col4,0,v4,M4Val,false);
  end;
  if (col5>0) then begin
    OutVal(col5,0,v5,M4Val,false);
  end;
  if (col6>0) then begin
    OutVal(col6,0,v6,M4Val,false);
  end;
  if (col7>0) then begin
    OutVal(col7,0,v7,M4Val,false);
  end;
  if (col8>0) then begin
    OutVal(col8,0,v8,M4Val,false);
  end;
  EndFormat;
  RETURN;
END;

global
function val UserSales(string person,Date startdate,Date enddate,string salesaccs,string custobjects,string partnerobjects)
BEGIN
  val res;
  string 10 fracc,toacc;
  record CUVc CUr;
  record IVVc IVr;
  row IVVc IVrw;
  Integer i,rwcnt,pos;
  Boolean TrHs,testf;
  string 255 ivobjects,partnerobject;
  
  fracc = FirstInRange(salesaccs,10);
  toacc = LastInRange(salesaccs,10);
  TrHs = true;
  IVr.SalesMan = person;
  IVr.InvDate = startdate;
  while (LoopKey("SalesMan",IVr,2,TrHs)) begin
    if (IVr.SalesMan!=person) then begin TrHs = false; end;
    if (IVr.InvDate>enddate) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
/*      
      if (nonblank(custcat)) then begin
        CUr.Code = QTr.CustCode;
        if (ReadFirstMain(CUr,1,true)) then begin
          if (CUr.CustCat!=custcat) then begin 
            testf = false;
          end;
        end;
      end;
*/      
    end;
    if (TrHs and testf) then begin
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        testf = false;
        if ((IVrw.SalesAcc>=fracc) and (IVrw.SalesAcc<=toacc)) then begin
          testf = true;
        end;
        if (blank(salesaccs)) then begin
          testf = true;
        end;
        if (testf) then begin
          ivobjects = IVr.Objects;
          if ((nonblank(ivobjects)) and (nonblank(IVrw.Objects))) then begin
            ivobjects = ivobjects & ",";
          end;
          ivobjects = ivobjects & IVrw.Objects;
          if (SetInSet(custobjects,ivobjects)) then begin testf = false; end;
          if (testf) then begin
            if (nonblank(partnerobjects)) then begin
              testf = false;
              pos = 0;
              ExtractObj(partnerobjects,pos,partnerobject);
              while (nonblank(partnerobject)) begin
                if (SetInSet(partnerobject,ivobjects)) then begin
                  testf = true;
                  goto LPARTNEROBJ;
                end;
                ExtractObj(partnerobjects,pos,partnerobject);
              end;  
LPARTNEROBJ:;
            end;
          end;
          if (testf) then begin
            res = res + MulRateToBase2(IVr.CurncyCode,IVrw.Sum,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
//            res = res + IVrw.Sum;
          end;
        end;
      end;
    end;
  end;
  UserSales = res;
  RETURN;
END;

global
procedure MonthConsultRn(record RcVc RepSpec)
BEGIN
  string 255 tstr;
  Integer rw;
  record CountryVc Countryr;
  record UserVc Userr;
  record ForecastUserVc ForecastUserr;
  record ResultUserVc ResultUserr;
  record MonthlyUserSetVc MonthlyUserSetr;
  Boolean forecastf;
  val consres,progres,projres,educres,chargeableres,consavailres;
  val constarg,progtarg,projtarg,eductarg,supptarg;
  val suppres,freeres;
  val chargeable,usedoncustomers,usedoncustomersres,consavailinclsuppres;
  val licenses,services;
  Integer adjhead,col1,col2,col3,col4,col5,col6,col7,col8;
  string 10 consstr,progstr,projstr,educstr,suppstr,freestr;  
  
  Userr.Code = RepSpec.TransStr;
  if (ReadFirstMain(Userr,1,true)) then begin end;
  ForecastUserr.Person = RepSpec.TransStr;
  ForecastUserr.Month = GetMonth(RepSpec.sStartDate);
  forecastf = ReadFirstKey("PersonMonth",ForecastUserr,2,true);

  Countryr.Code = ForecastUserr.Country;
  if (ReadFirstMain(Countryr,1,true)) then begin end;
  StartReportJob(USetStr(13400));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  Header(rw,Userr.Name,0);
  Header(rw,Countryr.Comment,1);
  EndHeader;
  col1 = 0;
  col2 = 50;
  col3 = 110;
  col4 = 160;
  col5 = 220;
  col6 = 280;
  col7 = 330;
  col8 = 390;
  adjhead = 0;
  if (blank(RepSpec.TransStr)) then begin
    StartFormat(15);
    OutString(0,0,USetStr(13401),false);
    EndFormat;
    goto LEND;
  end;
  if (forecastf==false) then begin
    StartFormat(15);
    OutString(0,0,USetStr(13402),false);
    EndFormat;
    goto LEND;
  end;
  ResultUserr.Person = RepSpec.TransStr;
  ResultUserr.Month = GetMonth(RepSpec.sStartDate);
  forecastf = ReadFirstKey("PersonMonth",ResultUserr,2,true);
  
  StartFormat(15);
  OutString(0,0,USetStr(13403),false);
  EndFormat;
  Gray_Divider(0,1);
  if (RepSpec.flags[0]==0) then begin
    PrintRowHeader(col1,col3,col5,col7,adjhead,13406,13407,13408,13409);  
    PrintForecastResultText(col1,col2,col3,col4,col5,col6,col7,col8);

    
    chargeableres = ResultUserr.chConsulting + ResultUserr.chProgramming + ResultUserr.chProjectMan + ResultUserr.chEducation;
    chargeable = ForecastUserr.chConsulting + ForecastUserr.chProgramming + ForecastUserr.chProjectMan + ForecastUserr.chEducation;

    PrintRowResult(col1,col2,col3,col4,col5,col6,col7,col8,
                   ForecastUserr.chConsulting,ResultUserr.chConsulting,ForecastUserr.chProgramming,ResultUserr.chProgramming,
                   ForecastUserr.chProjectMan,ResultUserr.chProjectMan,ForecastUserr.chEducation,ResultUserr.chEducation);
    StartFormat(15);
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(15);
    EndFormat;
    
    PrintRowHeader(col1,col3,col5,col7,adjhead,13410,13411,13412,-1)
    PrintForecastResultText(col1,col2,col3,col4,col5,col6,-1,-1);  
    PrintRowResult(col1,col2,col3,col4,col5,col6,-1,-1,
                   chargeable,chargeableres,ForecastUserr.AvailExclSupp,ResultUserr.AvailExclSupp,
                   (chargeable/ForecastUserr.AvailExclSupp)*100,(chargeableres/ResultUserr.AvailExclSupp)*100,0,0);
    StartFormat(15);
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(15);
    EndFormat;

    PrintRowHeader(col1,col3,col5,col7,adjhead,13413,13414,13415,13416)  
    PrintForecastResultText(col1,col2,col3,col4,col5,col6,col7,col8);
    usedoncustomers = chargeable + ForecastUserr.Support + ForecastUserr.FreeService;
    usedoncustomersres = chargeableres + ResultUserr.Support + ResultUserr.FreeService;
    PrintRowResult(col1,col2,col3,col4,col5,col6,col7,col8,
                   ForecastUserr.Support,ResultUserr.Support,ForecastUserr.FreeService,ResultUserr.FreeService,
                   usedoncustomers,usedoncustomersres,ForecastUserr.AvailInclSupp,ResultUserr.AvailInclSupp);
  
    StartFormat(15);
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(15);
    EndFormat;

    PrintRowHeader(col1,col3,col5,col7,adjhead,13417,-1,-1,-1)  
    PrintForecastResultText(col1,col2,-1,-1,-1,-1,-1,-1);
    PrintRowResult(col1,col2,-1,-1,-1,-1,-1,-1,
                   (ForecastUserr.UsedonCustomers/ForecastUserr.AvailInclSupp)*100,(ResultUserr.UsedonCustomers/ResultUserr.AvailInclSupp)*100,0,0,
                   0,0,0,0);

    StartFormat(15);
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(15);
    EndFormat;
    
    StartFormat(15);
    OutString(0,0,USetStr(13418),false);
    EndFormat;
    StartFormat(15);
    OutString(15,0,ForecastUserr.Development1,false);
    EndFormat;
    StartFormat(15);
    OutString(0,0,USetStr(13419),false);
    EndFormat;
    StartFormat(15);
    OutString(15,0,ForecastUserr.Development2,false);
    EndFormat;
    
    StartFormat(15);
    OutString(0,0,USetStr(13421) & USetStr(13422),false);
    OutVal(480,0,ForecastUserr.LicensesNewCU + ForecastUserr.LicensesOldCU,M4Val,true);
    EndFormat;  
    StartFormat(15);
    OutString(0,0,USetStr(13421) & USetStr(13423),false);
    OutVal(480,0,ForecastUserr.ConsultingNewCU + ForecastUserr.ConsultingOldCU,M4Val,true);
    EndFormat;
    
    ForecastPrintNote(ForecastUserr,"");
    goto LEND;
  end;


  PrintRowHeader(col1,col3,col5,col7,adjhead,13406,13407,13408,13409);  
  PrintForecastResultText(col1,col2,col3,col4,col5,col6,col7,col8);
  consstr = RepSpec.FirstAcc;
  progstr = RepSpec.LastAcc;
  projstr = RepSpec.AccStr;
  educstr = RepSpec.ObjType;
  suppstr = RepSpec.ObjStr;
  freestr = RepSpec.f1;
  
  MonthlyUserSetr.Person = RepSpec.TransStr;
  if (ReadFirstMain(MonthlyUserSetr,1,true)) then begin
    if (blank(consstr)) then begin consstr = MonthlyUserSetr.chConsulting; end;
    if (blank(progstr)) then begin progstr = MonthlyUserSetr.chProgramming; end;
    if (blank(projstr)) then begin projstr = MonthlyUserSetr.chProjectMan; end;
    if (blank(educstr)) then begin educstr = MonthlyUserSetr.chEducation; end;
    if (blank(suppstr)) then begin suppstr = MonthlyUserSetr.Support; end;
    if (blank(freestr)) then begin freestr = MonthlyUserSetr.FreeService; end;
  end;
  consres = UserActTypesHours(RepSpec.TransStr,consstr,RepSpec.sStartDate,RepSpec.sEndDate);
  progres = UserActTypesHours(RepSpec.TransStr,progstr,RepSpec.sStartDate,RepSpec.sEndDate);
  projres = UserActTypesHours(RepSpec.TransStr,projstr,RepSpec.sStartDate,RepSpec.sEndDate);
  educres = UserActTypesHours(RepSpec.TransStr,educstr,RepSpec.sStartDate,RepSpec.sEndDate);
  suppres = UserActTypesHours(RepSpec.TransStr,suppstr,RepSpec.sStartDate,RepSpec.sEndDate);
  freeres = UserActTypesHours(RepSpec.TransStr,freestr,RepSpec.sStartDate,RepSpec.sEndDate);

  chargeableres = chargeableres + educres;
  chargeableres = chargeableres + projres;
  chargeableres = chargeableres + progres;
  chargeableres = chargeableres + consres;

  constarg = FindTargetTimeForTypes(RepSpec,RepSpec.TransStr,consstr);
  progtarg = FindTargetTimeForTypes(RepSpec,RepSpec.TransStr,progstr);
  projtarg = FindTargetTimeForTypes(RepSpec,RepSpec.TransStr,projstr);
  eductarg = FindTargetTimeForTypes(RepSpec,RepSpec.TransStr,educstr);
  supptarg = FindTargetTimeForTypes(RepSpec,RepSpec.TransStr,suppstr);

  consavailres = constarg + progtarg + projtarg + eductarg;

  chargeable = ForecastUserr.chConsulting + ForecastUserr.chProgramming + ForecastUserr.chProjectMan + ForecastUserr.chEducation;
  PrintRowResult(col1,col2,col3,col4,col5,col6,col7,col8,
                 ForecastUserr.chConsulting,consres,ForecastUserr.chProgramming,progres,
                 ForecastUserr.chProjectMan,projres,ForecastUserr.chEducation,educres);
  
  StartFormat(15);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  EndFormat;

  PrintRowHeader(col1,col3,col5,col7,adjhead,13410,13411,13412,-1)
  PrintForecastResultText(col1,col2,col3,col4,col5,col6,-1,-1);  
  PrintRowResult(col1,col2,col3,col4,col5,col6,-1,-1,
                 chargeable,chargeableres,ForecastUserr.AvailExclSupp,consavailres,
                 (chargeable/ForecastUserr.AvailExclSupp)*100,(chargeableres/consavailres)*100,0,0);
  StartFormat(15);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  EndFormat;

  PrintRowHeader(col1,col3,col5,col7,adjhead,13413,13414,13415,13416)  
  PrintForecastResultText(col1,col2,col3,col4,col5,col6,col7,col8);
  
  usedoncustomers = chargeable + ForecastUserr.Support + ForecastUserr.FreeService;
  usedoncustomersres = chargeableres + suppres + freeres;
  consavailinclsuppres = constarg + progtarg + projtarg + eductarg + supptarg;

  PrintRowResult(col1,col2,col3,col4,col5,col6,col7,col8,
                 ForecastUserr.Support,suppres,ForecastUserr.FreeService,freeres,
                 usedoncustomers,usedoncustomersres,ForecastUserr.AvailInclSupp,consavailinclsuppres);
  
  StartFormat(15);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  EndFormat;

  PrintRowHeader(col1,col3,col5,col7,adjhead,13417,-1,-1,-1)  
  PrintForecastResultText(col1,col2,-1,-1,-1,-1,-1,-1);
  PrintRowResult(col1,col2,-1,-1,-1,-1,-1,-1,
                 (usedoncustomers/ForecastUserr.AvailInclSupp)*100,(usedoncustomersres/consavailinclsuppres)*100,0,0,
                 0,0,0,0);
  
  StartFormat(15);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(13418),false);
  EndFormat;
  StartFormat(15);
  OutString(15,0,ForecastUserr.Development1,false);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(13419),false);
  EndFormat;
  StartFormat(15);
  OutString(15,0,ForecastUserr.Development2,false);
  EndFormat;
  
  licenses = UserSales(RepSpec.TransStr,RepSpec.sStartDate,RepSpec.sEndDate,"3010:3026","74010","");
  services = UserSales(RepSpec.TransStr,RepSpec.sStartDate,RepSpec.sEndDate,"3070:3088","74010","");
  
  StartFormat(15);
  OutString(0,0,USetStr(13421) & USetStr(13422),false);
  OutVal(480,0,licenses,M4Val,true);
  EndFormat;  
  StartFormat(15);
  OutString(0,0,USetStr(13421) & USetStr(13423),false);
  OutVal(480,0,services,M4Val,true);
  EndFormat;
  ForecastPrintNote(ForecastUserr,"");
LEND:;  
  EndJob;
  RETURN;
END;

