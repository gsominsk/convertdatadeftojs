external procedure CalcRsTypeSum(vector val,vector val,vector val,
                        vector val,vector val,vector val,
                        vector Boolean,Array record UserDefRepLinesVc,Integer,LongInt);
external function Integer DateGetIntMonth(Date);
external function LongInt DateDiff(Date,Date);
external function Boolean GetObjBal(string,string,var record ObjBalVc);
external function Integer CountObjects(string);
external procedure HT2Per(Date, Date , var string);
external procedure LstRegDat(var string);
external procedure HTObj(string,var string);
external procedure HTOT(string,var string);
external procedure HTAccount(Integer,var string);
external function Boolean DatePrel(Date);
external procedure HTAccPer(Date,Date,var string);
external procedure HTComp(Integer,Boolean,Integer,var string);
external procedure HTNot(Integer,var string);
external procedure GetAccStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val);
external procedure GetAccBalance(string,string,Date,record ObjBalVc,Integer,Integer,Integer,string,Integer,var val);
external procedure GetAccDCStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val,var val);
external procedure GetAccTurnover(string,string,Date,Date,record ObjBalVc,string,Integer,Integer,Integer,var val,var val);
external procedure GetAccDCTurnover(string,string,Date,Date,record ObjBalVc,string,Integer,Integer,Integer,val,val,var val,var val);
external function val Budg1Calc2(string,string,string,string,Date,Date,Integer,Integer,Integer);
external function val Budg2Calc2(string,string,string,string,Date,Date,Integer,Integer,Integer);
external procedure FindFiscalYear(Date,var Date,var Date);

procedure SetPLSumups(Integer column,var val Sbp,var val Pbp,var val Ebp)
BEGIN
  val temp;
  
  if ((column==10) or (column==12)) then begin
    Ebp = Sbp - Pbp;
  end;
  if ((column==11) or (column==13)) then begin
    if (Pbp==0) then begin
      Ebp = blankval;
    end else begin
      temp = Sbp - Pbp;
      Ebp = temp/Pbp;
      Ebp = Ebp*100;
      Ebp = -Ebp;
    end;
  end;
  RETURN;
END;

procedure SetBSSumups(Integer column,var val Sbp,var val Pbp,var val Ebp)
BEGIN
  val temp;
  
  if ((column==10) or (column==12)) then begin
    Ebp = Sbp - Pbp;
  end;
  if ((column==11) or (column==13)) then begin
    if (Pbp==0) then begin
      Ebp = blankval;
    end else begin
      temp = Sbp - Pbp;
      Ebp = temp/Pbp;
      Ebp = Ebp*100;
      Ebp = -Ebp;
    end;
  end;
  RETURN;
END;

procedure AddupRU(Integer DCSide,var val Sbp,var val Pbp,val dSb,val dPb,val cSb,val cPb)
BEGIN
  if (DCSide==1) then begin
    Sbp = dSb;
    Pbp = dPb;
  end;
  if (DCSide==2) then begin
    Sbp = -cSb;
    Pbp = -cPb;
  end;
  if ((DCSide!=1) and (DCSide!=2)) then begin
    Sbp = dSb - cSb;
    Pbp = dPb - cPb;
  end;
  RETURN;
END;

procedure SetBSColBal(record RcVc RepSpec,Integer column,string accstr,string objs,record ObjBalVc ObjBalr,var val valp,Integer DCSide,Date AccumStartDate,
                      Date budsd,Date buded)
BEGIN
  Date pysd,pyed;
  val dSb,cSb,dPb,cPb;
  val temp,temp2;
  
  if (column==1) then begin// Start Balance 
    GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    AddupRU(DCSide,valp,temp,dSb,dPb,cSb,cPb);
  end;
  if (column==2) then begin// Turnover
    GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,valp,dSb,dPb,cSb,cPb);
  end;
  if (column==3) then begin// End Balance 
    GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,temp2,dSb,dPb,cSb,cPb);
    valp = temp + temp2;
  end;
  if (column==4) then begin// To Budget 1 
    valp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0); 
  end;
  if (column==5) then begin// To Budget 2 
    valp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0); 
  end;
  if (column==6) then begin// Previous Year Start Balance 
    pysd = AddYear(RepSpec.sStartDate,-1);
    pyed = AddYear(RepSpec.sEndDate,-1);
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    AddupRU(DCSide,valp,temp,dSb,dPb,cSb,cPb);
  end;
  if (column==7) then begin// Previous Year Turnover 
    pysd = AddYear(RepSpec.sStartDate,-1);
    pyed = AddYear(RepSpec.sEndDate,-1);
    if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
      if (IsLeapYear(GetYear(pyed))) then begin
        pyed = AddDay(pyed,-GetDay(pyed) + 29);
      end;
    end;          
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,temp2,dSb,dPb,cSb,cPb);
    valp = temp + temp2;
  end;
  if (column==8) then begin// Previous Year End Balance 
    pysd = AddYear(RepSpec.sStartDate,-1);
    pyed = AddYear(RepSpec.sEndDate,-1);
    if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
      if (IsLeapYear(GetYear(pyed))) then begin
        pyed = AddDay(pyed,-GetDay(pyed) + 29);
      end;
    end;          
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,temp2,dSb,dPb,cSb,cPb);
    valp = temp + temp2;
  end;
  if ((column==10) or (column==11) or (column==12) or (column==13)) then begin
  end;
  if (column==15) then begin// Start Balance this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    AddupRU(DCSide,valp,temp,dSb,dPb,cSb,cPb);
  end;
  if (column==16) then begin// Turnover this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,valp,dSb,dPb,cSb,cPb);
  end;
  if (column==17) then begin// End Balance this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    GetAccDCStartBalance(accstr,objs,pysd,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
    AddupRU(DCSide,temp,temp2,dSb,dPb,cSb,cPb);
    valp = temp + temp2;
  end;
  if (column==18) then begin// To Budget 1 this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,pyed,RepSpec.basecurncy,RepSpec.IncDaughter,0); 
  end;
  if (column==19) then begin// To Budget 2 this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,pyed,RepSpec.basecurncy,RepSpec.IncDaughter,0);  
  end;
  RETURN;
END;

procedure SetPLColBal(record RcVc RepSpec,Integer column,string accstr,string objs,record ObjBalVc ObjBalr,var val valp,Integer DCSide,Date AccumStartDate,
                      Date budsd,Date buded)
BEGIN
  Date pysd,pyed;
  val dSb,cSb,dPb,cPb;
  val temp,temp2;
  val t;
  
  if (column==1) then begin// Accumulated 
    GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
    AddupRU(DCSide,temp,valp,dSb,dPb,cSb,cPb);
  end;
  if (column==2) then begin// End Balance  
    GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dSb,cSb);
    GetAccDCTurnover(accstr,objs,AccumStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
    AddupRU(DCSide,temp,temp2,dSb,dPb,cSb,cPb);
    valp = temp + temp2;// Don't know if it is correct 
  end;
  if (column==3) then begin// Previous Year 
    pysd = AddYear(RepSpec.sStartDate,-1);
    pyed = AddYear(RepSpec.sEndDate,-1);
    if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
      if (IsLeapYear(GetYear(pyed))) then begin
        pyed = AddDay(pyed,-GetDay(pyed) + 29);
      end;
    end;              
    t = BlankVal;    
    GetAccTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,valp);
  end;
  if (column==4) then begin// To Budget 1  
    valp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  if (column==5) then begin// To Budget 2  
    valp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  if (column==6) then begin// Previous Year Result
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);
    pysd = AddYear(pysd,-1);
    pyed = AddYear(RepSpec.sEndDate,-1);
    if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
      if (IsLeapYear(GetYear(pyed))) then begin
        pyed = AddDay(pyed,-GetDay(pyed) + 29);
      end;
    end;              
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dSb,cSb);
    AddupRU(DCSide,valp,temp,dSb,dPb,cSb,cPb);
  end;
  if ((column==10) or (column==11) or (column==12) or (column==13)) then begin
  end;
  if (column==15) then begin // Accumulated YTD 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    pyed = RepSpec.sEndDate;
    GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
    AddupRU(DCSide,temp,valp,dSb,dPb,cSb,cPb);
  end;
  if (column==16) then begin // To Budget 1 YTD
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  if (column==17) then begin // To Budget 2 YTD
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  if (column==18) then begin// To Budget 1 this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,pyed,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  if (column==19) then begin// To Budget 2 this year 
    FindFiscalYear(RepSpec.sStartDate,pysd,pyed);  
    valp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,pysd,pyed,RepSpec.basecurncy,RepSpec.IncDaughter,0);
  end;
  return;
end;

global
function Boolean AccRuPerBal(record RcVc RepSpec,Boolean PLf,string accstr,string objs,var val Sbp,var val Pbp,var val Ebp,
                      var val S4bp,var val S5bp,var val S6bp,Integer DCSide,Boolean resUseAccum,Date AccumStartDate,
                      Date budsd,Date buded)
BEGIN
  record ObjBalVc ObjBalr;
  Boolean Objbals;
  Date pysd,pyed;
  val dSb,cSb,dPb,cPb;
  val t;
  Boolean skipf;
  Boolean res;
  val oS3b1,oPb1,oEb1,oS4b1,oS5b1,oS6b1;
  string 255 theobj;
  record AccVc Accr;
  LongInt diff;
  Integer mode;
  record ObjVc Objr;
  Boolean found;
  val v1,v2;

  Sbp = 0;
  S4bp = 0;
  S5bp = 0;
  S6bp = 0;
  Pbp = 0;
  Ebp = 0;
  ObjBalr.AccNumber = accstr;
  ObjBalr.Object = objs;
  Objbals = ReadFirstMain(ObjBalr,2,true);  
  if (Objbals==false) then begin
    if (RepSpec.IncDaughter==0) then begin
      if (CountObjects(objs)<=1) then begin
        skipf = true;        
      end;
    end;    
  end;
  if (PLf==false) then begin
    if ((RepSpec.Comparison==0) or (RepSpec.Comparison==4) or (RepSpec.Comparison==5)) then begin
      if (skipf==false) then begin      
        GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
        GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
      end;
      switch (RepSpec.AccSpec) begin
        case 1:
          if ((dPb-cPb)!=0) then begin
            res = true;
          end;
/*
          if ((dPb!=0) or (cPb!=0)) then begin
            res = true;
          end;

*/          
        case 4:
          Accr.AccNumber = accstr;
          if (ReadFIrstMain(Accr,1,true)) then begin end;
          if (Accr.blockedFlag!=0) then begin
            if (((dSb-cSb)!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end else begin
            if ((dSb!=0) or (cSb!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end;
      end;
/*      
      if (RepSpec.AccSpec==1) then begin
        if ((dSb!=0) or (cSb!=0) or (dPb!=0) or (cPb!=0)) then begin
          res = true;
        end;
      end;  
*/        
      AddupRU(DCSide,Sbp,Pbp,dSb,dPb,cSb,cPb);
      Ebp = Sbp + Pbp;
    end;
    if (RepSpec.Comparison==2) then begin
      switch (RepSpec.AccSpec) begin
        case 4:
          if (skipf==false) then begin
            GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
            Sbp = dSb - cSb;
            GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                             RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
            Pbp = dPb - cPb + Sbp;
          end;
          Accr.AccNumber = accstr;
          if (ReadFIrstMain(Accr,1,true)) then begin end;
          if (Accr.blockedFlag!=0) then begin
            if (((dSb-cSb)!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end else begin
            if ((dSb!=0) or (cSb!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end;
        otherwise
          if (skipf==false) then begin
            GetAccStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,Sbp);
            GetAccBalance(accstr,objs,RepSpec.sEndDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,0,RepSpec.CurncyCode,RepSpec.IncDaughter,Pbp);
          end;
      end;
      
      Ebp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
//      Ebp = Ebp + Sbp; //Why should we add Fwd Balance to Budget???
    end;
    if (RepSpec.Comparison==3) then begin
      switch (RepSpec.AccSpec) begin
        case 4:
          if (skipf==false) then begin
    //same as other comparison
            GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,dSb,cSb);
            Sbp = dSb - cSb;
            GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                             RepSpec.IncDaughter,dSb,cSb,dPb,cPb);
            Pbp = dPb - cPb + Sbp;
          end;
          Accr.AccNumber = accstr;
          if (ReadFIrstMain(Accr,1,true)) then begin end;
          if (Accr.blockedFlag!=0) then begin
            if (((dSb-cSb)!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end else begin
            if ((dSb!=0) or (cSb!=0) or (dPb!=0) or (cPb!=0)) then begin
              res = true;
            end;
          end;
        otherwise
          if (skipf==false) then begin
            GetAccStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,RepSpec.IncDaughter,Sbp);
            GetAccBalance(accstr,objs,RepSpec.sEndDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,0,RepSpec.CurncyCode,RepSpec.IncDaughter,Pbp);
          end;
      end;
      
      Ebp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
//      Ebp = Ebp + Sbp; //Why should we add Fwd Balance to Budget???
    end;
    if (RepSpec.Comparison==-1) then begin
      if (RepSpec.flags[11]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[11],accstr,objs,ObjBalr,Sbp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[12]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[12],accstr,objs,ObjBalr,Pbp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[13]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[13],accstr,objs,ObjBalr,Ebp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[14]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[14],accstr,objs,ObjBalr,S4bp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[15]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[15],accstr,objs,ObjBalr,S5bp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[16]==4) or (skipf==false) then begin
        SetPLColBal(RepSpec,RepSpec.flags[16],accstr,objs,ObjBalr,S6bp,DCSide,AccumStartDate,budsd,buded);
      end;
      SetPLSumups(RepSpec.flags[13],Sbp,Pbp,Ebp);
      SetPLSumups(RepSpec.flags[16],S4bp,S5bp,S6bp);
    end;
  end else begin
//StopAlert("S3b1 " & S3b1 & " Pb1 " & Pb1 & " Eb1 " & Eb1 & " S4b1 " & S4b1 & " S5b1 " & S5b1 & " S6b1 " & S6b1);        
    if (RepSpec.Comparison==0) then begin
      if (skipf==false) then begin      
        if (nonblank(RepSpec.ObjType)) then begin
          Objr.OTCode = RepSpec.ObjType;
          Objr.Code = objs;
          found = true;
          while (LoopKey("OTCode",Objr,2,found)) begin
            if (Objr.OTCode!=RepSpec.ObjType) then begin 
              found = false;
            end;
            if (nonblank(objs)) then begin
              if (Objr.Code!=objs) then begin 
                found = false;
              end;
            end;
            if (found) then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = Objr.Code;
              Objbals = ReadFirstMain(ObjBalr,2,true);  

              if (resUseAccum==true) then begin
                GetAccDCTurnover(accstr,Objr.Code,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);                           
                dSb = dSb + v1;                
                cSb = cSb + v2;                
                GetAccDCTurnover(accstr,Objr.Code,AccumStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);
                dPb = dPb + v1;
                cPb = cPb + v2;
              end else begin        
                GetAccDCTurnover(accstr,Objr.Code,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);
                                 
                dPb = dPb + v1;
                cPb = cPb + v2;
              end;
            end;
          end;
          if (blank(objs)) then begin
            if (RepSpec.flags[2]!=0) and true then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = "";
              Objbals = ReadFirstMain(ObjBalr,2,true);  
              if (resUseAccum==true) then begin
                GetAccDCTurnover(accstr,"",RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);                           
                dSb = dSb + (v1 - dSb);
                cSb = cSb + (v2 - cSb);
                GetAccDCTurnover(accstr,"",AccumStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);
                dPb = dPb + (v1 - dPb);
                cPb = cPb + (v2 - cPb);
              end else begin        
                GetAccDCTurnover(accstr,"",RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                                 RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,v1,v2);
                dPb = dPb + (v1 - dPb);
                cPb = cPb + (v2 - cPb);
              end;
            end;
          end;
          if (resUseAccum==true) then begin
          end else begin
            dSb = dPb;
            cSb = cPb;          
          end;
        end else begin              
          if (resUseAccum==true) then begin
            GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                             RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,dSb,cSb);                           
            GetAccDCTurnover(accstr,objs,AccumStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                             RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
          end else begin        
            GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,
                             RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
            dSb = dPb;
            cSb = cPb;
/*
          ObjBalr.AccNumber = accstr;
          ObjBalr.Object = "";
          Objbals = ReadFirstMain(ObjBalr,2,true);  
*/
          end;
        end;
        if (RepSpec.AccSpec==1) then begin
          if ((dSb!=0) or (cSb!=0) or (dPb!=0) or (cPb!=0)) then begin
            res = true;
          end;  
        end;  
        AddupRU(DCSide,Sbp,Pbp,dSb,dPb,cSb,cPb);
      end;
    end;
    if (RepSpec.Comparison==1) then begin
      if (skipf==false) then begin
        pysd = AddYear(RepSpec.sStartDate,-1);
        pyed = RepSpec.sEndDate;
        pyed = AddYear(RepSpec.sEndDate,-1);
        if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
          if (IsLeapYear(GetYear(pyed))) then begin
            pyed = AddDay(pyed,-GetDay(pyed) + 29);
          end;
        end;
        if (nonblank(RepSpec.ObjType)) then begin
          Objr.OTCode = RepSpec.ObjType;
          if (nonblank(objs)) then begin
            Objr.Code = objs;
          end;
          found = true;
          while (LoopKey("OTCode",Objr,2,found)) begin
            if (Objr.OTCode!=RepSpec.ObjType) then begin 
              found = false;
            end;
            if (nonblank(objs)) then begin
              if (Objr.Code!=objs) then begin 
                found = false;
              end;
            end;
            if (found) then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = Objr.Code;
              Objbals = ReadFirstMain(ObjBalr,2,true);  
              t = BlankVal;
              GetAccTurnover(accstr,Objr.Code,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v1);
              Sbp = Sbp + v1;
              t = blankval;
              GetAccTurnover(accstr,Objr.Code,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v2);
              Pbp = Pbp + v2;
            end;
          end;
          if (blank(objs)) then begin
            if (RepSpec.flags[2]!=0) and true then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = "";
              Objbals = ReadFirstMain(ObjBalr,2,true);  
              t = BlankVal;
              GetAccTurnover(accstr,"",pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v1);
              Sbp = Sbp + (v1 - Sbp);
              t = blankval;
              GetAccTurnover(accstr,"",RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v2);
              Pbp = Pbp + (v2 - Pbp);
            end;
          end;
        end else begin        
          t = BlankVal;
          GetAccTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,Sbp);
          t = blankval;
          GetAccTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,Pbp);
        end;
      end;
    end;
    if (RepSpec.Comparison==2) then begin
      if (nonblank(RepSpec.ObjType)) then begin
        Objr.OTCode = RepSpec.ObjType;
        if (nonblank(objs)) then begin
          Objr.Code = objs;
        end;
        found = true;
        while (LoopKey("OTCode",Objr,2,found)) begin
          if (Objr.OTCode!=RepSpec.ObjType) then begin 
            found = false;
          end;
          if (nonblank(objs)) then begin
            if (Objr.Code!=objs) then begin 
              found = false;
            end;
          end;
          if (found) then begin
            Sbp = Sbp + Budg1Calc2(accstr,Objr.Code,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
            if (skipf==false) then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = Objr.Code;
              Objbals = ReadFirstMain(ObjBalr,2,true);  
              t = BlankVal;
              GetAccTurnover(accstr,Objr.Code,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v2);
              Pbp = Pbp + v2;
            end;
          end;
        end;
      end else begin
        Sbp = Budg1Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
        if (skipf==false) then begin
          t = BlankVal;
          GetAccTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,Pbp);
        end;
      end;
    end;
    if (RepSpec.Comparison==3) then begin
      if (nonblank(RepSpec.ObjType)) then begin
        Objr.OTCode = RepSpec.ObjType;
        if (nonblank(objs)) then begin
          Objr.Code = objs;
        end;
        found = true;
        while (LoopKey("OTCode",Objr,2,found)) begin
          if (Objr.OTCode!=RepSpec.ObjType) then begin 
            found = false;
          end;
          if (nonblank(objs)) then begin
            if (Objr.Code!=objs) then begin 
              found = false;
            end;
          end;
          if (found) then begin
            Sbp = Sbp + Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
            if (skipf==false) then begin
              ObjBalr.AccNumber = accstr;
              ObjBalr.Object = Objr.Code;
              Objbals = ReadFirstMain(ObjBalr,2,true);  
              t = BlankVal;
              GetAccTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,v2);
              Pbp = Pbp + v2;
            end;
          end;
        end;
      end else begin
        Sbp = Budg2Calc2(accstr,objs,RepSpec.CurncyCode,RepSpec.FirstAcc,budsd,buded,RepSpec.basecurncy,RepSpec.IncDaughter,0);
        if (skipf==false) then begin
          t = BlankVal;
          GetAccTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.IncDaughter,t,Pbp);
        end;
      end;
    end;
    if (RepSpec.Comparison==4) then begin
      if (skipf==false) then begin
// OK, and this was agreed with someone else I assume?
/*      
Krister says we have that already when comapring preious year 
        pysd = AddYear(RepSpec.sStartDate,-1);
        pyed = AddYear(RepSpec.sEndDate,-1);
        if ((GetMonth(pyed)==2) and (GetDay(pyed)==28)) then begin
          if (IsLeapYear(GetYear(pyed))) then begin
            pyed = AddDay(pyed,-GetDay(pyed) + 29);
          end;
        end;                  
*/  
        mode = 0;
        if (GetDay(RepSpec.sStartDate)==1) then begin
          if (GetDay(RepSpec.sEndDate)==DaysInMonth(GetYear(RepSpec.sEndDate),GetMonth(RepSpec.sEndDate))) then begin
            mode = 1;
          end;
        end;
        switch (mode) begin
          case 0:
            pyed = AddDay(RepSpec.sStartDate,-1);
            diff = DateDiff(RepSpec.sEndDate,RepSpec.sStartDate);
            pysd = AddDay(pyed,-diff);
          case 1:
            pyed = AddDay(RepSpec.sStartDate,-1);
            pyed.day = DaysInMonth(GetYear(pyed),GetMonth(pyed));
            diff = DateGetIntMonth(RepSpec.sEndDate) - DateGetIntMonth(RepSpec.sStartDate);
            pysd = AddMonth(pyed,-diff);
            pysd.day = 1;
        end;

        GetAccDCTurnover(accstr,objs,pysd,pyed,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dSb,cSb);
        GetAccDCTurnover(accstr,objs,RepSpec.sStartDate,RepSpec.sEndDate,ObjBalr,RepSpec.CurncyCode,RepSpec.SimVerf,RepSpec.basecurncy,
                         RepSpec.IncDaughter,blankval,blankval,dPb,cPb);
        AddupRU(DCSide,Sbp,Pbp,dSb,dPb,cSb,cPb);
      end;
    end;
    if (RepSpec.Comparison==-1) then begin
      if (RepSpec.flags[11]==4) or (true) then begin//even if obj bal is not there Budget can be
        SetPLColBal(RepSpec,RepSpec.flags[11],accstr,objs,ObjBalr,Sbp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[12]==4) or (true) then begin
        SetPLColBal(RepSpec,RepSpec.flags[12],accstr,objs,ObjBalr,Pbp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[13]==4) or (true) then begin
        SetPLColBal(RepSpec,RepSpec.flags[13],accstr,objs,ObjBalr,Ebp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[14]==4) or (true) then begin
        SetPLColBal(RepSpec,RepSpec.flags[14],accstr,objs,ObjBalr,S4bp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[15]==4) or (true) then begin
        SetPLColBal(RepSpec,RepSpec.flags[15],accstr,objs,ObjBalr,S5bp,DCSide,AccumStartDate,budsd,buded);
      end;
      if (RepSpec.flags[16]==4) or (true) then begin
        SetPLColBal(RepSpec,RepSpec.flags[16],accstr,objs,ObjBalr,S6bp,DCSide,AccumStartDate,budsd,buded);
      end;
      SetPLSumups(RepSpec.flags[13],Sbp,Pbp,Ebp);
      SetPLSumups(RepSpec.flags[16],S4bp,S5bp,S6bp);
    end;
  end;
  if ((nonblank(RepSpec.f6)) and (SetInSet(RepSpec.f6,objs)==false)) then begin //and (blank(objs))) then begin
    theobj = RepSpec.f6;
    if (nonblank(objs)) then begin
      theobj = theobj & "," & objs;
    end;
    if (AccRuPerBal(RepSpec,PLf,accstr,theobj,oS3b1,oPb1,oEb1,oS4b1,oS5b1,oS6b1,DCSide,resUseAccum,AccumStartDate,budsd,buded)) then begin
    end;
/*
    Sbp = Sbp + oS3b1;
    Pbp = Pbp + oPb1;
    Ebp = Ebp + oEb1;
    S4bp = S4bp + oS4b1;
    S5bp = S5bp + oS5b1;
    S6bp = S6bp + oS6b1;
*/
    Sbp = Sbp - oS3b1;
    Pbp = Pbp - oPb1;
    Ebp = Ebp - oEb1;
    S4bp = S4bp - oS4b1;
    S5bp = S5bp - oS5b1;
    S6bp = S6bp - oS6b1;
  end;
  AccRuPerBal = res;
  RETURN;
END;

global
function Boolean AccObjTypePerBal(record RcVc RepSpec,Boolean PLf,string accstr,string objs,var val Sbp,var val Pbp,var val Ebp,
                                  var val S4bp,var val S5bp,var val S6bp,Integer DCSide,Boolean resUseAccum,Date AccumStartDate,
                                  Date budsd,Date buded)
BEGIN
  Boolean res;
  record ObjVc Objr;
  record ObjBalVc ObjBalr;
  Boolean TrHs,Objbals;
  val lSbp,lPbp,lEbp,lS4bp,lS5bp,lS6bp;

  Objr.OTCode = RepSpec.ObjType;
  TrHs = true;
  while (LoopKey("OTCode",Objr,1,TrHs)) begin
    if (Objr.OTCode!=RepSpec.ObjType) then begin 
      TrHs = false;
    end;
    if (TrHs) then begin
      if ((blank(objs)) or (Objr.Code==objs)) then begin
        ObjBalr.AccNumber = accstr;
        ObjBalr.Object = Objr.Code;
        Objbals = GetObjBal(accstr,Objr.Code,ObjBalr);
        if (Objbals) then begin
          res = AccRuPerBal(RepSpec,PLf,accstr,Objr.Code,lSbp,lPbp,lEbp,lS4bp,lS5bp,lS6bp,DCSide,resUseAccum,AccumStartDate,budsd,buded);
          Sbp = Sbp + lSbp;
          Pbp = Pbp + lPbp;
          Ebp = Ebp + lEbp;
          S4bp = S4bp + lS4bp;
          S5bp = S5bp + lS5bp;
          S6bp = S6bp + lS6bp;
        end;
      end;
    end;
  end;  
  AccObjTypePerBal = res;
  RETURN;
END;

global
procedure AGrHeader(record RcVc RepSpec,Boolean PLf,Boolean resUseAccum,Date AccumStartDate)
BEGIN
  string 255 tstr;
  Integer rw,oldAccSpec;
  record BaseCurBlock BC;
  
  BlockLoad(BC);
  
  rw = 1;  
  if (PLf==false) then begin
    HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
    LstRegDat(tstr);
    Header(rw,tstr,0);  
    
    if (blank(RepSpec.CurncyCode)) then begin
      tstr = USetStr(2513);
      if (RepSpec.basecurncy==0) then begin
        tstr = tstr & BC.BaseCur1;
      end;
      if (RepSpec.basecurncy==1) then begin
        tstr = tstr & " " & BC.BaseCur2;
      end;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    
    if (nonblank(RepSpec.ObjStr)) then begin
      HTObj(RepSpec.ObjStr,tstr);
      if ((blank(tstr)) and (nonblank(RepSpec.ObjStr))) then begin
        tstr = USetStr(5062) & ": " & RepSpec.ObjStr;
      end;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;    
    
    if (nonblank(RepSpec.ObjType)) then begin
      HTOT(RepSpec.ObjType,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;

    if (RepSpec.SimVerf==1) then begin
      tstr = USetStr(3019);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;

    if (ProgramType!=4) then begin
      HTNot(RepSpec.Notation,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
      HTComp(RepSpec.Comparison,true,RepSpec.flags[1],tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;  
    HTAccount(RepSpec.AccSpec,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
    if (RepSpec.flags[2]==1) then begin
      tstr = USetStr(6653);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (RepSpec.flags[4]==1) then begin
      tstr = USetStr(6652);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (DatePrel(RepSpec.sEndDate)) begin
      tstr = USetStr(3023);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (RepSpec.IncDaughter!=0) begin
      tstr = USetStr(3027);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.CurncyCode)) then begin
      tstr = USetStr(7672) & ": ";
      tstr = tstr & RepSpec.CurncyCode;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end else begin
    HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
    LstRegDat(tstr);
    Header(rw,tstr,0);
    
    if (resUseAccum) then begin
      HTAccPer(AccumStartDate,RepSpec.sEndDate,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.ObjStr)) then begin
      HTObj(RepSpec.ObjStr,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.ObjType)) then begin
      HTOT(RepSpec.ObjType,tstr);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (RepSpec.SimVerf==1) then begin
      tstr = USetStr(3019);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    HTNot(RepSpec.Notation,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
    HTComp(RepSpec.Comparison,false,RepSpec.flags[1],tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
    
    oldAccSpec = RepSpec.AccSpec;
    //wierd code for geting header correct
    if (RepSpec.AccSpec==1) then begin
      RepSpec.AccSpec = 4;
    end else begin
      if (RepSpec.AccSpec==4) then begin
        RepSpec.AccSpec = 1;
      end;
    end;
    HTAccount(RepSpec.AccSpec,tstr);
    
    RepSpec.AccSpec = oldAccSpec;    
    Header(rw,tstr,1);
    rw = rw + 1;
    
    if (RepSpec.flags[2]==1) then begin
      tstr = USetStr(6653);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (RepSpec.flags[4]==1) then begin
      tstr = USetStr(6652);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (DatePrel(RepSpec.sEndDate)) begin
      tstr = USetStr(3023);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (RepSpec.IncDaughter!=0) then begin
      tstr = USetStr(3027);
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.CurncyCode)) then begin
      tstr = USetStr(7672) & ": ";
      tstr = tstr & RepSpec.CurncyCode;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
    if (nonblank(RepSpec.f6)) then begin
      tstr = USetStr(1318) & " " & RepSpec.f6;
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;
  RETURN;
END;

global
function Boolean GetNextSep(string aost,var Integer np,var string anitem)
BEGIN
  Boolean TrHs,res;
  string 255 ost;
  string 255 nitem;
  string 1 nc;

  ost = aost;
  nitem = "";
  TrHs = true;
  while (TrHs) begin 
    if (np>len(ost)) then begin TrHs = false; end;   
    if (TrHs) then begin
      nc = Mid(ost,np,1);
      if ((nc>=chr(48)) and (nc<=chr(57))) then begin
        TrHs = false;
      end;
      if (TrHs) then begin
        nitem = nitem & nc;
        np = np + 1;    
      end;      
    end;  
  end;  
  if (blank(nitem)) then begin
    res = false;
  end else begin
    res = true;
  end; 
  anitem = nitem;  
  GetNextSep = res; 
  RETURN;  
END;

global
function Boolean GetNextItem(string aost,var Integer np,var string anitem)
BEGIN
  string 255 ost;
  string 255 nitem;
  string 1 nc;
  Boolean res,TrHs;
  
  ost = aost;
  nitem = "";
  
  TrHs = true;
  while (TrHs) begin
    if (np>len(ost)) then begin TrHs = false; end;
    if (TrHs) then begin
      nc = Mid(ost,np,1);
      if ((nc<chr(48)) or (nc>chr(57))) then begin
        TrHs = false;
      end;
      if (TrHs) then begin
        nitem = nitem & nc;
        np = np + 1;    
      end;
    end;
  end;  
  if nonblank(nitem) then begin
    res = true;
  end else begin
    res = false;
  end;
  anitem = nitem;
  GetNextItem = res;
  RETURN;
END;

global
function Boolean GetNextItem2(string aost,var Integer np,var string anitem)
BEGIN
  string 255 ost;
  string 255 nitem;
  string 1 nc;
  Boolean res,TrHs;
  
  ost = aost;
  nitem = "";
  
  TrHs = true;
  while (TrHs) begin
    if (np>len(ost)) then begin TrHs = false; end;
    if (TrHs) then begin
      nc = Mid(ost,np,1);
      TrHs = false;
      if ((asc(nc)>=asc("0")) and (asc(nc)<=asc("9"))) then begin
        TrHs = true;
      end;  
      if ((asc(nc)>=asc("a")) and (asc(nc)<=asc("z"))) then begin
        TrHs = true;
      end;
      if ((asc(nc)>=asc("A")) and (asc(nc)<=asc("Z"))) then begin
        TrHs = true;
      end;      
      if (nc=="_") or (nc=="/") or (nc=="-") then begin
        TrHs = true;
      end;      
      if (TrHs) then begin
        nitem = nitem & nc;
        np = np + 1;    
      end;
    end;
  end;    
  if nonblank(nitem) then begin
    res = true;
  end else begin
    res = false;
  end;
  anitem = nitem;
  GetNextItem2 = res;
  RETURN;
END;

global
procedure AGrSumLine2(record RcVc RepSpec,Integer c1,string t1,string t2,string extracode,
                     val Sp1,val Sp2,val Sp3,val Sp4,val Sp5,val Sp6,
                     Boolean negf,val goms,Boolean PLf,Boolean resUseAccum,string dblstr,LongInt agrid,
                     Boolean usedf,Boolean printf,Boolean comparef)
BEGIN
  val v,cppr;
  val s1,s2,s3,s4,s5,s6;
  val os1,os2,os3,os4,os5,os6;
  string 5 tstr;
  Integer ValForm;
  Boolean prntdf,skipf;

  if (printf==false) then begin
    goto LAGrSumLine;
  end;
  skipf = true;
  if (usedf) then begin
    skipf = false;
  end;
  switch (RepSpec.AccSpec) begin
    case 4:
//      if (Sp3!=0) then begin
      if (PLf) then begin
        if (Sp1!=0) then begin
          skipf = false;
        end;
      end else begin
        if (Sp2!=0) then begin
          skipf = false;
        end;
      end;
    case 1:
// If you comment this line in and next one out, it means all accounts that once had a saldo but no longer has, will be printed. Not so nice.
// If an account has nothing in start balance, 100 in and 100 out during period (zero) and zero in ending balance, it won't print either
// But commenting this line in is not the solution to that problem. It has to be tested someplace else.
//      if ((nonblank(Sp1)) or (nonblank(Sp2)) or (nonblank(Sp3)) or (nonblank(Sp4)) or (nonblank(Sp5)) or (nonblank(Sp6))) then begin
      if ((Sp1!=0) or (Sp2!=0) or (Sp3!=0) or (Sp4!=0) or (Sp5!=0) or (Sp6!=0)) then begin
        skipf = false;
      end;
    otherwise
      skipf = false;
  end;
  if (skipf) then begin
    goto LAGrSumLine;
  end;
  ValForm = M4Val;
  if (RepSpec.Notation==0) then begin
    ValForm = M4Val;
  end;  
  if (RepSpec.Notation==1) then begin
    ValForm = M4TVal;
  end;  
  if (RepSpec.Notation==2) then begin
    ValForm = M4MVal;
  end;  
  if (RepSpec.Notation==3) then begin
    ValForm = M4Val;
  end;  
  if (RepSpec.Notation==4) then begin
    ValForm = M40Val;
  end;  
  s1 = Sp1;
  s2 = Sp2;
  s3 = Sp3;
  s4 = Sp4;
  s5 = Sp5;
  s6 = Sp6;
  if (negf) then begin
    s1 = -s1;
    s2 = -s2;
    s3 = -s3;
    s4 = -s4;
    s5 = -s5;
    s6 = -s6;
  end;
  if (RepSpec.flags[19]!=0) then begin
    if (blank(s1)) then begin s1 = 0; end;
    if (blank(s2)) then begin s2 = 0; end;
    if (blank(s3)) then begin s3 = 0; end;
    if (blank(s4)) then begin s4 = 0; end;
    if (blank(s5)) then begin s5 = 0; end;
    if (blank(s6)) then begin s6 = 0; end;
  end;
  StartFormat(15);
  if ((RepSpec.repname!="ConsResRn") and (RepSpec.repname!="ConsBalRn")) then begin
    if (nonblank(dblstr)) then begin
      if (Left(RepSpec.critname,7)=="ConsRes") then begin
        if ((Left(dblstr,10)=="DblResCons")) then begin
          OutStringID(c1,dblstr,t1,false,agrid);
        end else begin
          OutStringID(c1,"DblConsResRClass",t1,false,"" & RepSpec.shortname & ":" & agrid);
        end;
        prntdf = true;
      end;
      if (RepSpec.critname=="ConsBalRClass") then begin
        OutStringID(c1,"DblConsBalRClass",t1,false,"" & RepSpec.shortname & ":" & agrid);
        prntdf = true;
      end;
    end else begin
      if (RepSpec.Media!=mtFile and RepSpec.Media!=mtExcel) then begin
        OutString(c1,0,"",false);  
      end;
    end;
    if (prntdf==false) then begin
      OutStringID(c1,dblstr,t1,false,RepSpec.flags[29]);//29 id company ID    
    end;
  end else begin
    if (nonblank(dblstr)) then begin
      if (RepSpec.critname=="ConsResRClass") then begin
        OutString(c1,"DblNLSpec",t1,false);
        prntdf = true;
      end;
      if (RepSpec.critname=="ConsBalRClass") then begin
        OutString(c1,"DblNLSpec",t1,false);
        prntdf = true;
      end;
    end;
    if (prntdf==false) then begin
      OutStringID(c1,dblstr,t1,false,RepSpec.flags[29]);//29 id company ID
    end;
  end;
  if ((nonblank(t2)) or (RepSpec.Media==mtFile or RepSpec.Media==mtExcel)) then begin
    OutString(2,0,t2,false);
  end;  
  prntdf = false;
  if (PLf==false) then begin
    os1 = s1;
    os2 = s2;
    os3 = s3;
    os4 = s4;
    os5 = s5;
    os6 = s6;
    if ((RepSpec.Comparison==2) or (RepSpec.Comparison==3)) then begin
      prntdf = true;
      cppr = blankval;
      OutVal(3,0,s1,ValForm,true);
      OutVal(4,0,s2,ValForm,true);
      if (comparef) then begin
        if (RepSpec.flags[1]==1) then begin
          if (os3!=0) then begin
            v = os2 - os3;
            v = v/os3;
            cppr = v * 100;
          end;
          OutVal(5,0,cppr,M4Prcnt,true);
        end else begin
          OutVal(5,0,s3,ValForm,true);
        end;
      end;
    end;
    if (RepSpec.Comparison==4) then begin
      prntdf = true;
      tstr = "";
      OutString(3,0,tstr,true);
      OutVal(4,0,s3,ValForm,true);
      if (comparef) then begin
        OutVal(5,0,s1,ValForm,true);
      end;
    end;
    if (RepSpec.Comparison==5) then begin
      prntdf = true;
      OutString(3,0,extracode,true);
      OutVal(4,0,s1,ValForm,true);
      if (comparef) then begin
        OutVal(5,0,s3,ValForm,true);
      end;
    end;
    if (RepSpec.Comparison==-1) then begin// HAL Defined 
      prntdf = true;
      if (RepSpec.flags[20]>0) then begin
        OutVal(3,0,s1,ValForm,true);
      end;  
      if (RepSpec.flags[20]>1) then begin
        OutVal(4,0,s2,ValForm,true);
      end;  
      if (RepSpec.flags[20]>2) then begin
        OutVal(5,0,s3,ValForm,true);
      end;  
      if (RepSpec.flags[20]>3) then begin
        OutVal(7,0,s4,ValForm,true);
      end;  
      if (RepSpec.flags[20]>4) then begin
        OutVal(8,0,s5,ValForm,true);
      end;  
      if (RepSpec.flags[20]>5) then begin 
        OutVal(9,0,s6,ValForm,true);
      end;
    end;
    if (prntdf==false) then begin
      OutVal(3,0,s1,ValForm,true);
      OutVal(4,0,s2,ValForm,true);
      if (comparef) then begin
        OutVal(5,0,s3,ValForm,true);
      end;
    end;
  end;
  if (PLf==true) then begin
    os1 = s1;
    os2 = s2;
    os3 = s3;
    os4 = s4;
    os5 = s5;
    os6 = s6;
    if (RepSpec.Notation==3) then begin
      s1 = s1/goms;
      s2 = s2/goms;
      if (RepSpec.flags[13]!=11) then begin
        s3 = s3/goms;
      end;  
      s4 = s4/goms;
      s5 = s5/goms;
      if (RepSpec.flags[16]!=13) then begin
        s6 = s6/goms;
      end;  
    end;
    if ((s1==0) and (RepSpec.Comparison!=0)) then begin
      s1 = blankval;
    end;  
    if (RepSpec.Comparison==0) then begin
//      if (resUseAccum==true) then begin//I don't think this is needed here at all, in January number of columns is diffrent then in february why?
        OutVal(4,0,s1,ValForm,true);
//      end;  
      OutVal(5,0,s2,ValForm,true);
    end;
    if (RepSpec.Comparison==1) then begin
      cppr = blankval;
      if (true) then begin
        OutVal(3,0,s2,ValForm,true);
        OutVal(4,0,s1,ValForm,true);
      end else begin
        OutVal(3,0,s1,ValForm,true);
        OutVal(4,0,s2,ValForm,true);
      end;
      if (comparef) then begin
        switch (RepSpec.flags[1]) begin
          case 0:
            v = os2 - os1;
            OutVal(5,0,v,ValForm,true);
          case 1:
            if (os1!=0) then begin
              v = os2 - os1;
              v = v/os1;        
              cppr = v*100;        
            end;
            OutVal(5,0,cppr,M4Prcnt,true);
          case 2:
            v = os2 + os1;
            OutVal(5,0,v,ValForm,true);
        end;
      end;
    end;
    if (RepSpec.Comparison==4) then begin
      OutString(200,0,extracode,false); //I know, text rightaligned, but I didn't see any other way out 
      if (HasLocalization("FIN")) then begin
        OutVal(3,0,s2,ValForm,true);
        OutVal(4,0,s1,ValForm,true);
      end else begin
        OutVal(3,0,s1,ValForm,true);
        OutVal(4,0,s2,ValForm,true);
      end;
      if (comparef) then begin
        switch (RepSpec.flags[1]) begin
          case 0:
            v = s2 - s1;
            OutVal(5,0,v,ValForm,true);
          case 1:
            if (os1!=0) then begin
              v = s2 - s1;//-s1
              v = v/os1;        
              cppr = v * 100;
            end;
            OutVal(5,0,cppr,M4Prcnt,true);
          case 2:
            v = s2 + s1;
            OutVal(5,0,v,ValForm,true);
        end;
      end;
    end;
    if ((RepSpec.Comparison==2) or (RepSpec.Comparison==3)) then begin
      cppr = blankval;
      OutVal(3,0,s1,ValForm,true);
      OutVal(4,0,s2,ValForm,true);
      if (comparef) then begin
        switch (RepSpec.flags[1]) begin
          case 0:
            v = os2 - os1;
            OutVal(5,0,v,ValForm,true);
          case 1:
            if (os1!=0) then begin
              v = os2 - os1;//-os1
              v = v/os1;        
              cppr = v * 100;
            end;
            OutVal(5,0,cppr,M4Prcnt,true);
          case 2:
            v = os2 + os1;
            OutVal(5,0,v,ValForm,true);
        end;
      end;
    end;
    if (RepSpec.Comparison==-1) then begin// HAL Defined 
      if (RepSpec.flags[20]>0) then begin
        OutVal(3,0,s1,ValForm,true);
      end;  
      if (RepSpec.flags[20]>1) then begin
        OutVal(4,0,s2,ValForm,true);
      end;  
      if (RepSpec.flags[20]>2) then begin
//        OutVal(5,0,s3,M4Val,true);
        if (RepSpec.flags[1]==1) then begin
          if (s2!=0) then begin
            v = s1;
            v = v/s2;        
            cppr = v * 100;
          end;
          OutVal(5,0,cppr,M4Prcnt,true);
        end else begin
          OutVal(5,0,s2 - s1,ValForm,true);
        end;
      end;  
      if (RepSpec.flags[20]>3) then begin
        OutVal(7,0,s4,ValForm,true);
      end;  
      if (RepSpec.flags[20]>4) then begin
        OutVal(8,0,s5,ValForm,true);
      end;  
      if (RepSpec.flags[20]>5) then begin
//        OutVal(9,0,s6,M4Val,true);
        if (RepSpec.flags[1]==1) then begin
          if (s5!=0) then begin
            v = s4;
            v = v/s5;        
            cppr = v * 100;
          end;
          OutVal(9,0,cppr,M4Prcnt,true);
        end else begin
          OutVal(9,0,s4 - s5,ValForm,true);
        end;
      end;  
    end;
  end;
  EndFormat;
LAGrSumLine:;  
  RETURN;
END;

global
procedure AGrSumLine(record RcVc RepSpec,Integer c1,string t1,string t2,string extracode,
                    val Sp1,val Sp2,val Sp3,val Sp4,val Sp5,val Sp6,
                    Boolean negf,val goms,Boolean PLf,Boolean resUseAccum,string dblstr,LongInt agrid,
                    Boolean usedf,Boolean printf)
begin
  AGrSumLine2(RepSpec,c1,t1,t2,extracode,Sp1,Sp2,Sp3,Sp4,Sp5,Sp6,negf,goms,PLf,resUseAccum,dblstr,agrid,usedf,printf,true);
  return;
end;

global
procedure SumListPerBal(string accstr,Integer rid,var Array val S3ba,var Array val Pba,var Array val Eba,
                        var Array val S4ba,var Array val S5ba,var Array val S6ba,
                        Integer maxrsums,var Array LongInt aidp,Boolean zerof)
BEGIN
  string 255 nitem;
  string 5 nsep;
  LongInt idn;
  Integer np;
  Boolean sepd,addflag;
  Integer i,aid;

  if (zerof) then begin
    S3ba[rid] = 0;
    S4ba[rid] = 0;
    S5ba[rid] = 0;
    S6ba[rid] = 0;
    Pba[rid] = 0;
    Eba[rid] = 0;
  end;
  np = 0;
  sepd = GetNextSep(accstr,np,nsep);
  while (GetNextItem(accstr,np,nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    sepd = GetNextSep(accstr,np,nsep);
    idn = FirstInRange(nitem,10);
    aid = -1;
    for (i = 0; i<maxrsums; i=i+1) begin
      if (aidp[i]==idn) then begin
        aid = i;
      end;
    end;  
    if ((aid>=0) and (aid<maxrsums)) then begin
      if (addflag==true) then begin
        S3ba[rid] = S3ba[rid] + S3ba[aid];
        S4ba[rid] = S4ba[rid] + S4ba[aid];
        S5ba[rid] = S5ba[rid] + S5ba[aid];
        S6ba[rid] = S6ba[rid] + S6ba[aid];
        Pba[rid] = Pba[rid] + Pba[aid];
        Eba[rid] = Eba[rid] + Eba[aid];
      end else begin
        S3ba[rid] = S3ba[rid] - S3ba[aid];
        S4ba[rid] = S4ba[rid] - S4ba[aid];
        S5ba[rid] = S5ba[rid] - S5ba[aid];
        S6ba[rid] = S6ba[rid] - S6ba[aid];
        Pba[rid] = Pba[rid] - Pba[aid];
        Eba[rid] = Eba[rid] - Eba[aid];
      end;
    end;
  end;
  RETURN;    
END;

global
procedure GetNotStr(Integer n,var string notstr)
BEGIN
  notstr = "";
  if ((n==4) or (n==0)) then begin
  end;  
  if (n==1) then begin
    notstr = USetStr(3001);
  end;  
  if (n==2) then begin
    notstr = USetStr(3002);
  end;  
  if (n==3) then begin
    notstr = USetStr(3003);
  end;  
  RETURN;
END;

global
procedure Get2WholePeriods(record RcVc RepSpec,Date start1,Date end1,var string now,var string prev)
BEGIN
  record YearBlock YearRec;
  row YearBlock Yearrw;
  string 255 tstr;
  Integer i,rwcnt;
  Boolean wholeyear;
  Date start2,end2;
  
  BlockLoad(YearRec);
  rwcnt = MatRowCnt(YearRec);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(YearRec,i,Yearrw);
    if (DateInRange(RepSpec.sStartDate,Yearrw.StartDate,Yearrw.EndDate)) then begin
      if ((Yearrw.StartDate==start1) and (Yearrw.EndDate==end1)) then begin
        wholeyear = true;
      end;  
      goto L22;
    end;
  end;
L22:;
  start2 = start1;
  end2 = end1;
  if (wholeyear) then begin
    end2 = AddDay(start1,-1);
    for (i=0; i<rwcnt; i=i+1) begin
      MatRowGet(YearRec,i,Yearrw);
      if (DateInRange(end2,Yearrw.StartDate,Yearrw.EndDate)) then begin
        start2 = Yearrw.StartDate;
        end2 = Yearrw.EndDate;
        goto L33;
      end;
    end;
  end;
  start2 = AddYear(start2,-1);
  start2.month = 1; start2.day = 1;
  end2 = AddYear(end2,-1);
  end2.month = 12; end2.day = 31;
L33:;
// This can NOT be correct... This is assuming everyone has format DDMMYY..... 
//it does not asssume, it presents it in this format
  now = DateToString(start1,"DDMMYY") & ":" & DateToString(end1,"DDMMYY");
  prev = DateToString(start2,"DDMMYY") & ":" & DateToString(end2,"DDMMYY");
/*
  now = StripNonDigits(start1) & ":";
  tstr = StripNonDigits(end1);
  now = now & tstr;
  prev = StripNonDigits(start2) & ":";
  tstr = StripNonDigits(end2);
  prev = prev & tstr;
*/  
  
/*
  now = start1;
  now = now & ":";
  now = now & end1;
  prev = start2;
  prev = prev & ":";
  prev = prev & end2;
*/  
  RETURN;
END;

global
procedure GetPreviousPeriods(record RcVc RepSpec,Date start1,Date end1,var string now,var string prev)
begin
  Date start2,end2;  
  LongInt diff;
  Integer mode;
  record SysFormatBlock SFb;
  
  BlockLoad(SFb);
  mode = 0;
  if (start1.day==1) then begin
    if (end1.day==DaysInMonth(GetYear(end1),GetMonth(end1))) then begin
      mode = 1;
    end;
  end;
  switch (mode) begin
    case 0:
      end2 = AddDay(start1,-1);
      diff = DateDiff(end1,start1);
      start2 = AddDay(end2,-diff);
    case 1:
/*
      start2 = AddYear(start1,-1);
      end2 = AddYear(end1,-1);
*/
      end2 = AddDay(start1,-1);
      end2.day = DaysInMonth(GetYear(end2),GetMonth(end2));
      diff = DateGetIntMonth(end1) - DateGetIntMonth(start1);
      start2 = AddMonth(end2,-diff);
      start2.day = 1;
  end;

// Removed this on commit please. 
//   We only want the previous years range result.
//   start2 = start1;
//   start2 = AddYear(start1,-1);  
//   end2 = end1;
//   end2 = AddYear(end1,-1);
  switch (SFb.dateOrder) begin
    case 0:
      now = DateToString(start1,"MMDDYY") & ":" & DateToString(end1,"MMDDYY");
      prev = DateToString(start2,"MMDDYY") & ":" & DateToString(end2,"MMDDYY");  
    case 2:
      now = DateToString(start1,"YYMMDD") & ":" & DateToString(end1,"YYMMDD");
      prev = DateToString(start2,"YYMMDD") & ":" & DateToString(end2,"YYMMDD");  
    otherwise
      now = DateToString(start1,"DDMMYY") & ":" & DateToString(end1,"DDMMYY");
      prev = DateToString(start2,"DDMMYY") & ":" & DateToString(end2,"DDMMYY");  
  end;
  now = start1 & ":" & end1;
  prev = start2 & ":" & end2;
  return;
end;

global
procedure SumBalRnVectors(string accstr,LongInt idkey,Boolean zerof,
                          vector val S3ba,vector val Pba,vector val Eba,
                          vector val S4ba,vector val S5ba,vector val S6ba,
                          vector Boolean sumsv,
                          Array record UserDefRepLinesVc aUserDefRepLinesr,Integer udrlcnt)
begin
  string 255 nitem;
  string 5 nsep;
  Integer np;
  Boolean sepd,addflag;
  LongInt idn;

  if (zerof) then begin
    S3ba[idkey] = 0;
    S4ba[idkey] = 0;
    S5ba[idkey] = 0;
    S6ba[idkey] = 0;
    Pba[idkey] = 0;
    Eba[idkey] = 0;
  end;
  np = 0;
  sepd = GetNextSep(accstr,np,nsep);
  while (GetNextItem(accstr,np,nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    sepd = GetNextSep(accstr,np,nsep);
    idn = FirstInRange(nitem,10);
    if (idn>=0) then begin
      if (sumsv[idn]==false) then begin
//        if (idn!=StringToLongInt(nitem)) then begin
        if (idn!=idkey) then begin//? to stop never ending loop, but this data is not posible to enter any more
          CalcRsTypeSum(S3ba,Pba,Eba,S4ba,S5ba,S6ba,sumsv,aUserDefRepLinesr,udrlcnt,idn);
        end;
//        end;
//        sumsv[idn] = true; //no calculation here
      end;
      if (addflag==true) then begin
        S3ba[idkey] = S3ba[idkey] + S3ba[idn];
        S4ba[idkey] = S4ba[idkey] + S4ba[idn];
        S5ba[idkey] = S5ba[idkey] + S5ba[idn];
        S6ba[idkey] = S6ba[idkey] + S6ba[idn];
        Pba[idkey] = Pba[idkey] + Pba[idn];
        Eba[idkey] = Eba[idkey] + Eba[idn];
      end else begin
        S3ba[idkey] = S3ba[idkey] - S3ba[idn];
        S4ba[idkey] = S4ba[idkey] - S4ba[idn];
        S5ba[idkey] = S5ba[idkey] - S5ba[idn];
        S6ba[idkey] = S6ba[idkey] - S6ba[idn];
        Pba[idkey] = Pba[idkey] - Pba[idn];
        Eba[idkey] = Eba[idkey] - Eba[idn];
      end;
    end;
  end;
  return;    
end;
