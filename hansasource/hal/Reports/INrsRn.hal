external procedure PrintItemHist(record RcVc,record INVc,record ItemHistVc,record MainStockBlock,Boolean,val);
external procedure ItemHistItemHeader(record RcVc,string,string,string,val,val,val,var val,var Boolean);
external procedure ItemHistItemHeader_PerLocation(record RcVc,string,string,string,val,val,val,var Boolean);
external function roundmode SetRoundModeD(Integer);
external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);
external procedure ItemHistHeader(record RcVc);
external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);
external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer CostPricePerLocation(record INVc,record ITVc,record CostAccBlock);
external function Integer ItemCostPerLocation(record INVc);
external function val CalculateQty2(val,val);
external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);
external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);
external function val FindBPPriceBackdated(record CostAccBlock,record INVc,string,val,Date,Boolean);
external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);
external function Boolean SetInSet2(string,string);
external procedure ItemClassTypef(string,string,var Boolean);
external function val GetStockQty(string,string,Date,Boolean);
external procedure HT2Per(Date, Date , var string);
external procedure HTArtSel(string,string, var string);
external procedure HTDepartments(string,string,var string);
external procedure HTItemHistType(Integer,Integer,Integer,Integer,Integer,Integer,var string);
external procedure HTItemHistType2(Integer,Integer,Integer,Integer,Integer,var string);
external procedure PrintCustName(string,string,integer);

procedure PrintItemTotals_Overview(record RcVc RepSpec,record INVc INr,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout)
begin
  Boolean testf;
  
  testf = false;
  switch (RepSpec.ArtMode) begin
    case 0:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
    case 1:
      if ((itemcpin!=0) or (itemcpout!=0) or (fwdtotcp!=0)) then begin
        testf = true;
      end;
    case 3:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
  end;
  if (RepSpec.flags[13]==0) then begin
    if (fwdqty!=0) then begin
      testf = true;
    end;
  end;
  if (testf) then begin
  switch (RepSpec.Media) begin
    case mtFile:
      goto LPrintItemTotals_OverviewExcel;
    case mtExcel:
LPrintItemTotals_OverviewExcel:;
        StartFormat(15);
        OutString(0,0,INr.Code,false);
        OutString(70,0,INr.Name,false);
        OutString(70,0,"",false);
        switch (RepSpec.ArtMode) begin
          case 0:
            OutVal(240,0,fwdqty,M4Qty,true);
            OutVal(320,0,itemqin,M4Qty,true);
            OutVal(420,0,itemqout,M4Qty,true);
            OutVal(480,0,fwdqty+itemqin+itemqout,M4Qty,true);
          case 1:
            OutVal(240,0,fwdtotcp,M45Val,true); // fwdqty (shows same as fwdtotcp)? fwdcp (is blank)?
            OutVal(320,0,itemcpin,M45Val,true);
            OutVal(400,0,itemcpout,M45Val,true);
            OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true);
          case 3:
            OutVal(240,0,fwdqty,M4Qty,true);
            OutVal(320,0,itemqin,M4Qty,true);
            OutVal(420,0,itemqout,M4Qty,true);         
            OutVal(480,0,fwdqty+itemqin+itemqout,M4Qty,true);
        end;
        EndFormat;
    otherwise
        StartFormat(15);
        OutString(0,0,INr.Code,false);
        OutString(70,0,INr.Name,false);
        switch (RepSpec.ArtMode) begin
          case 0:
            OutValBiDi(240,0,fwdqty,M4Qty,true,280);
            OutValBiDi(320,0,itemqin,M4Qty,true,360);
            OutValBiDi(400,0,itemqout,M4Qty,true,440);
            OutValBiDi(480,0,fwdqty+itemqin+itemqout,M4Qty,true,520);
          case 1:
            OutValBiDi(240,0,fwdtotcp,M45Val,true,280); // fwdqty (shows same as fwdtotcp)? fwdcp (is blank)?
            OutValBiDi(320,0,itemcpin,M45Val,true,350);
            OutValBiDi(400,0,itemcpout,M45Val,true,440);
            OutValBiDi(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true,500);
          case 3:
            OutValBiDi(240,0,fwdqty,M4Qty,true,280);
            OutValBiDi(320,0,itemqin,M4Qty,true,360);
            OutValBiDi(400,0,itemqout,M4Qty,true,440);
            OutValBiDi(480,0,fwdqty+itemqin+itemqout,M4Qty,true,520);
        end;
        EndFormat;
    end;
  end;
  return;
end;

procedure PrintItemTotals_Overview_PerLocation(record RcVc RepSpec,record INVc INr,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout)
begin
  Boolean testf;
  
  testf = false;
  switch (RepSpec.ArtMode) begin
    case 0:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
        testf = true;
      end;
    case 1:
      if ((itemqin!=0) or (itemqout!=0) or (fwdqty!=0)) then begin
//      if ((itemcpin!=0) or (itemcpout!=0) or (fwdtotcp!=0)) then begin
        testf = true;
      end;
  end;
  if (RepSpec.flags[13]==0) then begin
    if (fwdqty!=0) then begin
      testf = true;
    end;
  end;
  if (testf) then begin
    switch (RepSpec.Media) begin
      case mtFile:
        goto LPrintItemTotals_Overview_PerLocationExcel;
      case mtExcel:
LPrintItemTotals_Overview_PerLocationExcel:;
        if (RepSpec.flags[9]==0) then begin
           StartFormat(15);
           switch (RepSpec.ArtMode) begin
             case 0:
               OutString(15,0,INr.Code,false);
               OutString(90,0,INr.Name,false);
               OutString(90,0,"",false);
               OutVal(240,0,fwdqty,M4UVal,true);
               OutVal(320,0,itemqin,M4UVal,true);
               OutVal(400,0,itemqout,M4UVal,true);
               OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
             case 1:
               OutString(15,0,INr.Code,false);
               OutString(90,0,INr.Name,false);
               OutString(90,0,"",false);
               OutVal(200,0,fwdqty,M4UVal,true);
               OutVal(240,0,fwdtotcp,M4Val,true);
               OutVal(280,0,itemqin,M4UVal,true);
               OutVal(320,0,itemcpin,M4Val,true);
               OutVal(360,0,itemqout,M4UVal,true);
               OutVal(400,0,itemcpout,M4Val,true);
               OutVal(440,0,fwdqty+itemqin+itemqout,M4Val,true);
               OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M4Val,true);
           end;
           EndFormat;
        end else begin
          Gray_Divider(0,1);
          StartFormat(15);
          switch (RepSpec.ArtMode) begin
            case 0:
              OutString(200,0,INr.Code,false);
              OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
            case 1:
              OutString(200,0,INr.Code,false);
              OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
              OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true);
          end;
          EndFormat;
          Gray_Divider(200,1);
        end;
      otherwise
        if (RepSpec.flags[9]==0) then begin
          StartFormat(15);
          switch (RepSpec.ArtMode) begin
            case 0:
              OutString(15,0,INr.Code,false);
              OutString(90,0,Left(INr.Name,10),false);
              OutVal(240,0,fwdqty,M4UVal,true);
              OutVal(320,0,itemqin,M4UVal,true);
              OutVal(400,0,itemqout,M4UVal,true);
              OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
            case 1:
              OutString(15,0,INr.Code,false);
              OutString(90,0,Left(INr.Name,20),false);
              OutVal(200,0,fwdqty,M4UVal,true);
              OutVal(240,0,fwdtotcp,M4Val,true);
              OutVal(280,0,itemqin,M4UVal,true);
              OutVal(320,0,itemcpin,M4Val,true);
              OutVal(360,0,itemqout,M4UVal,true);
              OutVal(400,0,itemcpout,M4Val,true);
              OutVal(440,0,fwdqty+itemqin+itemqout,M4Val,true);
              OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M4Val,true);
          end;
          EndFormat;
        end else begin
          Gray_Divider(0,1);
          StartFormat(15);
          switch (RepSpec.ArtMode) begin
            case 0:
              OutString(200,0,INr.Code,false);
              OutVal(480,0,fwdqty+itemqin+itemqout,M4UVal,true);
            case 1:
              OutString(200,0,INr.Code,false);
              OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
              OutVal(480,0,fwdtotcp+itemcpin-itemcpout,M45Val,true);
          end;
          EndFormat;
          Gray_Divider(200,1);
        end;
    end;
  end;
  return;
end;

procedure ItemHistLineToFile_Detailed(record RcVc RepSpec,record INVc INr,Boolean itemheaderf,
                             val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout,
                             val itemq2in,val bal)
begin
  StartFormat(15);
  OutString(0,0,INr.Code,false);
  OutString(100,0,INr.Name,false);
  OutString(300,0,INr.Unittext,false);
  OutString(300,0,"",false);
  OutString(100,0,USetStr(4993),false);
  OutString(300,0,"",false);
  OutString(300,0,"",false);
  switch (RepSpec.ArtMode) begin
    case 0:
      if (RepSpec.flags[12]!=0) then begin
        OutVal(375,0,itemq2in,M45Val,true);
      end else begin
        OutString(300,0,"",false);          
      end;
      OutVal(410,0,fwdqty+itemqin+itemqout,M4UVal,true);
      OutVal(480,0,bal,M45Val,true);
    case 1:
      if (RepSpec.flags[12]!=0) then begin
        OutVal(375,0,itemq2in,M45Val,true);
      end else begin
        OutString(300,0,"",false);                
      end;
      OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
      OutVal(480,0,Round(fwdtotcp+itemcpin-itemcpout,SetRoundModeD(2)),M4Val,true);
    case 3:
      if (RepSpec.flags[12]!=0) then begin
        OutVal(375,0,itemq2in,M45Val,true);
      end else begin
        OutString(300,0,"",false);                
      end;
      OutVal(300,0,fwdqty+itemqin+itemqout,M4UVal,true);
      OutVal(480,0,bal,M45Val,true);
  end;
  EndFormat;
  return;
end;

procedure PrintItemTotals_Detailed(record RcVc RepSpec,record INVc INr,Boolean itemheaderf,
                                   val fwdqty,val fwdcp,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout,
                                   val itemq2in,val bal)
begin
  if (itemheaderf==true) then begin
    switch (RepSpec.Media) begin
      case mtFile:
        ItemHistLineToFile_Detailed(RepSpec,INr,itemheaderf,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in,bal);
      case mtExcel:
        ItemHistLineToFile_Detailed(RepSpec,INr,itemheaderf,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in,bal);
      otherwise
        Gray_Divider(0,1);
        StartFormat(15);
        switch (RepSpec.ArtMode) begin
          case 0:
            if (RepSpec.flags[12]!=0) then begin
              OutValBiDi(375,0,itemq2in,M4Qty,true,420);
            end;
            OutValBiDi(410,0,fwdqty+itemqin+itemqout,M45Val,true,450);
            OutValBiDi(480,0,bal,M45Val,true,520);
          case 1:
            OutValBiDi(340,0,fwdqty+itemqin+itemqout,M45Val,true,350);
            if (RepSpec.flags[12]!=0) then begin
              OutValBiDi(375,0,itemq2in,M45Val,true,420);
            end;
            if (UserCanAction("ViewCostPrice",true)) then begin
              OutValBiDi(480,0,Round(fwdtotcp+itemcpin-itemcpout,SetRoundModeD(2)),M4Val,true,500);
            end;
          case 3:
            OutValBiDi(300,0,fwdqty+itemqin+itemqout,M45Val,true,340);
            if (RepSpec.flags[12]!=0) then begin
              OutValBiDi(375,0,itemq2in,M45Val,true,420);
            end;
            OutValBiDi(480,0,bal,M45Val,true,520);
        end;
        EndFormat;
        StartFormat(15);
        EndFormat;
    end;
  end;
  return;
end;

procedure PrintItemHist_PerLocation(record RcVc RepSpec,record INVc INr,record ItemHistVc IHr,record MainStockBlock MSb,Boolean outf,val bal)
begin
  Integer strid;
  string 50 dblstr;

  switch (IHr.FileName) begin
    case "IVVc": strid = 5004; dblstr = "DblIVVc";
    case "IVCashVc": strid = 11675; dblstr = "DblIVVc";
    case "INTransferVc": strid = 5040; dblstr = "DblINTransfer";
    case "ProdVc": strid = 5016; dblstr = "DblProd";
    case "ProdOperationVc": strid = 11674; dblstr = "DblProdOperationVc";
    case "PUVc": strid = 5002; dblstr = "DblPU";
    case "RetPUVc": strid = 5058; dblstr = "DblRetPU";
    case "RetVc": strid = 5029; dblstr = "DblRet";
    case "SDVc": strid = 5020; dblstr = "DblSD";
    case "SRVc": strid = 11676; dblstr = "DblSRVc";
    case "SHVc": strid = 5003; dblstr = "DblSHVc";
    case "StockMovVc": strid = 5012; dblstr = "DblStockMov";
    case "WSVc": strid = 7650; dblstr = "DblWS";
    case "Fut2ProdOrderInVc": begin
      record ProdOrderVc PrOr;

      PrOr.SerNr = IHr.TransNr;
      if (ReadFirstMain(PrOr,1,true)) then begin end;
      if (PrOr.StatusFlag<3) then begin 
        strid = 5057; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProdOrder";
      end;
    case "Fut2ProdInVc": begin
      record ProdVc Prodr;

      Prodr.SerNr = IHr.TransNr;
      if (ReadFirstMain(Prodr,1,true)) then begin end;
      if (Prodr.PRStatusFlag<3) then begin 
        strid = 5037; 
      end else begin
        strid = 5016; 
      end;
      dblstr = "DblProd";
      end;
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.OKFlag==0) then begin
          strid = 5036; 
        end else begin
          strid = 5038; 
        end;
        dblstr = "DblPOVc";
      end;
    case "Fut3ORVc": strid = 5035; dblstr = "DblORVc";
  end;

  switch (RepSpec.Media) begin
    case mtFile:
      goto LPrintItemHist_PerLocationExcel;
    case mtExcel:
LPrintItemHist_PerLocationExcel:;
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          OutString(0,0,INr.Code,false);
          OutString(100,0,INr.Name,false);
          OutString(300,0,INr.Unittext,false);
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);       
          OutLongInt(160,dblstr,IHr.TransNr,false);  
          if (RepSpec.flags[21]==1) then begin  
            PrintCustName(IHr.FileName,IHr.TransNr,210);    
          end;
          OutVal(480,0,IHr.Qty,M4UVal,true);
        case 1:
          OutString(0,0,INr.Code,false);
          OutString(100,0,INr.Name,false);
          OutString(300,0,INr.Unittext,false);
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);            
          OutLongInt(140,dblstr,IHr.TransNr,false);   
          if (RepSpec.flags[21]==1) then begin     
            PrintCustName(IHr.FileName,IHr.TransNr,200);  
          end;      
          OutVal(300,0,IHr.Qty,M4UVal,true);
          if (outf) then begin
            OutVal(400,0,-Round(bal/IHr.Qty,SetRoundModeD(5)),M45Val,true);
            OutVal(480,0,-bal,M4Val,true);
          end else begin
            OutVal(400,0,Round(IHr.TotCostPrice/IHr.Qty,SetRoundModeD(5)),M45Val,true);
            OutVal(480,0,IHr.TotCostPrice,M4Val,true);
          end;
        case 3://INRS
          OutString(0,0,INr.Code,false);
          OutString(100,0,INr.Name,false);
          OutString(300,0,INr.Unittext,false);
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);           
          OutLongInt(160,dblstr,IHr.TransNr,false);   
          if (RepSpec.flags[21]==1) then begin     
            PrintCustName(IHr.FileName,IHr.TransNr,210);                  
          end;
          OutString(310,0,Right(IHr.Variety,len(IHr.Variety)-1),false);      
          switch (RepSpec.flags[12]) begin
            case 1: OutVal(375,0,IHr.Qty2,M4UVal,true);
            case 2: 
              if (MSb.UnitConvCalc==0) then begin
                OutVal(375,0,IHr.Qty/IHr.Qty2,M4Qty,true);
              end else begin
                OutVal(375,0,IHr.Qty2/IHr.Qty,M4Qty,true);
              end;
          end;
          OutVal(410,0,IHr.Qty,M4UVal,true);
          OutVal(480,0,bal,M4UVal,true);
      end;   
      EndFormat;
    otherwise
      StartFormat(15);
      switch (RepSpec.ArtMode) begin
        case 0:
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);       
          OutLongInt(160,dblstr,IHr.TransNr,false);    
          if (RepSpec.flags[21]==1) then begin  
            PrintCustName(IHr.FileName,IHr.TransNr,210);        
          end;
          OutValBiDi(480,0,IHr.Qty,M4UVal,true,520);                
        case 1:
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);            
          OutLongInt(140,dblstr,IHr.TransNr,false);        
          if (RepSpec.flags[21]==1) then begin
            PrintCustName(IHr.FileName,IHr.TransNr,200);                  
          end;
          OutValBiDi(300,0,IHr.Qty,M4UVal,true,340);
          if (outf) then begin
            OutValBiDi(400,0,-Round(bal/IHr.Qty,SetRoundModeD(5)),M45Val,true,440);
            OutValBiDi(480,0,-bal,M4Val,true,520);
          end else begin
            OutValBiDi(400,0,Round(IHr.TotCostPrice/IHr.Qty,SetRoundModeD(5)),M45Val,true,440);
            OutValBiDi(480,0,IHr.TotCostPrice,M4Val,true,500);
          end;
        case 3://INRS
          OutDate(0,0,IHr.TransDate,false);
          OutString(60,0,USetStr(strid),false);           
          OutLongInt(160,dblstr,IHr.TransNr,false);        
          if (RepSpec.flags[21]==1) then begin
            PrintCustName(IHr.FileName,IHr.TransNr,210);                     
          end;
          OutString(300,0,Right(IHr.Variety,len(IHr.Variety)-1),false);
          switch (RepSpec.flags[12]) begin
            case 1: OutValBiDi(375,0,IHr.Qty2,M4UVal,true,420);
            case 2: 
              if (MSb.UnitConvCalc==0) then begin
                OutValBiDi(375,0,IHr.Qty/IHr.Qty2,M4Qty,true,420);
              end else begin
                OutValBiDi(375,0,IHr.Qty2/IHr.Qty,M4Qty,true,420);
              end;
          end;
          OutValBiDi(410,0,IHr.Qty,M4UVal,true,450);
          OutValBiDi(480,0,bal,M4UVal,true,520);
      end;   
      EndFormat;
  end;
  return;
end;

procedure PrintReportTotals(record RcVc RepSpec,val SumQFwd,val SumQIn,val SumQOut,val SumCPFwd,val SumCPIn,val SumCPOut,
                            val SumQ2)
begin
  switch (RepSpec.Media) begin
    case mtFile:
      goto LPrintReportTotalsExcel;
    case mtExcel:
LPrintReportTotalsExcel:;
      switch (RepSpec.flags[9]) begin
        case 0:
          StartFormat(15);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          switch (RepSpec.ArtMode) begin
            case 0:
              OutVal(240,0,SumQFwd,M4Qty,true);
              OutVal(320,0,SumQIn,M4Qty,true);
              OutVal(400,0,SumQOut,M4Qty,true);
              OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
            case 1:
              OutVal(240,0,SumCPFwd,M45Val,true);
              OutVal(310,0,SumCPIn,M45Val,true);
              OutVal(400,0,SumCPOut,M45Val,true);
              OutVal(480,0,SumCPIn-SumCPOut+SumCPFwd,M4Qty,true);
            case 3:
              OutVal(240,0,SumQFwd,M4Qty,true);
              OutVal(320,0,SumQIn,M4Qty,true);
              OutVal(400,0,SumQOut,M4Qty,true);
              OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
          end;
          EndFormat;
        case 1:
          StartFormat(15);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          OutString(0,0,"",false);
          switch (RepSpec.ArtMode) begin
            case 0:
              if (RepSpec.flags[12]!=0) then begin
                OutVal(375,0,SumQ2,M4Qty,true);
              end;
              OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
            case 1:
              OutVal(300,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
              OutVal(480,0,SumCPIn-SumCPOut+SumCPFwd,M45Val,true);
            case 3:
              if (RepSpec.flags[12]!=0) then begin
                OutVal(375,0,SumQ2,M4Qty,true);
              end;
              OutVal(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true);
          end;
          EndFormat;
      end;
    otherwise
      Gray_Divider(0,1);
      switch (RepSpec.flags[9]) begin
        case 0:
          StartFormat(15);
          switch (RepSpec.ArtMode) begin
            case 0:
              OutValBiDi(240,0,SumQFwd,M4Qty,true,280);
              OutValBiDi(320,0,SumQIn,M4Qty,true,360);
              OutValBiDi(400,0,SumQOut,M4Qty,true,440);
              OutValBiDi(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true,520);
            case 1:
              OutValBiDi(240,0,SumCPFwd,M45Val,true,280);
              OutValBiDi(320,0,SumCPIn,M45Val,true,360);
              OutValBiDi(400,0,SumCPOut,M45Val,true,440);
              OutValBiDi(480,0,SumCPIn-SumCPOut+SumCPFwd,M4Qty,true,500);
            case 3:
              OutValBiDi(240,0,SumQFwd,M4Qty,true,280);
              OutValBiDi(320,0,SumQIn,M4Qty,true,360);
              OutValBiDi(400,0,SumQOut,M4Qty,true,440);
              OutValBiDi(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true,520);
          end;
          EndFormat;
        case 1:
          StartFormat(15);
          switch (RepSpec.ArtMode) begin
            case 0:
              if (RepSpec.flags[12]!=0) then begin
                OutValBiDi(375,0,SumQ2,M4Qty,true,420);
              end;
              OutValBiDi(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true,520);
            case 1:
              OutValBiDi(340,0,SumQIn+SumQOut+SumQFwd,M4Qty,true,340);
              if (UserCanAction("ViewCostPrice",true)) then begin
                OutValBiDi(480,0,SumCPIn-SumCPOut+SumCPFwd,M45Val,true,500);
              end;
            case 3:
              if (RepSpec.flags[12]!=0) then begin
                OutValBiDi(375,0,SumQ2,M4Qty,true,420);
              end;
              OutValBiDi(480,0,SumQIn+SumQOut+SumQFwd,M4Qty,true,520);
          end;
          EndFormat;
      end;
      Gray_Divider(0,1);
  end; 
  return;
end;

procedure ItemHistList_In(record RcVc RepSpec,record ItemHistVc IHr,record INVc INr,record MainStockBlock MSb,                         
                          record CostAccBlock CAb,var Boolean itemheaderf,
                          val fwdqty,val fwdtotcp,val fwdqty2,
                          var val itemqin,var val itemcpin,var val itemq2in,var val bal)
begin
  val t,q2;
  val cp;
  Boolean testf;

  testf = true;
  switch (IHr.FileName) begin
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.Closed!=0) then begin
          testf = false;
        end;
      end;
    case "Fut3ORVc": begin
        record ORVc ORr;

        ORr.SerNr = IHr.TransNr;
        if (ReadFirstMain(ORr,1,true)) then begin end;
        if (ORr.Closed!=0) then begin
          testf = false;
        end;
      end;
  end;

  if (testf) then begin    
    if (RepSpec.flags[15]==0) then begin
      ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
    end else begin
      ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
    end;
    itemqin = itemqin + IHr.Qty;
    itemq2in = itemq2in + IHr.Qty2;
    cp = IHr.TotCostPrice;    
    itemcpin = itemcpin + cp;
    if (RepSpec.flags[9]==1) then begin      
      switch (RepSpec.ArtMode) begin
        case 0: bal = bal + IHr.Qty;
        case 1: bal = cp;
        case 3: bal = bal + IHr.Qty;
      end;
      if (RepSpec.flags[15]!=0) then begin
        PrintItemHist_PerLocation(RepSpec,INr,IHr,MSb,false,bal);
      end else begin
        PrintItemHist(RepSpec,INr,IHr,MSb,false,bal);
      end;
    end;
  end;
  return;
end;

procedure ItemHistList_Out(record RcVc RepSpec,record ItemHistVc IHr,record INVc INr,record MainStockBlock MSb,                         
                          record CostAccBlock CAb,var Boolean itemheaderf,
                          val fwdqty,val fwdtotcp,val fwdqty2,
                          var val itemqout,var val itemcpout,var val itemq2out,var val bal)
begin
  val t,q2;
  record ITVc ITr;
  Integer primary,queuecostmodel;
  val cp;
  Boolean testf;
    
  testf = true;
  switch (IHr.FileName) begin
    case "Fut1POVc": begin
        record POVc POr;

        POr.SerNr = IHr.TransNr;
        if (ReadFirstMain(POr,1,true)) then begin end;
        if (POr.Closed!=0) then begin
          testf = false;
        end;
      end;
    case "Fut3ORVc": begin
        record ORVc ORr;

        ORr.SerNr = IHr.TransNr;
        if (ReadFirstMain(ORr,1,true)) then begin end;
        if (ORr.Closed!=0) then begin
          testf = false;
        end;
      end;
    case "Fut2ProdoutVc": begin
        record ProdVc Prodr;
        record ProdOperationVc ProdOpr;

        Prodr.SerNr = IHr.TransNr;
        if (ReadFirstMain(Prodr,1,true)) then begin end;
        if (Prodr.PRStatusFlag==2) then begin
          if (nonblank(Prodr.Routing)) then begin
            ProdOpr.ProdNr = Prodr.SerNr;
            ProdOpr.PRStatusFlag = 3;
            testf = !ReadFirstkey("ProdNrPRStatus",ProdOpr,2,true);
          end;
        end;
      end;
  end;
  if (testf==false) then begin
    goto LItemHistList_Out;
  end;
  GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);  
  if (RepSpec.flags[15]==0) then begin
    ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
  end else begin
    ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
  end;
  itemqout = itemqout + IHr.Qty;
  itemq2out = itemq2out + IHr.Qty2;
  cp = IHr.TotCostPrice;
// If we take these lines out, Item History will be correct with WA decimal round offs.
// But is it correct? I mean, it then shows exactly the amount that was taken out. I think it IS correct
//
//  if (IHr.FileName!="RetPUVc") then begin //wrong it is, NL doesnt match Item History
    if (queuecostmodel!=20) then begin
      switch (primary) begin
        case kCostModelNoneItem: cp = 0;
        case kCostModelCostPrice:
          if (CAb.CostPricePerLocation!=0) then begin
            cp = IHr.CPTotCostPerLoc;
          end else begin
            cp = IHr.CPTotCost;
          end;
          if (INr.PriceFactor!=0) then begin
            cp = cp / INr.PriceFactor;
          end;
        case kCostModelPctBasePrice:
          cp = IHr.BPTotCost;
        case kCostModelWA:
          if (WAPerLocation(INr,ITr,CAb)!=0) then begin
            if (IHr.WATotCostPerLoc!=0) then begin
              cp = IHr.WATotCostPerLoc;
            end;
          end else begin
            if (IHr.WATotCost!=0) then begin
              cp = IHr.WATotCost;
            end;
          end;
//          cp = IHr.TotCostPrice;
      end;
    end;
//  end;
//
  itemcpout = itemcpout + cp;
  if (RepSpec.flags[9]==1) then begin      
    switch (RepSpec.ArtMode) begin
      case 0: bal = bal + IHr.Qty;
      case 1: bal = -cp;
      case 3: bal = bal + IHr.Qty;
    end;
    if (RepSpec.flags[15]!=0) then begin
      PrintItemHist_PerLocation(RepSpec,INr,IHr,MSb,true,bal);
    end else begin
      PrintItemHist(RepSpec,INr,IHr,MSb,true,bal);
    end;
  end;
LItemHistList_Out:;  
  return;
end;

procedure ItemForwardBalance(record RcVc RepSpec,record INVc INr,var val fwdqty,var val fwdtotcp,var val fwdcp,string mainstock)
begin
  record LocationVc Locr;
  Boolean locfound,nostockf;
  val tq,tv;
  record CostAccBlock CAb;
  Date dt;
  Integer primary,queuecostmodel;
  record ITVc ITr;
  Boolean testf;

  BlockLoad(CAb);
  fwdqty = blankval;
  fwdtotcp = blankval;
  fwdcp = blankval;
  if (INr.ItemType!=0) then begin
    dt = AddDay(RepSpec.sStartDate,-1);
    if (nonblank(RepSpec.f7) or nonblank(RepSpec.f8)) then begin 
      locfound = true;
      while (LoopMain(Locr,1,locfound)) begin  
        testf = true;  
        if (nonblank(RepSpec.f7)) then begin
          if (Locr.Group!=RepSpec.f7) then begin
            testf = false;
          end;
        end;
        if (nonblank(RepSpec.f8)) then begin
          if (SetInSet2(RepSpec.f8,Locr.Classification)==false) then begin
            testf = false;
          end;
        end;
        if (testf) then begin 
          fwdqty = fwdqty + GetStockQty(INr.Code,Locr.Code,dt,false);
        end;
      end;  
    end else begin       
      fwdqty = GetStockQty(INr.Code,RepSpec.TransStr,dt,false);
    end;  
    if (RepSpec.ArtMode==1) then begin
      GetCostModel(INr,CAb,ITr,primary,queuecostmodel,false);
      switch (primary) begin
        case 1: fwdtotcp = FindCPPriceBackdated(CostPricePerLocation(INr,ITr,CAb),INr,RepSpec.TransStr,fwdqty,dt,false) * fwdqty;
        case 2: fwdtotcp = FindBPPriceBackdated(CAb,INr,RepSpec.TransStr,fwdqty,dt,false) * fwdqty;
        case 3: fwdtotcp = FindWAPriceBackdated(WAPerLocation(INr,ITr,CAb),INr,RepSpec.TransStr,fwdqty,dt,false,0);
        case 4: 
          if (ItemCostPerLocation(INr)!=0) then begin
            if (blank(RepSpec.TransStr)) then begin
              fwdqty = blankval;
              Locr.Code = "";
              nostockf = true;
              locfound = true;
              while (LoopMain(Locr,1,locfound)) begin
                if (locfound) and (nonblank(Locr.Code)) then begin
                  tq = GetStockQty(INr.Code,Locr.Code,dt,false);
                  switch (queuecostmodel) begin
                    case 0: tv = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0,0);
                    case 1: tv = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0,0);
                    case 20: tv = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,Locr.Code,"",tq,0,dt,false,0,false,0,0,0);
                  end;
                  fwdtotcp = fwdtotcp + tv;
                  fwdqty = fwdqty + tq;
                  nostockf = false;
                end;
              end;
              if (blank(mainstock)) and (nostockf) then begin
                fwdqty = GetStockQty(INr.Code,"",dt,false); 
              end;
            end else begin
              switch (queuecostmodel) begin
                case 0: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
                case 1: fwdtotcp = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
                case 20: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
              end;
            end;
          end else begin
            switch (queuecostmodel) begin
              case 0: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
              case 1: fwdtotcp = FindCostPriceLIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
              case 20: fwdtotcp = FindCostPriceFIFOBackDated(ItemCostPerLocation(INr),INr,RepSpec.TransStr,"",fwdqty,0,dt,false,0,false,0,0,0);
            end;
          end;
          fwdcp = fwdtotcp/fwdqty;
      end;
    end;
  end;
  return;
end;

procedure AddItemHistRecord(record ItemHistVc IHr,record ItemHistVc sumIHr)
begin
  sumIHr.Qty = sumIHr.Qty + IHr.Qty;
  sumIHr.Qty2 = sumIHr.Qty2 + IHr.Qty2;
  sumIHr.TotCostPrice = sumIHr.TotCostPrice + IHr.TotCostPrice;
  sumIHr.WATotCost = sumIHr.WATotCost + IHr.WATotCost;
  sumIHr.CPTotCost = sumIHr.CPTotCost + IHr.CPTotCost;
  sumIHr.BPTotCost = sumIHr.BPTotCost + IHr.BPTotCost;

  sumIHr.WATotCostPerLoc = sumIHr.WATotCostPerLoc + IHr.WATotCostPerLoc;
  sumIHr.CPTotCostPerLoc = sumIHr.CPTotCostPerLoc + IHr.CPTotCostPerLoc;
  sumIHr.BPTotCostPerLoc = sumIHr.BPTotCostPerLoc + IHr.BPTotCostPerLoc;
  return;
end;

procedure PrintItemHistoryRecord(record RcVc RepSpec,record ItemHistVc sumIHr,record INVc INr,record MainStockBlock MSb,
                              record CostAccBlock CAb,var Boolean itemheaderf,
                              val fwdqty,val fwdtotcp,val fwdqty2,
                              var val itemqin,var val itemcpin,var val itemq2in,
                              var val itemqout,var val itemcpout,var val itemq2out,
                              var val bal)
begin
  switch (sumIHr.FileName) begin
    case "Fut2ProdOrderInVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdOrderOutVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdInVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut2ProdOutVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut1POVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "Fut3ORVc": 
      if (RepSpec.flags[14]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;
    case "IVVc":
      if (RepSpec.flags[1]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "IVCashVc":
      if (RepSpec.flags[1]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "INTransferVc": 
      if (RepSpec.flags[17]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;
    case "ProdVc": 
      if (RepSpec.flags[5]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "ProdOperationVc": 
      if (RepSpec.flags[20]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "PUVc": 
      if (RepSpec.flags[3]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;
    case "RetPUVc": 
      if (RepSpec.flags[19]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "RetVc": 
      if (RepSpec.flags[8]!=0) then begin
        ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
      end;      
    case "SDVc": 
      if (RepSpec.flags[6]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "SRVc":
      if (RepSpec.flags[22]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;      
    case "SHVc": 
      if (RepSpec.flags[2]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
    case "StockMovVc": 
      if (RepSpec.flags[4]!=0) then begin
        if (sumIHr.Qty>0) then begin
          ItemHistList_In(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,bal);
        end else begin
          ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
        end;
      end;
    case "WSVc": 
      if (RepSpec.flags[7]!=0) then begin
        ItemHistList_Out(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqout,itemcpout,itemq2out,bal);
      end;      
  end;         
  return;
end;

procedure SumTotals(val fwdqty,val fwdtotcp,val itemqin,val itemqout,val itemcpin,val itemcpout,val itemq2in,
                    var val SumQFwd,var val SumCPFwd,var val SumQIn,var val SumQOut,var val SumCPIn,var val SumCPOut,var val SumQ2)
begin
  SumQFwd = SumQFwd + fwdqty;
  SumCPFwd = SumCPFwd + Round(fwdtotcp,SetRoundModeD(2));
  SumQIn = SumQIn + itemqin;
  SumQOut = SumQOut + itemqout;
  SumCPIn = SumCPIn + Round(itemcpin,SetRoundModeD(2));
  SumCPOut = SumCPOut + Round(itemcpout,SetRoundModeD(2));
  SumQ2 = SumQ2 + itemq2in;
  return;
end;

procedure SetBlankVals(var val fwdqty,var val fwdqty2,var val fwdcp,var val fwdtotcp,var val itemqin,var val itemqout,
                       var val itemq2out,var val itemcpin,var val itemcpout,var val itemq2in,var val bal)
begin
  fwdqty = blankval;
  fwdqty2 = blankval;
  fwdcp = blankval;
  fwdtotcp = blankval;
  itemqin = blankval;
  itemqout = blankval;
  itemq2out = blankval;
  itemcpin = blankval;
  itemcpout = blankval;
  itemq2in = blankval;
  bal = blankval;      
  return;
end;

function Boolean SignEqual(val Qty1,val Qty2)
begin
  Boolean res;
  
  res = false;
  if (Qty1<0) then begin
    if (Qty2<0) then begin
      res = true;
    end;
  end else begin
    if (Qty2>=0) then begin
      res = true;
    end;
  end;
  SignEqual = res;
  return;
end;

function Boolean CheckIfAnyHistory(record RcVc RepSpec,record INVc INr)
begin
  Boolean res;
  record ItemHistVc IHr;
  Integer sorting,ihkeys;
  string 255 ihckey;
  Boolean foundIH,testf;
  
  sorting = RepSpec.flags[10];
  ResetLoop(IHr);
  switch (sorting) begin
    case 0:
      if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0)  then begin
        ihkeys = 2;
        ihckey = "ArtCodeFD";
      end else begin
        ihkeys = 3;
        ihckey = "ArtCodeLocFD";
        IHr.Location = RepSpec.TransStr;
      end;
    case 1:
      if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0) then begin
        ihkeys = 2;
        ihckey = "ArtCode";
      end else begin
        ihkeys = 3;
        ihckey = "ArtCodeLoc";
        IHr.Location = RepSpec.TransStr;
      end;
  end;
  IHr.ArtCode = INr.Code;
  switch (sorting) begin
    case 0: IHr.FIFODate = RepSpec.sStartDate;
    case 1: IHr.TransDate = RepSpec.sStartDate;
  end;
  foundIH = true;
  while (LoopKey(ihckey,IHr,ihkeys,foundIH)) begin
    if (IHr.ArtCode!=INr.Code) then begin foundIH = false; end;
    switch (sorting) begin
      case 0: if (IHr.FIFODate>RepSpec.sEndDate) then begin foundIH = false; end;
      case 1: if (IHr.TransDate>RepSpec.sEndDate) then begin foundIH = false; end;
    end;
    testf = true;
    if (nonblank(RepSpec.TransStr)) then begin
      if (ihkeys==3) then begin
        if (RepSpec.TransStr!=IHr.Location) then begin foundIH = false; end;
      end else begin
        if (RepSpec.TransStr!=IHr.Location) then begin testf = false; end;
      end;
    end; 
    if (RepSpec.flags[11]!=0) then begin
      if (INr.ItemType!=1) then begin testf = false; end;
    end;
    if (RepSpec.flags[14]!=0) then begin
      if (IHr.StockAffectf==0) then begin 
        if (Left(IHr.FileName,3)!="Fut") then begin
          testf = false;
        end;
      end;
    end else begin
      if (IHr.StockAffectf==0) then begin testf = false; end;
    end;
    if (foundIH==false) then begin testf = false; end;
    if (testf) then begin
      res = true;
      foundIH = false;
    end;
  end;
  CheckIfAnyHistory = res;
  return;
end;

procedure INrsRnRun(record RcVc RepSpec,record MainStockBlock MSb,record CostAccBlock CAb,
                    var val SumQFwd,var val SumQIn,var val SumQOut,var val SumCPFwd,var val SumCPIn,var val SumCPOut,var val SumQ2)
begin
  string 20 frin,toin;
  string 20 frloc,toloc;
  string 255 ckey,ihckey;
  Integer keys,ihkeys,sorting;
  record INVc INr;
  record PIVc PIr;
  record ItemHistVc IHr;
  record ItemHistVc sumIHr;
  record ItemHistVc lastIHr;
  record LocationVc Locationr;
  Boolean foundIH,foundIN,testf,itemheaderf,ihtestf,foundpi,itemhistf;  
  val itemqin,itemq2in,itemqout,bal,itemcpin,itemcpout,itemq2out;
  val fwdqty,fwdqty2,fwdcp,fwdtotcp;
    
  sorting = RepSpec.flags[10];
  frin = FirstInRange(RepSpec.f1,20);
  toin = LastInRange(RepSpec.f1,20);
  frloc = FirstInRange(RepSpec.AccStr,20);
  toloc = LastInRange(RepSpec.AccStr,20);
  if (nonblank(RepSpec.f3)) then begin
    INr.Group = RepSpec.f3;
    INr.Code = frin;
    ckey = "Group";
    keys = 2;
  end else begin
    INr.Code = frin;
    ckey = "Code";
    keys = 1;
  end;
  foundIN = true;
  while (LoopKey(ckey,INr,keys,foundIN)) begin
    if (foundIN) then begin
      if (nonblank(toin)) then  begin
        if (INr.Code>toin) then begin foundIN = false; end;
      end;  
    end;
    if (foundIN) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group!=RepSpec.f3) then begin foundIN = false; end;
      end;  
    end;
    if (foundIN) then begin
      if (RepSpec.flags[11]==1) then begin
        if (INr.ItemType!=1) then begin
          goto LINwhileend;
        end;
      end;    
      if (nonblank(toloc)) then begin
        if (INr.Department>toloc) then begin goto LINwhileend; end;
      end;  
      if (nonblank(frloc)) then begin
        if (INr.Department<frloc) then begin goto LINwhileend; end;
      end;  
      if (nonblank(RepSpec.f2)) then begin
        PIr.DefaultChoice = 1;
        PIr.ItemCode = INr.Code;
        PIr.Location = RepSpec.f6;
        PIr.VECode = RepSpec.f2;
        foundpi = ReadFirstKey("DefaultChoice",PIr,4,true);
        if (foundpi==false) then begin
          goto LINwhileend;
        end;
      end;
      if (nonblank(RepSpec.f4)) then begin
        if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
          goto LINwhileend;
        end;
      end;
      if (nonblank(RepSpec.f5)) then begin
        testf = false;
        ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
        if (testf==false) then begin
          goto LINwhileend;
        end;
      end;
    end;
    if (foundIN) then begin
      SetBlankVals(fwdqty,fwdqty2,fwdcp,fwdtotcp,itemqin,itemqout,itemq2out,itemcpin,itemcpout,itemq2in,bal);
      itemheaderf = false;
      ItemForwardBalance(RepSpec,INr,fwdqty,fwdtotcp,fwdcp,MSb.MainStock);
      if (RepSpec.flags[13]!=0) then begin
        if (fwdqty!=0) then begin
          if (RepSpec.flags[15]==0) then begin
            ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
          end else begin
            ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
          end;
        end;
      end else begin
//when Show Balance for Items with no History it is done on other place      
        if (fwdqty!=0) then begin
          if (RepSpec.flags[15]==0) then begin
//            ItemHistItemHeader(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,bal,itemheaderf);
          end else begin
//            ItemHistItemHeader_PerLocation(RepSpec,INr.Code,INr.Name,INr.Unittext,fwdqty,fwdtotcp,fwdqty2,itemheaderf);
          end;
        /*what was this for ? 
          if (CheckIfAnyHistory(RepSpec,INr)==false) then begin
            fwdqty = blankval;
            fwdtotcp = blankval;
            fwdcp = blankval;
          end;
        */
        end;
      end;

      ResetLoop(IHr);
      switch (sorting) begin
        case 0:
          if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0)  then begin
            ihkeys = 2;
            ihckey = "ArtCodeFD";
          end else begin
            ihkeys = 3;
            ihckey = "ArtCodeLocFD";
            IHr.Location = RepSpec.TransStr;
          end;
        case 1:
          if (blank(RepSpec.TransStr)) or (ItemCostPerLocation(INr)==0) then begin
            ihkeys = 2;
            ihckey = "ArtCode";
          end else begin
            ihkeys = 3;
            ihckey = "ArtCodeLoc";
            IHr.Location = RepSpec.TransStr;
          end;
      end;
      IHr.ArtCode = INr.Code;
      switch (sorting) begin
        case 0: IHr.FIFODate = RepSpec.sStartDate;
        case 1: IHr.TransDate = RepSpec.sStartDate;
      end;
      RecordNew(lastIHr);
      RecordNew(sumIHr);
      foundIH = true;
      while (LoopKey(ihckey,IHr,ihkeys,foundIH)) begin
        if (IHr.ArtCode!=INr.Code) then begin foundIH = false; end;
        switch (sorting) begin
          case 0: if (IHr.FIFODate>RepSpec.sEndDate) then begin foundIH = false; end;
          case 1: if (IHr.TransDate>RepSpec.sEndDate) then begin foundIH = false; end;
        end;
        testf = true;
        if (nonblank(RepSpec.TransStr)) then begin
          if (ihkeys==3) then begin
            if (RepSpec.TransStr!=IHr.Location) then begin foundIH = false; end;
          end else begin
            if (RepSpec.TransStr!=IHr.Location) then begin testf = false; end;
          end;
        end; 
        if (RepSpec.flags[14]!=0) then begin
          if (IHr.StockAffectf==0) then begin 
            if (Left(IHr.FileName,3)!="Fut") then begin
              testf = false;
            end;
          end;
        end else begin
          if (RepSpec.flags[11]==0) then begin
            if (INr.ItemType==kItemTypeStocked) then begin 
              if (IHr.StockAffectf==0) then begin testf = false; end;
              if (IHr.ItemType!=kItemTypeStocked) then begin testf = false; end;
            end else begin
              if (IHr.ItemType==kItemTypeStocked) and (IHr.StockAffectf==0) then begin testf = false; end;
            end;
          end else begin
            if (IHr.ItemType!=kItemTypeStocked) or (IHr.StockAffectf==0) then begin testf = false; end;
/*            
StartFormat(15);
 OutString(0,0,"jarek",false);
 OutString(50,0,IHr.FileName,false);
 OutString(150,0,IHr.TransNr,false);
 OutString(300,0,IHr.ItemType,false);
 OutString(350,0,IHr.StockAffectf,false);
EndFormat;
*/
          end;
        end;
        if (nonblank(RepSpec.f7) or nonblank(RepSpec.f8)) then begin
          Locationr.Code = IHr.Location;
          ReadFirstMain(Locationr,1,true);
          if (nonblank(RepSpec.f7)) then begin
            if (Locationr.Group!=RepSpec.f7) then begin
              testf = false;
            end;
          end;
          if (nonblank(RepSpec.f8)) then begin
            if (!SetInSet2(RepSpec.f8,Locationr.Classification)) then begin
              testf = false;
            end;
          end;
        end;
        if (foundIH==false) then begin testf = false; end;
//StopAlert("IHr.FileName " & IHr.FileName & " IHr.TransNr " & IHr.TransNr & " IHr.Location " & IHr.Location & " foundIH " & foundIH);
        if (testf) then begin
          itemhistf = true;
          if (lastIHr.SerNr<=0) then begin//first time
            RecordCopy(sumIHr,IHr);
          end else begin
            ihtestf = true;
            if (lastIHr.FileName==IHr.FileName) and (lastIHr.TransNr==IHr.TransNr) and (lastIHr.Row==IHr.Row) and (SignEqual(lastIHr.Qty,IHr.Qty)) then begin
              if (RepSpec.AccSpec!=0) then begin
                if (lastIHr.SerialNr==IHr.SerialNr) then begin
                  ihtestf = false;
                end;
              end else begin
                ihtestf = false;
              end;
            end;
//StopAlert("lastIHr.FileName " & lastIHr.FileName & " lastIHr.Qty " & lastIHr.Qty & " IHr.Qty " & IHr.Qty & " ihtestf " & ihtestf);
            if (ihtestf) then begin
              PrintItemHistoryRecord(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,itemqout,itemcpout,itemq2out,bal);
              RecordCopy(sumIHr,IHr);
            end else begin
              AddItemHistRecord(IHr,sumIHr);
            end;
          end;
          RecordCopy(lastIHr,IHr);
        end;
      end;
      if (RepSpec.flags[13]==0) then begin
        if (itemhistf==false) then begin
          fwdqty = blankval;
          fwdtotcp = blankval;
        end;
      end;
      if (sumIHr.Qty!=0) then begin
        PrintItemHistoryRecord(RepSpec,sumIHr,INr,MSb,CAb,itemheaderf,fwdqty,fwdtotcp,fwdqty2,itemqin,itemcpin,itemq2in,itemqout,itemcpout,itemq2out,bal);
      end;
      SumTotals(fwdqty,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in+itemq2out,SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
      if (RepSpec.flags[15]==0) then begin
        switch (RepSpec.flags[9]) begin
          case 0: PrintItemTotals_Overview(RepSpec,INr,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout);
          case 1: PrintItemTotals_Detailed(RepSpec,INr,itemheaderf,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout,itemq2in+itemq2out,bal);
        end;
      end else begin
        PrintItemTotals_Overview_PerLocation(RepSpec,INr,fwdqty,fwdcp,fwdtotcp,itemqin,itemqout,itemcpin,itemcpout);
      end;
    end;    
LINwhileend:;  
  end;
  return;
end;

procedure PrintLocation(record LocationVc Locr)
begin
  StartFormat(15);
   OutString(0,0,Locr.Code,false);
   OutString(100,0,Locr.Name,false);
  EndFormat;
  Gray_Divider(0,200);
  return;
end;

procedure PrintLocationTotals(record RcVc RepSpec,string location,val LocSumQFwd,val LocSumCPFwd,val LocSumQIn,val LocSumQOut,val LocSumCPIn,val LocSumCPOut,val LocSumQ2)
begin
  switch (RepSpec.Media) begin
    case mtFile:
      goto LPrintLocationTotalsExcel;
    case mtExcel:
LPrintLocationTotalsExcel:;
      if (RepSpec.flags[9]==0) then begin
        StartFormat(15);
        OutString(0,0,"",false);
        OutString(0,0,"",false);
        OutString(0,0,"",false);
        switch (RepSpec.ArtMode) begin
          case 0:
             OutString(100,0,location,false);
             OutVal(240,0,LocSumQFwd,M4UVal,true);
             OutVal(320,0,LocSumQIn,M4UVal,true);
             OutVal(400,0,LocSumQOut,M4UVal,true);
             OutVal(480,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
          case 1:
             OutString(60,0,location,false);
             OutVal(200,0,LocSumQFwd,M4UVal,true);
             OutVal(240,0,LocSumCPFwd,M4Val,true);
             OutVal(280,0,LocSumQIn,M4UVal,true);
             OutVal(310,0,LocSumCPIn,M4Val,true);
             OutVal(360,0,LocSumQOut,M4UVal,true);
             OutVal(400,0,LocSumCPOut,M4Val,true);
             OutVal(440,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4Val,true);
             OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
        end;
        EndFormat;
      end else begin
        StartFormat(15);
        OutString(0,0,"",false);
        OutString(0,0,"",false);
        OutString(0,0,"",false);
        switch (RepSpec.ArtMode) begin
          case 0:
             OutString(250,0,location,false);
             OutVal(1,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
          case 1:
             OutString(200,0,location,false);
             OutVal(300,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
             OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
        end;
        EndFormat;
      end;
    otherwise
      if (RepSpec.flags[9]==0) then begin
        Gray_Divider(150,1);
        StartFormat(15);
        switch (RepSpec.ArtMode) begin
          case 0:
             OutString(100,0,location,false);
             OutVal(240,0,LocSumQFwd,M4UVal,true);
             OutVal(320,0,LocSumQIn,M4UVal,true);
             OutVal(400,0,LocSumQOut,M4UVal,true);
             OutVal(480,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
          case 1:
             OutString(60,0,location,false);
             OutVal(200,0,LocSumQFwd,M4UVal,true);
             OutVal(240,0,LocSumCPFwd,M4Val,true);
             OutVal(280,0,LocSumQIn,M4UVal,true);
             OutVal(320,0,LocSumCPIn,M4Val,true);
             OutVal(360,0,LocSumQOut,M4UVal,true);
             OutVal(400,0,LocSumCPOut,M4Val,true);
             OutVal(440,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4Val,true);
             OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
        end;
        EndFormat;
      end else begin
        Gray_Divider(300,1);
        StartFormat(15);
        switch (RepSpec.ArtMode) begin
          case 0:
             OutString(250,0,location,false);
             OutVal(1,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
          case 1:
             OutString(200,0,location,false);
             OutVal(300,0,LocSumQFwd+LocSumQIn+LocSumQOut,M4UVal,true);
             OutVal(480,0,LocSumCPFwd+LocSumCPIn-LocSumCPOut,M4Val,true);
        end;
        EndFormat;
        Gray_Divider(0,1);
        StartFormat(5);
        EndFormat;
      end;
  end;
  return;
end;

procedure SetSumBlankVals(var val LFwd,var val LCPFwd,var val LQIn,var val LQOut,var val LCPIn,var val LCPOut,var val LQ2)
begin
  LFwd = blankval;
  LCPFwd = blankval;
  LQIn = blankval;
  LQOut = blankval;
  LCPIn = blankval;
  LCPOut = blankval;
  LQ2 = blankval;
  return;
end;

global
procedure INrsRn(record RcVc RepSpec)
begin
  record MainStockBlock MSb;
  record CostAccBlock CAb;
  record LocationVc Locr;
  Boolean found,testf;
  string 255 frloc,toloc;
  val SumQIn,SumQOut,SumQFwd,SumCPIn,SumCPOut,SumCPFwd,SumQ2;
  val bal;
  val LocSumQIn,LocSumQOut,LocSumQFwd,LocSumCPIn,LocSumCPOut,LocSumCPFwd,LocSumQ2;

  frloc = FirstInRange(RepSpec.f6,20);
  toloc = LastInRange(RepSpec.f6,20);
  BlockLoad(MSb);
  BlockLoad(CAb);
  ItemHistHeader(RepSpec);
  Gray_Divider(0,1);
  switch (RepSpec.flags[15]) begin // Per Location
    case 0: 
      if (frloc!=toloc) then begin
        StartFormat(15);
         OutString(0,0,USetStr(11687),false);
        EndFormat;
        goto LINrsRn;
      end;
      RepSpec.TransStr = frloc;
      INrsRnRun(RepSpec,MSb,CAb,SumQFwd,SumQIn,SumQOut,SumCPFwd,SumCPIn,SumCPOut,SumQ2);
      PrintReportTotals(RepSpec,SumQFwd,SumQIn,SumQOut,SumCPFwd,SumCPIn,SumCPOut,SumQ2);
    case 1:
      found = true;
      Locr.Code = frloc;
      while (LoopMain(Locr,1,found)) begin
        if (nonblank(RepSpec.f6)) then begin
          if (Locr.Code>toloc) then begin found = false; end;
        end;
        testf = found;
        if (nonblank(RepSpec.f7)) then begin
          if (Locr.Group!=RepSpec.f7) then begin
            testf = false;
          end;
        end;
        if (nonblank(RepSpec.f8)) then begin
          if (!SetInSet2(RepSpec.f8,Locr.Classification)) then begin
            testf = false;
          end;
        end;
        if (testf) then begin
          SetSumBlankVals(LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2);
          PrintLocation(Locr);
          RepSpec.TransStr = Locr.Code;          
          INrsRnRun(RepSpec,MSb,CAb,LocSumQFwd,LocSumQIn,LocSumQOut,LocSumCPFwd,LocSumCPIn,LocSumCPOut,LocSumQ2);
          PrintLocationTotals(RepSpec,Locr.Code,LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2);
          SumTotals(LocSumQFwd,LocSumCPFwd,LocSumQIn,LocSumQOut,LocSumCPIn,LocSumCPOut,LocSumQ2,SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
        end;
      end;
      RepSpec.TransStr = "";
      PrintLocationTotals(RepSpec,"",SumQFwd,SumCPFwd,SumQIn,SumQOut,SumCPIn,SumCPOut,SumQ2);
  end;  
LINrsRn:;  
  EndJob; 
  return;
end;
