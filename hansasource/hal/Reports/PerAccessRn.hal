// I'm sorry, but I wrote another Access report, this was very confusing code and we wanted to have it for the Database, not for each company
procedure PersAcc1Rn(record RcVc RepSpec)
begin
  record UserVc User;
  record ConfVc Confr;
  row ConfVc Confrw;
  integer i,rwcnt,tconf;
  boolean TrHs,test,mailf;
  User.Code = RepSpec.f3;
  TrHs = true;

  StartFormat(15);
  OutString(0,0,USetStr(13201),false); //Person
  OutString(50,0,USetStr(13202),false); //Name
  OutString(230,0,USetStr(13203),false); //Access Group
  OutString(300,0,USetStr(13204),false); //Conf.Access Group
  EndFormat;    
  while LoopMain(User,1,TrHs) begin
    test = true; 
  if nonblank(RepSpec.f3) then begin
    if (RepSpec.f3<>User.Code) then begin
      TrHs = false;
      test = false;
    end;
  end;
  if nonblank(RepSpec.f1) then begin
    if (RepSpec.f1<>User.AccessGroup) then begin
      test = false;
    end;
  end;
  tconf = -1;
  if test then begin
    if nonblank(RepSpec.f2)  then begin
      test = false;
      Confr.AddrCode = User.Code;
      if (ReadFirstKey("AddrCode",Confr,1,true)) then begin
        rwcnt = MatRowCnt(Confr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Confr,i,Confrw);
          if nonblank(Confrw.Group) then begin
            if (Confrw.Group == RepSpec.f2) then begin
              test = true;
              tconf = i;
              i = rwcnt;
            end;
          end;
        end;
      end;    
    end;
  end;  
  if (test == true) then begin
     StartFormat(15);
        OutString(0,0,User.Code,false);
        OutString(50,0,User.Name,false);
        OutString(230,"DblAccessVc",User.AccessGroup,false);
        Confr.AddrCode = User.Code;
        if blank(RepSpec.f2) then begin
      if (ReadFirstKey("AddrCode",Confr,1,true)) then begin
        rwcnt = MatRowCnt(Confr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Confr,i,Confrw);
          if nonblank(Confrw.Group) then begin
            if (i > 0) then begin
              EndFormat;    
              StartFormat(15);
            end;  
            OutString(300,0,Confrw.Group,false);
          end;
        end;     
      end;
    end else begin
      MatRowGet(Confr,tconf,Confrw);
      OutString(300,0,Confrw.Group,false);
    end;  
    EndFormat;    
  end;
  end;
  return;
end;


procedure SortAcc(var array string person,var array string access,var integer k)
begin
integer m,cond;
string 5 perstemp,acctemp;

cond = 1;
while (cond==1) begin
    cond = 0;
    for (m=0;m<k;m=m+1) begin
     if (access[m] & person[m] > access[m+1] & person[m+1]) then begin
        cond = 1;
        perstemp = person[m];
        acctemp  = access[m];
       
        person[m] = person[m+1];
        access[m] = access[m+1];
        
        person[m+1] = perstemp;
        access[m+1] = acctemp;
      end;
    end;
end; 
return;
end;

// UGLY CODE!!!!
procedure OutAccess(string access)
begin
record AccessVc Accessr;
row AccessVc Accessrw;
integer i,rwcnt;
string 20 atype;
  Integer setnr;

Accessr.Code = access;
if ReadFirstMain(Accessr,1,true) then begin
   OutString(80,0,Accessr.Comment,false);
   if (Accessr.StartLevel == 0) then begin
       OutString(280,0,USetStr(13205),false); //No Access
   end;  
   if (Accessr.StartLevel == 1) then begin
       OutString(280,0,USetStr(13206),false);//Full Access
   end;  
   if (Accessr.StartLevel == -1) then begin
       OutString(280,0,USetStr(13199),false);//Additional
   end;  
   EndFormat;
   StartFormat(15);
   EndFormat;
   StartFormat(15);
   OutString(0,0,USetStr(13207),false); //Type
   OutString(100,0,USetStr(13208),false); //Item
   OutString(350,0,USetStr(13209),false); //Level
   EndFormat;
   
   rwcnt = MatRowCnt(Accessr);
   for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Accessr,i,Accessrw);
      StartFormat(15);
      switch (Accessrw.AccType) begin
      case 1:  
        atype = USetStr(13210);
      case 2: 
        atype = USetStr(13211);
      case 3:
        atype = USetStr(13212);
      case 4:
          atype = USetStr(13213);
      case 5:
        atype = USetStr(13214);
      case 6:
        atype = USetStr(13215);
      case 7:
        atype = USetStr(13216);
        case 8:
        atype = USetStr(13217);  
      case 9:
        atype = USetStr(13218);  
        case 10:
        atype = USetStr(13219);    
      end;
      OutString(0,0,atype,false);
      switch (Accessrw.AccType) begin
        case 1: setnr = -2;
        case 2: setnr = -1;
        case 3: setnr = 5; /* Setting */
        case 4: setnr = 6; /* Report */
        case 5: setnr = 7; /* Document */
        case 6: setnr = 8; /* Export */
        case 7: setnr = 9; /* Import */
        case 8: setnr = 10; /* Maintenance */
        case 9: setnr = 3; /* Special */
      end;
      OutString(100,0,StringFromStringSet(setnr,Accessrw.AccName),false);
      switch (Accessrw.AccLevel) begin
      case 1:  
        atype = USetStr(13220);  
      case 2: 
        atype = USetStr(13221);  
      case 3:
        atype = USetStr(13222);  
      case 6:
          atype = USetStr(13223);  
      case 7:
        atype = USetStr(13224);  
        case 4:
        atype = USetStr(13225);
      case 5:
        atype = USetStr(13226);  
      end;
      OutString(350,0,atype,false);
      EndFormat;
   end;     
end;
return;
end;

procedure PersAcc2Rn(record RcVc RepSpec)
begin
record UserVc User;
boolean TrHs,test;
array string 5 person;
array string 5 access;
integer i,tot;
string 5 tacc;

StartFormat(15);
OutString(60,0,USetStr(13203),true);
if (RepSpec.flags[2] == 0) then begin
  OutString(70,0,USetStr(13201),false);
  OutString(120,0,USetStr(13202),false);
end else begin
  OutString(80,0,USetStr(13227),false);
  OutString(280,0,USetStr(13228),false);
end;
EndFormat;
i = 0;
tacc = "*";
  User.Code = RepSpec.f3;
  TrHs = true;
  ResetLoop(User);
  while LoopMain(User,1,TrHs) begin
    if nonblank(RepSpec.f3) then begin
      if (RepSpec.f3<>User.Code) then begin
        TrHs = false;
      end;
    end;
    if (TrHs == true) then begin
        if nonblank(User.AccessGroup) then begin
            test = true;
            if nonblank(RepSpec.f1) then begin
              if (RepSpec.f1<>User.AccessGroup) then begin
                test = false;
              end;  
            end;
            if test then begin  
          person[i]=User.Code;
          access[i]=User.AccessGroup;
          i = i + 1;
        end;  
      end;
    end;
  end;
  tot = i;
  //sorting
  if (i > 1) then begin
     SortAcc(person,access,i);
  end;
  i = 0;
  for (i=0;i<tot;i=i+1) begin
    if nonblank(access[i]) then begin
      if (access[i] <> tacc) then begin
        if (tacc<>"*") then begin
          StartFormat(15);
          EndFormat;
          Black_Divider(0,1);
        end;  
        StartFormat(15);
        OutString(30,"DblAccessVc",access[i],false);
        if (RepSpec.flags[2] == 1) then begin
          OutAccess(access[i]);
          Gray_Divider(70,300);
          StartFormat(15);
          OutString(70,0,USetStr(13201),false);
          OutString(120,0,USetStr(13202),false);
          EndFormat;
        end;  
      end;  
      tacc = access[i];
      StartFormat(15);
      OutString(70,0,person[i],false);
      User.Code = person[i];
      if ReadFirstMain(User,1,true) then begin
         OutString(120,0,User.Name,false);
      end;
      EndFormat;
    end;  
  end;  

  return;
end;

procedure GlobalPersAcc2Rn(record RcVc RepSpec)
begin
  record GlobalUserVc User;
  boolean TrHs,test;
  array string 5 person;
  array string 5 access;
  integer i,tot;
  string 5 tacc;
  Integer j,rwcnt;
  row GlobalUserVc Userw;

  StartFormat(15);
  OutString(60,0,USetStr(13203),true);
  if (RepSpec.flags[2] == 0) then begin
    OutString(70,0,USetStr(13201),false);
    OutString(120,0,USetStr(13202),false);
  end else begin
    OutString(80,0,USetStr(13227),false);
    OutString(280,0,USetStr(13228),false);
  end;
  EndFormat;
  i = 0;
  tacc = "*";
  User.Code = RepSpec.f3;
  TrHs = true;
  ResetLoop(User);
  while LoopMain(User,1,TrHs) begin
    if nonblank(RepSpec.f3) then begin
      if (RepSpec.f3<>User.Code) then begin
        TrHs = false;
      end;
    end;
    if (TrHs == true) then begin
        if nonblank(User.AccessGroup) then begin
            test = true;
            if nonblank(RepSpec.f1) then begin
              test = false;
              rwcnt = MatRowCnt(User);
              for (j=0;j<rwcnt;j=j+1) begin
                MatRowGet(User,j,Userw);
                if (Userw.AccessGroup==RepSpec.f1) then begin
                  test = true;
                  person[i]=User.Code;
                  access[i]=Userw.AccessGroup;
                  i = i + 1;

                  j = rwcnt;
                end;
              end;
              if (test==false) then begin
                if (RepSpec.f1==User.AccessGroup) then begin
                  test = true;
                  person[i]=User.Code;
                  access[i]=User.AccessGroup;
                  i = i + 1;
                end;  
              end;
            end else begin  
              test = true;
              person[i]=User.Code;
              access[i]=User.AccessGroup;
              i = i + 1;  
            end;
      end;
    end;
  end;
  tot = i;
  //sorting
  if (i > 1) then begin
     SortAcc(person,access,i);
  end;
  i = 0;
  for (i=0;i<tot;i=i+1) begin
    if nonblank(access[i]) then begin
      if (access[i] <> tacc) then begin
        if (tacc<>"*") then begin
          StartFormat(15);
          EndFormat;
          Black_Divider(0,1);
        end;  
        StartFormat(15);
        OutString(30,"DblAccessVc",access[i],false);
        if (RepSpec.flags[2] == 1) then begin
          OutAccess(access[i]);
          Gray_Divider(70,300);
          StartFormat(15);
          OutString(70,0,USetStr(13201),false);
          OutString(120,0,USetStr(13202),false);
          EndFormat;
        end;  
      end;  
      tacc = access[i];
      StartFormat(15);
      OutString(70,0,person[i],false);
      User.Code = person[i];
      if ReadFirstMain(User,1,true) then begin
        OutString(120,0,User.Name,false);
      end;
      EndFormat;
    end;  
  end;  

return;
end;

procedure PersAcc3Rn(record RcVc RepSpec)
begin
  record ConfVc Confr;
  row ConfVc Confrw;
  record UserVc User;
  record ConfAccVc ConfAccr;

  boolean TrHs,test;
  array string 5 person;
  array string 5 access;
  integer i,tot;
  string 5 tacc;
  integer j,rwcnt;

  StartFormat(15);
  OutString(100,0,USetStr(13204),true);
  OutString(170,0,USetStr(13201),false);
  OutString(220,0,USetStr(13202),false);
  EndFormat;
    
  i = 0;
  tacc = "*";
  Confr.AddrCode = RepSpec.f3;
  TrHs = true;
  ResetLoop(Confr);
  while LoopKey("AddrCode",Confr,1,TrHs) begin
    if nonblank(RepSpec.f3) then begin
      if (RepSpec.f3<>Confr.AddrCode) then begin
        TrHs = false;
      end;
    end;
    if ((TrHs == true) and nonblank(Confr.AddrCode)) then begin
            rwcnt = -1;
        rwcnt = MatRowCnt(Confr);
        if (rwcnt <> -1) then begin
          for (j=0;j<rwcnt;j=j+1) begin
            MatRowGet(Confr,j,Confrw);
            if nonblank(Confrw.Group) then begin
                test = true;
                if nonblank(RepSpec.f2) and (RepSpec.f2<>Confrw.Group) then begin
                  test = false;
                end;
                if test then begin
                person[i]=Confr.AddrCode;
                access[i]=Confrw.Group;
                i = i + 1;
              end;  
            end;
          end;
        end;      
    end;
  end;
  tot = i;
  //sorting
  if (i > 1) then begin
     SortAcc(person,access,i);
  end;
  i = 0;
  for (i=0;i<tot;i=i+1) begin
    if nonblank(access[i]) then begin
      if (access[i] <> tacc) then begin
        if (tacc<>"*") then begin
          StartFormat(15);
          EndFormat;
          Black_Divider(0,1);
        end;  
        StartFormat(15);
        OutString(30,0,access[i],false);
        ConfAccr.Code = access[i];
        if ReadFirstMain(ConfAccr,1,true) then begin
          OutString(100,0,ConfAccr.Comment,false);
        end;
        EndFormat;
        Gray_Divider(170,300);
      end;  
      tacc = access[i];
      StartFormat(15);
      OutString(170,0,person[i],false);
      User.Code = person[i];
      if ReadFirstMain(User,1,true) then begin
         OutString(220,0,User.Name,false);
      end;
      EndFormat;
    end;  
  end;  
return;
end;

procedure CompPersAcc2Rn(record RcVc RepSpec)
BEGIN
  record CompaniesBlock CompaniesRec;
  row CompaniesBlock comprw;
  Integer i,rwcnt;
  Integer compnr,curcomp;
  
  BlockLoad(CompaniesRec);
  curcomp = CurrentCompany;  
  
  rwcnt = MatRowCnt(CompaniesRec);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CompaniesRec,i,comprw);
    if (SetCompanyCode(comprw.CompCode,false)) then begin
      StartFormat(15);
      EndFormat;
      Black_Divider(0,1);
      StartFormat(15);
      OutString(0,0,USetStr(7661) & ":",false);
      OutString(80,0,comprw.CompCode,false);
      OutString(100,0,comprw.CompName,false);
      EndFormat;
      Black_Divider(0,1);
      PersAcc2Rn(RepSpec);
    end;
  end;
  ResetCompany(curcomp);
  RETURN;
END;



global
procedure PersAccRn(record RcVc RepSpec)
begin
  integer rw;
  string 255 tstr;
  StartReportJob(USetStr(13200));
   
  rw = 1;
  tstr = USetStr(13229);
  if (RepSpec.flags[1] == 0) then begin
    tstr = tstr & USetStr(13201);
  end;
  if (RepSpec.flags[1] == 1) then begin
    tstr = tstr & USetStr(13203);
  end;
  if (RepSpec.flags[1] == 2) then begin
    tstr = tstr & USetStr(13204);
  end;
  Header(rw,tstr,1);
  rw = rw + 1;

  if (RepSpec.flags[2] == 1) then begin
     tstr = USetStr(13230);
     Header(rw,tstr,0);
  end;
  if nonblank(RepSpec.f3) then begin
     tstr = USetStr(13201) & ": " & RepSpec.f3;
     Header(rw,tstr,1);
     rw = rw + 1;
  end;
   if nonblank(RepSpec.f1) then begin
     tstr = USetStr(13203) & ": " & RepSpec.f1;
     Header(rw,tstr,1);
     rw = rw + 1;
  end;
  if nonblank(RepSpec.f2) then begin
    tstr = USetStr(13204) & ": " & RepSpec.f2;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  EndHeader;
  if (RepSpec.flags[1] == 0) then begin
    PersAcc1Rn(RepSpec);
  end; 
  //change start
  if (RepSpec.flags[1] == 1) then begin
    if (RepSpec.flags[3] == 1) then begin
      StartFormat(15);
      OutString(0,0,"Global Users",false); // English hardcoded
      EndFormat;
      Black_Divider(0,1);
      GlobalPersAcc2Rn(RepSpec);
    end; 
    if (RepSpec.IncDaughter==0) then begin
      PersAcc2Rn(RepSpec);
    end else begin
      CompPersAcc2Rn(RepSpec);
    end;
  end; 
  //change end
  if (RepSpec.flags[1] == 2) then begin
    PersAcc3Rn(RepSpec);
  end; 
  EndJob;
  return;
end;

