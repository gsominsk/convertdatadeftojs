external procedure CurValToOtherCur(Date,string,val,string,var val,roundmode);
external function Integer DateGetIntMonth(Date);
external function string 60 AddObjectToObjectList(string,string);
external function roundmode DefaultRoundMode();
external function val Budg1Calc(string,string,string,Date,Date,Integer,Integer,Integer);
external function val Budg2Calc(string,string,string,Date,Date,Integer,Integer,Integer);
external function Boolean GetOwnerPrc(Date,var Date,var val);
external function Integer TypeOfCurncy(var string,var Integer);
external procedure GetOnAccBalance(record RcVc,string,string,Boolean,Integer,var val,var val,var val,var val,var val,var val,var val,record SMVc,
                   Array string,Array val,var Integer);
external procedure APGetOnAccBalance(record RcVc,record CUVc,Boolean,var val,var val,var val,var val,var val,var val,var val,
                   Array string,Array val,var Integer,Array string,Array val,var Integer);
external function Integer GetIntYc(Date);
external procedure Base1ToOther(var string,val,val,val,val,val,val,var val,roundmode);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external procedure MockObjFromVATCode(string,var string);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase2(var string,val,val,val,val,val,val,roundmode);
external function Integer CountObjects(string);
external procedure NormalizeObjstr(var string);
external procedure GetAccDCBalance(string,string,Date,record ObjBalVc,Integer,Integer,Integer,string,var val,var val,Integer);
external procedure GetAccDCStartBalance(string,string,Date,record ObjBalVc,Integer,Integer,string,Integer,var val,var val);
external function Boolean GetNext3Sep(string,var Integer,var string);
external function Boolean GetNextItem2(string,var Integer,var string);
external procedure PSFindPaydAmount(record IPrsVc,var val);
external function Boolean GetObjBal(string,string,var record ObjBalVc);
external function string 255 AddStr(string,string,string);

procedure KLAccRuPerBal(record RcVc RepSpec,string accstr,string objs,var val dSbp,var val dPbp,var val dEbp,
                        var val cSbp,var val cPbp,var val cEbp,Integer conspr,val prc)
begin
  record ObjBalVc ObjBalr;
  Boolean Objbals;
  Integer ocnt;

  dSbp = 0;
  dPbp = 0;
  dEbp = 0;
  cSbp = 0;
  cPbp = 0;
  cEbp = 0;
  NormalizeObjstr(objs);
  ocnt = CountObjects(objs);
  Objbals = GetObjBal(accstr,objs,ObjBalr);
  if ((Objbals) or (ocnt>1)) then begin  
    GetAccDCStartBalance(accstr,objs,RepSpec.sStartDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,RepSpec.CurncyCode,0,dSbp,cSbp);
    GetAccDCBalance(accstr,objs,RepSpec.sEndDate,ObjBalr,RepSpec.SimVerf,RepSpec.basecurncy,0,RepSpec.CurncyCode,dEbp,cEbp,0);    
    if (conspr>0) then begin
      dSbp = dSbp * prc;
      dSbp = dSbp / 100;
      dSbp = Round(dSbp,DefaultRoundMode);
      cSbp = cSbp * prc;
      cSbp = cSbp / 100;
      cSbp = Round(cSbp,DefaultRoundMode);

      dEbp = dEbp * prc;
      dEbp = dEbp / 100;
      dEbp = Round(dEbp,DefaultRoundMode);
      cEbp = cEbp * prc;
      cEbp = cEbp / 100;
      cEbp = Round(cEbp,DefaultRoundMode);
    end;
    dPbp = dEbp - dSbp;
    cPbp = cEbp - cSbp;
  end;
  return;
end;

procedure KLPB2(string functionname,record RcVc RepSpec,record AccVc Accp,string nru,var val dSbp,var val dPbp,var val dEbp,
                var val cSbp,var val cPbp,var val cEbp,Boolean addflag,val prc)
begin
  val dSb1,dPb1,dEb1;
  val cSb1,cPb1,cEb1;
  val v;
  string 255 objstr,vatcode;
  transaction string 5 keycurcod;
  transaction string 255 gKeyRn_columncod;
  transaction record TRVc gKeyRn_TRr;
  row TRVc TRrw;
  Integer tri,trrwcnt;
  transaction integer gKeyRn_columntype;
    
  switch (functionname) begin
    case "VATResult":
      KLAccRuPerBal(RepSpec,Accp.AccNumber,AddObjectToObjectList(nru,RepSpec.ObjStr),dSb1,dPb1,dEb1,cSb1,cPb1,cEb1,Accp.Conspr,prc);
    case "VATCredResult":
      KLAccRuPerBal(RepSpec,Accp.AccNumber,AddObjectToObjectList(nru,RepSpec.ObjStr),dSb1,dPb1,dEb1,cSb1,cPb1,cEb1,Accp.Conspr,prc);
    case "VATDebResult":
      KLAccRuPerBal(RepSpec,Accp.AccNumber,AddObjectToObjectList(nru,RepSpec.ObjStr),dSb1,dPb1,dEb1,cSb1,cPb1,cEb1,Accp.Conspr,prc);
    otherwise
     KLAccRuPerBal(RepSpec,Accp.AccNumber,nru,dSb1,dPb1,dEb1,cSb1,cPb1,cEb1,Accp.Conspr,prc);
  end;
  if (addflag==true) then begin
    dSbp = dSbp + dSb1;
    dPbp = dPbp + dPb1;
    dEbp = dEbp + dEb1;
    cSbp = cSbp + cSb1;
    cPbp = cPbp + cPb1;
    cEbp = cEbp + cEb1;
  end else begin
    dSbp = dSbp - dSb1;
    dPbp = dPbp - dPb1;
    dEbp = dEbp - dEb1;
    cSbp = cSbp - cSb1;
    cPbp = cPbp - cPb1;
    cEbp = cEbp - cEb1;
  end;
  switch (RepSpec.AccSpec) begin
    case 4:
      switch (functionname) begin
        case "Result": v = dPb1 - cPb1; objstr = nru;
        case "AvgResult": v = dPb1 - cPb1; objstr = nru;
        case "VATResult": v = dPb1 - cPb1; vatcode = Left(nru,1);
        case "AvgVATResult": v = dPb1 - cPb1; vatcode = Left(nru,1);
        case "VATCredResult": v = -cPb1; vatcode = Left(nru,1);
        case "AvgVATCredResult": v = -cPb1; vatcode = Left(nru,1);
        case "VATDebResult": v = dPb1; vatcode = Left(nru,1);
        case "AvgVATDebResult": v = dPb1; vatcode = Left(nru,1);
        case "VATBalance": v = dEb1 - cEb1;
        case "ObjResult": v = dPb1 - cPb1; objstr = nru;
        case "AvgObjResult": v = dPb1 - cPb1; objstr = nru;
        case "ObjDebResult": v = dPb1; objstr = nru;
        case "AvgObjDebResult": v = dPb1; objstr = nru;
        case "ObjCredResult": v = -cPb1; objstr = nru;
        case "AvgObjCredResult": v = -cPb1; objstr = nru;
        case "Balance": v = dEb1 - cEb1; objstr = nru;
        case "DebBalance": v = dEb1; objstr = nru;
        case "CredBalance": v = -cEb1; objstr = nru;
        case "DebResult": v = dPb1; objstr = nru;
        case "AvgDebResult": v = dPb1; objstr = nru;
        case "CredResult": v = -cPb1; objstr = nru;
        case "AvgCredResult": v = -cPb1; objstr = nru;
      end;      

      if (v!=0 or RepSpec.flags[19]!=0) then begin
        trrwcnt = MatRowCnt(gKeyRn_TRr);
        for (tri=0;tri<trrwcnt;tri=tri+1) begin
          MatRowGet(gKeyRn_TRr,tri,TRrw);
          if (TRrw.TFromFileName==gKeyRn_columncod) then begin
            TRrw.AccNumber = Accp.AccNumber;
            TRrw.Comment = Accp.Comment;
            TRrw.Objects = objstr;
            TRrw.VATCode = vatcode;
            TRrw.DebVal = -v;
            TRrw.Typ = gKeyRn_columntype;
            MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
//Trace("TRrw.AccNumber " & TRrw.AccNumber & " keycurcod " & keycurcod & " gKeyRn_columncod " & gKeyRn_columncod," TRrw.DebVal " & TRrw.DebVal);                
            SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,-v);
          end;
        end;
      end;
  end;  
  return;
end;

function val GetOpenPOSum(string accstr,string objs,string crncycode,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter)
begin
  val res;
  record POVc POr;
  row POVc POrw;
  string 60 fracc,toacc;
  Integer i,rwcnt;
  Boolean foundf,testf,newaccf;
  val rem,v;
  transaction string 5 keycurcod;
  transaction string 255 gKeyRn_columncod;
  transaction record TRVc gKeyRn_TRr;
  row TRVc TRrw;
  Integer tri,trrwcnt;
  record AccVc Accr;
  transaction integer gKeyRn_columntype;
  string 255 poobjects;
  
  fracc = FirstInRange(accstr,20);
  toacc = LastInRange(accstr,20);
  res = 0;
  POr.TransDate = sdp;
  foundf = true;
  while (LoopKey("TransDate",POr,1,foundf)) begin
    if (POr.TransDate>edp) then begin
      foundf = false;
    end;
    testf = foundf;
    if (POr.OKFlag==0) then begin testf = false; end;
    if (POr.Closed!=0) then begin testf = false; end;
    if (POr.PUFlag!=0) then begin testf = false; end;
    if (testf) then begin
      rwcnt = MatRowCnt(POr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(POr,i,POrw);
        testf = true;
        rem = POrw.Quant - POrw.Shipd2;
        if (rem>0) then begin
          if (nonblank(accstr)) then begin
            if (Left(POrw.CostAcc,len(fracc))<fracc or POrw.CostAcc>toacc) then begin
              testf = false;
            end;
          end;
          if (nonblank(objs)) then begin
            poobjects = AddStr(POr.Objects,POrw.Objects,",");
            if (!SetInSet(objs,poobjects)) then begin
              testf = false;
            end;
          end;
          if (testf) then begin
            if (POrw.Shipd2==0) then begin
              v = POrw.Sum;
            end else begin
              v = (rem * POrw.Price);
            end;
            res = res + v;
            if (v!=0) then begin
              newaccf = true;
              trrwcnt = MatRowCnt(gKeyRn_TRr);
              for (tri=0;tri<trrwcnt;tri=tri+1) begin
                MatRowGet(gKeyRn_TRr,tri,TRrw);
                if (TRrw.TFromFileName==gKeyRn_columncod) then begin
                  if (POrw.CostAcc==TRrw.AccNumber) then begin
                    TRrw.DebVal = TRrw.DebVal + v;
                    MatRowPut(gKeyRn_TRr,tri,TRrw);
                    newaccf = false;
                    SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,v);
                  end;
                end;
              end;
              if (newaccf) then begin
                Accr.AccNumber = POrw.CostAcc;
                ReadFirstMain(Accr,1,true);
                TRrw.AccNumber = POrw.CostAcc;
                TRrw.Comment = Accr.Comment;
                TRrw.Objects = POrw.Objects;
                TRrw.VATCode = POrw.VATCode;
                TRrw.DebVal =  v;
                TRrw.Typ = gKeyRn_columntype;
                MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
                SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,v);
              end;

 /*
          StartFormat(15);
          Outstring(0,0,"TRrw = " & POr.SerNr,false);
          Outstring(100,0,"TRrw.AccNumber = " & TRrw.AccNumber,false);
          Outstring(200,0,"TRrw.Comment = " & TRrw.Comment,false);
          Outstring(300,0,"TRrw.TFromFileName = " & TRrw.TFromFileName,false);
          Outstring(380,0,"sum = " & rem * POrw.Price,false);
          Outstring(1,0,"tot = " & res,true);
          EndFormat;
*/
            end;

          end;
        end;
      end;
    end;
  end;
  GetOpenPOSum = res;
  return;
end;

function val InvoicedQty(record POVc POr,row POVc POrw,Integer porownr)
begin
  val res;
  record VIVc VIr;
  row VIVc VIrw;
  Boolean pufound,found,testf;
  Integer i,rwcnt;

  VIr.POSerNr = POr.SerNr;
  found = true;
  while (LoopKey("POSerNr",VIr,1,found)) begin
    if (VIr.POSerNr!=POr.SerNr) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (VIr.OKFlag==0) then begin testf = false; end;
      if (testf) then begin
        rwcnt = MatRowCnt(VIr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(VIr,i,VIrw);
          if (VIrw.OrdRow==porownr) then begin
            pufound = true;
            res = res + VIrw.qty;
          end;
        end;
      end;
    end;
  end;

  if (pufound) then begin
    ResetLoop(VIr);
    found = true;
    while (LoopKey("RowPONr:" & POr.SerNr,VIr,1,found)) begin
      if (found) then begin
        testf = true;
        if (VIr.OKFlag==0) then begin testf = false; end;
        if (testf) then begin
          rwcnt = MatRowCnt(VIr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(VIr,i,VIrw);
            if (VIrw.OrdRow==porownr) then begin
              res = res + VIrw.qty;
            end;
          end;
        end;
      end;
    end;
  end;
  InvoicedQty = res;
  return;
end;

function val GetOpenGRSum(string accstr,string objs,string crncycode,Date sdp,Date edp,Integer basecurncy,Integer IncDaughter)
begin
  val res;
  record POVc POr;
  row POVc POrw;
  string 60 fracc,toacc;
  Integer i,rwcnt;
  Boolean foundf,testf,newaccf;
  val rem;
  transaction string 5 keycurcod;
  transaction string 255 gKeyRn_columncod;
  transaction record TRVc gKeyRn_TRr;
  row TRVc TRrw;
  Integer tri,trrwcnt;
  record AccVc Accr;
  vector Boolean vaccf;
  transaction integer gKeyRn_columntype;
  string 255 poobjects;
  
  newaccf = true;
  fracc = FirstInRange(accstr,20);
  toacc = LastInRange(accstr,20);
  res = 0;
  POr.TransDate = sdp;
  foundf = true;
  while (LoopKey("TransDate",POr,1,foundf)) begin
    if (POr.TransDate>edp) then begin
      foundf = false;
    end;
    testf = foundf;
    if (POr.OKFlag==0) then begin testf = false; end;
    if (POr.Closed!=0) then begin testf = false; end;
    if (POr.PUFlag!=0 and POr.PIFlag!=0) then begin testf = false; end;
    if (testf) then begin
      rwcnt = MatRowCnt(POr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(POr,i,POrw);
        testf = true;
        rem = POrw.Shipd2 - InvoicedQty(POr,POrw,i);
//        rem = POrw.Shipd2 - POrw.Invd;
        if (rem>0) then begin
          if (nonblank(accstr)) then begin
            if (Left(POrw.CostAcc,len(fracc))<fracc or POrw.CostAcc>toacc) then begin
              testf = false;
            end;
          end;
          if (nonblank(objs)) then begin
            poobjects = AddStr(POr.Objects,POrw.Objects,",");
            if (!SetInSet(objs,poobjects)) then begin
              testf = false;
            end;
          end;
          if (testf) then begin
            res = res + (rem * POrw.Price);

            if (rem * POrw.Price!=0) and (nonblank(POrw.CostAcc)) then begin
              newaccf = true;
              trrwcnt = MatRowCnt(gKeyRn_TRr);
              for (tri=0;tri<trrwcnt;tri=tri+1) begin
                MatRowGet(gKeyRn_TRr,tri,TRrw);
                if (TRrw.TFromFileName==gKeyRn_columncod) then begin
                  if (POrw.CostAcc==TRrw.AccNumber) then begin
                    vaccf[POrw.CostAcc] = true;
                    TRrw.DebVal = TRrw.DebVal + rem * POrw.Price;
                    MatRowPut(gKeyRn_TRr,tri,TRrw);
                    newaccf = false;
                    SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,rem * POrw.Price);
                  end;
                end;
              end;
              if (newaccf) then begin
                vaccf[POrw.CostAcc] = true;
                Accr.AccNumber = POrw.CostAcc;
                ReadFirstMain(Accr,1,true);
                TRrw.AccNumber = POrw.CostAcc;
                TRrw.Comment = Accr.Comment;
                TRrw.Objects = POrw.Objects;
                TRrw.VATCode = POrw.VATCode;
                TRrw.DebVal =  rem * POrw.Price;
                TRrw.Typ = gKeyRn_columntype;
                MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
                SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,rem * POrw.Price);
                newaccf = false;
              end;
            end;
/*
          StartFormat(15);
          Outstring(0,0,"GetOpenGRSum PO = " & POr.SerNr,false);
          Outstring(100,0,"line = " & i,false);
          Outstring(200,0,"testf = " & testf,false);
          Outstring(300,0,"TRrw.TFromFileName = " & TRrw.TFromFileName,false);
          Outstring(380,0,"sum = " & rem * POrw.Price,false);
          Outstring(1,0,"tot = " & res,true);
          EndFormat;
*/
          end;
        end;
      end;
    end;
  end;
  /*
          StartFormat(15);
          Outstring(0,0,"GetOpenGRSum ",false);
          EndFormat;
              trrwcnt = MatRowCnt(gKeyRn_TRr);
              for (tri=0;tri<trrwcnt;tri=tri+1) begin
                MatRowGet(gKeyRn_TRr,tri,TRrw);
          StartFormat(15);
          Outstring(100,0,"TRrw.AccNumber = " & TRrw.AccNumber,false);
          Outstring(200,0,"TRrw.TFromFileName = " & TRrw.TFromFileName,false);
          Outstring(300,0,"TRrw.DebVal = " & TRrw.DebVal,false);
          EndFormat;
              end;
*/    
/*
  if (newaccf) then begin
    foundf = true;
    Accr.AccNumber = fracc;
    while (LoopMain(Accr,1,foundf)) begin
      if (Accr.AccNumber>toacc) then begin foundf = false; end;
      if (foundf) then begin
        if (vaccf[Accr.AccNumber]==false) then begin
          TRrw.AccNumber = Accr.AccNumber;
          TRrw.Comment = Accr.Comment;
          TRrw.Objects = objs;
          TRrw.VATCode = "";
          TRrw.DebVal =  0.00;
          MatRowPut(gKeyRn_TRr,trrwcnt,TRrw);
          SetTransVal(TRrw.AccNumber & "," & keycurcod & "," & gKeyRn_columncod,0.00);
        end;
      end;
    end;
  end;
*/
  GetOpenGRSum = res;
  return;
end;

procedure KLPerBalExecute(string functionname,record RcVc RepSpec,string accstr,string object,var val dSbp,var val dPbp,var val dEbp,
                   var val cSbp,var val cPbp,var val cEbp,Integer keycoltype)
BEGIN
  record AccVc Accr;
  Boolean addflag;
  string 255 Nitem;
  string 255 Nitem2;
  string 5 nsep;
  Boolean Accs;
  Boolean testf,skipf;
  Integer np;
  Date ed;
  val prc;
  val v;
  Integer sorting;
  vector Boolean vaccusedf;

  if (GetOwnerPrc(RepSpec.sStartDate,ed,prc)) then begin end;
  dSbp = 0;
  dPbp = 0;
  dEbp = 0;
  cSbp = 0;
  cPbp = 0;
  cEbp = 0;
  np = 0;
  if (keycoltype>0) then begin
    skipf = true;
// This may need support for ConsAccNumber and percentage etc.
    Accr.AccNumber = accstr;
    Accs = ReadFirstMain(Accr,1,true);

//Trace("accstr " & accstr," TRrw.DebVal " & TRrw.DebVal & " Accr.AccNumber " & Accr.AccNumber);                

    switch (keycoltype) begin
      case kUserDefRepColumnTypeBudget:
        sorting = 0;
        if (nonblank(object)) then begin
          sorting = 1;
        end;
        skipf = false;
      case kUserDefRepColumnTypeRevBudget:
        sorting = 0;
        if (nonblank(object)) then begin
          sorting = 1;
        end;
        skipf = false;
      case kUserDefRepColumnTypePOCommitments:
        v = GetOpenPOSum(accstr,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter);
      case kUserDefRepColumnTypePUAccruals:
        v = GetOpenGRSum(accstr,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter);
    end;
    if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
      dPbp = v;
      dEbp = v;
    end else begin
      dPbp = v;
      dEbp = v;
      
//      cPbp = v;
//      cEbp = v;      
    end;
    if (skipf) then begin
      goto LKLPerBal;
    end;
  end;

  testf = GetNext3Sep(accstr,np,nsep);
  while (GetNextItem2(accstr,np,Nitem)) begin//  while (GetNextItem(accstr,&np,Nitem)) begin
    if (nsep=="-") then begin
      addflag = false; 
    end else begin
      addflag = true;
    end;  
    testf = GetNext3Sep(accstr,np,nsep);//    GetNextSep(accstr,&np,nsep);//JJ??
    if (nsep==":") then begin
      testf = GetNextItem2(accstr,np,Nitem2);//GetNextItem(accstr,&np,Nitem2);
      testf = GetNext3Sep(accstr,np,nsep);//      GetNextSep(accstr,&np,nsep);//JJ??
    end else begin
      Nitem2 = "";
    end;  
    if (blank(Nitem2)) then begin
      Accs = vaccusedf[Nitem]==false;
      if (Accs) then begin
        Accr.ConsAccNumber = Nitem;
        Accs = ReadFirstKey("ConsAccNumber",Accr,1,true);
      end;
      if ((Accs) and (Accr.GroupAcc==0)) then begin//(Accr.blockedFlag==false) and
        vaccusedf[Accr.AccNumber] = true;
        switch (keycoltype) begin
          case kUserDefRepColumnTypeBudget:
            v = Budg1Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
            if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end else begin
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end;
          case kUserDefRepColumnTypeRevBudget:
            v = Budg2Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
            if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end else begin
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end;
          otherwise
            KLPB2(functionname,RepSpec,Accr,object,dSbp,dPbp,dEbp,cSbp,cPbp,cEbp,addflag,prc);
        end;
      end;
     
      Accs = vaccusedf[Nitem]==false;
      if (Accs) then begin
        Accr.AccNumber = Nitem;
        Accs = ReadFirstMain(Accr,1,true);
      end;
      if ((Accs) and (Accr.GroupAcc==0) and ((blank(Accr.ConsAccNumber)) or (RepSpec.repname=="VAT2Rn"))) then begin//(Accr.blockedFlag==false) and
        vaccusedf[Accr.AccNumber] = true;
        switch (keycoltype) begin
          case kUserDefRepColumnTypeBudget:
            v = Budg1Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
            if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end else begin
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end;
          case kUserDefRepColumnTypeRevBudget:
            v = Budg2Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
            if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end else begin
              dPbp = dPbp + v;
              dEbp = dEbp + v;
            end;
          otherwise
            KLPB2(functionname,RepSpec,Accr,object,dSbp,dPbp,dEbp,cSbp,cPbp,cEbp,addflag,prc);
        end;
      end;
    end else begin
      Accr.ConsAccNumber = Nitem;
      ResetLoop(Accr);
      Accs = true;
      while (LoopKey("ConsAccNumber",Accr,1,Accs)) begin
        if (Accs==true) then begin
          if (Accr.ConsAccNumber>Nitem2) then begin
            Accs = false;
          end;
        end;
        if ((Accs) and (Accr.GroupAcc==0) and ((blank(Accr.ConsAccNumber)) or (RepSpec.repname=="VAT2Rn"))) then begin//(Accr.blockedFlag==false) and
        if (vaccusedf[Accr.AccNumber]==false) then begin
          vaccusedf[Accr.AccNumber] = true;
          switch (keycoltype) begin
            case kUserDefRepColumnTypeBudget:
              v = Budg1Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
              if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end else begin
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end;
            case kUserDefRepColumnTypeRevBudget:
              v = Budg2Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
              if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end else begin
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end;
            otherwise
              KLPB2(functionname,RepSpec,Accr,object,dSbp,dPbp,dEbp,cSbp,cPbp,cEbp,addflag,prc);
          end;
        end;
        end;
      end;

      Accr.AccNumber = Nitem;
      ResetLoop(Accr);
      Accs = true;
      while (LoopMain(Accr,1,Accs)) begin
        if (Accs==true) then begin
          if (Accr.AccNumber>Nitem2) then begin
            Accs = false;
          end;
        end;
        if ((Accs) and (Accr.GroupAcc==0)) then begin//(Accr.blockedFlag==false) and
        if (vaccusedf[Accr.AccNumber]==false) then begin
          vaccusedf[Accr.AccNumber] = true;
          switch (keycoltype) begin
            case kUserDefRepColumnTypeBudget:
              v = Budg1Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
              if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end else begin
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end;
            case kUserDefRepColumnTypeRevBudget:
              v = Budg2Calc(Accr.AccNumber,object,RepSpec.CurncyCode,RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.basecurncy,RepSpec.IncDaughter,sorting);
              if (Accr.AccType==kAccTypeAsset) or (Accr.AccType==kAccTypeExpense) then begin // Wierd, but I guess should exist in both result and balance variables....
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end else begin
                dPbp = dPbp + v;
                dEbp = dEbp + v;
              end;
            otherwise
              KLPB2(functionname,RepSpec,Accr,object,dSbp,dPbp,dEbp,cSbp,cPbp,cEbp,addflag,prc);
          end;
        end;
      end;
      end;
    end;
  end;
LKLPerBal:;
  if (Left(functionname,3)=="Avg") then begin
    v = DateGetIntMonth(RepSpec.sEndDate) - DateGetIntMonth(RepSpec.sStartDate) + 1;
    dSbp = dSbp/v;
    dPbp = dPbp/v;
    dEbp = dEbp/v;
    cSbp = cSbp/v;
    cPbp = cPbp/v;
    cEbp = cEbp/v;
  end;
  return;
end;

global
procedure KLPerBal(string functionname,record RcVc RepSpec,string accstr,string object,var val dSbp,var val dPbp,var val dEbp,
                   var val cSbp,var val cPbp,var val cEbp,Integer keycoltype)
begin
  KLPerBalExecute(functionname,RepSpec,accstr,object,dSbp,dPbp,dEbp,cSbp,cPbp,cEbp,keycoltype);
  return;
end;

global
procedure KLIVGetPaidVal(record IVVc IVp,var val paidp,var val credited,Date untildatp)
BEGIN
  record IPrsVc IPrsr;
  record PurgeTRVc PurgeTRr;
  record TRVc TRr;
  record CLInVc CLInr;
  row TRVc TRrw;
  row CLInVc CLInrw;
  record IVVc IVr;
  record CredManVc CredManr;
  Boolean found,testf;
  val t,t2;
  Integer i,rwcnt,oldstyle;
  row IVVc IVrw;
  vector Boolean alreadycnted;

  paidp = blankval;
  credited = blankval;
  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    if (IVrw.stp==6) then begin
      paidp = paidp + IVrw.Sum;
    end;
  end;  

  IPrsr.IVNr = IVp.SerNr;
  IPrsr.TransType = kIPrsTransTypeInvoice;
  found = true;
  while (LoopKey("IVKey",IPrsr,2,found)) begin
    if (IPrsr.IVNr!=IVp.SerNr) then begin found = false; end;
    testf = true;
    if (nonblankdate(untildatp)) then begin
      if (IPrsr.TransDate>untildatp) then begin testf = false; end;
    end;
    if (alreadycnted[IPrsr.TransType & "." & IPrsr.TransNr]) then begin 
      testf = false;
    end;
    if (found and testf) then begin
      alreadycnted[IPrsr.TransType & "." & IPrsr.TransNr] = true;
      switch (IPrsr.TransType) begin
        case kIPrsTransTypeInvoice:
          IVr.SerNr = IPrsr.TransNr;
          if (ReadFirstMain(IVr,1,true)) then begin
            if (IVr.Invalid==0) then begin
              if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) and (IVr.CredInv>0) then begin
//                paidp = paidp + IVr.Sum4;
                credited = credited + IVr.Sum4;
              end;
            end;
          end;
        case kIPrsTransTypeReceipt:
          PSFindPaydAmount(IPrsr,t);
          paidp = paidp + t;
        case kIPrsTransTypePurgeNLTransaction:
          PurgeTRr.Number = IPrsr.TransNr;
          PurgeTRr.IntYc = GetIntYc(IPrsr.TransDate);
          PurgeTRr.TransRow = IPrsr.TransRow;
          if (ReadFirstMain(PurgeTRr,3,true)) then begin
            if (PurgeTRr.SerNr==IPrsr.IVNr) then begin
              t = PurgeTRr.CurCredVal - PurgeTRr.CurDebVal;
              if (TypeOfCurncy(PurgeTRr.Curncy,oldstyle)==2) then begin
                t2 = PurgeTRr.CredVal2 - PurgeTRr.DebVal2;
              end else begin
                t2 = PurgeTRr.CredVal - PurgeTRr.DebVal;
              end;
              if ((PurgeTRr.CurDebVal==blankval) and (PurgeTRr.CurCredVal==blankval)) then begin
                t = t2;
              end;
              paidp = paidp + t;
            end;
          end;
        case kIPrsTransTypeNLTransaction:
          TRr.Number = IPrsr.TransNr;
          TRr.IntYc = GetIntYc(IPrsr.TransDate);
          if (ReadFirstMain(TRr,2,true)) then begin
            rwcnt = MatRowCnt(TRr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              if (TRrw.ovst==0) then begin
                if (TRrw.stp==1) then begin
                  if (TRrw.SerNr==IPrsr.IVNr) then begin
                    t = TRrw.CurCredVal - TRrw.CurDebVal;
                    if (TypeOfCurncy(TRrw.Curncy,oldstyle)==2) then begin
                      t2 = TRrw.CredVal2 - TRrw.DebVal2;
                    end else begin
                      t2 = TRrw.CredVal - TRrw.DebVal;
                    end;
                    if ((TRrw.CurDebVal==blankval) and (TRrw.CurCredVal==blankval)) then begin
                      t = t2;
                    end;
                    paidp = paidp + t;
                  end;
                end;
              end;
            end;
          end;
        case kIPrsTransTypeCashIn:
          CLInr.SerNr = IPrsr.TransNr;
          if (ReadFirstMain(CLInr,1,true)) then begin
            if (CLInr.Invalid==0) then begin
              rwcnt = MatRowCnt(CLInr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(CLInr,i,CLInrw);
                if (CLInrw.Type==1) then begin
                  if (CLInrw.TransNr==IVp.SerNr) then begin
                    t = CLInrw.Sum;
                    paidp = paidp + t;
                  end;
                end;
              end;
            end;
          end;                    
        case kIPrsTransTypeCredMan:
          CredManr.SerNr = IPrsr.TransNr;
          if (ReadFirstMain(CredManr,1,true)) then begin
            if (CredManr.Invalid==0) then begin
              t = CredManr.InvSum4;
              paidp = paidp + t;
            end;
          end;                    
      end;
    end;
  end;
  RETURN;
END;

global
function val KLGetARBal2(Integer basecurncy,Date untildatp,string daysoverduestr,Boolean skipreminders,Boolean skipdisputed,Boolean printf,Integer keycoltype,Boolean inclclosedf,string forperson,string curncycode)
BEGIN
  val res;
//  record RcVc RepSpec;
  record CUVc CUr;
  record IVVc IVr;
  record IVVc IV2r;
  record SMVc Dummyr;
  Boolean found,found2,testf;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,credited;
  Date dat;
  LongInt daysoverdue;
  string 255 index;

//  RecordNew(RepSpec);
//  RepSpec.d1 = untildatp;
  daysoverdue = StringToVal(daysoverduestr,M4UVal);
  res = blankval;
  if (keycoltype>0) then begin
    goto LKLGetARBal2;
  end;
  dat = AddDay(untildatp,-daysoverdue);
  found = true;
  CUr.Code = "";
//  CUr.CUType = 1;
  index = "ActCode";
  if (inclclosedf) then begin
    index = "Code";
  end;
  while (LoopKey(index,CUr,1,found)) begin
    found2 = found;
    if (CUr.CUType==0) then begin found2 = false; end;
    IVr.CustCode = CUr.Code;
    ResetLoop(IVr);
    while (LoopKey("CustCode",IVr,1,found2)) begin
      if (IVr.CustCode!=CUr.Code) then begin
        found2 = false;
      end;  
      testf = true;
      if (IVr.TransDate>untildatp) then begin testf = false; end;  
      if (IVr.PayDate>=dat) then begin testf = false; end;
      if (IVr.OKFlag==0) then begin testf = false; end;
      if (IVr.Invalid!=0) then begin testf = false; end;
      if (found2==false) then begin testf = false; end;
      if (IVr.InvType==kInvoiceTypePrepayment) then begin testf = false; end;
      if (IVr.InvType==kInvoiceTypeCash or IVr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin testf = false; end;
      if (nonblank(forperson)) then begin
        if (SetInSet(IVr.SalesMan,forperson)==false) then begin testf = false; end;
        if (blank(IVr.SalesMan)) then begin testf = false; end;
      end;
      if (skipreminders) then begin
        if (IVr.NoRemndrFlag!=0) then begin
          testf = false;
        end;
      end;
      if (skipdisputed) then begin
        if (IVr.DisputedFlag!=0) then begin
          testf = false;
        end;
      end;
      if (IVr.InvType==kInvoiceTypeCredit or IVr.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (IVr.CredInv>0) then begin
          testf = false;
          IV2r.SerNr = IVr.CredInv;
          if (ReadFirstMain(IV2r,1,true)) then begin
//            if (IV2r.InvType==kInvoiceTypeCash) then begin
              testf = false;
//            end;
          end; 
        end;
      end;
      if (testf) then begin
        KLIVGetPaidVal(IVr,t3,credited,untildatp);
        t3 = t3 + credited;
        switch(IVr.InvType) begin
          case kInvoiceTypeCredit:
            t2 = -IVr.Sum4;
          case kInvoiceTypeCreditSpecialSales:
            t2 = -IVr.Sum4;
          otherwise
            t2 = IVr.Sum4;
        end;
        baseopen = t2 - t3;
        if (nonblank(curncycode)) then begin
          CurValToOtherCur(CurrentDate,IVr.CurncyCode,t2,curncycode,t2,DefaultCurRoundOff);
        end else begin
          switch (basecurncy) begin
            case 0:
              baseopen = MulRateToBase1(IVr.CurncyCode,baseopen,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
            case 1:
              baseopen = MulRateToBase2(IVr.CurncyCode,baseopen,IVr.FrRate,IVr.ToRateB1,IVr.ToRateB2,IVr.BaseRate1,IVr.BaseRate2,DefaultCurRoundOff);
          end;
        end;
        res = res + baseopen;
        if (printf and baseopen!=0) then begin
          StartFormat(15);
          OutStringID(20,"DblKeyIVInfo",IVr.SerNr,false,CurrentCompany);
          OutString(70,0,IVr.TransDate,false);
          OutString(130,0,IVr.PayDate,false);
          OutString(190,0,IVr.CustCode,false);
          OutString(250,0,IVr.Addr0,false);
          OutVal(1,0,baseopen,M4Val,true);
          EndFormat;
        end;
      end;
    end;
/*
    if (found) then begin
      GetOnAccBalance(RepSpec,CUr.Code,CUr.CurncyCode,true,1,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,Dummyr);
      res = res + baseopen;
    end;
*/
  end;
LKLGetARBal2:;
  KLGetARBal2 = res;
  RETURN;
END;

global
function val KLGetARBal(Integer basecurncy,Date untildatp,string daysoverduestr,Boolean skipreminders,Boolean skipdisputed,Boolean printf,Integer keycoltype,Boolean inclclosedf,string forperson)
begin
  KLGetARBal = KLGetARBal2(basecurncy,untildatp,daysoverduestr,skipreminders,skipdisputed,printf,keycoltype,inclclosedf,forperson,"");
  return;
end;

global
function val KLGetAROnAcc(Integer basecurncy,Date untildatp,Integer keycoltype,string forperson)
begin
  val res;
  record RcVc RepSpec;
  record CUVc CUr;
  Boolean found,testf;
  record SMVc Dummyr;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff;
  Date dat;
  LongInt daysoverdue;
  Array string 10 debaccs;
  Array val debbal;
  Integer debcnt;

  RecordNew(RepSpec);
  RepSpec.d1 = untildatp;
  res = blankval;
  if (keycoltype>0) then begin
    goto LKLGetAROnAcc;
  end;
  found = true;
  CUr.Code = "";
  CUr.CUType = 1;
  while (LoopKey("ActCode",CUr,1,found)) begin
    if (CUr.CUType==0) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(forperson)) then begin
        if (SetInSet(CUr.SalesMan,forperson)==false) then begin testf = false; end;
        if (blank(CUr.SalesMan)) then begin testf = false; end;
      end;
      if (testf) then begin
        GetOnAccBalance(RepSpec,CUr.Code,CUr.CurncyCode,true,1,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,Dummyr,debaccs,debbal,debcnt);
        switch (basecurncy) begin
          case 1:
            res = res + t2;
          otherwise
            res = res + baseopen;
        end;
      end;
    end;
  end;
LKLGetAROnAcc:;
  KLGetAROnAcc = res;
  return;
end;

global
procedure APFindPaydAmount(record OPrsVc OPrsp,var val ap)
BEGIN
  record OPVc OPr;
  row OPVc OPrw;
  Integer i,rwcnt;
  
  ap = blankval;
  OPr.SerNr = OPrsp.TransNr;
  if (ReadFirstMain(OPr,1,true)) then begin
    if ((OPr.Invalid==0) and (OPr.RejectedFlag==0) and (OPr.OrderedFlag!=0)) then begin
      if (OPr.TransDate==OPrsp.TransDate) then begin
        rwcnt = MatRowCnt(OPr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(OPr,i,OPrw);
          if ((OPrw.ovst==0)) then begin
            if (OPrw.VISerNr==OPrsp.VINr) then begin
              if ((OPrw.stp==kPaymentRowTypeNormal) or (OPrw.stp==kPaymentRowTypeSettlementDiscount)) then begin
                ap = ap + OPrw.PInvVal;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure KLVIGetPaidVal(record VIVc VIp,var val paidp,Date untildatp)
BEGIN
  record VIVc VIr;
  row VIVc VIrw;
  record OPrsVc OPrsr;
  record PurgeTRVc PurgeTRr;
  record TRVc TRr;
  row TRVc TRrw;
  record CLOutVc CLOutr;
  row CLOutVc CLOutrw;
  Boolean found,testf;
  val t,t2;
  Integer i,rwcnt,oldstyle;

  paidp = blankval;
  rwcnt = MatRowCnt(VIp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(VIp,i,VIrw);
    if (VIrw.stp==6) then begin
      paidp = paidp + VIrw.PrepayAmount;
    end;
  end;  
  OPrsr.VINr = VIp.SerNr;
  OPrsr.TransType = 0;
  found = true;
  while (LoopKey("VIKey",OPrsr,2,found)) begin
    if (OPrsr.VINr!=VIp.SerNr) then begin found = false; end;
    testf = true;
    if (OPrsr.TransDate>untildatp) then begin testf = false; end;
    if (found and testf) then begin
      switch (OPrsr.TransType) begin
        case 0:
          VIr.SerNr = OPrsr.TransNr;
          if (ReadFirstMain(VIr,1,true)) then begin
            if (VIr.Invalid==0) then begin
              if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) and (VIr.CredInv>0) then begin
                paidp = paidp + VIr.PayVal;
              end;
            end;
          end;
        case 1:
          APFindPaydAmount(OPrsr,t);
          paidp = paidp + t;
        case kOPrsTransTypePurgeNLTransaction:
          PurgeTRr.Number = OPrsr.TransNr;
          PurgeTRr.IntYc = GetIntYc(OPrsr.TransDate);
          if (ReadFirstMain(PurgeTRr,3,true)) then begin
            if (PurgeTRr.SerNr==VIp.SerNr) then begin
              t = PurgeTRr.CurDebVal - PurgeTRr.CurCredVal;
              if (TypeOfCurncy(PurgeTRr.Curncy,oldstyle)==2) then begin
                t2 = PurgeTRr.DebVal2 - PurgeTRr.CredVal2;
              end else begin
                t2 = PurgeTRr.DebVal - PurgeTRr.CredVal;
              end;
              if ((PurgeTRr.CurDebVal==blankval) and (PurgeTRr.CurCredVal==blankval)) then begin
                t = t2;
              end;
              paidp = paidp + t;
            end;
          end;
        case kOPrsTransTypeNLTransaction:
          TRr.Number = OPrsr.TransNr;
          TRr.IntYc = GetIntYc(OPrsr.TransDate);
          if (ReadFirstMain(TRr,2,true)) then begin
            rwcnt = MatRowCnt(TRr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(TRr,i,TRrw);
              if (TRrw.ovst==0) then begin
                if (TRrw.stp==1) then begin
                  if (TRrw.SerNr==VIp.SerNr) then begin
                    t = TRrw.CurDebVal - TRrw.CurCredVal;
                    if (TypeOfCurncy(TRrw.Curncy,oldstyle)==2) then begin
                      t2 = TRrw.DebVal2 - TRrw.CredVal2;
                    end else begin
                      t2 = TRrw.DebVal - TRrw.CredVal;
                    end;
                    if ((TRrw.CurDebVal==blankval) and (TRrw.CurCredVal==blankval)) then begin
                      t = t2;
                    end;
                    paidp = paidp + t;
                  end;
                end;
              end;
            end;
          end;
        case 3:
          CLOutr.SerNr = OPrsr.TransNr;
          if (ReadFirstMain(CLOutr,1,true)) then begin
            if (CLOutr.Invalid==0) then begin
              rwcnt = MatRowCnt(CLOutr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(CLOutr,i,CLOutrw);
                if (CLOutrw.Type==1 or CLOutrw.Type==2) then begin
                  if (CLOutrw.TransNr==VIp.SerNr) then begin
                    t = CLOutrw.Sum;
                    paidp = paidp + t;
                  end;
                end;
              end;
            end;
          end;                              
      end;
    end;
  end;
  RETURN;
END;

global
function val KLGetAPOnAcc(Integer basecurncy,Date untildatp,Integer keycoltype,string forperson)
begin
  val res;
  record RcVc RepSpec;
  record CUVc VEr;
  Boolean found,testf;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff;
  Date dat;
  LongInt daysoverdue;
  Array string 10 credaccs;
  Array val credbal;
  Integer credcnt;
  array val av1;
  array string 20 acur;
  Integer curcnt;

  RecordNew(RepSpec);
  RepSpec.d1 = untildatp;
  res = blankval;
  if (keycoltype>0) then begin
    goto LKLGetAPOnAcc;
  end;
  found = true;
  VEr.Code = "";
  VEr.VEType = 1;
  while (LoopKey("VEActCode",VEr,1,found)) begin
    if (VEr.VEType==0) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(forperson)) then begin
        if (SetInSet(VEr.SalesMan,forperson)==false) then begin testf = false; end;
        if (blank(VEr.SalesMan)) then begin testf = false; end;
      end;
      if (testf) then begin
        APGetOnAccBalance(RepSpec,VEr,true,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff,credaccs,credbal,credcnt,acur,av1,curcnt);
        switch (basecurncy) begin
          case 1:
            res = res + t2;
          otherwise
            res = res + baseopen;
        end;
      end;
    end;
  end;
LKLGetAPOnAcc:;
  KLGetAPOnAcc = res;
  return;
end;

global
function val KLGetAPBal2(Integer basecurncy,Date untildatp,string daysoverduestr,Boolean printf,Boolean skiponholdf,Integer keycoltype,Boolean inclclosedf,string forperson,string curncycode)
begin
  val res;
  record RcVc RepSpec;
  record CUVc VEr;
  record VIVc VIr;
  record VIVc VI2r;
  Boolean found,found2,testf;
  val baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff;
  Date dat;
  LongInt daysoverdue;
  val a,b;
  string 255 index;

  RecordNew(RepSpec);
  RepSpec.d1 = untildatp;
  daysoverdue = StringToVal(daysoverduestr,M4UVal);
  res = blankval;
  if (keycoltype>0) then begin
    goto LKLGetAPBal2;
  end;
  dat = AddDay(untildatp,-daysoverdue);
  found = true;
  VEr.Code = "";
//  VEr.VEType = 1;
  index = "VEActCode";
  if (inclclosedf) then begin
    index = "Code";
  end;
  while (LoopKey(index,VEr,1,found)) begin
    found2 = found;
    if (VEr.VEType==0) then begin found2 = false; end;
    VIr.VECode = VEr.Code;
    ResetLoop(VIr);
    while (LoopKey("VECode",VIr,1,found2)) begin
      if (VIr.VECode!=VEr.Code) then begin found2 = false; end;
      testf = true;
      if (VIr.TransDate>untildatp) then begin testf = false; end;
      if (VIr.DueDate>=dat) then begin testf = false; end;
      if (VIr.OKFlag==0) then begin testf = false; end;
      if (VIr.Invalid!=0) then begin testf = false; end;
      if (VIr.InvType==kInvoiceTypeEmployee or VIr.InvType==kInvoiceTypeCash or VIr.InvType==kInvoiceTypeCashInvoiceReceiptPRT) then begin testf = false; end;
      if (nonblank(forperson)) then begin
        if (SetInSet(VIr.SalesMan,forperson)==false) then begin testf = false; end;
        if (blank(VIr.SalesMan)) then begin testf = false; end;
      end;
      if (found2==false) then begin testf = false; end;
      if (skiponholdf) then begin
        if (VIr.Closed==2) then begin testf = false; end;
      end;
      if (VIr.InvType==kInvoiceTypeCredit or VIr.InvType==kInvoiceTypeCreditSpecialSales) then begin
        if (VIr.CredInv>0) then begin
          testf = false;
          VI2r.SerNr = VIr.CredInv;
          if (ReadFirstMain(VI2r,1,true)) then begin
//            if (VI2r.InvType==kInvoiceTypeCash) then begin
              testf = false;
//            end;
          end; 
        end;
      end;
      if (testf) then begin
        KLVIGetPaidVal(VIr,baseopen,untildatp);
        a = baseopen;
        switch(VIr.InvType) begin
          case kInvoiceTypeCredit:
            t2 = -VIr.PayVal;
          case kInvoiceTypeCreditSpecialSales:
            t2 = -VIr.PayVal;
          otherwise
            t2 = VIr.PayVal;
        end;
        baseopen = t2 - baseopen;
        b = baseopen;
        if (nonblank(curncycode)) then begin
          CurValToOtherCur(CurrentDate,VIr.CurncyCode,baseopen,curncycode,baseopen,DefaultCurRoundOff);
        end else begin
          switch (basecurncy) begin
            case 1:
              baseopen = MulRateToBase2(VIr.CurncyCode,baseopen,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
            otherwise
              baseopen = MulRateToBase1(VIr.CurncyCode,baseopen,VIr.FrRate,VIr.ToRateB1,VIr.ToRateB2,VIr.BaseRate1,VIr.BaseRate2,DefaultCurRoundOff);
          end;
        end;
        res = res + baseopen;
        if (printf and baseopen!=0) then begin
          StartFormat(15);
          OutStringID(20,"DblKeyVIInfo",VIr.SerNr,false,CurrentCompany);
          OutString(70,0,VIr.TransDate,false);
          OutString(130,0,VIr.DueDate,false);
          OutString(190,0,VIr.VECode,false);
          OutString(250,0,VIr.VEName,false);
          OutVal(1,0,baseopen,M4Val,true);
          EndFormat;
        end;
/*
if ((baseopen!=0) and (daysoverdue<0)) then begin
StartFormat(15);
OutString(0,"DblVIVc",VIr.SerNr,false);
OutVal(120,0,a,M4Val,true);
OutVal(200,0,b,M4Val,true);
OutVal(280,0,baseopen,M4Val,true);
OutVal(1,0,res,M4Val,true);
EndFormat;
end;
*/
        RepSpec.d1 = untildatp;
      end;
    end;
/*
    if (found) then begin
      APGetOnAccBalance(RepSpec,VEr,true,baseopen,t2,t3,sumbooked,sumnow,sumcurncy,sumdiff);
      res = res + baseopen;
    end;
*/
  end;
LKLGetAPBal2:;
  KLGetAPBal2 = res;
  return;
end;

global
function val KLGetAPBal(Integer basecurncy,Date untildatp,string daysoverduestr,Boolean printf,Boolean skiponholdf,Integer keycoltype,Boolean inclclosedf,string forperson)
begin
  KLGetAPBal = KLGetAPBal2(basecurncy,untildatp,daysoverduestr,printf,skiponholdf,keycoltype,inclclosedf,forperson,"");
  return;
end;

function val KLGetAPPaidResult_TRVc(Boolean debside,Integer basecurncy,string custcode,LongInt sernr,Integer yc,string fracc,string toacc)
begin
  val res;
  record TRVc TRr;
  row TRVc TRrw;
  Integer i,rwcnt;
  Boolean testf;
  
  TRr.Number = sernr;
  TRr.IntYc = yc;
  if (ReadFirstMain(TRr,2,true)) then begin
    rwcnt = MatRowCnt(TRr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(TRr,i,TRrw);
      testf = true;
      if ((TRrw.AccNumber<fracc) or (TRrw.AccNumber>toacc)) then begin
        testf = false;
      end;
      if (nonblank(custcode)) then begin
        if (TRrw.CompCode!=custcode) then begin testf = false; end;
      end;
      if (testf) then begin
        switch (basecurncy) begin
          case 0: 
            if (debside) then begin
              res = res + (TRrw.DebVal - TRrw.CredVal);
            end else begin
              res = res + (TRrw.CredVal - TRrw.DebVal);
            end;
          case 1: 
            if (debside) then begin
              res = res + (TRrw.DebVal2 - TRrw.CredVal2);
            end else begin
              res = res + (TRrw.CredVal2 - TRrw.DebVal2);
            end;
        end;
      end;
    end;
  end;
  KLGetAPPaidResult_TRVc = res;
  return;
end;

global
function val KLGetAPPaidResult(Integer basecurncy,Date startdate,Date enddate,string accounts,string suppliers,string class)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean found,testf,test2f;
  string 255 frve,tove;
  string 255 fracc,toacc;
  string 255 keystr;
  Integer segs;
  Integer vi,virwcnt;
  row VIVc VIrw;
  record VIVc VIr;
  record VIVc orgVIr;
  record OPVc OPr;
  row OPVc OPrw;
  record CLOutVc CLOutr;  
  Integer i,rwcnt;
  record CUVc VEr;
  val t;
  vector Boolean vPaymentTreatedf;
  
  fracc = FirstInRange(accounts,10);
  toacc = LastInRange(accounts,10);
  frve = FirstInRange(suppliers,20);
  tove = LastInRange(suppliers,20);
  OPrsr.TransDate = startdate;
  if (nonblank(suppliers)) then begin
    OPrsr.VECode = frve;
    keystr = "MainKey";
    segs = 2;
  end else begin
    keystr = "TransDate";
    segs = 1;
  end;
  found = true;
  while (LoopKey(keystr,OPrsr,segs,found)) begin
    if (nonblank(suppliers)) then begin
      if (OPrsr.VECode>tove) then begin found = false; end;
    end else begin
      if (DateInRange(OPrsr.TransDate,startdate,enddate)==false) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (DateInRange(OPrsr.TransDate,startdate,enddate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        if (nonblank(class)) then begin
          VEr.Code = OPrsr.VECode;
          if (ReadFirstMain(VEr,1,true)) then begin
            if (SetInSet(class,VEr.Classification)==false) then begin
              testf = false;
            end;
          end;
        end;
      end;
      if (testf) then begin
        switch (OPrsr.TransType) begin
          case kOPrsTransTypeInvoice:
            VIr.SerNr = OPrsr.TransNr;
            if (ReadFirstMain(VIr,1,true)==false) then begin
              if (VIr.Invalid==0) then begin
                switch (VIr.InvType) begin
                  case kInvoiceTypeCashInvoiceReceiptPRT:
                    res = res + KLGetAPPaidResult_TRVc(false,basecurncy,VIr.VECode,VIr.SerNr,VIYc,fracc,toacc);
                  case kInvoiceTypeCash:
                    res = res + KLGetAPPaidResult_TRVc(false,basecurncy,VIr.VECode,VIr.SerNr,VIYc,fracc,toacc);
                  case kInvoiceTypeEmployee:
                    res = res + KLGetAPPaidResult_TRVc(false,basecurncy,VIr.VECode,VIr.SerNr,VIYc,fracc,toacc);
                  case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
                  case kInvoiceTypeCredit:
                    LkInvoiceTypeCredit:;
                    orgVIr.SerNr = VIr.CredInv;
                    if (ReadFirstMain(orgVIr,1,true)) then begin
                      if (orgVIr.Invalid==0) then begin
                        switch (orgVIr.InvType) begin
                          case kInvoiceTypeCash:
                            res = res + KLGetAPPaidResult_TRVc(false,basecurncy,orgVIr.VECode,orgVIr.SerNr,VIYc,fracc,toacc);
                          case kInvoiceTypeEmployee:
                            res = res + KLGetAPPaidResult_TRVc(false,basecurncy,orgVIr.VECode,orgVIr.SerNr,VIYc,fracc,toacc);
                        end;
                      end;
                    end;
                end;
              end;
            end;
          case kOPrsTransTypePayment:
            if (vPaymentTreatedf[OPrsr.TransNr & "??" & OPrsr.VECode]==false) then begin
              OPr.SerNr = OPrsr.TransNr;
              if (ReadFirstMain(OPr,1,true)) then begin
                if (OPr.Invalid==0) then begin
                  rwcnt = MatRowCnt(OPr);
                  for (i=0;i<rwcnt;i=i+1) begin
                    MatRowGet(OPr,i,OPrw);
                    testf = true;
                    if (OPrw.ovst!=0) then begin testf = false; end;
                    if (testf) then begin
                      switch (OPrw.stp) begin
                        case kPaymentRowTypeNormal:
                          if (OPrw.VISerNr>0) then begin
                            if (vPaymentTreatedf[OPrsr.TransNr & "??" & OPrsr.VECode]==false) then begin
                              vPaymentTreatedf[OPrsr.TransNr & "??" & OPrsr.VECode] = true;
                              VIr.SerNr = OPrw.VISerNr;
                              if (ReadFirstMain(VIr,1,true)) then begin
                                if (VIr.Invalid==0) then begin
                                  switch (VIr.InvType) begin
                                    case kInvoiceTypeCash:
                                    case kInvoiceTypeEmployee:
                                    case kInvoiceTypeCreditSpecialSales: 
                                      goto LkInvoiceTypeCredit;
                                    case kInvoiceTypeCredit:
LkInvoiceTypeCredit:;
                                      orgVIr.SerNr = VIr.CredInv;
                                      if (ReadFirstMain(orgVIr,1,true)) then begin
                                        if (orgVIr.Invalid==0) then begin
                                          switch (orgVIr.InvType) begin
                                            case kInvoiceTypeCash:
                                            case kInvoiceTypeEmployee:
                                            otherwise
                                              res = res + KLGetAPPaidResult_TRVc(false,basecurncy,orgVIr.VECode,orgVIr.SerNr,VIYc,fracc,toacc);
                                          end;
                                        end;
                                      end;
                                    otherwise
                                      test2f = false;
                                      virwcnt = MatRowCnt(VIr);
                                      for (vi=0;vi<virwcnt;vi=vi+1) begin
                                        MatRowGet(VIr,vi,VIrw);
                                        if (VIrw.AccNumber>=fracc) and (VIrw.AccNumber<=toacc) then begin
                                          test2f = true;
                                          vi = virwcnt;
                                        end;
                                      end;
                                      if (test2f) then begin
                                        res = res + KLGetAPPaidResult_TRVc(false,basecurncy,OPrsr.VECode,OPr.SerNr,OPYc,VIr.APAcc,VIr.APAcc);//fracc,toacc, changed to VIr.APAcc cause cost account doesnt show up on payment
                                      end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          case kOPrsTransTypeCashOut:
        end;
      end;
    end;
  end;
  KLGetAPPaidResult = res;
  return;
end;

global
function val KLGetAPResult(Integer basecurncy,Date startdate,Date enddate,string accounts,string suppliers,string class)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean found,testf;
  string 255 frve,tove;
  string 255 fracc,toacc;
  string 255 keystr;
  Integer segs;
  record VIVc VIr;
  record VIVc orgVIr;
  Integer i,rwcnt;
  record CUVc VEr;
  
  fracc = FirstInRange(accounts,10);
  toacc = LastInRange(accounts,10);
  frve = FirstInRange(suppliers,20);
  tove = LastInRange(suppliers,20);
  OPrsr.TransDate = startdate;
  if (nonblank(suppliers)) then begin
    OPrsr.TransType = kOPrsTransTypeInvoice;
    OPrsr.VECode = frve;
    keystr = "TransType";
    segs = 2;
  end else begin
    keystr = "TransDate";
    segs = 1;
  end;
  found = true;
  while (LoopKey(keystr,OPrsr,segs,found)) begin
    if (nonblank(suppliers)) then begin
      if (OPrsr.TransType!=kOPrsTransTypeInvoice) then begin found = false; end;
      if (OPrsr.VECode>tove) then begin found = false; end;
    end else begin
      if (DateInRange(OPrsr.TransDate,startdate,enddate)==false) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (OPrsr.TransType!=kOPrsTransTypeInvoice) then begin testf = false; end;
      if (DateInRange(OPrsr.TransDate,startdate,enddate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        if (nonblank(class)) then begin
          VEr.Code = OPrsr.VECode;
          if (ReadFirstMain(VEr,1,true)) then begin
            if (SetInSet(class,VEr.Classification)==false) then begin
              testf = false;
            end;
          end;
        end;
      end;
      if (testf) then begin
        switch (OPrsr.TransType) begin
          case kOPrsTransTypeInvoice:
            VIr.SerNr = OPrsr.TransNr;
            if (ReadFirstMain(VIr,1,true)) then begin
              if (VIr.Invalid==0) then begin
                res = res + KLGetAPPaidResult_TRVc(false,basecurncy,"",VIr.SerNr,VIYc,fracc,toacc);
              end;
            end;
        end;
      end;
    end;
  end;
  KLGetAPResult = res;
  return;
end;

global
function val KLGetARPaidResult(Integer basecurncy,Date startdate,Date enddate,string accounts,string customers,string class)
begin
  val res;
  record IPrsVc IPrsr;
  Boolean found,testf;
  string 255 frcu,tocu;
  string 255 fracc,toacc;
  string 255 keystr;
  Integer segs;
  record IVVc IVr;
  record IVVc orgIVr;
  record IPVc IPr;
  row IPVc IPrw;
  record CLInVc CLINr;  
  Integer i,rwcnt;
  record CUVc CUr;
  vector Boolean vReceiptTreatedf;
  
  fracc = FirstInRange(accounts,10);
  toacc = LastInRange(accounts,10);
  frcu = FirstInRange(customers,20);
  tocu = LastInRange(customers,20);
  IPrsr.TransDate = startdate;
  if (nonblank(customers)) then begin
    IPrsr.CustCode = frcu;
    keystr = "MainKey";
    segs = 1;
  end else begin
    keystr = "TransDate";
    segs = 1;
  end;
  found = true;
  while (LoopKey(keystr,IPrsr,segs,found)) begin
    if (nonblank(customers)) then begin
      if (IPrsr.CustCode>tocu) then begin found = false; end;
    end else begin
      if (DateInRange(IPrsr.TransDate,startdate,enddate)==false) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (DateInRange(IPrsr.TransDate,startdate,enddate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        if (nonblank(class)) then begin
          CUr.Code = IPrsr.CustCode;
          if (ReadFirstMain(CUr,1,true)) then begin
            if (SetInSet(class,CUr.Classification)==false) then begin
              testf = false;
            end;
          end;
        end;
      end;
      if (testf) then begin
        switch (IPrsr.TransType) begin
          case kIPrsTransTypeInvoice:
            IVr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(IVr,1,true)) then begin
              if (IVr.Invalid==0) then begin
                switch (IVr.InvType) begin
                  case kInvoiceTypeCash:
                    res = res + KLGetAPPaidResult_TRVc(false,basecurncy,IVr.CustCode,IVr.SerNr,IVYc,fracc,toacc);
                  case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
                  case kInvoiceTypeCredit:
                    LkInvoiceTypeCredit:;
                    orgIVr.SerNr = IVr.CredInv;
                    if (ReadFirstMain(orgIVr,1,true)) then begin
                      if (orgIVr.Invalid==0) then begin
                        switch (orgIVr.InvType) begin
                          case kInvoiceTypeCash:
                            res = res + KLGetAPPaidResult_TRVc(false,basecurncy,orgIVr.CustCode,orgIVr.SerNr,IVYc,fracc,toacc);
                        end;
                      end;
                    end;
                end;
              end;
            end;
          case kIPrsTransTypeReceipt:
              if (vReceiptTreatedf[IPrsr.TransNr & "??" & IPrsr.CustCode]) then begin testf = false; end;
            if (testf) then begin
              IPr.SerNr = IPrsr.TransNr;
              if (ReadFirstMain(IPr,1,true)) then begin
                if (IPr.Invalid==0) then begin
                  rwcnt = MatRowCnt(IPr);
                  for (i=0;i<rwcnt;i=i+1) begin
                    MatRowGet(IPr,i,IPrw);
                    testf = true;
                    if (IPrw.ovst!=0) then begin testf = false; end;
                    if (testf) then begin
                      switch (IPrw.stp) begin
                        case kReceiptRowTypeNormal:
                          if (IPrw.InvoiceNr>0) then begin
                            testf = true;
                            if (vReceiptTreatedf[IPrsr.TransNr & "??" & IPrsr.CustCode]) then begin testf = false; end;
                            if (testf) then begin
                              vReceiptTreatedf[IPrsr.TransNr & "??" & IPrsr.CustCode] = true;
                              IVr.SerNr = IPrw.InvoiceNr;
                              if (ReadFirstMain(IVr,1,true)) then begin
                                if (IVr.Invalid==0) then begin
                                  switch (IVr.InvType) begin
                                    case kInvoiceTypeCash:
                                    case kInvoiceTypeCreditSpecialSales: goto LkInvoiceTypeCredit;
                                    case kInvoiceTypeCredit:
                                      LkInvoiceTypeCredit:;
                                      orgIVr.SerNr = IVr.CredInv;
                                      if (ReadFirstMain(orgIVr,1,true)) then begin
                                        if (orgIVr.Invalid==0) then begin
                                          switch (orgIVr.InvType) begin
                                            case kInvoiceTypeCash:
                                            otherwise
                                              res = res + KLGetAPPaidResult_TRVc(false,basecurncy,orgIVr.CustCode,orgIVr.SerNr,IVYc,fracc,toacc);
                                          end;
                                        end;
                                      end;
                                    otherwise
                                      res = res + KLGetAPPaidResult_TRVc(false,basecurncy,IPrsr.CustCode,IPr.SerNr,IPYc,IVr.ARAcc,IVr.ARAcc);
                                  end;
                                end;
                              end;
                            end;
                          end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          case kIPrsTransTypeCashOut:
        end;
      end;
    end;
  end;
  KLGetARPaidResult = res;
  return;
end;

global
function val KLGetARResult(Integer basecurncy,Date startdate,Date enddate,string accounts,string customers,string class)
begin
  val res;
  record IPrsVc IPrsr;
  Boolean found,testf;
  string 255 frcu,tocu;
  string 255 fracc,toacc;
  string 255 keystr;
  Integer segs;
  record IVVc IVr;
  record IVVc orgIVr;
  Integer i,rwcnt;
  record CUVc CUr;
  
  fracc = FirstInRange(accounts,10);
  toacc = LastInRange(accounts,10);
  frcu = FirstInRange(customers,20);
  tocu = LastInRange(customers,20);
  IPrsr.TransDate = startdate;
  if (nonblank(customers)) then begin
    IPrsr.TransType = kIPrsTransTypeInvoice;
    IPrsr.CustCode = frcu;
    keystr = "TransType";
    segs = 2;
  end else begin
    keystr = "TransDate";
    segs = 1;
  end;
  found = true;
  while (LoopKey(keystr,IPrsr,segs,found)) begin
    if (nonblank(customers)) then begin
      if (IPrsr.TransType!=kIPrsTransTypeInvoice) then begin found = false; end;
      if (IPrsr.CustCode>tocu) then begin found = false; end;
    end else begin
      if (DateInRange(IPrsr.TransDate,startdate,enddate)==false) then begin
        found = false;
      end;
    end;
    if (found) then begin
      testf = true;
      if (IPrsr.TransType!=kIPrsTransTypeInvoice) then begin testf = false; end;
      if (DateInRange(IPrsr.TransDate,startdate,enddate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        CUr.Code = IPrsr.CustCode;
        if (ReadFirstMain(CUr,1,true)) then begin
          if (SetInSet(class,CUr.Classification)==false) then begin
            testf = false;
          end;
        end;
      end;
      if (testf) then begin
        switch (IPrsr.TransType) begin
          case kIPrsTransTypeInvoice:
            IVr.SerNr = IPrsr.TransNr;
            if (ReadFirstMain(IVr,1,true)) then begin
              if (IVr.Invalid==0) then begin
                res = res + KLGetAPPaidResult_TRVc(true,basecurncy,"",IVr.SerNr,IVYc,fracc,toacc);
              end;
            end;
        end;
      end;
    end;
  end;
  KLGetARResult = res;
  return;
end;
