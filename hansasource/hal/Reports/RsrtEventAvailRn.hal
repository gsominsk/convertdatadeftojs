external procedure HT2Per(Date, Date , var string);
external function Boolean DateTimeInsideDateTimeRsrt(Date,Time,Date,Time,Date,Time,Date,Time);
external function Integer DateGetIntMonth(Date);
external function LongInt DateDiff(Date,Date);
external function time AddTime_Minutes(time,time);

procedure AddSubEventsValues(LongInt mothereventnr,string eventtype,Date td,
                          var LongInt minqty,var LongInt maxqty,var LongInt booked)
begin
  record RsrtEventVc REventr;
  Boolean found;

  minqty = 0; maxqty = 0; booked = 0;
  if (mothereventnr>0) then begin
    found = true;
    REventr.MotherEvent = mothereventnr;
    REventr.EventType = eventtype;
    REventr.StartDate = td;  
    while (LoopKey("MotherEventET",REventr,3,found)) begin
      if (REventr.MotherEvent!=mothereventnr) then begin found = false; end;
      if (REventr.EventType!=eventtype) then begin found = false; end;
      if (REventr.StartDate!=td) then begin found = false; end;
      if (found) then begin
        minqty = minqty + REventr.MinPersons;
        maxqty = maxqty + REventr.MaxPersons;
        booked = booked + REventr.TotQty;
      end;
    end;
  end;
  return;
end;

function Boolean PrintPackagesOnDate(string resloc,record RcVc RepSpec,Date td,Array string apackage,Array LongInt asequencenr,Integer are)
begin
  Boolean res;
  Integer i;
  string 255 lastpackage;
  record INVc INr;
  record RsrtEventTypeVc RETr;
  record RsrtEventTypePackVc RETPr;
  row RsrtEventTypePackVc RETPrw;
  Integer ei,erwcnt;

  for (i=0;i<are;i=i+1) begin
    switch (RepSpec.flags[0]) begin
      case 1:
        if (apackage[i]!=lastpackage) then begin
          RETr.Code = apackage[i];
          ReadFirstMain(RETr,1,true);
          INr.Code = RETr.ArtCode;
          ReadFirstMain(INr,1,true);
          
          StartFormat(15);
           OutString(0,"DblREventPackDetail",apackage[i],false);
           OutVal(200,0,INr.UPrice1,M4Val,true);
          EndFormat;

          RETPr.Code = apackage[i];
          if (ReadFirstMain(RETPr,1,true)) then begin
            erwcnt = MatRowCnt(RETPr);
            for (ei=0;ei<erwcnt;ei=ei+1) begin
              MatRowGet(RETPr,ei,RETPrw);
              StartFormat(15);
               OutString(15,0,RETPrw.EventType,false);
               RETr.Code = RETPrw.EventType;
               ReadFirstMain(RETr,1,true);
               INr.Code = RETr.ArtCode;
               ReadFirstMain(INr,1,true);
               OutVal(270,0,INr.UPrice1,M4Val,true);
              EndFormat;
            end;
          end;
        end;        
    end;
    lastpackage = apackage[i];
  end;
  PrintPackagesOnDate = res;
  return;
end;

function Boolean IsEventPackaged(string EventType,string resloc,Date td)
begin
  Boolean res;
  record RsrtEventTypePackVc RETPr;
  Boolean found;
  string 255 index;
  
  index = "ActEventType:" & EventType;
  found = true;
  RETPr.ResLoc = resloc;
  RETPr.StartDate = td;  
  while (LoopBackKey(index,RETPr,2,found)) begin
    if (RETPr.ResLoc!=resloc) then begin found = false; end;
    if (RETPr.StartDate>td) then begin found = false; end;
    if (found) then begin
      res = true;
      goto LIsEventPackaged;
    end;
  end;
LIsEventPackaged:;  
  IsEventPackaged = res;
  return;
end;

function Boolean PrintEventsOnDate(string resloc,record RcVc RepSpec,Date td,Array record RsrtEventVc aREventr,Array string apackage,Array LongInt asequencenr,Integer are)
begin
  Boolean res;
  record RsrtEventVc REventr;
  row RsrtEventVc REventrw;
  Boolean found,testf;
  LongInt minqty;
  LongInt subminqty,submaxqty,subbooked,avail,fromjob;
  Boolean dateprintedf,packageprintedf;
  Integer i;
  Integer ri,rrwcnt;

  dateprintedf = false;
  for (i=0;i<are;i=i+1) begin
    REventr = aREventr[i];    
    fromjob = 0;
    if (dateprintedf==false) then begin
      if (nonblank(resloc)) then begin
        StartFormat(15);
         OutString(0,0,resloc,false);
        EndFormat;
      end;
      StartFormat(15);
       OutDate(0,0,td,false);
       OutString(80,0,USetStr(2792+GetDateID(td)),false);
      EndFormat;
      dateprintedf = true;
    end;
    if (packageprintedf==false) then begin
      switch (RepSpec.flags[0]) begin
        case 2:
          StartFormat(15);
           OutString(0,0,RepSpec.AccStr,false);
          EndFormat;
          packageprintedf = true;
      end;
    end;
    AddSubEventsValues(REventr.SerNr,REventr.EventType,td,subminqty,submaxqty,subbooked);
    switch (RepSpec.flags[0]) begin
      case 0:
        StartFormat(15);
        if (REventr.SerNr>0) then begin
          if (nonblank(RepSpec.FirstAcc)) then begin
            OutStringID(0,"DblAddRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.FirstAcc & "," & RepSpec.long1 & "," & apackage[i]  & "," & asequencenr[i]);
            rrwcnt = MatRowCnt(REventr);
            for (ri=0;ri<rrwcnt;ri=ri+1) begin
              MatRowGet(REventr,ri,REventrw);
              if (REventrw.JobNr==RepSpec.long1) and (REventrw.Status<4) then begin
                fromjob = fromjob + 1;
              end;
            end;
          end else begin
            OutStringID(0,"DblRsrtEventVc",REventr.EventType,false,REventr.SerNr);
          end;
        end else begin
           if (nonblank(RepSpec.FirstAcc)) then begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i] & "," & RepSpec.FirstAcc & "," & RepSpec.long1);
           end else begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i]);
           end;
        end;
        OutString(70,0,Left(REventr.Comment,23),false);        
        if (IsEventPackaged(REventr.EventType,resloc,td)) then begin
          OutString(200,"DblRsrtEventAvPack",USetStr(18226),false);
        end;
        OutString(2,0,REventr.ResCode,false);
        OutString(6,0,Left(REventr.StartTime,5),false);
        OutString(7,0,Left(REventr.EndTime,5),false);
        if (fromjob>0) then begin
          OutLongInt(400,0,fromjob,true);
        end;
        OutLongInt(8,0,REventr.MinPersons + subminqty,true);
        OutLongInt(9,0,REventr.MaxPersons + submaxqty,true);
        avail = REventr.MaxPersons + submaxqty - subbooked;
        if (REventr.TotQty>0) then begin
          avail = avail - REventr.TotQty;
        end;
        OutLongInt(1,0,avail,true);
        EndFormat;
      case 1: 
        StartFormat(15);
        if (REventr.SerNr>0) then begin
          if (nonblank(RepSpec.FirstAcc)) then begin
            OutStringID(0,"DblAddRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.FirstAcc & "," & RepSpec.long1 & "," & apackage[i] & "," & asequencenr[i]);
            rrwcnt = MatRowCnt(REventr);
            for (ri=0;ri<rrwcnt;ri=ri+1) begin
              MatRowGet(REventr,ri,REventrw);
              if (REventrw.JobNr==RepSpec.long1) and (REventrw.Status<4) then begin
                fromjob = fromjob + 1;
              end;
            end;
          end else begin
            OutStringID(0,"DblPackRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.AccStr & "," & asequencenr[i]);
            OutString(100,0,asequencenr[i],false);
          end;
        end else begin
           if (nonblank(RepSpec.FirstAcc)) then begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i] & "," & RepSpec.FirstAcc & "," & RepSpec.long1);
           end else begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i]);
           end;
        end;
        OutString(70,0,Left(REventr.Comment,23),false);        
        OutString(200,0,apackage[i],false);
        OutString(2,0,REventr.ResCode,false);
        OutString(6,0,Left(REventr.StartTime,5),false);
        OutString(7,0,Left(REventr.EndTime,5),false);
        if (fromjob>0) then begin
          OutLongInt(390,0,fromjob,true);
        end;
        OutLongInt(8,0,REventr.MinPersons + subminqty,true);
        OutLongInt(9,0,REventr.MaxPersons + submaxqty,true);
        avail = REventr.MaxPersons + submaxqty - subbooked;
        if (REventr.TotQty>0) then begin
          avail = avail - REventr.TotQty;
        end;
        OutLongInt(1,0,avail,true);
        EndFormat;
      case 2: 
        StartFormat(15);
        if (REventr.SerNr>0) then begin
          if (nonblank(RepSpec.FirstAcc)) then begin
            OutStringID(0,"DblAddRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.FirstAcc & "," & RepSpec.long1 & "," & apackage[i]  & "," & asequencenr[i]);
            rrwcnt = MatRowCnt(REventr);
            for (ri=0;ri<rrwcnt;ri=ri+1) begin
              MatRowGet(REventr,ri,REventrw);
              if (REventrw.JobNr==RepSpec.long1) and (REventrw.Status<4) then begin
                fromjob = fromjob + 1;
              end;
            end;
          end else begin
            OutStringID(0,"DblPackRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.AccStr & "," & asequencenr[i]);
          end;
        end else begin
           if (nonblank(RepSpec.FirstAcc)) then begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i] & "," & RepSpec.FirstAcc & "," & RepSpec.long1);
           end else begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i]);
           end;
        end;
        OutString(70,0,Left(REventr.Comment,23),false);        
        OutLongInt(200,0,asequencenr[i],false);
        OutString(2,0,REventr.ResCode,false);
        OutString(6,0,Left(REventr.StartTime,5),false);
        OutString(7,0,Left(REventr.EndTime,5),false);
        if (fromjob>0) then begin
          OutLongInt(390,0,fromjob,true);
        end;
        OutLongInt(8,0,REventr.MinPersons + subminqty,true);
        OutLongInt(9,0,REventr.MaxPersons + submaxqty,true);
        avail = REventr.MaxPersons + submaxqty - subbooked;
        if (REventr.TotQty>0) then begin
          avail = avail - REventr.TotQty;
        end;
        OutLongInt(1,0,avail,true);
        EndFormat;
      case 3: 
        StartFormat(15);
        if (REventr.SerNr>0) then begin
          if (nonblank(RepSpec.FirstAcc)) then begin
            OutStringID(0,"DblAddRsrtEventVc",REventr.EventType,false,REventr.SerNr & "," & RepSpec.FirstAcc & "," & RepSpec.long1 & "," & apackage[i]  & "," & asequencenr[i]);
            rrwcnt = MatRowCnt(REventr);
            for (ri=0;ri<rrwcnt;ri=ri+1) begin
              MatRowGet(REventr,ri,REventrw);
              if (REventrw.JobNr==RepSpec.long1) and (REventrw.Status<4) then begin
                fromjob = fromjob + 1;
              end;
            end;
          end else begin
            OutStringID(0,"DblRsrtEventVc",REventr.EventType,false,REventr.SerNr);
          end;
        end else begin
           if (nonblank(RepSpec.FirstAcc)) then begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i] & "," & RepSpec.FirstAcc & "," & RepSpec.long1);
           end else begin
             OutStringID(0,"DblNewRsrtEventVc",REventr.EventType,false,REventr.ResCode & "," & td & "," & REventr.StartTime & "," & REventr.EndTime & "," & apackage[i] & "," & asequencenr[i]);
           end;
        end;
        OutString(70,0,Left(REventr.Comment,23),false);        
        if (IsEventPackaged(REventr.EventType,resloc,td)) then begin
          OutString(200,"DblRsrtEventAvPack",USetStr(18226),false);
        end;
        OutString(2,0,REventr.ResCode,false);
        OutString(6,0,Left(REventr.StartTime,5),false);
        OutString(7,0,Left(REventr.EndTime,5),false);
        if (fromjob>0) then begin
          OutLongInt(400,0,fromjob,true);
        end;
        OutLongInt(8,0,REventr.MinPersons + subminqty,true);
        OutLongInt(9,0,REventr.MaxPersons + submaxqty,true);
        avail = REventr.MaxPersons + submaxqty - subbooked;
        if (REventr.TotQty>0) then begin
          avail = avail - REventr.TotQty;
        end;
        OutLongInt(1,0,avail,true);
        EndFormat;
    end;

  end;
  if (dateprintedf) then begin
    StartFormat(15);
    EndFormat;
  end;
  PrintEventsOnDate = res;
  return;
end;

procedure CreateEventsFromScheduleOnDateEveryHour(record RsrtEventTypeVc RETr,record RsrtEventScheduleVc RESchr,Date td,record RcVc RepSpec,
                                                  string package,
                                                  var Array record RsrtEventVc aREventr,var Array string apackage,Array LongInt asequencenr,var Integer are)
begin
  Time tt,et;
  record ResVc Resr;
  Boolean found,loopf;
  LongInt maxpersons,sequencenr;
  Boolean testf;
  record RsrtEventVc REventr;
  row RsrtEventVc REventrw;
  Integer rei,rerwcnt;

  tt = RESchr.StartTime;
  loopf = true;
  while (loopf) begin
    et = AddTime_Minutes(tt,RESchr.DayDuration);
    testf = true;
    if (nonblank(RepSpec.sEndTime)) then begin
      if (DateTimeInsideDateTimeRsrt(td,tt,td,et,
                                RepSpec.sStartDate,RepSpec.sStartTime,RepSpec.sEndDate,RepSpec.sEndTime)==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      REventr.EventType = RESchr.EventType;
      REventr.ResCode = RESchr.ResCode;
      REventr.StartDate = td;
      REventr.ScheduleStartTime = tt;
      testf = ReadFirstKey("ActEventTypeSchedule",REventr,4,true);
      if (REventr.IgnoreInEventsAvail!=0) then begin
        testf = false;
      end;
      if (testf==false) then begin
        Resr.Code = RESchr.ResCode;
        ReadFirstMain(Resr,1,true);
        maxpersons = Resr.MaxPersons;
        if (maxpersons<0) then begin
          maxpersons = RETr.MaxPersons;
        end;
        
        RecordClear(REventr);
        REventr.ResLoc = RESchr.ResLoc;
        REventr.ResCode = RESchr.ResCode;
        REventr.EventType = RESchr.EventType;
        REventr.StartDate = td;
        REventr.EndDate = td;
        REventr.StartTime = tt;
        REventr.EndTime = et;
        REventr.Comment = RETr.Comment;
        REventr.MinPersons = RETr.MinPersons;
        REventr.MaxPersons = maxpersons;  
      end else begin
        switch (Repspec.flags[0]) begin
          case 0:
            if (nonblank(RepSpec.ObjStr)) then begin
              rerwcnt = MatRowCnt(REventr);
              for (rei=0;rei<rerwcnt;rei=rei+1) begin
                MatRowGet(REventr,rei,REventrw);
                if (REventrw.GuestCode==RepSpec.ObjStr) then begin
                  sequencenr = REventrw.SequenceNr;
                  rei = rerwcnt;//guest found
                end;
              end;
            end;
          case 2:
            if (nonblank(RepSpec.ObjStr)) then begin
              rerwcnt = MatRowCnt(REventr);
              for (rei=0;rei<rerwcnt;rei=rei+1) begin
                MatRowGet(REventr,rei,REventrw);
                if (REventrw.GuestCode==RepSpec.ObjStr) then begin
                  sequencenr = REventrw.SequenceNr;
                end;
              end;
            end;
            loopf = false;//package found
        end;
      end;
      aREventr[are] = REventr;
      apackage[are] = package;
      asequencenr[are] = -1;
      are = are + 1;
    end;

    tt = AddTime_Minutes(tt,RESchr.DayTimeInterval);
    if (tt>=RESchr.EndTime) then begin loopf = false; end;
    if (tt<=RESchr.StartTime) then begin loopf = false; end;
  end;
  return;
end;

procedure CreateEventsFromScheduleOnDateSpecifiedHours(record RsrtEventTypeVc RETr,record RsrtEventScheduleVc RESchr,Date td,record RcVc RepSpec,
                                                       string package,
                                                       var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  row RsrtEventScheduleVc RESchrw;
  Integer i,rwcnt,rerwcnt;
  record ResVc Resr;
  LongInt maxpersons;
  Boolean found;
  Boolean testf;
  record RsrtEventVc REventr;
  row RsrtEventVc REventrw;
  LongInt sequencenr;

  rwcnt = MatRowCnt(RESchr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(RESchr,i,RESchrw);
    Resr.Code = RESchr.ResCode;
    ReadFirstMain(Resr,1,true);
    maxpersons = Resr.MaxPersons;
    if (maxpersons<0) then begin
      maxpersons = RETr.MaxPersons;
    end;
    testf = true;
    if (nonblank(RepSpec.sEndTime)) then begin
      if (DateTimeInsideDateTimeRsrt(td,RESchrw.StartTime,td,RESchrw.EndTime,
                                RepSpec.sStartDate,RepSpec.sStartTime,RepSpec.sEndDate,RepSpec.sEndTime)==false) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      sequencenr = -1;
      REventr.EventType = RESchr.EventType;
      REventr.ResCode = RESchr.ResCode;
      REventr.StartDate = td;
      REventr.ScheduleStartTime = RESchrw.StartTime;
      testf = ReadFirstKey("ActEventTypeSchedule",REventr,4,true);
      if (REventr.IgnoreInEventsAvail!=0) then begin
        testf = false;
      end;
      if (testf==false) then begin
        Resr.Code = RESchr.ResCode;
        ReadFirstMain(Resr,1,true);
        maxpersons = Resr.MaxPersons;
        if (maxpersons<0) then begin
          maxpersons = RETr.MaxPersons;
        end;
        
        RecordClear(REventr);
        REventr.ResLoc = RESchr.ResLoc;
        REventr.ResCode = RESchr.ResCode;
        REventr.EventType = RESchr.EventType;
        REventr.StartDate = td;
        REventr.EndDate = td;
        REventr.StartTime = RESchrw.StartTime;
        REventr.EndTime = RESchrw.EndTime;
        REventr.Comment = RETr.Comment;
        REventr.MinPersons = RETr.MinPersons;
        REventr.MaxPersons = maxpersons;  
      end else begin
        switch (Repspec.flags[0]) begin
          case 0:
            if (nonblank(RepSpec.ObjStr)) then begin
              rerwcnt = MatRowCnt(REventr);
              for (i=0;i<rerwcnt;i=i+1) begin
                MatRowGet(REventr,i,REventrw);
                if (REventrw.GuestCode==RepSpec.ObjStr) then begin
                  sequencenr = REventrw.SequenceNr;
                  i = rwcnt;//guest found
                end;
              end;
            end;
          case 2:
            if (nonblank(RepSpec.ObjStr)) then begin
              rerwcnt = MatRowCnt(REventr);
              for (i=0;i<rerwcnt;i=i+1) begin
                MatRowGet(REventr,i,REventrw);
                if (REventrw.GuestCode==RepSpec.ObjStr) then begin
                  sequencenr = REventrw.SequenceNr;
                end;
              end;
            end;
            i = rwcnt;//package found
        end;
      end;
      aREventr[are] = REventr;
      apackage[are] = package;
      asequencenr[are] = sequencenr;
      are = are + 1;
    end;
  end;
  return;
end;

procedure CreateEventsFromScheduleOnDate(record RsrtEventTypeVc RETr,record RsrtEventScheduleVc RESchr,Date td,record RcVc RepSpec,string package,
                                         var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  Boolean testf;
  LongInt diff;
  Date sd;
  
//same as in CreateEventsFromSchedule  
  testf = true;
  switch (RESchr.PeriodType) begin
    case kResortEventScheduleDaily:
      if (nonblankdate(RESchr.StartDate)) then begin
        diff = DateDiff(td,RESchr.StartDate);
        if (Mod(diff,RESchr.DayInterval)!=0) then begin
          testf = false;
        end;
      end;
    case kResortEventScheduleWeekly:
      sd = AddDay(RESchr.StartDate,-GetDateId(RESchr.StartDate)+1);
      diff = DateDiff(td,sd);
      if (Mod(diff/7,RESchr.WeekInterval)!=0) then begin
        testf = false;
      end;
      if (testf) then begin
        testf = false;
        if (RESchr.Mon!=0) then begin
          if (GetDateId(td)==1) then begin testf = true; end;
        end;
        if (RESchr.Tue!=0) then begin
          if (GetDateId(td)==2) then begin testf = true; end;
        end;
        if (RESchr.Wed!=0) then begin
          if (GetDateId(td)==3) then begin testf = true; end;
        end;
        if (RESchr.Thu!=0) then begin
          if (GetDateId(td)==4) then begin testf = true; end;
        end;
        if (RESchr.Fri!=0) then begin
          if (GetDateId(td)==5) then begin testf = true; end;
        end;
        if (RESchr.Sat!=0) then begin
          if (GetDateId(td)==6) then begin testf = true; end;
        end;
        if (RESchr.Sun!=0) then begin
          if (GetDateId(td)==7) then begin testf = true; end;
        end;
      end;
    case kResortEventScheduleMonthly:
      sd = AddDay(RESchr.StartDate,-GetDay(RESchr.StartDate)+1);
      diff = DateGetIntMonth(td) - DateGetIntMonth(sd);
      if (Mod(diff,RESchr.MonthInterval)!=0) then begin
        testf = false;
      end;
      switch (RESchr.MonthType) begin
        case 0:
          if (GetDay(td)!=RESchr.DayInterval) then begin
            testf = false;
          end;
        case 1:
          if (GetDateId(td)!=RESchr.WeekDay) then begin testf = false; end;
          if (testf) then begin
            testf = false;
            sd = AddDay(td,-GetDay(td)+1);
            diff = GetDay(td) - GetDay(sd)+1;
            if (diff>7*(RESchr.DayInterval-1)) and (diff<=7*RESchr.DayInterval) then begin
              testf = true;
            end;
          end;
      end;
  end;
  if (testf) then begin
    switch (RESchr.DayType) begin
      case kResortEventScheduleDailyFreqEveryHour:
        CreateEventsFromScheduleOnDateEveryHour(RETr,RESchr,td,RepSpec,package,aREventr,apackage,asequencenr,are);          
      case kResortEventScheduleDailyFreqSpecifiedHours:
        CreateEventsFromScheduleOnDateSpecifiedHours(RETr,RESchr,td,RepSpec,package,aREventr,apackage,asequencenr,are);
    end;
  end;
  return;
end;

procedure BuildRsrtEventArray(string resloc,string package,record RcVc RepSpec,Date td,var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  record RsrtEventScheduleVc RESr;
  record RsrtEventTypeVc RETr;
  record RsrtEventVc REventr;
  Boolean found,foundres,testf;
  string 255 resindexname;
  Integer ressegs;
  string 255 fret,toet,thepackage;
  Integer i;
  LongInt seqnr;

  fret = FirstInRange(RepSpec.f2,10);
  toet = LastInRange(RepSpec.f2,10);
  ressegs = 2;
  resindexname = "ActResLocET";

  foundres = true;
  RESr.ResLoc = resloc;
  RESr.EventType = fret;
  while (LoopKey(resindexname,RESr,ressegs,foundres)) begin    
    if (RESr.ResLoc!=resloc) then begin foundres = false; end;
    if (nonblank(RepSpec.f2)) then begin
      if (RESr.EventType>toet) then begin foundres = false; end;
    end;
    if (foundres) then begin
      testf = true;
      if (nonblankdate(RESr.StartDate)) then begin
        if (RESr.StartDate>RepSpec.sEndDate) then begin
          testf = false;
        end;
      end;
      if (nonblankdate(RESr.EndDate)) then begin
        if (RESr.EndDate<RepSpec.sStartDate) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        RETr.Code = RESr.EventType;
        ReadFirstMain(RETr,1,true);
        CreateEventsFromScheduleOnDate(RETr,RESr,td,RepSpec,package,aREventr,apackage,asequencenr,are);
      end;
    end;
  end;
  for (i=0;i<are;i=i+1) begin
    if (asequencenr[i]>0) then begin
      thepackage = apackage[i];
      seqnr = asequencenr[i];
    end;
  end;

  if (nonblank(thepackage)) then begin
    for (i=0;i<are;i=i+1) begin
      if (apackage[i]==thepackage) then begin
        if (asequencenr[i]<=0) then begin
          asequencenr[i] = seqnr;
        end;
      end;
    end;
  end;
  return;
end;

procedure BuildRsrtPackageEventArray(string resloc,record RcVc RepSpec,Date td,var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  string 255 orgf2;
  record RsrtEventTypeVc RETr;
  record RsrtEventTypePackVc RETPr;
  row RsrtEventTypePackVc RETPrw;
  Integer i,rwcnt,ai;
  Boolean found,testf;
  Integer segs;
  string 255 index;
  
  orgf2 = RepSpec.f2;

  if (nonblank(RepSpec.AccStr)) then begin
    index = "ActCodeStartDate";
    RETPr.Code = RepSpec.AccStr;
    segs = 2;
  end else begin
    index = "ActRLDate";
    RETPr.ResLoc = resloc;
    segs = 2;
  end;
  found = true;
  RETPr.StartDate = td;  
  while (LoopBackKey(index,RETPr,2,found)) begin
    if (nonblank(RepSpec.AccStr)) then begin
      if (RETPr.Code!=RepSpec.AccStr) then begin found = false; end;
    end else begin
      if (RETPr.ResLoc!=resloc) then begin found = false; end;
    end;
    if (RETPr.StartDate>td) then begin found = false; end;
    if (found) then begin
      testf = true;
      for (ai=0;ai<are;ai=ai+1) begin
        if (RETPr.Code==apackage[ai]) then begin
          testf = false;
          ai = are;
        end;
      end;
      if (testf) then begin
        rwcnt = MatRowCnt(RETPr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(RETPr,i,RETPrw);
          RepSpec.f2 = RETPrw.EventType;
          BuildRsrtEventArray(resloc,RETPr.Code,RepSpec,td,aREventr,apackage,asequencenr,are);  
        end;
      end;
    end;
  end;
  RepSpec.f2 = orgf2;
  return;
end;

procedure BuildReservationRsrtEventArray(string resloc,record RcVc RepSpec,Date td,var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  string 255 orgf2;
  record RsrtEventVc REventr;
  Boolean found;

  orgf2 = RepSpec.f2;
  found = true;
  if (RepSpec.long1>0) then begin
    while (LoopKey("JobNr:" & RepSpec.long1,REventr,1,found)) begin
      if (found) then begin
        if (REventr.StartDate==td) then begin
          aREventr[are] = REventr;
          apackage[are] = "";
          asequencenr[are] = -1;
          are = are + 1;
        end;
      end;
    end;
  end;
  RepSpec.f2 = orgf2;
  return;
end;

procedure RsrtEventAvailPerResLocPerDay(string resloc,record RcVc RepSpec,Date td)
begin
  Array record RsrtEventVc aREventr;
  Array string 255 apackage;
  Array LongInt asequencenr;
  Integer are;

  switch (RepSpec.flags[0]) begin
    case 0:
      BuildRsrtEventArray(resloc,"",RepSpec,td,aREventr,apackage,asequencenr,are);  
    case 1:
      BuildRsrtPackageEventArray(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
    case 2:
      BuildRsrtPackageEventArray(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
    case 3:
      BuildReservationRsrtEventArray(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);  
  end;
  switch (RepSpec.flags[0]) begin
    case 0: PrintEventsOnDate(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
    case 1: PrintPackagesOnDate(resloc,RepSpec,td,apackage,asequencenr,are);
    case 2: PrintEventsOnDate(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
    case 3: PrintEventsOnDate(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
  end;
  return;
end;

procedure RsrtEventAvailPerResLoc(string resloc,record RcVc RepSpec)
begin
  Date td;
  
  td = RepSpec.sStartDate;
  while (td<=RepSpec.sEndDate) begin
    RsrtEventAvailPerResLocPerDay(resloc,RepSpec,td);    
    td = AddDay(td,1);
  end;
  return;
end;

procedure RsrtEventPackageAvailPerResLocPerDay(string resloc,record RcVc RepSpec,Date td,var Array record RsrtEventVc aREventr,var Array string apackage,var Array LongInt asequencenr,var Integer are)
begin
  switch (RepSpec.flags[0]) begin
    case 1:
      BuildRsrtPackageEventArray(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);
  end;
  return;
end;

procedure RsrtEventPackageAvailPerResLoc(string resloc,record RcVc RepSpec)
begin
  Date td;
  Array record RsrtEventVc aREventr;
  Array string 255 apackage;
  Array LongInt asequencenr;
  Integer are;
  
  td = RepSpec.sStartDate;
  while (td<=RepSpec.sEndDate) begin
    RsrtEventPackageAvailPerResLocPerDay(resloc,RepSpec,td,aREventr,apackage,asequencenr,are);    
    td = AddDay(td,1);
  end;
  switch (RepSpec.flags[0]) begin
    case 1: PrintPackagesOnDate(resloc,RepSpec,td,apackage,asequencenr,are);
  end;
  return;
end;

global
procedure RsrtEventAvailRn(record RcVc RepSpec)
begin    
  Boolean found;
  record ResLocVc RLr;
  string 255 frrl,torl;
  string 255 fret,toet;
  Integer rw;
  string 255 tstr;
  
  frrl = FirstInRange(RepSpec.f1,10);
  torl = LastInRange(RepSpec.f1,10);
  fret = FirstInRange(RepSpec.f2,10);
  toet = LastInRange(RepSpec.f2,10);
  StartReportJob(USetStr(18210));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f1)) then begin
    tstr = USetStr(18218) & " " & RepSpec.f1;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (nonblank(RepSpec.f2)) then begin
    tstr = USetStr(18219) & " " & RepSpec.f2;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  EndHeader;
  
  switch (RepSpec.flags[0]) begin
    case 2:
      goto LPrintStdHeader;
    case 0:
LPrintStdHeader:;    
      SetRepCol(2,250);
      SetRepCol(6,320);
      SetRepCol(7,350);
      SetRepCol(8,425);
      SetRepCol(9,450);
      StartFormat(15);
       OutString(0,0,USetStr(18218),false);
       OutString(2,0,USetStr(18212),false);
       OutString(6,0,USetStr(18213),false);
       OutString(7,0,USetStr(18214),false);
       OutString(8,0,USetStr(18215),true);
       OutString(9,0,USetStr(18216),true);
       OutString(1,0,USetStr(18217),true);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18211),false);
       OutString(6,0,USetStr(18220),false);
       OutString(7,0,USetStr(18220),false);
       OutString(8,0,USetStr(18221),true);
       OutString(9,0,USetStr(18221),true);
      EndFormat;
    case 1:
      StartFormat(15);
       OutString(0,0,USetStr(18224),false);
       OutString(200,0,USetStr(18224) & " " & USetStr(18225),true);
       OutString(270,0,USetStr(18225),true);
      EndFormat;
  end;
  Gray_Divider(0,1);
  found = true;
  RLr.Code = frrl;
  while (LoopMain(RLr,1,found)) begin
    if (nonblank(RepSpec.f1)) then begin
      if (RLr.Code>torl) then begin found = false; end;
    end;
    if (found) then begin
      switch (RepSpec.flags[0]) begin
        case 0: RsrtEventAvailPerResLoc(RLr.Code,RepSpec);
        case 1: RsrtEventPackageAvailPerResLoc(RLr.Code,RepSpec);
        case 2: RsrtEventAvailPerResLoc(RLr.Code,RepSpec);
        case 3: RsrtEventAvailPerResLoc(RLr.Code,RepSpec);
      end;
    end;
  end;
  RsrtEventAvailPerResLoc("",RepSpec);
  EndJob;
  return;
end;

global
procedure JobRsrtEventAvailRn(record RcVc RepSpec)
begin    
  record ResTypeVc RTr;
  Integer rw;
  string 255 tstr;
  
  RTr.Code = RepSpec.LastAcc;
  if (ReadFirstMain(RTr,1,true)) then begin
  end;
  StartReportJob(USetStr(18210));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f1)) then begin
    tstr = USetStr(18218) & " " & RepSpec.f1;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (nonblank(RepSpec.f2)) then begin
    tstr = USetStr(18219) & " " & RepSpec.f2;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  Header(rw,USetStr(18222) & RepSpec.long1,1);
  rw = rw + 1;
  EndHeader;
  
  switch (RepSpec.flags[0]) begin
    case 3:
      goto LPrintStdHeader;
    case 2:
      goto LPrintStdHeader;
    case 0:
LPrintStdHeader:;    
      SetRepCol(2,250);
      SetRepCol(6,320);
      SetRepCol(7,350);
      SetRepCol(8,425);
      SetRepCol(9,450);
      StartFormat(15);
       OutString(0,0,USetStr(18218),false);
       OutString(2,0,USetStr(18212),false);
       OutString(6,0,USetStr(18213),false);
       OutString(7,0,USetStr(18214),false);
       OutString(8,0,USetStr(18215),true);
       OutString(9,0,USetStr(18216),true);
       OutString(1,0,USetStr(18217),true);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18211),false);
       OutString(6,0,USetStr(18220),false);
       OutString(7,0,USetStr(18220),false);
       OutString(400,0,USetStr(18221),true);
       OutString(8,0,USetStr(18221),true);
       OutString(9,0,USetStr(18221),true);
      EndFormat;
    case 1:
      StartFormat(15);
       OutString(0,0,USetStr(18224),false);
       OutString(200,0,USetStr(18224) & " " & USetStr(18225),true);
       OutString(270,0,USetStr(18225),true);
      EndFormat;
  end;
  Gray_Divider(0,1);
  switch (RepSpec.flags[0]) begin
    case 1:
    case 3:
    otherwise
      StartFormat(15);
       OutString(270,"DblREAvailAllJob",USetStr(18227),true);
      EndFormat;
  end;
  switch (RepSpec.flags[0]) begin
    case 0: RsrtEventAvailPerResLoc(RTr.ResLoc,RepSpec);
    case 1: RsrtEventPackageAvailPerResLoc(RTr.ResLoc,RepSpec);
    case 2: RsrtEventAvailPerResLoc(RTr.ResLoc,RepSpec);
    case 3: RsrtEventAvailPerResLoc(RTr.ResLoc,RepSpec);
  end;
  EndJob;
  return;
end;
