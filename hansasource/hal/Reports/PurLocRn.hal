external function roundmode SetRoundModeD(Integer);
external function Boolean CheckVARSubsets(record VARVc,string,string);
external function Boolean TestArtCodeMatch(string,string);
external procedure ExtractObj(string,var Integer,var string);
external function Integer FindYVars(string,string,string);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean FindItemVAR2(string,var string,var string,var string);
external function Boolean IsVarietyItem(string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure GetStockValue(string,string,var record ItemStatusVc);
external procedure HTSort1(Integer, var string);
external procedure HTDetailLevel(Integer, var string);
external procedure HTArtSel(string,string, var string);
external procedure HTLocations(string, string, var string);
external procedure HTDepartments(string,string,var string);
external function Boolean GetItemNameStr(Integer,var string,string,string,string);
external procedure HTCustClass(string,var string);
external procedure HTCustClassType(string,var string);
external function Boolean SetInSet2(string,string);
external procedure ItemClassTypef(string,string,var Boolean);

procedure FindMinLevel(var val mlevel, string location,record INVc INp,Boolean varf,Boolean itemminlevelf)
begin
  record MinPerLocVc MinPer;
  Boolean TrHs,found;
  Integer keys;

  MinPer.ItemCode = INp.Code;
  keys = 1;
  if (nonblank(location)) then begin
    MinPer.Location = location;
    keys = 2;
  end;
  TrHs = true;
  while LoopMain(MinPer,keys,TrHs) begin
    if (varf) then begin
      if (MinPer.ItemCode!=INp.Code) then begin
        TrHs = false;
      end;
    end else begin
      if (MinPer.ItemCode!=INp.Code) then begin
        TrHs = false;
      end;
    end;
    if (nonblank(location)) then begin
      if (MinPer.Location!=location) then begin
        TrHs = false;
      end;
    end;
    if (TrHs) then begin
      mlevel = mlevel + MinPer.MinLevel;   
      found = true;
    end;		
  end;
  if (found==false) then begin
    TrHs = true;
    ResetLoop(MinPer);
    while LoopMain(MinPer,keys,TrHs) begin
      if (varf) then begin
        if (MinPer.ItemCode!=INp.Code) then begin
          TrHs = false;
        end;
      end else begin
        if (MinPer.ItemCode!=INp.Code) then begin
          TrHs = false;
        end;
      end;
      if (nonblank(location)) then begin
        if (MinPer.Location!=location) then begin
          TrHs = false;
        end;
      end;
      if (TrHs) then begin
        mlevel = mlevel + MinPer.MinLevel;
        found = true;
      end;		
    end;
  end;
  if (found==false) then begin
    if (itemminlevelf) then begin
      mlevel = INp.MinLevel;
    end;
  end;
  return;
end;

Function Boolean FindPItem(string itemcode,string location,var record PIVc PIp,string veselect,Integer flag)
begin
  Boolean res;
  record POSettingBlock POSetRec;

  PIp.DefaultChoice = 1;
  PIp.ItemCode = itemcode;
  PIp.Location = location;
  res = ReadFirstKey("DefaultChoice",PIp,3,true);
  if (res==false) then begin
    if (nonblank(location)) then begin
      PIp.DefaultChoice = 1;
      PIp.ItemCode = itemcode;
      PIp.Location = "";
      res = ReadFirstKey("DefaultChoice",PIp,3,true);
    end;
  end;
  if (flag==0) then begin
    if (nonblank(veselect)) then begin
      if (veselect<>PIp.VECode) then begin
        res = false;
        goto LFindPItem;
      end;
    end;
  end else begin
    PIp.DefaultChoice = 1;
    PIp.ItemCode = itemcode;
    PIp.Location = location;
    PIp.VECode = veselect;
    res = ReadFirstKey("DefaultChoice",PIp,4,true);
    if (res==false) then begin
      if (nonblank(location)) then begin
        PIp.DefaultChoice = 1;
        PIp.ItemCode = itemcode;
        PIp.Location = "";
        PIp.VECode = veselect;
        res = ReadFirstKey("DefaultChoice",PIp,4,true);
      end;
    end;
    if (res==false) then begin
      PIp.ItemCode = itemcode;
      PIp.Location = location;
      PIp.VECode = veselect;
      res = ReadFirstKey("MainKey",PIp,3,true);
    end;
    if (res==false) then begin
      if (nonblank(location)) then begin
        PIp.ItemCode = itemcode;
        PIp.Location = "";
        PIp.VECode = veselect;
        res = ReadFirstKey("MainKey",PIp,3,true);
      end;
    end;
  end;
  if (res==false) then begin
    BlockLoad(POSetRec);
    if (nonblank(POSetRec.DefaultSupplier)) then begin
      RecordNew(PIp);
      PIp.ItemCode = itemcode;
      PIp.VEItemCode = itemcode;
      PIp.VECode = POSetRec.DefaultSupplier;
      res = true;
    end;
  end;

LFindPItem:;
  FindPItem = res;
  return;
end;

procedure FindSalesOrderQuantity(string artcode,LongInt ordernr,var val qty)
BEGIN
  record ORVc ORr;
  row ORVc ORrw;
  Integer i,rwcnt;
  val t;
  
  qty = 0;
  ORr.SerNr = ordernr;
  if (ReadFirstMain(ORr,1,true)) then begin
    rwcnt = MatRowCnt(ORr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ORr,i,ORrw);
      if (ORrw.ArtCode==artcode) then begin
        t = ORrw.Shipd1 - ORrw.Quant;
        qty = qty + t;
      end;
    end;
  end;
  RETURN;
END;

procedure FindPurchaseOrderQuantity(string artcode,LongInt ordernr,var val qty)
BEGIN
  record POVc POr;
  row POVc POrw;
  Integer i,rwcnt;
  val t;
  
  qty = 0;
  POr.SerNr = ordernr;
  if (ReadFirstMain(POr,1,true)) then begin
    rwcnt = MatRowCnt(POr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(POr,i,POrw);
      if (POrw.ArtCode==artcode) then begin
        t = POrw.Shipd1 - POrw.Quant;
        qty = qty + t;
      end;
    end;
  end;
  RETURN;
END;

procedure FindFutureQuantity(record RcVc RepSpec,string artcode,var val totquant)
BEGIN
  record ItemHistVc IHr;
  Boolean TrHs;
  val quant;

  totquant = 0;
  IHr.ArtCode = artcode;
  IHr.TransDate = RepSpec.d1;
  TrHs = true;
  while (LoopKey("ArtCode",IHr,2,TrHs)) begin
    if (IHr.ArtCode!=artcode) then begin TrHs = false; end;
    if ((TrHs) and (IHr.TransDate<>RepSpec.d1))  then begin
      if (IHr.FileName=="Fut3ORVc") then begin
        FindSalesOrderQuantity(artcode,IHr.TransNr,quant);
        totquant = totquant + quant;
      end;
      if (IHr.FileName=="Fut1POVc") then begin
        FindPurchaseOrderQuantity(artcode,IHr.TransNr,quant);
        totquant = totquant + quant;
      end;
    end;
  end;
  RETURN;
END;

Function Boolean FindPOQantity(record INVc INp,record ItemStatusVc ISp,record ItemStatusVc IS2p,Boolean varf,string location,record PIVc PIp,var val t1p,var val t2p,var val minlevel,val predsales,Boolean defic,Boolean checkpif,Boolean checkminpoqty,Boolean itemminlevelf)
begin
//try to make same as FindPOQty2
  Boolean res;
  val t;
  record POSettingBlock POb;
  Integer it;

  res = true;
  BlockLoad(POb);
  minlevel = blankval;  
  FindMinLevel(minlevel,location,INp,varf,itemminlevelf);

  GetStockValue(INp.Code,location,ISp);
  t1p = (ISp.Instock - IS2p.Instock) - (ISp.OrddOut - IS2p.OrddOut) + (ISp.POUnOKQty -IS2p.POUnOKQty) - (ISp.ProdOrd-IS2p.ProdOrd);
  t2p = 0;
  t   = 0;
  t1p = t1p - predsales;
  if (t1p<minlevel) then begin
    t2p = minlevel - t1p;
  end;
  
  if (PIp.ItemCode=="") then begin
    res = false;
  end;
  if (res) and (checkpif) then begin
    if (t2p>0) then begin
      t = t2p;
      if (PIp.NormPOQty!=0) and (defic==false) then begin
        if (PIp.NormPOQty>t2p) then begin
          t2p = PIp.NormPOQty;
        end;
        if (POb.UseNormOrdMult!=0) then begin
          t = t2p/PIp.NormPOQty;
          t = t + 49999.00/100000.00;
          t = Round(t,SetRoundModeD(0));
          t2p = t*PIp.NormPOQty;
        end;
      end;
      if (checkminpoqty) then begin
        if (PIp.MinPOQty!=0) then begin
          if (PIp.MinPOQty>t2p) then begin
            t2p = PIp.MinPOQty;
          end;
        end;
      end;
    end;
  end;
//  FindFutureQuantity(RepSpec,INp.Code,t);//??
  //t1p = t1p + t;
  FindPOQantity = res;
  return;
end;

procedure PrintHeaderRsrv()
begin
  if (true) then begin
    StartFormat(15);
    OutString(11,0,USetStr(2325),false);
    OutString(2,0,USetStr(2392),false);
    OutString(180,0,USetStr(17881),true);
    OutString(240,0,USetStr(17883),true);
    OutString(250,0,"Supplier",false);
    OutString(360,0,"Price",true);
    OutString(8,0,USetStr(17882),true);
    OutString(1,0,USetStr(2341),true);
    EndFormat;
    Gray_Divider(0,1);
  end;
  return;
end;

procedure PrintHeader(var Boolean headerf)
begin
  if (headerf) then begin
    StartFormat(15);
    EndFormat;
    StartFormat(15);
    OutString(0,0,USetStr(2325),false);
    OutString(7,0,USetStr(5579),true);
    OutString(3,0,USetStr(2342),true);
    OutString(4,0,USetStr(2343),true);
    OutString(5,0,USetStr(2348),true);
    OutString(6,0,USetStr(2347),true);
    OutString(8,0,USetStr(17882),true);//USetStr(11770)
    OutString(1,0,USetStr(2341),true);
    EndFormat;
    Gray_Divider(0,1);
    StartFormat(15);
    OutString(1,"DblDfncyStockAll",USetStr(17884),true);
    EndFormat;
    headerf = false;
  end;
  return;
end;

global
function val DfncyStockForStockReserv(Integer FromFileName,LongInt FromSerNr,string artcode)
begin
  val res;
  record DfncyStockVc DSr;
  Boolean found,testf;
  
  found = true;
  DSr.FromFileName = FromFileName;
  DSr.FromSerNr = FromSerNr;
  while (LoopKey("ActFromSerNr",DSr,2,found)) begin
    if (DSr.FromFileName!=FromFileName) then begin found = false; end;
    if (DSr.FromSerNr!=FromSerNr) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(artcode)) then begin
        if (DSr.ArtCode!=artcode) then begin testf = false; end;
      end;
      if (testf) then begin
        res = res + DSr.Quant;
      end;
    end;
  end;
  DfncyStockForStockReserv = res;
  return;
end;

global
function val DfncyStockWOStockReserv(string artcode,string location)
begin
  val res;
  record DfncyStockVc DSr;
  Boolean found,testf;
  
  found = true;
  DSr.ArtCode = artcode;
  while (LoopKey("ActArtCode",DSr,1,found)) begin
    if (DSr.ArtCode!=artcode) then begin found = false; end;
    if (found) then begin
      testf = true;
      if (nonblank(location)) then begin
        if (DSr.Location!=location) then begin testf = false; end;
        if (DSr.FromFileName>0) or (DSr.FromSerNr>0) then begin testf = false; end;
      end;      
      if (testf) then begin
        res = res + DSr.Quant;
      end;
    end;
  end;
  DfncyStockWOStockReserv = res;
  return;
end;

function val GetRsrvQty(string artcode,string location,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  val res;
  Integer i;  
  
  for (i=0;i<arsrvcnt;i=i+1) begin
    if (arsrvitem[i]==artcode) and (arsrvlocation[i]==location) then begin
      res = arsrvqty[i];
      goto LGetRsrvQty;
    end;
  end;
LGetRsrvQty:;  
  GetRsrvQty = res;
  return;
end;

procedure PrintData(Integer namepos,record RcVc RepSpec,string itemcode,record INVc INr,val totdsrsrvq,Boolean varf,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  record PIVc PIr;
  record ItemStatusVc ISr;
  record ItemStatusVc totlocISr;
  record ItemStatusVc fakeISr;
  Boolean printf,pifound,found,firstf;
  val t,t1,t2,minlevel,q,dsrsrvq,dsq;
  record LocationVc Locr;
  record MainStockBlock MSb;
  record CUVc VEr;

  BlockLoad(MSb);
  firstf = true;
  pifound = FindPItem(INr.Code,"",PIr,RepSpec.TransStr,RepSpec.flags[1]);
  found = true;
  if (pifound==false) then begin
    PIr.ItemCode = "";
  end else begin
    VEr.Code = PIr.VECode;
    ReadFirstMain(VEr,1,true);
    if (nonblank(RepSpec.TransStr)) then begin
      if (VEr.Code!=RepSpec.TransStr) then begin
        found = false;
      end;
    end;
    if (nonblank(RepSpec.AccStr)) then begin
      if (VEr.VECat!=RepSpec.AccStr) then begin
        found = false;
      end;
    end;
    if (nonblank(RepSpec.f5)) then begin
      if (SetInSet(RepSpec.f5,VEr.Classification)==false) then begin
        found = false;
      end;
    end;
  end;
  if (nonblank(RepSpec.AccStr)) then begin
    if (pifound==false) then begin 
      found = false;
    end else begin
      if (PIr.SalesMan<>RepSpec.AccStr) then begin
        found = false;
      end;
    end;
  end;
  if (nonblank(RepSpec.TransStr)) then begin
    if (pifound==false) then begin 
      found = false;
    end else begin
      if (PIr.VECode!=RepSpec.TransStr) then begin
        found = false;
      end;
    end;
  end;
  if (nonblank(RepSpec.Stext)) then begin
    if (pifound==false) then begin 
      found = false;
    end else begin
      if (PIr.SalesGroup<>RepSpec.Stext) then begin
        found = false;
      end;
    end;
  end;
  if (found) then begin   

    found = true;
    ResetLoop(Locr);
    Locr.Code = ""; 
    while (LoopMain(Locr,1,found)) begin
      printf = true;
      pifound = FindPOQantity(INr,ISr,fakeISr,varf,Locr.Code,PIr,t1,t2,minlevel,0,true,RepSpec.flags[5]!=0,false,false);
//      if (minlevel==0) then begin
//        printf = false;
//      end;
      dsq = DfncyStockWOStockReserv(INr.Code,Locr.Code);
      t2 = t2 - GetRsrvQty(INr.Code,Locr.Code,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt) - totdsrsrvq - dsq;
//      t2 = t2 - rsrvqty[Locr.Code] - dsrsrvq - dsq;

      if ((RepSpec.flags[3]==0) or (t1<>0)) then begin
        if (RepSpec.flags[4]==1) then  begin
          if (t2==0) then begin 
            printf = false; 
          end;
        end;
        if (t2<0) then begin 
          printf = false; 
        end;
        if (printf) then begin
          totlocISr.Instock = totlocISr.Instock + ISr.Instock;
          totlocISr.OrddOut = totlocISr.OrddOut + ISr.OrddOut;
          totlocISr.POUnOKQty = totlocISr.POUnOKQty + ISr.POUnOKQty;
          PrintHeader(headerf);
          if (firstf) then begin
            StartFormat(15);
             OutString(0,"DblINVc",INr.Code,false);
             OutString(namepos,0,INr.Name,false);
            EndFormat;
            firstf = false;
          end;
          StartFormat(15);
          OutString(15,0,Locr.Code,false);
  //        OutString(namepos+270,0,Left(Locr.Name,25),false);
          OutVal(7,0,minlevel,M4UVal,true);
          OutVal(3,0,ISr.Instock,M4UVal,true);
          OutVal(4,0,ISr.OrddOut,M4UVal,true);
          t = ISr.Instock - ISr.OrddOut;
          OutVal(5,0,t,M4UVal,true);
          OutVal(6,0,ISr.POUnOKQty,M4UVal,true);
//          OutVal(8,0,ISr.ProdOrd,M4UVal,true);
          OutVal(8,0,dsq,M4UVal,true);
//          OutValID(8,"DblDfncyStock",dsq,M4UVal,true,itemcode & ":" & Locr.Code);
          OutValID(1,"DblNewDfncyStock",t2,M4UVal,true,itemcode & ":" & Locr.Code);
          EndFormat;
        end;
      end;
    end;

    if (INr.MinLevel!=0) and (firstf) then begin
      printf = true;
      pifound = FindPOQantity(INr,ISr,totlocISr,varf,";;;",PIr,t1,t2,minlevel,0,true,RepSpec.flags[5]!=0,false,true);      
//      if (minlevel==0) then begin
//        printf = false;
//      end;
      dsq = DfncyStockWOStockReserv(INr.Code,"");
      
      t2 = t2 - GetRsrvQty(INr.Code,"",arsrvitem,arsrvlocation,arsrvqty,arsrvcnt) - dsrsrvq - dsq;
//      t2 = t2 - rsrvqty[""] - dsrsrvq - dsq;

      if ((RepSpec.flags[3]==0) or (t1<>0)) then begin
        if (RepSpec.flags[4]==1) then  begin
          if (t2==0) then begin 
            printf = false; 
          end;
        end;
        if (t2<0) then begin 
          printf = false; 
        end;
        if (printf) then begin
          PrintHeader(headerf);
          if (firstf) then begin
            StartFormat(15);
             OutString(0,"DblINVc",INr.Code,false);
             OutString(namepos,0,INr.Name,false);
            EndFormat;
            firstf = false;
          end;
          StartFormat(15);
          OutVal(7,0,minlevel,M4UVal,true);
          OutVal(3,0,ISr.Instock-totlocISr.Instock,M4UVal,true);
          OutVal(4,0,ISr.OrddOut-totlocISr.OrddOut,M4UVal,true);
          t = (ISr.Instock-totlocISr.Instock) - (ISr.OrddOut-totlocISr.OrddOut);
          OutVal(5,0,t,M4UVal,true);
          OutVal(6,0,ISr.POUnOKQty-totlocISr.POUnOKQty,M4UVal,true);
//          OutVal(8,0,ISr.ProdOrd,M4UVal,true);
          OutVal(8,0,dsq,M4UVal,true);
          OutValID(1,"DblDfncyStockVc",t2,M4UVal,true,itemcode & ":" & "");
          EndFormat;
        end;
      end;
    end;
    
  end;
  return;
end;

procedure ShowOneVarietyGroupDeficiency(string group,string itsz,record RcVc RepSpec,record INVc INr,string subsets,string mask,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  record VARVc VARr;
  Boolean found,testf;
  Integer insz;
  string 255 artcode,itemcode,itemname;

  itemcode = INr.Code;
  itemname = INr.Name;
  if (itsz!=".") then begin
    insz = StringToInt(itsz);
  end;
  found = true;
  VARr.VARGCode = group;
  while (LoopKey("VARGCode",VARr,1,found)) begin
    if (VARr.VARGCode!=group) then begin
      found = false;
    end;
    if (found) then begin
      if (itsz!=".") then begin
        artcode = itemcode & VARr.Code;
      end else begin
        artcode = itemcode & itsz & VARr.Code;
      end;      
      INr.Code = artcode;
      INr.Name = itemname & ", " & VARr.Comment;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr,subsets,mask)==false) then begin
          testf = false;
        end;
      end;    
      if (testf) then begin
        PrintData(90,RepSpec,itemcode,INr,blankval,true,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
      end;
    end;
  end;
  return;
end;

procedure ShowTwoVarietiesGroupDeficiency(string group1,string group2,record RcVc RepSpec,record INVc INr,string subsets,string mask,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  record VARVc VARr1;
  Boolean found1,testf;
  record VARVc VARr2;
  Boolean found2;
  record VARGVc VARGr;
  Integer insz1,insz2;
  string 255 artcode,artcode1,itemcode,itemname,itsz1,itsz2,subsettotest;

  itemcode = INr.Code;
  itemname = INr.Name;
  found1 = true;
  VARr1.VARGCode = group1;
  while (LoopKey("VARGCode",VARr1,1,found1)) begin
    if (VARr1.VARGCode!=group1) then begin
      found1 = false;
    end;
    if (found1) then begin
      VARGr.Code = VARr1.VARGCode;
      ReadFIrstMain(VARGr,1,true);
      itsz1 = VARGr.VarSize;
      if (itsz1!=".") then begin
        insz1 = StringToInt(itsz1);
      end;
      if (itsz1!=".") then begin
        artcode = itemcode & VARr1.Code;
      end else begin
        artcode = itemcode & itsz1 & VARr1.Code;
      end;      
      artcode1 = artcode;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr1,subsets,mask)==false) then begin
          testf = false;
        end;
      end;
      
      if (testf) then begin
        ResetLoop(VARr2);
        found2 = true;
        VARr2.VARGCode = group2;
        while (LoopKey("VARGCode",VARr2,1,found2)) begin
          if (VARr2.VARGCode!=group2) then begin
            found2 = false;
          end;
          if (found2) then begin  
            artcode = artcode1;
            VARGr.Code = VARr2.VARGCode;
            ReadFIrstMain(VARGr,1,true);
            itsz2 = VARGr.VarSize;
            if (itsz2!=".") then begin
              insz2 = StringToInt(itsz2);
            end;
            if (itsz2!=".") then begin
              artcode = artcode & VARr2.Code;
            end else begin
              artcode = artcode & itsz2 & VARr2.Code;
            end;      
            INr.Code = artcode;
            INr.Name = itemname & ", "  & VARr1.Comment & ", " & VARr2.Comment;
            testf = true;
            if (nonblank(subsets)) then begin
              if (CheckVARSubsets(VARr2,subsets,mask)==false) then begin
                testf = false;
              end;
            end;
            if (testf) then begin
              PrintData(110,RepSpec,itemcode,INr,blankval,true,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

procedure ShowThreeVarietiesGroupDeficiency(string group1,string group2,string group3,record RcVc RepSpec,record INVc INr,string subsets,string mask,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  record VARVc VARr1;
  Boolean found1;
  record VARVc VARr2;
  Boolean found2;
  record VARVc VARr3;
  Boolean found3,testf;
  record VARGVc VARGr;
  Integer insz1,insz2,insz3;
  string 255 artcode,artcode1,artcode2,itemcode,itemname,itsz1,itsz2,itsz3;
  string 255 varname1,varname2,varname3;

  itemcode = INr.Code;
  itemname = INr.Name;
  found1 = true;
  VARr1.VARGCode = group1;
  while (LoopKey("VARGCode",VARr1,1,found1)) begin
    if (VARr1.VARGCode!=group1) then begin
      found1 = false;
    end;
    if (found1) then begin
      VARGr.Code = VARr1.VARGCode;
      ReadFIrstMain(VARGr,1,true);
      itsz1 = VARGr.VarSize;
      if (itsz1!=".") then begin
        insz1 = StringToInt(itsz1);
      end;
      if (itsz1!=".") then begin
        artcode = itemcode & VARr1.Code;
      end else begin
        artcode = itemcode & itsz1 & VARr1.Code;
      end;      
      artcode1 = artcode;
      testf = true;
      if (nonblank(subsets)) then begin
        if (CheckVARSubsets(VARr1,subsets,mask)==false) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        ResetLoop(VARr2);
        found2 = true;
        VARr2.VARGCode = group2;
        while (LoopKey("VARGCode",VARr2,1,found2)) begin
          if (VARr2.VARGCode!=group2) then begin
            found2 = false;
          end;
          if (found2) then begin  
            artcode = artcode1;
            VARGr.Code = VARr2.VARGCode;
            ReadFIrstMain(VARGr,1,true);
            itsz2 = VARGr.VarSize;
            if (itsz2!=".") then begin
              insz2 = StringToInt(itsz2);
            end;
            if (itsz2!=".") then begin
              artcode = artcode & VARr2.Code;
            end else begin
              artcode = artcode & itsz2 & VARr2.Code;
            end;      
            artcode2 = artcode;

            testf = true;
            if (nonblank(subsets)) then begin
              if (CheckVARSubsets(VARr2,subsets,mask)==false) then begin
                testf = false;
              end;
            end;
            if (testf) then begin
              ResetLoop(VARr3);
              found3 = true;
              VARr3.VARGCode = group3;
              while (LoopKey("VARGCode",VARr3,1,found3)) begin
                if (VARr3.VARGCode!=group3) then begin
                  found3 = false;
                end;
                if (found3) then begin
                  artcode = artcode2;
                  VARGr.Code = VARr3.VARGCode;
                  ReadFIrstMain(VARGr,1,true);
                  itsz2 = VARGr.VarSize;
                  if (itsz2!=".") then begin
                    insz2 = StringToInt(itsz2);
                  end;
                  if (itsz2!=".") then begin
                    artcode = artcode & VARr3.Code;
                  end else begin
                    artcode = artcode & itsz2 & VARr3.Code;
                  end;      
                  INr.Code = artcode;
                  INr.Name = itemname & ", "  & VARr1.Comment & ", " & VARr2.Comment & ", " & VARr3.Comment;
                  testf = true;
                  if (nonblank(subsets)) then begin
                    if (CheckVARSubsets(VARr3,subsets,mask)==false) then begin
                      testf = false;
                    end;
                  end;
                  if (testf) then begin
                    PrintData(150,RepSpec,itemcode,INr,blankval,true,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;

procedure ShowVarietiesDeficiency(record RcVc RepSpec,record INVc INr,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  string 255 itsz,mask,subsets,mskrep,xpos,ypos,zpos,tstr;
  Integer nrofy,pos,i,cnt;
  Array string 20 ac;

  FindItemVAR(INr.Code,itsz,mask,mskrep,subsets);
  cnt = 0;
  pos = 0;
  for (i=0;i<20;i=i+1) begin
    ExtractObj(mask,pos,tstr);
    if (nonblank(tstr)) then begin
      ac[i] = tstr;
      cnt = cnt + 1;
    end else begin
      i = 20;
    end;
  end;
  if (cnt>0) then begin xpos = ac[0]; end;
  if (cnt>1) then begin ypos = ac[1]; end;
  if (cnt>2) then begin zpos = ac[2]; end;

//Trace("mask " & mask," mskrep " & mskrep);

  nrofy = FindYVars(ypos,subsets,mask);

//Trace("xpos " & xpos," ypos " & ypos & " nrofy " & nrofy & " cnt " & cnt & " zpos " & zpos);
  switch (cnt) begin
    case 1: ShowOneVarietyGroupDeficiency(xpos,itsz,RepSpec,INr,subsets,mask,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    case 2: ShowTwoVarietiesGroupDeficiency(xpos,ypos,RepSpec,INr,subsets,mask,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    case 3: ShowThreeVarietiesGroupDeficiency(xpos,ypos,zpos,RepSpec,INr,subsets,mask,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
  end;

  return;
end;

procedure PrintOneItemData(record RcVc RepSpec,record INVc INr,Boolean varf,val dsrsrvq,var string lastgroup,var Boolean itemout,var Boolean headerf,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,Integer arsrvcnt)
begin
  record ITVc ITr;
  string 255 namestr;
    
  if (GetItemNameStr(1,namestr,RepSpec.Stext,INr.Name,INr.Code)) then begin end;
  if (RepSpec.flags[2]==1) then begin
    if (lastgroup<>INr.Group) then begin
      if (itemout==true) then begin
        Gray_Divider(0,1);
      end;
      StartFormat(15);
      OutString(20,0,INr.Group,false);
      ITr.Code = INr.Group;
      if (ReadFirstMain(ITr,1,true)) then begin
        OutString(100,0,ITr.Comment,false);
      end;
      EndFormat;
      Gray_Divider(0,1);
      lastgroup = INr.Group;
      itemout = true;
    end;
  end;
  if (RepSpec.flags[6]!=0) and (varf) then begin
    ShowVarietiesDeficiency(RepSpec,INr,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
  end else begin
    PrintData(90,RepSpec,INr.Code,INr,dsrsrvq,varf,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
  end;
  return;
end;

procedure TestItem(record RcVc RepSpec,record INVc INr,string fromart,string toart,string frcc,string tocc,string frdep,string todep,
                   var Boolean testf,var Boolean TrHs)
begin
  testf = true;
  if (nonblank(RepSpec.LastAcc)) then begin
    if (INr.Department<frdep) then begin
      testf = false;
    end;
    if (INr.Department>todep) then begin
      testf = false;
    end;
  end;
  if (INr.ItemType<>1) then begin testf = false; end;
  if (RepSpec.flags[2]==0) then begin
      if (TrHs) then begin
        if (nonblank(tocc)) then begin
          if (INr.Group>tocc) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(frcc)) then begin
          if (INr.Group<frcc) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(toart)) then begin
          if (INr.Code>toart) then begin
            TrHs = false;
          end;
        end;
      end;
  end;
  if (RepSpec.flags[2]==1) then begin
      if (TrHs) then begin
        if (nonblank(tocc)) then begin
          if (INr.Group>tocc) then begin
            TrHs = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(toart)) then begin
          if (INr.Code>toart) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(fromart)) then begin
          if (INr.Code<fromart) then begin
            testf = false;
          end;
        end;
      end;
  end;
  if (RepSpec.flags[2]==2) then begin
      if (TrHs) then begin
        if (nonblank(tocc)) then begin
          if (INr.Group>tocc) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(frcc)) then begin
          if (INr.Group<frcc) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(toart)) then begin
          if (INr.Code>toart) then begin
            testf = false;
          end;
        end;
      end;
      if (TrHs) then begin
        if (nonblank(fromart)) then begin
          if (INr.Code<fromart) then begin
            testf = false;
          end;
        end;
      end;
  end;
  if (TrHs) then begin
    if (INr.Terminated<>0) then begin
      testf = false;
    end;
  end;
  if (nonblank(RepSpec.f4)) then begin
    if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
      testf = false;
    end;
  end;
  if (nonblank(RepSpec.f5)) then begin
    if (testf==true) then begin
      testf = false;
      ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
    end;
  end;
  if (TrHs==false) then begin testf = false; end;
  return;
end;    

procedure AddtoRsrvArray(string FromLocation,string artcode,val q,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,var Integer arsrvcnt)
begin
  Integer i;
  
  for (i=0;i<arsrvcnt;i=i+1) begin
    if (arsrvitem[i]==artcode) and (arsrvlocation[i]==FromLocation) then begin
      arsrvqty[i] = arsrvqty[i] + q;
      goto LAddtoRsrvArray;
    end;
  end;
  arsrvitem[arsrvcnt] = artcode;
  arsrvlocation[arsrvcnt] = FromLocation;
  arsrvqty[arsrvcnt] = q;
  arsrvcnt = arsrvcnt + 1;
LAddtoRsrvArray:;
  return;
end;    

function val OrderedInt(record IntORVc IntORr,string artcode)
begin
  row IntORVc IntORrw;
  Integer i,rwcnt;
  val res;
  
  rwcnt = MatRowCnt(IntORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IntORr,i,IntORrw);
    if (IntORrw.ArtCode==artcode) then begin
      res = res + IntORrw.Quant;
    end;
  end;
  OrderedInt = res;
  return;
end;    

procedure PrintReservationsIntOR(record RcVc RepSpec,Integer tofilename,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,var Integer arsrvcnt)
begin
  Boolean firstf,TrHs,printf;
  val q,dsrsrvq;
  record StockReservVc SResr;
  record IntORVc IntORr;
  record ItemStatusVc ISr;
  Integer lastFromFileName;
  LongInt lastFromSerNr;
  record PIVc PIr;
  String 255 fromart,toart;
  
  fromart = FirstInRange(RepSpec.f1,20);
  toart =  LastInRange(RepSpec.f1,20);
  firstf = true;
  TrHs = true;
  SResr.Donef = 0;
  SResr.FromFileName = 1;      
  while (LoopKey("FromItem",SResr,2,TrHs)) begin
    if (SResr.Donef!=0) then begin TrHs = false; end;
    if (SResr.FromFileName!=1) then begin TrHs = false; end;
    if (TrHs) then begin
      printf = true;
      if (SResr.ToFileName!=tofilename) then begin
        printf = false;
      end;
      if (printf) then begin
        dsrsrvq = DfncyStockForStockReserv(SResr.FromFileName,SResr.FromSerNr,SResr.ArtCode);
        q = SResr.Quant - dsrsrvq;
//        if (q<=0) then begin printf = false; end;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (SResr.TransDate>RepSpec.d1) then begin printf = false; end;
      end;
      if (nonblanktime(RepSpec.sStartTime)) then begin
        if (SResr.TransTime>RepSpec.sStartTime) then begin printf = false; end;
      end;
      if (nonblank(RepSpec.f1)) then begin
        if (SResr.ArtCode<fromart) then begin printf = false; end;
        if (SResr.ArtCode>toart) then begin printf = false; end;
      end;
      if (printf) then begin
        if (SResr.FromFileName!=lastFromFileName or SResr.FromSerNr!=lastFromSerNr) then begin
          if (lastFromSerNr>0) then begin
            Gray_Divider(0,1);
          end;
          if (firstf) then begin
            StartFormat(20);
            switch (tofilename) begin
              case kResTypeMakeNewPO:
                OutString(0,0,"Back to Back Internal Orders",false);
              case kResTypeNextStockIn:
                OutString(0,0,"Internal Orders reserved from next Purchase Order",false);
            end;
            EndFormat;
            StartFormat(15);
            OutString(0,0,"Ord. No.",false);
            OutString(100,0,"Ord. Date",false);
            OutString(180,0,"Location",false);
            EndFormat;
            Gray_Divider(0,1);
            firstf = false;
          end;
          IntORr.SerNr = SResr.FromSerNr;
          ReadFirstMain(IntORr,1,true);
          StartFormat(15);
          OutLongInt(0,"DblIntORVc",IntORr.SerNr,false);
          OutDate(100,0,IntORr.TransDate,false);
          OutString(180,0,IntORr.Location,false);
          EndFormat;
          StartFormat(15);
          OutStringID(1,"DblAllDfncySRsrvVc",USetStr(17800),true,IntORr.SerNr);
          EndFormat;
          PrintHeaderRsrv;
        end;
        GetStockValue(SResr.ArtCode,IntORr.FrLocation,ISr);
        StartFormat(15);
        OutString(15,0,SResr.ArtCode,false);
        OutString(2,0,SResr.SerialNr,false);
        OutVal(180,0,OrderedInt(IntORr,SResr.ArtCode),M4Val,true);
        OutVal(240,0,ISr.Instock,M4Val,true);
        FindPItem(SResr.ArtCode,"",PIr,RepSpec.f2,RepSpec.flags[1]);
        OutString(250,0,PIr.VECode,false);
        OutVal(360,0,PIr.PurPrice,M4Val,true);
        OutVal(8,0,dsrsrvq,M4Val,true);
        OutValID(1,"DblDfncyStockRsrvVc",q,M4UVal,true,SResr.SerNr);
        EndFormat;
        
        AddtoRsrvArray(SResr.FromLocation,SResr.ArtCode,q,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
        lastFromFileName = SResr.FromFileName;
        lastFromSerNr = SResr.FromSerNr;
      end;
      
    end;
  end;
  if (firstf==False) then begin
    Black_Divider(0,1);
  end;
  return;
end;

procedure PrintReservedIntOrders(record RcVc RepSpec,Integer tofilename,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,var Integer arsrvcnt)
begin
  Boolean firstf,TrHs,printf;
  val q,dsrsrvq;
  record StockReservVc SResr;
  record IntORVc IntORr;
  row IntORVc IntORrw;
  Integer i,rwcnt;
  record ItemStatusVc ISr;
  Integer lastFromFileName;
  LongInt lastFromSerNr;
  record PIVc PIr;
  
  firstf = true;
  TrHs = true;
  SResr.Donef = 0;
  SResr.FromFileName = 0;      
  while (LoopKey("FromItem",SResr,2,TrHs)) begin
    if (SResr.Donef!=0) then begin TrHs = false; end;
    if (SResr.FromFileName!=0) then begin TrHs = false; end;
    if (TrHs) then begin
      printf = true;
      if (SResr.ToFileName!=tofilename) then begin
        printf = false;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (SResr.TransDate>RepSpec.d1) then begin printf = false; end;
      end;
      if (nonblanktime(RepSpec.sStartTime)) then begin
        if (SResr.TransTime>RepSpec.sStartTime) then begin printf = false; end;
      end;
      if (printf) then begin
        if (SResr.FromFileName!=lastFromFileName or SResr.FromSerNr!=lastFromSerNr) then begin
          if (lastFromSerNr>0) then begin
            Gray_Divider(0,1);
          end;
          if (firstf) then begin
            StartFormat(20);
            switch (tofilename) begin
              case kResTypeMakeNewPO:
                OutString(0,0,"Back to Back Internal Orders",false);
              case kResTypeNextStockIn:
                OutString(0,0,"Internal Orders reserved from next Purchase Order",false);
            end;
            EndFormat;
            StartFormat(15);
            OutString(0,0,"Ord. No.",false);
            OutString(100,0,"Ord. Date",false);
            OutString(180,0,"Location",false);
            EndFormat;
            Gray_Divider(0,1);
            firstf = false;
          end;
          IntORr.SerNr = SResr.FromSerNr;
          ReadFirstMain(IntORr,1,true);
          StartFormat(15);
          OutLongInt(0,"DblIntORVc",IntORr.SerNr,false);
          OutDate(100,0,IntORr.TransDate,false);
          OutString(180,0,IntORr.Location,false);
          EndFormat;
          StartFormat(15);
          OutStringID(1,"DblAllDfncySRsrvVc",USetStr(17800),true,IntORr.SerNr);
          EndFormat;
          PrintHeaderRsrv;

          rwcnt = MatRowCnt(IntORr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IntORr,i,IntORrw);
          
            GetStockValue(IntORrw.ArtCode,IntORr.FrLocation,ISr);
            StartFormat(15);
            OutString(15,0,IntORrw.ArtCode,false);
            OutString(2,0,IntORrw.SerialNr,false);
            OutVal(180,0,IntORrw.Quant,M4Val,true);
            OutVal(240,0,ISr.Instock,M4Val,true);
            FindPItem(IntORrw.ArtCode,"",PIr,RepSpec.f2,RepSpec.flags[1]);
            OutString(250,0,PIr.VECode,false);
            OutVal(360,0,PIr.PurPrice,M4Val,true);
            
            dsrsrvq = DfncyStockForStockReserv(SResr.FromFileName,SResr.FromSerNr,IntORrw.ArtCode);
            q = IntORrw.Quant - dsrsrvq;
            
            OutVal(8,0,dsrsrvq,M4Val,true);
            OutValID(1,"DblDfncyStockRsrvVc",q,M4UVal,true,SResr.SerNr);
            EndFormat;
            AddtoRsrvArray(IntORr.FrLocation,IntORrw.ArtCode,q,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
          end;
        
          lastFromFileName = SResr.FromFileName;
          lastFromSerNr = SResr.FromSerNr;
        end;
      end;
      
    end;
  end;
  if (firstf==False) then begin
    Black_Divider(0,1);
  end;
  return;
end;

function val Ordered(record ORVc ORr,string artcode)
begin
  row ORVc ORrw;
  Integer i,rwcnt;
  val res;
  
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.ArtCode==artcode) then begin
      res = res + ORrw.Quant;
    end;
  end;
  Ordered = res;
  return;
end;    

procedure PrintReservations(record RcVc RepSpec,Integer tofilename,var val totdsrsrvq,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,var Integer arsrvcnt)
begin
  Boolean firstf,TrHs,printf;
  val q,dsrsrvq;
  record StockReservVc SResr;
  record ORVc ORr;
  record ItemStatusVc ISr;
  Integer lastFromFileName;
  LongInt lastFromSerNr;
  record PIVc PIr;
  string 255 fromart,toart;
  
  fromart = FirstInRange(RepSpec.f1,20);
  toart =  LastInRange(RepSpec.f1,20);
  firstf = true;
  TrHs = true;
  SResr.Donef = 0;
  SResr.FromFileName = 0;      
  while (LoopKey("FromItem",SResr,2,TrHs)) begin
    if (SResr.Donef!=0) then begin TrHs = false; end;
    if (SResr.FromFileName!=0) then begin TrHs = false; end;
    if (TrHs) then begin
      printf = true;
      if (SResr.ToFileName!=tofilename) then begin
        printf = false;
      end;
      if (printf) then begin
        dsrsrvq = DfncyStockForStockReserv(SResr.FromFileName,SResr.FromSerNr,SResr.ArtCode);
        q = SResr.Quant - dsrsrvq;
//        if (q<=0) then begin printf = false; end;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (SResr.TransDate>RepSpec.d1) then begin printf = false; end;
      end;
      if (nonblanktime(RepSpec.sStartTime)) then begin
        if (SResr.TransTime>RepSpec.sStartTime) then begin printf = false; end;
      end;
      if (nonblank(RepSpec.f1)) then begin
        if (SResr.ArtCode<fromart) then begin printf = false; end;
        if (SResr.ArtCode>toart) then begin printf = false; end;
      end;
      if (printf) then begin
        if (SResr.FromFileName!=lastFromFileName or SResr.FromSerNr!=lastFromSerNr) then begin
          if (lastFromSerNr>0) then begin
            Gray_Divider(0,1);
          end;
          if (firstf) then begin
            StartFormat(20);
            switch (tofilename) begin
              case kResTypeMakeNewPO:
                OutString(0,0,"Back to Back Orders",false);
              case kResTypeNextStockIn:
                OutString(0,0,"Orders reserved from next Purchase Order",false);
            end;
            EndFormat;
            StartFormat(15);
            OutString(0,0,"Ord. No.",false);
            OutString(100,0,"Ord. Date",false);
            OutString(180,0,"Customer",false);
            OutString(300,0,"Name",false);
            EndFormat;
            Gray_Divider(0,1);
            firstf = false;
          end;
          ORr.SerNr = SResr.FromSerNr;
          ReadFirstMain(ORr,1,true);
          StartFormat(15);
          OutLongInt(0,"DblORVc",ORr.SerNr,false);
          OutDate(100,0,ORr.OrdDate,false);
          OutString(180,0,ORr.CustCode,false);
          OutString(300,0,ORr.Addr0,false);
          EndFormat;
          StartFormat(15);
          OutStringID(1,"DblAllDfncySRsrvVc",USetStr(17800),true,ORr.SerNr);
          EndFormat;
          PrintHeaderRsrv;
        end;
        GetStockValue(SResr.ArtCode,ORr.Location,ISr);
        totdsrsrvq = totdsrsrvq + dsrsrvq;
        StartFormat(15);
        OutString(15,0,SResr.ArtCode,false);
        OutString(2,0,SResr.SerialNr,false);
        OutVal(180,0,Ordered(ORr,SResr.ArtCode),M4Val,true);
        OutVal(240,0,ISr.Instock,M4Val,true);
        FindPItem(SResr.ArtCode,"",PIr,RepSpec.f2,RepSpec.flags[1]);
        OutString(250,0,PIr.VECode,false);
        OutVal(360,0,PIr.PurPrice,M4Val,true);
        OutVal(8,0,dsrsrvq,M4Val,true);
        OutValID(1,"DblDfncyStockRsrvVc",q,M4UVal,true,SResr.SerNr);
        EndFormat;
        
        AddtoRsrvArray(SResr.FromLocation,SResr.ArtCode,q,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
        lastFromFileName = SResr.FromFileName;
        lastFromSerNr = SResr.FromSerNr;
      end;
      
    end;
  end;
  if (firstf==False) then begin
    Black_Divider(0,1);
  end;
  return;
end;

procedure PrintReservedOrders(record RcVc RepSpec,Integer tofilename,Array string arsrvitem,Array string arsrvlocation,Array val arsrvqty,var Integer arsrvcnt)
begin
  Boolean firstf,TrHs,printf;
  val q,dsrsrvq;
  record StockReservVc SResr;
  record ORVc ORr;
  row ORVc ORrw;
  Integer i,rwcnt;
  record ItemStatusVc ISr;
  Integer lastFromFileName;
  LongInt lastFromSerNr;
  record PIVc PIr;
  
  firstf = true;
  TrHs = true;
  SResr.Donef = 0;
  SResr.FromFileName = 0;      
  while (LoopKey("FromItem",SResr,2,TrHs)) begin
    if (SResr.Donef!=0) then begin TrHs = false; end;
    if (SResr.FromFileName!=0) then begin TrHs = false; end;
    if (TrHs) then begin
      printf = true;
      if (SResr.ToFileName!=tofilename) then begin
        printf = false;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (SResr.TransDate>RepSpec.d1) then begin printf = false; end;
      end;
      if (nonblanktime(RepSpec.sStartTime)) then begin
        if (SResr.TransTime>RepSpec.sStartTime) then begin printf = false; end;
      end;
      if (printf) then begin
        if (SResr.FromFileName!=lastFromFileName or SResr.FromSerNr!=lastFromSerNr) then begin
          if (lastFromSerNr>0) then begin
            Gray_Divider(0,1);
          end;
          if (firstf) then begin
            StartFormat(20);
            switch (tofilename) begin
              case kResTypeMakeNewPO:
                OutString(0,0,"Back to Back Orders",false);
              case kResTypeNextStockIn:
                OutString(0,0,"Orders reserved from next Purchase Order",false);
            end;
            EndFormat;
            StartFormat(15);
            OutString(0,0,"Ord. No.",false);
            OutString(100,0,"Ord. Date",false);
            OutString(180,0,"Customer",false);
            OutString(300,0,"Name",false);
            EndFormat;
            Gray_Divider(0,1);
            firstf = false;
          end;
          ORr.SerNr = SResr.FromSerNr;
          ReadFirstMain(ORr,1,true);
          StartFormat(15);
          OutLongInt(0,"DblORVc",ORr.SerNr,false);
          OutDate(100,0,ORr.OrdDate,false);
          OutString(180,0,ORr.CustCode,false);
          OutString(300,0,ORr.Addr0,false);
          EndFormat;
          StartFormat(15);
          OutStringID(1,"DblAllDfncySRsrvVc",USetStr(17800),true,ORr.SerNr);
          EndFormat;
          PrintHeaderRsrv;


          rwcnt = MatRowCnt(ORr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(ORr,i,ORrw);
            switch (ORrw.stp) begin
              case 1:
                RecordClear(ISr);
                if (blank(ORrw.ArtCode)) then begin
                  StartFormat(15);
                  OutString(15,0,ORrw.Spec,false);
                  EndFormat;
                end else begin
                  GetStockValue(ORrw.ArtCode,ORr.Location,ISr);

                  StartFormat(15);
                  OutString(15,0,ORrw.ArtCode,false);
                  OutString(2,0,ORrw.SerialNr,false);
                  OutVal(180,0,ORrw.Quant,M4Val,true);
                  OutVal(240,0,ISr.Instock,M4Val,true);
                  FindPItem(ORrw.ArtCode,"",PIr,RepSpec.f2,RepSpec.flags[1]);
                  OutString(250,0,PIr.VECode,false);
                  OutVal(360,0,PIr.PurPrice,M4Val,true);
                
                  dsrsrvq = DfncyStockForStockReserv(SResr.FromFileName,SResr.FromSerNr,ORrw.ArtCode);
                  q = ORrw.Quant - dsrsrvq;
                
                  OutVal(8,0,dsrsrvq,M4Val,true);
                  OutValID(1,"DblDfncyStockRsrvVc",q,M4UVal,true,SResr.SerNr);
                  EndFormat;
                  AddtoRsrvArray(ORr.Location,ORrw.ArtCode,q,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
                end;
              case 9:
                StartFormat(15);
                OutString(15,0,ORrw.Spec,false);
                EndFormat;
              case 10:
                StartFormat(15);
                OutString(15,0,"This row and all rows below it will be hidden on printout",false);
                EndFormat;
            end;
          end;
        
          lastFromFileName = SResr.FromFileName;
          lastFromSerNr = SResr.FromSerNr;
        end;
      end;
      
    end;
  end;
  if (firstf==False) then begin
    Black_Divider(0,1);
  end;
  return;
end;

global
procedure PurLocRn(record RcVc RepSpec)
begin
  record INVc INr;
  record ITVc ITr;
  record ItemStatusVc ISr;
  record PIVc PIr;
  String 255 tstr;
  Integer rw;
  Boolean pifound;
  Boolean TrHs;
  val t,t1,t2;
  String 255 fromart,toart;
  String 255 frcc,tocc;
  String 255 lastgroup;
  Boolean itemout;
  Boolean testf,varf,headerf;
  Boolean printf;
  String 255 ckey;
  Integer keys;
  String 255 namestr;
  String 20 frdep,todep;
  val minlevel,dsrsrvq,q;
  string 255 itsz,mask,subsets,mskrep;
  record ORVc ORr;
  record StockReservVc SResr;
  Integer lastFromFileName;
  LongInt lastFromSerNr;
  array string 20 arsrvitem;
  array string 20 arsrvlocation;
  array val arsrvqty;
  Integer arsrvcnt;
  Boolean firstf;
  val totdsrsrvq;

  fromart = FirstInRange(RepSpec.f1,20);
  toart =  LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,5);
  tocc = LastInRange(RepSpec.f3,5);

  frdep = FirstInRange(RepSpec.LastAcc,10);
  todep = LastInRange(RepSpec.LastAcc,10);

  itemout = false;
  lastgroup ="";
  rw = 1;
  StartReportJob(USetStr(17880));
  HTArtSel(RepSpec.f1,RepSpec.f3,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTCustClass(RepSpec.f4,tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end; 
  HTCustClassType(RepSpec.f5,tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;  
  HTDetailLevel(RepSpec.ArtMode,tstr);
  Header(rw,tstr,0);
  HTSort1(RepSpec.flags[2],tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.LastAcc)) then begin
    HTDepartments(frdep,todep,tstr);
    Header(rw,tstr,0);
  end;
  if (RepSpec.flags[3]==1) then begin
    tstr=USetStr(6651);
    Header(rw,tstr,1);
  end;
  EndHeader;
  headerf = true;

  SetRepCol(2,80);
  SetRepCol(7,180);
  SetRepCol(3,230);
  SetRepCol(4,280);
  SetRepCol(5,320);
  SetRepCol(6,365);
  SetRepCol(8,430);

  if (RepSpec.flags[7]==0) then begin
    PrintReservations(RepSpec,kResTypeMakeNewPO,totdsrsrvq,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    PrintReservations(RepSpec,kResTypeNextStockIn,totdsrsrvq,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    PrintReservationsIntOR(RepSpec,kResTypeMakeNewPO,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    PrintReservationsIntOR(RepSpec,kResTypeNextStockIn,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
  end else begin
    PrintReservedOrders(RepSpec,kResTypeMakeNewPO,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    PrintReservedOrders(RepSpec,kResTypeNextStockIn,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);

    PrintReservedIntOrders(RepSpec,kResTypeMakeNewPO,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
    PrintReservedIntOrders(RepSpec,kResTypeNextStockIn,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
  end;
  TrHs = true;
  if (RepSpec.flags[2]==0) then begin
    INr.Code = fromart;
    ckey = "Code";
    keys = 1;
  end;
  if (RepSpec.flags[2]==1) then begin
    INr.Group = frcc;
    INr.Code = fromart;
    ckey = "Group";
    keys = 2;
  end;
  if (RepSpec.flags[2]==2) then begin
    INr.Name = "";
    ckey = "Name";
    keys = 1;
  end;
  TrHs = true;
  if (RepSpec.flags[6]==0) then begin
    if (FindItemVAR2(fromart,itsz,mask,subsets)) then begin
      if (ReadFirstItem(fromart,INr,true,false)) then begin
        TrHs = true;
        TestItem(RepSpec,INr,fromart,toart,frcc,tocc,frdep,todep,testf,TrHs);
        if (testf) then begin
          INr.Code = fromart;
          PrintOneItemData(RepSpec,INr,true,blankval,lastgroup,itemout,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
          TrHs = false;
        end;
      end;
    end;
  end;
  if (TrHs) then begin
  
    while (LoopKey(ckey,INr,keys,TrHs)) begin
      TestItem(RepSpec,INr,fromart,toart,frcc,tocc,frdep,todep,testf,TrHs);
      if (testf) then begin
        varf = FindItemVAR(INr.Code,itsz,mask,mskrep,subsets);
        PrintOneItemData(RepSpec,INr,varf,totdsrsrvq,lastgroup,itemout,headerf,arsrvitem,arsrvlocation,arsrvqty,arsrvcnt);
      end;
    end;
  end;
L99:;
  EndJob;
  return;
end;
