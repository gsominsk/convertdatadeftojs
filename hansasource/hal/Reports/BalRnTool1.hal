external procedure AGrSumLine(record RcVc,Integer,string,string,string,
                              val,val,val,val,val,val,Boolean,val,Boolean,Boolean,string,LongInt,Boolean,Boolean);
external function Boolean AccRuPerBal(record RcVc,Boolean,string,string,var val,var val,var val,var val,var val,var val,
                                      Integer,Boolean,Date,Date,Date);
external function Boolean GetObjBal(string,string,var record ObjBalVc);

global
procedure SumLine2(record RcVc RepSpec,Boolean PLf,string t1,string t2,string extracode,
                   var val Sum1p,var val Sum2p,var val Sum3p,var val Sum4p,var val Sum5p,
                   var val Sum6p,Boolean negf,val goms,Boolean resUseAccum,Date AccumStartDate,Integer DCSide,LongInt agrid,Boolean printf)
BEGIN
  record ObjVc RUr;
  Boolean Accs,RUOut,usedf;
  val S3b1,Pb1,Eb1,S4b1,S5b1,S6b1;
  val S3b2,Pb2,Eb2,S4b2,S5b2,S6b2;
  val S3b3,Pb3,Eb3,S4b3,S5b3,S6b3;
  string 255 tstr,nru,objs;
  record ObjBalVc ObjBalr;
  Boolean Objbals;

  S3b2 = Sum1p;
  Pb2 = Sum2p;
  Eb2 = Sum3p;
  S4b2 = Sum4p;
  S5b2 = Sum5p;
  S6b2 = Sum6p;
  RUOut = false;
  RUr.OTCode = RepSpec.ObjType;
  RUr.Code = "";
  Accs = true;
  while (LoopKey("OTCode",RUr,2,Accs)) begin
    if (RUr.OTCode!=RepSpec.ObjType) then begin 
      goto L22SumLine2;
    end;
    if (RepSpec.critname=="ResRClass") then begin
      if (nonblank(RepSpec.f6)) then begin
        if (SetInSet(RUr.Code,RepSpec.f6)) then begin
          goto LSkipObjectSumLine2;
        end;
      end;
    end;

    ObjBalr.AccNumber = t1;
    ObjBalr.Object = RUr.Code;
//    Objbals = ReadFirstMain(RUr,1,true);
    Objbals = GetObjBal(t1,RUr.Code,ObjBalr);
    if (RepSpec.IncDaughter==1) then begin//otherwise it skips daughter
//        if (cstreq(RepSpec.repname,"ResRn")==false) then
//            if (Objbals==false) then goto LSkipObjectSumLine2;
    end else begin
//        if (Objbals==false) then begin //budget may be defined even if no NL transactions
//          goto LSkipObjectSumLine2;
//        end;  
    end;  
    usedf = AccRuPerBal(RepSpec,PLf,t1,RUr.Code,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,0,resUseAccum,AccumStartDate,RepSpec.sStartDate,RepSpec.sEndDate);
// Jarek thinks that it is not correct fix and we need to discuss it more
// I agree, but as you said, we should probably analyse this before dismissing it...
// [Jarek] we do not have amounts per objects set , like A,B, in support register
/*
    objs = RUr.Code;
    if (nonblank(RepSpec.ObjStr)) then begin
      objs = objs & ",";
      objs = objs & RepSpec.ObjStr;
    end;
    usedf = AccRuPerBal(RepSpec,PLf,t1,objs,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,0,resUseAccum,AccumStartDate,RepSpec.sStartDate,RepSpec.sEndDate);
*/
    S3b2 = S3b2 - S3b1;
    S4b2 = S4b2 - S4b1;
    S5b2 = S5b2 - S5b1;
    S6b2 = S6b2 - S6b1;
    Pb2 = Pb2 - Pb1;
    Eb2 = Eb2 - Eb1;
    S3b3 = S3b3 + S3b1;
    S4b3 = S4b3 + S4b1;
    S5b3 = S5b3 + S5b1;
    S6b3 = S6b3 + S6b1;
    Pb3 = Pb3 + Pb1;
    Eb3 = Eb3 + Eb1;  
    if ((S3b1==0) or (S4b1==0) or (S5b1==0) or (S6b1==0) or (Pb1==0) or (Eb1==0) or (usedf)) then begin
      if (RUOut==false) then begin
        if (printf) then begin
          StartFormat(15);
          OutString(0,0,t1,false);
          OutString(2,0,t2,false);
          EndFormat;
          RUOut = true;
        end;
      end;
      nru = RUr.Code;
      if (nonblank(RepSpec.ObjStr)) then begin
        nru = nru & ",";
        nru = nru & RepSpec.ObjStr;
      end;
      AGrSumLine(RepSpec,6,nru,RUr.Comment,extracode,S3b1,Pb1,Eb1,S4b1,S5b1,S6b1,negf,goms,PLf,resUseAccum,"",agrid,usedf,printf);
    end;
LSkipObjectSumLine2:;
  end;
L22SumLine2:;
  if (RepSpec.flags[2]!=0) then begin
    if (RUOut) then begin
      if ((S3b2!=0) or (S4b2!=0) or (S5b2!=0) or (S6b2!=0) or (Pb2!=0) or (Eb2!=0)) then begin
        AGrSumLine(RepSpec,6,"",USetStr(3141),extracode,S3b2,Pb2,Eb2,S4b2,S5b2,S6b2,negf,goms,PLf,resUseAccum,"DblNL",agrid,usedf,printf);
      end;
      AGrSumLine(RepSpec,6,"",USetStr(3142),extracode,Sum1p,Sum2p,Sum3p,Sum4p,Sum5p,Sum6p,negf,goms,PLf,resUseAccum,"DblNL",agrid,usedf,printf);
    end else begin
      AGrSumLine(RepSpec,0,t1,t2,extracode,Sum1p,Sum2p,Sum3p,Sum4p,Sum5p,Sum6p,negf,goms,PLf,resUseAccum,"DblNL",agrid,usedf,printf);
    end;
  end else begin
    if (RUOut) then begin
      AGrSumLine(RepSpec,6,"",USetStr(3142),extracode,S3b3,Pb3,Eb3,S4b3,S5b3,S6b3,negf,goms,PLf,resUseAccum,"DblNL",agrid,usedf,printf);
    end;
    Sum1p = S3b3;
    Sum2p = Pb3;
    Sum3p = Eb3;
    Sum4p = S4b3;
    Sum5p = S5b3;
    Sum6p = S6b3;
  end;
  RETURN;
END;

global
procedure GetUserDefRepDescription(record UserDefRepLinesVc UserDefRepLinesr,string language,var string res)
BEGIN
  row UserDefRepLinesVc UserDefRepLinesrw;
  Integer i,rwcnt;
  
  res = UserDefRepLinesr.Comment;
  if (language=="-1") then begin
    goto LGetUserDefRepDescription;
  end;
  if (nonblank(language)) then begin
    rwcnt = MatRowCnt(UserDefRepLinesr);
    for (i=0; i<rwcnt ;i=i+1) begin
      MatRowGet(UserDefRepLinesr,i,UserDefRepLinesrw);
      if (UserDefRepLinesrw.LangCode==language) then begin
        if (nonblank(UserDefRepLinesrw.Text)) then begin
          res = UserDefRepLinesrw.Text;
        end;  
        goto LGetUserDefRepDescription;
      end;
    end;  
  end;
LGetUserDefRepDescription:;
  RETURN;
END;

global
procedure InitLongArray(Integer maxrsums,var Array LongInt lv)
BEGIN
  Integer i;
  
  for (i=0;i<=maxrsums;i=i+1) begin
    lv[i] = -1;
  end;  
  RETURN;
END;

global
procedure InitValArray(Integer maxrsums,var Array val arrv)
BEGIN
  Integer i;
  
  for (i=0;i<=maxrsums;i=i+1) begin
    arrv[i] = 0;
  end;  
  RETURN;
END;

global
procedure InitIntegerArray(Integer maxrsums,var Array Integer iv)
BEGIN
  Integer i;
  
  for (i=0;i<=maxrsums;i=i+1) begin
    iv[i] = -1;
  end;  
  RETURN;
END;
