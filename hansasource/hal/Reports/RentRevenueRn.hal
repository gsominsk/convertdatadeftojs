external function Integer DateGetIntMonth(Date);
external procedure HTLocations(string, string, var string);
external procedure HT2Per(Date, Date , var string);
external function LongInt CountWorkingDays(Date,Date,string,string);
/*
function val FindOffHireMonth(LongInt rentresnr,Date sStart,Date sEnd)
begin
  record RentChrgVc RentCharger;
  boolean TrHs,testf;
  val tsum;
  
  tsum = 0;
  RentCharger.FileName = -1;
  RentCharger.TransNr = rentresnr;
  TrHs = true;
  while (LoopKey("TransNr",RentCharger,2,TrHs)) begin
    if (RentCharger.FileName!=-1) then begin TrHs = false; end;
    if (RentCharger.TransNr!=rentresnr) then begin TrHs = false; end;
    if (TrHs) then begin
      testf = true;
      if (DateInRange(RentCharger.ToDate,sStart,sEnd)==false) then begin testf = false; end;
      if (RentCharger.InvNr<=0) then begin testf = false; end;
      if (testf) then begin
        tsum = tsum + RentCharger.Sum;
      end;
    end;
  end; 
  FindOffHireMonth = tsum;
  return;
end;

procedure CalcRevenueOld(record RcVc RepSpec, record RentResVc Rentr,var val ActRev,var val NotCharged,var val Forecast,val extday)
begin
  val days,days2;
  record CUVc CUr;
  record AgreementVc Agreementr;
  Date sStart;
  Date sEnd;
  string 10 countrycode;
  string 20 custcode;
  
  Agreementr.SerNr = Rentr.AgreementNr;
  if (ReadFirstMain(Agreementr,1,true)) then begin
     custcode = Agreementr.CustCode;
  end;
  
  CUr.Code = custcode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (nonblank(CUr.CountryCode)) then begin
      countrycode = CUr.CountryCode;
    end;
  end;
  if (Rentr.TransDate<CurrentDate) then begin
    if (nonblankdate(Rentr.LastChargeDate)) then begin
      if (Rentr.LastChargeDate > Rentr.TransDate) then begin
        sStart = Rentr.LastChargeDate;
      end;
    end;
    if (blankdate(sStart)) then begin
      sStart = Rentr.TransDate;
    end;    
    days = CountWorkingDays(sStart,CurrentDate,custcode,countrycode) + extday;
  end;
  if (blankdate(Rentr.EndDate)) then begin
    sEnd = RepSpec.sEndDate;
  end;  
  if (nonblankdate(Rentr.EndDate)) then begin
    if (RepSpec.sEndDate<=Rentr.EndDate) then begin
      sEnd = RepSpec.sEndDate;
    end else begin
      if (RepSpec.sEndDate > Rentr.EndDate) then begin
        if (Rentr.EndDate < CurrentDate) then begin
          days2 = 0;
          goto L99;
        end;
        if (Rentr.EndDate > CurrentDate) then begin
          sEnd = Rentr.EndDate;
        end;
      end;
    end;
  end;
  if (Rentr.TransDate > CurrentDate) then begin
    days2 = CountWorkingDays(Rentr.TransDate,sEnd,custcode,countrycode) + extday;
  end else begin
    days2 = CountWorkingDays(CurrentDate,sEnd,custcode,countrycode);
  end;
L99:;
  NotCharged = days * Rentr.Sum;
  Forecast = days2 * Rentr.Sum;
  if (NotCharged<0) then begin NotCharged = 0; end;
  if (Forecast<0) then begin Forecast = 0; end;
  ActRev = FindOffHireMonth(Rentr.SerNr,RepSpec.sStartDate,sEnd);
  return;
end;
*/

function val CalcCharges(LongInt sernr,Boolean invoiced,string site,longint filename,longint transnr)
begin
  record RentChrgVc RentChrgr;
  Boolean foundf2,testf2;
  val totsum;

  foundf2 = true;
  totsum = 0;
  RentChrgr.AgreementNr = sernr;
  if (invoiced==false) then begin
    RentChrgr.InvNr = -1;
  end else begin
    RentChrgr.InvNr = 0;
  end;
  while(LoopKey("AgrInv",RentChrgr,2,foundf2)) begin
    testf2 = true;
    if (RentChrgr.AgreementNr<>sernr) then begin
      foundf2 = false;
    end;
    if ((RentChrgr.FileName!=filename) or (RentChrgr.TransNr!=transnr)) then begin
      testf2 = false;
    end;
    if (invoiced==false) then begin
      if (RentChrgr.InvNr>-1) then begin
        foundf2 = false;
      end;
    end else begin
      if (RentChrgr.InvNr<0) then begin
        foundf2 = false;
      end;
    end;
    if (foundf2==false) then begin
      testf2 = false;
    end;
    if (nonblank(site)) then begin
      if (site!=RentChrgr.Site) then begin
        testf2 = false;
      end;
    end;
    if (testf2) then begin
      totsum = totsum + RentChrgr.Sum;
    end;
  end;
  CalcCharges = totsum;
  return;
end;

procedure CalcRevenue(record RcVc RepSpec, record RentResVc Rentr,var val Invoiced,var val ChargedNotInvoiced,var val Forecast,val extday)
begin
  val days,days2;
  record CUVc CUr;
  record AgreementVc Agreementr;
  Date sStart;
  Date sEnd;
  string 10 countrycode;
  string 20 custcode;
  record AgreeTypeVc ATr;
  
  Agreementr.SerNr = Rentr.AgreementNr;
  if (ReadFirstMain(Agreementr,1,true)) then begin
    custcode = Agreementr.CustCode;
  end;    
  CUr.Code = custcode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (nonblank(CUr.CountryCode)) then begin
      countrycode = CUr.CountryCode;
    end;
  end;
  ATr.Code = Rentr.AgreeType; 
  ReadFirstMain(ATr,1,true);
  
  sStart = CurrentDate;
  if (Rentr.TransDate>sStart) then begin
    sStart = Rentr.TransDate;
  end;  
  if (sStart<RepSpec.sStartDate) then begin
    sStart = RepSpec.sStartDate;
  end;
  sEnd = RepSpec.sEndDate;
  if (nonblankdate(Rentr.EndDate)) then begin
    if (RepSpec.sEndDate>Rentr.EndDate) then begin
      sEnd = Rentr.EndDate;
    end;
  end;
  if (nonblankdate(Rentr.LastChargeDate)) then begin
    if (sStart<Rentr.LastChargeDate) then begin
      sStart = Rentr.LastChargeDate;
      if (GetDay(Rentr.LastChargeDate)==DaysInMonth(GetDay(Rentr.LastChargeDate),GetMonth(Rentr.LastChargeDate))) then begin
        sStart = AddDay(Rentr.LastChargeDate,1);
      end;
    end;
  end;
  if (Rentr.AdvPrActive==0) then begin
    switch (ATr.perType) begin
      case 0:
        days2 = CountWorkingDays(sStart,sEnd,custcode,countrycode);
        if (Rentr.TransDate>CurrentDate) then begin
          days2 = days2 + extday;
        end;
        Forecast = days2 * Rentr.Sum;
      case 1:
        days2 = DateGetIntMonth(sEnd) - DateGetIntMonth(sStart) + 1;
        Forecast = days2 * Rentr.Sum/Rentr.RentQuant;
      otherwise
        //?
    end;
  end;
//  Invoiced = CalcCharges(Rentr.AgreementNr,true,"");
//  ChargedNotInvoiced = CalcCharges(Rentr.AgreementNr,false,"");
  Invoiced = CalcCharges(Rentr.AgreementNr,true,"",-1,Rentr.SerNr);
  ChargedNotInvoiced = CalcCharges(Rentr.AgreementNr,false,"",-1,Rentr.SerNr);
  if (ChargedNotInvoiced<0) then begin ChargedNotInvoiced = 0; end;
  if (Forecast<0) then begin Forecast = 0; end;
//  Invoiced = FindOffHireMonth(Rentr.SerNr,RepSpec.sStartDate,sEnd);
  return;
end;

global 
procedure RentRevenueRn(record RcVc RepSpec)
begin
  record RentResVc Rentr;
  record RentControlBlock RentControlr;
  val Invoiced, ChargedNotInvoiced, Forecast,Total;
  val tInvoiced, tChargedNotInvoiced,tForecast, tTotal,tsum;
  val extday;
  boolean TrHs, testf;
  Integer rw;
  string 255 tstr;
 
  BlockLoad(RentControlr);
  if (RentControlr.ChargeForFirstDay <> 0) then begin
    extday = 1;
  end else begin
    extday = 0;
  end;
 
  StartReportJob(USetStr(13130));
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTLocations(RepSpec.f1,RepSpec.f1,tstr);
  Header(rw,tstr,1);
  EndHeader;
  StartFormat(15);
  OutString(0,0,USetStr(13131),false);
  OutString(90,0,USetStr(13132),false);
  OutString(150,0,USetStr(13133),false);
  OutString(260,0,USetStr(13139),true);
  OutString(330,0,USetStr(13134),true);
  OutString(400,0,USetStr(13135),true);
  OutString(1,0,USetStr(13136),true);
  EndFormat;
  Gray_Divider(0,1);
  TrHs = true;

  Rentr.SerNr = -1;
  while (LoopMain(Rentr,1,TrHs)) begin
    if (TrHs) then begin
      testf = true;  
      if (Rentr.Price == 0) then begin
        testf = false;
      end;
      if (Rentr.TransDate>=RepSpec.sEndDate) then begin//discuss
        testf = false;
      end;
      if (Rentr.Done <> 0) then begin
        testf = false;
      end;
      if (Rentr.RentResRet > 0) then begin
        testf = false;
      end;
      if (nonblank(RepSpec.f1)) then begin
        if (RepSpec.f1 <> Rentr.Location) then begin
          testf = false;
        end;
      end;
      if (testf) then begin
        StartFormat(15);
        OutStringID(0,"DblRentResVc",Rentr.SerNr,false,Rentr.SerNr);
        OutString(90,0,Rentr.SerialNr,false);
        if (Rentr.EndDate < RepSpec.sEndDate) then begin
          OutString(150,0,Rentr.EndDate,false);
        end;
//        CalcRevenueOld(RepSpec,Rentr,Invoiced,ChargedNotInvoiced,Forecast,extday);
        CalcRevenue(RepSpec,Rentr,Invoiced,ChargedNotInvoiced,Forecast,extday);
        OutVal(260,0,Invoiced,M40Val,true);
        OutVal(330,0,ChargedNotInvoiced,M40Val,true);
        OutVal(400,0,Forecast,M40Val,true);
        Total = Invoiced + ChargedNotInvoiced + Forecast;
        OutVal(1,0,Total,M40Val,true);
        EndFormat;
        tInvoiced = tInvoiced + Invoiced;
        tChargedNotInvoiced = tChargedNotInvoiced + ChargedNotInvoiced;
        tForecast = tForecast + Forecast;
        tTotal = tTotal + Total;
      end;
    end;        
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(13137),false);
  OutVal(260,0,tInvoiced,M40Val,true);
  OutVal(330,0,tChargedNotInvoiced,M40Val,true);
  OutVal(400,0,tForecast,M40Val,true);
  OutVal(1,0,tTotal,M40Val,true);
  EndFormat;
  
  StartFormat(15);
  OutString(0,0,USetStr(13138),false);
  OutVal(330,0,tsum,M40Val,true);
  tTotal = tTotal + tsum;
  OutVal(1,0,tTotal,M40Val,true);
  EndFormat; 
 
  EndJob;
  return;
end;

