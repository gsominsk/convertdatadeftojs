external function roundmode SetRoundModeD(Integer);
external procedure HT2Per(Date, Date , var string);
external function LongInt DateDiff(Date,Date);

procedure AddToTimeArray(record TimingDataVc TimingDatar,var array string auser,var array val alength,var array val atransa,var array val ainserv,var array val awaitsv,var array val anetwor,var LongInt acnt)
begin
  LongInt i;
  Boolean foundf;
  
  foundf = false;
  for (i=0;i<acnt;i=i+1) begin
    if (auser[i]==TimingDatar.UserCode) then begin
      alength[i] = alength[i] + TimingDatar.Length/1000;
      atransa[i] = atransa[i] + TimingDatar.Transactions;
      ainserv[i] = ainserv[i] + TimingDatar.TimeInServer;
      awaitsv[i] = awaitsv[i] + TimingDatar.ServerWait;
      anetwor[i] = anetwor[i] + TimingDatar.NetworkTime;
      foundf = true;
    end;
  end;
  if (foundf==false) then begin
    auser[acnt] = TimingDatar.UserCode;
    alength[acnt] = TimingDatar.Length/1000;
    atransa[acnt] = TimingDatar.Transactions;
    ainserv[acnt] = TimingDatar.TimeInServer;
    awaitsv[acnt] = TimingDatar.ServerWait;
    anetwor[acnt] = TimingDatar.NetworkTime;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure ConnectionLogRn(record RcVc RepSpec)
begin
  record TimingDataVc TimingDatar;
  Boolean foundf,testf;
  array string 20 auser;
  array val alength;
  array val atransa;
  array val ainserv;
  array val awaitsv;
  array val anetwor;
  LongInt acnt,i;
  val a;
  Integer segments;
  string 20 thekey;
  
  acnt = 0;
  StartReportJob(USetStr(16350));
  EndHeader;
  SetRepCol(2,60);
  SetRepCol(3,40);
  SetRepCol(4,120);
  switch (RepSpec.ArtMode) begin
    case 0:
      SetRepCol(5,180);
      SetRepCol(6,280);
      SetRepCol(7,380);
    case 1:
      SetRepCol(5,240);
      SetRepCol(6,300);
      SetRepCol(7,360);
      SetRepCol(8,420);
  end;
  
  
  if ((blankdate(RepSpec.d1)) and (blank(RepSpec.f1))) then begin
    StartFormat(15);
    OutString(0,0,USetStr(16360),false);
    EndFormat;
    goto LConnectionLogRn;
  end;
  switch (RepSpec.ArtMode) begin
    case 0:
      StartFormat(15);
      OutString(6,0,USetStr(16361),true);
      OutString(7,0,USetStr(16361),true);
      OutString(1,0,USetStr(16361),true);
      EndFormat;
      StartFormat(15);
      OutString(0,0,USetStr(16351),false);
      OutString(4,0,USetStr(16354),true);
      OutString(5,0,USetStr(16355),true);
      OutString(6,0,USetStr(16356),true);
      OutString(7,0,USetStr(16357),true);
      OutString(1,0,USetStr(16358),true);
      EndFormat;
    case 1:
      StartFormat(15);
      OutString(7,0,USetStr(16359),true);
      OutString(8,0,USetStr(16359),true);
      EndFormat;
      StartFormat(15);
      if (blank(RepSpec.f1)) then begin
        OutString(0,0,USetStr(16352),false);
        OutString(2,0,USetStr(16353),false);
        OutString(4,0,USetStr(16351),false);
      end else begin
        OutString(0,0,USetStr(16351),false);
        OutString(3,0,USetStr(16352),false);
        OutString(4,0,USetStr(16353),false);
      end;
      OutString(5,0,USetStr(16354),true);
      OutString(6,0,USetStr(16355),true);
      OutString(7,0,USetStr(16356),true);
      OutString(8,0,USetStr(16357),true);
      OutString(1,0,USetStr(16358),true);
      EndFormat;
  end;
  Gray_Divider(0,1);
  if (blank(RepSpec.f1)) then begin
    segments = 2;
    thekey = "DateTime";
  end else begin
    segments = 3;
    thekey = "UserCode";
  end;
  foundf = true;
  TimingDatar.UserCode = RepSpec.f1;
  TimingDatar.Date = RepSpec.d1;
  TimingDatar.Time = RepSpec.sStartTime;
  while LoopKey(thekey,TimingDatar,segments,foundf) begin
    if (nonblank(RepSpec.f1)) then begin
      if (RepSpec.f1!=TimingDatar.UserCode) then begin
        foundf = false;
      end;
    end;
    testf = foundf;
    if (testf) then begin
      switch (RepSpec.ArtMode) begin
        case 0:
          AddToTimeArray(TimingDatar,auser,alength,atransa,ainserv,awaitsv,anetwor,acnt);
        case 1:
          StartFormat(15);
          if (blank(RepSpec.f1)) then begin
            OutString(0,0,TimingDatar.Date,false);
            OutStringID(2,"DblSlowConnect",Left(TimingDatar.Time,5),false,TimingDatar.UserCode & ":" & TimingDatar.Date);
            OutString(4,0,TimingDatar.UserCode,false);
          end else begin
            OutString(0,0,TimingDatar.UserCode,false);
            OutString(3,0,TimingDatar.Date,false);
            OutStringID(4,"DblSlowConnect",Left(TimingDatar.Time,5),false,TimingDatar.UserCode & ":" & TimingDatar.Date);
          end;
          OutLongInt(5,0,TimingDatar.Length/1000,true);
          OutLongInt(6,0,TimingDatar.Transactions,true);
          a = TimingDatar.TimeInServer;
          OutVal(7,0,a/1000,M4Val,true);
          a = TimingDatar.ServerWait;
          OutVal(8,0,a/1000,M4Val,true);
          a = TimingDatar.NetworkTime;
          OutVal(1,0,a/1000,M4Val,true);
          EndFormat;
      end;
    end;
  end;
  if (RepSpec.ArtMode==0) then begin
    for (i=0;i<acnt;i=i+1) begin
      StartFormat(15);
      OutString(0,"DblDetailConnect",auser[i],false);
      OutLongInt(4,0,alength[i],true);
      OutLongInt(5,0,atransa[i],true);

      OutVal(6,0,ainserv[i]/atransa[i]/1000,M4Val,true);
      OutVal(7,0,awaitsv[i]/atransa[i]/1000,M4Val,true);
      OutVal(1,0,anetwor[i]/atransa[i]/1000,M4Val,true);
      EndFormat;
    end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(16362),false);
  EndFormat;
LConnectionLogRn:;
  EndJob;
  return;
end;

global
procedure SlowConLogRn(record RcVc RepSpec)
begin
  record SlowFunctionsVc SlowFunctionsr;
  Boolean foundf,testf;
  val a;
  
  StartReportJob(USetStr(16364));
  EndHeader;
  SetRepCol(2,60);
  SetRepCol(3,40);
  SetRepCol(4,120);
  SetRepCol(5,160);
  SetRepCol(6,200);
  
  StartFormat(15);
  OutString(0,0,USetStr(16351),false);
  OutString(3,0,USetStr(16352),false);
  OutString(4,0,USetStr(16353),false);
  OutString(5,0,USetStr(16365),false);
  OutString(6,0,USetStr(16363),false);
  OutString(1,0,USetStr(16359),true);
  EndFormat;
  Gray_Divider(0,1);
  foundf = true;
  SlowFunctionsr.UserCode = RepSpec.f1;
  SlowFunctionsr.Date = RepSpec.d1;
  SlowFunctionsr.Time = RepSpec.sStartTime;
  while LoopKey("UserCode",SlowFunctionsr,3,foundf) begin
    if (nonblank(RepSpec.f1)) then begin
      if (RepSpec.f1!=SlowFunctionsr.UserCode) then begin
        foundf = false;
      end;
    end;
    testf = foundf;
    if (testf) then begin
      StartFormat(15);
      OutString(0,0,SlowFunctionsr.UserCode,false);
      OutString(3,0,SlowFunctionsr.Date,false);
      OutString(4,0,Left(SlowFunctionsr.Time,5),false);
      OutString(5,0,SlowFunctionsr.AC,false);
      OutString(6,0,SlowFunctionsr.Comment,false);
      a = SlowFunctionsr.TimeInServer;
      OutVal(1,0,a/1000,M4Val,true);
      EndFormat;
    end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(16362),false);
  EndFormat;
  EndJob;
  return;
end;

function string 255 GetACShortDesc(string ac)
begin
  string 255 res;
  Integer accode;
  
  accode = StringToLongInt(ac);
  switch (accode) begin
case 1: res = "SBlockGet";
case 2: res = "SRPosition";
case 3: res = "InsertPost";
case 4: res = "RecordExists";
case 5: res = "Remove";
case 6: res = "Invalidate";
case 7: res = "PreviousPost";
case 8: res = "NextPost";
case 9: res = "LockForUpdate";
case 10: res = "UpdatePost2";
case 11: res = "BlockUpdate";
case 12: res = "RecListAction";
case 13: res = "DoReport";
case 14: res = "NewPost";
case 15: res = "DuplicatePost";
case 16: res = "RegisterAtSV";
case 17: res = "ServerIsAlive";
case 18: res = "ReadFirstMain";
case 19: res = "SavePost";
case 20: res = "DeletePost";
case 21: res = "ChangePassword";
case 22: res = "DoImport";
case 23: res = "ServerImport";
case 24: res = "DoExport";
case 25: res = "ReadPostIDNr";
case 26: res = "MlistRows";
case 27: res = "IsPostLocked";
case 28: res = "BrowseReadPostIDNr";
case 29: res = "Disconnect";
case 30: res = "LockBlock";
case 31: res = "InvoicePrint";
case 32: res = "UnlockPost";
case 33: res = "UnlockBlock";
case 34: res = "Maint";
case 35: res = "Login";
case 36: res = "GetBlocks";
case 37: res = "SysList";
case 38: res = "ConfWHandle";
case 39: res = "ClientPoll";
case 40: res = "ReadFirstCKey";
case 41: res = "ReadLastCKey";
case 42: res = "ReadLastMain";
case 43: res = "FindMailBoxName";
case 44: res = "ViewSize";
case 45: res = "xx11";
case 46: res = "StartFileTransfer";
case 47: res = "FileTransBlock";
case 48: res = "EndFileTransfer";
case 49: res = "GetStartFileTransfer";
case 50: res = "GetFileTransBlock";
case 51: res = "GetEndFileTransfer";
case 52: res = "LogOffUser";
case 53: res = "NoLockedItems";
case 54: res = "ServerEnv";
case 55: res = "CheckKey";
case 56: res = "ChatText";
case 57: res = "LeaveChat";
case 58: res = "InviteToChat";
case 59: res = "ServerStatus";
case 60: res = "ActsInDay";
case 61: res = "ReservationsInDay";
case 62: res = "RTInDay";
case 63: res = "DoBrowseDrag";
case 64: res = "RecordStore";
case 65: res = "SocketInfo";
case 66: res = "RemoteCall";
case 67: res = "GetServerMailboxList";
case 68: res = "FillArchiveW";
case 69: res = "StarSearch";
case 70: res = "FillToDo";
case 71: res = "ClientPollNW";
case 72: res = "SocketInfo2";
case 73: res = "GetNumberOfUsers";
case 74: res = "SyncRegister";
case 75: res = "SyncPost";
case 76: res = "ReadFirstSequence";
case 77: res = "SyncBlock";
case 78: res = "SyncBegin";
case 79: res = "SyncEnd";
case 80: res = "SyncPostDone";
case 81: res = "BlockLocked";
case 82: res = "GenerateReport";
case 83: res = "DeleteAttachFile";
case 84: res = "GetReportList";
case 85: res = "SetReadFlag";
case 86: res = "HTS";
case 87: res = "RemoteCallNonDest";
case 88: res = "ReRegisterAtSV";
case 89: res = "GetFileBinSize";
case 90: res = "SIPOutboundCall";
case 91: res = "CancelReport";
  end;
  GetACShortDesc = res;
  return;
end;

global
procedure SlowConPerRn(record RcVc RepSpec)
begin
  record SlowFunctionsVc SlowFunctionsr;
  Boolean foundf,testf;
  val a;
  
  StartReportJob(USetStr(16364));
  EndHeader;
  SetRepCol(3,60);
  SetRepCol(4,95);
  SetRepCol(5,200);
  SetRepCol(6,440);
  
  StartFormat(15);
  OutString(0,0,USetStr(16352),false);
  OutString(3,0,USetStr(16353),false);
  OutString(4,0,USetStr(16365),false);
  OutString(5,0,USetStr(16363),false);
  OutString(6,0,USetStr(16359),true);
  OutString(1,0,USetStr(16351),true);
  EndFormat;
  Gray_Divider(0,1);
  foundf = true;
  SlowFunctionsr.Date = RepSpec.sStartDate;
  SlowFunctionsr.Time = RepSpec.sStartTime;
  while LoopKey("DateTime",SlowFunctionsr,2,foundf) begin
    if (DateInRange(SlowFunctionsr.Date,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin
      foundf = false;
    end;
    testf = foundf;
    if (testf) then begin
      StartFormat(15);
      OutString(0,0,SlowFunctionsr.Date,false);
      OutString(3,0,Left(SlowFunctionsr.Time,5),false);
      OutString(4,0,GetACShortDesc(SlowFunctionsr.AC) & " (" & SlowFunctionsr.AC & ")",false);
      OutString(5,0,SlowFunctionsr.Comment,false);
      a = SlowFunctionsr.TimeInServer;
      OutVal(6,0,a/1000,M4Val,true);
      OutString(1,0,SlowFunctionsr.UserCode,true);
      EndFormat;
    end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  OutString(0,0,USetStr(16362),false);
  EndFormat;
  EndJob;
  return;
end;

procedure AddToLatencyArray(record TimingDataVc TimingDatar,var array string auser,var array Date adate,var array val alength,var array val atransa,var array val anetwor,var LongInt acnt)
begin
  LongInt i;
  Boolean foundf;
  
  foundf = false;
  for (i=0;i<acnt;i=i+1) begin
    if ((auser[i]==TimingDatar.UserCode) and (adate[i]==TimingDatar.Date)) then begin
      alength[i] = alength[i] + TimingDatar.Length/1000;
      atransa[i] = atransa[i] + TimingDatar.Transactions;
      anetwor[i] = anetwor[i] + TimingDatar.NetworkTime;
      foundf = true;
    end;
  end;
  if (foundf==false) then begin
    auser[acnt] = TimingDatar.UserCode;
    adate[acnt] = TimingDatar.Date;
    alength[acnt] = TimingDatar.Length/1000;
    atransa[acnt] = TimingDatar.Transactions;
    anetwor[acnt] = TimingDatar.NetworkTime;
    acnt = acnt + 1;
  end;
  return;
end;

procedure AddToLatencyDayArray(record TimingDataVc TimingDatar,array Time aheadtime,var array string auser,var array Time atime,var array val alength,var array val atransa,var array val anetwor,var LongInt acnt)
begin
  LongInt i;
  Boolean foundf;
  Time thetim;
  
  foundf = false;
  for (i=0;i<7;i=i+1) begin
    if (((i==0) and (TimingDatar.Time<aheadtime[i])) or (i==6) or ((TimingDatar.Time>aheadtime[i]) and (TimingDatar.Time<aheadtime[i+1]))) then begin
      thetim = aheadtime[i];
      i = 7;
    end;
  end;
  for (i=0;i<acnt;i=i+1) begin
    if ((auser[i]==TimingDatar.UserCode) and (atime[i]==thetim)) then begin
      alength[i] = alength[i] + TimingDatar.Length/1000;
      atransa[i] = atransa[i] + TimingDatar.Transactions;
      anetwor[i] = anetwor[i] + TimingDatar.NetworkTime;
      foundf = true;
    end;
  end;
  if (foundf==false) then begin
    auser[acnt] = TimingDatar.UserCode;
    atime[acnt] = thetim;
    alength[acnt] = TimingDatar.Length/1000;
    atransa[acnt] = TimingDatar.Transactions;
    anetwor[acnt] = TimingDatar.NetworkTime;
    acnt = acnt + 1;
  end;
  return;
end;

global
procedure LatencyRn(var record RcVc RepSpec)
begin
  record TimingDataVc TimingDatar;
  Boolean foundf,testf;
  array string 20 auser;
  array Date adate;
  array Time atime;
  array val alength;
  array val atransa;
  array val anetwor;
  LongInt acnt,i,j;
  val a;
  string 60 lastuser;
  array Time aheadtime;
  Time t;
  Integer rw;
  string 200 tstr;
  
  acnt = 0;
  StartReportJob(USetStr(16366));
  rw = 1;
  if (blankdate(RepSpec.d1)) then begin
    RepSpec.d1 = AddDay(CurrentDate,-6);
  end;
  if (nonblankdate(RepSpec.d2)) then begin
    tstr = RepSpec.d2;
  end else begin
    HT2Per(RepSpec.d1,AddDay(RepSpec.d1,6),tstr);
  end;
  Header(rw,tstr,1);
  rw = rw + 1;
  EndHeader;
  aheadtime[0] = AddHours(t,8);
  aheadtime[1] = AddHours(aheadtime[0],2);
  aheadtime[2] = AddHours(aheadtime[1],2);
  aheadtime[3] = AddHours(aheadtime[2],2);
  aheadtime[4] = AddHours(aheadtime[3],2);
  aheadtime[5] = AddHours(aheadtime[4],2);
  aheadtime[6] = AddHours(aheadtime[5],2);
  switch (RepSpec.ArtMode) begin
    case 0:
      SetRepCol(3,120);
      SetRepCol(4,180);
      SetRepCol(5,240);
      SetRepCol(6,300);
      SetRepCol(7,360);
      SetRepCol(8,420);
      SetRepCol(9,480);
    case 1:
      SetRepCol(2,60);
      SetRepCol(3,40);
      SetRepCol(4,120);
      SetRepCol(5,180);
      SetRepCol(6,280);
      SetRepCol(7,380);
    case 2:
      SetRepCol(3,120);
      SetRepCol(4,180);
      SetRepCol(5,240);
      SetRepCol(6,300);
      SetRepCol(7,360);
      SetRepCol(8,420);
      SetRepCol(9,480);
  end;
  
  switch (RepSpec.ArtMode) begin
    case 0:
      StartFormat(15);
      for (i=0;i<7;i=i+1) begin
        OutString(3+i,"DblLatOnDay",DateToString(AddDay(RepSpec.d1,i),"MM/DD"),true);
      end;
      EndFormat;
    case 1:
      StartFormat(15);
      OutString(0,0,USetStr(16351),false);
      OutString(4,0,"",true);
      OutString(5,0,USetStr(16355),true);
      OutString(6,0,USetStr(16354),true);
      OutString(7,0,USetStr(16358),true);
      OutString(1,0,USetStr(16358),true);
      EndFormat;
    case 2:
      StartFormat(15);
      for (i=0;i<7;i=i+1) begin
        OutString(3+i,0,Left(aheadtime[i],5),true);
      end;
      EndFormat;
  end;
  Gray_Divider(0,1);
  foundf = true;
  TimingDatar.UserCode = RepSpec.f1;
  TimingDatar.Date = RepSpec.d1;
  if (nonblankdate(RepSpec.d2)) then begin
    TimingDatar.Date = RepSpec.d2;
  end;
  while LoopKey("UserCode",TimingDatar,2,foundf) begin
    if (nonblank(RepSpec.f1)) then begin
      if (RepSpec.f1!=TimingDatar.UserCode) then begin
        foundf = false;
      end;
    end;
    testf = foundf;
// Crappy, it will loop through ALL records for ALL users..... Should be done a different way.
    if (TimingDatar.Date>AddDay(RepSpec.d1,7)) then begin
      testf = false;
    end;
    if (nonblankdate(RepSpec.d2)) then begin
      if (TimingDatar.Date!=RepSpec.d2) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      if (RepSpec.ArtMode==2) then begin
        AddToLatencyDayArray(TimingDatar,aheadtime,auser,atime,alength,atransa,anetwor,acnt);
      end else begin
        AddToLatencyArray(TimingDatar,auser,adate,alength,atransa,anetwor,acnt);
      end;
    end;
  end;
  lastuser = "";
  for (i=0;i<acnt;i=i+1) begin
    switch (RepSpec.ArtMode) begin
      case 0:
        if (auser[i]!=lastuser) then begin
          StartFormat(15);
          OutString(0,0,auser[i],false);
        end;
        OutValID(3+DateDiff(adate[i],RepSpec.d1),"DblLatUserDay",Round(anetwor[i]/atransa[i],SetRoundModeD(0)),M4UVal,true,auser[i] & ":" & adate[i]);
        if (((i+1)>=acnt) or (auser[i]!=auser[i+1])) then begin
          EndFormat;
        end;
      case 1:
        StartFormat(15);
        OutString(0,0,auser[i],false);
        OutDate(4,0,adate[i],true);
        OutLongInt(5,0,atransa[i],true);
        OutVal(6,0,alength[i],M4UVal,true);
        OutVal(7,0,Round(anetwor[i],SetRoundModeD(0)),M4UVal,true);
        OutVal(1,0,Round(anetwor[i]/atransa[i],SetRoundModeD(0)),M4UVal,true);
        EndFormat;
      case 2:
        if (auser[i]!=lastuser) then begin
          StartFormat(15);
          OutStringID(0,"DblLatDetail",auser[i],false,RepSpec.d2);
        end;
        for (j=0;j<7;j=j+1) begin
          if (atime[i]==aheadtime[j]) then begin
            OutVal(3+j,0,Round(anetwor[i]/atransa[i],SetRoundModeD(0)),M4UVal,true);
          end;
        end;
        if (((i+1)>=acnt) or (auser[i]!=auser[i+1])) then begin
          EndFormat;
        end;
    end;
    lastuser = auser[i];
  end;
  Gray_Divider(0,1);
  EndJob;
  return;
end;

