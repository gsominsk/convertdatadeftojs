external function val MulWithRateToBase1(var string,Date,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external procedure AddProjValue(Boolean,Boolean,var val,val,val,val);
external procedure GetPRItemCost(string,string,string,string,Integer,var val);
external procedure GetPRClassName(string,var string);
external function string 255 FindINObjects(string,string);

global
procedure ProjStatDoSumup(val invablep,val invoicedp,val budgetp,var val addinvablep,var val addinvoicedp,var val addbudgetp)
BEGIN
  addinvoicedp = addinvoicedp + invoicedp;
  addbudgetp = addbudgetp + budgetp;
  addinvablep = addinvablep + invablep;
  RETURN;
END;

global
procedure ProjStatCostSumup(record RcVc RepSpec,val costpricep,val prinvablep,val prinvoicedp,var val classcostp)
BEGIN
  
  if (RepSpec.flags[5]==1) then begin
//    classcostp = classcostp + prinvablep;
//    classcostp = classcostp + prinvoicedp;
    classcostp = classcostp + costpricep;
  end else begin
    classcostp = classcostp + costpricep;
  end;
  RETURN;
END;

global
procedure ProjStatHeader(record RcVc RepSpec,record PRVc PRp,string prcode,string prname,string custcode,string custname,Integer showcust,Integer sorting,var Boolean sortingheaderf)
BEGIN
  string 255 tstr;
  
  if (sortingheaderf==false) then begin
    switch (sorting) begin
      case 0:
      case 1:
        StartFormat(15);
         OutString(0,0,USetStr(4863),false);
         OutString(80,0,PRp.Leader,false);
        EndFormat;
      case 2:
        StartFormat(15);
         OutString(0,0,USetStr(4823),false);
         OutString(80,0,custcode,false);
         OutString(180,0,custname,false);
        EndFormat;
      case 3:
        if (RepSpec.flags[13]==0) then begin
          StartFormat(15);
           OutString(0,0,USetStr(4870),false);
           OutString(80,0,PRp.PRClass,false);
          EndFormat;
        end;
    end;
    if (sorting!=3) or ((sorting==3) and (RepSpec.flags[13]==0)) then begin
      switch (RepSpec.flags[10]) begin
        case 0:
          Gray_Divider(0,1);
        otherwise
      end;
    end;
    sortingheaderf = true;
  end;
  if (RepSpec.flags[10]>0) then begin
    Gray_Divider(0,1);
    StartFormat(15);
    OutStringID(0,"DblPRVc",prcode,false,prcode);
    if (RepSpec.flags[15]==0) then begin
      OutStringID(60,0,prname,false,prcode);
    end else begin
      GetPRClassName(PRp.PRClass,tstr);        
      OutString(60,0,tstr,false);             
    end;  
    if (showcust!=0) then begin
      OutString(280,"DblCUVc",custcode,false);
      OutString(340,0,custname,false);
    end;
    EndFormat;
  end;
  RETURN;
END;

procedure SortPTList(Array string aincode,Array string aemcode,Array string aprcode,
                     Array string adblstr,Array Date adate,
                     Array val ainvoicable,Array val anotdone,Array val ainvoiced,Array val abudget,Array val acost,Array string acomment,
                     Array string adblroutine,Integer acnt)
begin
  Integer i;
  Boolean changedf;
  string 255 tmpincode,tmpemcode,tmpprcode,tmpdblstr,tmpcomment,tmpdblroutine;
  Date tmpdate;
  val tmpinvoicable,tmpinvoiced,tmpbudget,tmpcost;
  Integer tmpanotdone;
  
  changedf = true;
  while (changedf) begin
    changedf = false;
    for (i=0;i<acnt-1;i=i+1) begin
      if (aincode[i]>aincode[i+1]) then begin
        changedf = true;
        tmpincode = aincode[i];
        tmpemcode = aemcode[i];
        tmpprcode = aprcode[i];        
        tmpdblstr = adblstr[i];        
        tmpdate = adate[i];
        tmpinvoicable = ainvoicable[i];
        tmpinvoiced = ainvoiced[i];
        tmpbudget = abudget[i];
        tmpcost = acost[i];
        tmpcomment = acomment[i];
        tmpdblroutine = adblroutine[i];
        tmpanotdone = anotdone[i]; 
        
        aincode[i] = aincode[i+1];
        aemcode[i] = aemcode[i+1];
        aprcode[i] = aprcode[i+1];
        adblstr[i] = adblstr[i+1];
        adate[i] = adate[i+1];
        ainvoicable[i] = ainvoicable[i+1];
        ainvoiced[i] = ainvoiced[i+1];
        abudget[i] = abudget[i+1];
        acost[i] = acost[i+1];
        acomment[i] = acomment[i+1];
        adblroutine[i] = adblroutine[i+1];
        anotdone[i] = anotdone[i+1]; 
        
        aincode[i+1] = tmpincode;
        aemcode[i+1] = tmpemcode;
        aprcode[i+1] = tmpprcode;
        adblstr[i+1] = tmpdblstr;
        adate[i+1] = tmpdate;
        ainvoicable[i+1] = tmpinvoicable;
        ainvoiced[i+1] = tmpinvoiced;
        abudget[i+1] = tmpbudget;
        acost[i+1] = tmpcost;
        acomment[i+1] = tmpcomment;
        adblroutine[i+1] = tmpdblroutine;
        anotdone[i+1] = tmpanotdone; 
      end;
    end;
  end;
  return;
end;

global
procedure PrintPTList(record RcVc RepSpec,Array string aincode,Array string aemcode,Array string aprcode,
                      Array string adblstr,Array Date adate,
                      Array val ainvoicable, Array val anotdone,Array val ainvoiced,Array val abudget,Array val acost,Array string acomment,
                      Array string adblroutine,Integer acnt)
BEGIN
  Integer i;
  val diff;

  if (RepSpec.flags[10]<2) then begin goto LPrintPTListrecord; end;
  SortPTList(aincode,aemcode,aprcode,adblstr,adate,ainvoicable,anotdone,ainvoiced,abudget,acost,acomment,adblroutine,acnt);

  for (i=0;i<acnt;i=i+1) begin
    diff = ainvoiced[i] + ainvoicable[i];
    diff = diff + anotdone[i];
    diff = diff - abudget[i];
    if ((RepSpec.flags[12]==0) or (RepSpec.flags[12]==2)) then begin diff = -diff; end;
    StartFormat(15);
    if (blank(aprcode[i])) then begin
      OutString(15,0,aincode[i],false);
      OutString(80,0,aemcode[i],false);
      if (nonblankdate(adate[i])) then begin
        OutDate(135,0,adate[i],false);
      end;
      if (RepSpec.flags[17]==1) then begin 
        OutVal(220,0,anotdone[i],M4Val,true);
      end;  
      OutVal(270,0,ainvoicable[i],M4Val,true);
      OutVal(320,0,ainvoiced[i],M4Val,true);
      OutVal(400,0,abudget[i],M4Val,true);
      if (RepSpec.flags[14]!=0) then begin
        OutVal(480,0,acost[i],M4Val,true);
      end else begin
        OutVal(480,0,diff,M4Val,true);
      end;
    end else begin
      OutStringID(15,0,aincode[i],false,adblstr[i]);
      if (RepSpec.flags[16]==0) then begin
        OutStringID(80,0,aemcode[i],false,adblstr[i]);
        if (nonblankdate(adate[i])) then begin
          OutStringID(135,0,adate[i],false,adblstr[i]);
        end;
      end else begin
        OutStringID(80,adblroutine[i],acomment[i],false,adblstr[i]);
      end;  
      switch (adblroutine[i]) begin
        case "DblPrTranRn":
          if (RepSpec.flags[10]!=3) then begin
            if (RepSpec.flags[17]==1) then begin 
              OutVal(220,0,anotdone[i],M4Val,true);
            end;  
            OutValID(270,"DblPrTranRn",ainvoicable[i],M4Val,true,aprcode[i] & "," & aincode[i] & "," & aemcode[i]);
          end else begin
            if (RepSpec.flags[17]==1) then begin 
              OutVal(220,0,anotdone[i],M4Val,true);
            end;  
            OutValID(270,adblroutine[i],ainvoicable[i],M4Val,true,adblstr[i]);
          end;
        otherwise
          if (RepSpec.flags[17]==1) and (anotdone[i]<>0) then begin 
            OutVal(220,0,anotdone[i],M4Val,true);
          end;  
          OutValID(270,adblroutine[i],ainvoicable[i],M4Val,true,adblstr[i]);
      end;
      switch (adblroutine[i]) begin
        case "DblPrTranRn":
          if (RepSpec.flags[10]!=3) then begin
            OutValID(320,"DblPrTranRnInvd",ainvoiced[i],M4Val,true,aprcode[i] & "," & aincode[i] & "," & aemcode[i]);
          end else begin
            OutValID(320,"DblPrTranRnInvd",ainvoiced[i],M4Val,true,aprcode[i] & "," & aincode[i]);
          end;
        otherwise
          OutValID(320,adblroutine[i],ainvoiced[i],M4Val,true,adblstr[i]);
      end;
      OutValID(400,"DblTSBud",abudget[i],M4Val,true,aprcode[i]);
      if (RepSpec.flags[14]!=0) then begin
        OutValID(480,0,acost[i],M4Val,true,adblstr[i]);
      end else begin
        OutValID(480,0,diff,M4Val,true,adblstr[i]);
      end;
    end;
    EndFormat;
  end;
LPrintPTListrecord:;
  RETURN;
END;

global
procedure AddPTToList(record RcVc RepSpec,Array string aincode,Array string aemcode,Array string aprcode,Array string adblstr,Array Date adate,
                      Array val ainvoicable, Array val anotdone,Array val ainvoiced,Array val abudget,Array val abudgetcur,Array val acost,
                      Array string acomment,Array string adblroutine,var Integer acnt,
                      string ArtCode,string EMCode,string PRCode,string dblstr,Date TransDate,var val invablep,
                      var val invoicedp,var val budgetp,var val budgetcurp,val costp,string comment,string dblroutine, Integer notdone)
BEGIN
  Boolean found;
  Date bldat;
  Integer i;
  record INVc INr;
  val lcostp;
  
  if (RepSpec.flags[5]==0) then begin
    lcostp = costp;
  end else begin
    lcostp = invablep + invoicedp;
  end;

  for (i=0;i<acnt;i=i+1) begin
    switch(RepSpec.flags[10]) begin
      case 0:
        if (notdone==1) then begin 
          anotdone[i] = anotdone[i] + invablep;
        end else begin  
          ainvoicable[i] = ainvoicable[i] + invablep;
        end; 
        ainvoiced[i] = ainvoiced[i] + invoicedp;
        abudget[i] = abudget[i] + budgetp;
        abudgetcur[i] = abudgetcur[i] + budgetcurp;
        acost[i] = acost[i] + lcostp;
        acomment[i] = "";
      case 1:
        if (notdone==1) then begin 
          anotdone[i] = anotdone[i] + invablep;
        end else begin  
          ainvoicable[i] = ainvoicable[i] + invablep;
        end;
        ainvoiced[i] = ainvoiced[i] + invoicedp;
        abudget[i] = abudget[i] + budgetp;
        abudgetcur[i] = abudgetcur[i] + budgetcurp;
        acost[i] = acost[i] + lcostp;
        acomment[i] = "";
      case 2:;
      case 3:
        if (aincode[i]!=ArtCode) then begin goto L88AddPTToList; end;
        acomment[i] = "";
//        aemcode[i] = "";
        adate[i] = bldat;
        if (notdone==1) then begin 
          anotdone[i] = anotdone[i] + invablep;
        end else begin  
          ainvoicable[i] = ainvoicable[i] + invablep;
        end;  
        ainvoiced[i] = ainvoiced[i] + invoicedp;
        abudget[i] = abudget[i] + budgetp;
        abudgetcur[i] = abudgetcur[i] + budgetcurp;
        acost[i] = acost[i] + lcostp;
        found = true;
      case 4:
        if (aincode[i]!=ArtCode) then begin goto L88AddPTToList; end;
        if (aemcode[i]!=EMCode) then begin goto L88AddPTToList; end;
        if (notdone==1) then begin 
          anotdone[i] = anotdone[i] + invablep;
        end else begin  
          ainvoicable[i] = ainvoicable[i] + invablep;
        end;      
        ainvoiced[i] = ainvoiced[i] + invoicedp;
        abudget[i] = abudget[i] + budgetp;
        abudgetcur[i] = abudgetcur[i] + budgetcurp;
        acost[i] = acost[i] + lcostp;
        acomment[i] = "";
        found = true;
      case 5: ;
    end;
L88AddPTToList:;
  end;
  if (found==false) then begin
    aincode[acnt] = ArtCode;
    if (RepSpec.flags[10]==3) then begin
      if (ReadFirstItem(ArtCode,INr,false,false)) then begin end;
      aemcode[acnt] = INr.Name;
    end else begin
      aemcode[acnt] = EMCode;
    end;
    acomment[acnt] = comment;
    aprcode[acnt] = PRCode;
    adblstr[acnt] = dblstr;
    adblroutine[acnt] = dblroutine;
    adate[acnt] = TransDate;
    if (notdone==1) then begin 
      anotdone[acnt] = anotdone[acnt] + invablep;
    end else begin  
      ainvoicable[acnt] = ainvoicable[acnt] + invablep;
    end;   
    ainvoiced[acnt] = invoicedp;
    abudget[acnt] = budgetp;
    abudgetcur[acnt] = budgetcurp;
    acost[acnt] = lcostp;
    acnt = acnt + 1;
  end;
  RETURN;
END;

global
function Boolean ProjStatDownpayable(record RcVc RepSpec,Array string aincode,Array string aemcode,Array string aprcode,Array string adblstr,Array Date adate,
                                     Array val ainvoicable, Array val anotdone,Array val ainvoiced,Array val abudget,Array val abudgetcur,Array val acost,Array string acomment,
                                     Array string adblroutine,var Integer acnt,
                                     record PRVc PRp,var val downpayedp,var val downpayablep,Boolean amounts,var val prinvable, var val prinvoiced,
                                     string dblroutine,var val downpayusedp,var val prinvableincur,var val prinvoicedincur,var val downpayedincurp,var val downpayableincurp,var val downpayusedincurp)
BEGIN
  Boolean res;
  row PRVc PRrw;
  Integer rwcnt,i;
  val t,value1,value2,t1;
  val downpayd,downpayble;
  string 5 tstr;
  record IVVc IVr;
  Boolean testf,rowfoundf;
  val value1incur,value2incur;
  val downpaydincur,downpaybleincur;
  
  if (RepSpec.flags[11]==0) then begin goto LProjStatDownpayable; end;
  if (amounts==false) then begin goto LProjStatDownpayable; end;
  
  rwcnt = MatRowCnt(PRp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(PRp,i,PRrw);
    testf = true;
    if (PRrw.InvNr!=-1) then begin
      IVr.SerNr = PRrw.InvNr;
      if (ReadFirstMain(IVr,1,true)) then begin
        if (DateInRange(IVr.TransDate,RepSpec.d1,RepSpec.d2)==false) then begin testf = false; end;
      end;
    end;
    if (PRrw.InvFlag!=2) then begin
      if (nonblankdate(RepSpec.d2)) then begin
        if (prrw.PlanDate>RepSpec.d2) then begin testf = false; end;
      end;
    end;
    if (SetInSet(RepSpec.ObjStr,IVr.Objects)==false) then begin testf = false; end;
    if (nonblank(RepSpec.f4)) then begin
      if (RepSpec.f4!=PRrw.Person) then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      res = true;
      t = StringToVal(PRrw.ValStr,M4Val);
      value1 = blankval;
      value2 = blankval;
      if (PRrw.InvFlag==2) then begin
        if (PRrw.InvNr==-1) then begin
          if (prrw.PlanDate>RepSpec.d2) then begin
            value1 = t;
          end;
        end else begin
          if (prrw.PlanDate<RepSpec.d2) then begin
            value2 = t;
          end;
        end;
      end else begin
        if ((PRrw.InvNr!=-1) or (PRrw.InvFlag!=0)) then begin
          value1 = MulWithRateToBase1(PRp.CurncyCode,prrw.PlanDate,t,DefaultCurRoundOff);
          value1incur = t;
        end else begin
          value2 = MulWithRateToBase1(PRp.CurncyCode,prrw.PlanDate,t,DefaultCurRoundOff);
          value2incur = t;
        end;
      end;
      downpayd = downpayd + value1;
      downpayble = downpayble + value2;

      downpaydincur = downpaydincur + value1incur;
      downpaybleincur = downpaybleincur + value2incur;
      t = blankval;
      AddPTToList(RepSpec,aincode,aemcode,aprcode,adblstr,adate,ainvoicable,anotdone,ainvoiced,abudget,abudgetcur,acost,acomment,adblroutine,acnt,
                  tstr,tstr,tstr,tstr,PRrw.PlanDate,value2,value1,t1,t,blankval,"",dblroutine,0);
    end;
  end;
  if (RepSpec.flags[11]>1) then begin
    prinvable = prinvable - downpayd;
    prinvableincur = prinvableincur - downpaydincur;
    if (RepSpec.flags[11]==2) then begin
      if (prinvable<0) then begin
        prinvable = 0;
        prinvableincur = 0;
      end;
    end;
  end;
  downpayablep = downpayble;
  downpayedp = downpayd;
  downpayusedp = PRp.DownPayRedcd;

  downpayableincurp = downpaybleincur;
  downpayedincurp = downpaydincur;
  downpayusedincurp = PRp.DownPayRedcd;

LProjStatDownpayable:;
  ProjStatDownpayable = res;
  RETURN;
END;

global
function Boolean TestProStatSpecifiction(record RcVc RepSpec,record TBBUVc TBBUp,Integer ItemType,string objsel)
begin
  Boolean res;
  row TBBUVc TBBUrw;
  record INVc INr;
  Integer i,rwcnt;
  
  rwcnt = MatRowCnt(TBBUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TBBUp,i,TBBUrw);
    if (TBBUrw.Invoiced==-2) then begin goto L88TestProStatSpecifiction; end;    
    if (nonblank(RepSpec.f4)) then begin
      if (RepSpec.f4!=TBBUrw.EMCode) then begin
        goto L88TestProStatSpecifiction;
      end;
    end;    
    INr.Code = TBBUrw.ArtCode;
    if (ReadFirstMain(INr,1,true)==false) then begin goto L88TestProStatSpecifiction; end;
    if (nonblank(RepSpec.LastAcc)) then begin
      if (RepSpec.LastAcc!=INr.Group) then begin
        goto L88TestProStatSpecifiction;
      end;
    end;
    if (ItemType!=-1) then begin
      if (ItemType!=5) then begin
        if ((INr.ItemType!=ItemType) or (INr.ItemMaterial==1)) then begin goto L88TestProStatSpecifiction; end;
      end else begin
        if ((INr.ItemMaterial==0) or (INr.ItemType!=0)) then begin goto L88TestProStatSpecifiction; end;
      end;
    end;
/*    
there is object test below
objsel = RepSpec.ObjStr;

    if (nonblank(RepSpec.ObjStr)) then begin
      if (RepSpec.ObjStr!=FindINObjects(INr.Objects,INr.Group)) then begin
        goto L88TestProStatSpecifiction;
      end;
    end;
*/    

    if (SetInSet(objsel,TBBUrw.Objects)==false) then begin goto L88TestProStatSpecifiction; end;
    res = true;
    goto LTestProStatSpecifiction;
L88TestProStatSpecifiction:;      
  end;
LTestProStatSpecifiction:;  
  TestProStatSpecifiction = res;
  return;
end;

global
function Boolean AddNotDoneActivities(record RcVc RepSpec,string prcode,
                               Array string aincode,Array string aemcode,Array string aprcode,Array string adblstr,Array Date adate,
                               Array val ainvoicable,Array val anotdone,Array val ainvoiced,Array val abudget,Array val abudgetcur,Array val acost,
                               Array string acomment,Array string adblroutine,var Integer acnt,
                               Boolean amounts,
                               var val invable,var val invoiced,var val budget,var val budgetcur,
                               var val grinvoiced,var val grnotdone,var val grinvable,var val grbudget,var val grcost,
                               var val prinvable,var val prinnotdone,var val prinvoiced,var val prbudget,var val prcost)
                               
begin
  record ActVc Actr;
  Boolean found,testf;
  val v,q;
  Boolean res;
  Integer notdone; 
  
  res = false;
  found = true;
  Actr.PRCode = prcode;
  Actr.OKFlag = 0;
  Actr.TransDate = RepSpec.sStartDate;
  while (LoopKey("PRCode",Actr,3,found)) begin
    budget = blankval;
    invoiced = blankval;
    invable = blankval;
    if (Actr.PRCode!=prcode) then begin found = false; end;
    if (Actr.OKFlag!=0) then begin found = false; end;
    testf = found;
    if (nonblankdate(RepSpec.d1)) then begin
      if (Actr.TransDate<RepSpec.d1) then begin
        testf = false;
      end;
    end;
    if (nonblankdate(RepSpec.d2)) then begin
      if (Actr.TransDate>RepSpec.d2) then begin
        testf = false;
      end;
    end;
    if (Actr.CalTimeFlag!=1) then begin testf = false; end;
    if (testf) then begin
      q = TimeToVal(Actr.CostTime);
      GetPRItemCost(prcode,Actr.MainPersons,Actr.ItemCode,Actr.TimeClass,3,v);
      AddProjValue(amounts,true,invable,blankval,v,q);
      if (Actr.OKFlag<>1) then begin 
        notdone = 1;
      end;
      AddPTToList(RepSpec,aincode,aemcode,aprcode,adblstr,adate,ainvoicable,anotdone,ainvoiced,abudget,abudgetcur,acost,acomment,adblroutine,acnt,
                  Actr.ItemCode,Actr.MainPersons,prcode,"",Actr.TransDate,invable,invoiced,budget,budgetcur,v*q,
                  Actr.Comment,"",notdone);
      ProjStatDoSumup(invable,invoiced,budget,grinvable,grinvoiced,grbudget);
      grnotdone = grnotdone + invable;
      grinvable = grinvable - invable;
      ProjStatDoSumup(invable,invoiced,budget,prinvable,prinvoiced,prbudget);
      prinnotdone = prinnotdone + invable;
      prinvable = prinvable -invable;
      if (RepSpec.flags[14]==1) then begin
        ProjStatCostSumup(RepSpec,v,invable,invoiced,prcost);      
        grcost = grcost + v;
      end;
      if ((invable!=0) or (invoiced!=0) or (budget!=0)) then begin res = true; end;
    end;
  end;
  AddNotDoneActivities = res;
  RETURN;
END;

global
procedure ProjStatBudgNoTrans(record RcVc RepSpec,record PRVc PRp,Array string aincode,Array string aemcode,Array string aprcode,Array string adblstr,
                              Array Date adate,
                              Array val ainvoicable,Array val anotdone,Array val ainvoiced,Array val abudget,Array val abudgetcur,Array val acost,
                              Array string acomment,Array string adblroutine,var Integer acnt,
                              record TBBUVc TBBUp,Boolean amounts,var val invablep,
                              var val invoicedp,var val budgetp,var Integer budtp,Integer ItemType,string objsel,
                              var val invableincurp,var val invoicedincurp,var val budgetincurp)
BEGIN
  row TBBUVc TBBUrw;
  record INVc INr;
  val invable,invoiced,invoicedincur,budget,budgetincur;
  val oinvable,oinvablesum;
  Integer i,rwcnt;
  Boolean costf;
  Date blankd;
  string 255 dblroutine;
  val invablesum,invablesumincur;
  
  if (RepSpec.flags[12]==2) then begin costf = true; end;
  invablep = blankval;
  invoicedp = blankval;
  budgetp = blankval;
  rwcnt = MatRowCnt(TBBUp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(TBBUp,i,TBBUrw);
    if (TBBUrw.Invoiced==-2) then begin goto L88ProjStatBudgNoTrans; end;    
    if (nonblank(RepSpec.f4)) then begin
      if (RepSpec.f4!=TBBUrw.EMCode) then begin
        goto L88ProjStatBudgNoTrans;
      end;
    end;    
    INr.Code = TBBUrw.ArtCode;
    if (ReadFirstMain(INr,1,true)==false) then begin goto L88ProjStatBudgNoTrans; end;
    if (nonblank(RepSpec.LastAcc)) then begin
      if (RepSpec.LastAcc!=INr.Group) then begin
        goto L88ProjStatBudgNoTrans;
      end;
    end;
/*    
there is object test below
objsel = RepSpec.ObjStr;

    if (nonblank(RepSpec.ObjStr)) then begin
      if (RepSpec.ObjStr!=FindINObjects(INr.Objects,INr.Group)) then begin
        goto L88ProjStatBudgNoTrans;
      end;
    end;
*/    
    if (ItemType!=5) then begin
      if ((INr.ItemType!=ItemType) or (INr.ItemMaterial==1)) then begin goto L88ProjStatBudgNoTrans; end;
    end else begin
      if ((INr.ItemMaterial==0) or (INr.ItemType!=0)) then begin goto L88ProjStatBudgNoTrans; end;
    end;
    if (SetInSet(objsel,TBBUrw.Objects)==false) then begin goto L88ProjStatBudgNoTrans; end;
    invable = blankval;
    invoiced = blankval;
    budget = blankval;
    budtp = TBBUrw.BudType;
    if (RepSpec.flags[12]==4) then begin budtp = 0; end;
    if (budtp==0) then begin
      switch (TBBUrw.ItemType) begin
        case 1: budtp = TBBUp.BudStocked+1;
        case 3: budtp = TBBUp.BudTime+1;
        case 5: budtp = TBBUp.BudMaterial+1;
        otherwise budtp = TBBUp.BudOther+1;
      end;
    end;
    invablesumincur = TBBUrw.Sum;
    invablesum = MulRateToBase1(TBBUp.CurncyCode,TBBUrw.Sum,TBBUp.FrRate,TBBUp.ToRateB1,TBBUp.ToRateB2,TBBUp.BaseRate1,TBBUp.BaseRate2,DefaultCurRoundOff);
    if (PRp.StopInvoicing!=0) then begin 
      invablesum = blankval; 
      invablesumincur = blankval; 
    end;
    oinvablesum = invablesum;
    if (RepSpec.flags[12]==4) then begin      
      invablesum = blankval;
      invablesumincur = blankval;
    end;
    switch (budtp) begin// here : 1 - running, 2 - fixed 
      case 1:
        if (RepSpec.flags[12]!=1) then begin
          AddProjValue(amounts,costf,budget,invablesum,TBBUrw.Cost,TBBUrw.Qty);
          if (RepSpec.flags[18]!=0) and (nonblank(TBBUp.CurncyCode)) then begin
            AddProjValue(amounts,costf,budgetincurp,invablesumincur,TBBUrw.Cost,TBBUrw.Qty);
          end;
        end;
      case 2:
          if (TBBUrw.Invoiced<=0) then begin
            AddProjValue(amounts,costf,invable,invablesum,TBBUrw.Cost,TBBUrw.Qty);
            if (RepSpec.flags[18]!=0) and (nonblank(TBBUp.CurncyCode)) then begin
              AddProjValue(amounts,costf,invableincurp,invablesumincur,TBBUrw.Cost,TBBUrw.Qty);
            end;
            oinvable = invable;
            if (RepSpec.flags[12]==4) then begin
              invable = blankval;
            end;
          end else begin
            if (nonblankdate(RepSpec.d1)) then begin
              if (TBBUrw.InvDate<RepSpec.d1) then begin goto L88ProjStatBudgNoTrans; end;
            end;
            if (nonblankdate(RepSpec.d2)) then begin
              if (TBBUrw.InvDate>RepSpec.d2) then begin goto L88ProjStatBudgNoTrans; end;
            end;
            oinvable = invable;
            if (RepSpec.flags[12]==4) then begin
              invable = blankval;
            end;
            AddProjValue(amounts,costf,invoiced,invablesum,TBBUrw.Cost,TBBUrw.Qty);
            if (RepSpec.flags[18]!=0) and (nonblank(TBBUp.CurncyCode)) then begin
              AddProjValue(amounts,costf,invoicedincurp,invablesumincur,TBBUrw.Cost,TBBUrw.Qty);
            end;
          end;
          invablesum = oinvablesum;
          if (RepSpec.flags[12]!=1) then begin 
            AddProjValue(amounts,costf,budget,invablesum,TBBUrw.Cost,TBBUrw.Qty);
            if (RepSpec.flags[18]!=0) and (nonblank(TBBUp.CurncyCode)) then begin
              AddProjValue(amounts,costf,budgetincurp,invablesumincur,TBBUrw.Cost,TBBUrw.Qty);
            end;
          end;
      case 3: ;// internal 
    end;
    dblroutine = "DblTBBUVc";
    if (budtp==1) then begin
      dblroutine = "";
    end;
//    AddPTToList(RepSpec,aincode,aemcode,aprcode,adblstr,adate,ainvoicable,ainvoiced,abudget,acost,acomment,adblroutine,acnt,
//                TBBUrw.ArtCode,TBBUrw.EMCode,TBBUp.PRCode,TBBUp.PRCode,blankd,invable,invoiced,budget,TBBUrw.Cost,"",dblroutine);
    
    AddPTToList(RepSpec,aincode,aemcode,aprcode,adblstr,adate,ainvoicable,anotdone,ainvoiced,abudget,abudgetcur,acost,acomment,adblroutine,acnt,
                TBBUrw.ArtCode,TBBUrw.EMCode,TBBUp.PRCode,TBBUp.PRCode,blankd,invable,invoiced,budget,budgetincur,blankval,"",dblroutine,0);
    TBBUrw.Invoiced = -2;
    ProjStatDoSumup(invable,invoiced,budget,invablep,invoicedp,budgetp);
    ProjStatDoSumup(invablesumincur,invoicedincur,budgetincur,invableincurp,invoicedincurp,budgetincurp);
L88ProjStatBudgNoTrans:;
  end;
  RETURN;
END;

global
procedure ProjStatPrintGrSumup(record RcVc RepSpec,Integer strnr,var val grinvoicedp,var val grinvablep,var val grbudgetp,var val grcostp,var val grnotdone)
BEGIN
  val diff;
  
  if (RepSpec.flags[10]==0) then begin goto LProjStatPrintGrSumup; end;
  diff = grinvoicedp + grinvablep;
  diff = diff + grnotdone;
  diff = diff - grbudgetp;
  if (RepSpec.flags[12]==0) then begin diff = -diff; end;
  if (RepSpec.flags[12]==2) then begin diff = -diff; end;
  if (RepSpec.flags[10]!=1) then begin Black_Divider(170,480); end;
  StartFormat(15);
  OutString(15,0,"",false);
  OutString(80,0,"",false);
  OutString(170,0,USetStr(strnr),true);
  if (RepSpec.flags[17]==1) then begin 
    OutVal(220,0,grnotdone,M4Val,true); 
  end;  
  OutVal(270,0,grinvablep,M4Val,true); 
  OutVal(320,0,grinvoicedp,M4Val,true);
  OutVal(400,0,grbudgetp,M4Val,true);
  if (RepSpec.flags[14]!=0) then begin
    OutVal(480,0,grcostp,M4Val,true);
  end else begin
    OutVal(480,0,diff,M4Val,true);
  end;
  EndFormat;
  if (RepSpec.flags[10]!=1) then begin
    StartFormat(15);
    EndFormat;
  end;
LProjStatPrintGrSumup:;
  grbudgetp = blankval;
  grinvoicedp = blankval;
  grinvablep = blankval;
  grcostp = blankval;
  grnotdone = blankval;
  RETURN;
END;
