external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure ExtractObj(string,var Integer,var string);
external procedure HT2Per(Date, Date , var string);
external procedure FindAccSD(Date,var Date,var Boolean);
  
function
Integer FindObj(string obj,Array string orobjp2object,Integer orobjp2cnt)
BEGIN
  Integer res;
  Integer i;
  
  res = -1;
  for (i=0;i<orobjp2cnt;i=i+1) begin
    if (obj==orobjp2object[i]) then begin
      res = i;
      goto LFindObj;
    end;
  end;
LFindObj:;  
  FindObj = res;
  RETURN;
END;

procedure AddORToObj2(record RcVc RepSpec,Array string arrobject,Array LongInt arrcount,Array val arrsum,
                      string object,record ORVc ORp,string frobj,string toobj,var Integer arrcnt)
BEGIN
  Boolean found;
  Integer i;
  val t;

  if (nonblank(RepSpec.ObjStr)) then begin
    if (object<frobj) then begin goto LAddORToObj2; end;
    if (object>toobj) then begin goto LAddORToObj2; end;
  end; 
  if (ORp.InclVAT==0) then begin
    t = ORp.Sum1;
  end else begin
    t = ORp.Sum4 - ORp.Sum3;
  end;
  if (nonblank(ORp.CurncyCode)) then begin
    if (ORp.FrRate!=0) then begin
       t = MulRateToBase1(ORp.CurncyCode,t,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,
                    ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
    end;
  end;
  for (i=0;i<arrcnt;i=i+1) begin
    if (arrobject[i]==object) then begin
      found = true;
      arrcount[i] = arrcount[i] + 1;
      arrsum[i] = arrsum[i] + t;
    end;
  end;
  if (found==false) then begin
    arrobject[arrcnt] = object;
    arrsum[arrcnt] = t;
    arrcount[arrcnt] = 1;
    arrcnt = arrcnt + 1;
  end;
LAddORToObj2:;
  RETURN;
END;

procedure AddORToObj(record RcVc RepSpec,Array string arrobject,Array LongInt arrcount,Array val arrsum,
                     record ORVc ORp,string frobj,string toobj,var Integer arrcnt)
BEGIN
  Integer pos;
  string 255 ostr;
  
  pos = 0;
  ExtractObj(ORp.Objects,pos,ostr);
  while (nonblank(ostr)) begin
    AddORToObj2(RepSpec,arrobject,arrcount,arrsum,ostr,ORp,frobj,toobj,arrcnt);
    ExtractObj(ORp.Objects,pos,ostr);
  end;
  RETURN;
END;

global
procedure ORObjStatRn(record RcVc RepSpec)
BEGIN
  record ObjVc Objr;
  record ORVc ORr;
  Boolean found,resUseAccum;
  Integer rwcnt,i;
  Integer l2;
  LongInt c1,c2;
  LongInt tc1,tc2;
  LongInt orfr,orto;
  string 255 tstr,frobj,toobj;
  val ta1,ta2,ts1,ts2;
  val a1,a2,s1,s2,t;
  Array string 20 orobjpobject;
  Array val orobjpsum;
  Array LongInt orobjpcount;

  Array string 20 orobjp2object;
  Array val orobjp2sum;
  Array LongInt orobjp2count;
  Date AccumStartDate;
  Integer orobjprwcnt,orobjp2rwcnt;

  orfr = FirstInRange(RepSpec.f1,10);
  orto = LastInRange(RepSpec.f1,10);
  frobj = FirstInRange(RepSpec.ObjStr,20);
  toobj = LastInRange(RepSpec.ObjStr,20);
  tc1 = 0;
  tc2 = 0;  
  StartReportJob(USetStr(5260));
  EndHeader;
  FindAccSD(RepSpec.sStartDate,AccumStartDate,resUseAccum);
  StartFormat(15);
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  OutString(280,0,tstr,true);
  HT2Per(AccumStartDate,RepSpec.sEndDate,tstr);
  OutString(480,0,tstr,true);
  EndFormat;
  StartFormat(15);
  EndFormat;
  StartFormat(15);
  OutString(0,0,USetStr(2411),false);
  OutString(160,0,USetStr(5262),true);
  OutString(210,0,USetStr(5263),true);
  OutString(280,0,USetStr(5264),true);
  OutString(360,0,USetStr(5262),true);
  OutString(400,0,USetStr(5263),true);
  OutString(480,0,USetStr(5264),true);
  EndFormat;
  Gray_Divider(0,1);
  ORr.SerNr = orfr;
  found = true;
  while (LoopMain(ORr,1,found)) begin
    if (orto!=-1) then begin
      if (ORr.SerNr>orto) then begin found = false; end;
    end;
    if (found) then begin
      if ((ORr.OrdDate>=AccumStartDate) and (ORr.OrdDate<=RepSpec.sEndDate)) then begin
        AddORToObj(RepSpec,orobjpobject,orobjpcount,orobjpsum,ORr,frobj,toobj,orobjprwcnt);
      end;
      if ((ORr.OrdDate>=RepSpec.sStartDate) and (ORr.OrdDate<=RepSpec.sEndDate)) then begin
        AddORToObj(RepSpec,orobjp2object,orobjp2count,orobjp2sum,ORr,frobj,toobj,orobjp2rwcnt);
      end;
    end;
  end;
// -------------------------------------- 
  for (i=0;i<orobjprwcnt;i=i+1) begin
    Objr.Code = orobjpobject[i];
    found = ReadFirstMain(Objr,1,true);
//    if (found) then
    begin
      l2 = FindObj(orobjpobject[i],orobjp2object,orobjp2rwcnt);
      begin
         StartFormat(15);
         OutString(0,0,orobjpobject[i],false);
         if (found) then begin
        //   OutString(60,0,left(Objr.Comment,15),false);
         end;
         s1 = orobjpsum[i];
         c1 = orobjpcount[i];
         if (l2!=-1) then begin
           s2 = orobjp2sum[l2];
           c2 = orobjp2count[l2];
         end else begin
           s2 = blankval;
           c2 = 0;
         end;
         t = c1;
         a1 = s1/t;
         t = c2;
         a2 = s2/t;
         OutVal(160,0,s2,M4Val,true);
         OutLongInt(210,0,c2,true);
         OutVal(280,0,a2,M4Val,true);
         OutVal(360,0,s1,M4Val,true);
         OutLongInt(400,0,c1,true);
         OutVal(480,0,a1,M4Val,true);
         EndFormat;
         ts1 = ts1 + s1;
         ts2 = ts2 + s2;
         tc1 = tc1 + c1;
         tc2 = tc2 + c2;
      end;
    end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
  t = tc1;
  ta1 = ts1/t;
  t = tc2;
  ta2 = ts2/t;
  OutVal(160,0,ts2,M4Val,true);
  OutLongInt(210,0,tc2,true);
  OutVal(280,0,ta2,M4Val,true);
  OutVal(360,0,ts1,M4Val,true);
  OutLongInt(400,0,tc1,true);
  OutVal(480,0,ta1,M4Val,true);
  EndFormat;
  EndJob;
  RETURN;
END;