external procedure GetVATproc(string,Integer,var val);
external function Boolean RequireOpenSession(string);
external function Boolean TransInFiscal(Date);
external procedure ExtractObj(string,var Integer,var string);
external procedure GetPayModeText(string,var string);
external function string 255 CurDrawerCode(string);
external procedure CashSumup(record CashVc);
external function LongInt DateDiff(Date,Date);
external procedure TimeToSeconds(Time,var LongInt);
external function Boolean IsSessionOpen(string,string,Date,Time);
external procedure HT2Per(Date, Date , var string);
external procedure InsertAtPos(Integer,string,string,LongInt,Date,Time,Integer,var array string,var array string,var array LongInt,var array Date,var array Time,var array Integer,var Integer);
external procedure GetPayDealText(string,string,var string);
external procedure FindTimeOfLastPOSBalance(var Date,var Time,string,string,var val,var val);
external procedure FillUpAllCashBal(Date,Date,Time,Time,string,string,var array string,var array string,var array LongInt,var array Date,var array Time,var array Integer,var Integer);
external procedure FillUpAllPOSEvents(Date,Date,Time,Time,string,string,var array string,var array string,var array LongInt,var array Date,var array Time,var array Integer,var Integer);
external procedure FillUpAllPOSBalance(Date,Date,Time,Time,string,string,var array string,var array string,var array LongInt,var array Date,var array Time,var array Integer,var Integer);
external procedure FillUpAllCashEvents(Date,Date,Time,Time,string,string,var array string,var array string,var array LongInt,var array Date,var array Time,var array Integer,var Integer);
external procedure FillUpAllIVCash(Integer,Date,Date,Time,Time,Date,Time,Date,Time,string,string,string,var array string,var array string,var array val,var array val,var array val,var array val,var array val,var array val,var Integer,Integer,var array string,var array val,var array val,var array val,var Integer,Boolean,var val,var val,var array string,var array val,Integer,var record SMVc,var vector val);
external procedure FillUpAllSLIV(Integer,Date,Date,Time,Time,Date,Time,Date,Time,string,string,string,var array string,var array string,var array val,var array val,var array val,var array val,var array val,var array val,var Integer,Integer,var array string,var array val,var array val,var array val,var Integer,Boolean,var val,var val,var array string,var array val,Integer,var record SMVc,var vector val);
external procedure FillUpAllSLIP(Integer,Date,Date,Time,Time,Date,string,string,string,var array string,var array string,var array val,var array val,var array val,var array val,var array val,var array val,var Integer,Integer,var array string,var array val,var array val,var array val,var Integer,Boolean,var val,var val,var array string,var array val,Integer,var record SMVc);
external procedure FillUpAllRestAccCash(Integer,Integer,Date,Date,Time,Time,Date,string,string,string,var array string,var array string,var array val,var array val,var array val,var array val,var array val,var array val,var Integer,Integer,
                                        var array string,var array string,var array val,var array val,var array val,var array val,var array val,var array val,var Integer,
                                        var array string,var array val,var array val,var array val,var Integer,Boolean,var val,var val,var array string,var array val,Integer,var record SMVc);
external procedure PrintSMRecord(record SMVc,Integer);
external procedure PrintTRRecord(record TRVc,Integer);
external procedure AddSMRow(record SMVc,Date,string,string,string,string,val,Boolean,Boolean,var val);
external function Boolean GetPMRow(string,var row PMBlock);
external function Boolean GetAccName(string,var string,Integer);
external procedure AddEuroTrRow(record TRVc,string,string,string,string,val,val,val,Boolean,Boolean,var val,Boolean,string,string,string);
external function Integer GetIntYc(Date);
external procedure TRSumup(var record TRVc,var val);
external function string 255 CheckTrans(var record TRVc,Integer,Boolean);
external procedure SMSumup(var record SMVc);
external updating procedure SaveTrans(record TRVc);
external procedure GetFullCurncyRate(var string,Date,var val,var val,var val,var val,var val);

enum begin
  kCashupReportStd = 0,
  kCashupReportCleanCash = 1
end;

function Boolean BuildPOSTRFromSM(record SMVc SMr,var record TRVc TRr,var Integer pos,var LongInt lastno,var Boolean bookf,var record POSBalanceVc POSBalancer)
begin
  row SMVc SMrw;
  row TRVc TRrw;
  Integer rwcnt,i;
  val s,totsum;
  string 255 tstr;
  Boolean debf;
  Boolean res;
  val temp,baserate1,baserate2;
  string 10 curncy;
  vector val vacc;
  
  res = false;
  bookf = false;
  RecordNew(TRr);
  RecordNew(POSBalancer);
  POSBalancer.SerNr = -1;
  curncy = "";
  GetFullCurncyRate(curncy,TRr.TransDate,temp,temp,temp,baserate1,baserate2);
  rwcnt = MatRowCnt(SMr);
  res = false;
  for (i=pos;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (SMrw.AccNumber=="BALANCE") then begin
      if (res) then begin
        TRr.TransDate = SMrw.TransDate; // Exchange Rate Date
        TRr.Comment = "POS Balance " & SMrw.Comment;
        POSBalancer.SerNr = SMrw.Comment;
        if (ReadFirstMain(POSBalancer,1,true)==false) then begin
          POSBalancer.SerNr = -1;
        end;
        i = rwcnt;
      end;
    end;
    res = true;
  end;
  res = false;
  for (i=pos;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (SMrw.AccNumber=="BALANCE") then begin
      if (res) then begin
        TRr.IntYc = RestAccYc; // GetIntYc(TRr.TransDate);
        TRr.Number = POSBalancer.SerNr; // NextSerNr("TRVc",TRr.TransDate,lastno,false,"");
        if (TRr.Number<=lastno) then begin
          TRr.Number = lastno + 1;
        end;
        lastno = TRr.Number;
        if (CheckTrans(TRr,2,false)=="") then begin end;
      end;
      if (MatRowCnt(TRr)>0) then begin
        bookf = true;
      end;
      res = true;
      i = i + 1;
      goto LBuildPOSTRFromSM;
    end;
    if (GetAccName(SMrw.AccNumber,tstr,60)==false) then begin end;
    if (SMrw.DebVal!=0) then begin
      s = SMrw.DebVal;
      debf = true;
    end else begin
      s = SMrw.CredVal;
      debf = false;      
    end;
    AddEuroTrRow(TRr,SMrw.AccNumber,SMrw.Objects,SMrw.VATCode,tstr,s,baserate1,baserate2,false,debf,totsum,true,"","","");
    if (debf) then begin
      vacc[SMrw.AccNumber] = vacc[SMrw.AccNumber] + s;
    end else begin
      vacc[SMrw.AccNumber] = vacc[SMrw.AccNumber] - s;
    end;
    res = true;
  end;
LBuildPOSTRFromSM:;
  pos = i;
/*  
StartFormat(15);  
 OutString(0,0,"74110",false);
 OutString(100,0,vacc["74110"],false);
EndFormat;
StartFormat(15);  
 OutString(0,0,"74115",false);
 OutString(100,0,vacc["74115"],false);
EndFormat;
*/
  BuildPOSTRFromSM = res;
  return;
end;

procedure PreparePOSSM(var record SMVc SMr)
begin
  row SMVc SMrw;
  Integer rwcnt,i,last;
  Boolean res;
  Integer cnt;
  
  SMr.TransDate = CurrentDate;
  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (SMrw.AccNumber=="BALANCE") then begin
      if (res) then begin
        SMrw.AccNumber = "";
        SMrw.Comment = "-------------- " & USetStr(12582) & " --------------";
        SMrw.DebVal = BlankVal;
        SMrw.CredVal = BlankVal;
        MatRowPut(SMr,i,SMrw);
        last = i;
        res = false;
      end else begin
        MatRowDelete(SMr,i);
        i = i - 1;
      end;
    end else begin
      res = true;
    end;
  end;
  if (last>0) then begin
    while (last<MatRowCnt(SMr)) begin
      MatRowDelete(SMr,MatRowCnt(SMr)-1);
    end;
  end;
  return;
end;

procedure AddToTotPayModesSum(array string aitcodetot,array string aitcrncytot,array val aitsumtot,array val aitsumb1tot,array val aitnrtot,array val aitstartbaltot,array val aitstartbalb1tot,array val aitvattot,array val aitsumb1outtot,Integer aitcnttot,
                              var array string aitcodesum,var array string aitcrncysum,var array val aitsumsum,var array val aitsumb1sum,var array val aitnrsum,var array val aitstartbalsum,var array val aitstartbalb1sum,var array val aitvatsum,var array val aitsumb1outsum,var Integer aitcntsum)
begin
  Integer toti;
  Integer sumi;
  Boolean addedf;
    

  for (toti=0;toti<aitcnttot;toti=toti+1) begin
    addedf = false;
    for (sumi=0;sumi<aitcntsum;sumi=sumi+1) begin
      if (aitcodetot[toti]==aitcodesum[sumi]) and (aitcrncytot[toti]==aitcrncysum[sumi]) then begin
        aitsumsum[sumi] = aitsumsum[sumi] + aitsumtot[toti];
        aitsumb1sum[sumi] = aitsumb1sum[sumi] + aitsumb1tot[toti];
        aitnrsum[sumi] = aitnrsum[sumi] + aitnrtot[toti];
        aitstartbalsum[sumi] = aitstartbalsum[sumi] + aitstartbaltot[toti];
        aitstartbalb1sum[sumi] = aitstartbalb1sum[sumi] + aitstartbalb1tot[toti];
        aitvatsum[sumi] = aitvatsum[sumi] + aitvattot[toti];
        aitsumb1outsum[sumi] = aitsumb1outsum[sumi] + aitsumb1outtot[toti];
        addedf = true;
      end;
    end;
    if (addedf==false) then begin
      aitcodesum[aitcntsum] = aitcodetot[toti];
      aitcrncysum[aitcntsum] = aitcrncytot[toti];
      aitsumsum[aitcntsum] = aitsumtot[toti];
      aitsumb1sum[aitcntsum] = aitsumb1tot[toti];
      aitnrsum[aitcntsum] = aitnrtot[toti];
      aitstartbalsum[aitcntsum] = aitstartbaltot[toti];
      aitstartbalb1sum[aitcntsum] = aitstartbalb1tot[toti];
      aitvatsum[aitcntsum] = aitvattot[toti];
      aitsumb1outsum[aitcntsum] = aitsumb1outtot[toti];
      aitcntsum = aitcntsum + 1;
    end;
  end;
  return;
end;

procedure AddToTotIV(string ivcode,string aivcrncy,val ivval,val ivb1val,val ivnr,val ivoutval,val ivb1outval,var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,Boolean inperiod,val openbal)
begin
  Integer i;
  string 255 ivcrncy;
  record BaseCurBlock BCb;

  ivcrncy = aivcrncy;
  if (blank(ivcrncy)) then begin
    BlockLoad(BCb);
    ivcrncy = BCb.BaseCur1;
  end;
  for (i=0;i<aitcnttot;i=i+1) begin
    if (aitcodetot[i]==ivcode) and (aitcrncytot[i]==ivcrncy) then begin
      if (inperiod==false) then begin
        aitstartbaltot[i] = aitstartbaltot[i] + (ivval - ivoutval);
        aitstartbalb1tot[i] = aitstartbalb1tot[i] + (ivb1val - ivb1outval);
        aitstartbaltot[i] = aitstartbaltot[i] + openbal;
      end else begin
        aitsumtot[i] = aitsumtot[i] + ivval;
        aitsumb1tot[i] = aitsumb1tot[i] + ivb1val;
        aitnrtot[i] = aitnrtot[i] + ivnr;
        aitvattot[i] = aitvattot[i] + ivoutval;
        aitsumb1outtot[i] = aitsumb1outtot[i] + ivb1outval;
      end;
      goto LAddToTotIV;
    end;
  end;
  aitcodetot[aitcnttot] = ivcode;
  aitcrncytot[aitcnttot] = ivcrncy;
  aitsumtot[aitcnttot] = 0;
  aitsumb1tot[aitcnttot] = 0;
  aitnrtot[aitcnttot] = 0;
  aitstartbaltot[aitcnttot] = 0;
  aitstartbalb1tot[aitcnttot] = 0;
  aitvattot[aitcnttot] = 0;
  aitsumb1outtot[i] = 0;
  if (inperiod==false) then begin
    aitstartbaltot[aitcnttot] = ivval - ivoutval;
    aitstartbalb1tot[aitcnttot] = ivb1val - ivb1outval;
  end else begin
    aitsumtot[aitcnttot] = ivval;
    aitsumb1tot[aitcnttot] = ivb1val;
    aitnrtot[aitcnttot] = ivnr;
    aitvattot[aitcnttot] = ivoutval;
    aitsumb1outtot[i] = ivb1outval;
  end;
  aitstartbaltot[aitcnttot] = aitstartbaltot[aitcnttot] + openbal;
  aitcnttot = aitcnttot + 1;
LAddToTotIV:;  
  return;
end;

procedure SetToTotIV(string ivcode,string aivcrncy,val ivval,val ivb1val,val ivoutval,val ivb1outval,var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitstartbaltot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,Boolean inperiod)
begin
  Integer i;
  Boolean addedf;
  string 255 ivcrncy;
  record BaseCurBlock BCb;
  
  ivcrncy = aivcrncy;
  if (blank(ivcrncy)) then begin
    BlockLoad(BCb);
    ivcrncy = BCb.BaseCur1;
  end;  
  addedf = false;
  for (i=0;i<aitcnttot;i=i+1) begin
    if (aitcodetot[i]==ivcode) and (aitcrncytot[i]==ivcrncy) then begin
      if (inperiod==false) then begin
        aitstartbaltot[i] = ivval - ivoutval;
        aitsumtot[i] = 0;
        aitsumb1tot[i] = 0;
//        aitnrtot[i] = 0;
        aitvattot[i] = 0;
        aitsumb1outtot[i] = 0;
      end else begin
        aitstartbaltot[i] = 0;
        aitsumtot[i] = ivval;
        aitsumb1tot[i] = ivb1val;
        aitvattot[i] = ivoutval;
        aitsumb1outtot[i] = ivb1outval;
      end;
      addedf = true;
    end else begin
      aitstartbaltot[i] = 0;
      aitsumtot[i] = 0;
      aitsumb1tot[i] = 0;
      aitvattot[i] = 0;
      aitsumb1outtot[i] = 0;
    end;
  end;
  if (addedf==false) then begin
    aitcodetot[aitcnttot] = ivcode;
    aitcrncytot[aitcnttot] = ivcrncy;
    aitsumtot[aitcnttot] = 0;
    aitsumb1tot[aitcnttot] = 0;
//    aitnrtot[aitcnttot] = 0;
    aitstartbaltot[aitcnttot] = 0;
    aitvattot[aitcnttot] = 0;
    aitsumb1outtot[aitcnttot] = 0;
    if (inperiod==false) then begin
      aitstartbaltot[aitcnttot] = ivval - ivoutval;
    end else begin
      aitsumtot[aitcnttot] = ivval;
      aitsumb1tot[aitcnttot] = ivb1val;
      aitvattot[aitcnttot] = ivoutval;
      aitsumb1outtot[aitcnttot] = ivb1outval;
    end;
    aitcnttot = aitcnttot + 1;
  end;
LSetToTotIV:;  
  return;
end;

procedure PrintStartBalance(val bal,Date thedat,string machine,string drawer,var Date printedd,Boolean recprinter)
begin
  if (recprinter==false) then begin
    if (nonblankdate(printedd) and RequireOpenSession(machine)==false) then begin
      goto LPrintStartBalance;
    end;
    StartFormat(15);
    if (nonblankdate(printedd)) then begin
      OutString(0,0,USetStr(12569),false);
    end else begin
      OutString(0,0,USetStr(12559),false);
    end;
    OutDate(2,0,thedat,false);
//    OutString(3,0,USetStr(12541) & ": " & machine,false);
//    OutString(4,0,USetStr(12542) & ": " & drawer,false);
    OutValBiDi(1,0,bal,M4Val,true,510);
    EndFormat;
  end;
LPrintStartBalance:;  
  printedd = thedat;
  return;
end;

procedure PrintPOSBalance(Date dfr,Date dto,Time tfr,Time tto,array string acod,array LongInt aser,array Date adat,array Time atim,Integer pos,Integer detail,var val bal,var Date printedd,Boolean printf,Boolean recprinter,
                          var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val ivb1outval,var Integer aitcnttot,record SMVc SMr)
begin
  record POSBalanceVc POSBalancer;
  record DefCashBlock DefCashRec;
  Boolean locprintf,inperiod;
  Integer i,rwcnt;
  val smsum;

  BlockLoad(DefCashRec);
  locprintf = printf;
  inperiod = true;
  if ((dfr>adat[pos]) or (dto<adat[pos])) then begin
    inperiod = false;
  end;
  if (nonblanktime(tfr)) then begin
    if (dfr==adat[pos]) then begin
      if (tfr>atim[pos]) then begin
        inperiod = false;
      end;
    end;
  end;
  if (nonblanktime(tto)) then begin
    if (dto==adat[pos]) then begin
      if (tto<atim[pos]) then begin
        inperiod = false;
      end;
    end;
  end;
  POSBalancer.SerNr = aser[pos];
  if (ReadFirstMain(POSBalancer,1,true)) then begin
    if (locprintf and inperiod) then begin
      if (recprinter==false) then begin
//        Gray_Divider(0,1);
        if (detail!=2) then begin
          StartFormat(15);
          OutStringID(0,"DblPOSBalance",USetStr(12563),false,POSBalancer.SerNr);
          OutString(2,0,POSBalancer.TransDate,false); // left(POSBalancer.TransTime,5)
//        OutString(5,0,"",false);
          OutValBiDi(1,0,POSBalancer.Bal,M4Val,true,510);
          EndFormat;
          if (POSBalancer.Bal!=bal) then begin
            StartFormat(15);
            OutString(9,0,USetStr(12550),true);
            OutValBiDi(1,0,POSBalancer.Bal-bal,M4Val,true,510);
            EndFormat;
          end;
//        Black_Divider(0,1);
          StartFormat(15);
          EndFormat;
        end;
        if ((printedd!=dfr) and (POSBalancer.TransDate!=dfr)) then begin
          if (detail!=2) then begin
            PrintStartBalance(bal,POSBalancer.TransDate,POSBalancer.MachineName,POSBalancer.Drawer,printedd,recprinter); // dfr
          end;
        end;
      end else begin
      end;
      printedd = POSBalancer.TransDate;
    end;
    bal = POSBalancer.Bal;
    if (pos==1) then begin
//      SetToTotIV(DefCashRec.DefCashPayMode,"",bal,bal,0,0,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitstartbaltot,aitvattot,ivb1outval,aitcnttot,false);
    end;
    if (POSBalancer.NLTransDone==0 or printf) then begin
      AddSMRow(SMr,POSBalancer.TransDate,"BALANCE","","",POSBalancer.SerNr,1,false,true,smsum);
    end else begin
      rwcnt = MatRowCnt(SMr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowDelete(SMr,0);
      end;
    end;
  end;
  return;
end;

procedure PrintPOSEvent(Date dfr,Date dto,Time tfr,Time tto,array string acod,array LongInt aser,array Date adat,array Time atim,Integer pos,Integer detail,val bal,var Date printedd,Boolean printf,Boolean recprinter)
begin
  record POSEventVc POSEventr;
  Boolean locprintf;

  locprintf = printf;
  if ((dfr>adat[pos]) or (dto<adat[pos])) then begin
    locprintf = false;
  end;
  if (nonblanktime(tfr)) then begin
    if (dfr==adat[pos]) then begin
      if (tfr>atim[pos]) then begin
        locprintf = false;
      end;
    end;
  end;
  if (nonblanktime(tto)) then begin
    if (dto==adat[pos]) then begin
      if (tto<atim[pos]) then begin
        locprintf = false;
      end;
    end;
  end;
  POSEventr.SerNr = aser[pos];
  if (ReadFirstMain(POSEventr,1,true)) then begin
    if (locprintf) then begin
      if (printedd!=adat[pos]) then begin
        PrintStartBalance(bal,POSEventr.TransDate,POSEventr.MachineName,POSEventr.Drawer,printedd,recprinter);
      end;
      if (recprinter==false) then begin
        if (POSEventr.Event!=2) then begin
          StartFormat(15);
          EndFormat;
          Black_Divider(0,1);
        end else begin
//          Gray_Divider(0,1);
        end;
        StartFormat(15);
        if (POSEventr.Event!=2) then begin
          OutStringID(0,"DblPOSEvent",USetStr(12543),false,POSEventr.SerNr);
        end else begin
          OutStringID(0,"DblPOSEvent",USetStr(12544),false,POSEventr.SerNr);
        end;
        OutString(2,0,left(POSEventr.TransTime,5),false);
        OutString(5,0,"",false);
        OutValBiDi(1,0,bal,M4Val,true,510);
        EndFormat;
        if (POSEventr.Event==2) then begin
          Black_Divider(0,1);
          StartFormat(15);
          EndFormat;
        end else begin
//          Gray_Divider(0,1);
        end;
      end else begin
      end;
    end;
  end;
  return;
end;

function val GetPMCodeBal(string pmcode,array string aitcodetot,array val aitsumtot,array val aitvattot,array val aitstartbaltot,Integer aitcnttot)
begin
  val res;
  Integer i;

  res = 0;
  for (i=0;i<aitcnttot;i=i+1) begin
    if (pmcode==aitcodetot[i]) then begin
      res = res + aitsumtot[i] - aitvattot[i];
      res = res + aitstartbaltot[i];
    end;
  end;
  GetPMCodeBal = res;
  return;
end;

procedure PrintCashierBal(string machine,string drawer,Date dfr,Date dto,Time tfr,Time tto,array string acod,array LongInt aser,array Date adat,array Time atim,Integer pos,Integer detail,val bal,var Date printedd,Boolean printf,Boolean recprinter,
                          array string aitcodetot,array string aitcrncytot,array val aitsumtot,array val aitsumb1tot,array val aitvattot,array val aitstartbaltot,array val aitstartbalb1tot,Integer aitcnttot,var record SMVc CountSMr)
begin
  record CashierBalVc CashierBalr;
  row CashierBalVc CashierBalrw;
  row PMBlock PMrw;
  row SMVc SMrw;
  Integer rwcnt,i;
  Boolean locprintf;
  LongInt d1,t1;
  Date the80s;
  val shouldbe;
  
  RecordNew(CountSMr);
  the80s.year = 1980;
  the80s.month = 1;
  the80s.day = 1;
  locprintf = printf;
  if ((dfr>adat[pos]) or (dto<adat[pos])) then begin
    locprintf = false;
  end;
  if (nonblanktime(tfr)) then begin
    if (dfr==adat[pos]) then begin
      if (tfr>atim[pos]) then begin
        locprintf = false;
      end;
    end;
  end;
  if (nonblanktime(tto)) then begin
    if (dto==adat[pos]) then begin
      if (tto<atim[pos]) then begin
        locprintf = false;
      end;
    end;
  end;
  CashierBalr.UserCode = acod[pos];
  CashierBalr.TransDate = adat[pos];
  CashierBalr.TransTime = atim[pos];
  if (ReadLastMain(CashierBalr,3,true)) then begin
    if (locprintf) then begin
      if (printedd!=adat[pos]) then begin
        PrintStartBalance(bal,CashierBalr.TransDate,CashierBalr.MachineName,CashierBalr.Drawer,printedd,recprinter);
      end;
      if (recprinter==false) then begin
        d1 = DateDiff(CashierBalr.TransDate,the80s);
        TimeToSeconds(CashierBalr.TransTime,t1);
        if (bal!=0) then begin
          switch (detail) begin
            case 0: // Wierd I know, but we only have sum per payment mode in overview. Fix later....            
              StartFormat(15);
              OutStringID(0,"DblCashierBal",USetStr(12549),false,CashierBalr.UserCode & "," & d1 & "," & t1);
              OutStringAdjustBiDi(170,0,USetStr(12536),true,M4Val,210);
              OutStringAdjustBiDi(240,0,USetStr(12537),true,M4Val,280);
              OutStringAdjustBiDi(310,0,USetStr(12550),true,M4Val,350);
              OutValBiDi(1,0,bal,M4Val,true,510);
              EndFormat;
              Gray_Divider(0,310);
              rwcnt = MatRowCnt(CashierBalr);
              for (i=0;i<rwcnt;i=i+1) begin
                MatRowGet(CashierBalr,i,CashierBalrw);
                if (GetPMRow(CashierBalrw.PMCode,PMrw)) then begin end;
                shouldbe = GetPMCodeBal(CashierBalrw.PMCode,aitcodetot,aitsumtot,aitvattot,aitstartbaltot,aitcnttot);
                StartFormat(15);
                OutString(20,0,CashierBalrw.PMCode,false);
                OutString(50,0,PMrw.Comment,false);
                OutValBiDi(170,0,CashierBalrw.Amount,M4Val,true,210);
                OutValBiDi(240,0,shouldbe,M4Val,true,280);
                OutValBiDi(310,0,CashierBalrw.Amount-shouldbe,M4Val,true,350);
                OutValBiDi(1,0,bal,M4Val,true,510);
                EndFormat;
                ClearRow(CountSMr,SMrw,1);
                SMrw.Objects = CashierBalrw.PMCode;
                SMrw.Comment = PMrw.Comment;
                SMrw.DebVal = CashierBalrw.Amount;
                SMrw.CredVal = shouldbe;
                MatRowPut(CountSMr,MatRowCnt(CountSMr),SMrw);
              end;
              Gray_Divider(0,310);
            otherwise // Code needed
              StartFormat(15);
              OutStringID(0,"DblCashierBal",USetStr(12549),false,CashierBalr.UserCode & "," & d1 & "," & t1);
              OutString(2,0,left(CashierBalr.TransTime,5),false);
              if (nonblank(CashierBalr.UserName)) then begin
                OutString(5,0,CashierBalr.UserName,false);
              end else begin
                OutString(5,0,CashierBalr.UserCode,false);
              end;
              OutValBiDi(1,0,CashierBalr.EndBal,M4Val,true,510);
              EndFormat;
              StartFormat(15);
              OutString(9,0,USetStr(12550),true);
              OutValBiDi(1,0,CashierBalr.EndBal-bal,M4Val,true,510);
              EndFormat;
          end;
        end;
      end;
    end else begin
      if (printf==false) then begin
        if (((CashierBalr.MachineName==machine) and (CashierBalr.Drawer==drawer)) or (blank(machine)) or (blank(drawer))) then begin
          rwcnt = MatRowCnt(CashierBalr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(CashierBalr,i,CashierBalrw);
            if (GetPMRow(CashierBalrw.PMCode,PMrw)) then begin end;
            shouldbe = GetPMCodeBal(CashierBalrw.PMCode,aitcodetot,aitsumtot,aitvattot,aitstartbaltot,aitcnttot);
            ClearRow(CountSMr,SMrw,1);
            SMrw.Objects = CashierBalrw.PMCode;
            SMrw.Comment = PMrw.Comment;
            SMrw.DebVal = CashierBalrw.Amount;
            SMrw.CredVal = shouldbe;
            MatRowPut(CountSMr,MatRowCnt(CountSMr),SMrw);
          end;
        end;
      end;
    end;
  end;
  return;
end;

procedure PrintCashInOut(Date dfr,Date dto,Time tfr,Time tto,array string acod,array LongInt aser,array Date adat,array Time atim,Integer pos,
                         Integer detail,var val bal,var val totin,var val totout,var Date printedd,Boolean printf,Boolean recprinter,
                         var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,
                         var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,record SMVc SMr)
begin
  record CashVc Cashr;
  row CashVc Cashrw;
  Integer rwcnt,i;
  Boolean locprintf;
  row SMVc SMrw;
  Boolean dbflag,inperiod;
  val smsum;
  string 40 CredAcc,accnr;
  row PMBlock PMrw;
  string 255 tstr;
  val ds,cs;
  record CashierDefBlock CDb;
  Boolean dcf;

  BlockLoad(CDb);
  locprintf = printf;
  inperiod = true;
  if ((dfr>adat[pos]) or (dto<adat[pos])) then begin
    inperiod = false;
  end;
  if (nonblanktime(tfr)) then begin
    if (dfr==adat[pos]) then begin
      if (tfr>atim[pos]) then begin
        inperiod = false;
      end;
    end;
  end;
  if (nonblanktime(tto)) then begin
    if (dto==adat[pos]) then begin
      if (tto<atim[pos]) then begin
        inperiod = false;
      end;
    end;
  end;
  Cashr.SerNr = aser[pos];
  if (ReadFirstMain(Cashr,1,true)) then begin
    if (locprintf and inperiod) then begin
      if (printedd!=adat[pos]) then begin
        PrintStartBalance(bal,Cashr.TransDate,Cashr.MachineName,Cashr.Drawer,printedd,recprinter);
      end;
    end;
    rwcnt = MatRowCnt(Cashr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Cashr,i,Cashrw);
      switch (Cashr.Event) begin
        case 0:
          if (Cashrw.PMCode!="DBTTRS") then begin
            bal = bal - Cashrw.Amount;
          end;
          if (inperiod) then begin
            totout = totout + Cashrw.Amount;
          end;
          cs = Cashrw.Amount;
          ds = 0;
        case 1:
          bal = bal + Cashrw.Amount;
          if (inperiod) then begin
            totin = totin + Cashrw.Amount;
          end;
          cs = 0;
          ds = Cashrw.Amount;
        case 2:
          bal = bal - Cashrw.Amount;
          if (inperiod) then begin
            totout = totout + Cashrw.Amount;
          end;
          cs = Cashrw.Amount;
          ds = 0;
      end;
      AddToTotIV(Cashrw.PMCode,"",ds,ds,0,cs,cs,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,inperiod,blankval);
      if (locprintf and inperiod) then begin
        if (recprinter==false) then begin
          if (GetPMRow(Cashrw.PMCode,PMrw)) then begin end;
          StartFormat(15);
          switch (Cashr.Event) begin
            case 0:
              OutStringID(0,"DblCash",USetStr(12555),false,Cashr.SerNr);
              OutString(2,0,Cashrw.PMCode,false);
              OutString(5,0,PMrw.Comment,false);
              OutVal(9,0,Cashrw.Amount,M4Val,true);
              OutValBiDi(1,0,bal,M4Val,true,510);
            case 1:
              OutStringID(0,"DblCash",USetStr(12554),false,Cashr.SerNr);
              OutString(2,0,Cashrw.PMCode,false);
              OutString(5,0,PMrw.Comment,false);
              OutVal(8,0,Cashrw.Amount,M4Val,true);
              OutValBiDi(1,0,bal,M4Val,true,510);
            case 2:
              OutStringID(0,"DblCash",USetStr(12538),false,Cashr.SerNr);
              OutString(2,0,Cashrw.PMCode,false);
              OutString(5,0,PMrw.Comment,false);
              OutVal(9,0,Cashrw.Amount,M4Val,true);
              OutValBiDi(1,0,bal,M4Val,true,510);
          end;
          EndFormat;
        end;
      end;
    end;
//    if ((Cashr.Event==0) or (Cashr.Event==2)) then begin
//Event==2 Writeoff on Debit Side
    if (Cashr.Event==0) then begin
      dbflag = true;
    end else begin
      dbflag = false;
    end;
    rwcnt = MatRowCnt(Cashr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(Cashr,i,Cashrw);
      if (Cashrw.Amount!=0) and (Cashrw.PMCode!="DBTTRS") then begin
        if (GetPMRow(Cashrw.PMCode,PMrw)) then begin end;
        CredAcc = Cashr.CredAcc;
        if (Cashr.Event==2) then begin
//          if (blank(CredAcc)) then begin
            CredAcc = PMrw.AccNr;
//          end;
//same acc below
        end else begin
          if (blank(CredAcc)) then begin
            CredAcc = PMrw.BackOfficeAcc;
          end;
          if (blank(CredAcc)) then begin
            CredAcc = CDb.CredAcc;
          end;
        end;
        if (nonblank(CredAcc)) then begin
          AddSMRow(SMr,SMr.TransDate,CredAcc,"","",Cashr.Comment,Cashrw.Amount,true,dbflag,smsum);
        end;
        accnr = "";
        if (Cashr.Event==2) then begin
          accnr = Cashr.CredAcc;
          if (blank(accnr)) then begin
            accnr = CDb.WriteOffAcc;// WriteOffAcc is the one put into Cashr.CredAcc filled in in recordcheck so no NL transaction is created
          end;
        end;
        if (blank(accnr)) then begin
          accnr = PMrw.AccNr;
        end;
        if (GetAccName(accnr,tstr,60)==false) then begin end;
        AddSMRow(SMr,SMr.TransDate,accnr,PMrw.Objects,"",tstr,Cashrw.Amount,true,!dbflag,smsum);
      end;
    end;
  end;
  return;
end;

procedure PrintIVArray(string aivtype,Date thedat,string machine,string drawer,string paymode,Date frdat,Time frtim,Date todat,Time totim,
                       array string aivcode,array string aivcrncy,array val aivval,array val aivb1val,array val aivnr,array val aivoutval,array val aivb1outval,array val atipsum,Integer aivcnt,
                       var val bal,var val totin,var val totout,var Date printedd,Boolean inperiod,Boolean printf,Boolean recprinter,Boolean dbttrsf,Integer detail,string dblclk,
                       var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot)
begin
  Integer i;
  string 200 pmcomment,tstr;
  LongInt d1,d2,t1,t2;
  Date the80s;
  record CashierDefBlock CDb;
  transaction Integer gCashupReportMode;
  record IVVc IVr;
  record IVCashVc IVCashr;
  string 255 lastivcode,lastivcrncy,ivtype;
  Boolean testf,ivf;
  val openbal;
  
  BlockLoad(CDb);
  the80s.year = 1980;
  the80s.month = 1;
  the80s.day = 1;
  ivtype = aivtype;
//  openbal = bal;//this line makes fwd balance going wild if u have many sessions in same day, or without closing
  for (i=0;i<aivcnt;i=i+1) begin
    if (printf and inperiod) then begin
      if (printedd!=thedat) then begin
        if (detail!=2) then begin
          PrintStartBalance(bal,thedat,machine,drawer,printedd,recprinter);
        end;
      end;
    end;
    if (aivcode[i]=="DBTTRS") then begin
      bal = bal + aivb1val[i];
      bal = bal - aivb1outval[i];
    end else begin
      bal = bal + aivb1val[i];
      bal = bal - aivb1outval[i];
    end;
    if (inperiod) then begin
      if (aivcode[i]=="DBTTRS") then begin
        totin = totin - aivb1val[i];
        totout = totout - aivb1outval[i];
      end else begin
        totin = totin + aivb1val[i];
        totout = totout + aivb1outval[i];
      end;
    end;
    testf = inperiod and printf;
    if (dbttrsf) then begin
      if (aivcode[i]!="DBTTRS") then begin
        testf = false;
      end;
    end else begin
      if (aivcode[i]=="DBTTRS") then begin
        testf = false;
      end;
    end;
    if (testf) then begin
      if (recprinter==false) then begin
        d1 = DateDiff(frdat,the80s);
        d2 = DateDiff(todat,the80s);
        TimeToSeconds(frtim,t1);
        TimeToSeconds(totim,t2);
        if (detail!=2) then begin
          IVCashr.SerNr = StringtoLongInt(aivcode[i]);
          ivf = ReadFirstMain(IVCashr,1,true);
          if (IVCashr.InvType==kPOSInvoiceTypeCredit) then begin
            ivtype = USetStr(38500);
          end;
          GetPayModeText(aivcode[i],pmcomment);
          StartFormat(15);
          if (detail!=0) then begin
            OutString(0,0,ivtype,false);
            OutString(2,dblclk,aivcode[i],false);
            OutString(110,dblclk,aivcrncy[i],false);
            switch (gCashupReportMode) begin
              case kCashupReportCleanCash:
                if (ivtype==USetStr(12566)) then begin
                  IVCashr.SerNr = StringtoLongInt(aivcode[i]);
                  if (ivf) then begin
                    if (nonblank(IVCashr.OfficialSerNr)) then begin
                      if (blank(IVCashr.OfficialSerNr2)) then begin
                        OutString(5,0,USetStr(18692),false);
                      end else begin
                        OutString(5,0,USetStr(18693),false);
                      end;
                    end else begin
                      OutString(5,0,USetStr(18694),false);
                    end;
                    tstr = IVCashr.FiscalDeviceSeqNr;
                    if (IVCashr.FiscalDeviceSeqNr<0) then begin
                      tstr = "";
                    end;
                    OutStringID(215,"DblFDSeqNrDetails",tstr,false,ivtype & ":" & IVCashr.SerNr);
                  end;
                end;
                if (ivtype==USetStr(12568)) then begin
                  IVr.SerNr = StringtoLongInt(aivcode[i]);
                  if (ReadFirstMain(IVr,1,true)) then begin
                    if (nonblank(IVr.OfficialSerNr)) then begin
                      if (blank(IVr.OfficialSerNr2)) then begin
                        OutString(5,0,USetStr(18692),false);
                      end else begin
                        OutString(5,0,USetStr(18693),false);
                      end;
                    end else begin
                      OutString(5,0,USetStr(18694),false);
                    end;
                    OutStringID(215,"DblFDSeqNrDetails",IVr.FiscalDeviceSeqNr,false,ivtype & ":" & IVr.SerNr);
                  end;
                end;
              otherwise
                OutString(5,0,"",false);
            end;
          end else begin
            if (lastivcode!=aivcode[i]) then begin
              switch (gCashupReportMode) begin
                case kCashupReportCleanCash:     
                  OutStringID(0,"DblPrintDetPOSCC",ivtype,false,"" & d1 & "," & d2 & "," & t1 & "," & t2 & "," & aivcode[i]);
                otherwise
                  OutStringID(0,"DblPrintDetPOS",ivtype,false,"" & d1 & "," & d2 & "," & t1 & "," & t2 & "," & aivcode[i]);
              end;
              OutString(2,0,aivcode[i],false);
              OutString(110,0,aivcrncy[i],false);
              OutString(5,0,pmcomment,false);
            end else begin
              OutString(110,0,aivcrncy[i],false);
              OutString(5,0,pmcomment,false);
            end;
          end;
          if (detail!=0) then begin
            switch (gCashupReportMode) begin
              case kCashupReportCleanCash:
                OutVal(260,0,aivnr[i],M40Val,true);
            end;
          end;
          OutVal(8,0,aivval[i],M4Val,true);
          OutVal(9,0,aivoutval[i],M4Val,true);
          OutValBiDi(1,0,bal,M4Val,true,510);
          EndFormat;
        end;
      end else begin
      end;
      lastivcode = aivcode[i];
    end;
    AddToTotIV(aivcode[i],aivcrncy[i],aivval[i],aivb1val[i],aivnr[i],aivoutval[i],aivb1outval[i],aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,inperiod,openbal);
  end;
  if (detail!=2) then begin
  if (CDb.InclTipInCashup) then begin
    the80s.year = 1980;
    the80s.month = 1;
    the80s.day = 1;
    for (i=0;i<aivcnt;i=i+1) begin
      bal = bal + atipsum[i];
      totin = totin + atipsum[i];
      if (printf) then begin
        if (recprinter==false) then begin
          if (atipsum[i]>0) then begin
            d1 = DateDiff(frdat,the80s);
            d2 = DateDiff(todat,the80s);
            TimeToSeconds(frtim,t1);
            TimeToSeconds(totim,t2);
            GetPayDealText(aivcode[i],"",pmcomment);
            StartFormat(15);
            OutString(0,0,"Tip",false);
            OutString(2,0,aivcode[i],false);
            if (detail!=0) then begin
              OutString(5,0,"",false);
            end else begin
              OutString(5,0,pmcomment,false);
            end;
            OutVal(8,0,atipsum[i],M4Val,true);
            OutVal(9,0,0,M4Val,true);
            OutValBiDi(1,0,bal,M4Val,true,510);
            EndFormat;
          end;
        end else begin
        end;
      end;
      AddToTotIV(aivcode[i],aivcrncy[i],atipsum[i],atipsum[i],0,0,0,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,inperiod,blankval);
    end;
  end;
  end;
  return;
end;

procedure PrintTotPayModes(Integer detail,array string aitcodetot,array string aitcrncytot,array val aitsumtot,array val aitsumb1tot,array val aitnrtot,array val aitstartbaltot,array val aitstartbalb1tot,array val aitvattot,array val aitsumb1outtot,Integer aitcnttot,Boolean recprinter)
begin
  Integer i;
  string 255 pmcomment;
  val bal;
  transaction Integer gCashupReportMode;
  string 255 lastitcode;
  
  if (detail!=2) then begin
    StartFormat(15);
    EndFormat;
    StartFormat(15);
    OutString(0,0,USetStr(12539),false);
    switch (gCashupReportMode) begin
      case kCashupReportCleanCash:
        OutString(110,0,USetStr(12547),false);
        OutString(210,0,USetStr(12796),true);
      otherwise
        OutString(5,0,USetStr(12547),false);
    end;
    if (aitcnttot==1) then begin
      OutStringAdjust(7,0,USetStr(12559),true,M4Val);
    end;
    OutStringAdjust(8,0,USetStr(12554),true,M4Val);
    OutStringAdjust(9,0,USetStr(12555),true,M4Val);
    OutStringAdjustBiDi(1,0,USetStr(12560),true,M4Val,510);
    EndFormat;
  end else begin
    StartFormat(15);
    switch (gCashupReportMode) begin
      case kCashupReportCleanCash:
        OutString(110,0,USetStr(12547),false);
        OutString(210,0,USetStr(12796),true);
      otherwise
        OutString(5,0,USetStr(12547),false);
    end;
    if (aitcnttot==1) then begin
      OutStringAdjust(7,0,USetStr(12559),true,M4Val);
    end;
    OutStringAdjust(8,0,USetStr(12554),true,M4Val);
    OutStringAdjust(9,0,USetStr(12555),true,M4Val);
    OutStringAdjustBiDi(1,0,USetStr(12560),true,M4Val,510);
    EndFormat;
  end;
  bal = 0;
  Gray_Divider(0,1);
  for (i=0;i<aitcnttot;i=i+1) begin
    if (aitcodetot[i]!="DBTTRS") then begin
      bal = bal + aitstartbalb1tot[i] + aitsumb1tot[i] - aitsumb1outtot[i];
    end;
    if (recprinter==false) then begin
      if ((aitstartbaltot[i]!=0) or (aitvattot[i]!=0) or (aitsumtot[i]!=0) or (aitstartbaltot[i]!=0)) and (aitcodetot[i]!="DBTTRS") then begin
        StartFormat(15);
        if (lastitcode!=aitcodetot[i]) then begin
          GetPayDealText(aitcodetot[i],"",pmcomment);
          if (detail!=2) then begin
            OutString(2,"DblPrintPMCashupSum",aitcodetot[i],false);
          end else begin
            OutString(2,0,aitcodetot[i],false);
          end;
          switch (gCashupReportMode) begin
            case kCashupReportCleanCash:
              OutString(110,0,pmcomment,false);
              OutString(210,0,aitnrtot[i],true);
            otherwise
              OutString(110,0,aitcrncytot[i],false);
              OutString(5,0,pmcomment,false);
          end;
        end else begin
          switch (gCashupReportMode) begin
            case kCashupReportCleanCash:
              OutString(110,0,pmcomment,false);
            otherwise
              OutString(110,0,aitcrncytot[i],false);
              OutString(5,0,pmcomment,false);
          end;
        end;
        if (aitcnttot==1) then begin
          OutVal(7,0,aitstartbaltot[i],M4Val,true);
//unfortunatelly POS balance doesnt know per payment mode
        end;
        OutVal(8,0,aitsumtot[i],M4Val,true);
        OutVal(9,0,aitvattot[i],M4Val,true);
        OutValBiDi(1,0,aitstartbalb1tot[i] + aitsumb1tot[i] - aitsumb1outtot[i],M4Val,true,510);
        EndFormat;
        lastitcode = aitcodetot[i];
      end;
    end;
  end;
  for (i=0;i<aitcnttot;i=i+1) begin
    if (aitcodetot[i]=="DBTTRS") then begin
      bal = bal + aitstartbalb1tot[i] + aitsumb1tot[i] - aitsumb1outtot[i];
    end;
    if (recprinter==false) then begin
      if ((aitstartbaltot[i]!=0) or (aitvattot[i]!=0) or (aitsumtot[i]!=0) or (aitstartbaltot[i]!=0)) and (aitcodetot[i]=="DBTTRS") then begin
        StartFormat(15);
        if (lastitcode!=aitcodetot[i]) then begin
          GetPayDealText(aitcodetot[i],"",pmcomment);
          if (detail!=2) then begin
            OutString(2,"DblPrintPMCashupSum",aitcodetot[i],false);
          end else begin
            OutString(2,0,aitcodetot[i],false);
          end;
          switch (gCashupReportMode) begin
            case kCashupReportCleanCash:
              OutString(110,0,pmcomment,false);
              OutString(210,0,aitnrtot[i],true);
            otherwise
              OutString(110,0,aitcrncytot[i],false);
              OutString(5,0,pmcomment,false);
          end;
        end else begin
          switch (gCashupReportMode) begin
            case kCashupReportCleanCash:
              OutString(110,0,pmcomment,false);
            otherwise
              OutString(110,0,aitcrncytot[i],false);
              OutString(5,0,pmcomment,false);
          end;
        end;
        OutVal(7,0,aitstartbaltot[i],M4Val,true);
        OutVal(8,0,aitsumtot[i],M4Val,true);
        OutVal(9,0,aitvattot[i],M4Val,true);
        OutValBiDi(1,0,aitstartbalb1tot[i] + aitsumb1tot[i] - aitsumb1outtot[i],M4Val,true,510);
        EndFormat;
        lastitcode = aitcodetot[i];
      end;
    end;
  end;
  Gray_Divider(230,1);
  StartFormat(15);
  OutValBiDi(1,0,bal,M4Val,true,510);
  EndFormat;
  Gray_Divider(0,1);
  return;
end;

procedure ClearIVArray(var array string aivcode,var array string aivcrncy,var array val aivval,var array val aivb1val,var array val aivnr,var array val aivoutval,var array val aivb1outval,var array val atipsum,var Integer aivcnt)
begin
  Integer i;
  
  for (i=0;i<aivcnt;i=i+1) begin
    aivcode[i] = "";
    aivcrncy[i] = "";
    aivval[i] = 0;
    aivb1val[i] = 0;
    aivnr[i] = 0;
    aivoutval[i] = 0;
    aivb1outval[i] = 0;
    atipsum[i] = 0;
  end;
  aivcnt = 0;
  return;
end;

function Boolean FillAndPrintRestAccCash(Integer detail,Integer onrooms,Integer itemstat,Date sStartDate,Date sEndDate,Time sStartTime,Time sEndTime,string machine,string drawer,string paymode,Date frdat,Time frtim,Date todat,Time totim,var val bal,var val totin,var val totout,var Date printedd,Boolean printf,Boolean recprinter,
                                  var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,record SMVc SMr,
                                  var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,
                                  var array string atrsfitcodetot,var array string atrsfitcrncytot,var array val atrsfitsumtot,var array val atrsfitsumb1tot,var array val atrsfitnrtot,var array val atrsfitstartbaltot,var array val atrsfitstartbalb1tot,var array val atrsfitvattot,var array val atrsfitsumb1outtot,var Integer atrsfitcnttot)
begin
  array string 20 aivcode;
  array string 20 aivcrncy;
  array val aivval;
  array val aivb1val;
  array val aivnr;
  array val aivoutval;
  array val aivb1outval;
  array val atipsum;
  Integer aivcnt;

  array string 20 atrsfivcode;
  array string 20 atrsfivcrncy;
  array val atrsfivval;
  array val atrsfivb1val;
  array val atrsfivnr;
  array val atrsfivoutval;
  array val atrsfivb1outval;
  array val atrsftipsum;
  Integer atrsfivcnt,i;
  Boolean inperiod,addtoit;
  Time bltim;
  Time thetim;
  Boolean res;
  val bal2,totin2,totout2;

  res = false;
  if ((sStartDate>frdat) and (sStartDate<todat)) then begin // Used to be sStartDate<=todat
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = false;
    addtoit = false;
    if (nonblanktime(sStartTime)) then begin
      thetim = sStartTime;
    end else begin
      thetim = frtim;
    end;
//    FillUpAllRestAccCash(onrooms,frdat,AddDay(sStartDate,-1),frtim,bltim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up before period
    FillUpAllRestAccCash(onrooms,itemstat,frdat,sStartDate,frtim,thetim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,atrsfivcode,atrsfivcrncy,atrsfivval,atrsfivb1val,atrsfivnr,atrsfivoutval,atrsfivb1outval,atrsftipsum,atrsfivcnt,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up before period
    PrintIVArray(USetStr(12567),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblRestAccVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    for (i=0;i<aivcnt;i=i+1) begin
      AddToTotIV(aivcode[i],aivcrncy[i],aivval[i],aivb1val[i],aivnr[i],aivoutval[i],aivb1outval[i],atrsfitcodetot,atrsfitcrncytot,atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot,atrsfitcnttot,inperiod,blankval);
    end;
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    ClearIVArray(atrsfivcode,atrsfivcrncy,atrsfivval,atrsfivb1val,atrsfivnr,atrsfivoutval,atrsfivb1outval,atrsftipsum,atrsfivcnt);
    inperiod = true;
    addtoit = true;
//    FillUpAllRestAccCash(onrooms,sStartDate,todat,bltim,totim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivb1val,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up and print inside period
    FillUpAllRestAccCash(onrooms,itemstat,sStartDate,todat,thetim,totim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,atrsfivcode,atrsfivcrncy,atrsfivval,atrsfivb1val,atrsfivnr,atrsfivoutval,atrsfivb1outval,atrsftipsum,atrsfivcnt,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up and print inside period
    PrintIVArray(USetStr(12567),sStartDate,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblRestAccVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end else begin
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    if (sStartDate>todat) then begin
      inperiod = false; // This period before selection
      addtoit = false;
    end else begin
      inperiod = true; // This period during selection
      addtoit = true;
    end;
    FillUpAllRestAccCash(onrooms,itemstat,frdat,todat,frtim,totim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,atrsfivcode,atrsfivcrncy,atrsfivval,atrsfivb1val,atrsfivnr,atrsfivoutval,atrsfivb1outval,atrsftipsum,atrsfivcnt,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr);
    PrintIVArray(USetStr(12567),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblRestAccVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    PrintIVArray(USetStr(12533),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,atrsfivcode,atrsfivcrncy,atrsfivval,atrsfivb1val,atrsfivnr,atrsfivoutval,atrsfivb1outval,atipsum,atrsfivcnt,bal2,totin2,totout2,printedd,inperiod,printf,recprinter,true,detail,"DblRestAccVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    for (i=0;i<aivcnt;i=i+1) begin
      AddToTotIV(aivcode[i],aivcrncy[i],aivval[i],aivb1val[i],aivnr[i],aivoutval[i],aivb1outval[i],atrsfitcodetot,atrsfitcrncytot,atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot,atrsfitcnttot,inperiod,blankval);
    end;
  end;
  if (aivcnt>0) then begin
    res = true;
  end;
  FillAndPrintRestAccCash = res;
  return;
end;

function Boolean FillAndPrintIVCash(Integer detail,Integer itemstat,Date sStartDate,Date sEndDate,Time sStartTime,Time sEndTime,string machine,string drawer,string paymode,Date frdat,Time frtim,Date todat,Time totim,var val bal,var val totin,var val totout,var Date printedd,Boolean printf,Boolean recprinter,
                                    var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,record SMVc SMr,
                                    var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,var vector val vstatussum)
begin
  array string 20 aivcode;
  array string 20 aivcrncy;
  array val aivval;
  array val aivb1val;
  array val aivnr;
  array val aivoutval;
  array val aivb1outval;
  array val atipsum;
  Integer aivcnt;
  Boolean inperiod,addtoit;
  Time bltim;
  Time thetim;
  Boolean res;

  res = false;

  if ((sStartDate>frdat) and (sStartDate<todat)) then begin // Used to be sStartDate<=todat
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = false;
    addtoit = false;
    if (nonblanktime(sStartTime)) then begin
      thetim = sStartTime;
    end else begin
      thetim = frtim;
    end;
//    FillUpAllIVCash(frdat,AddDay(sStartDate,-1),frtim,bltim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivb1val,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up before period
    FillUpAllIVCash(itemstat,frdat,sStartDate,frtim,thetim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum); // Add up before period        
    PrintIVArray(USetStr(12566),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblNPTSIVCash",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = true;
    addtoit = true;
//    FillUpAllIVCash(sStartDate,todat,bltim,totim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivb1val,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up and print inside period
    FillUpAllIVCash(itemstat,sStartDate,todat,thetim,totim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum); // Add up and print inside period
    PrintIVArray(USetStr(12566),sStartDate,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblNPTSIVCash",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end else begin
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    if (sStartDate>todat) then begin
      inperiod = false; // This period before selection
      addtoit = false;
    end else begin
      inperiod = true; // This period during selection
      addtoit = true;
    end;

    FillUpAllIVCash(itemstat,frdat,todat,frtim,totim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum);
    PrintIVArray(USetStr(12566),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblNPTSIVCash",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end;
  if (aivcnt>0) then begin
    res = true;
  end;
  FillAndPrintIVCash = res;
  return;
end;

function Boolean FillAndPrintSLIV(Integer detail,Integer itemstat,Date sStartDate,Date sEndDate,Time sStartTime,Time sEndTime,string machine,string drawer,string paymode,Date frdat,Time frtim,Date todat,Time totim,var val bal,var val totin,var val totout,var Date printedd,Boolean printf,Boolean recprinter,
                                  var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,record SMVc SMr,
                                  var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,var vector val vstatussum)
begin
  array string 20 aivcode;
  array string 20 aivcrncy;
  array val aivval;
  array val aivb1val;
  array val aivnr;
  array val aivoutval;
  array val aivb1outval;
  array val atipsum;
  Integer aivcnt;
  Boolean inperiod,addtoit;
  Time bltim;
  Time thetim;
  Boolean res;

  res = false;
  if ((sStartDate>frdat) and (sStartDate<todat)) then begin // Used to be sStartDate<=todat
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = false;
    addtoit = false;
    if (nonblanktime(sStartTime)) then begin
      thetim = sStartTime;
    end else begin
      thetim = frtim;
    end;
//    FillUpAllSLIV(frdat,AddDay(sStartDate,-1),frtim,bltim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivb1val,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up before period
    FillUpAllSLIV(itemstat,frdat,sStartDate,frtim,thetim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum); // Add up before period
    PrintIVArray(USetStr(12568),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIVVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = true;
    addtoit = true;
//    FillUpAllSLIV(sStartDate,todat,bltim,totim,sEndDate,machine,drawer,paymode,aivcode,aivval,aivb1val,aivnr,aivoutval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up and print inside period

    FillUpAllSLIV(itemstat,sStartDate,todat,thetim,totim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum); // Add up and print inside period
    PrintIVArray(USetStr(12568),sStartDate,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIVVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end else begin
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    if (sStartDate>todat) then begin
      inperiod = false; // This period before selection
      addtoit = false;
    end else begin
      inperiod = true; // This period during selection
      addtoit = true;
    end;
    FillUpAllSLIV(itemstat,frdat,todat,frtim,totim,sStartDate,sStartTime,sEndDate,sEndTime,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr,vstatussum);
    PrintIVArray(USetStr(12568),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIVVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end;
  if (aivcnt>0) then begin
    res = true;
  end;
  FillAndPrintSLIV = res;
  return;
end;

function Boolean FillAndPrintSLIP(Integer detail,Integer itemstat,Date sStartDate,Date sEndDate,Time sStartTime,Time sEndTime,string machine,string drawer,string paymode,Date frdat,Time frtim,Date todat,Time totim,var val bal,var val totin,var val totout,var Date printedd,Boolean printf,Boolean recprinter,
                                  var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,record SMVc SMr,
                                  var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot)
begin
  array string 20 aivcode;
  array string 20 aivcrncy;
  array val aivval;
  array val aivb1val;
  array val aivnr;
  array val aivoutval;
  array val aivb1outval;
  array val atipsum;
  Integer aivcnt;
  Boolean inperiod,addtoit;
  Time bltim;
  Time thetim;
  Boolean res;

  res = false;
  if ((sStartDate>frdat) and (sStartDate<todat)) then begin // Used to be sStartDate<=todat
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = false;
    addtoit = false;
    if (nonblanktime(sStartTime)) then begin
      thetim = sStartTime;
    end else begin
      thetim = frtim;
    end;
    FillUpAllSLIP(itemstat,frdat,sStartDate,frtim,thetim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up before period
    PrintIVArray(USetStr(12793),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIPVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    inperiod = true;
    addtoit = true;
    FillUpAllSLIP(itemstat,sStartDate,todat,thetim,totim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr); // Add up and print inside period
    PrintIVArray(USetStr(12793),sStartDate,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIPVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end else begin
    ClearIVArray(aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt);
    if (sStartDate>todat) then begin
      inperiod = false; // This period before selection
      addtoit = false;
    end else begin
      inperiod = true; // This period during selection
      addtoit = true;
    end;
    FillUpAllSLIP(itemstat,frdat,todat,frtim,totim,sEndDate,machine,drawer,paymode,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,detail,aitcode,aitsum,aitvat,aitqty,aitcnt,addtoit,totsum,totvat,avatcode,avatsum,avatcnt,SMr);
    PrintIVArray(USetStr(12793),frdat,machine,drawer,paymode,frdat,frtim,todat,totim,aivcode,aivcrncy,aivval,aivb1val,aivnr,aivoutval,aivb1outval,atipsum,aivcnt,bal,totin,totout,printedd,inperiod,printf,recprinter,false,detail,"DblIPVc",aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot);
  end;
  if (aivcnt>0) then begin
    res = true;
  end;
  FillAndPrintSLIP = res;
  return;
end;

global
procedure DoTheCashup(Integer detail,Integer barinv,Integer posinv,Integer slinv,Integer onrooms,Integer recpts,Integer itemstat,Date sStartDate,Date sEndDate,Time stfr,Time stto,string machine,string drawer,string pmcode,Integer typ,Boolean printf,Boolean recprinter,
                      var val bal,var val totin,var val totout,var array string aitcode,var array val aitsum,var array val aitvat,var array val aitqty,var Integer aitcnt,var val totsum,var val totvat,var array string avatcode,var array val avatsum,Integer avatcnt,var record SMVc SMr,
                      var array string aitcodetot,var array string aitcrncytot,var array val aitsumtot,var array val aitsumb1tot,var array val aitnrtot,var array val aitstartbaltot,var array val aitstartbalb1tot,var array val aitvattot,var array val aitsumb1outtot,var Integer aitcnttot,
                      var array string atrsfitcodetot,var array string atrsfitcrncytot,var array val atrsfitsumtot,var array val atrsfitsumb1tot,var array val atrsfitnrtot,var array val atrsfitstartbaltot,var array val atrsfitstartbalb1tot,var array val atrsfitvattot,var array val atrsfitsumb1outtot,var Integer atrsfitcnttot,
                      var array string aitcodesum,var array string aitcrncysum,var array val aitsumsum,var array val aitsumb1sum,var array val aitnrsum,var array val aitstartbalsum,var array val aitstartbalb1sum,var array val aitvatsum,var array val aitsumb1outsum,var Integer aitcntsum,
                      var record SMVc CountSMr,var vector val vstatussum,var Date ReportingDate)
begin
  array string 20 avcn;
  array string 20 acod;
  array Date adat;
  array Time atim;
  array LongInt aser;
  array Integer atyp;
  Date printedd;
  Integer acnt,i,ai;
  Date dfr,dto,bldat;
  Time tfr,tto,bltim;
  record CashierDefBlock CDb;
  val accsales;
  Boolean blankoutait,firstsessf;
  
  BlockLoad(CDb);
  RecordClear(SMr);
  RecordClear(CountSMr);
  SMr.TransDate = bldat;
  acnt = 0;
  bal = 0;
  totin = 0;
  totout = 0;
  dfr = sStartDate;
  dto = sEndDate;
  tfr = stfr;
  tto = stto;

// Fill up arrays, if pmcode is filled nothing is filled up, then we are only interested in actual entries
  if (detail==0) or (detail==2) then begin
    if (CDb.StartFromLastPOSBal!=0) then begin
      FindTimeOfLastPOSBalance(dfr,tfr,machine,drawer,bal,accsales);
    end;
  end;
 
  if (printf) then begin//check out !
    if (detail==0) or (detail==2) then begin
      if (CDb.StartFromLastPOSBal!=0) then begin
        if (bal==0) then begin
          tfr = AddSeconds(tfr,-1);
          FindTimeOfLastPOSBalance(dfr,tfr,machine,drawer,bal,accsales);
        end;
      end;
    end;
  end;
  
  if (blank(pmcode)) then begin
    FillUpAllCashEvents(dfr,dto,tfr,tto,machine,drawer,avcn,acod,aser,adat,atim,atyp,acnt);
    FillUpAllCashBal   (dfr,dto,tfr,tto,machine,drawer,avcn,acod,aser,adat,atim,atyp,acnt);
    FillUpAllPOSEvents (dfr,dto,tfr,tto,machine,drawer,avcn,acod,aser,adat,atim,atyp,acnt);
    FillUpAllPOSBalance(dfr,dto,tfr,tto,machine,drawer,avcn,acod,aser,adat,atim,atyp,acnt);
  end;

// I need one empty first and one last, due to some comparisons beeing made in the code
  InsertAtPos(0,"BlankLine","",-1,dfr,tfr,-1,avcn,acod,aser,adat,atim,atyp,acnt);
  InsertAtPos(acnt,"BlankLine","",-1,sEndDate,tto,-1,avcn,acod,aser,adat,atim,atyp,acnt);
  dfr = sStartDate;
  dto = sEndDate;
  tfr = stfr;
  tto = stto;

  firstsessf = true;
// Loops through arrays and print or calculate
  for (i=0;i<acnt-1;i=i+1) begin  
    switch (avcn[i]) begin
      case "POSBalanceVc":
        PrintPOSBalance(dfr,dto,tfr,tto,acod,aser,adat,atim,i,0,bal,printedd,printf,recprinter,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,SMr);
        RecordNew(CountSMr);
        blankoutait = true;
      case "POSEventVc":
/*
we need another totals per session      
        if (atyp[i]==1) then begin
          if (printf) and (firstsessf==false) then begin
            PrintTotPayModes(0,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,recprinter);
            AddToTotPayModesSum(aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,
                                aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
          end;
          firstsessf = false;
        end;
*/        
        if (atyp[i]==1) and (blankoutait) then begin

          for (ai=0;ai<aitcnttot;ai=ai+1) begin
            aitcodetot[ai] = "";
            aitcrncytot[ai] = blankval;
            aitsumtot[ai] = blankval;
            aitsumb1tot[ai] = blankval;
            aitnrtot[ai] = 0;
            aitstartbaltot[ai] = blankval;
            aitstartbalb1tot[ai] = blankval;
            aitvattot[ai] = blankval;
            aitsumb1outtot[ai] = blankval;
          end;
          aitcnttot = 0;
          blankoutait = false;
        end;
        PrintPOSEvent(dfr,dto,tfr,tto,acod,aser,adat,atim,i,0,bal,printedd,printf,recprinter);
        if (blankdate(ReportingDate)) then begin
          ReportingDate = adat[i];
        end;
      case "CashierBalVc":
        PrintCashierBal(machine,drawer,dfr,dto,tfr,tto,acod,aser,adat,atim,i,0,bal,printedd,printf,recprinter,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitvattot,aitstartbaltot,aitstartbalb1tot,aitcnttot,CountSMr);
      case "CashVc":
        PrintCashInOut(dfr,dto,tfr,tto,acod,aser,adat,atim,i,0,bal,totin,totout,printedd,printf,recprinter,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,SMr);
        RecordNew(CountSMr);
      case "BlankLine":
    end;

// Between each time frame, find invoices that can be printed between this and next position
    if (barinv) then begin
      if (FillAndPrintRestAccCash(detail,onrooms,itemstat,dfr,dto,tfr,tto,machine,drawer,pmcode,adat[i],atim[i],adat[i+1],atim[i+1],bal,totin,totout,printedd,printf,recprinter,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,atrsfitcodetot,atrsfitcrncytot,atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot,atrsfitcnttot)) then begin
        RecordNew(CountSMr);
      end;
    end;
    if (posinv) then begin
      if (FillAndPrintIVCash(detail,itemstat,dfr,dto,tfr,tto,machine,drawer,pmcode,adat[i],atim[i],adat[i+1],atim[i+1],bal,totin,totout,printedd,printf,recprinter,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,vstatussum)) then begin
        RecordNew(CountSMr);
      end;
    end;
    if (slinv) then begin
      if (FillAndPrintSLIV(detail,itemstat,dfr,dto,tfr,tto,machine,drawer,pmcode,adat[i],atim[i],adat[i+1],atim[i+1],bal,totin,totout,printedd,printf,recprinter,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,vstatussum)) then begin
        RecordNew(CountSMr);
      end;
    end;
    if (recpts) then begin
      if (FillAndPrintSLIP(detail,itemstat,dfr,dto,tfr,tto,machine,drawer,pmcode,adat[i],atim[i],adat[i+1],atim[i+1],bal,totin,totout,printedd,printf,recprinter,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot)) then begin
        RecordNew(CountSMr);
      end;
    end;
  end;
  return;
end;

function val CashDrawerOpeningsCount(record RcVc RepSpec)
begin
  val res;
  record POSJournalVc POSJr;
  Boolean found;
  string 255 index;
  Integer segs;
  
  index = "DrawerCode";
  segs = 3;
  POSJr.DrawerCode = RepSpec.f4;
  if (blank(POSJr.DrawerCode)) then begin
    index = "LocalMachineCode";
    segs = 2;
  end;
  POSJr.LocalMachineCode = RepSpec.f1;
  POSJr.Action = kPOSActionOpenDrawer;
  found = true;
  while (LoopKey(index,POSJr,segs,found)) begin
    if (POSJr.LocalMachineCode!=RepSpec.f1) then begin found = false; end;
    if (nonblank(RepSpec.f4)) then begin
      if (POSJr.DrawerCode!=RepSpec.f4) then begin found = false; end;
    end;
    if (DateInRange(POSJr.TransDate,RepSpec.sStartDate,RepSpec.sEndDate)==false) then begin
      found = false;
    end;
    if (found) then begin
      res = res + 1;
    end;
  end;
  CashDrawerOpeningsCount = res;
  return;
end;

procedure PrintCleanCashTotals(record RcVc RepSpec,vector val vcleancashstatussum,array string avatcode,array string avatname,array val avatsum)
begin
  val t1,t2;
  Integer i;
  val t;
  
  if (RepSpec.ArtMode!=0) then begin
    StartFormat(15);
    EndFormat;
  end else begin
    StartFormat(5);
    EndFormat;
  end;
  StartFormat(15);
   OutString(100,0,USetStr(18680),false);
   OutString(300,0,USetStr(18681),true);
   OutString(360,0,USetStr(18682),true);
  EndFormat;
  Gray_Divider(100,360);
  StartFormat(15);
   OutString(100,0,USetStr(18683),false);
   OutVal(300,0,vcleancashstatussum["registeredorig_count"],M40Val,true);
   OutVal(360,0,vcleancashstatussum["registeredorig_sum"],M4Val,true);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18684),false);
   OutVal(300,0,vcleancashstatussum["registeredcopy_count"],M40Val,true);
   OutVal(360,0,vcleancashstatussum["registeredcopy_sum"],M4Val,true);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18685),false);
   OutVal(300,0,vcleancashstatussum["notregistered_count"],M40Val,true);
   OutVal(360,0,vcleancashstatussum["notregistered_sum"],M4Val,true);
  EndFormat;
  StartFormat(10);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18686),false);
   OutString(300,0,USetStr(18681),true);
   OutString(360,0,USetStr(18682),true);
  EndFormat;
  Gray_Divider(100,360);
  StartFormat(15);
   OutString(100,0,USetStr(18687),false);
   OutVal(300,0,vcleancashstatussum["negativeinvoicecount"],M40Val,true);
   OutVal(360,0,vcleancashstatussum["negativeinvoicesum"],M4Val,true);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18688),false);
   OutVal(300,0,vcleancashstatussum["rebateinvoicecount"],M40Val,true);
   OutVal(360,0,vcleancashstatussum["rebateinvoicesum"],M4Val,true);
  EndFormat;
  StartFormat(10);
  EndFormat;
  t1 = vcleancashstatussum["registeredorig_sum"] + vcleancashstatussum["registeredcopy_sum"] + vcleancashstatussum["notregistered_sum"] + vcleancashstatussum["negativeinvoicesum"] + vcleancashstatussum["rebateinvoicesum"];
  StartFormat(15);
   OutString(100,0,USetStr(18689),false);
   OutVal(360,0,t1,M4Val,true);
  EndFormat;
  t2 = vcleancashstatussum["negativeinvoicesum"] + vcleancashstatussum["rebateinvoicesum"];
  StartFormat(15);
   OutString(100,0,USetStr(18690),false);
   OutVal(360,0,t2,M4Val,true);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18691),false);
   OutVal(360,0,t1-t2,M4Val,true);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18706),false);
   OutVal(300,0,CashDrawerOpeningsCount(RepSpec),M40Val,true);
  EndFormat;
  StartFormat(15);
  EndFormat;
  StartFormat(15);
   OutString(100,0,USetStr(18707),false);
   OutString(300,0,USetStr(18708),true);
   OutString(360,0,USetStr(18709),true);
  EndFormat;
  Gray_Divider(100,360);
  for (i=0;i<avatcode.length;i=i+1) begin
    if (avatsum[i]!=0) then begin
      StartFormat(15);
       GetVATproc(avatcode[i],0,t);
       OutString(100,0,avatcode[i],false);
       OutVal(300,0,t,M4Val,true);
       OutVal(360,0,avatsum[i],M4Val,true);
      EndFormat;
    end;
  end;
  return;
end;

procedure CashupRnRunHeader(record RcVc RepSpec)
begin
  Integer rw;
  string 255 tstr;
  record CYBlock CYb;
  record InternetEnablerBlock IEb;
  transaction Integer gCashupReportMode;
  
  BlockLoad(CYb);
  BlockLoad(IEb);
  switch (RepSpec.flags[29]) begin
    case 1:
      StartReportJob(USetStr(12797));
    otherwise
      StartReportJob(USetStr(12540));
  end;
  rw = 1;
  HT2Per(RepSpec.sStartDate,RepSpec.sEndDate,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (RepSpec.long1>0) then begin
    Header(rw,USetStr(12573) & " " & RepSpec.long1,0);
  end;
  switch (RepSpec.flags[29]) begin
    case 1:
      Header(rw,USetStr(12794) & ": " & CYb.OrgNr,0);
      Header(rw,USetStr(12795) & ": " & "5565924825" & "-" & "SWE" & "-" & IEb.Contract & "-" & CYb.OrgNr & "-" & RepSpec.f1,1);
      rw = rw + 1;
  end;
  if (nonblanktime(RepSpec.sStartTime)) then begin
    Header(rw,"" & Left(RepSpec.sStartTime,5) & " - " & Left(RepSpec.sEndTime,5),1);
    rw = rw + 1;
    if (nonblanktime(RepSpec.sEndTime)) then begin
      Header(rw,USetStr(12574) & " " & Left(RepSpec.sEndTime,5),0);
    end;
  end;
  Header(rw,USetStr(12541) & ": " & RepSpec.f1,1);
  rw = rw + 1;
  Header(rw,USetStr(12542) & ": " & RepSpec.f4,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f5)) then begin
    Header(rw,USetStr(12798) & ": " & RepSpec.f5,1);
    rw = rw + 1;
  end;
  if (nonblank(RepSpec.FirstAcc)) then begin
    Header(rw,USetStr(12799) & ": " & RepSpec.FirstAcc,1);
    rw = rw + 1;
  end;
  EndHeader;
  SetRepCol(2,80);
  SetRepCol(5,150);
  SetRepCol(3,160);
  SetRepCol(4,240);
  SetRepColBiDi(7,270,310);
  SetRepColBiDi(8,340,380);
  SetRepColBidi(9,410,450);
  StartFormat(15);
  OutString(0,0,USetStr(12546),false);
  OutString(2,0,USetStr(12562),false);
  OutString(5,0,USetStr(12561),false);
  if (RepSpec.ArtMode==0) then begin
    switch (gCashupReportMode) begin
      case kCashupReportCleanCash:
        OutString(260,0,USetStr(12796),true);
    end;
  end else begin
    switch (gCashupReportMode) begin
      case kCashupReportCleanCash:
        OutString(215,0,USetStr(18695),false);
    end;
  end;
  OutStringAdjust(8,0,USetStr(12554),true,M4Val);
  OutStringAdjust(9,0,USetStr(12555),true,M4Val);
  OutStringAdjustBidi(1,0,USetStr(12560),true,M4Val,510);
  EndFormat;
  Gray_Divider(0,1);
  return;
end;

procedure CashupRnRunExecute(record RcVc RepSpec,Boolean recprinter,
                             var array string aitcodesum,var array string aitcrncysum,var array val aitsumsum,var array val aitsumb1sum,var array val aitnrsum,
                             var array val aitstartbalsum,var array val aitstartbalb1sum,var array val aitvatsum,var array val aitsumb1outsum,var Integer aitcntsum)
begin
  val bal,totin,totout,totqty;
  Integer rw;
  string 255 tstr;
  array string 20 aitcode;
  array string 200 aitname;
  array val aitsum;
  array val aitvat;
  array val aitqty;
  array string 20 avatcode;
  array string 200 avatname;
  array val avatsum;
  val totsum,totvat;
  Integer i,aitcnt,avatcnt;
  record ITVc ITr;
  record VATCodeBlock VATCodeBlockr;
  row VATCodeBlock VATCodeBlockrw;
  record SMVc SMr;
  record TRVc TRr;
  record TRVc TR2r;
  record POSBalanceVc POSBalancer;
  record SMVc CountSMr;
  LongInt serno;
  Boolean bookf,onebook;
  array string 20 aitcodetot;
  array string 20 aitcrncytot;
  array val aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot;
  Integer aitcnttot;
  array string 20 atrsfitcodetot;
  array string 20 atrsfitcrncytot;
  array val atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot;
  Integer atrsfitcnttot;
  record INVc INr;
  transaction Integer gCashupReportMode;
  vector val vcleancashstatussum;
  val t1,t2,a_sumval,a_sumvat;
  Date ReportingDate;
  record AccBlock ARAccb;
 
  totsum = 0;
  totvat = 0;
  aitcnt = 0;
  if (RepSpec.flags[7]==0) then begin
    while(LoopMain(ITr,1,true)) begin
      aitcode[aitcnt] = ITr.Code;    
      aitname[aitcnt] = ITr.Comment;
      aitcnt = aitcnt + 1;
    end;
    aitcode[aitcnt] = "";    
    aitname[aitcnt] = USetStr(12534);
    aitcnt = aitcnt + 1;
  end;
  BlockLoad(VATCodeBlockr);
  BlockLoad(ARAccb);
  avatcnt = MatRowCnt(VATCodeBlockr);
  for(i=0; i<avatcnt; i=i+1) begin
    MatRowGet(VATCodeBlockr,i,VATCodeBlockrw);
    avatcode[i] = VATCodeBlockrw.VATCode;
    avatname[i] = VATCodeBlockrw.Comment;
  end;
  DoTheCashup(RepSpec.ArtMode,RepSpec.flags[1],RepSpec.flags[2],RepSpec.flags[3],RepSpec.flags[4],RepSpec.flags[8],RepSpec.flags[7],RepSpec.sStartDate,RepSpec.sEndDate,RepSpec.sStartTime,RepSpec.sEndTime,
              RepSpec.f1,RepSpec.f4,RepSpec.f5,0,true,recprinter,bal,totin,totout,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,
              aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,
              atrsfitcodetot,atrsfitcrncytot,atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot,atrsfitcnttot,
              aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum,
              CountSMr,vcleancashstatussum,ReportingDate);
  switch (gCashupReportMode) begin
    case kCashupReportCleanCash:
      PrintCleanCashTotals(RepSpec,vcleancashstatussum,avatcode,avatname,avatsum);
  end;
  if (recprinter==false) then begin
    if (RepSpec.ArtMode!=2) then begin
/*    
we need another totals per session      
      PrintTotPayModes(0,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,recprinter);

      AddToTotPayModesSum(aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,
                          aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
*/                        
      Black_Divider(0,1);
      StartFormat(15);
      OutString(0,0,USetStr(12552),false);
      OutVal(8,0,totin,M4Val,true);
      OutVal(9,0,totout,M4Val,true);
      if (RepSpec.ArtMode==0) then begin
        OutStringIDAdjustBiDi(1,"DblCreatePOSBal",bal,true,RepSpec.f1 & ":" & RepSpec.f4,M4Val,510);
      end else begin
        OutStringAdjustBiDi(1,0,bal,true,M4Val,510);
      end;
      EndFormat;
      if (blank(RepSpec.f5)) then begin
        StartFormat(15);
        if (IsSessionOpen(RepSpec.f1,RepSpec.f4,CurrentDate,CurrentTime)==false) then begin
          OutStringID(0,"DblOpenSess",USetStr(12565),false,RepSpec.f1 & ":" & RepSpec.f4);
        end else begin
          OutStringID(0,"DblCloseSess",USetStr(12564),false,RepSpec.f1 & ":" & RepSpec.f4);
        end;
        EndFormat;
      end;
      switch (gCashupReportMode) begin
        case 0:
          if (RepSpec.ArtMode==0) then begin
            StartFormat(15);
            EndFormat;
            StartFormat(15);
            if (RepSpec.flags[7]==0) then begin  
              OutString(0,0,USetStr(9776),false);
            end else begin
              OutString(0,0,USetStr(9788),false);
            end;
            OutString(70,0,USetStr(9778),false);
            OutStringAdjustBiDi(300,0,USetStr(12535),true,M4Val,340);
            OutStringAdjustBiDi(400,0,USetStr(12570),true,M4Val,420);
            OutStringAdjustBiDi(1,0,USetStr(12571),true,M4Val,510);
            EndFormat;
            Gray_Divider(0,1);
            for (i=0;i<aitcnt;i=i+1) begin
              if (aitsum[i]!=0) then begin
                StartFormat(15);
                if (aitcode[i]=="GV-SOLD") then begin
                  OutString(70,0,USetStr(24607),false);
                end else begin
                  OutString(0,0,aitcode[i],false);
                  if (RepSpec.flags[7]==0) then begin  
                    OutString(70,0,aitname[i],false);      
                  end else begin
                    INr.Code = aitcode[i];
                    ReadFirstMain(INr,1,true);
                    OutString(70,0,INr.Name,false);      
                  end;
                end;
                OutValBiDi(300,0,aitqty[i],M4Val,true,340);
                OutValBiDi(400,0,aitsum[i]+aitvat[i],M4Val,true,420);
                OutValBiDI(1,0,aitvat[i],M4Val,true,510); 
                EndFormat;
                totqty = totqty + aitqty[i];
                a_sumval = a_sumval + aitsum[i] + aitvat[i];
                a_sumvat = a_sumvat + aitvat[i];
              end;
            end;
            if (a_sumval!=(totsum+totvat)) then begin  // Display as Rounding off
              StartFormat(15);
              OutString(0,0,USetStr(18705),false);
              OutValBiDi(400,0,((totsum+totvat)-a_sumval),M4Val,true,420);
              OutValBiDI(1,0,(totvat-a_sumvat),M4Val,true,510); 
              EndFormat; 
            end;
            Gray_Divider(0,1);
            StartFormat(15);
            OutString(0,0,USetStr(12551),false);
            OutString(70,0,"",false);      
            OutValBiDi(300,0,totqty,M4Val,true,340);
            OutValBiDi(400,0,totsum+totvat,M4Val,true,420);
            OutValBiDi(1,0,totvat,M4Val,true,510); 
            EndFormat;          
            StartFormat(15);
            EndFormat;
            StartFormat(15);
            OutString(0,0,USetStr(12570),false);
            OutVal(200,0,totsum+totvat,M4Val,true);  
            EndFormat;
            for(i=0; i<avatcnt; i=i+1) begin
              if(avatsum[i] > 0) then begin
                StartFormat(15);
                OutString(0,0,USetStr(12551) & " " & avatname[i],false);
                OutVal(200,0,avatsum[i],M4Val,true);  
                EndFormat;
              end;
            end;
            StartFormat(15);
            OutString(0,0,USetStr(12572),false);
            OutVal(200,0,totvat,M4Val,true);  
            EndFormat;
          end;
          i = 0;
          serno = -1;
          if (RepSpec.flags[5]!=0) and (RepSpec.ArtMode==0) then begin
            PreparePOSSM(SMr);
            SMSumup(SMr);
            
            StartFormat(15);
            EndFormat;
            StartFormat(15);
            OutString(0,0,USetStr(12580),false);
            EndFormat;
            Black_Divider(0,1);
            while (BuildPOSTRFromSM(SMr,TRr,i,serno,bookf,POSBalancer)) begin
              TRr.IntYc = RestAccYc;
              if (POSBalancer.SerNr>0) then begin
                TRr.Number = POSBalancer.SerNr;
              end else begin
                ReadLastMain(TR2r,1,true);
              end;
              TRr.Number = TR2r.Number + 1;
              if (TRr.Number<=0) then begin
                TRr.Number = 1;
              end;
              TRSumup(TRr,t1);
              PrintTRRecord(TRr,0);
              onebook = true;
            end;
/*            
            if (MatRowCnt(SMr)>0) then begin
              StartFormat(15);
              EndFormat;
              StartFormat(15);
              OutString(0,0,USetStr(12580),false);
              EndFormat;
              Black_Divider(0,1);
              PrintSMRecord(SMr,0);
              onebook = true;
            end;
*/            
          end;
      end;
    end;
    
/*
StartFormat(15);
OutString(0,0,"XXXXXXXXXXXXXXXXXXXXXXXXXXX",false);
EndFormat;
PrintSMRecord(CountSMr,0);
StartFormat(15);
OutString(0,0,"XXXXXXXXXXXXXXXXXXXXXXXXXXX",false);
EndFormat;
*/
/*
    if (RepSpec.flags[6]!=0) then begin
      onebook = false;
      while (BuildPOSTRFromSM(SMr,TRr,i,serno,bookf,POSBalancer)) begin
        if (bookf) then begin
          StartFormat(15);
          EndFormat;
          StartFormat(15);
          OutString(0,0,USetStr(12581),false);
          EndFormat;
          Black_Divider(0,1);
          TRSumup(TRr,t1);
          PrintTRRecord(TRr,0);
          onebook = true;
        end;
      end;
    end;
*/
    if (RepSpec.ArtMode==0) then begin
      PrintTotPayModes(RepSpec.ArtMode,aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,recprinter);
    end;
    AddToTotPayModesSum(aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,
                        aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
    if (RepSpec.ArtMode!=2) then begin
      if (recprinter==false) then begin
        StartFormat(15);
        EndFormat;
        StartFormat(15);
        OutString(0,0,USetStr(12583),false);
        EndFormat;
      end;
    end;
  end;
  return;
end;

procedure CashupRnRun(record RcVc RepSpec,Boolean recprinter)
begin
  transaction Integer gCashupReportMode;
  array string 20 aitcodesum;
  array string 20 aitcrncysum;
  array val aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum;
  Integer aitcntsum;
  record LocalMachineVc LMr;
  Boolean foundlm;
  string 255 frlm,tolm;
  record DrawerVc Drawerr;
  Boolean founddr,printedf;
  string 255 frdr,todr;

  gCashupReportMode = RepSpec.flags[29];
  if (recprinter==false) then begin
    CashupRnRunHeader(RepSpec);
  end;
  frlm = FirstInRange(RepSpec.f1,10);
  tolm = LastInRange(RepSpec.f1,10);
  frdr = FirstInRange(RepSpec.f4,10);
  todr = LastInRange(RepSpec.f4,10);
  
  if (RecordsInIndex("LocalMachineVc","Code")==0) then begin
    CashupRnRunExecute(RepSpec,recprinter,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
  end else begin
    foundlm = true;
    LMr.Code = frlm;
    while (LoopMain(LMr,1,foundlm)) begin
      if (LMr.Code>tolm) then begin
        foundlm = false;
      end;
      if (foundlm) then begin
        ResetLoop(Drawerr);
        founddr = true;
        Drawerr.Code = frdr;
        while (LoopMain(Drawerr,1,founddr)) begin
          if (Drawerr.Code>todr) then begin
            founddr = false;
          end;
          if (founddr) then begin
            RepSpec.f1 = LMr.Code;
            RepSpec.f4 = Drawerr.Code;
            CashupRnRunExecute(RepSpec,recprinter,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
            printedf = true;
          end;
        end;
      end;
    end;
    if (frlm==tolm) and (frdr==todr) and (printedf==false) then begin
//old way when Local Machine code is not existsing in Local Machines register
      CashupRnRunExecute(RepSpec,recprinter,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
    end;
  end;

  if (recprinter==false) then begin
    if (RepSpec.ArtMode==0) then begin
      PrintTotPayModes(RepSpec.ArtMode,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum,recprinter);
    end;
    EndJob;
  end;
  return;
end;

global
procedure NIghtAuditCashupRn(record RcVc orgRepSpec,string localmachines)
begin
  transaction Integer gCashupReportMode;
  array string 20 aitcodesum;
  array string 20 aitcrncysum;
  array val aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum;
  Integer aitcntsum;
  string 255 frlm,tolm;
  record DrawerVc Drawerr;
  Boolean founddr;
  string 255 frdr,todr;
  string 255 lm;
  Integer pos;
  record RcVc RepSpec;

  RepSpec.sStartDate = orgRepSpec.sStartDate;
  RepSpec.sEndDate = RepSpec.sStartDate;
  RepSpec.ArtMode = 2;
  RepSpec.flags[1] = 1;
  RepSpec.flags[2] = 1;
  RepSpec.flags[3] = 1;
  RepSpec.flags[4] = 1;
  RepSpec.flags[7] = 0;
  RepSpec.flags[8] = 1;
//  RepSpec.sStartTime = 
//  RepSpec.sEndTime = 
  RepSpec.f5 = "";

  gCashupReportMode = kCashupReportStd;
  SetRepCol(2,80);
  SetRepCol(5,150);
  SetRepCol(3,160);
  SetRepCol(4,240);
  SetRepCol(7,270);
  SetRepCol(8,340);
  SetRepCol(9,410);

  pos = 0;
  ExtractObj(localmachines,pos,lm);
  while (nonblank(lm)) begin
    ResetLoop(Drawerr);
    founddr = true;
    Drawerr.Code = "";
    while (LoopMain(Drawerr,1,founddr)) begin
      if (founddr) then begin
        RepSpec.f1 = lm;
        RepSpec.f4 = Drawerr.Code;        
        CashupRnRunExecute(RepSpec,false,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum);
      end;
    end;
    ExtractObj(localmachines,pos,lm);
  end;
  
  PrintTotPayModes(RepSpec.ArtMode,aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum,false);
  return;
end;

global
procedure CashupRn(record RcVc RepSpec)
BEGIN
  CashupRnRun(RepSpec,false);
  RETURN;
END;

global
procedure CashupPOSRn(record RcVc RepSpec)
BEGIN
  CashupRnRun(RepSpec,true);
  RETURN;
END;

function Boolean MakePOSTRFromSM(record SMVc SMr,var record TRVc TRr,var record POSBalanceVc POSBalancer)
begin
  row SMVc SMrw;
  row TRVc TRrw;
  Integer rwcnt,i;
  val s,totsum;
  string 255 tstr;
  Boolean debf;
  Boolean res;
  val temp,baserate1,baserate2;
  string 10 curncy;
  Boolean bookf;
  record RestBlock Restb;
  
  res = false;
  BlockLoad(Restb);
  RecordNew(TRr);
  TRr.TransDate = POSBalancer.TransDate;
  if (Restb.UseReportingDateforNL!=0) then begin
    if (nonblankdate(POSBalancer.ReportingDate)) then begin
      TRr.TransDate = POSBalancer.ReportingDate;
    end;
  end;
  curncy = "";
  GetFullCurncyRate(curncy,TRr.TransDate,temp,temp,temp,baserate1,baserate2);
  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (SMrw.AccNumber=="BALANCE") then begin
      TRr.TransDate = SMrw.TransDate; // Exchange Rate Date
      if (Restb.UseReportingDateforNL!=0) then begin
        if (nonblankdate(POSBalancer.ReportingDate)) then begin
          TRr.TransDate = POSBalancer.ReportingDate;
        end;
      end;
      TRr.Comment = USetStr (2298) & " " & SMrw.Comment;
      if (TRr.TransDate!=SMrw.TransDate) then begin
        TRr.Comment = TRr.Comment & ",  ";
        TRr.Comment = TRr.Comment & TRr.TransDate;
        TRr.Comment = TRr.Comment & " : " & SMrw.TransDate;
      end;
      if (POSBalancer.SerNr==StringToLongInt(SMrw.Comment)) then begin
        bookf = true;
      end;
    end;
  end;
  res = false;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (SMrw.AccNumber=="BALANCE") then begin
      if (POSBalancer.SerNr!=StringToLongInt(SMrw.Comment)) then begin //##
      end;
    end else begin
      if (GetAccName(SMrw.AccNumber,tstr,60)==false) then begin end;
      if (SMrw.DebVal!=0) then begin
        s = SMrw.DebVal;
        debf = true;
      end else begin
        s = SMrw.CredVal;
        debf = false;      
      end;
      AddEuroTrRow(TRr,SMrw.AccNumber,SMrw.Objects,SMrw.VATCode,tstr,s,baserate1,baserate2,true,debf,totsum,false,"","","");
      res = true;
    end;
  end;
LMakePOSTRFromSM:;
  MakePOSTRFromSM = res;
  return;
end;

global
function Integer MakeTransFromPOSBalance(var record TRVc gTRp,record POSBalanceVc POSBalancer,Boolean rpt)
begin
  Integer res;
  val t1,totin,totout;
  array string 20 aitcode;
  array val aitsum;
  array val aitvat;
  array val aitqty;
  array string 20 avatcode;
  array val avatsum;
  val totsum,totvat,avatcnt;
  Integer aitcnt;
  record SMVc SMr;
  array string 20 aitcodetot;
  array string 20 aitcrncytot;
  array val aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot;
  Integer aitcnttot;

  array string 20 aitcodesum;
  array string 20 aitcrncysum;
  array val aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum;
  Integer aitcntsum;
  array string 20 atrsfitcodetot;
  array string 20 atrsfitcrncytot;
  array val atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot;
  Integer atrsfitcnttot;
  Date ReportingDate;

  record VATCodeBlock VATCodeBlockr;
  row VATCodeBlock VATCodeBlockrw;
  record ITVc ITr;
  record SMVc CountSMr;
  Integer i;
  val bal,accsales;
  Date d;
  Time t;
  vector val vstatussum;

  totsum = 0;
  totvat = 0;
  aitcnt = 0;
  res = 0;
  d = POSBalancer.TransDate;
  t = AddMinutes(POSBalancer.TransTime,-1);
  if (TransInFiscal(d)==false) then begin
    res = 1075;
    goto LMakeTransFromPOSBalance;
  end;
  FindTimeOfLastPOSBalance(d,t,POSBalancer.MachineName,POSBalancer.Drawer,bal,accsales);
/*
  while(LoopMain(ITr,1,true)) begin
    aitcode[aitcnt] = ITr.Code;    
    aitcnt = aitcnt + 1;
  end;
  BlockLoad(VATCodeBlockr);
  avatcnt = MatRowCnt(VATCodeBlockr);
  for(i=0; i<avatcnt; i=i+1) begin
    MatRowGet(VATCodeBlockr,i,VATCodeBlockrw);
    avatcode[i] = VATCodeBlockrw.VATCode;
  end;
*/
  DoTheCashup(0,1,1,0,0,1,0,d,POSBalancer.TransDate,t,POSBalancer.TransTime,POSBalancer.MachineName,POSBalancer.Drawer,"",0,false,false,t1,totin,totout,aitcode,aitsum,aitvat,aitqty,aitcnt,totsum,totvat,avatcode,avatsum,avatcnt,SMr,
              aitcodetot,aitcrncytot,aitsumtot,aitsumb1tot,aitnrtot,aitstartbaltot,aitstartbalb1tot,aitvattot,aitsumb1outtot,aitcnttot,
              atrsfitcodetot,atrsfitcrncytot,atrsfitsumtot,atrsfitsumb1tot,atrsfitnrtot,atrsfitstartbaltot,atrsfitstartbalb1tot,atrsfitvattot,atrsfitsumb1outtot,atrsfitcnttot,
              aitcodesum,aitcrncysum,aitsumsum,aitsumb1sum,aitnrsum,aitstartbalsum,aitstartbalb1sum,aitvatsum,aitsumb1outsum,aitcntsum,
              CountSMr,vstatussum,ReportingDate);
  if (rpt==false) then begin
    if (MakePOSTRFromSM(SMr,gTRp,POSBalancer)) then begin
      gTRp.IntYc = RestAccYc;
      gTRp.Number = POSBalancer.SerNr;
      if (CheckTrans(gTRp,2,false)=="") then begin end;
      if (MatRowCnt(gTRp)>0) then begin
        res = 0;
      end;
    end;
  end;
LMakeTransFromPOSBalance:;  
  MakeTransFromPOSBalance = res;
  return;
end;

global
procedure FDSeqNrDetailsRn(record RcVc RepSpec)
begin
  Integer rw;
  string 255 tstr;
  record CYBlock CYb;
  record InternetEnablerBlock IEb;
  record IVVc IVr;
  record IVCashVc IVCashr;
 
  BlockLoad(CYb);
  BlockLoad(IEb);
  StartReportJob(USetStr(18704));
  rw = 2;
  Header(rw,USetStr(12794) & ": " & CYb.OrgNr,0);
  Header(rw,USetStr(12795) & ": " & "5565924825" & "-" & "SWE" & "-" & IEb.Contract & "-" & CYb.OrgNr & "-" & RepSpec.f1,1);
  rw = rw + 1;
  Header(rw,USetStr(12541) & ": " & RepSpec.f1,1);
  rw = rw + 1;
  EndHeader;
  if (RepSpec.AccStr==USetStr(12566)) then begin
    IVCashr.SerNr = RepSpec.long1;
    if (ReadFirstMain(IVCashr,1,true)) then begin
      StartFormat(15);
       OutString(0,0,USetStr(18696) & ":",false);
       OutString(100,0,USetStr(18703),false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18697) & ":",false);
       OutString(100,0,IVCashr.SerNr,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18698) & ":",false);
       OutString(100,0,IVCashr.FiscalDeviceSeqNr,false);
      EndFormat;
      StartFormat(15);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18699) & ":",false);
       OutString(100,0,IVCashr.OfficialSerNr,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18700) & ":",false);
       OutString(100,0,IVCashr.OfficialSerNr2,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18701) & ":",false);
       OutString(100,0,IVCashr.TerminalID,false);
      EndFormat;
    end;
  end;
  if (RepSpec.AccStr==USetStr(12568)) then begin
    IVr.SerNr = RepSpec.long1;
    if (ReadFirstMain(IVr,1,true)) then begin
      StartFormat(15);
       OutString(0,0,USetStr(18696) & ":",false);
       OutString(100,0,USetStr(18702),false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18697) & ":",false);
       OutString(100,0,IVr.SerNr,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18698) & ":",false);
       OutString(100,0,IVr.FiscalDeviceSeqNr,false);
      EndFormat;
      StartFormat(15);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18699) & ":",false);
       OutString(100,0,IVr.OfficialSerNr,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18700) & ":",false);
       OutString(100,0,IVr.OfficialSerNr2,false);
      EndFormat;
      StartFormat(15);
       OutString(0,0,USetStr(18701) & ":",false);
       OutString(100,0,IVr.TerminalID,false);
      EndFormat;
    end;
  end;
  EndJob;
  return;
end;
