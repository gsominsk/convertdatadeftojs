external function string 255 HTProds(LongInt, LongInt);
external function string 255 HTProdOperations(LongInt, LongInt);
external procedure HTDetailLevel(Integer, var string);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Integer Nr_SequenceProdOperations(record ProdOperationVc);
external function Time TimeDiff(Time,Time);
external function LongInt DateDiff(Date,Date);
external function LongInt TimeToMinutes(Time);

function val ProducedQty(record ProdOperationVc curProdOpr)
begin
  val res;  
  record ProdOperationVc ProdOpr;
  Boolean found;

  found = true;
  ProdOpr.Sequence = curProdOpr.Sequence - 1;
	ProdOpr.ProdNr = curProdOpr.ProdNr;
	ProdOpr.PRStatusFlag = 3;
	while (LoopKey("Sequence",ProdOpr,3,found)) begin
	  if (ProdOpr.Sequence!=(curProdOpr.Sequence-1)) then begin found = false; end;
	  if (ProdOpr.ProdNr!=curProdOpr.ProdNr) then begin found = false; end;
	  if (ProdOpr.PRStatusFlag!=3) then begin found = false; end;
	  if (found) then begin
  	  if (ProdOpr.SerNr!=curProdOpr.SerNr) then begin
  	    res = res + ProdOpr.ActualQty;
  	  end;
	  end;
	end;

  ProducedQty = res;
  return;
end;

procedure PrintOperation(record RcVc RepSpec,record ProdOperationVc ProdOpr,Integer cursequenceoperations,
                         var string finalitem)
begin
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  val totincost;
  LongInt days;
  Time t;
  string 20 item;
  Boolean outf;
  val inq,outq,outcost;
  string 255 tstr;
  record INVc INr;
  val inqlowerlevel;
    
  outf = true;
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
	  if (ProdOprw.OutQty!=0) then begin
	    item = ProdOprw.Item;
	    outf = true;
	    if (blank(finalitem)) then begin
	      finalitem = item;
	    end;
//	    outq = outq + ProdOprw.OutQty;
	  end;
  end;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
  	if (ProdOprw.InQty!=0) then begin
      if (blank(item)) then begin
	      item = ProdOprw.Item;
	      outf = false;
	    end;
	    if (ReadFIrstItem(ProdOprw.Item,INr,false,false)) then begin end;
	    if (INr.ItemType==0) then begin
  	    inq = inq + ProdOprw.InQty;
  	  end;
      totincost = totincost + ProdOprw.ItemCost;
      switch (ProdOpr.RowsHoldActualQty) begin
        case 1: outcost = outcost + ProdOprw.InQty*ProdOprw.ItemCost;
        otherwise 
          outcost = outcost + ProdOprw.InQty*ProdOprw.ItemCost*ProdOpr.Qty;
	    end;
    end;
  end;
  if (blank(item)) then begin
    item = finalitem;
  end;
  switch (ProdOpr.PRStatusFlag) begin
    case 3:
      days = DateDiff(ProdOpr.EndDate,ProdOpr.StartDate);
      t = TimeDiff(ProdOpr.EndTime,ProdOpr.StartTime);
      inqlowerlevel = ProducedQty(ProdOpr);
    otherwise
      days = ProdOpr.PlanDurDays;
      t = ProdOpr.PlanDurTime;
  end;
  if (cursequenceoperations>1) then begin
    outf = false;
  end;
  if (inqlowerlevel==0) then begin
    inqlowerlevel = ProdOpr.Qty;
  end;  
	StartFormat(15);
   OutStringID(0,"DblProdOperationVc",ProdOpr.Comment,false,ProdOpr.SerNr);
   tstr = ProdOpr.Sequence;
   if (ProdOpr.SubSequence>0) then begin
     tstr = tstr & "." & ProdOpr.SubSequence;
   end;
   OutString(200,0,tstr,false);
   OutString(260,0,USetStr(16410 + ProdOpr.PRStatusFlag),false);   
   if (RepSpec.ArtMode==0) then begin
     OutVal(360,0,inqlowerlevel,M4Val,true);
     OutVal(420,0,ProdOpr.ActualQty,M4Val,true);
     OutVal(480,0,outcost,M4Val,true);
   end;
	EndFormat;
  if (RepSpec.ArtMode==1) then begin
	  StartFormat(15);
	   OutString(15,0,USetStr(16458),false);
	   OutString(100,0,USetStr(16459),false);
	   OutString(260,0,USetStr(16454),true);
	   OutString(320,0,USetStr(16455),true);
	  EndFormat;
	  Gray_Divider(0,1);  
    rwcnt = MatRowCnt(ProdOpr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ProdOpr,i,ProdOprw);
      StartFormat(15);
       OutString(15,0,ProdOprw.Item,false);
       OutString(100,0,ProdOprw.Comment,false);
       OutVal(260,0,ProdOprw.InQty,M4Val,true);
       OutVal(320,0,ProdOprw.OutQty,M4Val,true);
      EndFormat;
    end;
  end;
  Gray_Divider(0,1);
  return;
end;

global
procedure PrintOperations(record RcVc RepSpec,record ProdVc Prodr)
begin
  record ProdOperationVc ProdOpr;
  Boolean found;
  string 255 finalitem;
  Integer cursequenceoperations;
  
  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.Sequence = 1;
//  ProdOpr.SubSequence = -1;
  found = true;
  while (LoopKey("ProdNrSeq",ProdOpr,2,found)) begin
    if (ProdOpr.ProdNr!=Prodr.SerNr) then begin found = false; end;
    if (found) then begin
      cursequenceoperations = Nr_SequenceProdOperations(ProdOpr);
      PrintOperation(RepSpec,ProdOpr,cursequenceoperations,finalitem);
    end;
  end;
  Black_Divider(0,1);
  return;
end;

procedure PrintStockMovement(record RcVc RepSpec,record StockMovVc StockMovr,var Boolean headerf)
begin
  row StockMovVc StockMovrw;
    
  if (headerf) then begin
    StartFormat(15);
     OutString(0,0,USetStr(30064),false);
	  EndFormat;
    headerf = false;
  end;
	StartFormat(15);
   OutString(0,"DblStockMovVc",StockMovr.SerNr,false);
   OutString(100,0,StockMovr.Comment,false);
	EndFormat;
  return;
end;

procedure PrintStockMovements(record RcVc RepSpec,record ProdVc Prodr)
begin
  record StockMovVc StockMovr;
  Boolean found,headerf;
  
  headerf = true;
  StockMovr.ProdSerNr = Prodr.SerNr;
  found = true;
  while (LoopKey("ProdSerNr",StockMovr,1,found)) begin
    if (StockMovr.ProdSerNr!=Prodr.SerNr) then begin found = false; end;
    if (found) then begin
      PrintStockMovement(RepSpec,StockMovr,headerf);
    end;
  end;
  if (headerf==false) then begin
    Black_Divider(0,1);
  end;
  return;
end;

procedure ProdStatusHeader(record RcVc RepSpec,LongInt frprod,LongInt toprod)
begin
  Integer rw;
  string 255 tstr;
  
  rw = 1;
  Header(rw,HTProds(frprod,toprod),1);
  rw = rw + 1;
  HTDetailLevel(RepSpec.ArtMode,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (RepSpec.flags[0]!=0) then begin
    Header(rw,USetStr(16457),1);
    rw = rw + 1;
  end;  
  return;
end;

global
procedure ProdStatusRn(record RcVc RepSpec)
begin
  record ProdVc Prodr;
  Boolean testf,found;
  LongInt frp,top;
  LongInt lastprod;
    
  frp = FIrstInRange(RepSpec.f1,10);
  top = LastInRange(RepSpec.f1,10);
  StartReportJob(USetStr(16450));
   ProdStatusHeader(RepSpec,frp,top);
  EndHeader;
  if (RepSpec.ArtMode==0) then begin
	  StartFormat(15);
	   OutString(0,0,USetStr(16451),false);
	   OutString(200,0,USetStr(16452),false);
	   OutString(260,0,USetStr(16453),false);
	   OutString(360,0,USetStr(16454),true);
	   OutString(420,0,USetStr(16455),true);
	   OutString(480,0,USetStr(16456),true);
	  EndFormat;
	end else begin
	  StartFormat(15);
	   OutString(0,0,USetStr(16451),false);
	   OutString(200,0,USetStr(16452),false);
	   OutString(260,0,USetStr(16453),false);
	  EndFormat;
	end;	
  Gray_Divider(0,1);
  found = true;
  Prodr.SerNr = frp;
  while (LoopMain(Prodr,1,found)) begin
    if (nonblank(RepSpec.f1)) then begin
      if (Prodr.SerNr>top) then begin found = false; end;
    end;
    if (found) then begin
	    testf = true;
	    if (RepSpec.flags[0]!=0) then begin
	      if (Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==4) or (Prodr.PRStatusFlag==5) then begin
	        testf = false;
	      end;
	    end;
	    if (testf) then begin
		    if (lastprod!=Prodr.SerNr) then begin
		      StartFormat(15);
		       OutStringID(0,"DblProdVcID",USetStr(16463) & " " & Prodr.SerNr,false,Prodr.SerNr);
		   	   OutString(420,0,USetStr(16410+Prodr.PRStatusFlag),false);
		      EndFormat;
		      Gray_Divider(0,1);
		    end;
	      PrintOperations(RepSpec,Prodr);
	      PrintStockMovements(RepSpec,Prodr);
        lastprod = Prodr.SerNr;
	    end;
	  end;
  end;
  EndJob;
  return;
end;