external procedure HTItem(string,var string);
external procedure HTArtGroup(string, var string);
external procedure HTItemClass(string,var string);
external function Boolean HasItemClassification();
external function Boolean HasItemGroups();
external function Boolean ItemInItemGroupOrClass(string,string,string);
external function Boolean HasContactClassification();
external function Boolean HasCategories();
external procedure HTCustCat(string,var string);
external procedure HTCustClass(string,var string);
external function Boolean ContactInGroupClass(string,string,string,string,string,string);
external function Boolean FindProjContractSales(string,string,Date,Date,var record SMVc,var val,var val,var val,var val,
                                                var val,var val,var val,var val);
external procedure HTDetailLevel(Integer, var string);
external procedure HTCusts(string, string, var string);
external procedure HTProjects(string,string,var string);
external procedure FindInvoiceMethod(LongInt,string,string,string,var val,Date,Integer,var record TBBUVc,var Integer,var val,
                                     val,var val,val,var val,val,var val,val,var val,var string,Boolean);
external procedure HTPRClass(string,var string);
external procedure HTInvInvable(Integer,Integer,var string);
external procedure HTProjSort(Integer,var string);

procedure AddCurncyTotals(string curncy,val income,array string acur,vector val v,var Integer acurcnt)
begin
  Integer i;
  string 255 lcurncy;  
  record BaseCurBlock BCb;
  
  lcurncy = curncy;
  if (blank(lcurncy)) then begin
    BlockLoad(BCb);
    lcurncy = BCb.BaseCur1;
  end;
  for (i=0;i<acurcnt;i=i+1) begin
    if (lcurncy==acur[i]) then begin
      v[lcurncy] = v[lcurncy] + income;
      goto LAddCurncyTotals;
    end;
  end;
  v[lcurncy] = v[lcurncy] + income;
  acur[acurcnt] = lcurncy;
  acurcnt = acurcnt + 1;
LAddCurncyTotals:;  
  return;
end;

procedure PrintCurncyTotals(Integer details,array string acur,vector val vtottsum,vector val vtottcost,Integer acurcnt)
begin
  Integer i;
  val t;
  Integer p0,p1,p2,p3;
  
  if (details==0) then begin
    p0 = 230;
    p1 = 330;
    p2 = 420;
    p3 = 480;
  end else begin
    p0 = 200;
    p1 = 300;
    p2 = 400;
    p3 = 460;
  end;
  for (i=0;i<acurcnt;i=i+1) begin
    StartFormat(15);
     OutString(p0,0,acur[i],false);

     OutVal(p1,0,vtottsum[acur[i]],M4Val,true);
     OutVal(p2,0,vtottcost[acur[i]],M4Val,true);

     t = vtottcost[acur[i]] * 100;
     t = t / vtottsum[acur[i]];
     OutVal(p3,0,t,M4Prcnt,true);

    EndFormat;
  end;
  return;
end;

Function Boolean IsArtType(string item,Integer type)
begin
  record INVc INr;
  Boolean res;
  
  res = false;
  INr.Code = item;
  if (ReadFirstMain(INr,1,true)) then begin
    if (item==INr.Code) then begin
      if (type==1) then begin
        if (INr.ItemType==3) then begin res = true; end;
      end;
      if (type==2) then begin
        if ((INr.ItemType==0) and (INr.ItemMaterial==0)) then begin res = true; end;
      end;
      if (type==3) then begin
        if ((INr.ItemType == 0) and (INr.ItemMaterial <>0)) then begin res = true; end;
      end;
      if (type==4) then begin
        if (INr.ItemType==1) then begin res = true; end; //vg
      end;
    end;
  end;
  IsArtType = res;
  return;
end;

procedure FixedPriceBudget(string prcode,var val budp,Integer type)
begin
  row TBBUVc TBBUrw;
  record TBBUVc TBBUr;
  Integer rwcnt,i;
  Boolean testf;

  budp = BlankVal;
  TBBUr.PRCode = prcode;
  if (ReadFirstMain(TBBUr,1,true)) then begin
    rwcnt = MatRowCnt(TBBUr);
    for (i=0;i<rwcnt;i=i+1) begin
      testf = false;
      MatRowGet(TBBUr,i,TBBUrw);
      if (type==1) then begin
        if ((TBBUr.BudTime==1) and (TBBUrw.BudType==0)) then begin testf = true; end;
      end;
      if (type==2) then begin
        if ((TBBUr.BudOther==1) and (TBBUrw.BudType==0)) then begin testf = true; end;
      end;
      if (type==3) then begin
        if ((TBBUr.BudMaterial==1) and (TBBUrw.BudType==0)) then begin testf = true; end;
      end;
      if (type==4) then begin
        if ((TBBUr.BudStocked==1) and (TBBUrw.BudType==0)) then begin testf = true; end;
      end;
      if (TBBUrw.BudType==2) then begin testf = true; end;
      if (testf) then begin
        if (IsArtType(TBBUrw.ArtCode,type)==false) then begin testf = false; end;
      end;
      if (testf) then begin
 //vg       if (TBBUrw.Invoiced<=0) then begin testf = false; end;
      end;
      if (testf) then begin
        budp = budp + TBBUrw.Sum;
      end;
    end;
  end;
  return;
end;

/* Don't use this, use SumPrTrans2 since it can handle Recursive calls to this (IncDaughter) */
procedure SumPrTrans3(record RcVc RepSpec,string prcode,Integer type,var val sump,var val costp,Integer invd,Integer invbl,
                      array string acur,vector val vtottsum,vector val vtottcost,var Integer acurcnt,
                      var val sumincurp,var val costincurp,Boolean IsSubProject)
begin
  record TBBUVc TBBUr;
  record TBIVVc TBIVr;
  Boolean found;
  Boolean budfound;
  Integer invmethod;
  LongInt sernr;
  Date gd;
  val invprice,t,tincur;
  val price,invapric,qty,invqty;
  Boolean testf;
  string 20 locprcode;
  string 255 tbburowcomment;
  val SumInCur,GPInCur;
  
  locprcode = prcode;
  invprice = BlankVal;
  
  FixedPriceBudget(locprcode,invprice,type);
  if (invprice<>0) then begin
    if (IsSubProject) then begin
      sump = sump + invprice;
    end else begin
      sump = invprice;
    end;
  end;
  TBBUr.PRCode = locprcode;
  budfound = ReadFirstMain(TBBUr,1,true);
  sernr = -1;
//  gd.year = BlankM4Date;
  TBIVr.PRCode = locprcode;
  found = true;
  while (LoopMain(TBIVr,1,found)) begin
    if (TBIVr.PRCode<>locprcode) then begin found = false; end;
    testf = false;
    if (invd<>0) then begin
      if (TBIVr.Invoice<>-1) then begin testf = true; end;
    end;
    if (invbl<>0) then begin
      if (TBIVr.Invoice==-1) then begin testf = true; end;
    end;
    if (nonblank(RepSpec.LastAcc)) then begin
      if (RepSpec.LastAcc<>TBIVr.INGroup) then begin testf = false; end;
    end;
    if (testf) then begin 
      if (nonblank(RepSpec.f6)) then begin
        testf = (TBIVr.ArtCode==RepSpec.f6);
      end;
    end; 
    if (testf) then begin 
      testf = ItemInItemGroupOrClass(TBIVr.ArtCode,"",RepSpec.f7);
    end;    
    if (found==false) then begin testf = false; end;
    if (testf) then begin
      if (type==1) then begin /* time */
        if (TBIVr.ItemType==3) then begin
          if (RepSpec.flags[13]!=0) and (nonblank(TBIVr.CurncyCode)) then begin
            SumInCur = TBIVr.SumInCur;
            if (SumInCur==0) then begin SumInCur = TBIVr.Sum; end;
            GPInCur = TBIVr.GPInCur;
            if (GPInCur==0) then begin GPInCur = TBIVr.GPInCur; end;
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,SumInCur,gd,3,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);          
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
            end else begin
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
              sump = sump + TBIVr.Sum;
              sumincurp = sumincurp + SumInCur;
              AddCurncyTotals(TBIVr.CurncyCode,SumInCur,acur,vtottsum,acurcnt);
              AddCurncyTotals(TBIVr.CurncyCode,GPInCur,acur,vtottcost,acurcnt);
            end;
            costp = costp + t;
            costincurp = costincurp + tincur;
          end else begin
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,TBIVr.Sum,gd,3,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);          
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
            end else begin
              sump = sump + TBIVr.Sum;
              t = TBIVr.Sum - TBIVr.GP;
            end;
            costp = costp + t;
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.Sum,acur,vtottsum,acurcnt);
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.GP,acur,vtottcost,acurcnt);
          end;
        end;
      end;
      if (type==2) then begin /* purchase */
//        if (((TBIVr.oVc==1) or (TBIVr.oVc==2) or (TBIVr.oVc==3)) and (TBIVr.ItemType!=3) and (TBIVr.ItemType!=5)) then begin
        if (TBIVr.ItemType == 0) then begin 
          if (RepSpec.flags[13]!=0) and (nonblank(TBIVr.CurncyCode)) then begin
            SumInCur = TBIVr.SumInCur;
            if (SumInCur==0) then begin SumInCur = TBIVr.Sum; end;
            GPInCur = TBIVr.GPInCur;
            if (GPInCur==0) then begin GPInCur = TBIVr.GPInCur; end;
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,SumInCur,gd,2,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);          
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
            end else begin
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
              sump = sump + TBIVr.Sum;
              sumincurp = sumincurp + SumInCur;
              AddCurncyTotals(TBIVr.CurncyCode,SumInCur,acur,vtottsum,acurcnt);
              AddCurncyTotals(TBIVr.CurncyCode,GPInCur,acur,vtottcost,acurcnt);
            end;
            costp = costp + t;
            costincurp = costincurp + tincur;
          end else begin
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,TBIVr.Sum,gd,2,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end else begin
              sump = sump + TBIVr.Sum;
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end;
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.Sum,acur,vtottsum,acurcnt);
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.GP,acur,vtottcost,acurcnt);
          end;
        end;
      end;
      if (type==3) then begin /* material */
        if (TBIVr.ItemType==5) then begin
          if (RepSpec.flags[13]!=0) and (nonblank(TBIVr.CurncyCode)) then begin
            SumInCur = TBIVr.SumInCur;
            if (SumInCur==0) then begin SumInCur = TBIVr.Sum; end;
            GPInCur = TBIVr.GPInCur;
            if (GPInCur==0) then begin GPInCur = TBIVr.GPInCur; end;
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,SumInCur,gd,1,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);          
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
            end else begin
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
              sump = sump + TBIVr.Sum;
              sumincurp = sumincurp + SumInCur;
              AddCurncyTotals(TBIVr.CurncyCode,SumInCur,acur,vtottsum,acurcnt);
              AddCurncyTotals(TBIVr.CurncyCode,GPInCur,acur,vtottcost,acurcnt);
            end;
            costp = costp + t;
            costincurp = costincurp + tincur;
          end else begin
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,TBIVr.Sum,gd,1,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end else begin
              sump = sump + TBIVr.Sum;
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end;
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.Sum,acur,vtottsum,acurcnt);
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.GP,acur,vtottcost,acurcnt);
          end;
        end;
      end;
      if (type==4) then begin /* Stocked Items */
        if (((TBIVr.oVc==1) or (TBIVr.oVc==4) or (TBIVr.oVc==6) or (TBIVr.oVc==7)) and (TBIVr.ItemType==1)) then begin
          if (RepSpec.flags[13]!=0) and (nonblank(TBIVr.CurncyCode)) then begin
            SumInCur = TBIVr.SumInCur;
            if (SumInCur==0) then begin SumInCur = TBIVr.Sum; end;
            GPInCur = TBIVr.GPInCur;
            if (GPInCur==0) then begin GPInCur = TBIVr.GPInCur; end;
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,TBIVr.Sum,gd,1,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
            end else begin
              t = TBIVr.Sum - TBIVr.GP;
              tincur = SumInCur - GPInCur;
              sump = sump + TBIVr.Sum;
              sumincurp = sumincurp + SumInCur;
              AddCurncyTotals(TBIVr.CurncyCode,SumInCur,acur,vtottsum,acurcnt);
              AddCurncyTotals(TBIVr.CurncyCode,GPInCur,acur,vtottcost,acurcnt);
            end;
            costp = costp + t;
            costincurp = costincurp + tincur;
          end else begin
            FindInvoiceMethod(sernr,TBIVr.PRCode,TBIVr.ArtCode,TBIVr.EMCode,TBIVr.Sum,gd,1,TBBUr,invmethod,invprice,price,invapric,qty,invqty,t,t,t,t,tbburowcomment,false);
            if (invmethod==1) then begin /* fixed price */
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end else begin
              sump = sump + TBIVr.Sum;
              t = TBIVr.Sum - TBIVr.GP;
              costp = costp + t;
            end;
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.Sum,acur,vtottsum,acurcnt);
            AddCurncyTotals(TBIVr.CurncyCode,TBIVr.GP,acur,vtottcost,acurcnt);
          end;
        end;
      end;
    end;
  end;
  return;
end;

/* Don't use this, use SumPrTrans2 since it can handle Recursive calls to this (IncDaughter) */
procedure SumPrTrans(record RcVc RepSpec,string prcode,Integer type,var val sump,var val costp,Integer invd,Integer invbl,
                     array string acur,vector val vtottsum,vector val vtottcost,var Integer acurcnt,
                     var val sumincurp,var val costincurp)
begin
  SumPrTrans3(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp,false);
end;

procedure SumPrTransRecursive(record RcVc RepSpec,string prcode,Integer type,var val sump,var val costp,Integer invd,Integer invbl,
                              array string acur,vector val vtottsum,vector val vtottcost,var Integer acurcnt,
                              var val sumincurp,var val costincurp)
begin
  record PRVc PRr;
  Boolean foundf;
  
  PRr.MotherCode = prcode;
  foundf = true;
  while (LoopKey("MotherCode",PRr,1,foundf)) begin
    if (PRr.MotherCode<>prcode) then begin foundf = false; end;
    if (foundf) then begin
      SumPrTrans3(RepSpec,PRr.Code,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp,true);
      SumPrTransRecursive(RepSpec,PRr.Code,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp);
    end;
  end;
  return;
end;

global
procedure SumPrTrans2(record RcVc RepSpec,string prcode,Integer type,var val sump,var val costp,Integer invd,Integer invbl)
begin
  array string 20 acur;
  Integer acurcnt;
  vector val vtottsum,vtottcost;
  val sumincurp,costincurp;
  
  sump = BlankVal;
  costp = BlankVal;
  if (RepSpec.IncDaughter==1) then begin
    SumPrTrans(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp);
    SumPrTransRecursive(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp);
  end else begin
    SumPrTrans(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,sumincurp,costincurp);
  end;
  return;
end;

global
procedure SumPrTrans2_Cur(record RcVc RepSpec,string prcode,Integer type,var val sump,var val costp,Integer invd,Integer invbl,                          
                          array string acur,vector val vtottsum,vector val vtottcost,var Integer acurcnt,
                          var val sumincurp,var val costincurp)
begin
  sump = BlankVal;
  costp = BlankVal;
  sumincurp = BlankVal;
  costincurp = BlankVal;
  if (RepSpec.IncDaughter==1) then begin
    SumPrTrans(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,
                                   sumincurp,costincurp);
    SumPrTransRecursive(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,
                                            sumincurp,costincurp);
  end else begin
    SumPrTrans(RepSpec,prcode,type,sump,costp,invd,invbl,acur,vtottsum,vtottcost,acurcnt,
                                   sumincurp,costincurp);
  end;
  return;
end;

global
procedure GPProRn(record RcVc RepSpec)
begin
  record PRVc PRr;
  record SMVc SMr;
  Boolean testf,found,tempf;
  LongInt LLoop1;
  string 60 frpr,lastprleader;
  string 60 topr;
  string 60 frcu;
  string 60 tocu;
  string 200 tstr;
  string 20 ckey,i;
  Integer keys,rw;
  LongInt recid;
  val sum,tb,tg,tbincur;
  val tbtim,tbmat,tbexp,tbord,tbact;
  val stim,smat,sexp,sord,sact;
  val cost;
  val s,t;
  val ttb,ttbincur,tsum;
  val sumtime,sumpurch,summater,sumstock;
  val costtime,costpurch,costmater,coststock;
  Date blnkdat;
  array string 20 acur;
  Integer acurcnt;
  vector val vtottsum,vtottcost;
  val sumincur,costincur;

  tbtim = BlankVal;
  tbmat = BlankVal;
  tbexp = BlankVal;
  tbord = BlankVal;
  tbact = BlankVal;
  stim = BlankVal;
  smat = BlankVal;
  sexp = BlankVal;
  sord = BlankVal;
  sact = BlankVal;
  frpr = FirstInRange(RepSpec.f1,20);
  topr = LastInRange(RepSpec.f1,20);
  frcu = FirstInRange(RepSpec.f3,20);
  tocu = LastInRange(RepSpec.f3,20);
  rw = 1;
  StartReportJob(USetStr(6780));
  HTProjects(frpr,topr,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  if (nonblank(RepSpec.f2)) then begin
    tstr = USetStr(4849) & " " & RepSpec.f2;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (RepSpec.flags[10]<>0) then begin 
    HTDetailLevel(0,tstr);
  end else begin
    HTDetailLevel(1,tstr);
  end;
  Header(rw,tstr,0);
  HTCusts(frcu,tocu,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTPRClass(RepSpec.FirstAcc,tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (RepSpec.flags[13]==0) then begin
    tstr = USetStr(2369);
   end else begin
    tstr = USetStr(6650);
  end;            
  Header(rw,tstr,0);
  HTInvInvable(RepSpec.flags[11],RepSpec.flags[12],tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  HTProjSort(RepSpec.flags[8],tstr);
  if (nonblank(tstr)) then begin
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (RepSpec.IncDaughter==1) then begin
    Header(rw,USetStr(4860),1);
    rw = rw + 1;
  end;
  if (HasCategories) then begin
    HTCustCat(RepSpec.f5,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;
  if (HasContactClassification) then begin
    HTCustClass(RepSpec.f4,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;  
  if (nonblank(RepSpec.f6)) then begin
    HTItem(RepSpec.f6,tstr);
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (HasItemGroups) then begin
    HTArtGroup(RepSpec.LastAcc,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;
  if (HasItemClassification) then begin
    HTItemClass(RepSpec.f7,tstr);
    if (nonblank(tstr)) then begin
      Header(rw,tstr,1);
      rw = rw + 1;
    end;
  end;  
  EndHeader;
  if (RepSpec.flags[10]==1) then begin
    StartFormat(15);
    OutString(330,0,USetStr(6790),true);
    OutString(420,0,USetStr(6787),true);
    OutString(1,0,USetStr(6788),true);
    EndFormat;
    Gray_Divider(0,1);
  end;
  if (RepSpec.flags[8]==0) then begin
    PRr.Code = frpr;
    ckey = "Code";
    keys = 1;
  end;
  if (RepSpec.flags[8]==1) then begin
    PRr.Leader = RepSpec.f2;
    PRr.Code = frpr;
    ckey = "PRLeader";
    keys = 2;
  end;
  if (RepSpec.flags[8]==2) then begin
    PRr.CustCode = frcu;
    ckey = "CustCode";
    keys = 1;
  end;
  if (RepSpec.flags[8]==3) then begin
    PRr.PRClass = RepSpec.FirstAcc;
    ckey = "PRClass";
    keys = 1;
  end;
  found = true;
  while (LoopKey(ckey,PRr,keys,found)) begin
    if (found==true) then begin
      if (RepSpec.flags[8]==0) then begin
          if ((nonblank(topr)) and (PRr.Code>topr)) then begin
          found = false;
        end;
      end;
      if (RepSpec.flags[8]==2) then begin
        if ((nonblank(tocu)) and (PRr.CustCode>tocu)) then begin
          found = false;
        end;
      end;
      if (RepSpec.flags[8]==3) then begin
        if ((nonblank(RepSpec.FirstAcc)) and (PRr.PRClass==RepSpec.FirstAcc)) then begin
          found = false;
        end;
      end;
    end;
    if (found) then begin
      testf = true;
      if (nonblank(frcu)) then begin
        if (PRr.CustCode<frcu) then begin
          testf = false;
        end;
      end;
      if (nonblank(tocu)) then begin
        if (PRr.CustCode>tocu) then begin
          if (RepSpec.flags[8]==2) then begin
            found = false;
          end else begin
            testf = false;
          end;
        end;
      end;
      if (testf) then begin
        testf = ContactInGroupClass(PRr.CustCode,RepSpec.f5,RepSpec.f4,"CUST","","");
      end;      
      if (RepSpec.IncDaughter==1) then begin
        if (nonblank(PRr.MotherCode)) then begin
          testf = false;
        end;
      end;
      if (nonblank(RepSpec.FirstAcc) and (RepSpec.FirstAcc<>PRr.PRClass)) then begin testf = false; end;
      if (nonblank(RepSpec.f2)) then begin
        if (RepSpec.f2<>PRr.Leader) then begin
          if (RepSpec.flags[8]==1) then begin
            found = false;
          end else begin
            testf = false;
          end;
        end;
      end;
      if ((RepSpec.flags[19]==0) and (PRr.Terminated<>1)) then begin testf = false; end;
      if ((RepSpec.flags[20]==0) and (PRr.Terminated==1)) then begin testf = false; end;
      if (found==false) then begin testf = false; end;
      if (testf) then begin
        tempf = FindProjContractSales(PRr.Code,"",blnkdat,blnkdat,SMr,sumtime,sumpurch,summater,sumstock,costtime,costpurch,costmater,coststock);
        ttb = BlankVal;
        tsum = BlankVal;
        ttbincur = blankval;
        if (RepSpec.flags[8]==1) then begin
          if (lastprleader!=PRr.Leader) then begin
            StartFormat(15);
             OutString(20,0,PRr.Leader,false);
             OutString(100,0,PRr.LeaderName,false);            
            EndFormat;
          end;
        end;
        lastprleader = PRr.Leader;
        StartFormat(15);
        if (RepSpec.flags[10]==0) then begin
          OutString(20,"DblPRCode",PRr.Code,false);
          OutString(100,0,Left(PRr.Name,31),false);
          OutString(260,"DblCUVc",PRr.CustCode,false);
          OutString(340,0,Left(PRr.CustName,25),false);//OutStringCut
          if (RepSpec.flags[13]==1) then begin
            OutString(470,0,PRr.CurncyCode,false);
          end;  
          EndFormat;
          StartFormat(15);
          OutString(300,0,USetStr(6786),true);
          OutString(400,0,USetStr(6787),true);
          OutString(460,0,USetStr(6788),true);
          EndFormat;
          Gray_Divider(60,460);
        end else begin
          OutString(0,"DblPRCode",PRr.Code,false);
          OutString(70,0,Left(PRr.Name,26),false);
          if (RepSpec.flags[13]==1) then begin
            OutString(230,0,PRr.CurncyCode,false);
          end;  
        end;

        /* Time */
        SumPrTrans2_Cur(RepSpec,PRr.Code,1,sum,cost,RepSpec.flags[11],RepSpec.flags[12],acur,vtottsum,vtottcost,acurcnt,sumincur,costincur);
        sum = sum + sumtime;
        cost = cost + costtime;
        if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
          tsum = tsum + sumincur;
        end else begin
          tsum = tsum + sum;
        end;
        tbincur = sumincur - costincur;
        ttbincur = ttbincur + tbincur;
        tb = sum - cost;
        ttb = ttb + tb;
        tbtim = tbtim + tb;
        stim = stim + sum;
        if (RepSpec.flags[10]==0) then begin
          StartFormat(15);
          tstr = USetStr(6781);
          OutString(60,0,tstr,false);
          if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
            OutVal(300,0,sumincur,M4Val,true);
          end else begin
            OutVal(300,0,sum,M4Val,true);
          end;
          OutVal(400,0,tb,M4Val,true);
          tg = tb * 100;
          tg = tg / sum;
          OutVal(460,0,tg,M4Prcnt,true);
          EndFormat;
        end;

        /* purchases */
        SumPrTrans2_Cur(RepSpec,PRr.Code,2,sum,cost,RepSpec.flags[11],RepSpec.flags[12],acur,vtottsum,vtottcost,acurcnt,sumincur,costincur);
        sum = sum + sumpurch;
        cost = cost + costpurch;
        if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
          tsum = tsum + sumincur;
        end else begin
          tsum = tsum + sum;
        end;
        tbincur = sumincur - costincur;
        ttbincur = ttbincur + tbincur;
        tb = sum - cost;
        ttb = ttb + tb;
        tbexp = tbexp + tb;
        sexp = sexp + sum;
        if (RepSpec.flags[10]==0) then begin
          StartFormat(15);
          tstr = USetStr(6782);
          OutString(60,0,tstr,false);
          if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
            OutVal(300,0,sumincur,M4Val,true);
          end else begin
            OutVal(300,0,sum,M4Val,true);
          end;
          OutVal(400,0,tb,M4Val,true);
          tg = tb * 100;
          tg = tg / sum;
          OutVal(460,0,tg,M4Prcnt,true);
          EndFormat;
        end;

        /* material */
        SumPrTrans2_Cur(RepSpec,PRr.Code,3,sum,cost,RepSpec.flags[11],RepSpec.flags[12],acur,vtottsum,vtottcost,acurcnt,sumincur,costincur);
        sum = sum + summater;
        cost = cost + costmater;
        if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
          tsum = tsum + sumincur;
        end else begin
          tsum = tsum + sum;
        end;
        tbincur = sumincur - costincur;
        ttbincur = ttbincur + tbincur;
        tb = sum - cost;
        ttb = ttb + tb;
        tbmat = tbmat + tb;
        smat = smat + sum;
        if (RepSpec.flags[10]==0) then begin
          StartFormat(15);
          tstr = USetStr(6783);
          OutString(60,0,tstr,false);
          if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
            OutVal(300,0,sumincur,M4Val,true);
          end else begin
            OutVal(300,0,sum,M4Val,true);
          end;
          OutVal(400,0,tb,M4Val,true);
          tg = tb * 100;
          tg = tg / sum;
          OutVal(460,0,tg,M4Prcnt,true);
          EndFormat;
        end;

        /* Stocked Items */
        SumPrTrans2_Cur(RepSpec,PRr.Code,4,sum,cost,RepSpec.flags[11],RepSpec.flags[12],acur,vtottsum,vtottcost,acurcnt,sumincur,costincur);
        sum = sum + sumstock;
        cost = cost + coststock;
        if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
          tsum = tsum + sumincur;
        end else begin
          tsum = tsum + sum;
        end;
        tbincur = sumincur - costincur;
        ttbincur = ttbincur + tbincur;
        tb = sum - cost;
        ttb = ttb + tb;
        tbord = tbord + tb;
        sord = sord + sum;
        if (RepSpec.flags[10]==0) then begin
          StartFormat(15);
          tstr = USetStr(6784);
          OutString(60,0,tstr,false);
          if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
            OutVal(300,0,sumincur,M4Val,true);
          end else begin
            OutVal(300,0,sum,M4Val,true);
          end;
          OutVal(400,0,tb,M4Val,true);
          tg = tb * 100;
          tg = tg / sum;
          OutVal(460,0,tg,M4Prcnt,true);
          EndFormat;
        end;
        if (RepSpec.flags[10]==0) then begin
          Gray_Divider(60,460);
          StartFormat(15);
          OutString(60,0,USetStr(6785),false);
          OutVal(300,0,tsum,M4Val,true);
          OutVal(400,0,ttb,M4Val,true);
          if (RepSpec.flags[13]!=0) and (nonblank(PRr.CurncyCode)) then begin
            tg = ttbincur * 100;
          end else begin
            tg = ttb * 100;
          end;
          tg = tg / tsum;
          OutVal(460,0,tg,M4Prcnt,true);
          EndFormat;
          StartFormat(15);
          EndFormat;
        end;
        if (RepSpec.flags[10]==1) then begin
          OutVal(330,0,tsum,M4Val,true);
          OutVal(420,0,ttb,M4Val,true);
          tg = ttb * 100;
          tg = tg / tsum;
          OutVal(1,0,tg,M4Prcnt,true);
          EndFormat;
        end;
      end;
    end;
  end;
  if (RepSpec.flags[10]==1) then begin
    Gray_Divider(0,1);
    if (RepSpec.flags[13]!=0) then begin
      PrintCurncyTotals(0,acur,vtottsum,vtottcost,acurcnt);
    end else begin
      StartFormat(15);
      s = stim + sexp;
      s = s + smat;
      s = s + sord;
      OutVal(330,0,s,M4Val,true);
      t = tbtim + tbexp;
      t = t + tbmat;
      t = t + tbord;
      OutVal(420,0,t,M4Val,true);
      tg = t * 100;
      tg = tg / s;
      OutVal(1,0,tg,M4Prcnt,true);
      EndFormat;
    end;
  end;
  
  if (RepSpec.flags[10]==0) then begin
    StartFormat(15);
    EndFormat;
    StartFormat(15);
    OutString(60,0,USetStr(6797),false);
    OutString(300,0,USetStr(6786),true);
    OutString(400,0,USetStr(6787),true);
    OutString(460,0,USetStr(6788),true);
    EndFormat;
    Gray_Divider(60,460);

    /* Time */
    StartFormat(15);
    OutString(60,0,USetStr(6781),false);
    OutVal(300,0,stim,M4Val,true);
    OutVal(400,0,tbtim,M4Val,true);
    tg = tbtim * 100;
    tg = tg / stim;
    OutVal(460,0,tg,M4Prcnt,true);
    EndFormat;

    /* purchases */
    StartFormat(15);
    OutString(60,0,USetStr(6782),false);
    OutVal(300,0,sexp,M4Val,true);
    OutVal(400,0,tbexp,M4Val,true);
    tg = tbexp * 100;
    tg = tg / sexp;
    OutVal(460,0,tg,M4Prcnt,true);
    EndFormat;

    /* material */
    StartFormat(15);
    OutString(60,0,USetStr(6783),false);
    OutVal(300,0,smat,M4Val,true);
    OutVal(400,0,tbmat,M4Val,true);
    tg = tbmat * 100;
    tg = tg / smat;
    OutVal(460,0,tg,M4Prcnt,true);
    EndFormat;

    /* stocked items */
    StartFormat(15);
    OutString(60,0,USetStr(6784),false);
    OutVal(300,0,sord,M4Val,true);
    OutVal(400,0,tbord,M4Val,true);
    tg = tbord * 100;
    tg = tg / sord;
    OutVal(460,0,tg,M4Prcnt,true);
    EndFormat;
    
   /* activities */
   /*
    StartFormat(15);
    OutString(60,0,USetStr(6687),false);
    OutVal(300,0,sact,M4Val,true);
    OutVal(400,0,tbact,M4Val,true);
    tg = tbact * 100;
    tg = tg / sact;
    OutVal(460,0,tg,M4Prcnt,true);
    EndFormat;    
*/
    /* sum */
    Gray_Divider(60,460);
    if (RepSpec.flags[13]!=0) then begin
      StartFormat(15);
      OutString(60,0,USetStr(6797),false);
      EndFormat;
      PrintCurncyTotals(1,acur,vtottsum,vtottcost,acurcnt);
    end else begin
      StartFormat(15);
      OutString(60,0,USetStr(6797),false);
      s = stim + sexp;
      s = s + smat;
      s = s + sord;
      s = s + sact;
      OutVal(300,0,s,M4Val,true);
      t = tbtim + tbexp;
      t = t + tbmat;
      t = t + tbord;
      t = t + tbact;
      OutVal(400,0,t,M4Val,true);
      tg = t * 100;
      tg = tg / s;
      OutVal(460,0,tg,M4Prcnt,true);
      EndFormat;
    end;
  end;
  EndJob;
  return;
end;

