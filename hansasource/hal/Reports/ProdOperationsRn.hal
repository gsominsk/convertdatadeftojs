external procedure CreateProdOperation(record ProdSettingsBlock,record ProdOperationVc,record ProdVc,row RoutingVc,record StdOperationVc,var Date,var Time);
external updating procedure ProdOper_AddPhantomsOperations(record ProdSettingsBlock,record ProdVc,var Date,var Time);
external procedure AddTimeItemToProdOperation(record ProdOperationVc,string,Time);
external function string 255 HTProds(LongInt, LongInt);
external function LongInt AddTime(Time,LongInt,var Time);
external function LongInt TimeToMinutes(Time);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function Boolean IsPhantomItem(record INVc);


procedure PrintProdOperation(record ProdOperationVc ProdOpr)
begin
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  
  if (ProdOpr.SerNr>0) then begin
    StartFormat(15);
     OutString(0,0,ProdOpr.Sequence,false);
     OutString(30,0,ProdOpr.Comment,false);
    EndFormat;
    rwcnt = MatRowCnt(ProdOpr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ProdOpr,i,ProdOprw);
      StartFormat(15);
       OutString(15,0,ProdOprw.Item,false);
       OutString(100,0,ProdOprw.Comment,false);
       OutVal(420,0,ProdOprw.InQty,M4Val,true);
       OutVal(480,0,ProdOprw.OutQty,M4Val,true);
      EndFormat;
    end;
    Gray_Divider(0,1);
  end;
  return;
end;

procedure CopyInstructions(record ProdOperationVc ProdOpr,record StdOperationr StdOpr)
begin
  Integer i,rwcnt;
  string 255 tstr;
  
  rwcnt = LineTextCnt(StdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    tstr = LineTextGet(StdOpr,i);
    LineTextPut(ProdOpr,i,tstr);      
  end;  
  return;
end;

/*
procedure AddProdOpertaionRow(record ProdOperationVc ProdOpr,row ProdOperationVc ProdOprw,string item,string comment,string material,string objects,                               
                               val prodinqty,val prodoutqty,val itemcost,val relval,val fiforowval,val coef,val stdoqty,Boolean mulf)
//in ProdOperationsMn
begin
  ClearRow(ProdOpr,ProdOprw,1);
  ProdOprw.Item = item;
  ProdOprw.Comment = comment;
  ProdOprw.Material = material;
  if (prodinqty!=0) then begin
//StopAlert("2.ProdOprw.InQty " & ProdOprw.InQty & " stdoqty " & stdoqty & " prodinqty " & prodinqty & " mulf  " & mulf);                              
    if (stdoqty!=0) then begin
      ProdOprw.InQty = stdoqty;
//StopAlert("1.ProdOprw.InQty " & ProdOprw.InQty & " ProdOprw.ArtCode " & ProdOprw.Item & " Prodrw.InQty " & Prodrw.InQty);        
      switch (ProdOpr.RowsHoldActualQty) begin
        case 1: 
          ProdOprw.InQty = ProdOprw.InQty*ProdOpr.Qty;
        otherwise ;
      end;
    end;
    if (ProdOprw.InQty==0) then begin
      ProdOprw.InQty = prodinqty;
      if (mulf) then begin
        ProdOprw.InQty = ProdOprw.InQty*ProdOpr.Qty;
      end;
    end;
    ProdOprw.OutQty = blankval;
  end else begin
    ProdOprw.InQty = blankval;
    if (stdoqty!=0) then begin
      ProdOprw.OutQty = stdoqty;
      switch (ProdOpr.RowsHoldActualQty) begin
        case 1: 
          ProdOprw.OutQty = ProdOprw.OutQty*ProdOpr.Qty;
        otherwise ;
      end;
    end;
    if (ProdOprw.OutQty==0) then begin
      ProdOprw.OutQty = prodoutqty;
      if (mulf) then begin
        ProdOprw.OutQty = ProdOprw.OutQty*ProdOpr.Qty;
      end;
    end;
  end;
//StopAlert("ProdOprw.InQty " & ProdOprw.InQty & " ProdOprw.ArtCode " & ProdOprw.Item & " Prodrw.InQty " & Prodrw.InQty);        
  ProdOprw.ActualInQty = blankval;
  ProdOprw.ActualOutQty = blankval;
  ProdOprw.ItemCost = itemcost;
  ProdOprw.RelVal = relval;
  ProdOprw.FIFORowVal = fiforowval;
  ProdOprw.Coefficient = coef;
  ProdOprw.Objects = objects;
  MatRowPut(ProdOpr,MatRowCnt(ProdOpr),ProdOprw);
  return;
end;
                
procedure CreateProdOperation(record ProdSettingsBlock PSb,record ProdOperationVc ProdOpr,record ProdVc Prodr,row RoutingVc Routingrw,record StdOperationVc StdOperationr,var Date startdate,var Time starttime)
//in ProdOperationsMn
begin
  row ProdOperationVc ProdOprw;
  row ProdVc Prodrw;
  row StdOperationVc StdOperationrw;
  Integer rwcnt,i;
  Integer prwcnt,pi;
  Time tt;

  ProdOpr.Qty = blankval;
  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.ProdOrdNr = Prodr.ProdOrder;
  ProdOpr.Sequence = Routingrw.Sequence;
  ProdOpr.SubSequence = Routingrw.SubSequence;
  ProdOpr.Comment = Routingrw.Comment;
  ProdOpr.SetupTime = Routingrw.SetupTime;
  if (blank(ProdOpr.SetupTime)) then begin
    ProdOpr.SetupTime = StdOperationr.SetupTime;
  end;
  ProdOpr.QueueTime = Routingrw.QueueTime;
  if (blank(ProdOpr.QueueTime)) then begin
    ProdOpr.QueueTime = StdOperationr.QueueTime;
  end;
  ProdOpr.MoveTime = Routingrw.MoveTime;
  if (blank(ProdOpr.MoveTime)) then begin
    ProdOpr.MoveTime = StdOperationr.MoveTime;
  end;
  
  ProdOpr.StartDate = startdate;
  ProdOpr.StartTime = starttime;

  
  ProdOpr.ProdDate = startdate;
  ProdOpr.ProdDate = AddDay(ProdOpr.ProdDate,AddTime(ProdOpr.StartTime,TimeToMinutes(StdOperationr.DurTime),tt));
//ProdOpr.EndTime = tt;  
  if (StdOperationr.DurDays>0) then begin
    ProdOpr.ProdDate = AddDay(ProdOpr.ProdDate,StdOperationr.DurDays);
  end;
  startdate = ProdOpr.ProdDate;
  starttime = ProdOpr.EndTime;
    ProdOpr.Qty = Prodr.Qty;

  ProdOpr.Location = Prodr.Location;
  ProdOpr.StdOperation = StdOperationr.Code;
  ProdOpr.BatchTime = StdOperationr.BatchTime;
  ProdOpr.LangCode = Prodr.LangCode;
  ProdOpr.MachineGroup = StdOperationr.MachineGroup;
  ProdOpr.DisplayGroup = StdOperationr.DisplayGroup;
  CopyInstructions(ProdOpr,StdOperationr);
  ProdOpr.SerNr = NextSerNr("ProdOperationVc",ProdOpr.ProdDate,-1,false,"");
  
  rwcnt = MatRowCnt(StdOperationr);
  prwcnt = MatRowCnt(Prodr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StdOperationr,i,StdOperationrw);
    for (pi=0;pi<prwcnt;pi=pi+1) begin
      MatRowGet(Prodr,pi,Prodrw);
      if (Prodrw.Material==StdOperationrw.Material) then begin
        AddProdOpertaionRow(ProdOpr,ProdOprw,Prodrw.Item,Prodrw.Comment,StdOperationrw.Material,Prodrw.Objects,
                            Prodrw.InQty,Prodrw.OutQty,Prodrw.ItemCost,Prodrw.RelVal,Prodrw.FIFORowVal,Prodrw.Coefficient,
                            StdOperationrw.Qty,false);
      end else begin
        if (Prodrw.InQty!=0) then begin
          ProdOp_AddLowerLevelsRecursive(PSb,ProdOpr,ProdOprw,Prodrw.Item,Prodrw.InQty,StdOperationrw,true);
        end;
      end;
    end;
  end;
  if (PSb.FixedTime!=0) then begin
    AddTimeItemToProdOperation(ProdOpr,PSb.LabourCostItem,ProdOpr.RunTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.SetupCostItem,ProdOpr.SetupTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.MoveCostItem,ProdOpr.MoveTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.QueueCostItem,ProdOpr.QueueTime);
  end;
  return;
end;

procedure CreateProdOperation_Phantom(record ProdSettingsBlock PSb,record ProdOperationVc ProdOpr,record ProdVc Prodr,val inqty,record RcVc Recr,row RoutingVc Routingrw,record StdOperationVc StdOperationr,var Date startdate,var Time starttime)
//in ProdOperationsMn
begin
  row ProdOperationVc ProdOprw;
  row StdOperationVc StdOperationrw;
  Integer rwcnt,i;
  Time tt;
  row RecVc Recrw;
  Integer recrwcnt,reci;
  val q;

  ProdOpr.Qty = inqty;
  switch (ProdOpr.RowsHoldActualQty) begin
    case 1: q = inqty;
    otherwise q = 1;
  end;

  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.ProdOrdNr = Prodr.ProdOrder;
  ProdOpr.Sequence = Routingrw.Sequence;
  ProdOpr.SubSequence = Routingrw.SubSequence;
  ProdOpr.Comment = Routingrw.Comment;
  ProdOpr.RunTime = Routingrw.RunTime;
  if (blank(ProdOpr.RunTime)) then begin
    ProdOpr.RunTime = StdOperationr.RunTime;
  end;
  ProdOpr.SetupTime = Routingrw.SetupTime;
  if (blank(ProdOpr.SetupTime)) then begin
    ProdOpr.SetupTime = StdOperationr.SetupTime;
  end;
  ProdOpr.QueueTime = Routingrw.QueueTime;
  if (blank(ProdOpr.QueueTime)) then begin
    ProdOpr.QueueTime = StdOperationr.QueueTime;
  end;
  ProdOpr.MoveTime = Routingrw.MoveTime;
  if (blank(ProdOpr.MoveTime)) then begin
    ProdOpr.MoveTime = StdOperationr.MoveTime;
  end;
  
  ProdOpr.StartDate = startdate;
  ProdOpr.StartTime = starttime;

  
  ProdOpr.ProdDate = startdate;
  ProdOpr.ProdDate = AddDay(ProdOpr.ProdDate,AddTime(ProdOpr.StartTime,TimeToMinutes(StdOperationr.DurTime),tt));
//ProdOpr.EndTime = tt;  
  if (StdOperationr.DurDays>0) then begin
    ProdOpr.ProdDate = AddDay(ProdOpr.ProdDate,StdOperationr.DurDays);
  end;
  startdate = ProdOpr.ProdDate;
  starttime = ProdOpr.EndTime;
  ProdOpr.Qty = Prodr.Qty;

  ProdOpr.Location = Prodr.Location;
  ProdOpr.StdOperation = StdOperationr.Code;
  ProdOpr.BatchTime = StdOperationr.BatchTime;
  ProdOpr.LangCode = Prodr.LangCode;
  ProdOpr.MachineGroup = StdOperationr.MachineGroup;
  ProdOpr.DisplayGroup = StdOperationr.DisplayGroup;
  CopyInstructions(ProdOpr,StdOperationr);
  ProdOpr.SerNr = NextSerNr("ProdOperationVc",ProdOpr.ProdDate,-1,false,"");
  
  rwcnt = MatRowCnt(StdOperationr);
  recrwcnt = MatRowCnt(Recr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StdOperationr,i,StdOperationrw);
    for (reci=0;reci<recrwcnt;reci=reci+1) begin
      MatRowGet(Recr,reci,Recrw);
      if (Recrw.Material==StdOperationrw.Material) then begin
        AddProdOpertaionRow(ProdOpr,ProdOprw,Recrw.Item,Recrw.Comment,StdOperationrw.Material,"",
                            Recrw.InQty*q,Recrw.OutQty*q,Recrw.ItemCost,Recrw.RelVal,blankval,blankval,
                            StdOperationrw.Qty*q,false);
      end else begin
        if (Recrw.InQty!=0) then begin
          ProdOp_AddLowerLevelsRecursive(PSb,ProdOpr,ProdOprw,Recrw.Item,Recrw.InQty,StdOperationrw,true);
        end;
      end;
    end;
  end;
  if (PSb.FixedTime!=0) then begin
    AddTimeItemToProdOperation(ProdOpr,PSb.LabourCostItem,ProdOpr.RunTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.SetupCostItem,ProdOpr.SetupTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.MoveCostItem,ProdOpr.MoveTime);
    AddTimeItemToProdOperation(ProdOpr,PSb.QueueCostItem,ProdOpr.QueueTime);
  end;
  return;
end;

procedure ProdOper_AddPhantomOperations(record ProdSettingsBlock PSb,record RecVc Recr,record ProdVc Prodr,val inqty,var Date startdate,var Time starttime)
//in ProdOperationsMn
begin
  record ProdOperationVc ProdOpr;
  Integer roui,rourwcnt;
  record RoutingVc Routingr;
  row RoutingVc Routingrw;
  record StdOperationVc StdOperationr;

  Routingr.Code = Recr.DefaultRouting;
  if (ReadFirstMain(Routingr,1,true)) then begin
    rourwcnt = MatRowCnt(Routingr);
    for (roui=0;roui<rourwcnt;roui=roui+1) begin
      MatRowGet(Routingr,roui,Routingrw);
      StdOperationr.Code = Routingrw.StdOperation;
      if (ReadFirstMain(StdOperationr,1,true)) then begin
        RecordNew(ProdOpr);
        CreateProdOperation_Phantom(PSb,ProdOpr,Prodr,inqty,Recr,Routingrw,StdOperationr,startdate,starttime);
        PrintProdOperation(ProdOpr);
      end;
    end;
  end;
  return;
end;
    
procedure ProdOper_AddPhantomsOperations_Recursive(record ProdSettingsBlock PSb,record RecVc Recr,record ProdVc Prodr,val inqty,var Date startdate,var Time starttime)
//in ProdOperationsMn
begin    
  row RecVc Recrw;
  Integer recrwcnt,reci;
  record INVc INr;

  recrwcnt = MatRowCnt(Recr);
  for (reci=0;reci<recrwcnt;reci=reci+1) begin
    MatRowGet(Recr,reci,Recrw);
    if (Recrw.InQty!=0) then begin
      if (ReadFirstItem(Recrw.Item,INr,false,false)) then begin
        if (IsPhantomItem(INr)) then begin
          Recr.Code = INr.Recepy;
          if (ReadFirstMain(Recr,1,true)) then begin
            if (nonblank(Recr.DefaultRouting)) then begin
              ProdOper_AddPhantomsOperations_Recursive(PSb,Recr,Prodr,inqty,startdate,starttime);
              ProdOper_AddPhantomOperations(PSb,Recr,Prodr,inqty,startdate,starttime);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;
                            
procedure ProdOper_AddPhantomsOperations(record ProdSettingsBlock PSb,record ProdVc Prodr,var Date startdate,var Time starttime)
//in ProdOperationsMn
begin
  row ProdVc Prodrw;
  record INVc INr;
  record RecVc Recr;
  Integer pi,prwcnt;
    
  prwcnt = MatRowCnt(Prodr);
  for (pi=0;pi<prwcnt;pi=pi+1) begin
    MatRowGet(Prodr,pi,Prodrw);
    if (Prodrw.InQty!=0) then begin
      if (ReadFirstItem(Prodrw.Item,INr,false,false)) then begin
        if (IsPhantomItem(INr)) then begin
          Recr.Code = INr.Recepy;
          if (ReadFirstMain(Recr,1,true)) then begin
            if (nonblank(Recr.DefaultRouting)) then begin              
              ProdOper_AddPhantomsOperations_Recursive(PSb,Recr,Prodr,Prodrw.InQty,startdate,starttime);              
              ProdOper_AddPhantomOperations(PSb,Recr,Prodr,Prodrw.InQty,startdate,starttime);
            end;
          end;
        end;
      end;
    end;
  end;
  return;
end;
*/

procedure ProdOperationsHeader(LongInt frprod,LongInt toprod)
begin
  Integer rw;
  string 255 tstr;
  
  rw = 1;
  Header(rw,HTProds(frprod,toprod),1);
  return;
end;

function val SubSequenceOperationsQty(LongInt prodnr,LongInt seq,LongInt subseq)
begin
  val qty;
  Boolean found;
  record ProdOperationVc ProdOpr;

  found = true;
  ProdOpr.ProdNr = prodnr;
  ProdOpr.Sequence = seq;
  ProdOpr.SubSequence = subseq;    
  while (LoopKey("ProdNrSeq",ProdOpr,3,found)) begin
    if (ProdOpr.ProdNr!=prodnr) then begin 
      found = false;
    end;
    if (ProdOpr.Sequence!=seq) then begin 
      found = false;
    end;
    if (ProdOpr.SubSequence!=subseq) then begin 
      found = false;
    end;
    if (found) then begin
      switch (ProdOpr.PRStatusFlag) begin
        case 0: qty = qty + ProdOpr.Qty;
        case 2: qty = qty + ProdOpr.Qty;
        case 3: qty = qty + ProdOpr.Qty;
        case 4: qty = qty - ProdOpr.Qty;
        case 5: qty = qty - ProdOpr.Qty;
      end;        
    end;
  end;
  SubSequenceOperationsQty = qty;
  return;
end;

global
function Integer AnyOperationMissingToFinishProduction(record ProdVc Prodr)
begin
  Integer res;
  record ProdOperationVc ProdOpr;
  LongInt lastsequence,lastsubsequence;
  LongInt seq,subseq;
  val qty;
    
  res = 0;
  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.Sequence = 1000000;
  if (ReadLastKey("ProdNrSeq",ProdOpr,2,false)) then begin end;
  if (ProdOpr.ProdNr!=Prodr.SerNr) then begin
    res = 20759;
    goto LAnyOperationMissingToFinishProduction;
  end;
  lastsequence = ProdOpr.Sequence;
  
  seq = 1;
  while (seq<=lastsequence) begin
    ProdOpr.ProdNr = Prodr.SerNr;
    ProdOpr.Sequence = seq;
    ProdOpr.SubSequence = 1000000;
    if (ReadLastKey("ProdNrSeq",ProdOpr,3,false)) then begin end;
    lastsubsequence = ProdOpr.SubSequence;    
    if (lastsubsequence>0) then begin
      subseq = 1;
    end else begin
      subseq = -1;
    end;
    while (subseq<=lastsubsequence) begin
      qty = SubSequenceOperationsQty(Prodr.SerNr,seq,subseq);
//  StopAlert("qty " & qty & " seq  " & seq & " subseq " & subseq);    
      if (qty<Prodr.Qty) then begin
        res = 20758;
        goto LAnyOperationMissingToFinishProduction;
      end;
      subseq = subseq + 1;
    end;
    seq = seq + 1;
  end;
LAnyOperationMissingToFinishProduction:;  
  AnyOperationMissingToFinishProduction = res;
  return;
end;

procedure AddProdOperationToProdOperation(record ProdOperationVc resProdOpr,record ProdOperationVc ProdOpr)
begin
  row ProdOperationVc resProdOprw;
  row ProdOperationVc ProdOprw;
  Integer i,rwcnt;
  Integer resi,resrwcnt;
  Boolean itemaddedf;
  
  rwcnt = MatRowCnt(ProdOpr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ProdOpr,i,ProdOprw);
    resrwcnt = MatRowCnt(resProdOpr);
    itemaddedf = false;
    for (resi=0;resi<resrwcnt;resi=resi+1) begin
      MatRowGet(resProdOpr,resi,resProdOprw);
      if (ProdOprw.Item==resProdOprw.Item) then begin
        resProdOprw.InQty = resProdOprw.InQty + ProdOprw.InQty;
        resProdOprw.OutQty = resProdOprw.OutQty + ProdOprw.OutQty;
        MatRowPut(resProdOpr,resi,resProdOprw);   
        itemaddedf = true;     
      end;
    end;
    if (itemaddedf==false) then begin
      CopyRow(resProdOpr,ProdOprw,resProdOprw);
      MatRowPut(resProdOpr,resrwcnt,resProdOprw);   
    end;
  end;
  return;
end;

procedure PrintSubSequenceOperations(LongInt prodnr,LongInt seq,LongInt subseq)
begin
  Boolean found;
  record ProdOperationVc ProdOpr;
  record ProdOperationVc normProdOpr;
  record ProdOperationVc cancProdOpr;
  record ProdOperationVc discProdOpr;
  val qty,cancelqty,discqty;

  found = true;
  ProdOpr.ProdNr = prodnr;
  ProdOpr.Sequence = seq;
  ProdOpr.SubSequence = subseq;    
  while (LoopKey("ProdNrSeq",ProdOpr,3,found)) begin
    if (ProdOpr.ProdNr!=prodnr) then begin 
      found = false;
    end;
    if (ProdOpr.Sequence!=seq) then begin 
      found = false;
    end;
    if (ProdOpr.SubSequence!=subseq) then begin 
      found = false;
    end;
    if (found) then begin
      switch (ProdOpr.PRStatusFlag) begin
        case 0: 
          if (normProdOpr.SerNr==-1) then begin
            RecordCopy(normProdOpr,ProdOpr);
          end else begin
            AddProdOperationToProdOperation(normProdOpr,ProdOpr);
          end;
        case 2: 
          if (normProdOpr.SerNr==-1) then begin
            RecordCopy(normProdOpr,ProdOpr);
          end else begin
            AddProdOperationToProdOperation(normProdOpr,ProdOpr);
          end;
        case 3: 
          if (normProdOpr.SerNr==-1) then begin
            RecordCopy(normProdOpr,ProdOpr);
          end else begin
            AddProdOperationToProdOperation(normProdOpr,ProdOpr);
          end;
        case 4: 
          if (cancProdOpr.SerNr==-1) then begin
            RecordCopy(cancProdOpr,ProdOpr);
          end else begin
            AddProdOperationToProdOperation(cancProdOpr,ProdOpr);
          end;
        case 5: 
          if (discProdOpr.SerNr==-1) then begin
            RecordCopy(discProdOpr,ProdOpr);
          end else begin
            AddProdOperationToProdOperation(discProdOpr,ProdOpr);
          end;
      end;        
    end;
  end;
  if (normProdOpr.SerNr>0) then begin
    StartFormat(15);
     OutString(0,0,USetStr(16445),false);
    EndFormat;
    Gray_Divider(0,100);
    PrintProdOperation(normProdOpr);
  end;
  if (cancProdOpr.SerNr>0) then begin
    StartFormat(15);
     OutString(0,0,USetStr(16446),false);
    EndFormat;
    Gray_Divider(0,100);
    PrintProdOperation(cancProdOpr);  
  end;
  if (discProdOpr.SerNr>0) then begin
    StartFormat(15);
     OutString(0,0,USetStr(16447),false);
    EndFormat;
    Gray_Divider(0,100);
    PrintProdOperation(discProdOpr);  
  end;
  return;
end;

procedure PrintProdOperationsPerSequence(record ProdVc Prodr)
begin
  record ProdOperationVc ProdOpr;
  LongInt lastsequence,lastsubsequence;
  LongInt seq,subseq;

  ProdOpr.ProdNr = Prodr.SerNr;
  ProdOpr.Sequence = 1000000;
  if (ReadLastKey("ProdNrSeq",ProdOpr,2,false)) then begin end;
  lastsequence = ProdOpr.Sequence;
  seq = 1;
  while (seq<=lastsequence) begin
    ProdOpr.ProdNr = Prodr.SerNr;
    ProdOpr.Sequence = seq;
    ProdOpr.SubSequence = 1000000;
    if (ReadLastKey("ProdNrSeq",ProdOpr,3,false)) then begin end;
    lastsubsequence = ProdOpr.SubSequence;    
    if (lastsubsequence>0) then begin
      subseq = 1;
    end else begin
      subseq = -1;
    end;
    while (subseq<=lastsubsequence) begin
      PrintSubSequenceOperations(Prodr.SerNr,seq,subseq);
      subseq = subseq + 1;
    end;
    seq = seq + 1;
  end;
  return;
end;

global
updating procedure ProdOperationsRn(record RcVc RepSpec)
begin
  record ProdVc Prodr;
  record RoutingVc Routingr;
  row RoutingVc Routingrw;
  record StdOperationVc StdOperationr;
  Boolean TrHs,testf;
  Integer flushcnt;
  Integer rwcnt,i,err;
  Date startdate;
  Time starttime;
  Boolean firstf; 
  LongInt frprod,toprod,lastprod;
  record ProdOperationVc ProdOpr;
  Boolean routingmodef;
  record ProdSettingsBlock PSb;

  BlockLoad(PSb);
  frprod = FirstInRange(RepSpec.f1,10);
  toprod = LastInRange(RepSpec.f1,10);
  StartReportJob(USetStr(16460));
   ProdOperationsHeader(frprod,toprod);
  EndHeader;
  StartFormat(15);
   OutString(0,0,USetStr(16432),false);
   OutString(100,0,USetStr(16431),false);
  EndFormat;
  Gray_Divider(0,1);

  TrHs = true;
  Prodr.SerNr = frprod;
  ResetLoop(Prodr);
  while(LoopMain(Prodr,1,TrHs)) begin
    if (nonblank(RepSpec.f1)) then begin
      if (Prodr.SerNr>toprod) then begin
        TrHs = false;
      end;
    end;
    testf = true;
    if (TrHs==false) then begin
      testf = false;
    end;
    if (blank(Prodr.Routing)) then begin
      testf = false;
    end;
    if (testf) then begin
      switch (RepSpec.flags[0]) begin
        case 0:
          ProdOpr.ProdNr = Prodr.SerNr;
          testf = !ReadFirstKey("ProdNr",ProdOpr,1,true);
        case 1:
          err = AnyOperationMissingToFinishProduction(Prodr);
          if (err==0) then begin
            testf = false;
          end;
      end;
    end;
    if (testf) then begin
      if (lastprod!=Prodr.SerNr) then begin
        StartFormat(15);
         OutStringID(0,"DblProdVcID",USetStr(16463) & " " & Prodr.SerNr,false,Prodr.SerNr);
        EndFormat;
        Gray_Divider(0,1);
      end;
      startdate = Prodr.StartDate;
      if (blankdate(startdate)) then begin
        startdate = Prodr.ProdDate;
      end;
      if (blankdate(startdate)) then begin
        startdate = CurrentDate;
      end;
      starttime = Prodr.StartTime;
      switch (RepSpec.flags[0]) begin
        case 0:
          Routingr.Code = Prodr.Routing;
          if (ReadFirstMain(Routingr,1,true)) then begin
            ProdOper_AddPhantomsOperations(PSb,Prodr,startdate,starttime);
            firstf = true;
            rwcnt = MatRowCnt(Routingr);
            for (i=0;i<rwcnt;i=i+1) begin
              MatRowGet(Routingr,i,Routingrw);
              StdOperationr.Code = Routingrw.StdOperation;
              if (ReadFirstMain(StdOperationr,1,true)) then begin
                RecordNew(ProdOpr);
                CreateProdOperation(PSb,ProdOpr,Prodr,Routingrw,StdOperationr,startdate,starttime);
                PrintProdOperation(ProdOpr);
                firstf = false;
              end;
            end;
          end;
        case 1:
          PrintProdOperationsPerSequence(Prodr);
      end;
      lastprod = Prodr.SerNr;
    end;
  end;
  EndJob;
  return;
end;

