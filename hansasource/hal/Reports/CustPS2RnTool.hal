external function Boolean HasTouchScreenLook();
external function Boolean HasModSO();
external function Boolean HasModSL();
external procedure SplitEclass(string,var Array string);
external function string 255 CreateInvoiceNumber(LongInt,string);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Integer ERecordStatus(string,string,LongInt,string,var string);
external procedure GetDateTurnover(string,string,string,string,string,record ICSVc,string,Date,Date,var val,Integer);
external procedure ChStateName(Integer,Boolean, var String, Boolean);
external function val b12b2(Date,Val);
external function val cur2b1(String,Date,Val);
external function val cur2b2(String,Date,Val);
external procedure GetBaseCurncy(Integer,var string);

global
procedure PrintChecks(record CUVc CUp,var val totar,Record RcVc RepSpec) 
BEGIN
  record CheckVc Checkr;
  Boolean testf,found;
  string 255 tstr,tstr1;
  Val tmp;
  Integer k,m;
  
  StartFormat(15);
  OutString(0,0,USetStr(8380),false);
  EndFormat;
  Gray_Divider(0,1);
  StartFormat(15);
   OutString(0,0,USetStr(8381),false);
   OutString(80,0,USetStr(8382),false);
   OutString(150,0,USetStr(8384),false);
   OutString(280,0,USetStr(8389),false);
   OutString(400,0,USetStr(8383),true);
   if (RepSpec.flags[15]==0) then begin
     GetBaseCurncy(1,tstr);
   end else begin
     GetBaseCurncy(2,tstr);
   end;
   OutString(480,0,USetStr(8383) & " " & tstr,true);
  EndFormat;
  m = 1;
  for(k=1; k<=3; k=k+1) begin   //LO Muestra cheques en Cartera-1,Depositados-2,Endosado-4
    Checkr.Openf = m;
    found = true;
    while (LoopKey("Openf",Checkr,1,found)) begin    //LO WAS OpenEffectDate
      testf = true;
      if (found) then begin
        if (Checkr.CUCode!=CUp.Code) then begin testf = false; end;
      end;
      if (found) and (testf) then begin  
        if (Checkr.Openf != m)  then begin found = false; end;
      end;
      if (found==false) then begin testf = false; end;
      if (testf) then begin
        StartFormat(15);
         OutString(0,"DblCheckVc",Checkr.CheckNr,false);
         OutDate(80,0,Checkr.EffectDate,false);
         switch (Checkr.ChkMode) begin        //LO in stead of multiple if
           case 0 : tstr1 = USetStr(8385);  //LO
           case 1 : tstr1 = USetStr(8386);       
           case 2 : tstr1 = USetStr(8387);       
           case 3 : tstr1 = USetStr(8388);       
         end;  
         ChStateName(Checkr.Openf,true,tstr,true);
         tstr = tstr1 & "-" & tstr;
         OutString(150,0,tstr,false);
         OutString(280,0,Checkr.CurncyCode,false);
         OutVal(400,0,Checkr.Amount,M4Val,true);
         if (RepSpec.flags[15]==0) then begin
           tmp = Cur2b1(Checkr.CurncyCode,CurrentDate,Checkr.Amount);
         end else begin  
           tmp = Cur2b2(Checkr.CurncyCode,CurrentDate,Checkr.Amount);
          end;
         OutVal(480,0,tmp,M4Val,true);
         EndFormat;
         totar = totar + tmp;    // was Checkr.Amount;
      end;
    end;  
    m =  (m * 2);
  end;
  if (HasModSL or BuildProductCode!="StandardCRM") then begin
    Black_Divider(270,480);
    StartFormat(15);
    GetBaseCurncy(1,tstr);
    OutString(270,0,USetStr(2713) & " " & tstr,false);
    OutVal(480,0,totar,M4Val,true);
    EndFormat;
    tmp = b12b2(CurrentDate,totar);
    StartFormat(15);
    GetBaseCurncy(2,tstr);
    OutString(270,0,USetStr(2713) & " " & tstr,false);
    OutVal(480,0,tmp,M4Val,true);
    EndFormat;
  end;
  StartFormat(10);
  EndFormat;
  RETURN;  
END;

global
procedure PrintSMSes(record CUVc CUr,Integer nrofsmses)
begin
  record SMSVc SMSr;
  Boolean found,firstf;
  Integer cnt,erstatus;
  record InternetEnablerBlock IEb;
  string 255 errstr,tstr;
  
  BlockLoad(IEb);
  cnt = 1;
  firstf = true;
  found = true;
  SMSr.CustCode = CUr.Code;
  while (LoopKey("CustCode",SMSr,1,found)) begin
    if (SMSr.CustCode!=CUr.Code) then begin
      found = false;
    end;
    if (cnt>nrofsmses) then begin
      found = false;
    end;
    if (found) then begin
      if (firstf) then begin
        StartFormat(15);
        OutString(0,0,USetStr(15222),false);
        EndFormat;
        Black_Divider(0,1);
        StartFormat(15);
        OutString(0,0,USetStr(6682),false);
        OutString(70,0,USetStr(6683),false);
        OutString(150,0,USetStr(7013),false);
        EndFormat;
        firstf = false;
        Gray_Divider(0,1);
      end;
      StartFormat(15);
       OutStringID(0,"DblSMSVc",SMSr.TransDate,false,SMSr.SerNr);
       OutString(70,0,SMSr.TransTime,false);
       erstatus = ERecordStatus(IEb.CustomerCode,CUr.Code,SMSr.SerNr,"SMSVc",errstr);
       switch (erstatus) begin
         case 5: tstr = USetStr(20225);
         case 4: tstr = USetStr(20224);
         case 3: tstr = USetStr(20223);
         case 2: tstr = USetStr(20222);
         case 1: tstr = USetStr(20221);
         case 0: tstr = USetStr(20220);
         case 18: tstr = USetStr(20224); //sent
         case 43: tstr = USetStr(17739); //pending
         case 45: tstr = USetStr(20239); //error
         otherwise
           tstr = errstr;
       end;
       OutString(150,0,tstr,false);
      EndFormat;
      cnt = cnt + 1;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

global
procedure PSFindPaydAmount(record IPrsVc IPrsp,var val ap)
BEGIN
  record IPVc IPr;
  row IPVc IPrw;
  Integer i,rwcnt;
  
  ap = 0;
  IPr.SerNr = IPrsp.TransNr;
  if (ReadFirstMain(IPr,1,true)) then begin
    if ((IPr.Invalid==0) and (IPr.RejectedFlag==0)) then begin
      rwcnt = MatRowCnt(IPr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IPr,i,IPrw);
        if (((IPrw.stp==1) or (IPrw.stp==5) or (IPrw.stp==6)) and (IPrw.ovst==0)) then begin
          if (IPrw.InvoiceNr==IPrsp.IVNr) then begin
            ap = ap + IPrw.InvVal;
          end;
        end;
      end;
    end;
  end;
  RETURN;
END;

procedure RepCQ(record RcVc RepSpec,record CQVc CQr)
begin
  Integer i,rwcnt;
  row CQVc CQrw;
  val s,q;
  
  StartFormat(15);
  OutLongInt(0,"DblCQVc",CQr.SerNr,false);
  OutDate(70,0,CQr.CQDate,false);
  OutVal(200,0,CQr.CustPrice,M4Val,true);
  OutString(320,0,CQr.ReferingTo,false);
  EndFormat;
  if (RepSpec.ArtMode==1) then begin
    rwcnt = MatRowCnt(CQr);
    for (i = 0 ; i<rwcnt ;i=i+1) begin
      MatRowGet(CQr,i,CQrw);
      StartFormat(15);
      OutString(50,0,CQrw.ArtCode,false);
      OutVal(150,0,CQrw.Quant,M4Qty,true);
      OutVal(250,0,CQrw.PeriodSum,M4Val,true);
      OutString(350,0,CQrw.Spec,false);
      EndFormat;
      q = q + CQrw.Quant;
      s = s + CQrw.PeriodSum;
    end;
    Gray_Divider(50,1);
    StartFormat(15);
    OutString(50,0,USetStr(13137),false);
    OutVal(250,0,q,M4Qty,true);
    OutVal(350,0,s,M4Val,true);
    EndFormat;
    StartFormat(10);
    EndFormat;
  end;
  return;
end;

global
procedure CQCUPSList(record RcVc RepSpec,string custcode,Integer nrofcq)
begin
  record CQVc CQr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  CQr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",CQr,1,found)) begin
    if (CQr.CustCode!=custcode) then begin found = false; end;
    if (nrofcq!=-1) then begin 
      if (count>=nrofcq) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2752),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(6682),false);
          OutString(200,0,USetStr(2328),true);
          OutString(320,0,USetStr(6685),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        RepCQ(RepSpec,CQr);
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

global
procedure PrintCUOR(record CUVc CUr,string orclass,Integer flags24)
begin
  Boolean firstf;
  record ORVc ORr;
  Boolean TrHs,testf;
  Integer ornr;

  firstf = true;
  TrHs = true;
  ORr.CustCode = CUr.Code;
  while (LoopBackKey("CustDate",ORr,1,TrHs)) begin
    if (ORr.CustCode!=CUr.Code) then begin
      TrHs = false;
    end;
    if (ornr>=flags24) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      testf = true;
      if (nonblank(orclass)) then begin
        if (ORr.OrderClass!=orclass) then begin
          testf = false;
        end;
      end;  
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2750),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(2623),false);
          OutString(200,0,USetStr(2328),true);
          OutString(210,0,USetStr(2638),false);
          OutString(400,0,USetStr(2696),false);
          EndFormat;    
          Gray_Divider(0,1);
          firstf = false;
        end;
        StartFormat(15);
        ornr = ornr + 1;
        OutString(0,"DblORVc",ORr.SerNr,false);
        OutDate(70,0,ORr.OrdDate,false);
        OutVal(200,0,ORr.Sum1,M4Val,true);
        OutString(210,0,ORr.PlanShip,false);
        if (ORr.Closed == 1) then begin
          OutString(400,0,USetStr(15212),false);
          goto LDone;
        end;
        if (ORr.ShipFlag==0) and (ORr.InvFlag==1) then begin
          OutString(400,0,USetStr(15215),false);
        end;
        if (ORr.ShipFlag!=0) and (ORr.InvFlag==0) then begin
          OutString(400,0,USetStr(15213),false);
        end;
        if (ORr.ShipFlag==0) and (ORr.InvFlag==0) then begin
          OutString(400,0,USetStr(15214),false);
        end;
        if (ORr.ShipFlag==0) and (ORr.InvFlag==2) then begin
          OutString(400,0,USetStr(15211),false);
        end;
        if (ORr.ShipFlag!=0) and (ORr.InvFlag==2) then begin
          OutString(400,0,USetStr(15210),false);
        end;
LDone:;
        EndFormat;        
      end;
    end;    
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;        
  end;
  return;
end;

global
procedure PRCUPSList(record RcVc RepSpec,string custcode,Integer nrofpr)
begin
  record PRVc PRr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  PRr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",PRr,1,found)) begin
    if (PRr.CustCode!=custcode) then begin found = false; end;
    if (nrofpr!=-1) then begin 
      if (count>=nrofpr) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2753),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(210,0,USetStr(3013),false);
          OutString(320,0,USetStr(6685),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        StartFormat(15);
        OutString(0,"DblPRVc",PRr.Code,false);
        OutString(210,0,"" & PRr.StartDate & "-" & PRr.EndDate,false);
        OutString(320,0,PRr.Name,false);
        EndFormat;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;


global
procedure RentResCUPSList(record RcVc RepSpec,string custcode,Integer nrofrentres)
begin
  record AgreementVc Agreementr;
  record RentResVc RentResr;
  Boolean found,foundagr;
  Integer count;
  Boolean testf,firstf;

  count = -1;
  firstf = true;
  Agreementr.CustCode = custcode;
  foundagr = true;
  while (LoopBackKey("CustCode",Agreementr,1,foundagr)) begin
    if (Agreementr.CustCode!=custcode) then begin foundagr = false; end;
    if (foundagr) then begin
      ResetLoop(RentResr);
      RentResr.AgreementNr = Agreementr.SerNr;
      found = true;
      while (LoopBackKey("AgreementNr",RentResr,1,found)) begin
        if (RentResr.AgreementNr!=Agreementr.SerNr) then begin found = false; end;
        if (nrofrentres!=-1) then begin 
          if (count>=nrofrentres) then begin found = false; foundagr = false; end;
        end;  
        if (found) then begin
          testf = true;
          if (testf) then begin
            if (firstf) then begin
              StartFormat(15);
              OutString(0,0,USetStr(2756),false);
              EndFormat;
              Black_Divider(0,1);
              StartFormat(15);
              OutString(0,0,USetStr(2741),false);
              OutString(70,0,USetStr(2623),false);
              OutString(200,0,USetStr(2328),true);
              OutString(210,0,USetStr(2638),false);
    //          OutString(400,0,USetStr(2696),false);
              EndFormat;
              Gray_Divider(0,1);
              firstf = false;
            end;      
            StartFormat(15);
            OutString(0,"DblRentResVc",RentResr.SerNr,false);
            OutDate(70,0,RentResr.TransDate,false);
            OutVal(200,0,RentResr.CommitedSum,M4Val,true);
            OutString(210,0,RentResr.InvItemName,false);
            EndFormat;
          end;
        end;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

global
procedure WSCUPSList(record RcVc RepSpec,string custcode,Integer nrofws)
begin
  record WSVc WSr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  WSr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",WSr,1,found)) begin
    if (WSr.CustCode!=custcode) then begin found = false; end;
    if (nrofws!=-1) then begin 
      if (count>=nrofws) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2757),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(2623),false);
          OutString(200,0,USetStr(2328),true);
          OutString(210,0,USetStr(2638),false);
//          OutString(400,0,USetStr(2696),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        StartFormat(15);
        OutString(0,"DblWSVc",WSr.SerNr,false);
        OutDate(70,0,WSr.TransDate,false);
        OutVal(200,0,WSr.Sum1,M4Val,true);
        OutString(210,0,WSr.Addr0,false);
        EndFormat;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

global
procedure SVOCUPSList(record RcVc RepSpec,string custcode,Integer nrofsvo)
begin
  record SVOVc SVOr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  SVOr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",SVOr,1,found)) begin
    if (SVOr.CustCode!=custcode) then begin found = false; end;
    if (nrofsvo!=-1) then begin 
      if (count>=nrofsvo) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2758),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(2623),false);
          OutString(200,0,USetStr(2328),true);
          OutString(210,0,USetStr(2638),false);
//          OutString(400,0,USetStr(2696),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        StartFormat(15);
        OutString(0,"DblSVOVc",SVOr.SerNr,false);
        OutDate(70,0,SVOr.TransDate,false);
        OutVal(200,0,SVOr.TotCost,M4Val,true);
        OutString(210,0,SVOr.PlanShip,false);
        EndFormat;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

global
procedure TBBUCUPSList(record RcVc RepSpec,string custcode,Integer nroftbbu)
begin
  record TBBUVc TBBUr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  TBBUr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",TBBUr,1,found)) begin
    if (TBBUr.CustCode!=custcode) then begin found = false; end;
    if (nroftbbu!=-1) then begin 
      if (count>=nroftbbu) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2754),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(2623),false);
          OutString(320,0,USetStr(6685),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        StartFormat(15);
        OutString(0,"DblTBBUVc",TBBUr.PRCode,false);
        OutDate(70,0,TBBUr.TransDate,false);
        OutString(320,0,TBBUr.PRName,false);
        EndFormat;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;

procedure RepAgreement(record RcVc RepSpec,record AgreementVc Agreementr)
BEGIN  
  StartFormat(15);
  OutLongInt(0,"DblAgreementVc",Agreementr.SerNr,false);
  OutDate(80,0,Agreementr.TransDate,false);
  OutDate(150,0,Agreementr.startDate,false);
  OutDate(220,0,Agreementr.endDate,false);
  OutString(290,0,Agreementr.InvComment,false);
  EndFormat;
  RETURN;
END;

global
procedure AgreementCUPSList(record RcVc RepSpec,string custcode,Integer nrofco,Integer notokd)
BEGIN
  record AgreementVc Agreementr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  Agreementr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",Agreementr,1,found)) begin
    if (Agreementr.CustCode!=custcode) then begin found = false; end;
    if (nrofco!=-1) then begin 
      if (count>=nrofco) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (Agreementr.OKFlag==0) then begin
        if (notokd==0) then begin testf = false; end;
      end;        
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2755),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(11409),false);
          OutString(80,0,USetStr(6682),false);
          OutString(150,0,USetStr(12876),false);
          OutString(220,0,USetStr(12877),false);
          OutString(290,0,USetStr(6685),false);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        RepAgreement(RepSpec,Agreementr);
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  RETURN;
END;

global
procedure PrintCUQT(record CUVc CUr,string qtclass,Integer flags22)
BEGIN
  Boolean firstf;
  record QTVc QTr;
  Boolean TrHs,testf;
  Integer qtnr;

  firstf = true;
  TrHs = true;
  QTr.CustCode = CUr.Code;
  while (LoopBackKey("CustDate",QTr,1,TrHs)) begin
    if (QTr.CustCode!=CUr.Code) then begin
      TrHs = false;
    end;
    if (qtnr>=flags22) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      testf = true;
      if (nonblank(qtclass)) then begin
        if (QTr.QuoteClass!=qtclass) then begin
          testf = false;
        end;
      end;  
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutStringID(420,"DblNewQT",USetStr(34503),false,QTr.CustCode);
          EndFormat;        
          StartFormat(15);
          OutString(0,0,USetStr(2749),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2741),false);
          OutString(70,0,USetStr(2623),false);
          OutString(200,0,USetStr(2328),true);
          OutString(210,0,USetStr(3550),false);
          OutString(260,0,USetStr(3522),false);
          OutString(310,0,USetStr(2696),false);
          OutString(355,0,USetStr(12446),false);
          EndFormat;    
          Gray_Divider(0,1);
          firstf = false;
        end;
        StartFormat(15);
        qtnr = qtnr + 1;
        OutString(0,"DblQTVc",QTr.SerNr,false);
        OutDate(70,0,QTr.QTDate,false);
        OutVal(200,0,QTr.Sum1,M4Val,true);
        OutStringID(210,"DblPRVc",QTr.PRCode,false,QTr.PRCode);
        if (QTr.OrderNr>0) then begin
          OutString(260,"DblORVc",QTr.OrderNr,false);
        end;
        switch (QTr.Rejected) begin
          case 0: OutString(310,0,USetStr(15219),false);
          case 1: OutString(310,0,USetStr(15220),false);
          case 2: OutString(310,0,USetStr(15221),false);
        end;
        OutString(355,0,QTr.Comment,false);
        EndFormat;        
      end;
    end;    
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;        
  end;
  RETURN;
END;

global
procedure PrintCuArtSTRn(record RcVc RepSpec,record CUVc CUr,LongInt nrofmonths)//37
BEGIN
  Date sd,ed;
  Boolean TrHs,firstf;
  record INVc INr;
  record ICSVc ICSr;
  val q,s,gp;
  val tq,ts,tgp;  

  firstf = true;
//  ed = AddMonth(CurrentDate,-1);
  ed = CurrentDate;
  ed = AddDay(ed,-GetDay(ed) + DaysInMonth(GetYear(ed),GetMonth(ed)));
  sd = AddMonth(ed,-nrofmonths+1);
  sd = AddDay(sd,-GetDay(sd)+1);
  TrHs = true;
  ICSr.CustCode = CUr.Code;
  while (LoopMain(ICSr,1,TrHs)) begin
    if (ICSr.CustCode!=CUr.Code) then begin TrHs = false; end;
    if (TrHs) then begin
      GetDateTurnover(ICSr.ArtCode,ICSr.Variety,CUr.Code,"","",ICSr,"quant",sd,ed,q,RepSpec.basecurncy);          
      GetDateTurnover(ICSr.ArtCode,ICSr.Variety,CUr.Code,"","",ICSr,"salesexclvat",sd,ed,s,RepSpec.basecurncy);
      GetDateTurnover(ICSr.ArtCode,ICSr.Variety,CUr.Code,"","",ICSr,"grossprofit",sd,ed,gp,RepSpec.basecurncy);
      if ((q!=0) or (s!=0)) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(2739),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(3523),false);
          OutString(100,0,USetStr(2702),false);
          OutString(300,0,USetStr(8683),true);
          OutString(360,0,USetStr(9151),true);
          if (UserCanAction("ViewCostPrice",true)) then begin
            OutString(420,0,USetStr(8688),true);
          end;
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;
        StartFormat(15);
        INr.Code = ICSr.ArtCode;
        if (ReadFirstMain(INr,1,true)) then begin end;
        OutString(0,"DblINVc",ICSr.ArtCode,false);//"DblCUINStat", of course, the parameters were wrong
        OutString(100,0,INr.Name,false);
        OutVal(300,0,q,M4Qty,true);
        OutVal(360,0,s,M4Val,true);
        if (UserCanAction("ViewCostPrice",true)) then begin
          OutVal(420,0,gp,M4Val,true);
        end;
        EndFormat;    
        ts = ts + s;
        tq = tq + q;
        tgp = tgp + gp;
      end;
    end;  
  end;  
  if (firstf==false) then begin
    Gray_Divider(50,1);
    StartFormat(15);
    OutString(50,0,USetStr(13137),false);
    OutVal(300,0,tq,M4Qty,true);
    OutVal(360,0,ts,M4Val,true);
    if (UserCanAction("ViewCostPrice",true)) then begin
      OutVal(420,0,tgp,M4val,true);
    end;
    EndFormat;
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  RETURN;
END;

global
procedure PrintCUMonthBal(record CUVc CUr)
BEGIN
  Integer i,rwcnt;
  Date sd,ed,td,td2;
  val s,gp;
  val tq,ts,tgp;
  Boolean firstf;
  
  firstf = true;
  ed = AddMonth(CurrentDate,0);//-1
  ed = AddDay(ed,-GetDay(ed) + DaysInMonth(GetYear(ed),GetMonth(ed)));
  
  sd = AddMonth(ed,-11);
  sd = AddDay(sd,-GetDay(sd)+1);
  for (td=sd;td<=ed;td=AddMonth(td,1)) begin
    td2 = AddMonth(td,1);
    td2 = AddDay(td2,-1);
    td2 = AddDay(td2,-GetDay(td2) + DaysInMonth(GetYear(td2),GetMonth(td2)));
    s = GetTurnover(CUr,"salesexclvat",td,td2);
    gp = GetTurnover(CUr,"grossprofit",td,td2);
    if (s!=0) then begin
      if (firstf) then begin
        StartFormat(15);
        OutString(0,0,USetStr(2738),false);
        EndFormat;
        Black_Divider(0,1);
        StartFormat(15);
        OutString(0,0,USetStr(2991),false);
        OutString(120,0,USetStr(9567),false);
        OutString(360,0,USetStr(9151),true);
        if (UserCanAction("ViewCostPrice",true)) then begin        
          OutString(420,0,USetStr(8688),true);
        end;
        EndFormat;
        Gray_Divider(0,1);
        firstf = false;
      end;
      StartFormat(15);
      OutString(0,0,USetStr(2780+GetMonth(td)),false);
      OutLongInt(120,0,GetYear(td),false);
      OutVal(360,0,s,M4Val,true);
      if (UserCanAction("ViewCostPrice",true)) then begin
        OutVal(420,0,gp,M4Val,true);
      end;
      EndFormat;
      ts = ts + s;
      tgp = tgp + gp;
    end;  
  end;
  if (firstf==false) then begin
    Gray_Divider(0,1);
    StartFormat(15);
    OutString(50,0,USetStr(13137),false);
    OutVal(360,0,ts,M4Val,true);
    if (UserCanAction("ViewCostPrice",true)) then begin
      OutVal(420,0,tgp,M4val,true);
    end;
    EndFormat;
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  RETURN;
END;

global
procedure CustPS_PrintAPPrepaymentAmount(string salescurrency,record IVVc IVp,var val bal,var val prepayp,var Boolean first) 
BEGIN
  row IVVc IVrw;
  Integer i,rwcnt;
  val amnt,amntb1;
  string 255 tstr;
  record ARPayHistVc ARHistr;

  rwcnt = MatRowCnt(IVp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVp,i,IVrw);
    switch (IVrw.stp) begin
      case kInvoiceRowTypePrepayment:
        ARHistr.CUPNr = IVrw.CUPNr;
        ARHistr.FileName = "IPVc";
        if (ReadFirstMain(ARHistr,2,true)==false) then begin 
          ARHistr.CUPNr = IVrw.CUPNr;
          ARHistr.FileName = "CLInVc";
          if (ReadFirstMain(ARHistr,2,true)==false) then begin end;
        end;
        amnt = IVrw.Sum;
        amntb1 = IVrw.BasePrice;
        if (amntb1==0) then begin
          amntb1 = MulRateToBase1(IVp.CurncyCode,amnt,IVp.FrRate,IVp.ToRateB1,IVp.ToRateB2,IVp.BaseRate1,IVp.BaseRate2,DefaultCurRoundOff);
        end;
        prepayp = prepayp + amnt;
        StartFormat(15);
        if (first) then begin
          tstr = CreateInvoiceNumber(IVp.SerNr,IVp.OfficialSerNr);
          OutString(0,"DblCustPS2",tstr,false);
          OutDate(70,0,IVp.InvDate,false);
          first = false;
        end;
        tstr = USetStr(2497);
        tstr = tstr & ":";
        tstr = tstr & IVrw.CUPNr;
        OutString(130,0,tstr,false);
        OutDate(220,0,IVp.InvDate,false);
        OutValBiDi(305,0,amnt,M4Val,true,355);
        OutStringBiDi(309,0,ARHistr.CurncyCode,false,320);
        if (nonblank(salescurrency)) then begin
          bal = bal - amnt;
        end else begin
          bal = bal - amntb1;
        end;
        OutValBiDi(380,0,bal,M4Val,true,420);
        EndFormat;
    end;
  end;
  RETURN;
END;

procedure SortCustClass(var Array string crpCode,var Array string crpComment,var Array string crpCType,var Array string crpTypeComment,Integer cnt)
BEGIN
  string 5 tempCode;
  string 60 tempComment;
  string 5 tempCType;
  string 60 tempTypeComment;
  Integer i,j,res;
  string 255 t1,t2;

  for (i = 0;i<cnt;i=i+1) begin
    for (j = i+1;j<cnt;j=j+1) begin
      res = -1;
      t1 = crpCType[i];
      t2 = crpCType[j];
      if (t1>=t2) then begin
        res = 1;
      end;
      if (res>=0) then begin
        if (res==0) then begin
          t1 = crpCode[i];
          t2 = crpCode[j];
          if (t1<=t2) then begin
            goto LSortCustClass;
          end;  
        end;    
        tempCode = crpCode[j];
        tempComment = crpComment[j];
        tempCType = crpCType[j];
        tempTypeComment = crpTypeComment[j];
        crpCode[j] = crpCode[i];
        crpComment[j] = crpComment[i];
        crpCType[j] = crpCType[i];
        crpTypeComment[j] = crpTypeComment[i];
        crpCode[i] = tempCode;
        crpComment[i] = tempComment;
        crpCType[i] = tempCType;
        crpTypeComment[i] = tempTypeComment;
LSortCustClass:;
      end;
    end;
  end;
  RETURN;
END;

global
procedure PrintCustClass(string aclass)
BEGIN
  Integer i,res;
  Array string 20 ac;
  record CClassVc CCr;
  record CTypeVc CTr;
  Array string 5 crCode;
  Array string 60 crComment;
  Array string 5 crCType;
  Array string 60 crTypeComment;
  Integer cnt;
  Boolean firstf;
  
  firstf = true;
  res = 1;
  SplitEclass(aclass,ac);
  for (i = 0; i<40; i=i+1) begin
    crCode[cnt] = "";
    crComment[cnt] = "";
    crCType[cnt] = "";
    crTypeComment[cnt] = "";
    if (nonblank(ac[i])) then begin
      CCr.Code = ac[i];
      if (ReadFirstMain(CCr,1,true)) then begin
        CTr.Code = CCr.CType;
        if (ReadFirstMain(CTr,1,true)) then begin
          crTypeComment[cnt] = CTr.Comment;
        end;  
        crComment[cnt] = CCr.Comment;
        crCType[cnt] = CCr.CType;
      end;
      crCode[cnt] = ac[i];
      cnt = cnt + 1;
    end;
  end;
  SortCustClass(crCode,crComment,crCType,crTypeComment,cnt);
  for (i = 0;i<cnt;i=i+1) begin
    if (firstf) then begin
      StartFormat(15);
       OutString(0,0,USetStr(2735),false);
      EndFormat;
      Black_Divider(0,1);
      firstf = false;
    end;
    StartFormat(15);
    OutString(30,0,crCode[i],false);
    OutString(70,0,crComment[i],false);
    OutString(280,0,crCType[i],false);
    OutString(320,0,crTypeComment[i],false);
    EndFormat;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  RETURN;
END;

global
procedure IVCashCUPSList(record RcVc RepSpec,string custcode,Integer nrofivcash)
begin
  record IVCashVc IVCashr;
  Boolean found;
  Integer count;
  Boolean testf,firstf;

  firstf = true;
  IVCashr.CustCode = custcode;
  found = true;
  while (LoopBackKey("CustCode",IVCashr,1,found)) begin
    if (IVCashr.CustCode!=custcode) then begin found = false; end;
    if (nrofivcash!=-1) then begin 
      if (count>=nrofivcash) then begin found = false; end;
    end;  
    if (found) then begin
      testf = true;
      if (testf) then begin
        if (firstf) then begin
          StartFormat(15);
          OutString(0,0,USetStr(24600),false);
          EndFormat;
          Black_Divider(0,1);
          StartFormat(15);
          OutString(0,0,USetStr(2706),false);
          OutString(70,0,USetStr(2707),false);
          OutString(200,0,USetStr(2926),true);
          OutString(270,0,USetStr(2927),true);
          OutString(340,0,USetStr(2928),true);
          EndFormat;
          Gray_Divider(0,1);
          firstf = false;
        end;      
        StartFormat(15);
        if (HasTouchScreenLook) then begin
          OutString(0,"DblNPTSIVCash",IVCashr.SerNr,false);
        end else begin
          OutString(0,"DblIVCashVc",IVCashr.SerNr,false);
        end;
        OutDate(70,0,IVCashr.TransDate,false);
        OutVal(200,0,IVCashr.Sum1,M4Val,true);
        OutVal(270,0,IVCashr.Sum3,M4Val,true);
        OutVal(340,0,IVCashr.Sum4,M4Val,true);
        EndFormat;
      end;
    end;
  end;
  if (firstf==false) then begin
    Black_Divider(0,1);
    StartFormat(15);
    EndFormat;
  end;
  return;
end;
