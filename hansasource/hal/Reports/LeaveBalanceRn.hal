external function LongInt DateDiff(Date,Date);
external function LongInt MonthDiff(Date,Date);
external procedure FindFiscalYear(Date,var Date,var Date);
external procedure vTimeDiff(Time,Time,var val);
external procedure HTDepartments(string,string,var string);
external procedure HTJobTitles(string,string,var string);
external procedure HTEmployees(string,string,var string);

procedure PrintHeader(record RcVc RepSpec)
begin
  Integer rw;
  string 255 tstr;
  string 255 fremp,toemp;

  fremp = FirstInRange(RepSpec.f1,20);
  toemp = LastInRange(RepSpec.f1,20);
  rw = 1;
  HTEmployees(fremp,toemp,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTJobTitles(RepSpec.f3,RepSpec.f3,tstr);
  Header(rw,tstr,0);
  HTDepartments(RepSpec.FirstAcc,RepSpec.FirstAcc,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  tstr = USetStr(19652) & ": " & USetStr(19653+RepSpec.flags[0]);
  Header(rw,tstr,0);
  if (nonblank(RepSpec.LastAcc)) then begin
    tstr = USetStr(19651) & ": " & RepSpec.LastAcc;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  if (nonblankdate(RepSpec.d1)) then begin
    tstr = RepSpec.d1;
    Header(rw,tstr,1);
    rw = rw + 1;
  end;
  return;
end;

function val CalculateDaysTaken(record RcVc RepSpec,string Employee,string acttype)
begin
  val res,timev;
  Boolean found,testf;
  record ActVc Actr;
  string 255 keystr;
  Date td,YearStartDate;
  Time timet,blanktimet;

  td.year = 1980;
  td.month = 1;
  td.day = 1;

//  switch (LeaveCalculationBase
//  kLeaveCalculationBaseCalendarYear
  YearStartDate = CurrentDate;
  YearStartDate.month = 1;
  YearStartDate.day = 1;

  keystr = "CUCodeTypeDate";
  Actr.CUCode = Employee;
  Actr.ActType = acttype;
  Actr.TransDate = YearStartDate;
  found = true;
  while (LoopKey(keystr,Actr,3,found)) begin
    if (Actr.CUCode!=Employee) then begin found = false; end;
    if (Actr.ActType!=acttype) then begin found = false; end;
    if (nonblankdate(RepSpec.d1)) then begin
      if (Actr.TransDate>RepSpec.d1) then begin found = false; end;
    end;
    if (found) then begin
      testf = true;
      if (Actr.OKFlag==0) then begin testf = false; end;
      if (Actr.Invalid!=0) then begin testf = false; end;
      if (testf) then begin
        timet = blanktimet;
        if (nonblanktime(Actr.CostTime)) then begin
          vTimeDiff(timet,Actr.CostTime,timev);
        end else begin
          vTimeDiff(Actr.EndTime,Actr.StartTime,timev);
        end;  
        res = res + timev/8.00;
      end;
    end;
  end;
LCalculateDaysTaken:;  
  CalculateDaysTaken = res;
  return;
end;

function val LeaveUsed(Date startdate,Date enddate,record HRMCOVc HRMCOr)
begin
  val res;
  Boolean found,testf; 
  record LeaveApplicationVc LAr;
  Date td;
  
  found = true;
  LAr.Employee = HRMCOr.Employee;
  while (LoopKey("Employee",LAr,1,found)) begin
    if (LAr.Employee!=HRMCOr.Employee) then begin
      found = false;
    end;
    if (found) then begin
      testf = true;
      if (DateInRange(LAr.StartDate,startdate,enddate)==false) then begin  testf = false; end;
//      if (LAr.StartDate>enddate) then begin  testf = false; end;
      if (LAr.OKFlag==0) then begin  testf = false; end;
      if (testf) then begin
        td = enddate;
        if (td>LAr.EndDate) then begin
          td = LAr.EndDate;
        end;
        res = res + DateDiff(td,LAr.StartDate) + 1;
      end;
    end;
  end;
  LeaveUsed = res;
  return;
end;

//similar to CalcluateLeaveApplicationFwdBalDays
function val CalculateLeaveTransfer(record LeaveSchemeVc LSr,row LeaveSchemeVc LSrw,record RcVc RepSpec,record HRMCOVc HRMCOr)
begin
  val res;
  record LeaveRulesBlock LRb;
  record LeaveTransferVc LTr;
  Boolean found;
  Date StartDate,EndDate,td,appldate,YearStartDate;
  Date sd,ed;
  val fwdbaldays,montshdiff,months;
  val daysdiff1,daysdiff2;
  Integer i,rwcnt;
  
  BlockLoad(LRb);
  if (LRb.AutTransferBalance!=0) then begin
    StartDate = HRMCOr.StartDate;
    appldate = RepSpec.d1;
    if (StartDate<appldate and StartDate.year<appldate.year) then begin
      appldate = StartDate;
      appldate.month = 12; appldate.day = 31;
    end;
    if (StartDate<appldate) and (appldate==RepSpec.d1) then begin
      goto LCalculateLeaveTransfer;
    end;
    YearStartDate = CurrentDate;
    YearStartDate.month = 1;
    YearStartDate.day = 1;
    if (appldate>YearStartDate) then begin
      appldate = AddDay(YearStartDate,-1);
    end;
    months = 12;
    
    sd = StartDate;
    if (sd.day!=1) then begin
      sd = AddMonth(sd,1);
      sd.day = 1;
    end;
    ed = appldate;
    if (ed.day!=DaysInMonth(ed.year,ed.month)) then begin
      ed = AddMonth(appldate,-1);
      ed.day = DaysInMonth(ed.year,ed.month);
    end;
    montshdiff = MonthDiff(sd,ed);
    
    daysdiff1 = DateDiff(sd,StartDate);
    if (daysdiff1<=0) then begin daysdiff1 = 0; end;
    daysdiff1 = daysdiff1/DaysInMonth(StartDate.year,StartDate.month);

    daysdiff2 = DateDiff(appldate,ed) - 1;
    if (daysdiff2<=0) then begin daysdiff2 = 0; end;
    daysdiff2 = daysdiff2/DaysInMonth(appldate.year,appldate.month);
  
    if (LSrw.BankHolidays==kIncludedinAllowance or LSrw.BankHolidays==kExcludedinAllowance) then begin
      fwdbaldays = fwdbaldays + (LSrw.Allowance*montshdiff)/months;
      fwdbaldays = fwdbaldays + (LSrw.Allowance*daysdiff1)/months;
      fwdbaldays = fwdbaldays + (LSrw.Allowance*daysdiff2)/months;
    end;  
    res = fwdbaldays - LeaveUsed(sd,YearStartDate,HRMCOr);    
  end else begin
    td = RepSpec.d1;
    if (blankdate(td)) then begin
      td = CurrentDate;
    end;
    StartDate = td;
    switch (LRb.LeaveCalculationBase) begin
      case kLeaveCalculationBaseCalendarYear:
        StartDate.month = 1;
        StartDate.day = 1;
        EndDate.month = 12;
        EndDate.day = 31;
      case kLeaveCalculationBaseFiscalYear:
        FindFiscalYear(td,StartDate,EndDate);  
    end;
    if (StartDate<HRMCOr.StartDate) then begin
      StartDate = HRMCOr.StartDate;
    end;
    LTr.Employee = HRMCOr.Employee;
    LTr.TransDate = StartDate;
    found = true;
    while (LoopKey("EmployeeDate",LTr,2,found)) begin
      if (LTr.Employee!=HRMCOr.Employee) then begin found = false; end;
      if (DateInRange(LTr.TransDate,StartDate,EndDate)==false) then begin
        found = false;
      end;
      if (LTr.TransDate>td) then begin found = false; end;
      if (found) then begin
        res = res + LTr.Days;
      end;
    end;
  end;
LCalculateLeaveTransfer:;  
  CalculateLeaveTransfer = res;
  return;
end;

function val AddHRMCOChanges(record LeaveSchemeVc LSr,row LeaveSchemeVc LSrw,record RcVc RepSpec,record HRMCOVc HRMCOr)
begin
  val res;
  record HRMCOChangeVc HRMCOCr;
  Boolean found;
  
  found = true;
  HRMCOCr.HRMCOSerNr = HRMCOr.SerNr;
  found = true;
  while (LoopKey("HRMCOSerNr:" & HRMCOr.SerNr,HRMCOCr,1,found)) begin
    if (HRMCOCr.LeaveFwdBalDate<=RepSpec.d1 and HRMCOCr.OKFlag!=0) then begin
      res = res + HRMCOCr.LeaveFwdBal;
    end;
  end;
  AddHRMCOChanges = res;
  return;
end;


function val CalculateAllowance(record LeaveSchemeVc LSr,row LeaveSchemeVc LSrw,record RcVc RepSpec,record HRMCOVc HRMCOr)
begin
  val res;
  record LeaveRulesBlock LRb;
  record LeaveTransferVc LTr;
  Boolean found;
  Date StartDate,EndDate,td,appldate,YearStartDate;
  Date sd,ed;
  val allowance,montshdiff,months;
  val daysdiff1,daysdiff2;
  Integer i,rwcnt;
  
  BlockLoad(LRb);
  appldate = RepSpec.d1;
  YearStartDate = CurrentDate;
  YearStartDate.month = 1;
  YearStartDate.day = 1;
/*
  if (appldate<YearStartDate) then begin
    goto LCalculateAllowance;
  end;
*/  
  months = 12;
  
  sd = HRMCOr.StartDate;
  if (sd<YearStartDate) and (appldate>YearStartDate) then begin
    sd = YearStartDate;
  end;
  if (sd.day!=1) then begin
    sd = AddMonth(StartDate,1);
    sd.day = 1;
  end;
  ed = appldate;
  if (HasLocalization("POL")==false) then begin
    if (ed.day!=DaysInMonth(ed.year,ed.month)) then begin
      ed = AddMonth(appldate,-1);
      ed.day = DaysInMonth(ed.year,ed.month);
    end;
  end;
  if (LRb.AutTransferBalance!=0) then begin
    if (sd.year!=ed.year) then begin
      sd.year = ed.year; sd.month = 1; sd.day = 1;
    end;
  end;

  montshdiff = MonthDiff(sd,ed);
  
  daysdiff2 = DateDiff(appldate,ed) - 1;
  if (daysdiff2<=0) then begin daysdiff2 = 0; end;
  daysdiff2 = daysdiff2/DaysInMonth(appldate.year,appldate.month);

  if (LSrw.BankHolidays==kIncludedinAllowance or LSrw.BankHolidays==kExcludedinAllowance) then begin
    allowance = allowance + (LSrw.Allowance*montshdiff)/months;
    allowance = allowance + (LSrw.Allowance*daysdiff2)/months;
  end;
  res = allowance;
LCalculateAllowance:;  
  CalculateAllowance = res;
  return;
end;

procedure LeaveBalance_Employee(record RcVc RepSpec,var val tlt,var val tall,var val tdta)
begin
  string 255 fremp,toemp;
  record HRMCOVc HRMCOr;
  Boolean found,testf;
  record LeaveSchemeVc LSr;
  row LeaveSchemeVc LSrw;
  Integer i,rwcnt;
  val daystaken,leavetransfer,allowance;

  fremp = FirstInRange(RepSpec.f1,20);
  toemp = LastInRange(RepSpec.f1,20);
  found = true;
  HRMCOr.Employee = fremp;
  while (LoopKey("Employee",HRMCOr,1,found)) begin
    if (nonblank(RepSpec.f1)) then begin
      if (HRMCOr.Employee>toemp) then begin found = false; end;
    end;
    if (found) then begin
      testf = true;
      if (nonblank(RepSpec.FirstAcc)) then begin
        if (HRMCOr.DepCode!=RepSpec.FirstAcc) then begin testf = false; end;
      end;
      if (nonblank(RepSpec.f3)) then begin
        if (HRMCOr.JobTitle!=RepSpec.f3) then begin testf = false; end;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (HRMCOr.StartDate>RepSpec.d1) then begin testf = false; end;
      end;
      if (testf) then begin
        StartFormat(15);
         OutString(0,0,USetStr(19653) & ": ",false);
         OutString(50,0,HRMCOr.Employee,false);
         OutString(100,0,HRMCOr.Name,false);
         OutString(360,0,USetStr(19655) & ": ",false);
         OutString(420,0,HRMCOr.SerNr,false);
        EndFormat;
        Gray_Divider(0,1);        
        LSr.Code = HRMCOr.LeaveScheme;
        ReadFirstMain(LSr,1,true);
        rwcnt = MatRowCnt(LSr);
        StartFormat(15);
         OutString(15,0,USetStr(19656),false);
         OutString(2,0,USetStr(19657),false);
         OutString(3,0,USetStr(19658),true);
         OutString(4,0,USetStr(19659),true);
         OutString(5,0,USetStr(19660),true);
         OutString(6,0,USetStr(19661),true);
         OutString(1,0,USetStr(19662),true);
        EndFormat;
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(LSr,i,LSrw);
          StartFormat(15);
           OutString(15,0,LSrw.ActType,false);
           OutString(2,0,LSrw.Comment,false);
           if (i==0 and nonblank(HRMCOr.LeaveFwdBal) and (HRMCOr.LeaveFwdBalDate<=RepSpec.d1)) then begin
             leavetransfer = HRMCOr.LeaveFwdBal;
           end else begin
             leavetransfer = CalculateLeaveTransfer(LSr,LSrw,RepSpec,HRMCOr);
           end;
           leavetransfer = leavetransfer + AddHRMCOChanges(LSr,LSrw,RepSpec,HRMCOr);
           allowance = CalculateAllowance(LSr,LSrw,RepSpec,HRMCOr);
           OutVal(3,0,leavetransfer,M4Qty,true);
           OutVal(4,0,allowance,M4Qty,true);
           OutVal(5,0,allowance+leavetransfer,M4Qty,true);
           daystaken = CalculateDaysTaken(RepSpec,HRMCOr.Employee,LSrw.ActType);
           OutVal(6,0,daystaken,M4Qty,true);
           OutVal(1,0,allowance+leavetransfer-daystaken,M4Qty,true);
          EndFormat;
          tlt = tlt + leavetransfer;
          tall = tall + allowance;
          tdta = tdta + daystaken;
        end;
 
        Gray_Divider(0,1);        
        StartFormat(15);
        EndFormat;
      end;
    end;
  end;
  return;
end;

procedure LeaveBalance_LeaveType_PerActType(record RcVc RepSpec,string leaveacttype,var val tlt,var val tall,var val tdta)
begin
  string 255 fremp,toemp;
  record HRMCOVc HRMCOr;
  Boolean found,testf;
  record LeaveSchemeVc LSr;
  row LeaveSchemeVc LSrw;
  Integer i,rwcnt;
  val daystaken,leavetransfer,allowance;
  Boolean headerprntedf;

  fremp = FirstInRange(RepSpec.f1,20);
  toemp = LastInRange(RepSpec.f1,20);
  found = true;
  HRMCOr.Employee = fremp;
  while (LoopKey("Employee",HRMCOr,1,found)) begin
    if (nonblank(RepSpec.f1)) then begin
      if (HRMCOr.Employee>toemp) then begin found = false; end;
    end;
    if (found) then begin
      testf = true;
      if (nonblank(RepSpec.FirstAcc)) then begin
        if (HRMCOr.DepCode!=RepSpec.FirstAcc) then begin testf = false; end;
      end;
      if (nonblank(RepSpec.f3)) then begin
        if (HRMCOr.JobTitle!=RepSpec.f3) then begin testf = false; end;
      end;
      if (nonblankdate(RepSpec.d1)) then begin
        if (HRMCOr.StartDate>RepSpec.d1) then begin testf = false; end;
      end;
      if (testf) then begin
        LSr.Code = HRMCOr.LeaveScheme;
        ReadFirstMain(LSr,1,true);
        rwcnt = MatRowCnt(LSr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(LSr,i,LSrw);
          if (LSrw.ActType==leaveacttype) then begin
            if (headerprntedf==false) then begin
              StartFormat(15);
               OutString(15,0,USetStr(19653),false);
               OutString(2,0,USetStr(19663),false);
               OutString(3,0,USetStr(19658),true);
               OutString(4,0,USetStr(19659),true);
               OutString(5,0,USetStr(19660),true);
               OutString(6,0,USetStr(19661),true);
               OutString(1,0,USetStr(19662),true);
              EndFormat;
              headerprntedf = true;
            end;
            StartFormat(15);
             OutString(15,0,HRMCOr.Employee,false);
             OutString(2,0,HRMCOr.Name,false);
             leavetransfer = CalculateLeaveTransfer(LSr,LSrw,RepSpec,HRMCOr);
             allowance = CalculateAllowance(LSr,LSrw,RepSpec,HRMCOr);
             OutVal(3,0,leavetransfer,M4Qty,true);
             OutVal(4,0,allowance,M4Qty,true);
             OutVal(5,0,allowance+leavetransfer,M4Qty,true);
             daystaken = CalculateDaysTaken(RepSpec,HRMCOr.Employee,LSrw.ActType);
             OutVal(6,0,daystaken,M4Qty,true);
             OutVal(1,0,allowance+leavetransfer-daystaken,M4Qty,true);
            EndFormat;
            tlt = tlt + leavetransfer;
            tall = tall + allowance;
            tdta = tdta + daystaken;
            i = rwcnt;
          end;
        end; 
      end;
    end;
  end;
  return;
end;

procedure SortLeaveSchemeArray(record LeaveSchemeVc LSr)
begin
  row LeaveSchemeVc LSrw;
  row LeaveSchemeVc LS2rw;
  row LeaveSchemeVc tmpLSrw;
  Integer i,rwcnt;
  Boolean testf;

  testf = true;
  while (testf) begin
    testf = false;
    rwcnt = MatRowCnt(LSr);
    for (i=0;i<rwcnt-1;i=i+1) begin
      MatRowGet(LSr,i,LSrw);
      MatRowGet(LSr,i+1,LS2rw);
      if (LSrw.ActType>LS2rw.ActType) then begin
        MatRowPut(LSr,i,LS2rw);
        MatRowPut(LSr,i+1,LSrw);
        testf = true;
      end;
    end;
  end;
  return;
end;

procedure AddToLeaveSchemeArray(record LeaveSchemeVc LSr,row LeaveSchemeVc addLSrw)
begin
  row LeaveSchemeVc LSrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(LSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LSr,i,LSrw);
    if (addLSrw.ActType==LSrw.ActType) then begin
      goto LAddToLeaveSchemeArray;
    end;
  end;  
  MatRowPut(LSr,MatRowCnt(LSr),addLSrw);
LAddToLeaveSchemeArray:;        
  return;
end;

procedure LeaveBalance_LeaveType(record RcVc RepSpec,var val tlt,var val tall,var val tdta)
begin
  string 255 fremp,toemp;
  Boolean found,testf;
  record LeaveSchemeVc LSr;
  record LeaveSchemeVc combinedLSr;
  row LeaveSchemeVc LSrw;
  Integer i,rwcnt;

  fremp = FirstInRange(RepSpec.f1,20);
  toemp = LastInRange(RepSpec.f1,20);
  found = true;
  while (LoopMain(LSr,1,found)) begin
    if (found) then begin
      rwcnt = MatRowCnt(LSr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(LSr,i,LSrw);
        AddToLeaveSchemeArray(combinedLSr,LSrw);
      end;
    end;
  end;
  rwcnt = MatRowCnt(combinedLSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(combinedLSr,i,LSrw);
    StartFormat(15);
     OutString(0,0,USetStr(19656) & ": ",false);
     OutString(50,0,LSrw.ActType,false);
     OutString(360,0,USetStr(19657) & ": ",false);
     OutString(420,0,LSrw.Comment,false);
    EndFormat;
    Gray_Divider(0,1);        
    LeaveBalance_LeaveType_PerActType(RepSpec,LSrw.ActType,tlt,tall,tdta);
    Gray_Divider(0,1);        
    StartFormat(15);
    EndFormat;
  end;
  SortLeaveSchemeArray(combinedLSr);
  return;
end;

global
procedure LeaveBalanceRn(record RcVc RepSpec)
begin
  val tlt,tall,tdta;
  
  if (blankdate(RepSpec.d1)) then begin
    RepSpec.d1 = CurrentDate;
    RepSpec.d1 = AddDay(RepSpec.d1,-GetDay(RepSpec.d1)+DaysInMonth(GetYear(RepSpec.d1),GetMonth(RepSpec.d1)));
  end;
  StartReportJob(USetStr(19650));
   PrintHeader(RepSpec);
  EndHeader;
  if (RepSpec.wholemonthf==0) then begin
    StartFormat(15);
     OutString(0,0,USetStr(1163),false);     
    EndFormat;
    goto LLeaveBalanceRn;
  end;
  SetRepCol(2,65);
  SetRepCol(3,280);
  SetRepCol(4,330);
  SetRepCol(5,380);
  SetRepCol(6,430);
  switch (RepSpec.flags[0]) begin
    case 0: LeaveBalance_Employee(RepSpec,tlt,tall,tdta);
    case 1: LeaveBalance_LeaveType(RepSpec,tlt,tall,tdta);
  end;
  Gray_Divider(0,1);
  StartFormat(15);
   OutVal(3,0,tlt,M4Qty,true);
   OutVal(4,0,tall,M4Qty,true);
   OutVal(5,0,tall+tlt,M4Qty,true);
   OutVal(6,0,tdta,M4Qty,true);
   OutVal(1,0,tall+tlt-tdta,M4Qty,true);
  EndFormat;
LLeaveBalanceRn:;  
  EndJob;
  return;
end;