procedure AddToList(var string list,string add)begin  if (list<>"") then begin    list = list & ", ";  end;    list = list & add;end;function string 255 AddToList2(string list,string add)begin  string 255 res;    if (list<>"") then begin    res = list & ",";  end;    res = res & add;    AddToList2 = res;end;function string 255 AccessToString(Integer access)begin  string 255 res;    res = access;    switch (access) begin    case kAccessLevelDummy: res = "dummy";    case kAccessLevelFull: res = "full";    case kAccessLevelReadOnly: res = "read-only";    case kAccessLevelReadNew: res = "read & new";    case kAccessLevelLimited: res = "limited";    case kAccessLevelNone: res = "none";    case kAccessLevelBrowse: res = "browse";    case kAccessLevelBrowseNew: res = "browse & new";  end;    AccessToString = res;end;function string 255 CanBreakOut(record AccessVc Accessr,Integer startlevel)begin  string 255 res;  Integer level;    if (GetAccessForAccessGroup(Accessr,kAccessTypeModule,"modSY","",startlevel)==kAccessLevelFull) then begin    level = GetAccessForAccessGroup(Accessr,kAccessTypeRegister,"UserVc","",startlevel);    if (level<kAccessLevelNone and level<>kAccessLevelReadOnly) then begin      AddToList(res,"System>>Persons (" & AccessToString(level) & ")");    end;    level = GetAccessForAccessGroup(Accessr,kAccessTypeSetting,"AccessLClass","",startlevel);    if (level<kAccessLevelNone and level<>kAccessLevelReadOnly) then begin      AddToList(res,"System>>Access Groups (" & AccessToString(level) & ")");    end;    level = GetAccessForAccessGroup(Accessr,kAccessTypeSetting,"OneFunctionLClass","",startlevel);    if (level<kAccessLevelNone and level<>kAccessLevelReadOnly) then begin      AddToList(res,"System>>Single Functions (" & AccessToString(level) & ")");    end;  end;  if (GetAccessForAccessGroup(Accessr,kAccessTypeModule,"modTC","",startlevel)==kAccessLevelFull) then begin    level = GetAccessForAccessGroup(Accessr,kAccessTypeRegister,"GlobalUserVc","",startlevel);    if (level<kAccessLevelNone) then begin      AddToList(res,"Technics>>Global Users (" & AccessToString(level) & ")");    end;  end;/*  level = GetAccessForAccessGroup(Accessr,kAccessTypeAction,"InstallHalcust","",startlevel);  if (level<kAccessLevelNone) then begin    AddToList(res,"Install Halcust (" & AccessToString(level) & ")");  end;*/  CanBreakOut = res;end;globalprocedure AccessCheckRn(record RcVc RepSpec)begin  vector string 255 hasaccess;  vector Boolean guserf;  vector string 255 ufullname;  vector string 255 globcomps;  record GlobalUserVc GUr;  record UserVc USr;  record AccessVc Accessr;  Integer startlevel,oldcomp,rwcnt,i;  record CompaniesBlock Cb;  array string 255 allusers;  string 255 uname,compno;  LongInt pos;  Integer cnt;  string 255 acstr;  BlockLoad(Cb);  oldcomp = CurrentCompany;      StartReportJob("Access Check");  EndHeader;    SetRepCol(3,80);  SetRepCol(4,120);  SetRepCol(5,160);  StartFormat(15);  OutString(0,0,"Name",false);  OutString(3,0,"Signature",false);  OutString(4,0,"Companies",false);  OutString(5,0,"Access",false);  EndFormat;  StartFormat(1);  Black_divider(0,1);  EndFormat;    rwcnt = MatRowCnt(Cb);    for (i = 0; i<rwcnt; i = i + 1) begin    if (SetCompany(i + 1,false)) then begin      GUr.Code = "";      ResetLoop(GUr);      while (LoopMain(GUr,1,true)) begin        guserf[GUr.Code] = true;        if (GUr.Closed==0) then begin          if (AccessForUser(GUr.Code,Accessr,startlevel)) then begin            acstr = CanBreakOut(Accessr,startlevel);            hasaccess[GUr.Code] = acstr;            ufullname[GUr.Code] = GUr.Name;            globcomps[GUr.Code] = AddToList2(globcomps[GUr.Code],"" & i + 1);          end;        end;      end;		        USr.Code = "";      ResetLoop(USr);      while (LoopMain(USr,1,true)) begin        if (guserf[USr.Code]==false and USr.Closed==0) then begin          if (AccessForUser(USr.Code,Accessr,startlevel)) then begin            acstr = CanBreakOut(Accessr,startlevel);            hasaccess[USr.Code & ":" & i + 1] = acstr;            ufullname[USr.Code & ":" & i + 1] = USr.Name;          end;        end;      end;    end;  end;	  GetVectorTags(hasaccess,allusers);	SortStringArray(allusers);	  for (i = 0; i<allusers.length; i = i + 1) begin    if (nonblank(hasaccess[allusers[i]])) then begin      pos = -1;      GetNextSubstring(allusers[i],pos,":",uname);      GetNextSubstring(allusers[i],pos,":",compno);      StartFormat(15);      OutString(0,0,ufullname[allusers[i]],false);      OutStringID(3,"DblAccessCheckRn",uname,false,allusers[i]);      if (compno<>"") then begin        //stopalert("compno >>" & compno & "<<");        OutString(4,0,compno,false);      end else begin        OutString(4,0,globcomps[allusers[i]],false);          end;      OutString(5,0,hasaccess[allusers[i]],false);      EndFormat;      cnt = cnt + 1;    end;  end;  StartFormat(1);  Gray_divider(0,1);  EndFormat;   StartFormat(15);  OutString(0,0,"Total: " & cnt & " users",false);  EndFormat;    /*  StartFormat(15);  EndFormat;  StartFormat(15);  OutString(0,0,"Legend",false);  EndFormat;  StartFormat(1);  Gray_divider(0,1);  EndFormat;  StartFormat(15);  OutString(0,0,"Level " & kAccessLevelFull & " = " & StringFromSet(1,kAccessLevelFull),false);  OutString(0,0,"Level " & kAccessLevelReadOnly & " = " & StringFromSet(1,kAccessLevelReadOnly),false);  OutString(0,0,"Level " & kAccessLevelReadNew & " = " & StringFromSet(1,kAccessLevelReadNew),false);  OutString(0,0,"Level " & kAccessLevelBrowse & " = " & StringFromSet(1,kAccessLevelBrowse),false);  OutString(0,0,"Level " & kAccessLevelBrowseNew & " = " & StringFromSet(1,kAccessLevelBrowseNew),false);  EndFormat;  */    EndJob;  ResetCompany(oldcomp);    return;end;