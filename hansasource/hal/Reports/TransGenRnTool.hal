external function Integer MakeTransFromPU(record TRVc,record PUVc,record LocationVc,Boolean);
external function Integer MakeTransFromSR(record TRVc,record SRVc,Boolean,var string,var Integer);
external function Integer MakeTransFromIntIV(var record TRVc,record IntIVVc,Boolean);
external function Integer MakeTransFromOwnCheck(record TRVc,var record OwnCheckVc,Boolean,Boolean);
external function Integer MakeTransFromCheck(record TRVc,var record CheckVc,Boolean);
external function Integer MakeTransFromWrof(record TRVc,record AT2WrofVc,Boolean,var string,var Integer);
external function Integer MakeTransFromWS(record TRVc,record WSVc,Boolean);
external function Integer MakeTransFromProd(record TRVc,record ProdVc,Boolean);
external function Integer MakeTransFromRetPU(record TRVc,record RetPUVc,Boolean);
external function Integer MakeTransFromINTransfer(record TRVc,record INTransferVc,Boolean);
external procedure PrintTrrTransGen(record RcVc,record TRVc,LongInt,record TRVc,record SMVc,var val,Integer,Integer);

global
procedure TransGenRnINTransferVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record INTransferVc INTransferr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row INTransferVc INTransferrw;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  INTransferr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",INTransferr,1,TrHs)) begin
    if (TrHs) then begin
      if (INTransferr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (INTransferr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (INTransferr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (INTransferr.SerNr<frnr) then begin testf = false; end;
      if (INTransferr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,INTransferr.SerNr,false);
      OutDate(60,0,INTransferr.TransDate,false);
      OutString(140,0,INTransferr.FrLocation,false);
      OutString(240,0,INTransferr.Location,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(INTransferr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(INTransferr,i,INTransferrw);
          sum = sum + INTransferrw.FIFORowVal;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromINTransfer(TRr,INTransferr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,INTransferYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnRetPUVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record RetPUVc RetPUr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row RetPUVc RetPUrw;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  RetPUr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",RetPUr,1,TrHs)) begin
    if (TrHs) then begin
      if (RetPUr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (RetPUr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (RetPUr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (RetPUr.SerNr<frnr) then begin testf = false; end;
      if (RetPUr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,RetPUr.SerNr,false);
      OutDate(60,0,RetPUr.TransDate,false);
      OutString(140,0,RetPUr.VECode,false);
      OutString(240,0,RetPUr.VEName,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(RetPUr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(RetPUr,i,RetPUrw);
          sum = sum + RetPUrw.FIFORowVal;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromRetPU(TRr,RetPUr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,RetPUYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnProdVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record ProdVc Prodr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row ProdVc Prodrw;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  Prodr.ProdDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("ProdDate",Prodr,1,TrHs)) begin
    if (TrHs) then begin
      if (Prodr.ProdDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (Prodr.PRStatusFlag==3) or (Prodr.PRStatusFlag==5) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (Prodr.PRStatusFlag!=3) and (Prodr.PRStatusFlag!=5) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (Prodr.SerNr<frnr) then begin testf = false; end;
      if (Prodr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,Prodr.SerNr,false);
      OutDate(60,0,Prodr.ProdDate,false);
      OutString(140,0,Prodr.Person,false);
      OutString(240,0,Prodr.Comment,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(Prodr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(Prodr,i,Prodrw);
          sum = sum + Prodrw.ItemCost;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromProd(TRr,Prodr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,ProdYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnWSVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record WSVc WSr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row WSVc WSrw;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  WSr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",WSr,1,TrHs)) begin
    if (TrHs) then begin
      if (WSr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (WSr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (WSr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (WSr.SerNr<frnr) then begin testf = false; end;
      if (WSr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,WSr.SerNr,false);
      OutDate(60,0,WSr.TransDate,false);
      OutString(140,0,WSr.EMCode,false);
      OutString(240,0,WSr.EMName,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(WSr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(WSr,i,WSrw);
          sum = sum + WSrw.FIFORowVal;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromWS(TRr,WSr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,WSYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnAT2WrofVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record AT2WrofVc AT2Wrofr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt,gotorow;
  row AT2WrofVc AT2Wrofrw;
  val sum;
  LongInt frnr,tonr;
  string 255 gotofield;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  AT2Wrofr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",AT2Wrofr,1,TrHs)) begin
    if (TrHs) then begin
      if (AT2Wrofr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (AT2Wrofr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (AT2Wrofr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (AT2Wrofr.SerNr<frnr) then begin testf = false; end;
      if (AT2Wrofr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,AT2Wrofr.SerNr,false);
      OutDate(60,0,AT2Wrofr.TransDate,false);
      OutString(140,0,AT2Wrofr.RefStr,false);
      OutString(240,0,AT2Wrofr.Account,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(AT2Wrofr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(AT2Wrofr,i,AT2Wrofrw);
          sum = sum + AT2Wrofrw.SalesVal;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromWrof(TRr,AT2Wrofr,true,gotofield,gotorow); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,AT2WrofYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnCheckVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record CheckVc Checkr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  Checkr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",Checkr,1,TrHs)) begin
    if (TrHs) then begin
      if (Checkr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (Checkr.Openf!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (Checkr.Openf==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (Checkr.SerNr<frnr) then begin testf = false; end;
      if (Checkr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,Checkr.SerNr,false);
      OutDate(60,0,Checkr.TransDate,false);
      OutString(140,0,Checkr.BankCode,false);
      OutString(240,0,Checkr.BankName,false);
      if (RepSpec.ArtMode==1) then  begin
        OutVal(450,0,Checkr.Amount,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromCheck(TRr,Checkr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,CheckYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnOwnCheckVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record OwnCheckVc OwnCheckr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  OwnCheckr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",OwnCheckr,1,TrHs)) begin
    if (TrHs) then begin
      if (OwnCheckr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (OwnCheckr.Openf!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (OwnCheckr.Openf==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (OwnCheckr.SerNr<frnr) then begin testf = false; end;
      if (OwnCheckr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,OwnCheckr.SerNr,false);
      OutDate(60,0,OwnCheckr.TransDate,false);
      OutString(140,0,OwnCheckr.VECode,false);
      OutString(240,0,OwnCheckr.VEName,false);
      if (RepSpec.ArtMode==1) then  begin
        OutVal(450,0,OwnCheckr.Amount,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromOwnCheck(TRr,OwnCheckr,true,false); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,OwnCheckYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnIntIVVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record IntIVVc IntIVr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row IntIVVc IntIVrw;
  val sum;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  IntIVr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",IntIVr,1,TrHs)) begin
    if (TrHs) then begin
      if (IntIVr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (IntIVr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (IntIVr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (IntIVr.SerNr<frnr) then begin testf = false; end;
      if (IntIVr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,IntIVr.SerNr,false);
      OutDate(60,0,IntIVr.TransDate,false);
      OutString(140,0,IntIVr.SalesMan,false);
      OutString(240,0,IntIVr.Name,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(IntIVr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IntIVr,i,IntIVrw);
          sum = sum + IntIVrw.Sum;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromIntIV(TRr,IntIVr,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,IntIVYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  RETURN;
END;

global
procedure TransGenRnSRVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
begin
  record SRVc SRr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  Integer i,rwcnt;
  row SRVc SRrw;
  val sum;
  LongInt frnr,tonr;
  string 255 errofield;
  Integer errorrow;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);    
  SRr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",SRr,1,TrHs)) begin
    if (TrHs) then begin
      if (SRr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (SRr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (SRr.OKFlag==0) then begin
          testf = true;
        end;
      end;
    end;
    if (nonblank(RepSpec.f1)) then begin
      if (SRr.SerNr<frnr) then begin testf = false; end;
      if (SRr.SerNr>tonr) then begin testf = false; end;
    end;    
    if (testf) then begin
      sum = blankval;
      invalid = -1;
      StartFormat(15);
      OutLongInt(0,0,SRr.SerNr,false);
      OutDate(60,0,SRr.TransDate,false);
      OutString(240,0,SRr.Comment,false);
      if (RepSpec.ArtMode==1) then  begin
        rwcnt = MatRowCnt(SRr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(SRr,i,SRrw);
          sum = sum + SRrw.FIFORowVal;
        end;
        OutVal(450,0,sum,M4Val,true);
      end;
      EndFormat;
      trans = MakeTransFromSR(TRr,SRr,true,errofield,errorrow); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,SRYc,0);
      end;
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;            
    end;
  end;  
  return;
end;

global
procedure TransGenRnPUVc(record RcVc RepSpec,record TRVc TRTotr,record SMVc VATr,var val TotSum)
BEGIN
  record MainStockBlock MainStockRec;
  record LocationVc LocRec;
  record PUVc PUr;
  record TRVc TRr;
  Boolean TrHs,testf;
  LongInt invalid;
  Integer trans;
  LongInt frnr,tonr;

  frnr = FirstInRange(RepSpec.f1,10);
  tonr = LastInRange(RepSpec.f1,10);  
  BlockLoad(MainStockRec);
  PUr.TransDate = RepSpec.sStartDate;
  TrHs = true;
  while (LoopKey("TransDate",PUr,1,TrHs)) begin
    if (TrHs) then begin
      if (PUr.TransDate>RepSpec.sEndDate) then begin
        TrHs = false;
      end;
    end;
    testf = TrHs;
    if (TrHs) then begin
      testf = false;
      if (RepSpec.flags[1]!=0) then begin
        if (PUr.OKFlag!=0) then begin
          testf = true;
        end;
      end;
      if (RepSpec.flags[2]!=0) then begin
        if (PUr.OKFlag==0) then begin
          testf = true;
        end;
      end;
      if (nonblank(RepSpec.f1)) then begin
        if (PUr.SerNr<frnr) then begin testf = false; end;
        if (PUr.SerNr>tonr) then begin testf = false; end;
      end;
    end;
    if (testf) then begin
      invalid = -1;      
      if (PUr.Invalid!=0) then begin
        invalid = 1;
      end;
      StartFormat(15);
      OutLongInt(0,0,PUr.SerNr,false);
      OutDate(60,0,PUr.TransDate,false);
      OutString(140,0,PUr.VECode,false);
      OutString(240,0,PUr.VEName,false);
      if (RepSpec.ArtMode==1) then begin
        OutVal(1,0,PUr.SumCostPrice,M4Val,true);
      end;
      EndFormat;
      LocRec.Code = PUr.Location;
      if (blank(LocRec.Code)) then begin
        LocRec.Code = MainStockRec.MainStock;
      end;      
      if (ReadFirstMain(LocRec,1,true)) then begin
      end;      
      trans = MakeTransFromPU(TRr,PUr,LocRec,true); 
      if (trans==0) then begin
        PrintTrrTransGen(RepSpec,TRr,invalid,TRTotr,VATr,TotSum,PUYc,0);
      end;  
      if (RepSpec.ArtMode==0) then begin
        Gray_Divider(0,1);
      end;          
    end;
  end;  
  RETURN;
END;
