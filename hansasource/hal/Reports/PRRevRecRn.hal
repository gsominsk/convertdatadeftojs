external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure HTCusts(string, string, var string);
external procedure HTProjSort2(Integer,var string);
external procedure HTPRClass(string, var string);
external procedure FindDautherProjects(string,var array string,var integer);

procedure HTProjects(string arg,var string res)
begin
  string 255 a,b;
  record PRVc PRr;

  a = FirstInRange(arg,20);
  b = LastInRange(arg,20);
  if (blank(a) and blank(b)) then begin
    res = USetStr(4851);
  end else begin
    res = USetStr(4852);
    res = res & a;
    if (a<>b) then begin
      res = res & " : ";
      res = res & b;
    end else begin
      PRr.Code = a;
      if (ReadFirstMain(PRr,1,true)) then begin
        res = res & " ";
        res = res & PRr.Name;
      end;
    end;
  end;
  return;
end;

procedure Blankspace(Integer pix)
begin
  StartFormat(pix);
  EndFormat;
  return;
end;

procedure SumProjectBudget(Integer amincur,string project,var val bp,var val tt,var val to,var val tm,var val ts)
begin
  record TBBUVc TBBr;
  Boolean found;

  TBBr.PRCode = project;
  found = true;
  if (ReadFirstMain(TBBr,1,true)) then begin
    if (amincur==0) then begin
      tt = tt + MulRateToBase1(TBBr.CurncyCode,TBBr.SumTime,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff);
      to = to + MulRateToBase1(TBBr.CurncyCode,TBBr.SumOther,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff);
      tm = to + MulRateToBase1(TBBr.CurncyCode,TBBr.SumMaterial,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff);
      ts = to + MulRateToBase1(TBBr.CurncyCode,TBBr.SumStocked,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff);

      bp = bp + MulRateToBase1(TBBr.CurncyCode,TBBr.SumTime,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff)
              + MulRateToBase1(TBBr.CurncyCode,TBBr.SumOther,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff)
              + MulRateToBase1(TBBr.CurncyCode,TBBr.SumMaterial,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff)
              + MulRateToBase1(TBBr.CurncyCode,TBBr.SumStocked,TBBr.FrRate,TBBr.ToRateB1,TBBr.ToRateB2,TBBr.BaseRate1,TBBr.BaseRate2,DefaultCurRoundOff);
    end else begin
      tt = tt+TBBr.SumTime;
      to = to+TBBr.SumOther;
      tm = tm+TBBr.SumMaterial;
      ts = ts+TBBr.SumStocked;        
      bp = bp+TBBr.SumTime + TBBr.SumOther +TBBr.SumMaterial + TBBr.SumStocked;
    end;
  end;    
  return;
end;

procedure SumProjectSchedule(string project,var val percsum,var val completesum,var val outstandsum)
begin
  record PRScheduleVc PRScheduler;
  Boolean found;

  PRScheduler.PRCode = project;
  found = true;
  if (ReadFirstMain(PRScheduler,1,true)) then begin
    percsum = percsum+PRScheduler.TotalPerc;
    completesum = completesum + PRScheduler.CompletePerc;
    outstandsum = outstandsum + PRScheduler.OutstandingPerc;
  end;    
  return;
end;

function val CalcProjectActuals(record RcVc RepSpec,record PRVc PRr)
begin
  val res;
  record TBIVVc TBIVr;
  Boolean found;
  
  found = true;
  TBIVr.PRCode = PRr.Code;
  while (LoopKey("MainKey",TBIVr,1,found)) begin
    if (TBIVr.PRCode!=PRr.Code) then begin found = false; end;
    if (found) then begin
      if (RepSpec.flags[2]!=0) and (nonblank(PRr.CurncyCode)) then begin
        if (TBIVr.CostPriceInCur!=0) then begin
          res = res + TBIVr.Qty*TBIVr.CostPriceInCur;
        end else begin
          res = res + TBIVr.Qty*TBIVr.CostPrice;
        end;
      end else begin
        res = res + TBIVr.Qty*TBIVr.CostPrice;
      end;
    end;
  end;
  CalcProjectActuals = res;
  return;
end;

global
procedure PRRevRecRn(record RcVc RepSpec)
begin
  Boolean found;
  Record PRVc PRr;
  Row  PRVc PRrw;
  string 60 frpr,topr;
  string 50 frcu,tocu;
  val totbud;
  val tottime,totother,totmaterial,totstock;
  Boolean testf;
  string 255 ckey;
  Integer keys;
  string 255 tstr;
  Integer rw;
  Integer i,rwcnt,subpram;
  array string 20 subproject;
  string 20 wproj;
  Integer prcnt;
  Record PRScheduleVc PRScheduler;
  val percsum,completesum,outstandsum,revrec,practual;

  frpr = FirstInRange(RepSpec.f1,60);
  topr = LastInRange(RepSpec.f1,60);
  frcu = FirstInRange(RepSpec.f3,50);
  tocu = LastInRange(RepSpec.f3,50);

  StartReportJob(USetStr(18230));
  rw = 1;
  HTProjects(RepSpec.f1,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
  HTProjSort2(RepSpec.flags[1],tstr);
  Header(rw,tstr,0);
  HTCusts(frcu,tocu,tstr);
  Header(rw,tstr,1);
  rw = rw + 1;
//  rw = rw +1;
  if (nonblank(RepSpec.f2)) then begin
    tstr = USetStr(4849);
  tstr = tstr & " ";
  tstr = tstr & RepSpec.f2;
  Header(rw,tstr,1);
  rw = rw + 1;
  end;
  HTPRClass(RepSpec.FirstAcc,tstr);
  if (nonblank(tstr)) then begin
   Header(rw,tstr,1);
   rw = rw + 1;
  end; 
  if (RepSpec.IncDaughter==1) then begin
    Header(rw,USetStr(4860),1);
    rw = rw + 1;
  end;
   if (RepSpec.flags[2]==0) then begin
    Header(rw,USetStr(18242),1);
    rw = rw + 1;
  end;
  EndHeader;

  SetRepCol(2,50);
  SetRepCol(3,142);
  SetRepCol(4,191);
  SetRepCol(5,195);
  SetRepCol(6,260);
  SetRepCol(7,340);
  SetRepCol(8,390);
  SetRepCol(9,440);

  StartFormat(15);
  OutString(0,0,USetStr(18231),false);
  OutString(2,0,USetStr(18232),false);
  OutString(3,0,USetStr(18233),true);
  OutString(4,0,USetStr(18234),true);
  OutString(5,0,USetStr(18235),false);
  if (RepSpec.flags[3]==1) or (RepSpec.flags[2]==0) then begin 
    OutString(6,0,USetStr(18236),false);
  end else begin 
    OutString(6,0,USetStr(18241),false);
  end;
  OutString(7,0,USetStr(18237),true);
  OutString(8,0,USetStr(18238),true);
  OutString(9,0,USetStr(18239),true);
  OutString(1,0,USetStr(18240),true);
  EndFormat;
  Gray_Divider(0,1);

  if RepSpec.flags[1]==0 then begin
    PRr.Code = frpr;
    ckey = "Code";
    keys = 1;
  end;
  if RepSpec.flags[1]==1 then begin
    PRr.CustCode = frcu;
    PRr.Code = frpr;
    ckey = "CustCode";
    keys = 2;
  end;
  if RepSpec.flags[1]==2 then begin
    PRr.Name = "";
    ckey = "Name";
    keys = 1;
  end;
  if RepSpec.flags[1]==3 then begin
    PRr.CustName ="";
    ckey = "CustName";
    keys = 1;
  end;
  if RepSpec.flags[1]==4 then begin  //Bjorn
    PRr.Leader ="";
    ckey = "PRLeader";
    keys = 1;
  end;
  found = true;
  while LoopKey(ckey,PRr,keys,found) begin
   testf = false;
   if (found) then begin
    if RepSpec.flags[1]==0 then begin
      if (nonblank(topr) and (PRr.Code>topr)) then begin
        found = false;
      end;
    end;
    if RepSpec.flags[1]==1 then begin
      if (nonblank(tocu) and (PRr.CustCode>tocu)) then begin
        found = false;
      end;
    end;
   end;
   if (found) then begin
    testf = true;
    if (nonblank(frcu) and (PRr.CustCode<frcu)) then begin testf = false; end;
    if (nonblank(tocu) and (PRr.CustCode>tocu)) then begin testf = false; end;
    if (nonblank(frpr) and (PRr.Code<frpr)) then begin testf = false; end;
    if (nonblank(topr) and (PRr.Code>topr)) then begin testf = false; end;

    if (nonblank(RepSpec.f2) and (RepSpec.f2<>PRr.Leader)) then begin testf = false; end;
    if ((RepSpec.flags[19]==0) and (PRr.Terminated<>1)) then begin testf = false; end;
    if ((RepSpec.flags[20]==0) and (PRr.Terminated==1)) then begin testf = false; end;
    if (nonblank(RepSpec.FirstAcc) and (RepSpec.FirstAcc<>PRr.PRClass)) then begin testf = false; end;    
    if (nonblank(RepSpec.LastAcc) and (RepSpec.LastAcc<>PRr.PrSalesMan)) then begin testf = false; end;    
    if (nonblank(RepSpec.f4) and (RepSpec.f4<>PRr.SalesGroup)) then begin testf = false; end;    
    if ((RepSpec.flags[10]==0) and (PRr.Type==0)) then begin testf = false; end;
    if ((RepSpec.flags[11]==0) and (PRr.Type==1)) then begin testf = false; end;    
    if ((RepSpec.flags[12]==0) and (PRr.Type==2)) then begin testf = false; end;    
   end;
   if (testf) then begin
     prcnt = prcnt + 1;
     subpram = 1;
     subproject[0] = PRr.Code;
     if (RepSpec.IncDaughter==1) then begin
       FindDautherProjects(PRr.Code,subproject,subpram);
     end;   
     StartFormat(15);
     OutString(0,"DblPRCode",PRr.Code,false);
     if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
       OutString(2,0,PRr.Name,false);
     end else begin 
       tstr = Left(PRr.Name,8);
       OutString(2,0,tstr,false);
     end;
     OutDate(3,0,PRr.StartDate,true);
     OutDate(4,0,PRr.EndDate,true);
     if (RepSpec.Media==mtFile) or (RepSpec.Media==mtExcel) then begin
       OutString(5,0,PRr.CustName,false);
     end else begin 
       tstr = Left(PRr.CustName,10);
       OutString(5,0,tstr,false);
     end;
     if (RepSpec.flags[3]==1) or (RepSpec.flags[2]==0) then begin 
       OutString(6,0,PRr.SalesGroup,false);
     end else begin
       OutString(6,0,PRr.CurncyCode,false);
     end;
     totbud = 0; tottime = 0; totother = 0; totmaterial = 0; totstock = 0;
     for (i=0;i<subpram;i=i+1) begin       
       wproj = subproject[i];  
       SumProjectBudget(RepSpec.flags[2],wproj,totbud,tottime,totother,totmaterial,totstock);
     end;
     OutVal(7,0,totbud,M4Val,true);

     percsum=0;completesum=0;outstandsum=0;
     for (i=0;i<subpram;i=i+1) begin       
       wproj=subproject[i];  
       SumProjectSchedule(wproj,percsum,completesum,outstandsum);
     end;
     OutVal(8,0,completesum,M4Val,true);
     revrec=totbud*completesum/100;
     OutVal(9,0,revrec,M4Val,true);
     practual = CalcProjectActuals(RepSpec,PRr);
     OutVal(1,0,practual,M4Val,true);
     EndFormat;
   end;
  end;
  Gray_Divider(0,1);
  StartFormat(15);
   OutString(350,0,USetStr(8897) & " " ,false);
   OutString(1,0,prcnt,true);
  EndFormat;
  EndJob;
  return;
end;

