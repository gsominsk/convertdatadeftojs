external function roundmode DefaultRoundMode();
external procedure MainRClassReportDef(var record RcVc);
external function Integer GetIntYc(Date);

external procedure DanTRSumup(var record DanTRVc);

procedure DanTRBal(record DanTRVc DanTRp,var val rp,LongInt TransNr,Integer skiprow)
BEGIN
  val Bal;
  row DanTRVc DanTRrw;
  Integer i,rwcnt;

  if (TransNr<=0) then begin goto LDanTRBal; end;
  rwcnt = MatRowCnt(DanTRp);
  Bal = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(DanTRp,i,DanTRrw);
    if (i!=skiprow) then begin
      if (DanTRrw.TransNr==TransNr) then begin
        switch (DanTRrw.stp) begin
          case 1: 
            if (DanTRrw.ovst==0) then begin
              Bal = Bal + DanTRrw.DebVal;
              Bal = Bal - DanTRrw.CredVal;
              Bal = Round(Bal,DefaultRoundMode);
            end;
        end; 
      end else begin
        i = rwcnt;
      end;
    end;
  end;
  rp = Bal; 
LDanTRBal:;
  RETURN;
END;

global
procedure BalanceDanTRDsm()
BEGIN
  Integer wn,rownr;
  record DanTRVc DanTRr;
  row DanTRVc DanTRrw;
  val ct,rp2;
  string 255 field;
  
  wn = CurWindow; 
  if (WindowState(wn)!=0) then begin
    rownr = WindowActiveRow(wn);
    field = WindowActiveField(wn);
    if (rownr>=0) then begin
      DeselectWindow(wn,false);
      GetWindowRecord(wn,DanTRr); 
      MatRowGet(DanTRr,rownr,DanTRrw);
      DanTRBal(DanTRr,ct,DanTRrw.TransNr,rownr);
      if (ct<0) then begin
        DanTRrw.DebVal = -ct;
      end else begin
        DanTRrw.CredVal = ct;
      end;
      MatRowPut(DanTRr,rownr,DanTRrw);
      PutWindowRecord(wn,DanTRr); 
      WindowFieldGoto(wn,DanTRr,rownr,field,true);
    end;
  end;
  RETURN;
END;

procedure SwapDCDanTrans(Integer frr,var record DanTRVc DanTRp)
BEGIN
  row DanTRVc DanTRrw;
  Integer i,rwcnt;
  val sv;

  rwcnt = MatRowCnt(DanTRp);
  for (i=frr;i<rwcnt;i=i+1) begin
    MatRowGet(DanTRp,i,DanTRrw);
    switch (DanTRrw.stp) begin
      case 1:
        if (DanTRrw.ovst==0) then begin
          sv = DanTRrw.DebVal;
          DanTRrw.DebVal = DanTRrw.CredVal;
          DanTRrw.CredVal = sv;
          sv = DanTRrw.DebVal2;
          DanTRrw.DebVal2 = DanTRrw.CredVal2;
          DanTRrw.CredVal2 = sv;
          sv = DanTRrw.CurDebVal;
          DanTRrw.CurDebVal = DanTRrw.CurCredVal;
          DanTRrw.CurCredVal = sv;
          MatRowPut(DanTRp,i,DanTRrw);
        end;
    end;
  end;
  RETURN;
END;

global
procedure SwapDCDanTRDsm()
BEGIN
  Integer wn;
  record DanTRVc DanTRr;
  val t;
  Integer orwcnt;
  
  wn = CurWindow; 
  if (WindowState(wn)==0) then begin
    GetWindowRecord(wn,DanTRr); 
    PutWindowRecord(wn,DanTRr); 
  end;
  if (WindowState(wn)!=0) then begin
    orwcnt = WindowOldRowcnt(wn);
    DeselectWindow(wn,false);
    GetWindowRecord(wn,DanTRr); 
    SwapDCDanTrans(orwcnt,DanTRr);
    DanTRSumup(DanTRr);
    PutWindowRecord(wn,DanTRr); 
  end;  
  RETURN;
END;

global
procedure CalcFieldDanTRDsm()
BEGIN
  Integer wn;
  record DanTRVc DanTRr;
  row DanTRVc calcDanTRrw;
  row DanTRVc DanTRrw;
  string 255 field;
  Integer orwcnt,rownr,i,rwcnt;
  val bal;

  wn = CurWindow; 
  if (true) then begin
    rownr = WindowActiveRow(wn);
    if (rownr>=0) then begin
      orwcnt = WindowOldRowcnt(wn);
      field = WindowActiveField(wn);
      DeselectWindow(wn,false);
      GetWindowRecord(wn,DanTRr); 
      MatRowGet(DanTRr,rownr,calcDanTRrw);
      if (calcDanTRrw.TransNr>=0) and ((blank(calcDanTRrw.AccNumber1)) or (blank(calcDanTRrw.AccNumber2))) then begin
        rwcnt = MatRowCnt(DanTRr);
        for (i=0;i<rwcnt;i=i+1) begin
          if (i!=rownr) then begin
            MatRowGet(DanTRr,i,DanTRrw);
            if (DanTRrw.TransNr==calcDanTRrw.TransNr) then begin
              bal = bal + DanTRrw.DebVal;
              bal = bal - DanTRrw.CredVal;
            end else begin
              i = rwcnt;
            end;
          end;
        end;
        if (bal>=0) then begin
          calcDanTRrw.CredVal = bal;
        end else begin
          calcDanTRrw.DebVal = bal;
        end;
        MatRowPut(DanTRr,rownr,calcDanTRrw);
        PutWindowRecord(wn,DanTRr); 
        WindowFieldGoto(wn,DanTRr,orwcnt,field,true);
      end;
    end;
  end;
  RETURN;
END;

procedure ChangeDanTransSign(Integer frr,record DanTRVc DanTRp)
BEGIN
 Integer i,rwcnt;
 row DanTRVc DanTRrw;

  rwcnt = MatRowCnt(DanTRp);
  for (i=frr;i<rwcnt;i=i+1) begin
    MatRowGet(DanTRp,i,DanTRrw);
    switch (DanTRrw.stp) begin
      case 1:
        if (DanTRrw.ovst==0) then begin
          DanTRrw.DebVal = -DanTRrw.DebVal;
          DanTRrw.CredVal = -DanTRrw.CredVal;
          DanTRrw.DebVal2 = -DanTRrw.DebVal2;
          DanTRrw.CredVal2 = -DanTRrw.CredVal2;
          DanTRrw.CurDebVal = -DanTRrw.CurDebVal;
          DanTRrw.CurCredVal = -DanTRrw.CurCredVal;
          MatRowPut(DanTRp,i,DanTRrw);
        end;
    end;
  end;
  RETURN;
END;

global
procedure ChangeSignDanTRDsm()
BEGIN
  Integer wn;
  record DanTRVc DanTRr;
  val t;
  Integer orwcnt;

  wn = CurWindow; 
  if (WindowState(wn)==0) then begin
    GetWindowRecord(wn,DanTRr); 
    PutWindowRecord(wn,DanTRr); 
  end;
  if (WindowState(wn)!=0) then begin
    orwcnt = WindowOldRowcnt(wn);
    DeselectWindow(wn,false);
    GetWindowRecord(wn,DanTRr); 
    ChangeDanTransSign(orwcnt,DanTRr)
    DanTRSumup(DanTRr);
    PutWindowRecord(wn,DanTRr); 
  end;
  RETURN;
END;

global
procedure OpenTRFromDanTR()
BEGIN  
  record DanTRVc DanTRr;
  row DanTRVc DanTRrw;
  record TRVc TRr;
  Integer rownr;
  Integer wn,nwn;
  LongInt sernr;
  Boolean openf;
  Date td;
  Integer i,rwcnt;
  
  if (UserCanAction("OpenTRFromSpec",true)) then begin
    wn = CurWindow;
    GetWindowRecord(wn,DanTRr);
    rownr = WindowActiveRow(wn);
    if (rownr>=0) then begin
      MatRowGet(DanTRr,rownr,DanTRrw);
      sernr = DanTRrw.TransNr;
      td = DanTRrw.RowTransDate;
      if (blankdate(td)) then begin
        td = DanTRr.TransDate;
      end;
      openf = true;
    end else begin
      rwcnt = MatRowCnt(DanTRr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(DanTRr,i,DanTRrw);
        if (sernr>0) then begin
          if (sernr!=DanTRrw.TransNr) then begin
            Beep;
            goto LOpenTRFromDanTR;
          end;
        end;
        sernr = DanTRrw.TransNr;
        td = DanTRrw.RowTransDate;
      end;
      openf = true;
      if (blankdate(td)) then begin
        td = DanTRr.TransDate;
      end;
    end;
    if (openf) then begin
      TRr.Number = sernr;
      TRr.IntYc = GetIntYc(td);
      if (ReadFirstMain(TRr,2,true)) then begin
        nwn = OpenWindow("TRDClass",1,0,"","",TRr);
      end;
    end;
  end else begin
    Beep;
  end;
LOpenTRFromDanTR:;  
  RETURN;
END;

global
procedure MainRnFromDanTR()
BEGIN
  record DanTRVc DanTRr;
  row DanTRVc DanTRrw;
  Integer wn,rownr;
  record RcVc RepSpec;
  string 50 field;
  
  wn = CurWindow;
  rownr = WindowActiveRow(wn);
  field = WindowActiveField(wn);
  if (rownr>=0) then begin
    DeselectWindow(wn,WindowState(wn)==1);
    GetWindowRecord(wn,DanTRr);
    MatRowGet(DanTRr,rownr,DanTRrw);
    ReportDefaults(RepSpec,"MainRClass");    
    MainRClassReportDef(RepSpec);
    RepSpec.repname = "MainRn";
    RepSpec.Media = mtScreen;
    switch (field) begin
      case "AccNumber1": RepSpec.f4 = DanTRrw.AccNumber1;
      case "AccNumber2": RepSpec.f4 = DanTRrw.AccNumber2;
    end;
    RepSpec.ObjStr = DanTRrw.Objects;
    RunReport(RepSpec,0);
  end;
  RETURN;
END;
