external procedure AutomatedSalesOrderly(string);
external procedure CalcVATBaseVAT2(record SMVc,Integer,Integer,Integer,Boolean,var val,var val);
remote procedure ORVc_PasteDelCountry(var record ORVc,string);
remote procedure ORVc_PasteInvCountry(var record ORVc,string);
external function Boolean ORDClassActiveEditField(Integer,string,Integer,Integer,Integer,Integer);
remote procedure ORVc_PasteTaxTemplateCode(var record ORVc,Integer,var Boolean);
external function Boolean RPCUTax_TaxedAmount(val,val,string,record RPCUTaxVc);
remote function Boolean FindRPCUTax(string,Date,var record RPCUTaxVc);
external procedure RowCalculateTaxMatrix_ORVc(var record ORVc,Integer,row ORVc);
external procedure AddRowTaxMatrixToSumTaxMatrix(record TaxMatrixVc,var record TaxMatrixVc,Integer);
external function val CalculateTotalVATFromTaxMatrix(record TaxMatrixVc,Integer);
external function Boolean UseTaxTemplatesforTaxCalc();
remote procedure ORVc_PasteRegion(var record ORVc,string);
remote function string 255 FindPositionWithSerialNr(string,string,string,string);
remote procedure ORVc_PasteSalesMan(var record ORVc,string);
external function roundmode SetRoundModeD(Integer);
external function roundmode DefaultRoundMode();
remote procedure ORVc_PasteLocation(var record ORVc,Integer);
remote function Boolean CostPriceForGP(string,string,string,string,var val);
external procedure RecalcORSubtotal(var record ORVc);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure RoundRowSum(string,string,string,var val);
external procedure SendArtStat(string,string,string,val,val,val,Date,Integer);
external procedure CalcProc(val,val,var val);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external function val FindVAT(string,val,Integer,Integer);
external procedure AddTAX2Base(Boolean,record SMVc,string,val,val,val,Integer,string);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external function val CalcTax2BaseTax2(Boolean,record SMVc,Integer);
external procedure SetupVATBase(var record SMVc,var Integer);
external function Boolean TestForMATVARINS(Integer);
external function Boolean ORDchrsum(var record ORVc,Integer);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Boolean ORDClassSwitchRow(Integer,Integer);
external procedure ORVc_PasteBasePrice(var record ORVc,Integer,var Boolean);
remote procedure ORVc_PasteVATCode2(var record ORVc,Integer,string,var Boolean);
external procedure ORVc_PastevRebate(var record ORVc,Integer,var Boolean);
remote procedure ORVc_PastePrice(var record ORVc,Integer,var Boolean);
external procedure ORVc_PastePriceFactor(var record ORVc,Integer,var Boolean);
external procedure ORVc_PasteRecepy(var record ORVc,Integer,var Boolean);
remote function Boolean ORVc_PasteUnitFactQuant(var record ORVc,Integer);
remote procedure ORVc_PasteUnitFactPrice(var record ORVc,Integer);
remote procedure ORVc_PasteUnitCode(var record ORVc,Integer);
remote procedure ORVc_PastePriceList(var record ORVc);
external procedure ORVc_PasteCommision(var record ORVc,var Boolean);
remote procedure ORVc_PasteCurncyCode(var record ORVc,string);
remote procedure ORVc_PastePRCode(var record ORVc);
remote procedure ORVc_PastePayDeal(var record ORVc);
external procedure MulM4ProcVal(val,val,var val);
remote procedure ORVc_PasteDelAddrCode(var record ORVc);
external procedure GetSalesGroup(string,var string);
remote procedure ORVc_PasteFrPrice(var record ORVc);
remote procedure ORVc_PasteOrdDate(var record ORVc);
remote procedure ORVc_PasteQuant(var record ORVc,Integer,Boolean,var Boolean);
remote function Boolean ORVc_PasteArtCode(var record ORVc,Integer,var string,var string,Boolean);
remote function Boolean PasteCustInOrder(var record ORVc,string,string,var string,var string);
external function Boolean SetUnitFactor(string,var val,val,val,val,var val,var val,var val,var string,Boolean);
external procedure SerialNrDimensions(string,string,var val,var val,var val);
external function Integer CheckSerialStatus(string,string,var string);
remote function val CalculateSerialNrQuantity(string,string,string,Boolean,val,val,val,val);
remote function Boolean SerialNrForOneItem(string,var record SerBalVc);
remote procedure ORVc_GetPriceList2(var record ORVc,Boolean);
external function Boolean OpenContactRecord(string,string);

procedure ORSumup_TaxTemplate(var record ORVc ORp)
begin
  Integer i,rwcnt;
  row ORVc ORrw;
  record TaxMatrixVc TMr;
  record TaxMatrixVc sumTMr;
  roundmode roundlines,rndtotal,rndvat;
  val t;

  ORp.Sum1 = blankval; //Subtotal
  ORp.Sum3 = blankval; //VAT
  ORp.Sum4 = blankval; //Total
  ORp.TotGP = blankval;
  UnpackFieldMatrix(ORp,"TaxMatrix",sumTMr);
  RecordClear(sumTMr);
  rwcnt = MatRowCnt(ORp);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    switch (ORrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeInterest:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeRetention:
        goto LkInvoiceRowTypeNormal;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal:;      
        if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
          UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
          AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,ORp.InclVAT);
        end;
        ORp.Sum1 = ORp.Sum1 + ORrw.Sum;
        ORp.TotGP = ORp.TotGP + ORrw.rowGP;
      case kInvoiceRowTypeCorrection:
        if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
          UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
          AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,ORp.InclVAT);
        end;
        ORp.Sum1 = ORp.Sum1 + ORrw.Sum;
        ORp.TotGP = ORp.TotGP + ORrw.rowGP;
      case kInvoiceRowTypeGiftVoucherSold:
        if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
          UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
          AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,ORp.InclVAT);
        end;
        switch (ORp.InclVAT) begin
          case kBasePriceNotInclVAT:
            ORp.Sum1 = ORp.Sum1 + ORrw.Sum;
            if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
              ORp.Sum1 = ORp.Sum1 - CalculateTotalVATFromTaxMatrix(TMr,ORp.InclVAT);
            end;
          case kBasePriceInclVAT:
            ORp.Sum1 = ORp.Sum1 + ORrw.Sum;
        end;
      case kInvoiceRowTypeDownpayment:
        if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
          UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
          AddRowTaxMatrixToSumTaxMatrix(TMr,sumTMr,ORp.InclVAT);
        end;
        ORp.Sum1 = ORp.Sum1 + ORrw.Sum;      
      
//  kInvoiceRowTypePrepayment = 6,
//  kInvoiceRowTypeLoan = 7,
//  kInvoiceRowTypeLoanInterest = 8,

//  kInvoiceRowTypeGiftVoucherPayment = 14,
//  kInvoiceRowTypeCashPayment = 15,
//  kInvoiceRowTypeCreditCardPayment = 16,

//  kInvoiceRowTypePreviousDownpayment = 20,
//  kInvoiceRowTypeChequePayment = 21,

//  kInvoiceRowTypePerceptionTax = 22, //how to handle Perception Taxes ?
//  kInvoiceRowTypeWithholdingTax = 24  //how to handle Withholding Taxes ?
    end;
  end;
  if (ORp.FrPrice!=0) then begin
    if (ORp.InclVAT==0) then begin
      ORp.Sum1 = ORp.FrPrice + ORp.Sum1;
/*      
      if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
        t = FindVAT (ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        if (t==0) then begin
          s2 = ORp.FrPrice + s2;
        end;  
        ORp.Sum3 = t + ORp.Sum3;
        AddVATBase(SMr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
      end;
*/      
    end else begin
      if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
        ORp.Sum4 = ORp.FrPrice + ORp.Sum4;
/*        
        t = FindVAT (ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        ORp.Sum3 = t + ORp.Sum3;
        AddVATBase(SMr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
*/        
        if (t==0) then begin
          ORp.Sum2 = ORp.FrPrice + ORp.Sum2;
        end else begin
          ORp.Sum1 = ORp.FrPrice + ORp.Sum1;
        end;  
      end else begin
        ORp.Sum4 = ORp.FrPrice + ORp.Sum4;     
/*         
        t = FindVAT (ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        ORp.Sum3 = t + ORp.Sum3;
        AddVATBase(SMr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
        ORp.Sum4 = ORp.Sum4 - t;
        if (t==0) then begin
          ORp.Sum2 = ORp.FrPrice + ORp.Sum2;
        end else begin
          ORp.Sum1 = ORp.FrPrice + ORp.Sum1;
        end;  
*/        
      end;
    end;
//Freight VAT needs  to be added as well
  end;

  if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
    ORp.Sum3 = CalculateTotalVATFromTaxMatrix(sumTMr,ORp.InclVAT);
  end;
  PackFieldMatrix(ORp,"TaxMatrix",sumTMr);
  GetCurncyRoundoff(ORp.CurncyCode,ORp.PayDeal,"ORVc",rndtotal,roundlines,rndvat);

/*Rounding should be tested carefully*/

  ORp.Sum3 = Round(ORp.Sum3,rndvat);
  ORp.Sum1 = Round(ORp.Sum1,rndtotal);
  switch (ORp.InclVAT) begin
    case kBasePriceNotInclVAT:
      ORp.Sum4 = ORp.Sum1 + ORp.Sum3;
    case kBasePriceInclVATandTAX:
      ORp.Sum4 = ORp.Sum1;
    case kBasePriceInclVAT:
      ORp.Sum4 = ORp.Sum1;
  end;  
  ORp.Sum3 = Round(ORp.Sum3,rndvat);
  ORp.Sum4 = Round(ORp.Sum4,rndtotal);
  ORp.BaseSum4 = MulRateToBase1(ORp.CurncyCode,ORp.Sum4,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
  ORp.TotGP = Round(ORp.TotGP,rndtotal);
  return;
end;

function val ORVc_CalcTax2perCustomer(record RPCUTaxVc RPCUTaxr,var record ORVc ORp)
begin
  val res;
  Integer i,rwcnt;
  row ORVc ORrw;
  val tax2base,tax2baseb1,tax1reb,tax1sum,t;
  record INVc INr;
  record SMVc VATr;
  Integer vatcnt;
  
  SetupVATBase(VATr,vatcnt);
  rwcnt = MatRowCnt(ORp);

// OR2Sumup should look in item and make another SetupVATBase and SMr

  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    switch (ORrw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        goto LkInvoiceRowTypeNormal2;
      case kInvoiceRowTypeNormal:
LkInvoiceRowTypeNormal2:;
        if (ORrw.Perceptions!=0) then begin       
          if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
            AddVATBase(VATr,ORrw.VATCode,ORrw.Sum,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
            tax2base = tax2base + ORrw.Sum;
          end;
        end;
    end;
  end;
  CalcVATBaseVAT(VATr,ORp.InclVAT,ORp.NoTAXonVAT,vatcnt,t,tax1sum);  
  switch (ORp.InclVAT) begin
    case 0:
      switch (ORp.NoTAXonVAT) begin
        case 2:
        case 1:
        otherwise
          tax2base = tax2base - t;
      end;
    otherwise
      tax2base = tax2base - t;
  end;
/*
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    switch (ORrw.stp) begin
      case kInvoiceRowTypePerceptionTax: ;
      otherwise
        if (ORrw.Perceptions!=0) then begin
          tax2base = tax2base + ORrw.Sum;
        end;
    end;
  end;
*/
  tax2baseb1 = MulRateToBase1(ORp.CurncyCode,tax2base,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    if (ORrw.stp==kInvoiceRowTypePerceptionTax) then begin    
      if (RPCUTax_TaxedAmount(tax2base,tax2baseb1,ORrw.Region,RPCUTaxr)) then begin
        ORrw.Sum = (tax2base*ORrw.TAX2Prc)/100.00;
        res = res + Round(ORrw.Sum,SetRoundModeD(2));
        MatRowPut(ORp,i,ORrw);
      end else begin
        ORrw.Sum = (tax2base*0.00)/100.00;
        res = res + Round(ORrw.Sum,SetRoundModeD(2));
        MatRowPut(ORp,i,ORrw);
      end;
    end;
  end;
  ORVc_CalcTax2perCustomer = res;
  return;
end;

global
procedure ORSumup(var record ORVc ORp)
begin
  row ORVc ORrw;
  val s,ms,ms2,temp,s2,tax1sum,tax2sum,t;
  Integer i,rwcnt;
  roundmode roundlines,rndtotal,roundvat;
  record SMVc VATr;/*VATBaseRowType*/
  record SMVc SMTax2r;
  record SMVc RvrsVATr;
  Integer vatcnt;  
  val subtotv,tax1reb;
  record Tax1RebVc Tax1Rebr;
  val tms,ttax1sum;
  record RPCUTaxVc RPCUTaxr;
  Boolean calcperceppercuf;
  record CUVc CUr;

  if (UseTaxTemplatesforTaxCalc) then begin
    ORSumup_TaxTemplate(ORp);
    goto LORSumup;
  end;
  CUr.Code = ORp.CustCode;
  ReadFirstMain(CUr,1,true);
  calcperceppercuf = FindRPCUTax(ORp.CustCode,ORp.OrdDate,RPCUTaxr);
  SetupVATBase(VATr,vatcnt);
  SetupVATBase(RvrsVATr,vatcnt);
  ORp.TotGP = 0;
  rwcnt = MatRowCnt(ORp);
  for (i = 0 ; i<rwcnt ;i=i+1) begin
    MatRowGet(ORp,i,ORrw);
    if (ORrw.stp!=kInvoiceRowTypeSubtotal) and (ORrw.stp!=kInvoiceRowTypePerceptionTax) then begin
      tax1reb = ORrw.TAX1Reb;
//      tax1reb = 0;
//      Tax1Rebr.Code = ORrw.VATCode;
//      Tax1Rebr.CustCode = ORp.CustCode;
//      if (ReadFirstMain(Tax1Rebr,2,true)) then begin end;
//      if (ORp.OrdDate>=Tax1Rebr.From) then begin
//        tax1reb = Tax1Rebr.TAX1Reb;
//      end;
      ORp.TotGP = ORp.TotGP + ORrw.rowGP;
      temp = MulRateToBase1(ORp.CurncyCode,ORrw.Sum,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);        
      s = s + ORrw.Sum;
      s2 = s2 + temp;
      if (blank(ORrw.RvrsVATCode)) then begin
        AddVATBase(VATr,ORrw.VATCode,ORrw.Sum,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
      end else begin
        AddVATBase(RvrsVATr,ORrw.VATCode,ORrw.Sum,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
      end;
      AddTAX2Base(calcperceppercuf,SMTax2r,ORrw.TAX2Code,ORrw.TAX2Prc,ORrw.TAX2Reb,ORrw.Sum,ORp.InclVAT,ORrw.VATCode);        
      MatRowPut(ORp,i,ORrw);
      subtotv = subtotv + ORrw.Sum;
    end else begin
      if (ORrw.Sum!=subtotv) then begin
        ORrw.Sum = subtotv;
        MatRowPut(ORp,i,ORrw);
      end;
      subtotv = blankval;
    end;
  end;
  if (ORp.FrPrice!=0) then begin
    tax1reb = 0;
    Tax1Rebr.Code = ORp.FrVATCode;
    Tax1Rebr.CustCode = ORp.CustCode;
    if (ReadFirstMain(Tax1Rebr,2,true)) then begin end;
    if (ORp.OrdDate>=Tax1Rebr.From) then begin
      tax1reb = Tax1Rebr.TAX1Reb;
    end;
    if (ORp.InclVAT==0) then begin
      ms2 = ORp.FrPrice + ms2;
      s = ORp.FrPrice + s;
      if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
        t = FindVAT(ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        if (t==0) then begin
          s2 = ORp.FrPrice + s2;
        end;  
        ms = t + ms;
        AddVATBase(VATr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
      end;
    end else begin
      if ((ORp.ExportFlag==0) or (ORp.ExportFlag==3) or (ORp.ExportFlag==4)) then begin
        ms2 = ORp.FrPrice + ms2;
        t = FindVAT(ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        ms = t + ms;
        AddVATBase(VATr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
        if (t==0) then begin
          s2 = ORp.FrPrice + s2;
        end else begin
          s = ORp.FrPrice + s;
        end;  
      end else begin
        ms2 = ORp.FrPrice + ms2;      
        t = FindVAT(ORp.FrVATCode,ORp.FrPrice,ORp.InclVAT,ORp.NoTAXonVAT);
        ms = t + ms;
        AddVATBase(VATr,ORp.FrVATCode,ORp.FrPrice,tax1reb,vatcnt,ORp.InclVAT,ORp.NoTAXonVAT);
        ms2 = ms2 - t;
        if (t==0) then begin
          s2 = ORp.FrPrice + s2;
        end else begin
          s = ORp.FrPrice + s;
        end;  
      end;
    end;
  end;
  CalcVATBaseVAT(VATr,ORp.InclVAT,ORp.NoTAXonVAT,vatcnt,ms,tax1sum);
  CalcVATBaseVAT2(RvrsVATr,ORp.InclVAT,ORp.NoTAXonVAT,vatcnt,CUr.RvrsVAT!=0,ORp.RvrsVAT,t);  
  if (calcperceppercuf) then begin
    tax2sum = ORVc_CalcTax2perCustomer(RPCUTaxr,ORp);  
  end else begin
    tax2sum = CalcTax2BaseTax2(false,SMTax2r,ORp.InclVAT);  
  end;
  ORp.TAX1Sum = Round(tax1sum,DefaultRoundMode);
  ORp.TAX2Sum = Round(tax2sum,DefaultRoundMode);  
  if (ORp.TAX1Sum==0) then begin ORp.TAX1Sum = blankval; end;
  if (ORp.TAX2Sum==0) then begin ORp.TAX2Sum = blankval; end;
  if (ORp.NoTax1!=0) then begin  ORp.TAX1Sum = blankval; end;
  if (ORp.NoTax2!=0) then begin  ORp.TAX2Sum = blankval; end;
  GetCurncyRoundoff(ORp.CurncyCode,ORp.PayDeal,"ORVc",rndtotal,roundlines,roundvat);
  ms = Round(ms,roundvat);
  

  if ((ORp.ExportFlag==1) or (ORp.ExportFlag==2)) then begin
    if (ORp.InclVAT>0) then begin
      ms2 = s - ms;
    end else begin
      ms2 = s;
    end;  
    ms = blankval;
  end else begin
    if (ORp.InclVAT>0) then begin
      ms2 = s;
    end else begin
      ms2 = s + ms;
    end;  

    switch (ORp.InclVAT) begin
      case 1:
        switch (ORp.NoTAXonVAT) begin
          case 1:
          case 2:
          otherwise
        end;
      case 2:
        switch (ORp.NoTAXonVAT) begin
          case 2:
            if (ORp.TotalwoTAX==0) then begin
              ms2 = ms2 + tax1sum;
            end;
            CalcVATBaseVAT(VATr,ORp.InclVAT,1,vatcnt,tms,ttax1sum);  
            ms2 = ms2 + ms-tms;
          otherwise
            if (ORp.TotalwoTAX==0) then begin
              ms2 = ms2 + tax1sum;
            end;
        end;
      otherwise
        switch (ORp.NoTAXonVAT) begin
          otherwise
            if (ORp.TotalwoTAX==0) then begin
              ms2 = ms2 + tax1sum;
            end;
        end;
    end;

  end;

  t = ms2;
  ms2 = Round(t,rndtotal);
  t = ms2 - t;
  ORp.Sum0 = t + ORp.Sum0;
    
  ms2 = ms2 + ORp.TAX2Sum;
  s = Round(s,DefaultRoundMode);
  ms = Round(ms,roundvat);
  ms2 = Round(ms2,rndtotal);
  if (ORp.DiscPerc!=blankval) then begin    
    MulM4ProcVal(ORp.DiscPerc,s,temp);
    ORp.DiscSum = temp;
  end;  
  ORp.DiscSum = Round(ORp.DiscSum,DefaultRoundMode);
  ORp.Sum1 = s;
  ORp.Sum3 = ms;
  ORp.Sum4 = ms2;
  if (ORp.InclVAT==0) then begin
    temp = ORp.TotGP/s2;
  end else begin
    temp = s2-MulRateToBase1(ORp.CurncyCode,ORp.Sum3,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
    if (temp!=0) then begin
      temp = ORp.TotGP/temp;
    end;
  end;
  ORp.GPProc = temp*100;
  if (nonblank(ORp.CurncyCode)) then begin
    ORp.BaseSum4 = MulRateToBase1(ORp.CurncyCode,ORp.Sum4,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
  end;  
  ORp.SumIncCom = ORp.Sum4 + ORp.Commision;
  RecalcORSubtotal(ORp);
LORSumup:;  
  RETURN;
END;

global
procedure ORDchsum(var record ORVc ORp,Integer rownr)
BEGIN  
  row ORVc ORrw;
  row ORVc OR2rw;
  val t,s,rowsum,tproc,unitprdisc;
  val qty,sum;
  record TaxMatrixVc TMr;
  val gp;
  Integer i,rwcnt;

  if (rownr>=0) then begin
    MatRowGet(ORp,rownr,ORrw);
  end;
  qty = ORrw.Quant;
  if (nonblank(ORrw.ArtCode)) then begin
    t = qty*ORrw.BasePrice;   /* cost  */
    if (ORrw.PriceFactor!=0) then begin
      t = t/ORrw.PriceFactor;
    end;
    sum = ORrw.Sum;
    s = MulRateToBase1(ORp.CurncyCode,sum,ORp.FrRate,ORp.ToRateB1,ORp.ToRateB2,ORp.BaseRate1,ORp.BaseRate2,DefaultCurRoundOff);
    UnpackRowFieldMatrix(ORrw,"TaxMatrix",TMr);
    FindSalesExVat(TMr,ORrw.VATCode,s,ORp.InclVAT,ORp.NoTAXonVAT,rowsum);    
    ORrw.rowGP = rowsum - t;          /* GP    */
  end else begin
    ORrw.rowGP = blankval;
    ORrw.BasePrice = blankval;
  end;
  unitprdisc = Round(ORrw.Sum / ORrw.Quant,DefaultRoundMode);
  if (rownr>=0) then begin
    MatRowPut(ORp,rownr,ORrw);
  end;
  gp = ORrw.rowGP;
  rwcnt = MatRowCnt(ORp);  
  for (i=rownr+1;i<rwcnt;i=i+1) begin
    MatRowGet(ORp,i,OR2rw);
    switch (OR2rw.stp) begin
      case kInvoiceRowTypeStructuredItemComponent:
        if (OR2rw.MotherArtCode==ORrw.ArtCode) then begin
          gp = gp + OR2rw.rowGP;
        end;
      otherwise
        i = rwcnt;
    end;
  end;    
  CalcProc(rowsum,gp,tproc);
  SendArtStat(ORrw.ArtCode,ORp.Location,"",gp,tproc,unitprdisc,ORp.OrdDate,1);  
  RETURN;
END;

global
procedure ORVc_PasteSum(var record ORVc ORp,Integer rownr,var Boolean chsum)
BEGIN
  val s,t;
  row ORVc ORrw;
  record GeneralOptionBlock GenOptr;
  
  MatRowGet(ORp,rownr,ORrw);
  if ((ORrw.Quant!=0) and (ORrw.Price!=0)) then begin  
    chsum = true;
    ORrw.vRebate = blankval;
    BlockLoad(GenOptr);      
    CalcSum(ORrw.Quant,ORrw.Price,ORrw.PriceFactor,ORrw.vRebate,t,GenOptr.UseDiscount);
    RoundRowSum(ORp.CurncyCode,ORp.PayDeal,"ORVc",t);
    s = ORrw.Sum;// /ORrw.Quant not good
    s = t - s;
    s = s*100;
    s = s/t;
    ORrw.vRebate = Round(s,SetRoundModeD(1));
    RowCalculateTaxMatrix_ORVc(ORp,rownr,ORrw);
    if (ORrw.vRebate==0) then begin ORrw.vRebate = blankval; end;
    MatRowPut(ORp,rownr,ORrw);
  end;
  ORSumup(ORp);
  RETURN;
END;

function Boolean ORDClassUnitXvalEFAfter(Integer wn,Integer fn, Integer rownr,Integer changed)
BEGIN
  row ORVc ORrw;
  record ORVc ORr;
  Boolean res,chsum,chrsum;
  val unitqty,unitprice,qty,price;
  
  res = true;
  if ((changed!=0) and (rownr>=0)) then begin
    GetWindowRecord(wn,ORr);
    MatRowGet(ORr,rownr,ORrw);
    ORrw.Quant = CalculateSerialNrQuantity(ORrw.ArtCode,"","",false,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,ORrw.Quant);
    MatRowPut(ORr,rownr,ORrw);
    MatRowGet(ORr,rownr,ORrw);
    unitqty = ORrw.UnitFactQuant;
    unitprice = ORrw.UnitFactPrice;
    qty = ORrw.Quant;
    price = ORrw.Price;
    if (SetUnitFactor(ORrw.UnitCode,unitqty,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,unitprice,qty,price,ORrw.UnitComment,false)) then begin
      ORrw.UnitFactQuant = unitqty;
      ORrw.UnitFactPrice = unitprice;
      ORrw.Quant = qty;
      ORrw.Price = price;
      chrsum = true;
      MatRowPut(ORr,rownr,ORrw);
    end;
    if (chrsum) then begin
      chsum = ORDchrsum(ORr,rownr);
    end;
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassUnitXvalEFAfter = res;
  RETURN;
END;

function Boolean ORDClassUnitYvalEFAfter(Integer wn,Integer fn, Integer rownr,Integer changed)
BEGIN
  row ORVc ORrw;
  record ORVc ORr;
  Boolean res,chsum,chrsum;
  val unitqty,unitprice,qty,price;
  
  res = true;
  if ((changed!=0) and (rownr>=0)) then begin
    GetWindowRecord(wn,ORr);
    MatRowGet(ORr,rownr,ORrw);
    ORrw.Quant = CalculateSerialNrQuantity(ORrw.ArtCode,"","",false,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,ORrw.Quant);
    MatRowPut(ORr,rownr,ORrw);
    MatRowGet(ORr,rownr,ORrw);
    unitqty = ORrw.UnitFactQuant;
    unitprice = ORrw.UnitFactPrice;
    qty = ORrw.Quant;
    price = ORrw.Price;
    if (SetUnitFactor(ORrw.UnitCode,unitqty,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,unitprice,qty,price,ORrw.UnitComment,false)) then begin
      ORrw.UnitFactQuant = unitqty;
      ORrw.UnitFactPrice = unitprice;
      ORrw.Quant = qty;
      ORrw.Price = price;
      chrsum = true;
      MatRowPut(ORr,rownr,ORrw);
    end;
    if (chrsum) then begin
      chsum = ORDchrsum(ORr,rownr);
    end;
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassUnitYvalEFAfter = res;
  RETURN;
END;

function Boolean ORDClassUnitZvalEFAfter(Integer wn,Integer fn, Integer rownr,Integer changed)
BEGIN
  row ORVc ORrw;
  record ORVc ORr;
  Boolean res,chsum,chrsum;
  val unitqty,unitprice,qty,price;
  
  res = true;
  if ((changed!=0) and (rownr>=0)) then begin
    GetWindowRecord(wn,ORr);
    MatRowGet(ORr,rownr,ORrw);
    ORrw.Quant = CalculateSerialNrQuantity(ORrw.ArtCode,"","",false,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,ORrw.Quant);    
    MatRowPut(ORr,rownr,ORrw);
    MatRowGet(ORr,rownr,ORrw);
    unitqty = ORrw.UnitFactQuant;
    unitprice = ORrw.UnitFactPrice;
    qty = ORrw.Quant;
    price = ORrw.Price;
    if (SetUnitFactor(ORrw.UnitCode,unitqty,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,unitprice,qty,price,ORrw.UnitComment,false)) then begin
      ORrw.UnitFactQuant = unitqty;
      ORrw.UnitFactPrice = unitprice;
      ORrw.Quant = qty;
      ORrw.Price = price;
      chrsum = true;
      MatRowPut(ORr,rownr,ORrw);
    end;
    if (chrsum) then begin
      chsum = ORDchrsum(ORr,rownr);
    end;
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassUnitZvalEFAfter = res;
  RETURN;
END;

function Boolean ORDClassSerialNrEFAfter(Integer wn,Integer fn, Integer rownr,Integer changed)
BEGIN
  row ORVc ORrw;
  record ORVc ORr;
  Boolean res;
  val UnitXval,UnitYval,UnitZval,oldquant,t;
  string 255 tstr;
  Boolean chsum;
  record SerBalVc SBr;
  string 255 warning;
  string 30 serial;
  
  res = true;
  if ((changed!=0) and (rownr>=0)) then begin
    GetWindowRecord(wn,ORr);
    MatRowGet(ORr,rownr,ORrw);
    if (blank(ORrw.ArtCode)) then begin 
      if (SerialNrForOneItem(ORrw.SerialNr,SBr)) then begin
        if (nonblank(SBr.Item)) then begin 
          ORrw.ArtCode = SBr.Item;
          ORrw.Quant = 1;
          ORrw.Location = SBr.Location;
          serial = ORrw.SerialNr;
          ORrw.Position = FindPositionWithSerialNr(ORr.Location,ORrw.ArtCode,ORrw.SerialNr,ORrw.Location);
          MatRowPut(ORr,rownr,ORrw);
          if (ORVc_PasteArtCode(ORr,rownr,warning,warning,false)) then begin
          end;
          MatRowGet(ORr,rownr,ORrw);
          ORrw.SerialNr = serial;
          MatRowPut(ORr,rownr,ORrw);
        end;
      end;  
    end;
    SerialNrDimensions(ORrw.ArtCode,ORrw.SerialNr,UnitXval,UnitYval,UnitZval);
    ORrw.UnitXval = UnitXval;
    ORrw.UnitYval = UnitYval;
    ORrw.UnitZval = UnitZval;
    if (CheckSerialStatus(ORrw.ArtCode,ORrw.SerialNr,tstr)==1) then begin
      MessageBox(0,tstr);
    end;
    t = ORrw.BasePrice;
    chsum = CostPriceForGP(ORrw.ArtCode,ORrw.SerialNr,ORr.PriceList,ORr.CustCode,t);
    ORrw.BasePrice = t;
    oldquant = ORrw.Quant;
    ORrw.Quant = CalculateSerialNrQuantity(ORrw.ArtCode,"","",false,ORrw.UnitXval,ORrw.UnitYval,ORrw.UnitZval,ORrw.Quant);    
    if (ORrw.Quant!=oldquant) then begin
      chsum = true;
    end;
    MatRowPut(ORr,rownr,ORrw);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassSerialNrEFAfter = res;
  RETURN;
END;

function Boolean ORDClassPlanShipEFAfter(Integer wn,Integer fn, Integer rownr,Integer changed)
begin
  record ORVc ORr;
  record PlanDeliveryBlock PlanDelRec;
  LongInt week;
  date d;
  
  if (changed!=0) then begin
    BlockLoad(PlanDelRec);
    GetWindowRecord(wn,ORr);
    switch (PlanDelRec.FieldType) begin
      case 1:  /* date */
        d = ORr.PlanShip;
        ORr.PlanShip = d;
        ORr.PlanShipDate = StringToDate(ORr.PlanShip);
      case 2:  /* week number (nn) */
        week = ORr.PlanShip;
        ORr.PlanShip = week;
      case 3:  /* week number (yynn */
        if (nonblank(ORr.PlanShip)) then begin
          week = StringToLongInt(ORr.PlanShip);
          ORr.PlanShip = week;
          if (len(ORr.PlanShip)<4) then begin
            ORr.PlanShip = "0" & ORr.PlanShip;
          end;
          if (len(ORr.PlanShip)>4) then begin
            ORr.PlanShip = Left(ORr.PlanShip,4);
          end;
        end;
    end;
    ORVc_GetPriceList2(ORr,false);
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassPlanShipEFAfter = true;
  return;
end;

function Boolean ORDClassOrdDateEFAfter(Integer wn,Integer changed)
begin
  record ORVc ORr;
  
  if (changed!=0) then begin
    GetWindowRecord(wn,ORr);
    ORVc_PasteOrdDate(ORr);
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassOrdDateEFAfter = true;
  return;
end;
 
function Boolean ORDClassArtCodeEFAfter(Integer wn,Integer rownr,Integer changedf)
begin  
  record ORVc ORr;
  string 255 inwarning,warning;
 
  if (changedf!=0) then begin
    GetWindowRecord(wn,ORr);
    if (ORVc_PasteArtCode(ORr,rownr,inwarning,warning,false)) then begin
    end;
    if (nonblank(inwarning)) then begin
      MessageBox(0,inwarning);
    end;
    if (nonblank(warning)) then begin
      MessageBox(0,warning);
    end;
    PutWindowRecord(wn,ORr);
    if (ORDClassSwitchRow(wn,rownr)) then begin end;
  end;
  ORDClassArtCodeEFAfter = true;
  return;
end;
 
function Boolean ORDClassQuantEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin   
  record ORVc ORr;
  Boolean chsum;
  record ModuleBlock OptFeature;

  if (changedf!=0) then begin 
    GetWindowRecord(wn,ORr);
    BlockLoad(OptFeature);
    if (OptFeature.NoQtyDepPrices==0) then begin
      ORVc_PasteQuant(ORr,rownr,true,chsum);
    end else begin
      chsum = ORDchrsum(ORr,rownr);
    end;
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
  end;
  ORDClassQuantEFAfter = true;
  return;
end;
 
function Boolean ORDClassCustCodeEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin  
  record ORVc ORr;
  string 255 warning,errstr;
 
  GetWindowRecord(wn,ORr);    
  if ((changedf!=0) or ((blank(ORr.Addr0)) and (nonblank(ORr.CustCode)))) then begin
    if (PasteCustInOrder(ORr,ORr.CustCode,WindEFstr(wn),warning,errstr)) then begin
      if (nonblank(warning)) then begin
        MessageBox(0,warning);
      end;
      if (nonblank(errstr)) then begin
        MessageBox(0,errstr);
      end;
      PutWindowRecord(wn,ORr);
    end else begin
      Beep;
    end;
  end;
  ORDClassCustCodeEFAfter = true;
  return;
end;
 
function Boolean ORDClassFrPriceEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;
  val t;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteFrPrice(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassFrPriceEFAfter = true;
  return;
end;

function Boolean ORDClassSalesManEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;
  record UserVc Userr;
  string 255 efstr,tstr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteSalesMan(ORr,WindEFstr(wn))
    PutWindowRecord(wn,ORr);
  end;
  ORDClassSalesManEFAfter = true;
  return;
end;

function Boolean ORDClassRegionEFAfter(Integer wn,Boolean changedf)
begin  
  record ORVc ORr;

  if (changedf) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteRegion(ORr,WindEFstr(wn))
    PutWindowRecord(wn,ORr);
  end;
  ORDClassRegionEFAfter = true;
  return;
end;

function Boolean ORDClassInvCountryEFAfter(Integer wn,Boolean changedf)
begin  
  record ORVc ORr;

  if (changedf) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteInvCountry(ORr,WindEFstr(wn))
    PutWindowRecord(wn,ORr);
  end;
  ORDClassInvCountryEFAfter = true;
  return;
end;

function Boolean ORDClassDelCountryEFAfter(Integer wn,Boolean changedf)
begin  
  record ORVc ORr;

  if (changedf) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteDelCountry(ORr,WindEFstr(wn))
    PutWindowRecord(wn,ORr);
  end;
  ORDClassDelCountryEFAfter = true;
  return;
end;

function Boolean ORDClassOrderTypeEFAfter(Integer wn,Integer rownr,Boolean changedf)
begin  
  record ORVc ORr;
  row ORVc ORrw;
  Integer i,rwcnt;

  if (changedf) and (rownr<0) then begin  
/*  
we have order type default now
    GetWindowRecord(wn,ORr);
    rwcnt = MatRowCnt(ORr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(ORr,i,ORrw);
      if (ORrw.Shipd1==0) and (ORrw.Shipd2==0) and (ORrw.Invd==0) then begin
        ORrw.OrderType = ORr.OrderType;
        MatRowPut(ORr,i,ORrw);
      end;
    end;
    PutWindowRecord(wn,ORr);
*/    
  end;
  ORDClassOrderTypeEFAfter = true;
  return;
end;


function Boolean ORDClassDelAddrCodeEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;
  val t;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteDelAddrCode(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassDelAddrCodeEFAfter = true;
  return;
end;

function Boolean ORDClassDiscPercEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;
  val t;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    MulM4ProcVal(ORr.DiscPerc,ORr.Sum1,t);
    ORr.DiscSum = t;
    if (ORr.DiscPerc==0) then begin ORr.DiscSum = blankval; end;
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassDiscPercEFAfter = true;
  return;
end;

function Boolean ORDClassPayDealEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePayDeal(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassPayDealEFAfter = true;
  return;
end;

function Boolean ORDClassPRCodeEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePRCode(ORr);
    PutWindowRecord(wn,ORr);
    AutomatedSalesOrderly("HasModTS+Edit_ORVc");
  end;  
  ORDClassPRCodeEFAfter = true;
  return;
end;
 
function Boolean ORDClassCurncyCodeEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteCurncyCode(ORr,WindEFstr(wn));
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassCurncyCodeEFAfter = true;
  return;
end;

function Boolean ORDClassBaseRate2EFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORr.BaseSum4 = MulRateToBase1(ORr.CurncyCode,ORr.Sum4,ORr.FrRate,ORr.ToRateB1,ORr.ToRateB2,ORr.BaseRate1,ORr.BaseRate2,DefaultCurRoundOff);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassBaseRate2EFAfter = true;
  return;
end;

function Boolean ORDClassBaseRate1EFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORr.BaseSum4 = MulRateToBase1(ORr.CurncyCode,ORr.Sum4,ORr.FrRate,ORr.ToRateB1,ORr.ToRateB2,ORr.BaseRate1,ORr.BaseRate2,DefaultCurRoundOff);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassBaseRate1EFAfter = true;
  return;
end;

function Boolean ORDClassFrRateEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORr.BaseSum4 = MulRateToBase1(ORr.CurncyCode,ORr.Sum4,ORr.FrRate,ORr.ToRateB1,ORr.ToRateB2,ORr.BaseRate1,ORr.BaseRate2,DefaultCurRoundOff);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassFrRateEFAfter = true;
  return;
end;

function Boolean ORDClassToRateB1EFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORr.BaseSum4 = MulRateToBase1(ORr.CurncyCode,ORr.Sum4,ORr.FrRate,ORr.ToRateB1,ORr.ToRateB2,ORr.BaseRate1,ORr.BaseRate2,DefaultCurRoundOff);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassToRateB1EFAfter = true;
  return;
end;

function Boolean ORDClassToRateB2EFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORr.BaseSum4 = MulRateToBase1(ORr.CurncyCode,ORr.Sum4,ORr.FrRate,ORr.ToRateB1,ORr.ToRateB2,ORr.BaseRate1,ORr.BaseRate2,DefaultCurRoundOff);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassToRateB2EFAfter = true;
  return;
end;
 
function Boolean ORDClassCommisionEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteCommision(ORr,chsum);
    if (chsum) then begin
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassCommisionEFAfter = true;
  return;
end;

function Boolean ORDClassPriceListEFAfter(Integer wn,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePriceList(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassPriceListEFAfter = true;
  return;
end;

global
procedure ORVc_PastePlanShipRow(var record ORVc ORp,Integer rownr)
BEGIN
  row ORVc ORrw;
  record PlanDeliveryBlock PlanDelRec;
  LongInt week;
  Date d;
  
  MatRowGet(ORp,rownr,ORrw);
  BlockLoad(PlanDelRec);
  switch (PlanDelRec.FieldType) begin
    case 1:
      d = StringToDate(ORrw.PlanShipRow);
      ORrw.PlanShipRow = d;
    case 2: 
      week = StringToLongInt(ORrw.PlanShipRow);
      ORrw.PlanShipRow = week;
    case 3: 
      week = StringToLongInt(ORrw.PlanShipRow);
      ORrw.PlanShipRow = week;
      if (len(ORrw.PlanShipRow)<4) then begin
        ORrw.PlanShipRow = "0" & ORrw.PlanShipRow;
      end;
      if (len(ORrw.PlanShipRow)>4) then begin
        ORrw.PlanShipRow = Left(ORrw.PlanShipRow,4);
      end;
  end;
  MatRowPut(ORp,rownr,ORrw);
  RETURN;
END;

function Boolean ORDClassPlanShipRowEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePlanShipRow(ORr,rownr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassPlanShipRowEFAfter = true;
  return;
end;
 
function Boolean ORDClassUnitCodeEFAfter(Integer wn,Integer fn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteUnitCode(ORr,rownr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassUnitCodeEFAfter = true;
  return;
end;

function Boolean ORDClassUnitFactQuantEFAfter(Integer wn,Integer fn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    chsum = ORVc_PasteUnitFactQuant(ORr,rownr);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassUnitFactQuantEFAfter = true;
  return;
end;

function Boolean ORDClassUnitFactPriceEFAfter(Integer wn,Integer fn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteUnitFactPrice(ORr,rownr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassUnitFactPriceEFAfter = true;
  return;
end;

function Boolean ORDClassRecepyEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteRecepy(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
    end;    
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassRecepyEFAfter = true;
  return;
end;

function Boolean ORDClassPriceFactorEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePriceFactor(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassPriceFactorEFAfter = true;
  return;
end;

function Boolean ORDClassPriceEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastePrice(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;
    PutWindowRecord(wn,ORr);
    AutomatedSalesOrderly("HasPriceLists+Edit_ORVc");
  end;  
  ORDClassPriceEFAfter = true;
  return;
end;

function Boolean ORDClassvRebateEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PastevRebate(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
    AutomatedSalesOrderly("HasPriceLists+Edit_ORVc");
  end;  
  ORDClassvRebateEFAfter = true;
  return;
end;

function Boolean ORDClassBasePriceEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteBasePrice(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;    
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassBasePriceEFAfter = true;
  return;
end;

function Boolean ORDClassVATCodeEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteVATCode2(ORr,rownr,WindEFStr(wn),chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
    end;    
    ORSumup(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassVATCodeEFAfter = true;
  return;
end;

function Boolean ORDClassTaxTemplateCodeEFAfter(Integer wn,Integer rownr,Boolean changedf)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changedf) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteTaxTemplateCode(ORr,rownr,chsum);
    if (chsum) then begin
      ORDchsum(ORr,rownr);
    end;    
    ORSumup(ORr);
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassTaxTemplateCodeEFAfter = true;
  return;
end;

function Boolean ORDClassSumEFAfter(Integer wn,Integer rownr,Integer changed)
begin  
  record ORVc ORr;
  Boolean chsum;

  if (changed!=0) and (rownr>=0) then begin  
    GetWindowRecord(wn,ORr);
    ORVc_PasteSum(ORr,rownr,chsum);
    if (chsum) then begin      
//      chsum = ORDchrsum(ORr,rownr);
      ORDchsum(ORr,rownr);
      ORSumup(ORr);
    end;
    PutWindowRecord(wn,ORr);
  end;  
  ORDClassSumEFAfter = true;
  return;
end;

function Boolean ORDClassLocationEFAfter(Integer wn,Integer rownr,Boolean changedf)
begin
  record ORVc ORr;
  
  if (changedf) then begin
    GetWindowRecord(wn,ORr);
    ORVc_PasteLocation(ORr,rownr);
    PutWindowRecord(wn,ORr);
  end;
  ORDClassLocationEFAfter = true;
  return;
end;

function Boolean ORDClassDespatchDateEFAfter(Integer wn,Integer changed)
begin
  record ORVc ORr;
  
  if (changed!=0) then begin
    GetWindowRecord(wn,ORr);
    ORVc_GetPriceList2(ORr,false);
    PutWindowRecord(wn,ORr);    
  end;
  ORDClassDespatchDateEFAfter = true;
end;

global
function Boolean ORDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "Sum": res = ORDClassSumEFAfter(wn,rownr,changed);
    case "Recepy": res = ORDClassRecepyEFAfter(wn,rownr,changed);
    case "PriceFactor": res = ORDClassPriceFactorEFAfter(wn,rownr,changed);
    case "Price": res = ORDClassPriceEFAfter(wn,rownr,changed);
    case "vRebate": res = ORDClassvRebateEFAfter(wn,rownr,changed);
    case "BasePrice": res = ORDClassBasePriceEFAfter(wn,rownr,changed);
    case "VATCode": res = ORDClassVATCodeEFAfter(wn,rownr,changed);
    case "TaxTemplateCode": res = ORDClassTaxTemplateCodeEFAfter(wn,rownr,changed!=0);
    case "UnitFactPrice": res = ORDClassUnitFactPriceEFAfter(wn,fn,rownr,changed);
    case "UnitFactQuant": res = ORDClassUnitFactQuantEFAfter(wn,fn,rownr,changed);
    case "UnitCode": res = ORDClassUnitCodeEFAfter(wn,fn,rownr,changed);
    case "PlanShipRow": res = ORDClassPlanShipRowEFAfter(wn,rownr,changed);
    case "PriceList": res = ORDClassPriceListEFAfter(wn,changed);
    case "Commision": res = ORDClassCommisionEFAfter(wn,changed);
    case "FrRate": res = ORDClassFrRateEFAfter(wn,changed);
    case "ToRateB1": res = ORDClassToRateB1EFAfter(wn,changed);
    case "ToRateB2": res = ORDClassToRateB2EFAfter(wn,changed);
    case "BaseRate1": res = ORDClassBaseRate1EFAfter(wn,changed);
    case "BaseRate2": res = ORDClassBaseRate2EFAfter(wn,changed);
    case "CurncyCode": res = ORDClassCurncyCodeEFAfter(wn,changed);
    case "PRCode": res = ORDClassPRCodeEFAfter(wn,changed);
    case "PayDeal": res = ORDClassPayDealEFAfter(wn,changed);
    case "DiscPerc": res = ORDClassDiscPercEFAfter(wn,changed);
    case "DelAddrCode": res = ORDClassDelAddrCodeEFAfter(wn,changed);
    case "SalesMan": res = ORDClassSalesManEFAfter(wn,changed);
    case "FrPrice": res = ORDClassFrPriceEFAfter(wn,changed);
    case "OrdDate": res = ORDClassOrdDateEFAfter(wn,changed);
    case "PlanShip": res = ORDClassPlanShipEFAfter(wn,fn,rownr,changed);
    case "SerialNr": res = ORDClassSerialNrEFAfter(wn,fn,rownr,changed);
    case "UnitZval": res = ORDClassUnitZvalEFAfter(wn,fn,rownr,changed);
    case "UnitYval": res = ORDClassUnitYvalEFAfter(wn,fn,rownr,changed);
    case "UnitXval": res = ORDClassUnitXvalEFAfter(wn,fn,rownr,changed);
    case "CustCode": res = ORDClassCustCodeEFAfter(wn,fn,rownr,changed);
    case "Quant": res = ORDClassQuantEFAfter(wn,fn,rownr,changed);
    case "ArtCode": res = ORDClassArtCodeEFAfter(wn,rownr,changed);
    case "Location": res = ORDClassLocationEFAfter(wn,rownr,changed);
    case "Region": res = ORDClassRegionEFAfter(wn,changed!=0);
    case "InvCountry": res = ORDClassInvCountryEFAfter(wn,changed!=0);
    case "DelCountry": res = ORDClassDelCountryEFAfter(wn,changed!=0);
    case "OrderType": res = ORDClassOrderTypeEFAfter(wn,rownr,changed!=0);
    case "DespatchDate": res = ORDClassDespatchDateEFAfter(wn,changed);
  end;
  ORDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORDClassBeforeEditField(Integer wn,string fieldname,Integer fn, Integer rownr)
BEGIN
  Boolean res;
  record ORVc ORr;
  row ORVc ORrw;

  switch (fieldname) begin  
    case "Quant":     
      GetWindowRecord(wn,ORr);      
      MatRowGet(ORr,rownr,ORrw);
      if (ORrw.Quant==0) then begin
        if (TestForMATVARINS(wn)) then begin end;
      end;
  end;
  ORDClassBeforeEditField = res;
  return;
end;

// iOS functions follows

global 
procedure ORDClassOpenTerms()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORTermsDClass",1,wn,subset,"",ORr);
  RETURN;
END;

global
function boolean ORTermsDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORTermsDClassOnOKWindow = true;
end;

global
function Boolean ORTermsDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "PRCode": res = ORDClassPRCodeEFAfter(wn,changed);
    case "PayDeal": res = ORDClassPayDealEFAfter(wn,changed);
    case "SalesMan": res = ORDClassSalesManEFAfter(wn,changed);
    case "OrdDate": res = ORDClassOrdDateEFAfter(wn,changed);
    case "PlanShip": res = ORDClassPlanShipEFAfter(wn,fn,rownr,changed);
  end;
  ORTermsDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORTermsDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORTermsDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenItems()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORItemsDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORItemsDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORItemsDClassOnOKWindow = true;
end;

global
function Boolean ORItemsDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "CurncyCode": res = ORDClassCurncyCodeEFAfter(wn,changed);
  end;
  ORItemsDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORItemsDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORItemsDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenCurrency()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORCurrencyDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORCurrencyDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORCurrencyDClassOnOKWindow = true;
end;

global
function Boolean ORCurrencyDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;
  Integer mwn;
  record ORVc ORr;
  
  switch (fieldname) begin
    case "FrRate": res = ORDClassFrRateEFAfter(wn,changed);
    case "ToRateB1": res = ORDClassToRateB1EFAfter(wn,changed);
    case "ToRateB2": res = ORDClassToRateB2EFAfter(wn,changed);
    case "BaseRate1": res = ORDClassBaseRate1EFAfter(wn,changed);
    case "BaseRate2": res = ORDClassBaseRate2EFAfter(wn,changed);
    case "CurncyCode": res = ORDClassCurncyCodeEFAfter(wn,changed);
  end;
  
  ORCurrencyDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORCurrencyDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORCurrencyDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenDelTerms()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORDelTermsDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORDelTermsDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORDelTermsDClassOnOKWindow = true;
end;

global
function Boolean ORDelTermsDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "FrPrice": res = ORDClassFrPriceEFAfter(wn,changed);
    case "Location": res = ORDClassLocationEFAfter(wn,rownr,changed);
  end;
  ORDelTermsDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORDelTermsDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORDelTermsDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenPriceList()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORPriceListDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORPriceListDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORPriceListDClassOnOKWindow = true;
end;

global
function Boolean ORPriceListDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "PriceList": res = ORDClassPriceListEFAfter(wn,changed);
    case "Commision": res = ORDClassCommisionEFAfter(wn,changed);
    case "DiscPerc": res = ORDClassDiscPercEFAfter(wn,changed);
  end;
  ORPriceListDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORPriceListDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORPriceListDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenInvAddress()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORInvAddressDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORInvAddressDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORInvAddressDClassOnOKWindow = true;
end;

global
function Boolean ORInvAddressDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "Region": res = ORDClassRegionEFAfter(wn,changed!=0);
  end;
  ORInvAddressDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORInvAddressDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORInvAddressDClassActiveEditField = res;
  return;
end;

global 
procedure ORDClassOpenDelAddress()
BEGIN
  Integer wn,nwn;
  string 255 subset;
  record ORVc ORr;
  
  wn = CurWindow;
  GetWindowRecord(wn,ORr);
  nwn = OpenWindow("ORDelAddressDClass",1,wn,subset,"",ORr);
  PutWindowRecord(wn,ORr);
  RETURN;
END;

global
function boolean ORDelAddressDClassOnOKWindow(Integer wn)
begin
  record ORVc ORr;
  Integer mwn;

  mwn = MotherWindow(wn);
  if (WindowState(mwn)==Rs_normal) then begin
    SetWindowState(mwn,Rs_update);
  end;
  if (WindowState(mwn)!=Rs_normal) then begin
    GetWindowRecord(wn,ORr);
    PutWindowRecord(mwn,ORr);
  end;
  CloseWindow(wn);
  
  ORDelAddressDClassOnOKWindow = true;
end;

global
function Boolean ORDelAddressDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "DelAddrCode": res = ORDClassDelAddrCodeEFAfter(wn,changed);
    case "VATCode": res = ORDClassVATCodeEFAfter(wn,rownr,changed);
  end;
  ORDelAddressDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORDelAddressDClassActiveEditField(Integer wn,string fieldname,Integer fn,Integer wnst,Integer rownr,Integer changed)
begin
  Boolean res;
  Integer mwn;

  mwn = MotherWindow(wn);
  res = ORDClassActiveEditField(mwn,fieldname,fn,wnst,rownr,changed);
  ORDelAddressDClassActiveEditField = res;
  return;
end;

global
procedure ORDClassEditRow(Integer wn,Integer rwn)
begin
  record ORVc ORr;
  row ORVc ORrw;
  record RcVc RepSpec;
  integer nwn;
  
  GetWindowRecord(wn,ORr);
  MatRowGet(ORr,rwn,ORrw);
  RepSpec.long1 = rwn;
  RepSpec.f1 = ORrw.ArtCode;
  RepSpec.long2 = ORrw.Quant;
  RepSpec.f2 = ORrw.Spec;
  RepSpec.vals0 = ORrw.Price;
  RepSpec.vals1 = ORrw.vRebate;
  RepSpec.vals2 = ORrw.Sum;
  
  nwn = OpenWindow("ORRowDClass",0,wn,"","",RepSpec);
  SendArtStat(ORrw.ArtCode,ORr.Location,"",ORrw.rowGP,0,0,ORr.OrdDate,1);
end;

global
procedure ORDClassAddRow(Integer wn,Integer rwn)
begin
  record ORVc ORr;
  row ORVc ORrw;

  GetWindowRecord(wn,ORr);
  MatRowGet(ORr,rwn,ORrw);
  ORrw.stp = kInvoiceRowTypeNormal;
  MatRowPut(ORr,rwn,ORrw);
  PutWindowRecord(wn,ORr);
  ORDClassEditRow(wn,rwn);
  return;
end;

global
procedure ORRowDClassTrash()
begin
  record RcVc RepSpec;
  record ORVc ORr;
  integer wn;
  integer mwn;
  integer rwn;
  
  wn = CurWindow;
  mwn = MotherWindow(wn);
  
  GetWindowRecord(wn,RepSpec);
  GetWindowRecord(mwn,ORr);
  
  rwn = RepSpec.long1;
  MatRowDelete(ORr,rwn);
  
  PutWindowRecord(mwn,ORr);
  CloseWindow(wn);
end;

global
function boolean ORRowDClassOnOKWindow(Integer wn)
begin
  record RcVc RepSpec;
  record ORVc ORr;
  row ORVc ORrw;
  integer mwn;
  integer rwn;
  
  mwn = MotherWindow(wn);
  GetWindowRecord(mwn,ORr);
  
  GetWindowRecord(wn,RepSpec);
  rwn = RepSpec.long1;
  
  MatRowGet(ORr,rwn,ORrw);
  
  ORrw.ArtCode = RepSpec.f1;
  ORrw.Quant = RepSpec.long2;
  ORrw.Spec = RepSpec.f2;
  ORrw.Price = RepSpec.vals0;
  ORrw.vRebate = RepSpec.vals1;
  ORrw.Sum = RepSpec.vals2;
  ORrw.stp = kInvoiceRowTypeNormal;

  MatRowPut(ORr,rwn,ORrw);
  PutWindowRecord(mwn,ORr);
  ORDClassSwitchRow(mwn,rwn);
  ORRowDClassOnOKWindow = true;
end;


global
function Boolean ORRowDClassAfterEditField(Integer wn,string fieldname,Integer fn,Integer rownr,Integer changed)
BEGIN
  Boolean res;
  Integer mwn;
  Integer rwn;
  record RcVc RepSpec;
  record ORVc ORr,OR2r;
  row ORVc ORrw;
  
  GetWindowRecord(wn,RepSpec);
  rwn = RepSpec.long1;

  mwn = MotherWindow(wn);
  GetWindowRecord(mwn,ORr);
//  GetWindowRecord(mwn,OR2r);
  
  MatRowGet(ORr,rwn,ORrw);
  ORrw.ArtCode = RepSpec.f1;
  ORrw.Quant = RepSpec.long2;
  ORrw.Spec = RepSpec.f2;
  ORrw.Price = RepSpec.vals0;
  ORrw.vRebate = RepSpec.vals1;
  ORrw.Sum = RepSpec.vals2;
  MatRowPut(ORr,rwn,ORrw);
  PutWindowRecord(mwn,ORr);
  
  switch (fieldname) begin
//    case "Recepy": res = ORDClassRecepyEFAfter(wn,rownr,changed);
//    case "PriceFactor": res = ORDClassPriceFactorEFAfter(wn,rownr,changed);
//    case "BasePrice": res = ORDClassBasePriceEFAfter(wn,rownr,changed);
//    case "TaxTemplateCode": res = ORDClassTaxTemplateCodeEFAfter(wn,rownr,changed!=0);
//    case "UnitFactPrice": res = ORDClassUnitFactPriceEFAfter(wn,fn,rownr,changed);
//    case "UnitFactQuant": res = ORDClassUnitFactQuantEFAfter(wn,fn,rownr,changed);
//    case "UnitCode": res = ORDClassUnitCodeEFAfter(wn,fn,rownr,changed);
//    case "PlanShipRow": res = ORDClassPlanShipRowEFAfter(wn,rownr,changed);
//    case "SerialNr": res = ORDClassSerialNrEFAfter(wn,fn,rownr,changed);
//    case "UnitZval": res = ORDClassUnitZvalEFAfter(wn,fn,rownr,changed);
//    case "UnitYval": res = ORDClassUnitYvalEFAfter(wn,fn,rownr,changed);
//    case "UnitXval": res = ORDClassUnitXvalEFAfter(wn,fn,rownr,changed);
    case "long2": res = ORDClassQuantEFAfter(mwn,fn,rwn,changed);
    case "f1": 
            res = ORDClassArtCodeEFAfter(mwn,rwn,changed);
            if (res) then begin
              GetWindowRecord(mwn,ORr);
              MatRowGet(ORr,rwn,ORrw);
              if (ORrw.Quant==0) then begin
                ORrw.Quant = 1;
                MatRowPut(ORr,rwn,ORrw);
                PutWindowRecord(mwn,ORr);
                ORDClassQuantEFAfter(mwn,fn,rwn,changed);
              end;
            end;
    case "vals0": res = ORDClassPriceEFAfter(mwn,rwn,changed);
    case "vals1": res = ORDClassvRebateEFAfter(mwn,rwn,changed);
    case "vals2": res = ORDClassSumEFAfter(mwn,rwn,changed);
  end;

  if (res==true and changed!=0) then begin
    GetWindowRecord(mwn,ORr);
    MatRowGet(ORr,rwn,ORrw);
    RepSpec.f1 = ORrw.ArtCode;
    RepSpec.long2 = ORrw.Quant;
    RepSpec.f2 = ORrw.Spec;
    RepSpec.vals0 = ORrw.Price;
    RepSpec.vals1 = ORrw.vRebate;
    RepSpec.vals2 = ORrw.Sum;
    PutWindowRecord(wn,RepSpec);
    SendArtStat(ORrw.ArtCode,ORr.Location,"",ORrw.rowGP,0,0,ORr.OrdDate,1);
  end;
  PutWindowRecord(mwn,ORr);

  ORRowDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORDClassOpenRecord(Integer wn,string fieldname,Integer fn,Integer rownr)
begin
  Boolean res;
  record ORVc ORr;
  record DelAddrVc DelAddrr;
  
  res = false;
  GetWindowRecord(wn,ORr);
  switch (fieldname) begin
    case "CustContact":
      res = OpenContactRecord(ORr.CustContact,ORr.CustCode);
    case "DelAddrCode":
      if (nonblank(ORr.DelAddrCode)) then begin
        DelAddrr.DelCode = ORr.DelAddrCode;
        DelAddrr.CustCode = ORr.CustCode;
        if (ReadFirstMain(DelAddrr,2,true)) then begin
          OpenWindow("DelAddrDClass",0,0,"","",DelAddrr); 
          res = true;
        end;
      end;
  end;
  
  ORDClassOpenRecord = res;
end;
