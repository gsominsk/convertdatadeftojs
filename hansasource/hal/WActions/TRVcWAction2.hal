external procedure WarnFutureDate(Boolean,Date);
external function roundmode DefaultRoundMode();
remote function Integer TRVc_PasteNumber(var record TRVc,var string);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function Integer GetIntYc(Date);
external procedure DivM4OneRate(val,val,var val);
external procedure MulM4OneRate(val,val,var val,roundmode,Boolean);
external procedure GetFullCurncyRate (var string,Date,var val,var val,var val,var val,var val);
external function val DivRateToBase2(string,val,val,val,val,val,val,roundmode);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external procedure SpecialRateCalc(val,val,val,var val);
remote procedure TRAccName(var record TRVc,Integer,Boolean,Boolean);
remote procedure TRVc_PasteCurncy(var record TRVc,Integer);
remote function Boolean PasteSerNrInTRrw(var record TRVc,Integer);
remote function Boolean TRVc_PasteObjects(var record TRVc,Integer);
remote function Boolean TRVc_PasteCompCode(var record TRVc,Integer);
remote function Boolean TRVc_PasteACShort(var record TRVc,Integer,Integer);
remote function Boolean TRVc_PasteAccNumber(var record TRVc,Integer,Integer,Boolean);
external function Boolean WarnOldRecords(Date,string,LongInt);
external function Boolean DateLocked(Date,string);
external function Boolean DateWarned(Date,string);
remote procedure SetTRObjectRows(var record TRVc);

procedure TRUpdateCurDebValRows(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.CredVal = sv;
  TRrp.CredVal2 = sv;
  TRrp.CurCredVal = sv;
  if (TRrp.Typ==0) then begin
    if ((TRrp.DebVal==0) and 
        ((TRrp.ToRateB1!=0) or (TRrp.ToRateB2!=0))) then begin
      sv = MulRateToBase1(TRrp.Curncy,TRrp.CurDebVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
      TRrp.DebVal = sv;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      TRrp.DebVal2 = sv;
    end;
    if ((TRrp.DebVal!=0) and 
        ((TRrp.ToRateB1==0) and (TRrp.ToRateB2==0))) then begin  
      tor1 = blankval;
      tor2 = blankval;
      if (TRrp.FrRate==0) then begin // Old Currency Style 
        sv = TRrp.DebVal*100;
        tor1 = sv/TRrp.CurDebVal;
        tor1 = Round(tor1,DefaultRoundMode);
      end else begin
        GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
        sv = TRrp.DebVal/TRrp.CurDebVal;
        sv = sv*TRrp.FrRate;
        SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
        sv = Round(sv,DefaultRoundMode);
        if (tor1==0) then begin // Only one is filled at this moment 
          tor2 = sv;
        end else begin
          tor1 = sv;
        end;
      end;
      TRrp.ToRateB1 = tor1;
      TRrp.ToRateB2 = tor2;
    end;
  end else begin
    if (true) then begin  
      sv = MulRateToBase1(TRrp.Curncy,TRrp.CurDebVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
      TRrp.DebVal = sv;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      TRrp.DebVal2 = sv;
    end;
  end;
  RETURN;
END;

procedure TRUpdateCurCredValRows(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.DebVal = sv;
  TRrp.DebVal2 = sv;
  TRrp.CurDebVal = sv;
  if (TRrp.Typ==0) then begin
    if ((TRrp.CredVal==0) and 
        ((TRrp.ToRateB1!=0) or (TRrp.ToRateB2!=0))) then begin
      sv = MulRateToBase1(TRrp.Curncy,TRrp.CurCredVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
      TRrp.CredVal = sv;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      TRrp.CredVal2 = sv;
    end;
    if ((TRrp.CredVal!=0) and 
        ((TRrp.ToRateB1==0) and (TRrp.ToRateB2==0))) then begin  
      tor1 = blankval;
      tor2 = blankval;
      if (TRrp.FrRate==0) then begin // Old Currency Style 
        sv = TRrp.CredVal*100;
        tor1 = sv/TRrp.CurCredVal;
        tor1 = Round(tor1,DefaultRoundMode);
      end else begin
        GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
        sv = TRrp.CredVal/TRrp.CurCredVal;
        sv = sv*TRrp.FrRate;
        SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
        sv = Round(sv,DefaultRoundMode);
        if (tor1==0) then begin // Only one is filled at this moment 
          tor2 = sv;
        end else begin
          tor1 = sv;
        end;
      end;
      TRrp.ToRateB1 = tor1;
      TRrp.ToRateB2 = tor2;
    end;
  end else begin
    if (true) then begin  
      sv = MulRateToBase1(TRrp.Curncy,TRrp.CurCredVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
      TRrp.CredVal = sv;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      TRrp.CredVal2 = sv;
    end;
  end;
  RETURN;
END;

global
function Integer Norm2Cont(string a,val dvp,val cvp)
BEGIN
  Boolean Accs;
  record AccVc Accr;
  Integer res;

  Accr.AccNumber = a;
  Accs = ReadFirstKey("AccNumber",Accr,1,true);
  if (Accs==true) then begin
    if (dvp!=0) then begin
      if (Accr.NVD==0) then begin
        res = 1044;
      end;
    end;
    if (cvp!=0) then begin
      if (Accr.NVC==0) then begin
        res = 1044;
      end;
    end;
  end;
  Norm2Cont = res;
  RETURN;
END;

global
procedure TRSumup(var record TRVc TRr,var val base2diff)
BEGIN
  Integer i,rwcnt;
  row TRVc TRrw;
  val deb2,cred2;
  val CSum,CSum2;
  
  SetTRObjectRows(TRr);
  TRr.DSum = blankval;
  TRr.CSum = blankval;
  TRr.DSum2 = blankval;
  TRr.CSum2 = blankval;
  rwcnt = MatRowCnt(TRr);
  for (i=0; i<rwcnt; i=i+1) begin
    MatRowGet(TRr,i,TRrw);
    if ((TRrw.stp==1) and (TRrw.ovst==0)) then begin
      if ((nonblank(TRrw.DebVal)) or (nonblank(TRrw.CredVal))) then begin
        TRr.DSum = TRr.DSum + TRrw.DebVal;
        CSum = CSum + TRrw.CredVal;
      end;
      if ((nonblank(TRrw.DebVal2)) or (nonblank(TRrw.CredVal2))) then begin
        deb2 = deb2 + TRrw.DebVal2;
        cred2 = cred2 + TRrw.CredVal2;
        TRr.DSum2 = TRr.DSum2 + TRrw.DebVal2;
        CSum2 = CSum2 + TRrw.CredVal2;
      end;
    end;
  end;
  TRr.DSum = Round(TRr.DSum,DefaultRoundMode);
  TRr.DSum2 = Round(TRr.DSum2,DefaultRoundMode);
  TRr.CSum = -Round(CSum,DefaultRoundMode);
  TRr.CSum2 = -Round(CSum2,DefaultRoundMode);
  TRr.DiffVal = TRr.DSum + TRr.CSum;
  TRr.Diff2Val = TRr.DSum2 + TRr.CSum2;
  if (base2diff!=-1) then begin
    deb2 = Round(deb2,DefaultRoundMode);
    cred2 = -Round(cred2,DefaultRoundMode);
    base2diff = deb2 + cred2;
    base2diff = Round(base2diff,DefaultRoundMode);
  end;
  RETURN;
END;

global
procedure SpecialRateCalc(val from,val baserate1,val baserate2,var val to)
BEGIN
  val baserate;
  
  if (baserate1<baserate2) then begin
    DivM4OneRate(baserate2,baserate1,baserate);
    MulM4OneRate(from,baserate,to,DefaultCurRoundOff,false);
  end else begin
    DivM4OneRate(baserate1,baserate2,baserate);
    DivM4OneRate(from,baserate,to);
  end;
  RETURN;
END;

global
procedure TRUpdateCredRows(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.DebVal = sv;
  TRrp.DebVal2 = sv;
  TRrp.CurDebVal = sv;
/*  
works difrently only for value ZERO ?  how intuitive it is ?   
  if ((TRrp.CredVal==0) and (TRrp.CredVal2!=0)) then begin
    goto LTRUpdateCredRows;
  end;
*/  
  SpecialRateCalc(TRrp.CredVal,TRrp.BaseRate1,TRrp.BaseRate2,sv);
  sv = Round(sv,DefaultRoundMode);
//  if (M4ValBlankTest(&TRrp.CredVal2)) then//people say it is bug
  TRrp.CredVal2 = sv;
  if (((nonblank(TRrp.ToRateB1)) or (nonblank(TRrp.ToRateB2)))) then begin
    sv = DivRateToBase1(TRrp.Curncy,TRrp.CredVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
    TRrp.CurCredVal = sv;
  end;
  if ((nonblank(TRrp.CredVal)) and
      ((blank(TRrp.ToRateB1)) and (blank(TRrp.ToRateB2)))) then begin
    tor1 = blankval;
    tor2 = blankval;
    if (TRrp.FrRate==0) then begin // Old Currency Style 
      sv = TRrp.CredVal*100;
      tor1 = sv/TRrp.CurCredVal;
      tor1 = Round(tor1,DefaultRoundMode);
    end else begin
      GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = TRrp.CredVal/TRrp.CurCredVal;
      sv = sv*TRrp.FrRate;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin // Only one is filled at this moment 
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    TRrp.ToRateB1 = tor1;
    TRrp.ToRateB2 = tor2;
  end;
LTRUpdateCredRows:;  
  RETURN;
END;

global
procedure TRUpdateDebRows(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.CredVal = sv;
  TRrp.CredVal2 = sv;
  TRrp.CurCredVal = sv;
/*  
works difrently only for value ZERO ?  how intuitive it is ? 
  if ((TRrp.DebVal==0) and (TRrp.DebVal2!=0)) then begin
    goto LTRUpdateDebRows;
  end;
*/  
  SpecialRateCalc(TRrp.DebVal,TRrp.BaseRate1,TRrp.BaseRate2,sv);
  sv = Round(sv,DefaultRoundMode);
//  if (M4ValBlankTest(&TRrp.DebVal2)) then//people say it is bug
  TRrp.DebVal2 = sv;
  if (((nonblank(TRrp.ToRateB1)) or (nonblank(TRrp.ToRateB2)))) then begin
    sv = DivRateToBase1(TRrp.Curncy,TRrp.DebVal,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
    TRrp.CurDebVal = sv;
  end;
  if ((nonblank(TRrp.DebVal)) and
      ((blank(TRrp.ToRateB1)) and (blank(TRrp.ToRateB2)))) then begin
    tor1 = blankval;
    tor2 = blankval;
    if (TRrp.FrRate==0) then begin // Old Currency Style 
      sv = TRrp.DebVal*100;
      tor1 = sv/TRrp.CurDebVal;
      tor1 = Round(tor1,DefaultRoundMode);
    end else begin
      GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = TRrp.DebVal/TRrp.CurDebVal;
      sv = sv*TRrp.FrRate;
      SpecialRateCalc(sv,TRrp.BaseRate1,TRrp.BaseRate2,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin // Only one is filled at this moment 
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    TRrp.ToRateB1 = tor1;
    TRrp.ToRateB2 = tor2;
  end;
LTRUpdateDebRows:;  
  RETURN;
END;

global
procedure TRUpdateDebRows2(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.CredVal = sv;
  TRrp.CredVal2 = sv;
  TRrp.CurCredVal = sv;
  SpecialRateCalc(TRrp.DebVal2,TRrp.BaseRate2,TRrp.BaseRate1,sv);
  sv = Round(sv,DefaultRoundMode);
  if (blank(TRrp.DebVal)) then begin
    TRrp.DebVal = sv;
  end;
  if (((nonblank(TRrp.ToRateB1)) or (nonblank(TRrp.ToRateB2)))) then begin
    sv = DivRateToBase2(TRrp.Curncy,TRrp.DebVal2,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
    TRrp.CurDebVal = sv;
  end;
  if ((nonblank(TRrp.DebVal2)) and
      ((blank(TRrp.ToRateB1)) and (blank(TRrp.ToRateB2)))) then begin
    tor1 = blankval;
    tor2 = blankval;
    if (TRrp.FrRate!=0) then begin // Old Currency Style 
      GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = TRrp.DebVal2/TRrp.CurDebVal;
      sv = sv*TRrp.FrRate;
      SpecialRateCalc(sv,TRrp.BaseRate2,TRrp.BaseRate1,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin /* Only one is filled at this moment */
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    TRrp.ToRateB1 = tor1;
    TRrp.ToRateB2 = tor2;
  end;
  RETURN;
END;

global
procedure TRUpdateCredRows2(var row TRVc TRrp,Date trdat)
BEGIN
  val sv,tor1,tor2;
  val temp;
  
  TRrp.DebVal = sv;
  TRrp.DebVal2 = sv;
  TRrp.CurDebVal = sv;
  SpecialRateCalc(TRrp.CredVal2,TRrp.BaseRate2,TRrp.BaseRate1,sv);
  sv = Round(sv,DefaultRoundMode);
  if (blank(TRrp.CredVal)) then begin
    TRrp.CredVal = sv;
  end;
  if (((nonblank(TRrp.ToRateB1)) or (nonblank(TRrp.ToRateB2)))) then begin
    sv = DivRateToBase2(TRrp.Curncy,TRrp.CredVal2,TRrp.FrRate,TRrp.ToRateB1,TRrp.ToRateB2,TRrp.BaseRate1,TRrp.BaseRate2,DefaultCurRoundOff);
    TRrp.CurCredVal = sv;
  end;
  if ((nonblank(TRrp.CredVal2)) and
      ((blank(TRrp.ToRateB1)) and (blank(TRrp.ToRateB2)))) then begin
    tor1 = blankval;
    tor2 = blankval;
    if (TRrp.FrRate!=0) then begin // Old Currency Style 
      GetFullCurncyRate(TRrp.Curncy,trdat,temp,tor1,tor2,temp,temp);
      sv = TRrp.CredVal2/TRrp.CurCredVal;
      sv = sv*TRrp.FrRate;
      SpecialRateCalc(sv,TRrp.BaseRate2,TRrp.BaseRate1,sv);
      sv = Round(sv,DefaultRoundMode);
      if (tor1==0) then begin /* Only one is filled at this moment */
        tor2 = sv;
      end else begin
        tor1 = sv;
      end;
    end;
    TRrp.ToRateB1 = tor1;
    TRrp.ToRateB2 = tor2;
  end;
  RETURN;
END;

procedure TRVc_PasteCredVal(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  record BaseCurBlock BaseCurRec;
  row TRVc TRrw;
  val t;

  BlockLoad(CompYear);
  BlockLoad(BaseCurRec);
  MatRowGet(TRp,rownr,TRrw);
  if (blank(TRrw.AccNumber)) or (blank(TRrw.Curncy)) then begin
    GetFullCurncyRate(TRrw.Curncy,TRp.TransDate,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2);
  end;
  TRUpdateCredRows(TRrw,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrw.AccNumber,t,TRrw.CredVal);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  if (blank(BaseCurRec.BaseCur2)) then begin
    TRrw.CredVal2 = blankval;
  end;
  MatRowPut(TRp,rownr,TRrw);
  TRSumup(TRp,t);
  RETURN;
END;

procedure TRVc_PasteDebVal(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  record BaseCurBlock BaseCurRec;
  row TRVc TRrw;
  val t;

  BlockLoad(CompYear);
  BlockLoad(BaseCurRec);
  MatRowGet(TRp,rownr,TRrw);
  if (blank(TRrw.AccNumber)) or (blank(TRrw.Curncy)) then begin
    GetFullCurncyRate(TRrw.Curncy,TRp.TransDate,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2);
  end;
  TRUpdateDebRows(TRrw,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrw.AccNumber,TRrw.DebVal,t);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  if (blank(BaseCurRec.BaseCur2)) then begin
    TRrw.DebVal2 = blankval;
  end;
  MatRowPut(TRp,rownr,TRrw);
  TRSumup(TRp,t);
  RETURN;
END;

procedure TRVc_PasteDebVal2(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  row TRVc TRrr;
  val t;

  BlockLoad(CompYear);
  MatRowGet(TRp,rownr,TRrr);
  TRUpdateDebRows2(TRrr,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrr.AccNumber,TRrr.DebVal2,t);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  MatRowPut(TRp,rownr,TRrr);
  TRSumup(TRp,t);
  RETURN;
END;

procedure TRVc_PasteCredVal2(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  row TRVc TRrr;
  val t;

  BlockLoad(CompYear);
  MatRowGet(TRp,rownr,TRrr);
  TRUpdateCredRows2(TRrr,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrr.AccNumber,t,TRrr.CredVal2);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  MatRowPut(TRp,rownr,TRrr);
  TRSumup(TRp,t);
  RETURN;
END;

procedure TRVc_PasteCurDebVal(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  record BaseCurBlock BaseCurRec;
  row TRVc TRrr;
  val t;

  BlockLoad(BaseCurRec);
  BlockLoad(CompYear);
  MatRowGet(TRp,rownr,TRrr);
  TRUpdateCurDebValRows(TRrr,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrr.AccNumber,TRrr.DebVal,t);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  if (blank(BaseCurRec.BaseCur2)) then begin
    TRrr.DebVal2 = blankval;
  end;
  MatRowPut(TRp,rownr,TRrr);
  TRSumup(TRp,t);
  RETURN;
END;

global
procedure TRVc_PasteCurCredVal(var record TRVc TRp,Integer rownr)
BEGIN
  Integer res;
  record CYBlock CompYear;
  record BaseCurBlock BaseCurRec;
  row TRVc TRrr;
  val t;

  BlockLoad(CompYear);
  BlockLoad(BaseCurRec);
  MatRowGet(TRp,rownr,TRrr);
  TRUpdateCurCredValRows(TRrr,TRp.TransDate);
  if (CompYear.trDoNVTest==1) then begin
    res = Norm2Cont(TRrr.AccNumber,t,TRrr.CredVal);
    if (res!=0) then begin
      MessageBox(res,"");
    end;
  end;
  if (blank(BaseCurRec.BaseCur2)) then begin
    TRrr.CredVal2 = blankval;
  end;
  MatRowPut(TRp,rownr,TRrr);
  TRSumup(TRp,t);
  RETURN;
END;

function Boolean TRDClassSerNrEFAfter(Integer wn,Integer rownr,Integer changed)
BEGIN
  record TRVc TRr;
  val t;

  if ((changed!=0) and (rownr>=0)) then begin
    GetWindowRecord(wn,TRr);
    DeselectWindow(wn,false);
    if (PasteSerNrInTRrw(TRr,rownr)) then begin
      TRSumup(TRr,t);    
      PutWindowRecord(wn,TRr);
      SelectWindow(wn);
    end else begin
      Beep;
    end;
  end;
  TRDClassSerNrEFAfter = true;
  return;
end;

global
function Boolean DateTest(Date dp)
begin
  Boolean res;

  res = true;
  DateTest = res;
  return;
end;

function Boolean TRDClassNumberEFAfter(Integer wn,Boolean changedf)
BEGIN
  record TRVc TRr;
  record CYBlock CYb;
  Integer err;
  string 255 errstr;
  
  if (changedf) then begin
    BlockLoad(CYb);
    if (CYb.TRWarnOnNonChronology!=0) then begin
      GetWindowRecord(wn,TRr);
      if (blankdate(TRr.TransDate)) then begin
        TRr.TransDate = TRr.RegDate;
      end;
      err = TRVc_PasteNumber(TRr,errstr);
      if (err!=0) then begin
        MessageBox(err,errstr);
      end;
    end;
  end; 
LTRDClassNumberEFAfter:;  
  TRDClassNumberEFAfter = true;
  return;
end;

function Boolean TRDClassAccNumberEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRp;
  row TRVc TRrw;
  string 255 tstr,t2;
  Boolean res;
  
  GetWindowRecord(wn,TRp);
  res = TRVc_PasteAccNumber(TRp,WindowState(wn),rownr,changedf);
  MatRowGet(TRp,rownr,TRrw);
  if (res) then begin
    MatRowPut(TRp,rownr,TRrw);
    PutWindowRecord(wn,TRp);
    SetWindowNameArg(wn,TRrw.AccNumber);
  end;
  TRDClassAccNumberEFAfter = true;
  RETURN;
END;

function Boolean TRDClassACShortEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    if (TRVc_PasteACShort(TRr,WindowState(wn),rownr)) then begin
      PutWindowRecord(wn,TRr);
    end else begin
      Beep;
    end;  
  end;
  TRDClassACShortEFAfter = true;
  RETURN;
END;

function Boolean TRDClassCompCodeEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    if (TRVc_PasteCompCode(TRr,rownr)) then begin
      PutWindowRecord(wn,TRr);
    end else begin
      Beep;
    end;  
  end;
  TRDClassCompCodeEFAfter = true;
  RETURN;
END;

function Boolean TRDClassObjectsEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    if (TRVc_PasteObjects(TRr,rownr)) then begin
      PutWindowRecord(wn,TRr);
    end else begin
      Beep;
    end;  
  end;
  TRDClassObjectsEFAfter = true;
  RETURN;
END;

function Boolean TRDClassDebValEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteDebVal(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassDebValEFAfter = true;
  RETURN;
END;

function Boolean TRDClassDebVal2EFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteDebVal2(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassDebVal2EFAfter = true;
  RETURN;
END;

function Boolean TRDClassCredValEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteCredVal(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassCredValEFAfter = true;
  RETURN;
END;

function Boolean TRDClassCredVal2EFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteCredVal2(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassCredVal2EFAfter = true;
  RETURN;
END;

function Boolean TRDClassCurDebValEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteCurDebVal(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassCurDebValEFAfter = true;
  RETURN;
END;

function Boolean TRDClassCurCredValEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteCurCredVal(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassCurCredValEFAfter = true;
  RETURN;
END;

function Boolean TRDClassCurncyEFAfter(Integer wn,Integer rownr,Boolean changedf)
BEGIN
  record TRVc TRr;
  
  if (changedf) then begin
    GetWindowRecord(wn,TRr);
    TRVc_PasteCurncy(TRr,rownr);
    PutWindowRecord(wn,TRr);
  end;
  TRDClassCurncyEFAfter = true;
  RETURN;
END;

function Boolean TRDClassTransDateEFAfter(Integer wn,Boolean changedf)
BEGIN
  record TRVc TRr;
  row TRVc TRrw;
  Integer i,rwcnt;
  val t;
  Boolean testf;
  Integer wnst;
  
  if (changedf) then begin
    wnst = WindowState(wn);
    GetWindowRecord(wn,TRr);
    if (blankdate(TRr.TransDate)) then begin
      TRr.TransDate = TRr.RegDate;
    end;
    if (DateTest(TRr.TransDate)==false) then begin
      MessageBox(1047,"");
    end else begin
      if (DateLocked(TRr.TransDate,"TRVc")) then begin
        MessageBox(1046,"");
      end else begin
        if (DateWarned(TRr.TransDate,"TRVc")) then begin
          MessageBox(1045,"");
        end;
        if (WarnOldRecords(TRr.TransDate,"TRVc",TRr.Number)) then begin
          MessageBox(2020,"");
        end;
      end;
    end;
    testf = true;
    if (wnst==Rs_update) then begin testf = false; end;
    if (testf) then begin
      rwcnt = MatRowCnt(TRr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(TRr,i,TRrw);
        testf = true;
        switch (TRrw.Typ) begin
          case kTransactionRowTypeSupplier:
            if (TRrw.DebVal!=0) then begin testf = false; end; //payment
          case kTransactionRowTypeCustomer:
            if (TRrw.CredVal!=0) then begin testf = false; end; //receipt
          otherwise
            testf = true;
        end;
        if (testf) then begin
          TRVc_PasteCurncy(TRr,i);
          if (TRrw.DebVal!=0) then begin
            if (TRrw.CurDebVal!=0) then begin
              TRVc_PasteCurDebVal(TRr,i);
            end else begin
              TRVc_PasteDebVal(TRr,i);
            end;
          end else begin
            if (TRrw.CurCredVal!=0) then begin
              TRVc_PasteCurCredVal(TRr,i);
            end else begin
              TRVc_PasteCredVal(TRr,i);
            end;
          end;
        end;
      end;
      TRSumup(TRr,t);
    end;
    WarnFutureDate(true,TRr.TransDate);
    PutWindowRecord(wn,TRr);
//JJCS    
  end; 
  TRDClassTransDateEFAfter = true;
  return;
end;

global
function Boolean TRDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "Number": res = TRDClassNumberEFAfter(wn,changed!=0);
    case "TransDate": res = TRDClassTransDateEFAfter(wn,changed!=0);
    case "SerNr": res = TRDClassSerNrEFAfter(wn,rownr,changed);
    case "AccNumber": res = TRDClassAccNumberEFAfter(wn,rownr,changed!=0);
    case "ACShort": res = TRDClassACShortEFAfter(wn,rownr,changed!=0);
    case "CompCode": res = TRDClassCompCodeEFAfter(wn,rownr,changed!=0);
    case "Objects": res = TRDClassObjectsEFAfter(wn,rownr,changed!=0);
    case "DebVal": res = TRDClassDebValEFAfter(wn,rownr,changed!=0);
    case "DebVal2": res = TRDClassDebVal2EFAfter(wn,rownr,changed!=0);
    case "CredVal": res = TRDClassCredValEFAfter(wn,rownr,changed!=0);
    case "CredVal2": res = TRDClassCredVal2EFAfter(wn,rownr,changed!=0);
    case "CurDebVal": res = TRDClassCurDebValEFAfter(wn,rownr,changed!=0);
    case "CurCredVal": res = TRDClassCurCredValEFAfter(wn,rownr,changed!=0);
    case "Curncy": res = TRDClassCurncyEFAfter(wn,rownr,changed!=0);
  end;
  TRDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean TRDClassSwitchRow(Integer wn,Integer rownr)
begin        
  record TRVc TRr;
  row TRVc TRrw;
  
  GetWindowRecord(wn,TRr);
  if ((rownr<MatRowCnt(TRr)) and (rownr>=0)) then begin
    MatRowGet(TRr,rownr,TRrw);
    SetWindowNameArg(wn,TRrw.AccNumber);
  end;
  TRDClassSwitchRow = true;  
  return;
end;

global
procedure TrBal(record TRVc Trp,var val rp,var val rp2,Integer skiprow)
BEGIN
  val Bal,Bal2;
  row TRVc TRrw;
  Integer i,rwcnt;

  rwcnt = MatRowCnt(Trp);
  Bal = 0;
  Bal2 = 0;
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(Trp,i,TRrw);
    if (i!=skiprow) then begin
      switch (TRrw.stp) begin
        case 1: 
          if (TRrw.ovst==0) then begin
            Bal = Bal + TRrw.DebVal;
            Bal = Bal - TRrw.CredVal;
            Bal2 = Bal2 + TRrw.DebVal2;
            Bal2 = Bal2 - TRrw.CredVal2;
            Bal = Round(Bal,DefaultRoundMode);
            Bal2 = Round(Bal2,DefaultRoundMode);
          end;
      end;
    end;
  end;
  rp = Bal; 
  rp2 = Bal2; 
  RETURN;
END;

global
procedure TRDDefault(var record TRVc TRp,Integer rownr,string fieldname)
BEGIN
  Integer rwcnt,stp;
  row TRVc TRrw;
  val ct,ct2,bv,temp;

  rwcnt = MatRowCnt(TRp);
  stp = 1;
  if ((rownr!=-1) and (rownr<rwcnt)) then begin
    MatRowGet(TRp,rownr,TRrw);
    stp = TRrw.stp;
    switch (stp) begin
      case 1: 
        ct = 0;
        TRrw.DebVal = ct;
        TRrw.CredVal = ct;
        TrBal(TRp,ct,ct2,rownr);
        ct = -ct;
        ct2 = -ct2;
        if (ct>=0) then begin
          TRrw.DebVal = ct;
          if (TRrw.BaseRate1!=0 or TRrw.BaseRate2!=0) then begin
            SpecialRateCalc(ct,TRrw.BaseRate1,TRrw.BaseRate2,temp);
            temp = Round(temp,DefaultRoundMode);
            TRrw.DebVal2 = temp;
            if (TRrw.DebVal2==0) then begin
              TRrw.DebVal2 = ct2; // why should it work difrent than enterin vlaue in debval and presing enter?
            end;
          end else begin
            TRrw.DebVal2 = blankval;
          end;
          if ((blank(TRrw.CurDebVal)) and ((nonblank(TRrw.ToRateB1)) or (nonblank(TRrw.ToRateB2)))) then begin
            ct = DivRateToBase1(TRrw.Curncy,ct,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2,DefaultCurRoundOff);
            TRrw.CurDebVal = ct;
          end;
          TRrw.CredVal = blankval;
          TRrw.CredVal2 = blankval;
          TRrw.CurCredVal = blankval;
        end else begin
          ct2 = -ct2;
          bv = -ct;
          TRrw.CredVal = bv;
          if (TRrw.BaseRate1!=0 or TRrw.BaseRate2!=0) then begin
            SpecialRateCalc(bv,TRrw.BaseRate1,TRrw.BaseRate2,temp);
            temp = Round(temp,DefaultRoundMode);
            TRrw.CredVal2 = temp;
            if (TRrw.CredVal2==0) then begin
              TRrw.CredVal2 = ct2; // why should it work difrent than enterin vlaue in debval and presing enter?
            end;
          end else begin
            TRrw.CredVal2 = blankval;
          end;
          if ((blank(TRrw.CurCredVal)) and ((nonblank(TRrw.ToRateB1)) or (nonblank(TRrw.ToRateB2)))) then begin
            bv = DivRateToBase1(TRrw.Curncy,bv,TRrw.FrRate,TRrw.ToRateB1,TRrw.ToRateB2,TRrw.BaseRate1,TRrw.BaseRate2,DefaultCurRoundOff);
            TRrw.CurCredVal = bv;
          end;
          TRrw.DebVal = blankval;
          TRrw.DebVal2 = blankval;
          TRrw.CurDebVal = blankval;
        end;
        if ((TRrw.DebVal==0) and (TRrw.CredVal==0)) then begin
          if ((TRrw.DebVal2==0) and (TRrw.CredVal2==0)) then begin
            TRrw.DebVal = BlankVal;
            TRrw.CredVal = BlankVal;
          end;
        end;
        if ((TRrw.DebVal2==0) and (TRrw.CredVal2==0)) then begin
          TRrw.DebVal2 = BlankVal;
          TRrw.CredVal2 = BlankVal;
        end;
        MatRowPut(TRp,rownr,TRrw);
        TRSumup(TRp,ct);
    end;
  end;
  RETURN;
END;

global
function LongInt TRDEnterSpec(var record TRVc TRp,Integer wnst,Integer rownr,string fieldname,var Integer whattodoafter,var string gotofieldname,var Integer gotorownr)
BEGIN
  LongInt res;
  row TRVc TRrw;
  record CYBlock CompYear;
  Integer acccol,debcol,textcol,stp,rwcnt;
  record AccVc Accr;
  row TRVc TR2rw;
  Boolean lightFlag;
  
  res = -1;
  if (rownr<0) then begin
    goto LTRDEnterSpec;
  end;
  BlockLoad(CompYear);
  res = -1;
  rwcnt = MatRowCnt(TRp);
//  if (TrDNewEF!=0) then begin
//    res = TrDNewEF;
//    goto LTRDEnterSpec;
//  end;
//  if (oldf>=sf) then begin
    MatRowGet(TRp,rownr,TRrw);
    stp = 1;
    if (rownr!=-1) then begin
      stp = TRrw.stp;
    end;
    if (stp==0) then begin
      switch (fieldname) begin
        case "AccNumber":
          if (blank(TRrw.AccNumber)) then begin
             if (rwcnt>=2) then begin
               if (wnst==1) then begin
                 whattodoafter = 1;
                 gotofieldname = "TransDate";
                 gotorownr = -1;
                 res = 0;
               end else begin
                 whattodoafter = 2;
               end;
             end;
          end;
      end;
    end;
    if (stp==1) then begin
      switch (fieldname) begin
        case "Typ":
          if (TRrw.Typ==0) then begin 
            res = acccol; 
            gotofieldname = "AccNumber";
            gotorownr = rownr;
          end;
        case "SerNr":
          if (nonblank(TRrw.CompCode)) then begin
            if (blank(TRrw.AccNumber)) then begin
              res = acccol;
            end else begin
              if ((blank(TRrw.DebVal)) and
                  (nonblank(TRrw.CredVal))) then begin
                res = debcol + 1;
              end else begin
                res = debcol;
              end;
            end;
          end;
          gotofieldname = "DueDate";
          if (TRrw.Typ==1) then begin
            gotofieldname = "CredVal";
          end;
          if (TRrw.Typ==2) then begin
            gotofieldname = "DebVal";
          end;
          gotorownr = rownr;
        case "AccNumber":
            if (blank(TRrw.AccNumber)) then begin
               if (rwcnt>2) then begin
                 if (wnst==1) then begin
                   whattodoafter = 1;
                   gotofieldname = "TransDate";
                   gotorownr = -1;
                   res = 0;
                 end else begin
                   whattodoafter = 2;
                 end;
               end;
            end else begin
              if ((blank(TRrw.DebVal)) and (nonblank(TRrw.CredVal))) then begin
                gotorownr = rownr;
                gotofieldname = "CredVal";
              end else begin
                gotorownr = rownr;
                gotofieldname = "DebVal";
              end;
              if (CompYear.trSkipCom==0) then begin 
                gotorownr = rownr;
                gotofieldname = "Comment";
              end;
              if ((ProgramType==typFirstOffice) or 
                  (ProgramType==typFirstOfficeSmall) or IsBooks) then begin
                lightFlag = true;
              end;  
              if (lightFlag==false) then begin
                if (CompYear.trSkipObj==0) then begin
                  gotorownr = rownr;
                  gotofieldname = "Objects";
                end;
              end;
// This code works better than the one below..
              Accr.AccNumber = TRrw.AccNumber;
              if (ReadFirstMain(Accr,1,true)) then begin end;
              if (blank(Accr.AutCode)) then begin
                if ((MatRowCnt(TRp)-1)>rownr) then begin
                  gotorownr = MatRowCnt(TRp);
                  gotofieldname = "AccNumber";
                end;
              end;
/*
              if (rownr>0) then begin
                MatRowGet(TRp,rownr-1,TR2rw);
                Accr.AccNumber = TR2rw.AccNumber;
                if (ReadFirstMain(Accr,1,true)) then begin end;
                if (nonblank(Accr.AutCode)) then begin
                  if ((MatRowCnt(TRp)-1)>rownr) then begin
                    gotorownr = MatRowCnt(TRp);
                    gotofieldname = "AccNumber";
                  end;
                end;
              end;
*/
              res = 0;
            end;
        case "Objects":
            if ((blank(TRrw.DebVal)) and
                (nonblank(TRrw.CredVal))) then begin
              gotorownr = rownr;
              gotofieldname = "CredVal";
            end else begin
              gotorownr = rownr;
              gotofieldname = "DebVal";
            end;
            if (CompYear.trSkipCom==0) then begin 
              gotorownr = rownr;
              gotofieldname = "Comment";
            end;
            res = 0;
        case "DebVal":
            if (nonblank(TRrw.DebVal)) then begin
              gotorownr = rownr+1;
              if (TRrw.Typ!=0) then begin
                gotofieldname = "Typ";
              end else begin
                gotofieldname = "AccNumber";
              end;
              res = 0;
            end;
        case "CredVal":
            if ((blank(TRrw.DebVal)) and
                (blank(TRrw.CredVal))) then begin
              TRDDefault(TRp,rownr,fieldname);
/*              
ašready calulated in TRDDefault 
              MatRowGet(TRp,rownr,TRrw);
              if (TRrw.CredVal!=0) then begin
                TRVc_PasteCredVal(TRp,rownr);
              end else begin
                TRVc_PasteDebVal(TRp,rownr);
              end;
*/              
            end;
            res = 0;
            gotorownr = rownr+1;
            if (TRrw.Typ!=0) then begin
              gotofieldname = "Typ";
            end else begin
              gotofieldname = "AccNumber";
            end;
//            res = sf+((row+1)*nfr);
        case "DebVal2":
            if (nonblank(TRrw.DebVal2)) then begin
//              res = sf+((row+1)*nfr);
            end;
        case "CredVal2":
            if ((blank(TRrw.DebVal2)) and
                (blank(TRrw.CredVal2))) then begin
              TRDDefault(TRp,rownr,fieldname);
            end;
//            res = sf+((row+1)*nfr);
        end;
      end;
//  end;
LTRDEnterSpec:;
// The header is moving according to the Window Order, no need for code
  TRDEnterSpec = res;
  RETURN;
END;



global
updating procedure DropUserDefRepResDClassOnUserDefRepResDClass(Integer frwn,Integer town)
begin
  record UserDefRepVc frUDRr;
  record UserDefRepVc toUDRr;
  record UserDefRepLinesVc UDRLr;
  Integer r;
  Boolean testf;
  Integer oldcomp;
  Integer i;
  
  if ((GetWindowFileName(frwn)=="UserDefRepVc") and (GetWindowFileName(town)=="UserDefRepVc")) then begin
    if (IsRecordLocked(UDRLr)==false) then begin
      if (UserCanAction("XXGRToXXGR",true)) then begin
        i = 1;
        while (GetRecordFromBrowse(UDRLr,frwn,i)) begin
          GetWindowRecord(frwn,frUDRr);
          GetWindowRecord(town,toUDRr);
          UDRLr.shortname = toUDRr.shortname;
          oldcomp = CurrentCompany;  
          if (WindowCompanyNr(town)!=oldcomp) then begin
            SetCompany(WindowCompanyNr(town),false);
          end;          
          RecordStore(UDRLr,false);
          ResetCompany(oldcomp);
          UpdateBrowses("UserDefRepLinesVc");
          i = i + 1;
        end;    
      end else begin
        MessageBox(1274,StringFromStringSet(3,"XXGRToXXGR"));
      end;
    end;
  end;  
  return;
end;

global
updating procedure DropUserDefRepBalDClassOnUserDefRepBalDClass(Integer frwn,Integer town)
begin
  record UserDefRepVc frUDRr;
  record UserDefRepVc toUDRr;
  record UserDefRepLinesVc UDRLr;
  Integer r;
  Boolean testf;
  Integer oldcomp;
  Integer i;
  
  if ((GetWindowFileName(frwn)=="UserDefRepVc") and (GetWindowFileName(town)=="UserDefRepVc")) then begin
    if (IsRecordLocked(UDRLr)==false) then begin
      if (UserCanAction("XXGRToXXGR",true)) then begin
        i = 1;
        while (GetRecordFromBrowse(UDRLr,frwn,i)) begin
          GetWindowRecord(frwn,frUDRr);
          GetWindowRecord(town,toUDRr);
          UDRLr.shortname = toUDRr.shortname;
          oldcomp = CurrentCompany;  
          if (WindowCompanyNr(town)!=oldcomp) then begin
            SetCompany(WindowCompanyNr(town),false);
          end;          
          RecordStore(UDRLr,false);
          ResetCompany(oldcomp);
          UpdateBrowses("UserDefRepLinesVc");
          i = i + 1;
        end;    
      end else begin
        MessageBox(1274,StringFromStringSet(3,"XXGRToXXGR"));
      end;
    end;
  end;  
  return;
end;

global
updating procedure DropUserDefRepResDClassOnUserDefRepBalDClass(Integer frwn,Integer town)
begin
  record UserDefRepVc frUDRr;
  record UserDefRepVc toUDRr;
  record UserDefRepLinesVc UDRLr;
  Integer r;
  Boolean testf;
  Integer oldcomp;
  Integer i;
  
  if ((GetWindowFileName(frwn)=="UserDefRepVc") and (GetWindowFileName(town)=="UserDefRepVc")) then begin
    if (IsRecordLocked(UDRLr)==false) then begin
      if (UserCanAction("XXGRToXXGR",true)) then begin
        i = 1;
        while (GetRecordFromBrowse(UDRLr,frwn,i)) begin
          GetWindowRecord(frwn,frUDRr);
          GetWindowRecord(town,toUDRr);
          UDRLr.shortname = toUDRr.shortname;
          
          oldcomp = CurrentCompany;  
          if (WindowCompanyNr(town)!=oldcomp) then begin
            SetCompany(WindowCompanyNr(town),false);
          end;          
          RecordStore(UDRLr,false);
          ResetCompany(oldcomp);
          UpdateBrowses("UserDefRepLinesVc");
          i = i + 1;
        end;    
      end else begin
        MessageBox(1274,StringFromStringSet(3,"XXGRToXXGR"));
      end;
    end;
  end;  
  return;
end;

global
updating procedure DropUserDefRepBalDClassOnUserDefRepResDClass(Integer frwn,Integer town)
begin
  record UserDefRepVc frUDRr;
  record UserDefRepVc toUDRr;
  record UserDefRepLinesVc UDRLr;
  Integer r;
  Boolean testf;
  Integer oldcomp;
  Integer i;
  
  if ((GetWindowFileName(frwn)=="UserDefRepVc") and (GetWindowFileName(town)=="UserDefRepVc")) then begin
    if (IsRecordLocked(UDRLr)==false) then begin
      if (UserCanAction("XXGRToXXGR",true)) then begin
        i = 1;
        while (GetRecordFromBrowse(UDRLr,frwn,i)) begin
          GetWindowRecord(frwn,frUDRr);
          GetWindowRecord(town,toUDRr);
          UDRLr.shortname = toUDRr.shortname;
          oldcomp = CurrentCompany;  
          if (WindowCompanyNr(town)!=oldcomp) then begin
            SetCompany(WindowCompanyNr(town),false);
          end;          
          RecordStore(UDRLr,false);
          ResetCompany(oldcomp);
          UpdateBrowses("UserDefRepLinesVc");
          i = i + 1;
        end;    
      end else begin
        MessageBox(1274,StringFromStringSet(3,"XXGRToXXGR"));
      end;
    end;
  end;  
  return;
end;

global
updating procedure DropUserDefRepKeyDClassOnUserDefRepKeyDClass(Integer frwn,Integer town)
begin
  record UserDefRepVc frUDRr;
  record UserDefRepVc toUDRr;
  record UserDefRepLinesVc UDRLr;
  Integer r;
  Boolean testf;
  Integer oldcomp;
  Integer i;
  
  if ((GetWindowFileName(frwn)=="UserDefRepVc") and (GetWindowFileName(town)=="UserDefRepVc")) then begin
    if (IsRecordLocked(UDRLr)==false) then begin
      if (UserCanAction("XXGRToXXGR",true)) then begin
        i = 1;
        while (GetRecordFromBrowse(UDRLr,frwn,i)) begin
          GetWindowRecord(frwn,frUDRr);
          GetWindowRecord(town,toUDRr);
          UDRLr.shortname = toUDRr.shortname;
          oldcomp = CurrentCompany;  
          if (WindowCompanyNr(town)!=oldcomp) then begin
            SetCompany(WindowCompanyNr(town),false);
          end;          
          RecordStore(UDRLr,false);
          ResetCompany(oldcomp);
          UpdateBrowses("UserDefRepLinesVc");
          i = i + 1;
        end;    
      end else begin
        MessageBox(1274,StringFromStringSet(3,"XXGRToXXGR"));
      end;
    end;
  end;  
  return;
end;

global
procedure AddAccountQTDsm()
begin
  record AccVc Accr;
  Integer nwn;
  
  RecordNew(Accr);
  nwn = OpenWindow("AccDClass",0,0,"","",Accr);
  return;
end;

global
procedure SwitchToObjContactCUSClass()
begin
  Integer wn,mwn,wn2;
  record CUVc CUr;
  
  wn = CurWindow;
  mwn = MotherWindow(wn);
  CloseWindow(wn);      
  wn2 = OpenWindow("ObjContactCUSClass",0,mwn,"","",CUr);
  return;
end;

global
procedure SwitchToObjSClass()
begin
  Integer wn,mwn,wn2;
  record ObjVc Objr;
  
  wn = CurWindow;
  mwn = MotherWindow(wn);
  CloseWindow(wn);      
  wn2 = OpenWindow("ObjSClass",0,mwn,"","",Objr);
  return;
end;
