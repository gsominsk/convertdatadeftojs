external function Integer OpenArtStat(Integer,record RcVc,Boolean);
external function roundmode DefaultRoundMode();
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external procedure SendArtStat(string,string,string,val,val,val,Date,Integer);
external procedure FindSalesExVat(record TaxMatrixVc,string,val,Integer,Integer,var val);
external procedure CalcProc(val,val,var val);
external procedure CalcSum(val,val,val,val,var val,Integer);
external procedure AddVATBase(var record SMVc,string,val,val,Integer,Integer,Integer);
external procedure SetupVATBase(var record SMVc,var Integer);
external procedure CalcVATBaseVAT(record SMVc,Integer,Integer,Integer,var val,var val);
external procedure GetCurncyRoundoff(string,string,string,var roundmode,var roundmode,var roundmode);
external function Boolean GetFullCurncyRateDate(var string,Date,var val,var val,var val,var val,var val,var Date);
remote function Boolean GetItemPriceDiscount3(string,val,var record INVc,string,val,val,val,val,val,string,string,string,string,
                                                var val,var string,var val,var string,var val,var string,Integer,var Boolean,Date,Time,
                                                string,Boolean,var Boolean,string,var string,var val,string,string,var string);

global
procedure GetORProgCurncy(var record ORProgVc ORProgr)
begin
  string 20 crncycode;
  Val to1,to2,fr,br1,br2;
  Date ed;
  
  crncycode = ORProgr.CurncyCode;
  if (GetFullCurncyRateDate(crncycode,ORProgr.OrdDate,fr,to1,to2,br1,br2,ed)) then begin end;
  ORProgr.CurncyCode = crncycode;
  ORProgr.FrRate = fr;
  ORProgr.ToRateB1 = to1;
  ORProgr.ToRateB2 = to2;
  ORProgr.BaseRate1 = br1;
  ORProgr.BaseRate2 = br2;
  return;
end;

global
function Boolean ORProgDClassVECodeEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  record CUVc VEr;
  record ORProgVc ORProgr;

  if (changedf!=0) then begin
    DeselectWindow(wn,false);
    GetWindowRecord(wn,ORProgr);
    VEr.Code = ORProgr.VECode;
    if (ReadFirstMain(VEr,1,true)) then begin
      ORProgr.VEName = VEr.Name;
      ORProgr.CurncyCode = VEr.VECurncyCode;
      GetORProgCurncy(ORProgr);
      PutWindowRecord(wn,ORProgr);
    end;
  end;
  ORProgDClassVECodeEFAfter = true;
  return;
end;

global
function Boolean ORProgDClassOrdDateEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  record ORProgVc ORProgr;

  if (changedf!=0) then begin
    DeselectWindow(wn,false);
    GetWindowRecord(wn,ORProgr);
    GetORProgCurncy(ORProgr);
    PutWindowRecord(wn,ORProgr);
  end;
  ORProgDClassOrdDateEFAfter = true;
  return;
end;

global
function Boolean ORProgDClassCurncyCodeEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  record ORProgVc ORProgr;

  if (changedf!=0) then begin
    DeselectWindow(wn,false);
    GetWindowRecord(wn,ORProgr);
    GetORProgCurncy(ORProgr);
    PutWindowRecord(wn,ORProgr);
  end;
  ORProgDClassCurncyCodeEFAfter = true;
  return;
end;

global
procedure ORProgSumup(var record ORProgVc ORProgp)
BEGIN
  row ORProgVc ORProgrw;
  val s,ms,ms2,temp,s2,taxsum;
  Integer i,rwcnt;
  roundmode roundlines,rndtotal,rndvat;
  record SMVc SMr;
  Integer vatcnt;  

  SetupVATBase(SMr,vatcnt);
  rwcnt = MatRowCnt(ORProgp);
  for (i = 0 ; i<rwcnt ;i=i+1) begin
    MatRowGet(ORProgp,i,ORProgrw);
    temp = MulRateToBase1(ORProgp.CurncyCode,ORProgrw.Sum,ORProgp.FrRate,ORProgp.ToRateB1,ORProgp.ToRateB2,ORProgp.BaseRate1,ORProgp.BaseRate2,DefaultCurRoundOff);
    s = s + ORProgrw.Sum;
    s2 = s2 + temp;
    AddVATBase(SMr,ORProgrw.VATCode,ORProgrw.Sum,blankval,vatcnt,ORProgp.InclVAT,0);
  end;
  CalcVATBaseVAT(SMr,ORProgp.InclVAT,0,vatcnt,ms,taxsum);
  GetCurncyRoundoff(ORProgp.CurncyCode,"","ORProgVc",rndtotal,roundlines,rndvat);
  ms = Round(ms,rndvat);
  if (ORProgp.InclVAT!=0) then begin
    ms2 = s;
  end else begin
    ms2 = s + ms;
  end;  
  if (ORProgp.InclVAT==0) then begin
    ms2 = ms2 + taxsum;
  end;
  ms2 = Round(ms2,rndtotal);
  ORProgp.Sum1 = s;
  ORProgp.Sum3 = ms;
  ORProgp.Sum4 = ms2;
/*
  if (nonblank(ORProgp.CurncyCode)) then begin
    ORProgp.BaseSum4 = MulRateToBase1(ORProgp.CurncyCode,ORProgp.Sum4,ORProgp.FrRate,ORProgp.ToRateB1,ORProgp.ToRateB2,ORProgp.BaseRate1,ORProgp.BaseRate2,DefaultCurRoundOff);    
  end;  
*/
  RETURN;
END;

procedure ChangeORProgRowSum(var record ORProgVc ORProgr,Integer rownr)
begin
  row ORProgVc ORProgrw;
  val t,s,rowinbase,tproc;
  record GeneralOptionBlock GenOptRec;
  record TaxMatrixVc TMr;

  BlockLoad(GenOptRec);
  MatRowGet(ORProgr,rownr,ORProgrw);
  t = ORProgrw.Quant*ORProgrw.BasePrice;
  if (ORProgrw.PriceFactor!=0) then begin
    t = t/ORProgrw.PriceFactor;
  end;
  CalcSum(ORProgrw.Quant,ORProgrw.Price,ORProgrw.PriceFactor,0,s,GenOptRec.UseDiscount);
  ORProgrw.Sum = s;
  s = MulRateToBase1(ORProgr.CurncyCode,ORProgrw.Sum,ORProgr.FrRate,ORProgr.ToRateB1,ORProgr.ToRateB2,ORProgr.BaseRate1,ORProgr.BaseRate2,DefaultCurRoundOff);  
  FindSalesExVat(TMr,ORProgrw.VATCode,s,ORProgr.InclVAT,0,rowinbase);
  ORProgrw.rowGP = rowinbase - t;
  CalcProc(rowinbase,ORProgrw.rowGP,tproc);
  MatRowPut(ORProgr,rownr,ORProgrw);
  SendArtStat(ORProgrw.ArtCode,ORProgr.Location,"",ORProgrw.rowGP,tproc,t,ORProgr.OrdDate,0);
  return; 
end;
      
procedure GetSupplierCost(string vecode,string incode,var val cost)
begin
  record PIVc PIr;
  
  PIr.VECode = vecode;
  PIr.Location = "";
  PIr.ItemCode = incode;
  if (ReadFirstMain(PIr,2,true)) then begin
    cost = PIr.PurPrice;
  end;
  return;
end;

global
function Boolean ORProgDClassArtCodeEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  record ORProgVc ORProgr;
  row ORProgVc ORProgrw;
  record INVc INr;
  Integer rwcnt;
  val price,reb,cost,tax2prc;
  string 100 curitemname;
  string 20 salesacc,vatcode,tax2code,taxtemplatecode;
  Boolean calcprice,dummyf;
  Time blankt;

  if (changedf!=0) then begin
    DeselectWindow(wn,false);
    GetWindowRecord(wn,ORProgr);
    rwcnt = MatRowCnt(ORProgr);
    if (rownr<rwcnt) then begin
      MatRowGet(ORProgr,rownr,ORProgrw);
      if (GetItemPriceDiscount3(ORProgrw.ArtCode,ORProgrw.Quant,INr,ORProgr.CurncyCode,
                      ORProgr.FrRate,ORProgr.ToRateB1,ORProgr.ToRateB2,ORProgr.BaseRate1,ORProgr.BaseRate2,
                      ORProgr.LangCode,"","","",
                      price,curitemname,reb,vatcode,cost,salesacc,
                      0,calcprice,ORProgr.OrdDate,blankt,"",true,dummyf,"",tax2code,tax2prc,"","",taxtemplatecode)) then begin
        if (price==0) then begin price = BlankVal; end;
        if (cost==0) then begin cost = BlankVal; end;
        GetSupplierCost(ORProgr.VECode,ORProgrw.ArtCode,cost);
        ORProgrw.PriceFactor = INr.PriceFactor;
        ORProgrw.Price = price;
        ORProgrw.BasePrice = cost;
        ORProgrw.Spec = curitemname;
        ORProgrw.VATCode = vatcode;
        MatRowPut(ORProgr,rownr,ORProgrw);
        ChangeORProgRowSum(ORProgr,rownr);
      end;
    end;
    ORProgSumup(ORProgr);
    PutWindowRecord(wn,ORProgr);
  end;
  ORProgDClassArtCodeEFAfter = true;
  return;
end;

global
function Boolean ORProgDClassQuantEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  Boolean res;
  res = ORProgDClassArtCodeEFAfter(wn,fn,rownr,changedf);
  ORProgDClassQuantEFAfter = true;
  return;
end;

global
function Boolean ORProgDClassPriceEFAfter(Integer wn,Integer fn,Integer rownr,Integer changedf)
begin
  Boolean res;
  record ORProgVc ORProgr;
 
  GetWindowRecord(wn,ORProgr);
  ChangeORProgRowSum(ORProgr,rownr);
  ORProgSumup(ORProgr);
  PutWindowRecord(wn,ORProgr);
  ORProgDClassPriceEFAfter = true;
  return;
end;

global
function Boolean ORProgDClassAfterEditField(Integer wn,string fieldname,Integer fn, Integer rownr,Integer changed)
BEGIN
  Boolean res;

  switch (fieldname) begin
    case "VECode": res = ORProgDClassVECodeEFAfter(wn,fn,rownr,changed);
    case "OrdDate": res = ORProgDClassOrdDateEFAfter(wn,fn,rownr,changed);
    case "CurncyCode": res = ORProgDClassCurncyCodeEFAfter(wn,fn,rownr,changed);
    case "ArtCode": res = ORProgDClassArtCodeEFAfter(wn,fn,rownr,changed);
    case "Quant": res = ORProgDClassQuantEFAfter(wn,fn,rownr,changed);
  end;
  ORProgDClassAfterEditField = res;
  RETURN;
END;

global
function Boolean ORProgDClassSwitchRow(Integer wn,Integer rownr)
begin        
  record ORProgVc ORProgr;  
  row ORProgVc ORProgrw; 
  Integer rwcnt;
  Boolean res;
  val t,tproc,unitprdisc,s,rowsum;
  record TaxMatrixVc TMr;
  
  res = true;
  GetWindowRecord(wn,ORProgr);
  rwcnt = MatRowCnt(ORProgr);  
  if ((rownr<rwcnt) and (rownr>=0)) then begin
    MatRowGet(ORProgr,rownr,ORProgrw);
//    if (ORProgrw.stp==1) then begin
      t = ORProgrw.rowGP;
      s = MulRateToBase1(ORProgr.CurncyCode,ORProgrw.Sum,ORProgr.FrRate,ORProgr.ToRateB1,ORProgr.ToRateB2,ORProgr.BaseRate1,ORProgr.BaseRate2,DefaultCurRoundOff);
      FindSalesExVat(TMr,ORProgrw.VATCode,s,ORProgr.InclVAT,0,rowsum);
      CalcProc(rowsum,t,tproc);
      unitprdisc = ORProgrw.Sum/ORProgrw.Quant;
      unitprdisc = Round(unitprdisc,DefaultRoundMode);
///    end;
    SendArtStat(ORProgrw.ArtCode,ORProgr.Location,"",ORProgrw.rowGP,tproc,unitprdisc,ORProgr.OrdDate,0);
  end;
  ORProgDClassSwitchRow = res;  
  return;
end;

global
procedure ItemStatusORProgDsm()
BEGIN
  record RcVc RepSpec;
  Boolean testf;
  Integer nwn,wn;

  wn = CurWindow;
  nwn = OpenArtStat(wn,RepSpec,false);
  testf = ORProgDClassSwitchRow(wn,WindowActiveRow(wn));
  RETURN;
END;

